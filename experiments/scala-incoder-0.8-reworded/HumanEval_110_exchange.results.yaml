language: scala
name: HumanEval_110_exchange
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Solution goes here\n        val set1 = lst1.toSet\n        val set2 = lst2.toSet\n\
    \        if (set1.size < set2.size) {\n            if (set1.size + set2.size >\
    \ 1) {\n                if (set2.contains(\"even\") && set1.contains(\"even\"\
    )) {\n                    return \"YES\"\n                }\n            }\n \
    \           else {\n                if (set1.contains(\"even\") && set2.contains(\"\
    even\")) {\n                    return \"YES\"\n                }\n          \
    \  }\n        }\n        else {\n            if (set2.size + set1.size > 1) {\n\
    \                if (set2.contains(\"even\") && set1.contains(\"even\")) {\n \
    \                   return \"YES\"\n                }\n            }\n       \
    \     else {\n                if (set1.contains(\"even\") && set2.contains(\"\
    even\")) {\n                    return \"YES\"\n                }\n          \
    \  }\n        }\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp89aaq4xh.scala:23:34\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m\
    \ (set2.contains(\e[31m\"even\"\e[0m) && set1.contains(\e[31m\"even\"\e[0m)) {\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Found:    (\e[32m\"even\"\e[0m : String)\n\
    \e[31m   |\e[0m                                  Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp89aaq4xh.scala:23:59 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (set2.contains(\e[31m\"\
    even\"\e[0m) && set1.contains(\e[31m\"even\"\e[0m)) {\n\e[31m\e[31m   |\e[0m \
    \                                                          ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                             Found:    (\e[32m\"even\"\
    \e[0m : String)\n\e[31m   |\e[0m                                             Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp89aaq4xh.scala:28:34\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m\
    \ (set1.contains(\e[31m\"even\"\e[0m) && set2.contains(\e[31m\"even\"\e[0m)) {\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Found:    (\e[32m\"even\"\e[0m : String)\n\
    \e[31m   |\e[0m                                  Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp89aaq4xh.scala:28:59 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (set1.contains(\e[31m\"\
    even\"\e[0m) && set2.contains(\e[31m\"even\"\e[0m)) {\n\e[31m\e[31m   |\e[0m \
    \                                                          ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                             Found:    (\e[32m\"even\"\
    \e[0m : String)\n\e[31m   |\e[0m                                             Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659979801
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1.isEmpty) {\n            if (lst2.isEmpty) {\n                return\
    \ \"NO\"\n            }\n            return \"YES\"\n        }\n        if (lst2.isEmpty)\
    \ {\n            return \"YES\"\n        }\n        if (lst1.head < lst2.head)\
    \ {\n            return \"YES\"\n        }\n        // if (lst1.head > lst2.head)\
    \ {\n        //    return \"NO\"\n        // }\n        if (lst1.head == lst2.head\
    \ && lst1.head % 2 == 0) {\n            return \"YES\"\n        }\n        //\
    \ if (lst1.head != lst2.head && lst1.head % 2 == 0) {\n        //    return \"\
    NO\"\n        // }\n        var exchange = false\n        lst1.foreach(x => {\n\
    \            if (lst2.exists(y => x == y))\n                exchange = true\n\
    \        })\n        if (exchange) {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0xunuo0x.scala:51)\n\tat Problem.main(tmp0xunuo0x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) lst2\n        else {\n            val evens = lst1.filter(x\
    \ => x % 2 == 0l)\n            val evensB = evens.toList\n            val odds\
    \ = lst1.filter(x => x % 2 != 0l)\n            val oddsB = odds.toList\n     \
    \       evensB.map(x => {\n                val tmp = lst2\n                lst2\
    \ = lst2.filterNot(x => x == x)\n                lst2 += x\n                lst2\
    \ += tmp\n            })\n            oddsB.map(x => {\n                val tmp\
    \ = lst2\n                lst2 = lst2.filterNot(x => x == x)\n               \
    \ lst2 += x\n                lst2 += tmp\n            })\n            val evensA\
    \ = evens.toList\n            val oddsA = lst1.filter(x => x % 2 == 0l)\n    \
    \        val evensList = evensA.zipWithIndex.filter(x => x._2 == 0).map {\n  \
    \              x => x._1\n            }\n            val oddsList = oddsA.zipWithIndex.filter(x\
    \ => x._2 == 1).map {\n                x => x._1\n            }\n            if(evensList.forall(x\
    \ => x == x)) \"YES\"\n            else exchange(evensList, oddsList)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpinty2_1m.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(lst1.isEmpty)\
    \ lst2\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    (lst2 : List[Long])\n\e[31m   |\e[0m   \
    \                      Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpinty2_1m.scala:26:21 -----------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                lst2 = lst2.filterNot(\e[36mx\e[0m => x ==\
    \ x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val lst2\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpinty2_1m.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                lst2 += x\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member of\
    \ List[Long] - did you mean lst2.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpinty2_1m.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                lst2 += tmp\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ += is not a member of List[Long] - did you mean lst2.!=?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpinty2_1m.scala:32:21 -----------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                lst2 = lst2.filterNot(\e[36mx\e[0m => x ==\
    \ x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val lst2\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpinty2_1m.scala:33:21 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                lst2 += x\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member of\
    \ List[Long] - did you mean lst2.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpint"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var list1 = lst1\n        var list2 = lst2\n        var i = 0\n        var j\
    \ = 0\n        val lst3= List[Long]()\n        var flag = if (list1.length ==\
    \ 0) list2 else list1\n        while(flag != List())\n        {\n            if(flag(j)\
    \ % 2 == 1)\n            {\n                list1 =  list1.drop(j)\n         \
    \   }\n            else\n            {\n                list2 =  list2.drop(j)\n\
    \            }\n            j+=1\n        }\n        if (list1 != List() || list2\
    \ != List())\n        {\n            lst3 =  list1.intersect(list2)\n        \
    \    if (lst3 != List())\n            {\n                val lst4 = lst3.toList.sortBy(_\
    \ % 2)\n                if (lst4.size == list1.length)\n                {\n  \
    \                  return \"YES\"\n                }\n                else\n \
    \               {\n                    return \"NO\"\n                }\n    \
    \        }\n        }\n        else\n        {\n            return \"NO\"\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5ery8fxm.scala:38:17 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            lst3 =  list1.intersect(list2)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Reassignment to val lst3\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5ery8fxm.scala:39:12 --------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m            \e[33mif\e[0m (lst3 != List())\n\e[31m\e[31m \
    \  |\e[0m            ^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m\
    \   |\e[0m            Required: String\n\e[31m   |\e[0m            Maybe you are\
    \ missing an else part for the conditional?\n\e[31m40 |\e[0m            {\n\e\
    [31m41 |\e[0m                \e[33mval\e[0m \e[36mlst4\e[0m = lst3.toList.sortBy(_\
    \ % \e[31m2\e[0m)\n\e[31m42 |\e[0m                \e[33mif\e[0m (lst4.size ==\
    \ list1.length)\n\e[31m43 |\e[0m                {\n\e[31m44 |\e[0m           \
    \         \e[33mreturn\e[0m \e[31m\"YES\"\e[0m\n\e[31m45 |\e[0m              \
    \  }\n\e[31m46 |\e[0m                \e[33melse\e[0m\n\e[31m47 |\e[0m        \
    \        {\n\e[31m48 |\e[0m                    \e[33mreturn\e[0m \e[31m\"NO\"\e\
    [0m\n\e[31m49 |\e[0m                }\n\e[31m50 |\e[0m            }\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // O(n2) code\n        // (use two nested loops over the two lists)\n      \
    \  // sort the two lists\n        val lst1_sorted = lst1.toList.sort\n       \
    \ val lst2_sorted = lst2.toList.sort\n        // loop over lst2\n        for(x\
    \ <- lst2_sorted) {\n            // loop over lst1\n            for(y <- lst1_sorted)\
    \ {\n                // if the lists are equal, return\n                if(lst1_sorted\
    \ == lst2_sorted) {\n                    return \"YES\"\n                }\n \
    \               // if the lists differ in one element and y, return\n        \
    \        else if(lst1_sorted(x) != lst2_sorted(y)) {\n                    return\
    \ \"NO\"\n                }\n            }\n        }\n        \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1ev8oja8.scala:21:38 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlst1_sorted\e[0m = lst1.toList.sort\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue sort is not a member of List[Long] - did you mean List[Long].sortBy?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1ev8oja8.scala:22:38 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlst2_sorted\e[0m = lst2.toList.sort\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue sort is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var result : Boolean = false\n        var list1_count = 0\n        var list2_count\
    \ = 0\n        for(i <- 0 to lst1.length - 1) {\n            if(lst1(i % 2) !=\
    \ 0) {\n                result = (lst1(i % 2) != lst2(i % 2))\n            } else\
    \ {\n                result = (lst1(i % 2) == lst2(i % 2))\n            }\n  \
    \          list1_count = list1_count + (result ? 1 : 0)\n        }\n        list2_count\
    \ = 0\n        for(i <- 0 to lst2.length - 1) {\n            if(lst2(i % 2) !=\
    \ 0) {\n                result = (lst1(i % 2) != lst2(i % 2))\n            } else\
    \ {\n                result = (lst1(i % 2) == lst2(i % 2))\n            }\n  \
    \          list2_count = list2_count + (result ? 1 : 0)\n        }\n        if((list1_count\
    \ == lst1.length) && (list2_count == lst2.length)) {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0uzmtan.scala:27:48 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            list1_count = list1_count + (result ? \e\
    [31m1\e[0m : \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \     value ? is not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpf0uzmtan.scala:36:48 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m            list2_count = list2_count + (result ? \e[31m1\e[0m : \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value ? is not a member\
    \ of Boolean\n2 errors found\n"
  stdout: ''
  timestamp: 1659979799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val arr1 = lst1.toArray\n        val arr2 = lst2.toArray\n\
    \        if(arr1.length == 0 || arr2.length == 0)\n            return \"NO\"\n\
    \        val ls = arr2.toList.sortWith(_ > _)\n        var j = 0\n        var\
    \ i = 0\n        var evenArr = 0\n        var evenLst2 = 0\n        var evenLst1\
    \ = 0\n        while(i < arr1.length) {\n            if(arr1(i) % 2 == 0) {\n\
    \                evenArr += arr1(i)\n                evenLst2 += arr2(j)\n   \
    \             j += 1\n            }\n            i += 1\n        }\n        i\
    \ = arr2.length\n        while(i < arr2.length) {\n            if(arr2(i) % 2\
    \ == 0) {\n                evenArr += arr2(i)\n                evenLst1 += arr1(i)\n\
    \                i += 1\n            }\n            i += 1\n        }\n      \
    \  if (evenArr % evenLst1 == 0 && evenArr % evenLst2 == 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwj8hflz2.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                evenArr += arr1(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpwj8hflz2.scala:32:25 ------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                evenLst2 += arr2(j)\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwj8hflz2.scala:40:24\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                evenArr +=\
    \ arr2(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value += is not a member of Int - did you mean Int.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpwj8hflz2.scala:41:25 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                evenLst1 += arr1(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is\
    \ not a member of Int - did you mean Int.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // your code here\n        var lst3 = lst1.toList\n        var lst4 = lst2.toList\n\
    \        var exchanged = false\n        var even = false\n        var first =\
    \ true\n        var second=true\n        while(lst3.length>0 && !lst4.isEmpty){\n\
    \            if(first){\n                if(lst3.head.isEven){\n             \
    \       lst3 = lst3.tail\n                    lst4 = lst4.tail\n             \
    \       exchanged = true\n                }\n                else{\n         \
    \           lst3 = lst3.tail\n                    lst4 = lst4.tail\n         \
    \           even = false\n                }\n                first = false\n \
    \           }\n            if(lst4.head.isEven){\n                lst4 = lst4.tail\n\
    \                even = true\n            }\n            else if(even){\n    \
    \            lst4 = lst4.tail\n                even = false\n            }\n \
    \       }\n        if(exchanged || even ){\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpslszkyg_.scala:27:29 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e[0m(lst3.head.isEven){\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                  value isEven is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpslszkyg_.scala:39:25 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m            \e[33mif\e[0m(lst4.head.isEven){\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \ value isEven is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659979799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst1 = lst1.toSet\n        var lst2 = lst2.toSet\n        if (lst1 == lst2)\
    \ {\n            return \"NO\"\n        }\n        if (lst1.isEmpty)\n       \
    \     return \"NO\"\n        if (lst2.isEmpty)\n            return \"NO\"\n  \
    \      val result = lst1 & lst2\n        result.forall(x => x % 2 == 0) match\
    \ {\n            case false => \"NO\"\n            case true => \"YES\"\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_y5lvx6x.scala:18:19 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mlst1\e[0m = lst1.toSet\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvariable\e[0m \e[35mlst1\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_y5lvx6x.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mlst2\e[0m = lst2.toSet\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvariable\e[0m \e[35mlst2\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) lst2.toList.mkString(\",\")\n        else if(lst2.isEmpty)\
    \ lst1.toList.mkString(\",\")\n        else if(lst1.tail.isEmpty) exchange(lst1.tail,\
    \ lst2.tail).mkString(\",\")\n        else exchange(lst1.tail, lst2.tail).mkString(\"\
    ,\") + \",\" + exchange(lst1, lst2.tail).mkString(\",\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv2isrvce.scala:24)\n\tat Problem.main(tmpv2isrvce.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val length = lst1.length\n        val a = lst1.toIterator\n        val b = lst2.toIterator\n\
    \        var result = \"NO\"\n        if (length == 0 || length == 1) {\n    \
    \        result = \"YES\"\n        } else {\n            val even = a.remove\n\
    \            val odd = b.remove\n            while (a != null && b != null) {\n\
    \                if (even.compareTo(b) < 0)\n                    a.next()\n  \
    \              else if (even.compareTo(b) > 0)\n                    b.next()\n\
    \                else\n                    even.next(odd)\n            }\n   \
    \     }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29in3w0h.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36meven\e[0m = a.remove\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m value\
    \ remove is not a member of Iterator[Long] - did you mean a.reduce?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp29in3w0h.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36modd\e[0m = b.remove\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of Iterator[Long], but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.iterator\
    \ asJava\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // The variable count will hold the number of elements that are even in lst1\n\
    \        val count = 0\n        // The variable l2 will hold the elements that\
    \ we want to exchange in lst1\n        val l2 = lst2.filter{ a => a % 2 == 0 }\n\
    \        // The variable l1 will hold all the odd elements in lst1\n        val\
    \ l1 = lst1.filter{ a => a % 2 != 0 }\n        // The variable c will hold the\
    \ number of elements that will be exchanged\n        val c = l1.size + l2.size\n\
    \        // If l1 is empty, return \"NO\"\n        if (l1.isEmpty) {\n       \
    \     return \"NO\"\n        }\n        // Otherwise, go through each element\
    \ of l2 in order, check whether it is even in lst1\n        for (a2@(a <- l2;\
    \ a <= l2.last) <- l1) {\n            // If it is even in lst1, increment the\
    \ count and move on to the next element in l2\n            if (a % 2 == 0) {\n\
    \                count += 1\n            } else {\n                // Otherwise,\
    \ we do nothing, since if the current element of l2 is not even in lst1, \n  \
    \              // we will still go through all the elements of l2 before we move\
    \ on to the next element in l2\n            }\n        }\n        // If count\
    \ is equal to the number of elements in l1, return \"YES\"\n        if (count\
    \ == l1.size) {\n            return \"YES\"\n        }\n        // Otherwise,\
    \ if count is less than the number of elements in l1, return \"NO\"\n        if\
    \ (count < l1.size) {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9m5f1ks4.scala:31:19 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (a2@(a <- l2; a <= l2.last) <-\
    \ l1) {\n\e[31m\e[31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m    \
    \               ')' expected, but '<-' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp9m5f1ks4.scala:31:38 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mfor\e[0m (a2@(a <- l2; a <= l2.last) <- l1) {\n\e[31m\e\
    [31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m   \
    \                                   '<-' expected, but ')' found\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmp9m5f1ks4.scala:31:40 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (a2@(a <- l2; a <= l2.last) <-\
    \ l1) {\n\e[31m\e[31m   |\e[0m                                        ^^\e[0m\n\
    \e[31m   |\e[0m                                        expression expected but\
    \ \e[31m<-\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9m5f1ks4.scala:31:24\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (a2@(a\
    \ <- l2; a <= l2.last) <- l1) {\n\e[31m\e[31m   |\e[0m                       \
    \ ^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member of Null, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsSca"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        // return \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk52mvgn0.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// return \"NO\"\e[0m\n\e[31m20 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979798
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1 match {\n            case Nil => lst2 match {\n                case Nil\
    \ => \"YES\"\n                case _ => \"NO\"\n            }\n            case\
    \ _  => lst1 match {\n                case x :: xs => lst2 match {\n         \
    \           case Nil => lst1 match {\n                        case x :: xs =>\
    \ lst2 match {\n                            case Nil => \"YES\"\n            \
    \                case x :: xs => \"NO\"\n                        }\n         \
    \               case x :: xs => exchange(xs, lst2)\n                    }\n  \
    \                  case y :: ys => exchange(lst1, ys)\n                }\n   \
    \         }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphtlgoc3x.scala:39)\n\tat Problem.main(tmphtlgoc3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) \"\"\n        else {\n            if(lst2.isEmpty) \"\"\n \
    \           else {\n                if(lst1.head == lst2.head) {\n           \
    \         exchange(lst1.tail, lst2.tail)\n                }\n                else\
    \ {\n                    exchange(lst1, lst2.tail)\n                }\n      \
    \      }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsc3lenh5.scala:32)\n\tat Problem.main(tmpsc3lenh5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val res = lst2.map {\n            case x if x == 0l => \"NO\"\n            case\
    \ x if x % 2 == 0l => \"YES\"\n            case x => \"NO\"\n        }\n     \
    \   res.reduceLeft(\"NO\") {\n            case x if x.equals(\"NO\") => \"NO\"\
    \n            case x if x.equals(\"YES\") => \"YES\"\n            case x => \"\
    NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1kd6qcln.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        res.reduceLeft(\e[31m\"\
    NO\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                       Found:    (\e[32m\"NO\"\e[0m : String)\n\e[31m\
    \   |\e[0m                       Required: (String, String) => String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp1kd6qcln.scala:24:12 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x.equals(\e\
    [31m\"NO\"\e[0m) => \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I\
    \ could not infer the type of the parameter x$1 of expanded function:\n\e[31m\
    \   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e[33m match \e[0m\n\e[31m   |\e\
    [0m       {\n\e[31m   |\e[0m         \e[33mcase \e[0mx\e[33m if \e[0mx.equals(\e\
    [32m\"NO\"\e[0m) => \n\e[31m   |\e[0m           \e[32m\"NO\"\e[0m\n\e[31m   |\e\
    [0m         \e[33mcase \e[0mx\e[33m if \e[0mx.equals(\e[32m\"YES\"\e[0m) => \n\
    \e[31m   |\e[0m           \e[32m\"YES\"\e[0m\n\e[31m   |\e[0m         \e[33mcase\
    \ \e[0mx => \n\e[31m   |\e[0m           \e[32m\"NO\"\e[0m\n\e[31m   |\e[0m   \
    \    }.\n2 errors found\n"
  stdout: ''
  timestamp: 1659979799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.foreach(element => {\n            if(lst2.contains(element)) {\n      \
    \          lst2.remove(element)\n            } else {\n                lst2 +=\
    \ element\n            }\n        })\n        if(lst2.isEmpty) \"\" else lst2.reverse.mkString(\"\
    \ \").concat(\"is even\")\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj3pi7fzp.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                lst2.remove(element)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value remove is not\
    \ a member of List[Long] - did you mean lst2.reduce?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpj3pi7fzp.scala:22:21 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m                lst2 += element\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member of List[Long]\
    \ - did you mean lst2.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979799
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = (lst1 union lst2).sortWith(_ < _).map(_ %2l).toList\n        if(lst3.size\
    \ == lst1.size) {\n            val res = lst3.zip(lst1).map(x => if (x._1 == x._2)\
    \ \"YES\" else \"NO\").mkString\n            if(res.equals(\"NO\")) \n       \
    \         throw new IllegalArgumentException(\"Invalid inputs\")\n           \
    \ else\n                res\n        }\n        else\n            \"NO\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2p57jre6.scala:30)\n\tat Problem.main(tmp2p57jre6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(f => f % 2 == 0).foldLeft(mutable.ListBuffer[Long]())((a,\
    \ b) => a :+ b)\n        val odds = lst1.filter(f => f % 2 == 1).foldLeft(mutable.ListBuffer[Long]())((a,\
    \ b) => a :+ b)\n        if (evens.equals(lst2.filter(f => f % 2 == 0))) {\n \
    \           return \"YES\"\n        } else if (odds == lst2.filter(f => f % 2\
    \ == 1)) {\n            return \"YES\"\n        } else {\n            return \"\
    NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxwpys3t4.scala:18:58 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = lst1.filter(\e\
    [36mf\e[0m => f % \e[31m2\e[0m == \e[31m0\e[0m).foldLeft(mutable.ListBuffer[\e\
    [35mLong\e[0m]())((\e[36ma\e[0m, \e[36mb\e[0m) => a :+ b)\n\e[31m\e[31m   |\e\
    [0m                                                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxwpys3t4.scala:18:98\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mevens\e[0m = lst1.filter(\e[36mf\e[0m => f % \e[31m2\e[0m == \e[31m0\e[0m).foldLeft(mutable.ListBuffer[\e\
    [35mLong\e[0m]())((\e[36ma\e[0m, \e[36mb\e[0m) => a :+ b)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                            \
    \             value :+ is not a member of Any\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpxwpys3t4.scala:19:57 ------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36modds\e[0m = lst1.filter(\e[36mf\e[0m => f\
    \ % \e[31m2\e[0m == \e[31m1\e[0m).foldLeft(mutable.ListBuffer[\e[35mLong\e[0m]())((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a :+ b)\n\e[31m\e[31m   |\e[0m                  \
    \                                       ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxwpys3t4.scala:19:97 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36modds\e[0m = lst1.filter(\e\
    [36mf\e[0m => f % \e[31m2\e[0m == \e[31m1\e[0m).foldLeft(mutable.ListBuffer[\e\
    [35mLong\e[0m]())((\e[36ma\e[0m, \e[36mb\e[0m) => a :+ b)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \  "
  stdout: ''
  timestamp: 1659979799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // write your solution here\n        val evens = lst1.filter(i => i % 2 == 0).sorted\n\
    \        val odds = lst2.filter(i => i % 2 != 0).sorted\n\n        if (evens.head\
    \ == odds.head) {\n            val first = evens.tail.head\n            val second\
    \ = odds.tail.head\n            if (evens.head + 1 == odds.head) odds = odds ++\
    \ List(first + second - 1)\n            else evens = evens ++ List(first - second)\n\
    \            return \"NO\"\n        }\n        else {\n            val first =\
    \ odds.tail.head\n            val second = evens.tail.head\n            if (odds.head\
    \ + 1 == evens.head) evens = evens ++ List(first + second - 1)\n            else\
    \ odds = odds ++ List(first - second)\n            return \"NO\"\n        }\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpxzaof8k6.scala:25:50 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (evens.head + \e[31m1\e[0m\
    \ == odds.head) odds = odds ++ List(first + second - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Reassignment\
    \ to val odds\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpxzaof8k6.scala:26:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33melse\e\
    [0m evens = evens ++ List(first - second)\n\e[31m\e[31m   |\e[0m             \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \    Reassignment to val evens\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpxzaof8k6.scala:32:51 -----------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mif\e[0m (odds.head + \e[31m1\e[0m == evens.head) evens\
    \ = evens ++ List(first + second - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Reassignment\
    \ to val evens\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpxzaof8k6.scala:33:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33melse\e\
    [0m odds = odds ++ List(first - second)\n\e[31m\e[31m   |\e[0m               \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Reassignment\
    \ to val odds\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.toSet.intersect(lst2.toSet).size == lst1.size ? \"YES\" : \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxvxjdgt0.scala:18:59 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst1.toSet.intersect(lst2.toSet).size == lst1.size\
    \ ? \e[31m\"YES\"\e[0m : \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                    value ? is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659979799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val length = lst1.size + lst2.size\n        val even = lst1.filter(_ % 2 ==\
    \ 0).toList\n        val odd = lst2.filter(_ % 2 == 1).toList\n        if (even.length\
    \ == 0 && odd.isEmpty) {\n            return \"YES\"\n        } else if (even.size\
    \ == 0 && odd.length != 0) {\n            return \"NO\"\n        } else if (even.length\
    \ != 0 && odd.length == 0) {\n            return \"NO\"\n        } else {\n  \
    \          val evenList = even.foldRight((ListBuffer[Long](), ListBuffer[Long]()))((a,\
    \ e) => {\n                val tmp = a._1 + e\n                a._1 += e\n   \
    \             (tmp, a._2)\n            })\n            val oddList = odd.foldRight((ListBuffer[Long](),\
    \ ListBuffer[Long]()))((a, e) => {\n                val tmp = a._1 + e\n     \
    \           a._1 += e\n                (a._2, tmp)\n            })\n         \
    \   val result = oddList.takeWhile((a, b) => a < b).map((a, b) => a ++ b).toList\
    \ ++ evenList.takeWhile((a, b) => a < b).map((a, b) => a ++ b)\n            if\
    \ (even.size != result.size) {\n                return \"NO\"\n            } else\
    \ {\n                even.zip(result).forall((a, b) => a.toLong == b.toLong)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd3_ry81r.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mtmp\e[0m = a._1\
    \ + e\n\e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e\
    [0m                          value _1 is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpd3_ry81r.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                a._1 += e\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd3_ry81r.scala:31:24\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                (tmp, a._2)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0m        \
    \              value _2 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpd3_ry81r.scala:34:28 ------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                \e[33mval\e[0m \e[36mtmp\e[0m = a._1 + e\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m               \
    \           value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpd3_ry81r.scala:35:18 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                a._1 += e\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m                value _1 is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpd3_ry81r.scala:36:19 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                (a._2, tmp)\n\e[31m\e[31m   |\e[0m  \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                 value _2 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd3_ry81r.scala:38:33\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m\
    \ \e[36mresult\e[0m = oddList.takeWhile((\e[36ma\e[0m, \e[36mb\e[0m) => a < b).map((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a ++ b).toList ++ evenList.takeWhile((\e[36ma\e[0m,\
    \ \e[36mb\e[0m) => a < b).map((\e[36ma\e[0m, \e[36mb\e[0m) => a ++ b)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ takeWhile is not a member of (scala.collec"
  stdout: ''
  timestamp: 1659979800
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evenLst1 = lst1.filter(_%2 == 0)\n        val evenLst2 = lst2.filter(_%2\
    \ == 0)\n        val evenLst3 = evenLst1.filter(_ != evenLst2(0))\n        val\
    \ evenLst4 = evenLst3.map(_ - evenLst2(0))\n        if(evenLst4.length != 0) {\n\
    \            val evenLst5 = evenLst4.filter(_ == evenLst2(0))\n            if(evenLst5.length\
    \ == 0)\n                return \"NO\"\n            else\n                return\
    \ \"YES\"\n        } else\n            return \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo8unxli3.scala:35)\n\tat Problem.main(tmpo8unxli3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979800
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evenLst = lst1.filter(x=> x % 2 == 0).size\n        val exchangedLst = lst2.filter(x=>\
    \ x % 2 == 0).size\n        if (exchangedLst == evenLst)\n            \"YES\"\n\
    \        else\n            \"NO\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnduhiadi.scala:29)\n\tat Problem.main(tmpnduhiadi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979808
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.zip(lst2).filter { case (a: Long, b: Long) => (a % 2) == (b % 2) }.map(x\
    \ => x.toString()).mkString(\"|\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdlpa1v0d.scala:21)\n\tat Problem.main(tmpdlpa1v0d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val map1 = lst1.map(x=>x%2).toList\n        val map2 = lst2.map(x=>x%2).toList\n\
    \        var count = 0\n        val map3 = map1.zip(map2).map(x=>(x._1, x._2))\n\
    \        val map4 = map3.filter(x=>!map2.contains(x))\n        map4.foreach(x=>count+=1)\
    \ // count is number of even numbers found in both maps\n        if(count==map1.length)\
    \ \n          \"YES\" \n        else\n          \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0eq66ay1.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmap4\e[0m = map3.filter(x=>!map2.contains(x))\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        var listOfNumbers1 : List[Long] = lst1\n   \
    \     var listOfNumbers2 : List[Long] = lst2\n        var listOfNumbers3 : List[Long]\
    \ = listOfNumbers1.distinct\n        var listOfNumbers4 : List[Long] = listOfNumbers2.distinct\n\
    \        var evenNumbers1 : List[Long] = listOfNumbers3.filter(_ % 2 == 0)\n \
    \       var evenNumbers2 : List[Long] = listOfNumbers4.filter(_ % 2 == 0)\n  \
    \      var evenNumbers3 : List[Long] = listOfNumbers1.filter(_ % 2 == 0).filter(_\
    \ % 2 == 0)\n        var evenNumbers4 : List[Long] = listOfNumbers2.filter(_ %\
    \ 2 == 0).filter(_ % 2 == 0)\n        evenNumbers1 match {\n            case Nil\
    \ => evenNumbers2.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \            case x => evenNumbers2.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \        }\n        evenNumbers2 match {\n            case Nil => evenNumbers3.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \            case x => evenNumbers3.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \        }\n        evenNumbers3 match {\n            case Nil => evenNumbers4.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \            case x => evenNumbers4.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \        }\n        listOfNumbers2.filter(_ % 2 == 0).size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmporgitbb0.scala:28:60 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mcase\e[0m Nil => evenNumbers2.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue remove is not a member of List[Long] - did you mean\
    \ List[Long].reduce?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmporgitbb0.scala:29:58\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e\
    [0m x => evenNumbers2.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue remove is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmporgitbb0.scala:32:60\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mcase\e\
    [0m Nil => evenNumbers3.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue remove is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.col"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1 == null || lst2 == null || lst1.isEmpty){\n            return \"NO\"\
    \n        }\n        var oddList1 = (lst1.filter(x => x % 2 != 0)).sortWith((x,y)\
    \ => x.compareTo(y))\n        var oddList2 = (lst2.filter(x => x % 2 != 0)).sortWith((x,y)\
    \ => x.compareTo(y))\n        if (oddList1.size <= 1 && oddList2.size <= 1) {\n\
    \            return (oddList1.head % 2 + \"\\n\" + oddList2.head % 2) \n     \
    \   }\n        else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu4yk1lq5.scala:21:83\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36moddList1\e\
    [0m = (lst1.filter(\e[36mx\e[0m => x % \e[31m2\e[0m != \e[31m0\e[0m)).sortWith((\e\
    [36mx\e[0m,\e[36my\e[0m) => x.compareTo(y))\n\e[31m\e[31m   |\e[0m           \
    \                                                             ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu4yk1lq5.scala:22:83\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36moddList2\e\
    [0m = (lst2.filter(\e[36mx\e[0m => x % \e[31m2\e[0m != \e[31m0\e[0m)).sortWith((\e\
    [36mx\e[0m,\e[36my\e[0m) => x.compareTo(y))\n\e[31m\e[31m   |\e[0m           \
    \                                                             ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var i = 0\n        var j = 0\n        var even = 0\n        var odd = 0\n  \
    \      var evenList = []\n        var oddList = []\n\n        while(i < lst1.length\
    \ && j < lst2.length) {\n            i += 1\n            j += 1\n\n          \
    \  if(lst1(j) mod 2 == 0){\n                even += 1\n                evenList\
    \ += lst1(j)\n            }\n            else if(lst1(j) mod 2 != 0){\n      \
    \          odd += 1\n                oddList += lst1(j)\n            }\n     \
    \   }\n\n        if(even > odd){\n            return \"YES\"\n        }\n    \
    \    else if(even < odd){\n            return \"NO\"\n        }\n\n        if(evenList.size\
    \ == lst1.length){\n            return \"YES\"\n        }\n        else if(oddList.size\
    \ == lst1.length){\n            return \"NO\"\n        }\n\n        else{\n  \
    \          return exchange(evenList, lst2) || exchange(oddList, lst2)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_9xf1cib.scala:22:24 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mevenList\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp_9xf1cib.scala:23:0 ----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mvar\e[0m \e[36moddList\e[0m = []\n\e[31m\e[31m   |\e[0m^^^\e\
    [0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp_9xf1cib.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36moddList\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp_9xf1cib.scala:25:0 ----------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mwhile\e[0m(i < lst1.length && j < lst2.length) {\n\e[31m\e\
    [31m   |\e[0m^^^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_9xf1cib.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m(lst1(j) mod \e[31m2\e[0m ==\
    \ \e[31m0\e[0m){\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue mod is not a member of Long, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_9xf1cib.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                evenList\
    \ += lst1(j)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue += is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConver"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.zip(lst2).filter(_._1.toString.toDouble % 2 == _._1.toString.toDouble\
    \ % 2)\n        if(lst3.size == lst2.size)\n            \"YES\"\n        else\n\
    \            \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1w5q8a01.scala:18:43 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst1.zip(lst2).filter(_._1.toString.toDouble\
    \ % \e[31m2\e[0m == _._1.toString.toDouble % \e[31m2\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                         ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                 value _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even1 = lst1.filter(x => x % 2 == 0).toList\n        val even2 = lst2.filter(x\
    \ => x % 2 == 0).toList\n        val odd1 = lst1.filter(x => x % 2 != 0).toList\n\
    \        val odd2 = lst2.filter(x => x % 2 != 0).toList\n        if even1.length\
    \ == even2.length ||\n            odd1.length == odd2.length\n            { return\
    \ \"YES\" }\n        else\n            { return \"NO\" }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr6lsczj_.scala:25:8 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^\e[0m\n\e[31m   |\e[0m        'then' expected, but 'else' found\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpr6lsczj_.scala:23:32 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            odd1.length == odd2.length\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             \e[33mmethod\e[0m \e[35mlength\e[0m in \e[33mclass\e[0m \e[35mList\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmpr6lsczj_.scala:27:4 -----------------\e[0m\e[0m\n\e[33m26 |\e\
    [0m            { \e[33mreturn\e[0m \e[31m\"NO\"\e[0m }\n\e[33m27 |\e[0m    }\n\
    \e[33m\e[33m   |\e[0m                           ^\e[0m\n\e[33m   |\e[0mA pure\
    \ expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1659979807
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(_ % 2 == 0)\n        val odds = lst1.filter(_ % 2 !=\
    \ 0)\n        if (evens.length == 0) \"NO\"\n        else if (evens.length !=\
    \ lst1.length) \"NO\"\n        else odds match {\n            case Nil => \"NO\"\
    \n            case ev :: odf => ev match {\n                case 0 => \"NO\"\n\
    \                case _ => \"YES\"\n            }\n            case _ => \"NO\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfiz_1kb8.scala:32)\n\tat Problem.main(tmpfiz_1kb8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979813
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1.length != lst2.length) {\n            return \"NO\"\n        } else\
    \ {\n            var lst = lst2\n            lst = lst.filter(x => (lst1.count(x\
    \ => x == x) % 2 == 0))\n            val even = lst.count(x => x == x) % 2 ==\
    \ 0\n            if (even) {\n                return \"YES\"\n            } else\
    \ {\n                return \"NO\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc878z4c0.scala:33)\n\tat Problem.main(tmpc878z4c0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) lst2.isEmpty\n        else if(lst2.isEmpty) lst1.isEmpty\n\
    \        else if (lst1.head == lst2.head) exchange(lst1.tail, lst2.tail)\n   \
    \     else exchange(lst1, lst2.tail)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps324a9w3.scala:18:30\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(lst1.isEmpty)\
    \ lst2.isEmpty\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    Boolean\n\e[31m   |\e[0m   \
    \                      Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmps324a9w3.scala:19:35 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(lst2.isEmpty) lst1.isEmpty\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                              Found:    Boolean\n\e[31m   |\e[0m    \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n    }\n\
    }\n</code>\nFor Scala 2.10.x, Scala IDE will provide an IDE-friendly solution\
    \ for you, which can solve this problem in one line.\n<code>\nscala> List(1l,\
    \ 2l, 3l, 4l) intersect List(5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l,\
    \ 16l, 17l, 18l, 19l, 20l, 21l, 22l, 23l, 24l, 25l, 26l, 27l, 28l, 29l, 30l, 31l,\
    \ 32l, 33l, 34l, 35l, 36l, 37l, 38l, 39l, 40l, 41l, 42l, 43l, 44l, 45l, 46l, 47l,\
    \ 48l, 49l, 50l, 51l, 52l, 53l, 54l, 55l, 56l, 57l, 58l, 59l, 60l, 61l, 62l, 63l,\
    \ 64l, 65l, 66l, 67l, 68l, 69l, 70l, 71l, 72l, 73l, 74l, 75l, 76l, 77l, 78l, 79l,\
    \ 80l, 81l, 82l, 83l, 84l, 85l, 86l, 87l, 88l, 89l, 90l, 91l, 92l, 93l, 94l, 95l,\
    \ 96l, 97l, 98l, 99l, 100l, 101l, 102l, 103l, 104l, 105l, 106l, 107l, 108l, 109l,\
    \ 110l, 111l, 112l, 113l, 114l, 115l, 116l, 117l, 118l, 119l, 120l, 121l, 122l,\
    \ 123l, 124l, 125l, 126l, 127l, 128l, 129l, 130l, 131l, 132l, 133l, 134l, 135l,\
    \ 136l, 137l, 138l, 139l, 140l, 141l, 142l, 143l, 144l, 145l, 146l, 147l, 148l,\
    \ 149l, 150l, 151l, 152l, 153l, 154l, 155l, 156l, 157l, 158l, 159l, 160l, 161l,\
    \ 162l, 163l, 164l, 165l, 166l, 167l, 168l, 169l, 170l, 171l, 172l, 173l, 174l,\
    \ 175l, 176l, 177l, 178l, 179l, 180l, 181l, 182l, 183l, 184l, 185l, 186l, 187l,\
    \ 188l, 189l, 190l, 191l, 192l, 193l, 194l, 195l, 196l, 197l, 198l, 199l, 200l,\
    \ 201l, 202l, 203l, 204l, 205l, 206l, 207l, 208l, 209l, 210l, 211l, 212l, 213l,\
    \ 214l, 215l, 216l, 217l, 218l, 219l, 220l, 221l, 222l, 223\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E103] Syntax Error: /tmp/tmpjlkm20hh.scala:20:0 ----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m</code>\n\e[31m\e[31m   |\e[0m^^\e[0m\n\e[31m   |\e[0mIllegal\
    \ start of toplevel definition\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpjlkm20hh.scala:35:0 ----------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected, but '}' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjlkm20hh.scala:17:66 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e[0m(\e[36mlst1\e[0m\
    \ : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e[0m[\e[35mLong\e\
    [0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                            Found:    Unit\n\e[31m   |\e[0m \
    \                                                       Required: String\n\e[31m18\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjlkm20hh.scala:26:11\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m    assert(exchange((List[\e\
    [35mLong\e[0m](\e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong,\
    \ \e[31m4l\e[0m.toLong)), (List[\e[35mLong\e[0m](\e[31m1l\e[0m.toLong, \e[31m2l\e\
    [0m.toLong, \e[31m3l\e[0m.toLong, \e[31m4l\e[0m.toLong))).equals((\e[31m\"YES\"\
    \e[0m)));\n\e[31m\e[31m   |\e[0m           ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \       Not found: exchange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpjlkm20hh.scala:27:11 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m    assert(exchange((List[\e[35mLong\e[0m](\e[31m1l\e[0m.toLong, \e[31m2l\e\
    [0m.toLong, \e[31m3l\e[0m.toLong, \e[31m4l\e[0m.toLong)), (List[\e[35mLong\e[0m](\e\
    [31m1l\e[0m.toLong, \e[31m5l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m4l\e[0m.toLong))).equals((\e\
    [31m\"NO\"\e[0m)));\n\e[31m\e[31m   |\e[0m           ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m"
  stdout: ''
  timestamp: 1659979810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO\n        val lst3 = lst1 ++ lst2\n        if (lst3.sum % 2 == 0) \"\
    YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1j4l1le5.scala:26)\n\tat Problem.main(tmp1j4l1le5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst1copy: List[Long] = lst1.toList\n        var lst2copy: List[Long] = lst2.toList\n\
    \        var even = true\n        var evenlst1 = 0\n        var evenlst2 = 0\n\
    \        var evenlst1index = 0\n        var evenlst2index = 0\n        var evenlst1list\
    \ = 0\n        var evenlst2list = 0\n        var lst1even = []\n        var lst2even\
    \ = []\n        var lst1evenindex = 0\n        var lst2evenindex = 0\n       \
    \ while(lst1copy.length > 0 || lst2copy.length > 0) {\n            if(lst1copy.length\
    \ > 0 && lst2copy.length > 0) {\n                if(lst1copy(0).toLong % 2 ==\
    \ 0 && lst2copy(0).toLong % 2 == 0) {\n                    if(lst1copy(0).toLong\
    \ == lst2copy(0).toLong) {\n                        lst1copy.remove(0)\n     \
    \                   lst2copy.remove(0)\n                    } else if(lst1copy(0).toLong\
    \ > lst2copy(0).toLong) {\n                        lst1copy.remove(0)\n      \
    \                  lst2copy.remove(0)\n                    } else {\n        \
    \                lst1copy.remove(0)\n                        lst2copy.remove(0)\n\
    \                    }\n                } else {\n                    even = false\n\
    \                }\n            }\n            if(even) {\n                if(evenlst1\
    \ == lst1copy.length + lst2copy.length) {\n                    evenlst1 = 0\n\
    \                    evenlst2 = 0\n                    evenlst1index = 0\n   \
    \                 evenlst2index = 0\n                    evenlst1list = 0\n  \
    \                  evenlst2list = 0\n                    lst1even = []\n     \
    \               lst2even = []\n                    lst1evenindex = 0\n       \
    \             lst2evenindex = 0\n                    lst1copy.remove(0)\n    \
    \                lst2copy.remove(0)\n                } else if(evenlst1 == lst1copy.length\
    \ || evenlst1 == 0) {\n                    if(lst1copy.length + evenlst1 == lst1copy.length)\
    \ {\n                        lst1even ++= lst1copy\n                        lst1copy.remove(0)\n\
    \                        evenlst1 = lst1copy.length\n                        evenlst1index\
    \ = 0\n                    } else if(lst1copy.length + evenlst1 == 0) {\n    \
    \                    lst1even ++= lst1copy\n                        lst1copy.remove(0)\n\
    \                        evenlst1 = lst1copy.length\n                        evenlst1index\
    \ = 0\n                        lst1even ++= lst1copy\n                       \
    \ lst1copy.remove(0)\n                        evenlst1 = lst1copy.length\n   \
    \                     evenlst1index = 0\n                        lst1even ++=\
    \ lst1copy\n                        lst1copy.remove(0)\n                     \
    \   evenlst1 = lst1copy.length\n                        evenlst1index = 0\n  \
    \                      lst1even ++= lst\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi4tjdu3f.scala:27:24 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mlst1even\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpi4tjdu3f.scala:28:0 ----------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mvar\e[0m \e[36mlst2even\e[0m = []\n\e[31m\e[31m   |\e[0m^^^\e\
    [0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpi4tjdu3f.scala:28:24 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mlst2even\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpi4tjdu3f.scala:29:0 ----------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mvar\e[0m \e[36mlst1evenindex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi4tjdu3f.scala:56:32 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m                    lst1even = []\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpi4tjdu3f.scala:57:0 ----------------------------\e[0m\e[0m\n\e\
    [31m57 |\e[0m                    lst2even = []\n\e[31m\e[31m   |\e[0m^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpi4tjdu3f.scala:57:32 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                    lst2even = []\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpi4tjdu3f.scala:58:0 ----------------------------\e[0m\e[0m\n\e\
    [31m58 |\e[0m                    lst1evenindex = \e[31m0\e[0m\n\e[31m\e[31m  \
    \ |\e[0m^^^^^^^^^^^^^\e[0m\n"
  stdout: ''
  timestamp: 1659979816
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      //\
    \ Your code here\n      // If there are more elements in lst1 than elements in\
    \ lst2, then it is\n      // impossible to make lst1 a list of only even numbers.\
    \ Therefore, return \"NO\".\n      if (lst1.size > lst2.size) {\n        return\
    \ \"NO\"\n      }\n      val evens = lst1.filter(_ % 2 == 0).toList\n      val\
    \ odds = lst2.filter(_ % 2 != 0).toList\n      val newList = evens.zip(odds)\n\
    \      if (newList.size == evens.size) {\n        return \"YES\"\n      } else\
    \ {\n        return \"NO\"\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpegsjxiov.scala:35)\n\tat Problem.main(tmpegsjxiov.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val num1 = lst1.toSet.toList.size\n        val num2 = lst2.toSet.toList.size\n\
    \        if (num1 != num2) {\n            s\"NO\"\n        }\n        else if\
    \ (num1 == num2 && lst1.toSet == lst2.toSet) {\n            if (lst1.toSet.contains(2l.toLong)\
    \ && lst2.toSet.contains(2l.toLong)) {\n                \"YES\"\n            }\n\
    \            else {\n                \"NO\"\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxudtme48.scala:23:13\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (num1 == num2 && lst1.toSet == lst2.toSet) {\n\e[31m\e[31m   |\e[0m      \
    \       ^\e[0m\n\e[31m   |\e[0m             Found:    Unit\n\e[31m   |\e[0m  \
    \           Required: String\n\e[31m   |\e[0m             Maybe you are missing\
    \ an else part for the conditional?\n\e[31m24 |\e[0m            \e[33mif\e[0m\
    \ (lst1.toSet.contains(\e[31m2l\e[0m.toLong) && lst2.toSet.contains(\e[31m2l\e\
    [0m.toLong)) {\n\e[31m25 |\e[0m                \e[31m\"YES\"\e[0m\n\e[31m26 |\e\
    [0m            }\n\e[31m27 |\e[0m            \e[33melse\e[0m {\n\e[31m28 |\e[0m\
    \                \e[31m\"NO\"\e[0m\n\e[31m29 |\e[0m            }\n\e[31m30 |\e\
    [0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ def exchanges(lst1 : List[Long], lst2 : List[Long]) : List[Long] = ???\n\n \
    \       def findSum (lst1 : List[Long], lst2 : List[Long]) : List[Long] = ???\n\
    \n        val sum1 = findSum(lst1,lst2)\n        val sum2 = findSum(lst2,lst1)\n\
    \        if (sum1.toLong == sum2.toLong)\n            return \"YES\"\n       \
    \ else\n            return \"NO\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprhasrlfc.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (sum1.toLong == sum2.toLong)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter( l => l.toDouble % 2 == 0 ).toList\n        val odds\
    \ = lst2.filter( l => l.toDouble % 2 != 0 ).toList\n        val result = evens.head\
    \ + odds(0).filter( l => odds(1) contains l ).head + evens.tail.filter( l => evens(0)\
    \ contains l ).head + odds(1).filter( l => evens(1) contains l ).head + evens.tail.filter(\
    \ l => odds(0) contains l ).head + odds(0) + evens.tail.filter( l => evens(0)\
    \ contains l ).head + odds(1) + evens.tail.filter( l => odds(0) contains l ).head\
    \ + odds(1) + evens.tail.filter( l => evens(1) contains l ).head + evens.tail.filter(\
    \ l => odds(1) contains l )\n        if ( result > 0 ) \"\" else \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpunuvvxb1.scala:20:42 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = evens.head\
    \ + odds(\e[31m0\e[0m).filter( \e[36ml\e[0m => odds(\e[31m1\e[0m) contains l ).head\
    \ + evens.tail.filter( \e[36ml\e[0m => evens(\e[31m0\e[0m) contains l ).head +\
    \ odds(\e[31m1\e[0m).filter( \e[36ml\e[0m => evens(\e[31m1\e[0m) contains l ).head\
    \ + evens.tail.filter( \e[36ml\e[0m => odds(\e[31m0\e[0m) contains l ).head +\
    \ odds(\e[31m0\e[0m) + evens.tail.filter( \e[36ml\e[0m => evens(\e[31m0\e[0m)\
    \ contains l ).head + odds(\e[31m1\e[0m) + evens.tail.filter( \e[36ml\e[0m =>\
    \ odds(\e[31m0\e[0m) contains l ).head + odds(\e[31m1\e[0m) + evens.tail.filter(\
    \ \e[36ml\e[0m => evens(\e[31m1\e[0m) contains l ).head + evens.tail.filter( \e\
    [36ml\e[0m => odds(\e[31m1\e[0m) contains l )\n\e[31m\e[31m   |\e[0m         \
    \                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                   value filter is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659979811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // write your code here\n        lst1 foreach (x => lst2 filter (x % 2 == 0).toList)\n\
    \        lst1 filter (x => lst2 filter (x % 2 == 0).toList).length == 0\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjdj7t_t7.scala:19:52 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        lst1 foreach (\e[36mx\e[0m => lst2 filter (x\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).toList)\n\e[31m\e[31m   |\e[0m             \
    \                          ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                        value toList is not a member of Boolean\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmpjdj7t_t7.scala:20:21 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst1 filter (\e[36mx\e[0m => lst2 filter (x %\
    \ \e[31m2\e[0m == \e[31m0\e[0m).toList).length == \e[31m0\e[0m\n\e[31m\e[31m \
    \  |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                     I could\
    \ not infer the type of the parameter x.\n2 errors found\n"
  stdout: ''
  timestamp: 1659979812
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x % 2 == 1).toList\n        val evenLength = even.size\n        val oddLength\
    \ = odd.size\n        if(evenLength == 0 || oddLength == 0) {\n            \"\"\
    \n        } else {\n            if(evenLength == oddLength){\n               \
    \ val common = even.intersect(odd)\n                val evenCommon = even.filter(x\
    \ => common.contains(x)) // even in common\n                val oddCommon = odd.filter(x\
    \ => common.contains(x)) // odd in common\n                if(evenCommon.size\
    \ == evenLength && oddCommon.size == oddLength){\n                    if(evenCommon.isEmpty\
    \ || oddCommon.isEmpty){\n                        \"\"\n                    }\
    \ else {\n                        if(evenCommon.size == evenLength){\n       \
    \                     evenCommon.toList.mkString(\",\")\n                    \
    \    } else {\n                            oddCommon.toList.mkString(\",\")\n\
    \                        }\n                    }\n                } else {\n\
    \                    \"\"\n                }\n            } else {\n         \
    \       \"\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpobkuzse6.scala:48)\n\tat Problem.main(tmpobkuzse6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjmpthwed.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO\e[0m\n\e[31m19 |\e[0m    }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979811
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ \n        // Code here\n        \n        return \"\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqap2g4b2.scala:24)\n\tat Problem.main(tmpqap2g4b2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.filter(x => !lst2.contains(x))\n        val lst4 = lst1.filter(x\
    \ => !lst3.contains(x))\n        val lst5 = lst2.filter(x => !lst4.contains(x))\n\
    \        val lst6 = lst2.filter(x => !lst5.contains(x))\n\n        if (lst3.isEmpty)\
    \ \"\"\n        else if (lst4.isEmpty) \"\"\n        else if (lst5.isEmpty) \"\
    \"\n        else if (lst6.isEmpty) \"\"\n        else if (lst1.size < lst2.size)\
    \ \"\"\n        else if (lst2.size < lst1.size) \"\"\n        else if (lst4.contains(lst5.head))\
    \ \"NO\"\n        else if (lst4.contains(lst5.last)) \"NO\"\n        else if (lst5.contains(lst4.head))\
    \ \"NO\"\n        else if (lst5.contains(lst4.last)) \"NO\"\n        else if (lst6.contains(lst5.head))\
    \ \"NO\"\n        else if (lst6.contains(lst5.last)) \"NO\"\n        else if (lst5.contains(lst6.head))\
    \ \"NO\"\n        else if (lst5.contains(lst6.last)) \"NO\"\n        else if (lst3.contains(lst4.head))\
    \ \"NO\"\n        else if (lst3.contains(lst4.last)) \"NO\"\n        else if (lst4.contains(lst3.head))\
    \ \"NO\"\n        else if (lst4.contains(lst3.last)) \"NO\"\n        else if (lst5.contains(lst6.head))\
    \ \"NO\"\n        else if (lst5.contains(lst6.last)) \"NO\"\n        else if (lst6.contains(lst5.head))\
    \ \"NO\"\n        else if (lst6.contains(lst5.last)) \"NO\"\n        else if (lst3.contains(lst5.head))\
    \ \"NO\"\n        else if (lst3.contains(lst5.last)) \"NO\"\n        else if (lst5.contains(lst3.head))\
    \ \"NO\"\n        else if (lst5.contains(lst3.last)) \"NO\"\n        else if (lst6.contains(lst3.head))\
    \ \"NO\"\n        else if (lst6.contains(lst3.last)) \"NO\"\n        else if (lst4.contains(lst6.head))\
    \ \"NO\"\n        else if (lst4.contains(lst6.last)) \"NO\"\n        else if (lst6.contains(lst4.head))\
    \ \"NO\"\n        else if (lst6.contains(lst4.last)) \"NO\"\n        else if (lst3.contains(lst6.head))\
    \ \"NO\"\n        else if (lst3.contains(lst6.last)) \"NO\"\n        else if (lst5.contains(lst6.head))\
    \ \"NO\"\n        else if (lst5.contains(lst6.last)) \"NO\"\n        else if (lst6.contains(lst5.head))\
    \ \"NO\"\n        else if (lst6.contains(lst5.last)) \"NO\"\n        else if (lst3.contains(lst4.head))\
    \ \"NO\"\n        else if (\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8qrsrz4n.scala:62:17 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (\n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty){\n            return \"NO\";\n        }else if(lst2.isEmpty){\n\
    \            return \"NO\";\n        }else{\n            val a = lst1.head\n \
    \           val b = lst2.head\n            if(a % 2 == 0 && b % 2 == 0){\n   \
    \             val lst3 = lst1.tail\n                val lst4 = lst2.tail\n   \
    \             if(lst3.size == 0){\n                    return \"NO\"\n       \
    \         }else if(lst4.size == 0){\n                    return \"NO\"\n     \
    \           }else{\n                    return \"YES\"\n                }\n  \
    \          }else if(a % 2 == 0 && b % 2 != 0){\n                val lst3 = lst1.tail\n\
    \                val lst4 = lst2.tail\n                if(lst3.size == 0){\n \
    \                   return \"NO\"\n                }else if(lst4.size == 0){\n\
    \                    return \"NO\"\n                }else{\n                 \
    \   return \"YES\"\n                }\n            }else{\n                return\
    \ \"NO\"\n            }\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8t1ydv_q.scala:51)\n\tat Problem.main(tmp8t1ydv_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      val\
    \ evens = lst1.filter(_ % 2l.toLong == 0)\n      val odds = lst2.filter(_ % 2l.toLong\
    \ != 0)\n      evens.size == 0 && (\"NO\") || (evens.length < odds.length) &&\
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuxcwblgi.scala:20:26\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m      evens.size == \e[31m0\e\
    [0m && (\e[31m\"NO\"\e[0m) || (evens.length < odds.length) && \e[31m\"YES\"\e\
    [0m\n\e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Found:    (\e[32m\"NO\"\e[0m : String)\n\e[31m   |\e\
    [0m                          Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpuxcwblgi.scala:20:67 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      evens.size == \e[31m0\e[0m && (\e[31m\"NO\"\e[0m)\
    \ || (evens.length < odds.length) && \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                                                   ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Found:    (\e[32m\"\
    YES\"\e[0m : String)\n\e[31m   |\e[0m                                        \
    \      Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // YOUR CODE HERE\n        val lst3 = lst1 ++ lst2.reverse\n        val even\
    \ = lst3.map(x => if(x % 2 == 0) x else x * 2)\n        val even2 = even.sort\n\
    \        val even3 = even2.takeWhile(x => x < lst3.last).toList\n        val even4\
    \ = even3.take(even3.size - even2.size)\n        if(even4 forall even.contains(x\
    \ => x == x)) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqbkdtjve.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36meven2\e[0m = even.sort\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ sort is not a member of List[Long] - did you mean even.sortBy?\n1 error found\n"
  stdout: ''
  timestamp: 1659979819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.map { x =>\n            if(lst2.contains(x)){\n                lst2 -=x\n\
    \            }else{\n                lst2 += x\n            }\n        }\n   \
    \     if(lst2.isEmpty){\n            return \"YES\"\n        }else{\n        \
    \    return \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfvin9m7j.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                lst2 -=x\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m          value -= is not a member of\
    \ List[Long] - did you mean lst2.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfvin9m7j.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                lst2 += x\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ += is not a member of List[Long] - did you mean lst2.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) {\n            return \"NO\"\n        } else if(lst2.isEmpty)\
    \ {\n            return \"NO\"\n        }\n        if(lst1(0) < lst2(0) && lst1(0)\
    \ >= 0) {\n            exchangeHelper(lst1, lst2, 1l.toLong)\n        } else if(lst2(0)\
    \ < lst1(0) && lst2(0) >= 0) {\n            exchangeHelper(lst2, lst1, 1l.toLong)\n\
    \        } else {\n            exchangeHelper(lst1, lst2, 0l.toLong)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzubej9w.scala:24:12 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            exchangeHelper(lst1, lst2, \e[31m1l\e[0m.toLong)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    Not found: exchangeHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplzubej9w.scala:26:12 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            exchangeHelper(lst2, lst1, \e[31m1l\e[0m.toLong)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ exchangeHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzubej9w.scala:28:12\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            exchangeHelper(lst1,\
    \ lst2, \e[31m0l\e[0m.toLong)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: exchangeHelper\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var tmp1 : List[Long] = lst1.toList\n        var tmp2 : List[Long] = lst2.toList\n\
    \        var flag : Boolean = false\n        var count : Int = 1\n        while(count\
    \ <= lst2.length){\n            flag =  (lst1.contains(tmp2(0)) && lst2.contains(tmp1(0))\
    \ && tmp1.contains(tmp2(0)) && lst1.contains(tmp2(0)) && lst2.contains(tmp1(0)))\n\
    \            if(!flag){\n                tmp1 = tmp1.drop(1)\n               \
    \ tmp2 = tmp2.drop(1)\n                count +=1\n            }else{\n       \
    \         break\n            }\n        }\n        if(lst1.size == count){\n \
    \           if(lst2.size == count){\n                if(lst1.contains(tmp2(0))\
    \ && lst2.contains(tmp1(0))){\n                    return \"YES\"\n          \
    \      }else{\n                    return \"NO\"\n                }\n        \
    \    }\n        }\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyy8r7ivd.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your implementation goes here\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1srlp6u5.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your implementation goes here\e[0m\n\
    \e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979821
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        var lst3 = lst1\n        lst3 = lst2 ++ lst3\n\
    \        if (lst3.forall(x => x % 2 == 0)) {\n            \"YES\"\n        } else\
    \ {\n            \"NO\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1ycr26p.scala:28)\n\tat Problem.main(tmpj1ycr26p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) return \"NO\";\n        if(lst2.isEmpty) return \"NO\";\n \
    \       var even = true;\n        for(i <- lst1.indices) {\n            if(lst1(i).toInt\
    \ % 2 == 0) {\n                even = false\n            }\n        }\n      \
    \  for(i <- lst2.indices) {\n            if(lst2(i).toInt % 2 == 0) {\n      \
    \          even = false\n            }\n        }\n        if(even) \n       \
    \     return \"YES\"\n        else \n            return \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4u2hwq64.scala:37)\n\tat Problem.main(tmp4u2hwq64.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your code here\n        // Write your code here\n        var lst3 =\
    \ (lst1 take lst2.length) intersect (lst2 take lst1.length)\n        if (lst3\
    \ != Nil) lst3 else \"NO\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplqxmdtq6.scala:21:25\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (lst3 !=\
    \ Nil) lst3 \e[33melse\e[0m \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m         \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                         Found:   \
    \ (lst3 : List[Long])\n\e[31m   |\e[0m                         Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if(lst1.isEmpty){\n            \"\"\n        }\n\
    \        else if(lst2.isEmpty){\n            \"\"\n        }\n        else if(lst1.last.isEven){\n\
    \            exchange(lst1.dropRight(1),lst2)\n        }\n        else{\n    \
    \        exchange(lst1,lst2.dropRight(1))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq6kf8qsx.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(lst1.last.isEven){\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \              value isEven is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659979822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       val\
    \ evens = lst1.filter(_ % 2l.toLong == 0)\n       val odds  = lst2.filter(_ %\
    \ 2l.toLong == 0)\n\n       val exchangedElements = evens.zip(odds)\n       exchangedElements.foreach\
    \ {\n         case(evenElem, oddElem)  =>\n           lst1 ++= (evenElem.toLong)\n\
    \           lst2 ++= (oddElem.toLong)\n       }\n\n       if (lst1.size == evens.size)\
    \ (\"YES\")\n       else (\"NO\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprl3150su.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m           lst1 ++= (evenElem.toLong)\n\e[31m\e[31m \
    \  |\e[0m           ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value ++= is not a\
    \ member of List[Long] - did you mean lst1.++?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmprl3150su.scala:25:16 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m           lst2 ++= (oddElem.toLong)\n\e[31m\e[31m   |\e[0m          \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value ++= is not a member of List[Long]\
    \ - did you mean lst2.++?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter((x => x % 2 ==0l)).distinct\n        val odds  = lst2.filter((x\
    \ => x % 2 ==1l)).distinct\n        val evenOdds = evens ++ odds\n        var\
    \ result = \"\"\n        for (ev in evenOdds) {\n            val l1 = lst1.filter((x\
    \ => x % 2 ==0l)).distinct\n            val l2 = lst2.filter((x => x % 2 ==1l)).distinct\n\
    \            val l1 = l1.filter((x => x % 2 ==ev%2l)).distinct\n            val\
    \ l2 = l2.filter((x => x % 2 ==ev%2l)).distinct\n            val s1 = l1.size\n\
    \            val s2 = l2.size\n            val s3 = evenOdds.filter((x => x %\
    \ 2 ==ev%2l)).size\n            val s4 = evenOdds.filter((x => x % 2 !==ev%2l)).size\n\
    \            val n1 = l1.size - s1\n            val n2 = l2.size - s2\n      \
    \      val n3 = evenOdds.filter((x => x % 2 !==ev%2l)).size\n            val n4\
    \ = evenOdds.filter((x => x % 2 ==ev%2l)).size\n            if (n1 === n2 && n2\
    \ === n3) {\n                result = \"YES\"\n                break\n       \
    \     } else if (n1 === n2 && n2 === n4) {\n                result = \"YES\"\n\
    \                break\n            } else if (n1 === n2 && n3 === n4) {\n   \
    \             result = \"NO\"\n                break\n            } else if (n1\
    \ === n3 && n2 === n4) {\n                result = \"NO\"\n                break\n\
    \            } else if (n1 === n3 && n2 === n3) {\n                result = \"\
    YES\"\n                break\n            } else if (n1 === n4 && n2 === n3) {\n\
    \                result = \"NO\"\n                break\n            } else if\
    \ (n1 === n4 && n2 === n4) {\n                result = \"YES\"\n             \
    \   break\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxw9200n0.scala:22:29 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (ev in evenOdds) {\n\e[31m\e[31m\
    \   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m               \
    \              '<-' expected, but '{' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxw9200n0.scala:57:9 -------------------------\e[0m\e[0m\n\e[31m57 |\e\
    [0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter\
    \ is not a member of Null, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e\
    [0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.list asScalaBuffer\n\e[31m  \
    \ |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val n = lst1.size\n        if(lst1.isEmpty) {\n            lst2.toList.mkString(\"\
    [\", \", \", \"]\") \n        } else if (lst2.isEmpty) {\n            lst1.toList.mkString(\"\
    [\", \", \", \"]\") \n        } else {\n            // do some magic!\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiyyu4l87.scala:23:15\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m {\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    Unit\n\e[31m   |\e[0m               Required: String\n\e[31m24 |\e[0m   \
    \         \e[34m// do some magic!\e[0m\n\e[31m25 |\e[0m        }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkyot22ev.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1 == null || lst2 == null || lst1.isEmpty() || lst2.isEmpty) return \"\
    NO\"\n        val lst3 = new ListBuffer[Long]\n        lst2.foreach(x => lst3\
    \ += x)\n        lst1.foreach(x => lst3 -= x)\n        if(lst3.isEmpty || lst3.toSet.size\
    \ == 0) \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpp7xn1nt4.scala:18:48 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(lst1 == \e[31mnull\e[0m || lst2\
    \ == \e[31mnull\e[0m || lst1.isEmpty() || lst2.isEmpty) \e[33mreturn\e[0m \e[31m\"\
    NO\"\e[0m\n\e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35misEmpty\e[0m in\
    \ \e[33mclass\e[0m \e[35mList\e[0m does not take parameters\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.filter(x => ((lst2.exists(y => x == y)).toSeq).isEmpty)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuqzm3dmm.scala:18:53 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst1.filter(\e[36mx\e[0m => ((lst2.exists(\e\
    [36my\e[0m => x == y)).toSeq).isEmpty)\n\e[31m\e[31m   |\e[0m                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              value toSeq is not a member of Boolean\n1 error found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      lst1.toSet.intersect(lst2.toSet).isEmpty\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg5jygl3q.scala:18:39\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m      lst1.toSet.intersect(lst2.toSet).isEmpty\n\
    \e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      Found:    Boolean\n\e[31m   |\e[0m      Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // SOLUTION GOES BELOW\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppf6zjm7x.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// SOLUTION GOES BELOW\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val resultSet = mutable.Set[Long]()\n        // TODO: Write your code here\n\
    \        resultSet.addAll(lst2)\n        resultSet.removeAll(lst1)\n        val\
    \ resultString = resultSet.toList.mkString(\",\")\n        resultString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppoi68g_5.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresultSet\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val xs = lst1 ++ (0 until lst2.length)\n        val ys = lst2 ++ (0 until lst1.length)\n\
    \        xs zip ys filter (x => x % 2 == 0) forall {\n            x => lst1 exists\
    \ y => x == y\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpb9qqaqq4.scala:21:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[36mx\e[0m => lst1 exists y => x == y\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \             not a legal formal parameter\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpb9qqaqq4.scala:20:33 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        xs zip ys filter (\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\
    \ forall {\n\e[31m\e[31m   |\e[0m                               ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue % is not a member of (AnyVal, AnyVal), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb9qqaqq4.scala:21:39 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[36mx\e[0m => lst1 exists y => x == y\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                       Not found: y\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979827
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      if(lst1.length\
    \ == 0 || lst2.length == 0){\n        return \"\";\n      }\n      var list3 =\
    \ lst1.diff(lst2)\n      var list4 = lst2.diff(lst1)\n      val list5 = list3.toList.sortWith(_\
    \ < _)\n      val list6 = list4.toList.sortWith(_ < _)\n      if(list5.toSet ==\
    \ list6.toSet){\n        return \"YES\"\n      }\n      else{\n        return\
    \ \"NO\"\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw60z3fhm.scala:36)\n\tat Problem.main(tmpw60z3fhm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var count = 0\n        for(a <- lst1; b <- lst2) {\n            if(a.toDouble\
    \ % 2 == 0) && (b.toDouble % 2 == 0) {\n                count++\n            }\n\
    \        }\n        if(count == lst2.size)\n            \"YES\"\n        else\n\
    \            \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpc91z0f3p.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                count++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpc91z0f3p.scala:20:36 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            \e[33mif\e[0m(a.toDouble % \e[31m2\e[0m == \e[31m0\e[0m) && (b.toDouble\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^\e[0m\n\e[31m   |\e[0m                                   \
    \ Not found: &&\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1 = lst1.toList\n        val lst2 = lst2.toList\n        val even1 =\
    \ lst1.filter(x => x % 2 == 0).toList\n        val even2 = lst2.filter(x => x\
    \ % 2 == 0).toList\n        var evenToDelete = 0\n        val list1 = lst1\n \
    \       var list2 = lst2\n        var isEven = True\n\n        while(list1.nonEmpty\
    \ || list2.nonEmpty) {\n            var countEven = 0\n            if (list1.nonEmpty\
    \ && list2.nonEmpty) {\n                countEven = even1.size + even2.size\n\
    \                isEven = (countEven <= 1) ? True : isEven\n                evenToDelete\
    \ = (countEven == 1) ? 1 : countEven\n            } else if (list1.nonEmpty) {\n\
    \                countEven = even1.size\n                isEven = (countEven <=\
    \ 1) ? True : isEven\n                evenToDelete = countEven\n            }\
    \ else if (list2.nonEmpty) {\n                countEven = even2.size\n       \
    \         isEven = (countEven <= 1) ? True : isEven\n                evenToDelete\
    \ = countEven\n            }\n\n            if (isEven) {\n                if\
    \ (countEven == 1) {\n                    val even = even1.head\n            \
    \        val evenList = even1.tail\n                    list1 = list1 diff List(even)\n\
    \                    list2 = list2 diff List(even)\n                    lst1 =\
    \ lst1.filterNot(x => x == even)\n                    lst2 = lst2.filterNot(x\
    \ => x == even)\n                    even1 = evenList.filter(x => x % 2 == 0).toList\n\
    \                    even2 = evenList.filter(x => x % 2 == 0).toList\n       \
    \             evenToDelete = (countEven == 1) ? 1 : countEven\n              \
    \  } else {\n                    val even = even1.head\n                    val\
    \ evenList = even1.tail\n                    list1 = list1 diff List(even)\n \
    \                   list2 = list2 diff List(even)\n                    lst1 =\
    \ lst1.filterNot(x => x == even)\n                    lst2 = lst2.filterNot(x\
    \ => x == even)\n                    even1 = evenList.filter(x => x % 2 == 0).toList\n\
    \                    even2 = evenList.filter(x => x % 2 == 0).toList\n       \
    \             evenToDelete = (countEven == 1) ? 1 : countEven\n              \
    \  }\n            } else {\n                if (countEven == 1) {\n          \
    \          val even = even2.head\n                    val evenList = even2.tail\n\
    \                    list1 = list1 diff List(even)\n                    list2\
    \ = list2 diff List(even)\n                    lst1 = lst1.filterNot(x => x ==\
    \ even)\n                    lst2 = lst\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpblseka4a.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpblseka4a.scala:18:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst1\e[0m = lst1.toList\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\
    \e[31m   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mlst1\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpblseka4a.scala:19:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst2\e[0m = lst2.toList\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\
    \e[31m   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mlst2\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpblseka4a.scala:25:21\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e\
    [36misEven\e[0m = True\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: True\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpblseka4a.scala:31:51 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                isEven = (countEven <= \e[31m1\e[0m)\
    \ ? True : \e[35misEven\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \                         ^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                           Not found: type isEven\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpblseka4a.scala:31:42 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                isEven = (countEven <= \e[31m1\e[0m)\
    \ ? True : \e[35misEven\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value ? is not a member of Boolean\n\
    \e[31m\e[31m-"
  stdout: ''
  timestamp: 1659979829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst3 = lst1 ++ lst2\n        var lst4 = ListBuffer[Long]()\n        var\
    \ even = true\n        while (lst3.nonEmpty && even) {\n            var value\
    \ = lst3.head\n            var removeValue = lst3.remove(0)\n            lst4\
    \ += value\n            even = !even\n            lst3 += removeValue\n      \
    \  }\n        even = even\n        if (lst3.nonEmpty) {\n            return \"\
    NO\"\n        } else {\n            return \"YES\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo4xr6j8w.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mvar\e[0m \e[36mremoveValue\e[0m = lst3.remove(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue remove is not a member of List[Long] - did you mean\
    \ List[Long].reduce?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo4xr6j8w.scala:26:17\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            lst3 += removeValue\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean List[Long].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.zip(lst2).map{case (number1,number2) => if(number1 % 2 == 0 && number2\
    \ % 2 == 0){ number1 -> number2 } else { number1 -> number2 } }.foldLeft(List[Long]()){\n\
    \            case (acc, elem) => acc ++ elem\n        }.count(_ % 2 == 0).isEmpty\
    \ match {\n            case true  => \"YES\"\n            case false => \"NO\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnaaa7lcw.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m (acc,\
    \ elem) => acc ++ elem\n\e[31m\e[31m   |\e[0m                                \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                                       Found:\
    \    (elem : (Long, Long))\n\e[31m   |\e[0m                                  \
    \     Required: IterableOnce[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: fill in the body of the function here.\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkdjeytvn.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO: fill in the body of the function\
    \ here.\e[0m\n\e[31m19 |\e[0m        \n\e[31m20 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val exSet = mutable.HashSet[Long]()\n        for(a <- lst1; b <- lst2){\n  \
    \          if(b < a){\n                exSet.add(a)\n                exSet.add(b)\n\
    \            }else{\n                exSet.add(b)\n                exSet.add(a)\n\
    \            }\n        }\n        if(exSet.size == lst2.size){\n            return\
    \ \"YES\"\n        }else{\n            return \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpttmjv3pz.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mexSet\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979828
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var even = lst1.filter(x => x % 2 == 0).toList\n        var odd = lst2.filter(x\
    \ => x % 2 == 0).toList\n        var lst3 = lst1.toList\n        var lst4 = lst2.toList\n\
    \        var lst5 = even.union(odd).distinct\n        var lst6 = lst3.filter(x\
    \ => !lst5.contains(x))\n        var lst7 = lst4.filter(x => !lst5.contains(x))\n\
    \        var lst8 = lst6.toList\n        var lst9 = lst7.toList\n        var lst10\
    \ = lst8.toList\n        lst10.foreach(x => if (x % 2 == 0) even = even.filterNot(x\
    \ => x == x) else odd = odd.filterNot(x => x == x))\n        if (lst10.size ==\
    \ 0) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp147jw19u.scala:32)\n\tat Problem.main(tmp147jw19u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      //\
    \ Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq3yb377y.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m      \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst1_temp = lst1\n        var lst2_temp = lst2\n        while(lst1_temp.nonEmpty\
    \ || lst2_temp.nonEmpty) {\n            lst1_temp = lst1_temp map {\n        \
    \        val elm = lst1_temp.head\n                if (lst1_temp.head % 2 == 0)\
    \ {\n                    lst1_temp.remove(elm)\n                }\n          \
    \      elm\n            }\n            lst2_temp = lst2_temp map {\n         \
    \       val elm = lst2_temp.head\n                if (lst2_temp.head % 2 == 0)\
    \ {\n                    lst2_temp.remove(elm)\n                }\n          \
    \      elm\n            }\n            if (lst1_temp.size == 0 && lst2_temp.size\
    \ == 0) return \"YES\"\n            if (lst1_temp.size == 0) return \"NO\"\n \
    \           if (lst2_temp.size == 0) return \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy3hht9k9.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    lst1_temp.remove(elm)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long] - did you mean List[Long].reduce?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpy3hht9k9.scala:26:16 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                elm\n\e[31m\e[31m   |\e[0m          \
    \      ^^^\e[0m\n\e[31m   |\e[0m                Found:    (elm : Long)\n\e[31m\
    \   |\e[0m                Required: Long => Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpy3hht9k9.scala:31:30 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    lst2_temp.remove(elm)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy3hht9k9.scala:33:16\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                elm\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                Found: \
    \   (elm : Long)\n\e[31m   |\e[0m                Required: Long => Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Implement this function\n        lst1.foldLeft(\"\"){\n        case\
    \ (acc, i) => acc += s\"($i), ($lst2.head), ($lst2.tail)\\n\"\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6u3ohyke.scala:20:29 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mcase\e[0m (acc, i) => acc += \e[31ms\"\
    (\e[0m$i\e[31m), (\e[0m$lst2\e[31m.head), (\e[0m$lst2\e[31m.tail)\\n\"\e[0m\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \          value += is not a member of String - did you mean acc.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val map1 = lst1.groupBy(identity).mapValues(_.length)\n        val map2 = lst2.groupBy(identity).mapValues(_.length)\n\
    \n        val res = map1.filter(_._2 > map2.get(_._1)).exists { case (_, v) =>\
    \ v == 2 }\n        res match {\n            case true => \"YES\"\n          \
    \  case false => \"NO\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpc693p3sx.scala:21:46 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = map1.filter(_._2\
    \ > map2.get(_._1)).exists { \e[33mcase\e[0m (_, v) => v == \e[31m2\e[0m }\n\e\
    [31m\e[31m   |\e[0m                                              ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$4 of expanded function:\n\e[31m   |\e\
    [0m   _$4 => _$4._1.\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc693p3sx.scala:21:35\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e\
    [0m \e[36mres\e[0m = map1.filter(_._2 > map2.get(_._1)).exists { \e[33mcase\e\
    [0m (_, v) => v == \e[31m2\e[0m }\n\e[31m\e[31m   |\e[0m                     \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\
    \e[31m   |\e[0m  (x: Double): Boolean\n\e[31m   |\e[0m  (x: Float): Boolean\n\e\
    [31m   |\e[0m  (x: Long): Boolean\n\e[31m   |\e[0m  (x: Int): Boolean\n\e[31m\
    \   |\e[0m  (x: Char): Boolean\n\e[31m   |\e[0m  (x: Short): Boolean\n\e[31m \
    \  |\e[0m  (x: Byte): Boolean\n\e[31m   |\e[0m match arguments (Option[Int])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var i = 0\n        var j = 0\n        var k = 0\n        var exchanged = 0\n\
    \        while(i < lst1.length && j < lst2.length) {\n            if(lst1(k) ==\
    \ lst2(j)) {\n                if(lst1(k).even) {\n                    lst1(k)\
    \ = lst1(k).odd.get\n                    lst1(exchanged) = lst1(k).even.get\n\
    \                    exchanged = exchanged + 1 \n                } else {\n  \
    \                  lst1(k) = lst1(k).even.get\n                    lst1(exchanged)\
    \ = lst1(k).odd.get\n                    exchanged = exchanged + 1 \n        \
    \        }\n                i = i + 1\n                j = j + 1\n           \
    \     k = k + 1\n            } else {\n                i = i + 1\n           \
    \     j = j + 1\n                k = k + 1\n            }\n        }\n       \
    \ exchanged = exchanged\n        if(exchanged == lst1.length) {\n            return\
    \ \"YES\"\n        } else if(exchanged == 0) {\n            return \"NO\"\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphfrio70c.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(lst1(k).even) {\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        value even is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphfrio70c.scala:25:20 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                    lst1(k) = lst1(k).odd.get\n\e[31m\e[31m   |\e[0m      \
    \              ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of List[Long]\
    \ - did you mean lst1.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphfrio70c.scala:25:38\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    lst1(k)\
    \ = lst1(k).odd.get\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value odd is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphfrio70c.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    lst1(exchanged) = lst1(k).even.get\n\
    \e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m value update\
    \ is not a member of List[Long] - did you mean lst1.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphfrio70c.scala:26:46 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                    lst1(exchanged) = lst1(k).even.get\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                      value even is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphfrio70c.scala:29:20\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    lst1(k)\
    \ = lst1(k).even.get\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m\
    \   |\e[0m value update is not a member of List[Long] - did you mean lst1.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphfrio70c.scala:29:38 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    lst1(k) = lst1(k).even.get\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          "
  stdout: ''
  timestamp: 1659979836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        \n        val list1 = lst1.toSet.toList\n  \
    \      val list2 = lst2.toSet.toList\n        \n        var list3 = list1\n  \
    \      list3.foreach(list3 => {\n            val list4 = list2\n            list4.foreach(list4\
    \ => {\n                \n            })\n        })\n        list3\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu_8c8tj9.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        list3\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (list3 : List[Long])\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here!\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjlmgyihk.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here!\e[0m\n\e[31m19\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your function here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnzjrai8f.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO: Write your function here\e[0m\n\
    \e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your solution here\n        val result = lst2.foldLeft(lst1.size)((x,\
    \ y) => x+y)\n        result != lst1.size ? \"NO\" : \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp67gu2vjg.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = lst2.foldLeft(lst1.size)((\e[36mx\e[0m, \e[36my\e[0m) => x+y)\n\e[31m\e\
    [31m   |\e[0m                                                        ^^^\e[0m\n\
    \e[31m   |\e[0m                                                        Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp67gu2vjg.scala:20:28\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        result != lst1.size\
    \ ? \e[31m\"NO\"\e[0m : \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m            \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  value ? is not a member\
    \ of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659979836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.foreach { x =>\n            lst2.foreach { y =>\n                if (x\
    \ % 2 == 0 & y % 2 == 0) {\n                    if (x != y) {\n              \
    \          lst2 += (x - y)\n                        lst1 += (y)\n            \
    \            println(lst1)\n                        println(lst2)\n          \
    \              //return \"YES\"\n                    }\n                }\n  \
    \          }\n        }\n        //return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp32qweugj.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                        lst2 += (x - y)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ += is not a member of List[Long] - did you mean lst2.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp32qweugj.scala:23:29 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                        lst1 += (y)\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not\
    \ a member of List[Long] - did you mean lst1.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979838
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1.isEmpty)\n        {\n            return \"NO\"\n        }\n       \
    \ else if (lst2.isEmpty)\n        {\n            return \"NO\"\n        }\n  \
    \      else if (lst1.head % 2 == 0 & lst2.head % 2 == 0)\n        {\n        \
    \    return \"YES\"\n        }\n        else if (lst1.head == lst2.head)\n   \
    \     {\n            return exchange(lst1.tail, lst2.tail)\n        }\n      \
    \  else\n        {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1ysmyph.scala:42)\n\tat Problem.main(tmpj1ysmyph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979838
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO:\n        // 1. Your code here\n        // 2. Make sure you return \"\
    NO\" if the lists are empty.\n        // 3. Make sure you use only immutable types\
    \ (Long, Integer, etc)\n        // 4. In particular, make sure your code can handle\
    \ the case where the lists are both empty.\n        // 5. Make sure you understand\
    \ what a \"functional programming\" solution would look like.\n        // 6. Make\
    \ sure you understand how recursion works.\n        if (lst1.isEmpty) lst2 match\
    \ {\n            case Nil => \"NO\"\n            case _ => lst1 match {\n    \
    \            case Nil => \"NO\"\n                case _ => \"YES\"\n         \
    \   }\n        }\n        else if (lst2.isEmpty) lst1 match {\n            case\
    \ Nil => \"NO\"\n            case _ => lst2 match {\n                case Nil\
    \ => \"NO\"\n                case _ => \"YES\"\n            }\n        }\n   \
    \     else if (lst1.head % 2 == lst2.head % 2) \"YES\"\n        else exchange(lst1.tail,\
    \ lst2.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucq8tv_3.scala:44)\n\tat Problem.main(tmpucq8tv_3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst = lst1.map(x => x)\n        val lst2 = lst2.map(x => x)\n        var\
    \ x = 0\n        var y = 0\n        val len1 = lst1.length\n        val len2 =\
    \ lst2.length\n        if (len1 < len2) {\n            lst = lst2.zip(lst).map(x\
    \ => (x._1.toLong :: x._2.toLong))\n        } else {\n            lst = lst1.zip(lst2).map(x\
    \ => (x._1.toLong :: x._2.toLong))\n        }\n        if (lst.distinct.map{x\
    \ => x.toLong}.distinct.length == lst2.distinct.map{x => x.toLong}.distinct.length\
    \ && lst.distinct.map{x => x.toLong}.distinct.length == lst2.distinct.map{x =>\
    \ x.toLong}.distinct.length)\n        {\n            val length = lst.distinct.map{x\
    \ => x.toLong}.distinct.length\n            var i = 0\n            var j = length\n\
    \            while (i < j && lst(j).toLong % 2 == 0) {\n                i = i\
    \ + 1\n                j = j - 1\n            }\n            if (i == j)\n   \
    \         {\n                var j = 0\n                while (j < length && lst(j).toLong\
    \ % 2 == 0) {\n                    lst(j).toLong = lst(j).toLong + lst(j).toLong\n\
    \                    j = j + 1\n                }\n                for (i <- i\
    \ until lst(length).toLong)\n                {\n                    if (lst(i).toLong\
    \ % 2 == 0) lst(i).toLong = lst(i).toLong - lst(i).toLong\n                  \
    \  else lst(i).toLong = lst(i).toLong - lst(i).toLong\n                }\n   \
    \             lst(length).toLong = lst(length).toLong + lst(length).toLong\n \
    \               if (lst(length).toLong % 2 == 0) \"YES\" else \"NO\"\n       \
    \     } else \"NO\"\n        } else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbcex53zk.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlst2\e[0m = lst2.map(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e\
    [0m                   Recursive \e[33mvalue\e[0m \e[35mlst2\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpbcex53zk.scala:25:16 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            lst = lst2.zip(lst).map(\e[36mx\e[0m => (x._1.toLong\
    \ :: x._2.toLong))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val lst\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbcex53zk.scala:27:63 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            lst = lst1.zip(lst2).map(\e[36mx\e[0m =>\
    \ (x._1.toLong :: x._2.toLong))\n\e[31m\e[31m   |\e[0m                       \
    \                                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpbcex53zk.scala:42:34 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    lst(j).toLong = lst(j).toLong + lst(j).toLong\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val toLong\n\e[31m   |\e\
    [0"
  stdout: ''
  timestamp: 1659979838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO:\n        // 1) Declare a mutable list to store elements from lst1\n\
    \        // 2) Declare a mutable list to store elements from lst2\n        //\
    \ 3) Add all elements of lst1 to a mutable list\n        // 4) Add all elements\
    \ of lst2 to a mutable list\n        // 5) Remove all elements from lst1 that\
    \ do not have even value\n        // 6) Remove all elements from lst2 that do\
    \ not have even value\n        // 7) Loop through both lists, if an even value\
    \ exists in both lists\n        // 8) If it exists swap elements and update both\
    \ lists\n        // 9) Return either \"YES\" or \"NO\"\n        // 10) Return\
    \ an empty string if there are no even values in either list\n        val list1\
    \ = lst1.toList\n        val list2 = lst2.toList\n        list1.toList.map(x =>\
    \ if (x % 2 == 0) { x } else { \"\" }).filter(x => x != \"\").flatMap(x => list2.filter(y\
    \ => y % 2 == 0).map(y => x -> y))\n        list2.toList.map(x => if (x % 2 ==\
    \ 0) { x } else { \"\" }).filter(x => x != \"\").flatMap(x => list1.filter(y =>\
    \ y % 2 == 0).map(y => x -> y))\n        list1.toList.map(x => if (x % 2 == 0)\
    \ { x } else { \"\" }).filter(x => x != \"\").flatMap(x => list2.filter(y => y\
    \ % 2 == 0).map(y => x -> y)).filter(x => x != \"\").map(x => x -> list1.count(i\
    \ => i % 2 == 0))\n        list2.toList.map(x => if (x % 2 == 0) { x } else {\
    \ \"\" }).filter(x => x != \"\").flatMap(x => list1.filter(y => y % 2 == 0).map(y\
    \ => x -> y)).filter(x => x != \"\").map(x => x -> list2.count(i => i % 2 == 0))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpi0gb9fqc.scala:33:159 ----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        list1.toList.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x % \e[31m2\e[0m == \e[31m0\e[0m) { x } \e[33melse\e[0m { \e[31m\"\"\e[0m }).filter(\e\
    [36mx\e[0m => x != \e[31m\"\"\e[0m).flatMap(\e[36mx\e[0m => list2.filter(\e[36my\e\
    [0m => y % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36my\e[0m => x -> y)).filter(\e\
    [36mx\e[0m => x != \e[31m\"\"\e[0m).map(\e[36mx\e[0m => x -> list1.count(\e[36mi\e\
    [0m => i % \e[31m2\e[0m == \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m             \
    \                                                                            \
    \                                                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types (Matchable, Long) and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpi0gb9fqc.scala:34:159 ----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        list2.toList.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x % \e[31m2\e[0m == \e[31m0\e[0m) { x } \e[33melse\e[0m { \e[31m\"\"\e[0m }).filter(\e\
    [36mx\e[0m => x != \e[31m\"\"\e[0m).flatMap(\e[36mx\e[0m => list1.filter(\e[36my\e\
    [0m => y % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36my\e[0m => x -> y)).filter(\e\
    [36mx\e[0m => x != \e[31m\"\"\e[0m).map(\e[36mx\e[0m => x -> list2.count(\e[36mi\e\
    [0m => i % \e[31m2\e[0m == \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m             \
    \                                                                            \
    \                                                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types (Matchable, Long) and String cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659979837
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter(_%2==0)\n        val odd = lst1.filter(_%2!=0)\n    \
    \    if (even.length==lst1.length && even.mkString.equalsIgnoreCase(lst2.mkString)){\n\
    \            return \"YES\"\n        }\n        if (odd.length==lst1.length &&\
    \ odd.mkString.equalsIgnoreCase(lst2.mkString)){\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwfcqcb_l.scala:29)\n\tat Problem.main(tmpwfcqcb_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your implementation here\n        if(lst1.size != lst2.size)\n\
    \            return \"NO\"\n        if(lst1.size == 0)\n            return \"\
    YES\"\n        val list = lst1.clone\n        val evenList = lst2.filter(_%2 ==\
    \ 0l)\n        for(i <- evenList){\n            if(list.contains(i))\n       \
    \         list.remove(i)\n        }\n        if(list.size == 0)\n            return\
    \ \"YES\"\n        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwiq0wufj.scala:23:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = lst1.clone\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e\
    [0m \e[35mclone\e[0m in \e[33mclass\e[0m \e[35mObject\e[0m cannot be accessed\
    \ as a member of (lst1 : List[Long]) from module class Problem$.\n\e[31m   |\e\
    [0m Access to protected \e[33mmethod\e[0m \e[35mclone\e[0m not permitted because\
    \ prefix type List[Long]\n\e[31m   |\e[0m does not conform to \e[33mobject\e[0m\
    \ \e[35mProblem\e[0m where the access takes place\n1 error found\n"
  stdout: ''
  timestamp: 1659979837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ //TODO: write the code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg0hekepb.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m//TODO: write the code here\e[0m\n\e[31m19\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst = lst1.toList ++ lst2.toList\n        val lst1 = lst.filter(x => x %\
    \ 2 == 0)\n        val lst2 = lst.filter(x => x % 2 != 0)\n        lst1.size ==\
    \ lst2.size && lst1.map((x => lst2.indexOf(x) > -1 && lst1.indexOf(x) == lst2.indexOf(x))\
    \ _).forall(x => x == true)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjjbntja1.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlst1\e[0m = lst.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \            ^\e[0m\n\e[31m   |\e[0m                   Recursive \e[33mvalue\e\
    [0m \e[35mlst\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979837
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        val even = lst1.filter (x => x % 2 == 0)\n \
    \       val odd = lst2.filter (x => x % 2 == 1)\n        val pairs = lst1.zip(lst2).filter\
    \ (x => even.contains(x._1) && odd.contains(x._2))\n        if (pairs.size < 2)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpokultqkf.scala:25)\n\tat Problem.main(tmpokultqkf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your solution here\n        lst1.toSet.intersect(lst2.toSet).size ==\
    \ lst1.size ? \"YES\" : \"NO\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmen5hzov.scala:19:59 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        lst1.toSet.intersect(lst2.toSet).size == lst1.size\
    \ ? \e[31m\"YES\"\e[0m : \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                    value ? is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659979842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1s = lst1.sort\n        val lst2s = lst2.sort\n        val evens = lst1s.filter(x\
    \ => x % 2 == 0)\n        val evenCount = lst2s.count(x => x % 2 == 0)\n     \
    \   if (evenCount < evens.length) {\n            return \"NO\"\n        }\n  \
    \      val nums = lst1s.zip(lst2s).filter(_._1 == _._2)\n        val numsSet =\
    \ nums.toSet\n        val numsSetCopy = numsSet.clone()\n        val numsSetCopy2\
    \ = numsSet.clone().map(x => x * 2)\n        val numsSetCopy3 = numsSet.clone().map(x\
    \ => x * 3)\n        val numsSetCopy4 = numsSet.clone().map(x => x * 4)\n    \
    \    val numsSetCopy5 = numsSet.clone().map(x => x * 5)\n        val numsSetCopy6\
    \ = numsSet.clone().map(x => x * 6)\n        val numsSetCopy7 = numsSet.clone().map(x\
    \ => x * 7)\n        val numsSetCopy8 = numsSet.clone().map(x => x * 8)\n    \
    \    val numsSetCopy9 = numsSet.clone().map(x => x * 9)\n        val numsSetCopy10\
    \ = numsSet.clone().map(x => x * 10)\n        val numsSetCopy11 = numsSet.clone().map(x\
    \ => x * 11)\n        val numsSetCopy12 = numsSet.clone().map(x => x * 12)\n \
    \       val numsSetCopy13 = numsSet.clone().map(x => x * 13)\n        val numsSetCopy14\
    \ = numsSet.clone().map(x => x * 14)\n        val numsSetCopy15 = numsSet.clone().map(x\
    \ => x * 15)\n        val numsSetCopy16 = numsSet.clone().map(x => x * 16)\n \
    \       val numsSetCopy17 = numsSet.clone().map(x => x * 17)\n        val numsSetCopy18\
    \ = numsSet.clone().map(x => x * 18)\n        val numsSetCopy19 = numsSet.clone().map(x\
    \ => x * 19)\n        val numsSetCopy20 = numsSet.clone().map(x => x * 20)\n \
    \       val numsSetCopy21 = numsSet.clone().map(x => x * 21)\n        val numsSetCopy22\
    \ = numsSet.clone().map(x => x * 22)\n        val numsSetCopy23 = numsSet.clone().map(x\
    \ => x * 23)\n        val numsSetCopy24 = numsSet.clone().map(x => x * 24)\n \
    \       val nums\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi_7hyo2s.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi_7hyo2s.scala:18:25\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mlst1s\e[0m = lst1.sort\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value sort is not a member of List[Long] - did you mean\
    \ lst1.sortBy?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi_7hyo2s.scala:19:25\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mlst2s\e[0m = lst2.sort\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue sort is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi_7hyo2s.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var even1 = false\n        var even2 = false\n        val size = lst1.size\n\
    \        val evenList = new mutable.MutableList[Long](lst1.size)\n        for(i\
    \ <- 0 to lst1.size -1 ) {\n            if(lst1(i) % 2 == 0) {\n             \
    \   even1 = true\n            }\n            evenList(i) = lst1(i)\n        }\n\
    \        val even2 = true\n        for(i <- 0 to lst2.size -1 ) {\n          \
    \  if(lst2(i) % 2 == 0) {\n                even2 = true\n            }\n     \
    \       evenList(i+size) = lst2(i)\n        }\n        if(even1 && even2) {\n\
    \            return \"NO\"\n        }\n        else if(even1 && even2) {\n   \
    \         for(i <- 0 to lst1.size -1 ) {\n                if(evenList(i) != 0)\
    \ {\n                    return \"NO\"\n                }\n            }\n   \
    \         return \"YES\"\n        }\n        else {\n            for(i <- 0 to\
    \ lst1.size -1 ) {\n                if(evenList(i) != 0) {\n                 \
    \   return \"NO\"\n                }\n            }\n            return \"YES\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo5egqda0.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36meven2\e[0m = \e[31mtrue\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0meven2\
    \ is already defined as \e[33mvariable\e[0m \e[35meven2\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo5egqda0.scala:21:27\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mevenList\e[0m = \e[33mnew\e[0m mutable.MutableList[\e[35mLong\e[0m](lst1.size)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst3 = lst1\n        var lst4 = lst2\n        for( i <- 0 until lst3.length\
    \ ) {\n            // if lst3 contains all even numbers, we can remove it\n  \
    \          if(lst3.forall( (x:Long) => x%2 == 0) ) {\n                lst3.remove(lst3.last)\n\
    \                lst4 += lst3.last\n            } else {\n                // if\
    \ lst3 contains some even numbers, remove it and append it at first\n        \
    \        if(lst3.forall( (x:Long) => x%2 == 1 ) ) {\n                    lst3.remove(lst3.last)\n\
    \                    lst3 += lst3.last\n                }\n                //\
    \ if lst3 doesn't contain even numbers, remove it and append it at the last\n\
    \                else {\n                    lst3.remove(lst3.last)\n        \
    \            lst4 += lst3.last\n                }\n            }\n        }\n\
    \        if(lst3 == lst4.map(_.toLong).toList ) {\n            return \"YES\"\n\
    \        }\n        else {\n            return \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxds3tajb.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                lst3.remove(lst3.last)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not\
    \ a member of List[Long] - did you mean List[Long].reduce?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxds3tajb.scala:24:21 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                lst4 += lst3.last\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxds3tajb.scala:28:25\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    lst3.remove(lst3.last)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxds3tajb.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    lst3\
    \ += lst3.last\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxds3tajb.scala:33:25 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    lst3.remove(lst3.last)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.co"
  stdout: ''
  timestamp: 1659979847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.toSet.toList.intersect(lst2.toSet).toList.forall(x => x % 2 == 0)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpskftgwkq.scala:18:36\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        lst1.toSet.toList.intersect(lst2.toSet).toList.forall(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                     Found:    Set[Long]\n\e[31m   |\e[0m                   \
    \                 Required: scala.collection.Seq[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even_lst = lst1.filter(_ % 2 == 0)\n        if(even_lst.size != lst1.size)\
    \ return(\"NO\")\n        val exchange_lst = lst2.filter(_ % 2 == 0).filterNot(lst1.contains(_))\n\
    \        if(exchange_lst.size != lst2.size) return(\"NO\")\n        val result\
    \ = even_lst.zip(exchange_lst).map(_._1).take(2).exists(_ % 2 == 0)\n        if(!result)\
    \ return(\"NO\")\n        \"YES\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiua_93dq.scala:27)\n\tat Problem.main(tmpiua_93dq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: implement the body of this function\n        val numOfElementsBetweenLists\
    \ = lst2.length() - lst1.length()\n        if(numOfElementsBetweenLists < 0 ||\
    \ numOfElementsBetweenLists > 0){\n            return \"NO\"\n        }\n    \
    \    val numOfExchangedElements = 0\n        lst2.zip(lst1).filter(_._1.toLong\
    \ % 2 == 0 && _._1.toLong > _._2.toLong).foreach {case (a, b) =>\n           \
    \ val index = lst2.indexOf(b)\n            lst2.remove(index)\n            lst2.insert(index,\
    \ b)\n            numOfExchangedElements += 1\n        }\n        if(lst2.size\
    \ < lst1.size){\n            return \"NO\"\n        }\n        else{\n       \
    \     if((lst1.size == lst2.size) && lst2.size == numOfExchangedElements){\n \
    \               return \"YES\"\n            }\n            else{\n           \
    \     return \"NO\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpvlsdhzfn.scala:19:45 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnumOfElementsBetweenLists\e\
    [0m = lst2.length() - lst1.length()\n\e[31m\e[31m   |\e[0m                   \
    \                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \e\
    [33mmethod\e[0m \e[35mlength\e[0m in \e[33mclass\e[0m \e[35mList\e[0m does not\
    \ take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvlsdhzfn.scala:24:30\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        lst2.zip(lst1).filter(_._1.toLong\
    \ % \e[31m2\e[0m == \e[31m0\e[0m && _._1.toLong > _._2.toLong).foreach {\e[33mcase\e\
    [0m (a, b) =>\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvlsdhzfn.scala:26:17\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            lst2.remove(index)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value remove\
    \ is not a member of List[Long] - did you mean lst2.reduce?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpvlsdhzfn.scala:27:17 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            lst2.insert(index, b)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value insert is not a member\
    \ of List[Long] - did you mean lst2.init?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvlsdhzfn.scala:28:35 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            numOfExchangedElements += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of Int - did you mean numOfExchangedElements.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659979847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst3 = lst1\n        val evenNumbers = lst3.filter(x => x.toDouble % 2 ==\
    \ 0)\n        val lst4 = lst2.filter(x => x.toDouble % 2 == 0)\n        if (lst4.size\
    \ == 0) return \"NO\"\n        val lst5 = evenNumbers.filterNot(lst4.contains)\n\
    \        val lst6 = lst5.map(x => x - lst4.size)\n        lst3.zip(lst6).map(x\
    \ => (x._1, x._2)).toList.sortBy(x => x._1).reverse.map {\n            x => (x(0)._1,\
    \ x(1)._2)\n        }.forall { x =>\n            lst3.contains(x._1)\n       \
    \ }.foldLeft(\"\") {\n            (x, y) => x + (if (y.contains(\"YES\")) \"YES\"\
    \ else \"NO\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_axogeil.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[36mx\e[0m => (x(\e[31m0\e[0m)._1, x(\e\
    [31m1\e[0m)._2)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  value _1 is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_axogeil.scala:25:32 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[36mx\e[0m => (x(\e[31m0\e[0m)._1, x(\e[31m1\e\
    [0m)._2)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value _2 is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst3 = (lst1 zip lst2).filter(_._1 == _._1)\n        if (lst3.isEmpty &&\
    \ lst2.isEmpty && lst1.isEmpty)\n        \treturn \"NO\"\n        else if (lst3.isEmpty\
    \ && lst2.isEmpty && lst1.isDefinedAt){\n            return \"YES\"\n        }\n\
    \        else if (lst2.isEmpty && lst1.isDefinedAt){\n            return \"NO\"\
    \n        }\n        else if (lst1.isDefinedAt && !lst3.isDefinedAt){\n      \
    \      return \"YES\"\n        }\n        else if (!lst1.isDefinedAt && lst2.isDefinedAt){\n\
    \            return \"NO\"\n        }\n        else if (lst1.isDefinedAt && !lst2.isDefinedAt){\n\
    \            return \"NO\"\n        }\n        else{\n            lst3.foreach{t\
    \ => lst1 = List(t._1, t._2)}\n            if (lst1.isEven) {\n              \
    \  return \"YES\"\n            }\n            else{\n                return \"\
    NO\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprhc8v7cg.scala:18:44 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mlst3\e[0m = (lst1 zip lst2).filter(_._1\
    \ == _._1)\n\e[31m\e[31m   |\e[0m                                          ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprhc8v7cg.scala:21:49\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (lst3.isEmpty && lst2.isEmpty && lst1.isDefinedAt){\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                Found:    \e[1m\e[31mInt\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31m=\e[0m\e[1m\e[31m>\e[0m\e[1m\e[31m \e[0mBoolean\n\
    \e[31m   |\e[0m                                                Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprhc8v7cg.scala:24:33\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (lst2.isEmpty && lst1.isDefinedAt){\n\e[31m\e[31m   |\e[0m               \
    \                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \             Found:    \e[1m\e[31mInt\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m=\e[0m\e\
    [1m\e[31m>\e[0m\e[1m\e[31m \e[0mBoolean\n\e[31m   |\e[0m                     \
    \            Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmprhc8v7cg.scala:27:34 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33melse\e[0m \e[33mif\e[0m (lst1.isDefinedAt && !lst3.isDefinedAt){\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 value && is not a member of Int => Boolean\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprhc8v7cg.scala:27:37 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (lst1.isDefinedAt &&\
    \ !lst3.isDefinedAt){\n\e[31m\e[31m   |\e[0m                                 \
    \    "
  stdout: ''
  timestamp: 1659979849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ def exchangeElements(lst1 : List[Long], lst2 : List[Long], i : Int, lstResults\
    \ : List[Long]) : List[Long] = {\n            if (lst1.isEmpty) {\n          \
    \      lstResults\n            } else if (lst2.isEmpty) {\n                if\
    \ (lst1.head % 2 != 0 && lst2.head % 2 != 0) {\n                    lstResults\
    \ ::= lst1.head :: lst2.head\n                } else {\n                    if\
    \ (lst1.head % 2 == 0 && lst2.head % 2 != 0) {\n                        lstResults\
    \ ::= lst1.head :: lst2.head :: lst1.last\n                    } else if (lst1.head\
    \ % 2 != 0 && lst2.head % 2 == 0) {\n                        lstResults ::= lst1.head\
    \ :: lst2.head :: lst1.last\n                    } else if (lst1.head % 2 == 0\
    \ && lst2.head % 2 == 0) {\n                        lstResults ::= lst1.head ::\
    \ lst2.head :: lst1.last :: lst2.last\n                    }\n               \
    \ }\n            } else if (lst1.head == lst2.head) {\n                lstResults\
    \ ::= lst2.head :: lst2.last\n            } else {\n                val lst3 =\
    \ lst1.head :: lst1.last\n                val lst4 = lst2.head :: lst2.last\n\
    \                if (lst3 % 2 == 0) {\n                    if (lst4 % 2 != 0)\
    \ {\n                        lstResults ::= lst3 :: lst4.head :: lst4.last\n \
    \                   } else if (lst4 % 2 == 0) {\n                        lstResults\
    \ ::= lst3 :: lst4.head :: lst4.last :: lst2.last\n                    }\n   \
    \             } else {\n                    if (lst4 % 2 != 0) {\n           \
    \             lstResults ::= lst3.head :: lst4 :: lst2.head :: lst2.last\n   \
    \                 } else if (lst4 % 2 == 0) {\n                        lstResults\
    \ ::= lst3.head :: lst4 :: lst2.head :: lst2.last :: lst2.last\n             \
    \       }\n                }\n            }\n            exchangeElements(lst1.tail,\
    \ lst2.tail, i + 1, lstResults)\n        }\n        exchangeElements(lst1, lst2,\
    \ 0, Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6ij91dt.scala:23:31 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    lstResults ::= lst1.head :: lst2.head\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \   value ::= is not a member of List[Long] - did you mean lstResults.::?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6ij91dt.scala:23:45 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    lstResults ::= lst1.head :: lst2.head\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value :: is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6ij91dt.scala:26:35\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                        lstResults\
    \ ::= lst1.head :: lst2.head :: lst1.last\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ::= is not a member of\
    \ List[Long] - did you mean lstResults.::?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpw6ij91dt.scala:26:62 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m                        lstResults ::= lst1.head :: lst2.head :: lst1.last\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \    value :: is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpw6ij91dt.scala:28:35 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m                        lstResults ::= lst1.head :: lst2.head :: lst1.last\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m   value ::= is not a member of List[Long] - did you mean lstResults.::?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6ij91dt.scala:28:62 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                        lstResults ::= lst1.head :: lst2.head\
    \ :: lst1.last\n\e[31m\e[31m   |\e[0m                                        \
    \                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                    value :: is not a member"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1.filter( x => x % 2 == 0)\n        val odd = lst2.filter( x =>\
    \ x % 2 == 1)\n        if(even.size == 0 && odd.size == 0){\n            return\
    \ \"NO\"\n        }\n        else if(even.size == 0 || odd.size == 0){\n     \
    \       return \"NO\"\n        }\n        if(even.size != 0 && odd.size != 0){\n\
    \            if(even.length != odd.length){\n                return \"NO\"\n \
    \           }\n            else if(even.size == 1){\n                even.headOption\
    \ match {\n                    case Some(evenNum) => odd.headOption match {\n\
    \                        case Some(oddNum) =>\n                            lst1.remove(evenNum)\n\
    \                            lst2.remove(oddNum)\n                           \
    \ return \"NO\"\n                        case None => return \"NO\"\n        \
    \            }\n                    case None => return \"NO\"\n             \
    \   }\n            }\n            else if(odd.size == 1){\n                even.headOption\
    \ match {\n                    case Some(evenNum) => odd.headOption match {\n\
    \                        case Some(oddNum) =>\n                            lst1.remove(evenNum)\n\
    \                            lst2.remove(oddNum)\n                           \
    \ return \"NO\"\n                        case None => return \"NO\"\n        \
    \            }\n                    case None => return \"NO\"\n             \
    \   }\n            }\n        }\n        else if(even.size == 1 && odd.size ==\
    \ 1){\n            even.headOption match {\n                case Some(evenNum)\
    \ => odd.headOption match {\n                    case Some(oddNum) =>\n      \
    \                  lst1.remove(evenNum)\n                        lst2.remove(oddNum)\n\
    \                        return \"NO\"\n                    case None => return\
    \ \"NO\"\n                }\n                case None => return \"NO\"\n    \
    \        }\n        }\n        else{\n            return \"NO\"\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl1926z0y.scala:34:33 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                            lst1.remove(evenNum)\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m  value remove is not a member of List[Long] - did you mean lst1.reduce?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpl1926z0y.scala:35:33 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                            lst2.remove(oddNum)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl1926z0y.scala:46:33\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                        \
    \    lst1.remove(evenNum)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue remove is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl1926z0y.scala:47:33\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                        \
    \    lst2.remove(oddNum)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var exchange :List[Long] = lst1\n        var list : List[Long] = lst2\n    \
    \    for (x <- exchange ; if list.contains(x)){\n            exchange.remove(x)\n\
    \            exchange.insert(x, list.indexOf(x))\n        }\n        if (exchange.isEmpty)\
    \ (\"YES\")\n        else (\"NO\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgxxhzkxp.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            exchange.remove(x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member\
    \ of List[Long] - did you mean List[Long].reduce?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpgxxhzkxp.scala:22:21 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            exchange.insert(x, list.indexOf(x))\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue insert is not a member\
    \ of List[Long] - did you mean List[Long].init?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2 == 0)\n        val odds = lst2.filter(x =>\
    \ x % 2 == 1)\n        val lst3 = evens.union(odds)\n        if (lst3.length ==\
    \ lst1.length) \n            lst3.map(x=>x%2).toString.equals(\"YES\") ? \"YES\"\
    \ : \"NO\" \n        else\n            \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxgktxngz.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            lst3.map(\e[36mx\e[0m=>x%\e[31m2\e[0m).toString.equals(\e\
    [31m\"YES\"\e[0m) ? \e[31m\"YES\"\e[0m : \e[31m\"NO\"\e[0m \n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value ? is not a member of Boolean\n1 error found\n"
  stdout: ''
  timestamp: 1659979848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var even1 = false\n        var even2 = false\n  \
    \      for(i <- lst1){\n            even1 = even1 || ((i.toLong % 2) == 0l)\n\
    \        }\n        for(i <- lst2){\n            even2 = even2 || ((i.toLong %\
    \ 2) == 0l)\n        }\n        if(even1 && even2)\n            return \"YES\"\
    \n        else if(even1 && !even2)\n            return \"NO\"\n        else if(!even1\
    \ && even2)\n            return \"NO\"\n        else if(!even1 && !even2)\n  \
    \          return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfi2b00zp.scala:33:13\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m(!even1 && !even2)\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e\
    [0m             Found:    Unit\n\e[31m   |\e[0m             Required: String\n\
    \e[31m   |\e[0m             Maybe you are missing an else part for the conditional?\n\
    \e[31m34 |\e[0m            \e[33mreturn\e[0m \e[31m\"NO\"\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1 == null || lst2 == null || lst1.length == 0 || lst2.length == 0) \"\
    NO\"\n        else {\n            var count = 1\n            val map1 = lst1.map(_.toLong).distinct.toMap\n\
    \            val map2 = lst2.map(_.toLong).distinct.toMap\n            map1.foreach\
    \ {\n                case (x: Long) => {\n                    map2.remove(x)\n\
    \                    count += 1\n                }\n            }\n          \
    \  if(count > 1) \"YES\"\n            else exchange(lst1.filterNot(x => map1.contains(x)).toList,\
    \ lst2.filterNot(x => map2.contains(x)).toList)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxt71orwm.scala:21:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mmap1\e[0m = lst1.map(_.toLong).distinct.toMap\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       Cannot prove that Long\
    \ <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                               \
    \        where:    K is a type variable\n\e[31m   |\e[0m                     \
    \                            V is a type variable\n\e[31m   |\e[0m           \
    \                            .\n\e[31m\e[31m-- Error: /tmp/tmpxt71orwm.scala:22:56\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     \e[33mval\e[0m \e[36mmap2\e[0m = lst2.map(_.toLong).distinct.toMap\n\e[31m\e\
    [31m   |\e[0m                                                        ^\e[0m\n\e\
    [31m   |\e[0m                                       Cannot prove that Long <:<\
    \ (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                   \
    \    where:    K is a type variable\n\e[31m   |\e[0m                         \
    \                        V is a type variable\n\e[31m   |\e[0m               \
    \                        .\n2 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var i = 0\n        // while lst1 contains even nums\n        while (i < lst1.length-1\
    \ && lst1(i).even) {\n            i += 1\n        }\n\n        var j = 0\n   \
    \     // while lst2 contains even nums\n        while (j < lst2.length-1 && lst2(j).even)\
    \ {\n            j += 1\n        }\n\n        // if lst1 and lst2 are different\n\
    \        if (i != j) {\n            var exchanged_even = 0\n            // while\
    \ lst1 contains even nums\n            while (i < lst1.length-1 && lst1(i).even)\
    \ {\n                i += 1\n                exchanged_even += 1\n           \
    \ }\n            // while lst2 contains even nums\n            while (j < lst2.length-1\
    \ && lst2(j).even) {\n                j += 1\n                exchanged_even +=\
    \ 1\n            }\n            // if lst1 and lst2 are not the same\n       \
    \     // but lst1 is longer and has more even nums\n            if (i != j &&\
    \ exchanged_even > lst1.length - lst2.length) {\n                return \"NO\"\
    \n            }\n            // if lst1 and lst2 are not the same\n          \
    \  // and lst2 is longer and has more even nums\n            if (i != j && exchanged_even\
    \ > lst1.length - lst2.length && exchanged_even > lst2.length - lst1.length) {\n\
    \                return \"NO\"\n            }\n            // if lst1 and lst2\
    \ are the same or lst1 is longer\n            if (i != j && exchanged_even < lst1.length\
    \ - lst2.length) {\n                return \"YES\"\n            }\n        }\n\
    \        // if lst1 and lst2 are the same or lst1 is longer\n        if (i !=\
    \ j && i < lst1.length-1) {\n            return \"YES\"\n        }\n        //\
    \ if lst1 and lst2 are the same or lst1 is longer\n        if (i != j && j < lst2.length-1)\
    \ {\n            return \"YES\"\n        }\n        // if lst1 and lst2 are the\
    \ same or lst1 is longer\n        if (i < lst1.length-1) {\n            return\
    \ \"YES\"\n        }\n        // if lst1 and lst2 are the same or lst1 is longer\n\
    \        if (j < lst2.length-1) {\n            return \"YES\"\n        }\n   \
    \     // if lst1 and lst2 are the same or lst1 is longer\n        // and they\
    \ all have even nums\n        return \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp628rkn2i.scala:20:44 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m (i < lst1.length-\e[31m1\e[0m\
    \ && lst1(i).even) {\n\e[31m\e[31m   |\e[0m                                  \
    \  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    value\
    \ even is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp628rkn2i.scala:26:44\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mwhile\e[0m\
    \ (j < lst2.length-\e[31m1\e[0m && lst2(j).even) {\n\e[31m\e[31m   |\e[0m    \
    \                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                          value even is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp628rkn2i.scala:34:48 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mwhile\e[0m (i < lst1.length-\e[31m1\e\
    [0m && lst1(i).even) {\n\e[31m\e[31m   |\e[0m                                \
    \        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \    value even is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp628rkn2i.scala:39:48 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m            \e[33mwhile\e[0m (j < lst2.length-\e[31m1\e[0m && lst2(j).even)\
    \ {\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value even is not a\
    \ member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ //TODO: Your code goes here\n        //assert(lst1.isEmpty)\n        //assert(lst2.isEmpty)\n\
    \        if (lst1.length == 0 || lst2.length == 0) {\n            return \"\"\n\
    \        }\n        val lst1set = lst1.toSet\n        val lst2set = lst2.toSet\n\
    \        val exchangeSet = lst1set & lst2set\n        val exchange = exchangeSet.count(_\
    \ % 2 == 0).toString.toUpperCase\n        if (exchange == \"YES\") {\n       \
    \     return \"YES\"\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf99roep3.scala:35)\n\tat Problem.main(tmpf99roep3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Copy = lst1.copy.toList\n        val lst2Copy = lst2.copy.toList\n \
    \       lst2Copy.foreach{ x =>\n            lst1Copy.remove(x)\n        }\n  \
    \      lst1Copy.foreach{ x =>\n            if (x % 2 == 0) {\n               \
    \ return \"YES\"\n            }\n        }\n        return \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd_2rg1_r.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mlst1Copy\e[0m = lst1.copy.toList\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \    value copy is not a member of List[Long] - did you mean lst1.coll?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpd_2rg1_r.scala:19:28 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlst2Copy\e[0m = lst2.copy.toList\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \    value copy is not a member of List[Long] - did you mean lst2.coll?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst2.filter(x => x.toInt%2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x.toInt%2 != 0).toList\n        val evenAndOdd = even.intersect(odd)\n  \
    \      evenAndOdd.filter(x => lst1.contains(x)).toList.map(x => if (lst1.contains(x)).toList.map(x\
    \ => (x,x)).toSet.toList.map(x => x(0) + x(1)).map(\"+\"+_).map(x => if (x ==\
    \ x) \"+\"+_ else \"+\"+x).mkString(\" \") -> \"YES\"\n        else \"\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvse0bt5k.scala:22:8 ----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[31m\"\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        'then' expected, but 'else'\
    \ found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvse0bt5k.scala:21:87 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        evenAndOdd.filter(\e[36mx\e[0m => lst1.contains(x)).toList.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (lst1.contains(x)).toList.map(\e[36mx\e[0m => (x,x)).toSet.toList.map(\e\
    [36mx\e[0m => x(\e[31m0\e[0m) + x(\e[31m1\e[0m)).map(\e[31m\"+\"\e[0m+_).map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == x) \e[31m\"+\"\e[0m+_ \e[33melse\e[0m \e[31m\"\
    +\"\e[0m+x).mkString(\e[31m\" \"\e[0m) -> \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value toList is not a member\
    \ of Boolean\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpvse0bt5k.scala:23:4\
    \ -----------------\e[0m\e[0m\n\e[33m22 |\e[0m        \e[33melse\e[0m \e[31m\"\
    \"\e[0m\n\e[33m23 |\e[0m    }\n\e[33m\e[33m   |\e[0m               ^\e[0m\n\e\
    [33m   |\e[0mA pure expression does nothing in statement position; you may be\
    \ omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val count = new HashMap[Long,Int]()\n        for (i <- lst1 diff lst2){\n  \
    \          val count = count.getOrElse(i, 0) + 1\n            if (count == 2){\n\
    \                return \"YES\"\n            }\n            count.put(i, count)\n\
    \        }\n        return \"NO\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp60nlo5yc.scala:20:24 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mcount\e[0m = count.getOrElse(i,\
    \ \e[31m0\e[0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^\e\
    [0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e[0m \e[35mcount\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxlbzok_2.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659794623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var evenNums = lst1.filter(x => x % 2 == 0).sortWith((a,\
    \ b) => a < b).map(x => x.toLong)\n        var oddNums = lst2.filter(x => x %\
    \ 2 == 1).sortWith((a, b) => a < b).map(x => x.toLong)\n        var exchanged\
    \ = evenNums.intersect(oddNums).map(x => x + 1).toList\n        if (exchanged.isEmpty)\
    \ {\n            return \"NO\"\n        } else {\n            return \"YES\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmjqt4_h3.scala:29)\n\tat Problem.main(tmpmjqt4_h3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Replace this line by code that solves the problem\n        // Explain\
    \ in words the steps you need to take to solve the problem\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpotewqvzc.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO: Replace this line by code that\
    \ solves the problem\e[0m\n\e[31m19 |\e[0m        \e[34m// Explain in words the\
    \ steps you need to take to solve the problem\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1 == null || lst2 == null || lst1.isEmpty) {\n            lst1 match\
    \ {\n                case Nil => \"NO\"\n                case _ => \"YES\"\n \
    \           }\n        }\n        if (lst1 == null || lst2 == null || lst2.isEmpty)\
    \ {\n            lst2 match {\n                case Nil => \"NO\"\n          \
    \      case _ => \"YES\"\n            }\n        }\n        var temp1 = lst1.drop(1).toList\n\
    \        var temp2 = lst2.drop(1).toList\n        val lst1_copy = temp1.takeWhile(_\
    \ % 2 == 0)\n        val lst2_copy = temp2.takeWhile(_ % 2 == 0)\n        temp1\
    \ = lst1_copy.reverse\n        temp2 = lst2_copy.reverse\n        if (lst1.size\
    \ == lst2.size) {\n            var found = 0\n            var result = \"NO\"\n\
    \            var index = 0\n            while (index != lst1_copy.size) { //while\
    \ not equal\n                if (lst2_copy(index) == lst1_copy(index)) {\n   \
    \                 found += 1\n                    val temp1 = lst1_copy.take(found).toList\n\
    \                    val temp2 = lst2_copy.take(found).toList\n              \
    \      temp1 = temp1.reverse\n                    temp2 = temp2.reverse\n    \
    \                lst1_copy = temp1\n                    lst2_copy = temp2\n  \
    \              } else {\n                    if (found == (lst1_copy.size - 1))\
    \ {\n                        result = \"YES\"\n                    }\n       \
    \         }\n                index += 1\n            }\n            result\n \
    \       }\n        else {\n            \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpp2an34zo.scala:45:26 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    temp1 = temp1.reverse\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                Reassignment to val temp1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpp2an34zo.scala:46:26 -----------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m                    temp2 = temp2.reverse\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val temp2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpp2an34zo.scala:47:30 -----------------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m                    lst1_copy = temp1\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \     Reassignment to val lst1_copy\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpp2an34zo.scala:48:30 -----------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                    lst2_copy = temp2\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val lst2_copy\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning:\
    \ /tmp/tmpp2an34zo.scala:20:28 ----------------\e[0m\e[0m\n\e[33m20 |\e[0m   \
    \             \e[33mcase\e[0m Nil => \e[31m\"NO\"\e[0m\n\e[33m\e[33m   |\e[0m\
    \                            ^^^^\e[0m\n\e[33m   |\e[0mA pure expression does\
    \ nothing in statement position; you may be omitting necessary parentheses\n\e\
    [33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpp2an34zo.scala:21:26\
    \ ----------------\e[0m\e[0m\n\e[33m21 |\e[0m                \e[33mcase\e[0m _\
    \ => \e[31m\"YES\"\e[0m\n\e[33m\e[33m   |\e[0m "
  stdout: ''
  timestamp: 1659979851
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Complete this function\n        var i = 1\n        var j = 1\n    \
    \    var found = false\n        var exchanged_element_count = 0\n        while(i\
    \ < lst1.length && j < lst2.length) {\n            if(lst1(i) == lst2(j)) {\n\
    \                found = true\n                exchanged_element_count += 1\n\
    \                i += 1\n                j += 1\n            }\n            else\
    \ if(found == true) {\n                if(exchanged_element_count == lst1.length\
    \ - 1){\n                    if((lst1(i) % (lst2(j)))==0) {\n                \
    \        found = false\n                    }\n                    else {\n  \
    \                      i += 1\n                        j += 1\n              \
    \      }\n                }\n                else {\n                    i +=\
    \ 1\n                }\n            }\n            else {\n                i +=\
    \ 1\n            }\n        }\n        while(i < lst1.length) {\n            if(lst1(i)\
    \ != 0) {\n                found = true\n                exchanged_element_count\
    \ += 1\n                i += 1\n            }\n            else {\n          \
    \      i += 1\n            }\n        }\n        while(j < lst2.length) {\n  \
    \          if(lst2(j) != 0) {\n                found = true\n                exchanged_element_count\
    \ += 1\n                j += 1\n            }\n            else {\n          \
    \      j += 1\n            }\n        }\n        if(exchanged_element_count ==\
    \ lst1.length)\n            return \"NO\"\n        else\n            return \"\
    YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuwc40irt.scala:75)\n\tat Problem.main(tmpuwc40irt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty)\n           if(lst2.isEmpty)\n              return \"NO\"\n\
    \           else\n              return \"YES\"\n        else\n           if(lst2.isEmpty)\n\
    \              return \"YES\"\n           else\n              return  exchange(lst1.tail,\
    \ lst2.tail).map(\"YES\").orElse(\"NO\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpptb4ee1a.scala:27:57\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m              \e[33mreturn\e\
    [0m  exchange(lst1.tail, lst2.tail).map(\e[31m\"YES\"\e[0m).orElse(\e[31m\"NO\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                                                \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \      Found:    (\e[32m\"YES\"\e[0m : String)\n\e[31m   |\e[0m              \
    \                                Required: Char => <?>\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979856
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: implement the function here\n        return \"NO\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkcpy3c25.scala:22)\n\tat Problem.main(tmpkcpy3c25.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val first = lst1(0)\n        val second = lst2(0)\n        val exchanged = mutable.LinkedListBuffer.empty[Long]\n\
    \        val even = mutable.LinkedListBuffer.empty[Long]\n\n        var temp =\
    \ second\n        var j = 0\n        lst2.remove(second)\n        lst1.remove(first)\n\
    \        lst2.remove(temp)\n        lst1.remove(temp)\n        lst1 foreach {\n\
    \            x => exchanged += x\n        }\n\n        lst2 foreach {\n      \
    \      x => even += x\n        }\n\n        if (exchanged.size == 0 && even.size\
    \ == 0){\n            return \"YES\"\n        }else{\n            return \"NO\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr7equsq6.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mexchanged\e[0m = mutable.LinkedListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr7equsq6.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = mutable.LinkedListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpr7equsq6.scala:25:13 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        lst2.remove(second)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value remove is not a member of List[Long]\
    \ - did you mean lst2.reduce?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr7equsq6.scala:26:13\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        lst1.remove(first)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr7equsq6.scala:27:13\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        lst2.remove(temp)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is\
    \ not a member of List[Long], but could be made available as an extension"
  stdout: ''
  timestamp: 1659979859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // DO NOT USE Arrays or Lists.\n        // Arrays cannot be modified.\n    \
    \    // Lists cannot be modified.\n        \n        lst1.toSet.intersect(lst2.toSet).forall(x\
    \ => x % 2 == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxfqq012.scala:22:47\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        lst1.toSet.intersect(lst2.toSet).forall(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    Boolean\n\e[31m   |\e[0m        Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst3 = lst1.takeWhile( x => lst2.contains(x)\
    \ )\n        val lst4 = lst2.takeWhile( x => lst1.contains(x) )\n        if(lst3.length\
    \ == 0){\n            \"NO\"\n        }else if(lst4.length == 0){\n          \
    \  \"NO\"\n        }else{\n            \"YES\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpudk96obb.scala:31)\n\tat Problem.main(tmpudk96obb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var lst1Len = lst1.length\n        var lst2Len = lst2.length\n        var res\
    \ = \"\"\n\n        while(lst1Len != lst2Len){\n            var temp = lst1.head\n\
    \            lst1.head = (lst1.head % 2l).toLong\n            lst1.head = (lst1.head\
    \ + temp%2l).toLong\n            lst1.tail -= (lst2.head % 2l).toLong\n      \
    \      lst2.head = (lst2.head + temp%2l).toLong\n            lst2.tail -= (lst1.head\
    \ % 2l).toLong\n            res = res + \"YES\"\n        }\n        if(lst1.length\
    \ == 0 && lst2.length == 0){\n            res = \"NO\"\n        }\n        else\
    \ if(lst1.length == 0){\n            res = res + \"NO\"\n        }\n        else{\n\
    \            res = res + \"NO\"\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp363t45ap.scala:24:22 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            lst1.head = (lst1.head % \e[31m2l\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            Reassignment to val head\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp363t45ap.scala:25:22 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            lst1.head = (lst1.head + temp%\e[31m2l\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val head\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp363t45ap.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            lst1.tail -= (lst2.head % \e[31m2l\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue -= is\
    \ not a member of List[Long @uncheckedVariance] - did you mean List[Long @uncheckedVariance].!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp363t45ap.scala:27:22 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            lst2.head = (lst2.head + temp%\e[31m2l\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val head\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp363t45ap.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            lst2.tail -= (lst1.head % \e[31m2l\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue -= is\
    \ not a member of List[Long @uncheckedVariance] - did you mean List[Long @uncheckedVariance].!=?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Solution here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpherib0y7.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Solution here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val temp1 = lst1.toSet\n        val temp2 = lst2.toSet\n        temp1 -- temp2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5jjqr5nf.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        temp1 -- temp2\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Set[Long]\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979860
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) return \"NO\"\n        val lst3 = lst1.filter(_.toLong % 2\
    \ == 0)\n        if(lst3.isEmpty) return \"NO\"\n        val l1 = lst3.head +\
    \ 1\n        val l2 = lst3.last\n        val l3 = lst2.head + 1\n        val l4\
    \ = lst2.last\n        if(l1 == l2 && l2 == l3) \"YES\"\n        else if(l1 ==\
    \ l2 && l2 != l3) \"NO\"\n        else if(l1 == l2 && l3 == l4) \"NO\"\n     \
    \   else if(l1 == l2 && l2 != l4) \"YES\"\n        else if(l1 == l3 && l2 == l4)\
    \ \"NO\"\n        else if(l1 == l3 && l2 != l4) \"YES\"\n        else if(l1 ==\
    \ l4 && l2 == l3) \"NO\"\n        else if(l1 == l4 && l2 != l3) \"YES\"\n    \
    \    else exchange(lst1, lst2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst3 = lst1.toList\n        val lst4 = lst2.toList\n        val lst5 = lst3.filter(_\
    \ % 2 == 0).filter(_ != 2l.toLong)\n        val lst6 = lst4.filter(_ % 2 == 0).filter(_\
    \ != 2l.toLong)\n        if(lst5.size == lst6.size){\n            return \"NO\"\
    \n        }\n        var i = 0\n        var j = 0\n        while(i < lst5.size\
    \ && j < lst6.size){\n            if(lst5(i) > lst6(j)){\n                lst3(j)\
    \ = lst5(i)\n                lst5(i) = lst6(j)\n                lst6(j) = 2l.toLong\n\
    \                j++\n            }\n            else{\n                lst3(j)\
    \ = lst5(i)\n                lst5(i) = lst6(j)\n                lst6(j) = 2l.toLong\n\
    \                i++\n            }\n        }\n        if(lst5.size == lst6.size){\n\
    \            return \"YES\"\n        }\n        lst3.toList.foreach(println)\n\
    \        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpycf_03_n.scala:32:19 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpycf_03_n.scala:38:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                i++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpycf_03_n.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                lst3(j) = lst5(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of\
    \ List[Long] - did you mean lst3.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpycf_03_n.scala:30:16 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                lst5(i) = lst6(j)\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did you mean\
    \ lst5.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycf_03_n.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                lst6(j) =\
    \ \e[31m2l\e[0m.toLong\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m\
    \   |\e[0m value update is not a member of List[Long] - did you mean lst6.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycf_03_n.scala:35:16 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                lst3(j) = lst5(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of\
    \ List[Long] - did you mean lst3.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpycf_03_n.scala:36:16 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m                lst5(i) = lst6(j)\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did you mean "
  stdout: ''
  timestamp: 1659979863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1 ++ lst2.filter( x => x % 2 == 0 ) match {\n            case x :: y => if\
    \ (x.toDouble == y.toDouble) \"YES\" else \"NO\"\n            case x :: y => \"\
    NO\"\n            case _ => \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpawusrm0k.scala:19:47 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m x :: y => \e[33mif\e[0m (x.toDouble\
    \ == y.toDouble) \e[31m\"YES\"\e[0m \e[33melse\e[0m \e[31m\"NO\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue toDouble is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var even = lst1 filter { _ % 2 == 0 }\n        var odd = lst2 filter { _ % 2\
    \ == 1 }\n        if (even.isEmpty || odd.isEmpty) {\n            return \"NO\"\
    \n        }\n        val evenlist = even.map(_.toLong)\n        val oddlist =\
    \ odd.map(_.toLong)\n        val neweven = evenlist.zip(oddlist).map { case (e1,\
    \ e2) => e1.toLong to e2.toLong }.toMap\n        val newodd = evenlist.zip(oddlist).map\
    \ { case (e1, e2) => e2.toLong to e1.toLong }.toMap\n        if (neweven.keySet.forall(newodd.contains))\
    \ return \"YES\"\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpz227isdq.scala:25:97 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mneweven\e[0m = evenlist.zip(oddlist).map\
    \ { \e[33mcase\e[0m (e1, e2) => e1.toLong to e2.toLong }.toMap\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                             ^\e[0m\n\e[31m   |\e[0mCannot prove that scala.collection.immutable.NumericRange.Inclusive[Long]\
    \ <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    K is a type variable\n\
    \e[31m   |\e[0m          V is a type variable\n\e[31m   |\e[0m.\n\e[31m\e[31m--\
    \ Error: /tmp/tmpz227isdq.scala:26:96 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnewodd\e[0m = evenlist.zip(oddlist).map\
    \ { \e[33mcase\e[0m (e1, e2) => e2.toLong to e1.toLong }.toMap\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                            ^\e[0m\n\e[31m   |\e[0mCannot prove that scala.collection.immutable.NumericRange.Inclusive[Long]\
    \ <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    K is a type variable\n\
    \e[31m   |\e[0m          V is a type variable\n\e[31m   |\e[0m.\n2 errors found\n"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkyot22ev.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Your code here!\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7jrwetfo.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO: Your code here!\e[0m\n\e[31m19\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979862
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evenList = lst1.filter(_ % 2 == 0).sortWith(_ < _)\n        val oddList\
    \ = lst2.filter(_ % 2 != 0).sortWith(_ < _)\n        val evenListLength = evenList.length\n\
    \        val oddListLength = oddList.length\n        if (evenListLength == 0)\
    \ \"NO\" else if (oddListLength == 0) \"YES\" else if (evenListLength <= oddListLength)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp6x3uhpt.scala:26)\n\tat Problem.main(tmpp6x3uhpt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ def allEven(lst: List): Boolean = {\n          lst.filter{ x => x % 2 == 0 }.size\
    \ == lst.size \n        }\n        if(lst1 == lst2 || lst2 == lst1 && !allEven(lst2)\
    \ ) {\n            return \"YES\"\n        } else {\n            return \"NO\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E056] Syntax Error: /tmp/tmpeg_b6anw.scala:18:25 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mdef\e[0m \e[36mallEven\e[0m(\e[36mlst\e\
    [0m: \e[35mList\e[0m): \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                         Missing type\
    \ parameter for List\n1 error found\n"
  stdout: ''
  timestamp: 1659979859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1 map {n => (n % 2 == 0 && lst2 contains n) match {\n            case true\
    \ => \"YES\"\n            case false => \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjwuemz0y.scala:34:0 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjwuemz0y.scala:18:38\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        lst1 map {\e[36mn\e[0m\
    \ => (n % \e[31m2\e[0m == \e[31m0\e[0m && lst2 contains n) \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                      Found:    (lst2 : List[Long])\n\
    \e[31m   |\e[0m                                      Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjwuemz0y.scala:33:1 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpjwuemz0y.scala:23:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m23 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659979864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: define your solution here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfmyvtqnk.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO: define your solution here\e[0m\n\
    \e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evens = lst1.filter(x => x % 2l.toLong == 0l.toLong)\n        val odds =\
    \ lst2.filter(x => x % 2l.toLong != 0l.toLong)\n        var even = 0\n       \
    \ var odd = 0\n        var c = 0\n        var i = 0\n        var j = 0\n     \
    \   var even1 = 0\n        var odd1 = 0\n        var even2 = 0\n        var odd2\
    \ = 0\n        while (c < evens.size || c < evens.size + odds.size) {\n      \
    \      if (c < evens.size) {\n                if (odd < evens.size) {\n      \
    \              if (odd1 >= evens.size + odds.size) {\n                       \
    \ even1 += even(c).toLong\n                        odd1 += odd(c).toLong\n   \
    \                     even1 += even1\n                        odd1 += odd1\n \
    \                   } else {\n                        even1 += even(c).toLong\n\
    \                        even1 += even1\n                    }\n             \
    \   } else {\n                    if (even1 >= evens.size + odds.size) {\n   \
    \                     even1 += even(c).toLong\n                        even1 +=\
    \ even1\n                    } else {\n                        even1 += even(c).toLong\n\
    \                        even1 += even1\n                    }\n             \
    \   }\n                even += even1\n                even1 += even(c).toLong\n\
    \            }\n            if (c < evens.size + odds.size) {\n              \
    \  if (odd < odds.size) {\n                    if (odd2 >= evens.size + odds.size)\
    \ {\n                        odd2 += odd(c).toLong\n                        odd2\
    \ += odd1\n                        even2 += even(c).toLong\n                 \
    \       even2 += even2\n                    } else {\n                       \
    \ odd2 += odd(c).toLong\n                        odd2 += odd2\n              \
    \      }\n                } else {\n                    if (even2 >= evens.size\
    \ + odds.size) {\n                        even2 += even(c).toLong\n          \
    \              even2 += even2\n                    } else {\n                \
    \        even2 += even(c).toLong\n                        even2 += even2\n   \
    \                 }\n                }\n                odd += odd2\n        \
    \        odd2 += odd(c).toLong\n            }\n            c += 2\n        }\n\
    \        if (even % 2l.toLong == 0l.toLong) {\n            if (odd % 2l.toLong\
    \ == 0l.toLong) {\n                return \"NO\"\n            } else {\n     \
    \           return \"YES\"\n            }\n        } else {\n            if (odd\
    \ % 2l.toLong == 0l.toLong) {\n                return \"YES\"\n            } else\
    \ {\n                return \"NO\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuzjzsfpy.scala:33:30 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        even1 += even(c).toLong\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \        value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmpuzjzsfpy.scala:33:33 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        even1 += even(c).toLong\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            \e[33mvariable\e[0m \e[35meven\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuzjzsfpy.scala:34:29\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                        odd1\
    \ += odd(c).toLong\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpuzjzsfpy.scala:34:32 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        odd1 += odd(c).toLong\n\e[31m\e\
    [31m   |\e[0m                                ^^^\e[0m\n\e[31m   |\e[0m       \
    \                         \e[33mvariable\e[0m \e[35modd\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuzjzsfpy.scala:38:30\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                        even1\
    \ += even(c).toLong\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpuzjzsfpy.scala:38:33 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                        even1 += even(c).toLong\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            \e[33mvariable\e[0m \e[35meven\e[0m does not take\
    \ parameters\n\e[31m   |"
  stdout: ''
  timestamp: 1659979865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1 match {\n            case x :: Nil => \"NO\"\n            case y :: Nil\
    \ => \"YES\"\n            case x :: y :: xs => {\n                val i = lst1.indexOf(x)\n\
    \                val j = lst2.indexOf(y)\n                if (i < j) {\n     \
    \               if (i==0) {\n                        val temp = lst1(1); lst1(1)\
    \ =lst2(1); lst2(1) = temp\n                        exchange(lst1, lst2)\n   \
    \                 } else {\n                        val temp = lst1(1); lst1(1)\
    \ =lst2(1); lst2(1) = temp\n                        exchange(lst1, lst2)\n   \
    \                 }\n                } else {\n                    if (j==0) {\n\
    \                        val temp = lst1(1); lst1(1) =lst2(1); lst2(1) = temp\n\
    \                        exchange(lst1, lst2)\n                    } else {\n\
    \                        val temp = lst1(1); lst1(1) =lst2(1); lst2(1) = temp\n\
    \                        exchange(lst1, lst2)\n                    }\n       \
    \         }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ubi6kew.scala:26:44 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        \e[33mval\e[0m \e[36mtemp\e[0m\
    \ = lst1(\e[31m1\e[0m); lst1(\e[31m1\e[0m) =lst2(\e[31m1\e[0m); lst2(\e[31m1\e\
    [0m) = temp\n\e[31m\e[31m   |\e[0m                                           \
    \ ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did\
    \ you mean lst1.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ubi6kew.scala:26:62\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                        \e\
    [33mval\e[0m \e[36mtemp\e[0m = lst1(\e[31m1\e[0m); lst1(\e[31m1\e[0m) =lst2(\e\
    [31m1\e[0m); lst2(\e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e[0m                \
    \                                              ^^^^\e[0m\n\e[31m   |\e[0m value\
    \ update is not a member of List[Long] - did you mean lst2.updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0ubi6kew.scala:29:44 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        \e[33mval\e[0m \e[36mtemp\e[0m\
    \ = lst1(\e[31m1\e[0m); lst1(\e[31m1\e[0m) =lst2(\e[31m1\e[0m); lst2(\e[31m1\e\
    [0m) = temp\n\e[31m\e[31m   |\e[0m                                           \
    \ ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did\
    \ you mean lst1.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ubi6kew.scala:29:62\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                        \e\
    [33mval\e[0m \e[36mtemp\e[0m = lst1(\e[31m1\e[0m); lst1(\e[31m1\e[0m) =lst2(\e\
    [31m1\e[0m); lst2(\e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e[0m                \
    \                                              ^^^^\e[0m\n\e[31m   |\e[0m value\
    \ update is not a member of List[Long] - did you mean lst2.updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0ubi6kew.scala:34:44 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        \e[33mval\e[0m \e[36mtemp\e[0m\
    \ = lst1(\e[31m1\e[0m); lst1(\e[31m1\e[0m) =lst2(\e[31m1\e[0m); lst2(\e[31m1\e\
    [0m) = temp\n\e[31m\e[31m   |\e[0m                                           \
    \ ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did\
    \ you mean lst1.updated?\n\e[31m\e[31m--"
  stdout: ''
  timestamp: 1659979865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code in here.\n        var i = lst1.head - 1\n        var\
    \ j = lst2.head - 1\n        var count = 0\n        while (i <= j) {\n       \
    \     if (lst1(j) % lst1(i) == 0) {\n                count += 1\n            }\
    \ else {\n                count -= 1\n            }\n            i += 1\n    \
    \        j -= 1\n        }\n        if (count == 0) {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx3kbrthf.scala:23:21\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (lst1(j)\
    \ % lst1(i) == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                     ^\e\
    [0m\n\e[31m   |\e[0m                     Found:    (j : Long)\n\e[31m   |\e[0m\
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpx3kbrthf.scala:23:31 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33mif\e[0m (lst1(j) % lst1(i) == \e[31m0\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     Found:    (i : Long)\n\e[31m   |\e[0m                  \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979864
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ //Write your code here\n        \n        if (lst1.isEmpty) {\n            lst1\
    \ +: lst2\n        }\n        if (lst2.isEmpty) {\n            lst1 +: lst2\n\
    \        }\n        if (lst1.isEmpty && lst2.isEmpty) {\n            lst1 +: lst2\n\
    \        }\n        if (lst1.isEmpty) {\n            lst1 +: lst2\n        }\n\
    \        if (lst2.isEmpty) {\n            lst1 +: lst2\n        }\n        if\
    \ (lst1.isEmpty || lst2.isEmpty) {\n            \"NO\"\n        }\n        \n\
    \        val lst1_even = lst1.filter(x => x % 2 == 0).toList\n        val lst2_even\
    \ = lst2.filter(x => x % 2 == 0).toList\n        if (lst1_even.isEmpty || lst2_even.isEmpty)\
    \ {\n            \"NO\"\n        }\n        var lst3 = lst1.toList\n        lst3\
    \ ++= lst2\n        lst3 ++= lst2_even\n        lst3 ++= lst1_even\n        //lst3\
    \ ++= lst1.filter(x => x % 2 == 0)\n        //lst3 ++= lst2.filter(x => x % 2\
    \ == 0)\n        val isEven = lst3.filter(x => x % 2 == 0).toList.size == lst3.size\n\
    \        val result = if (isEven) \"YES\" else \"NO\"\n        \n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6k5sh0bp.scala:56)\n\tat Problem.main(tmp6k5sh0bp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Implement me\n        val len = lst1.length\n        val len2 = lst2.length\n\
    \        val ev = mutable.Buffer[Long]()\n        if(len == 0 || len2 == 0){\n\
    \            \"\"\n        }else{\n            for(i<- 0 until len){\n       \
    \         if(lst1(i) ==  lst2(i)){\n                    ev += lst1(i)\n      \
    \          }\n            }\n            val even = ev.filter(x => x % 2 == 0)\n\
    \            if(even.length == 0){\n                return \"NO\"\n          \
    \  }else{\n                \"\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqmfl7dej.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mev\e[0m = mutable.Buffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var count = 0\n        for( i <- 0 until lst1.length\
    \ ){\n            if( lst1(i) == lst2(0) ){\n                count += 1\n    \
    \        }\n        }\n        if( count == lst2.length ) {\n            val even\
    \ = lst1.filter { x => x % 2 == 0 }\n            val evenList = even.mkString\n\
    \            val odd = lst2.filter { x => x % 2 == 1 }\n            val oddList\
    \ = odd.mkString\n            if( (evenList == even) && (oddList == odd) ){\n\
    \                return \"YES\"\n            }\n        }\n        return \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxc7cvatf.scala:30:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m( (evenList == even) && (oddList\
    \ == odd) ){\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m  Values of types String and List[Long] cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmpxc7cvatf.scala:30:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m( (evenList == even) && (oddList\
    \ == odd) ){\n\e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  Values of types String and List[Long] cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659979868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your code here.\n        var lst1 : (List[Long], List[Long]) = (lst1,\
    \ lst2)\n        var lst2 : List[Long] = lst1\n        var temp : List[Long] =\
    \ lst1\n        for (l1 <- lst1 :: lst2) {\n            if (l1 % 2 == 0) {\n \
    \               lst1.remove(l1)\n                lst2.remove(l1)\n           \
    \ }\n        }\n        if (lst2.isEmpty) {\n            return \"YES\"\n    \
    \    } else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4dbaxau6.scala:19:47\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mlst1\e\
    [0m : (\e[35mList\e[0m[\e[35mLong\e[0m], \e[35mList\e[0m[\e[35mLong\e[0m]) = (lst1,\
    \ lst2)\n\e[31m\e[31m   |\e[0m                                               ^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (lst1 : (List[Long],\
    \ List[Long]))\n\e[31m   |\e[0m                             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4dbaxau6.scala:20:32\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mlst2\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = lst1\n\e[31m\e[31m   |\e[0m         \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \  Found:    (lst1 : (List[Long], List[Long]))\n\e[31m   |\e[0m              \
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4dbaxau6.scala:21:32 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mtemp\e[0m : \e[35mList\e[0m[\e\
    [35mLong\e[0m] = lst1\n\e[31m\e[31m   |\e[0m                                ^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (lst1 : (List[Long],\
    \ List[Long]))\n\e[31m   |\e[0m                             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4dbaxau6.scala:23:19\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m\
    \ (l1 % \e[31m2\e[0m == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of Matchable, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might make progress towards fixing the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4d"
  stdout: ''
  timestamp: 1659979871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.foreach { (x @ _) =>\n            lst2.foreach { (y @ _) =>\n         \
    \       if (x != y && x * y == x)\n                    return \"YES\"\n      \
    \      }\n        }\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp95mk2yau.scala:18:26 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst1.foreach { (\e[36mx\e[0m @ _) =>\n\e[31m\e\
    [31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m               \
    \           ')' expected, but '@' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp95mk2yau.scala:19:30\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            lst2.foreach\
    \ { (\e[36my\e[0m @ _) =>\n\e[31m\e[31m   |\e[0m                             \
    \ ^\e[0m\n\e[31m   |\e[0m                              ')' expected, but '@' found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979866
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val a = lst1 diff lst2\n        val b = lst1 diff a\n        val c = a diff\
    \ lst2\n        val d = a diff c\n        val e = b diff c\n        val f = b\
    \ diff e\n        val g = c diff e\n        val h = c diff f\n        val i =\
    \ d diff f\n        val j = d diff h\n        val k = e diff h\n        val l\
    \ = e diff k\n        val m = f diff k\n        val n = f diff l\n        val\
    \ o = g diff l\n        val p = g diff m\n        val q = h diff m\n        val\
    \ r = h diff n\n        val s = i diff n\n        val t = i diff o\n        val\
    \ u = j diff o\n        val v = j diff p\n        val w = k diff p\n        val\
    \ x = k diff q\n        val y = l diff q\n        val z = l diff r\n\n       \
    \ if(a.contains(0l) || b.contains(0l) ||\n            c.contains(0l) || d.contains(0l)\
    \ ||\n            e.contains(0l) || f.contains(0l) ||\n            g.contains(0l)\
    \ || h.contains(0l) ||\n            i.contains(0l) || j.contains(0l) ||\n    \
    \        k.contains(0l) || l.contains(0l) ||\n            m.contains(0l) || n.contains(0l)\
    \ ||\n            o.contains(0l) || p.contains(0l) ||\n            q.contains(0l)\
    \ || r.contains(0l) ||\n            s.contains(0l) || t.contains(0l) ||\n    \
    \        u.contains(0l) || v.contains(0l) ||\n            w.contains(0l) || x.contains(0l)\
    \ ||\n            y.contains(0l) || z.contains(0l)) {\n            return \"NO\"\
    \n        }\n        else {\n            return \"YES\"\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4slxdg1s.scala:66)\n\tat Problem.main(tmp4slxdg1s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ def exchange(lst1 : List[Long], lst2 : List[Long], result : List[Long]) : String\
    \ = {\n            val numExchanged : Int = 0\n            val newResult = result.take(result.size)\n\
    \            val newLst = newResult.filter(x => x % 2 == 0).map(x => x - 1).toList\n\
    \            val newLst1 = lst1.filter(x => x % 2 == 0).map(x => x - 1).toList\n\
    \            val newLst2 = lst2.filter(x => x % 2 == 0).map(x => x - 1).toList\n\
    \            newLst match {\n                case Nil =>\n                   \
    \ if (newResult.size == 0){\n                        result\n                \
    \    } else {\n                        exchange(newLst1, newLst2, newResult)\n\
    \                    }\n                case x => exchange(newLst1, newLst2, newResult\
    \ ++ newLst)\n            }\n        }\n        exchange(lst1, lst2, Nil).mkString(\"\
    \ \")\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5hnfessd.scala:27:24\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                        result\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                    Found:    (result : List[Long])\n\e[31m   |\e[0m        \
    \                Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var count = 0\n        var j = 0\n        var k = 0\n        var n = 0\n   \
    \     while(j < lst1.length && k < lst2.length) {\n            if(lst1(j) == lst2(k))\
    \ {\n                count += 1\n                j += 1\n                k +=\
    \ 1\n            }\n            else if(lst1(j) < lst2(k)) {\n               \
    \ j += 1\n            }\n            else {\n                k += 1\n        \
    \    }\n        }\n        if(count != lst1.length) {\n            return \"NO\"\
    \n        }\n        else if(count == lst1.length) {\n            var count =\
    \ 0\n            var n = 0\n            while(n < lst1.length) {\n           \
    \     if(lst1(n) % 2 == 0) {\n                    count += 1\n               \
    \ }\n                n += 1\n            }\n            if(count != lst1.length)\
    \ {\n                return \"NO\"\n            }\n            else {\n      \
    \          return \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4c6jtylj.scala:38:13\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m(count == lst1.length) {\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m\
    \   |\e[0m             Found:    Unit\n\e[31m   |\e[0m             Required: String\n\
    \e[31m   |\e[0m             Maybe you are missing an else part for the conditional?\n\
    \e[31m39 |\e[0m            \e[33mvar\e[0m count = \e[31m0\e[0m\n\e[31m40 |\e[0m\
    \            \e[33mvar\e[0m n = \e[31m0\e[0m\n\e[31m41 |\e[0m            \e[33mwhile\e\
    [0m(n < lst1.length) {\n\e[31m42 |\e[0m                \e[33mif\e[0m(lst1(n) %\
    \ \e[31m2\e[0m == \e[31m0\e[0m) {\n\e[31m43 |\e[0m                    count +=\
    \ \e[31m1\e[0m\n\e[31m44 |\e[0m                }\n\e[31m45 |\e[0m            \
    \    n += \e[31m1\e[0m\n\e[31m46 |\e[0m            }\n\e[31m47 |\e[0m        \
    \    \e[33mif\e[0m(count != lst1.length) {\n\e[31m48 |\e[0m                \e\
    [33mreturn\e[0m \e[31m\"NO\"\e[0m\n\e[31m49 |\e[0m            }\n\e[31m50 |\e\
    [0m            \e[33melse\e[0m {\n\e[31m51 |\e[0m                \e[33mreturn\e\
    [0m \e[31m\"YES\"\e[0m\n\e[31m52 |\e[0m            }\n\e[31m53 |\e[0m        }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code goes here\n        var result = \"NO\"\n        for(i <- 0 until\
    \ lst1.length){\n            var a = lst1(i).toInt\n            var b = lst2(i).toInt\n\
    \            var c = a * b\n            if(c % 2 == 0){\n                result\
    \ = \"YES\"\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr0dd9b27.scala:32)\n\tat Problem.main(tmpr0dd9b27.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979873
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.size == 0)\n            \"\"\n        else if(lst2.size == 0)\n    \
    \        exchange(lst2.tail, lst1.tail)\n        else {\n            val firstEven\
    \ = lst1.filter(v => v.toInt == 0).toList\n            val secondEven = lst2.filter(v\
    \ => v.toInt == 0).toList\n            if(firstEven.size == lst1.size && secondEven.size\
    \ == lst2.size)\n                exchange(lst1.tail, lst2.tail)\n            else\
    \ if(firstEven.size != lst1.size || secondEven.size != lst2.size)\n          \
    \      \"NO\"\n            else\n                exchange(firstEven, secondEven)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz5ooyltk.scala:34)\n\tat Problem.main(tmpz5ooyltk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1 filter (x => x % 2 == 0)\n        val odd = lst2 filter (x =>\
    \ x % 2 == 1)\n        val evenEven = even zip odd.map(x => x._1 -> x._2)\n  \
    \      val evenOdd = even zip odd.map(x => x._2 -> x._1)\n        val evenEvenOddEven\
    \ = evenEven zip evenOdd.map(x => x._1 -> x._2)\n        val evenEvenOddOdd =\
    \ evenEvenOdd zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOdd\
    \ = evenEvenOddEven zip evenOdd.map(x => x._1 -> x._2)\n        val evenEvenOddEvenOddOdd\
    \ = evenEvenOddEvenOdd zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOddEvenOdd\
    \ = evenEvenOddEvenOddEven zip evenOdd.map(x => x._1 -> x._2)\n        val evenEvenOddEvenOddEvenOddOdd\
    \ = evenEvenOddEvenOddEvenOdd zip evenOdd.map(x => x._2 -> x._1)\n        val\
    \ evenEvenOddEvenOddEvenOddEvenOdd = evenEvenOddEvenOddEvenOddOdd zip evenOdd.map(x\
    \ => x._1 -> x._2)\n        val evenEvenOddEvenOddEvenOddEvenOddOdd = evenEvenOddEvenOddEvenOddEvenOdd\
    \ zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOddEvenOddEvenOddEvenOdd\
    \ = evenEvenOddEvenOddEvenOddEvenOddOdd zip evenOdd.map(x => x._1 -> x._2)\n \
    \       val evenEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = evenEvenOddEvenOddEvenOddEvenOddEvenOddOdd\
    \ zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd\
    \ = evenEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddO\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0lf9v699.scala:20:47 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mevenEven\e[0m = even zip\
    \ odd.map(\e[36mx\e[0m => x._1 -> x._2)\n\e[31m\e[31m   |\e[0m               \
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                    value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp0lf9v699.scala:21:46 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36mevenOdd\e[0m = even zip odd.map(\e\
    [36mx\e[0m => x._2 -> x._1)\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \       value _2 is not a member of Long\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0lf9v699.scala:23:29 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mevenEvenOddOdd\e[0m = evenEvenOdd zip evenOdd.map(\e\
    [36mx\e[0m => x._2 -> x._1)\n\e[31m\e[31m   |\e[0m                           \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found: evenEvenOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0lf9v699.scala:25:81\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mevenEvenOddEvenOddOdd\e[0m = evenEvenOddEvenOdd zip evenOdd.map(\e[36mx\e\
    [0m => x._2 -> x._1)\n\e[31m\e[31m   |\e[0m                                  \
    \                                          ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                value -> is not a member of Nothing\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0lf9v699.scala:26:40 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mevenEvenOddEvenOddEvenOdd\e\
    [0m = evenEvenOddEvenOddEven zip evenOdd.map(\e[36mx\e[0m => x._1 -> x._2)\n\e\
    [31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Not found: evenEvenOddEvenOddEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `"
  stdout: ''
  timestamp: 1659979874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkyot22ev.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) {\n            \"\"\n        } else if(lst2.isEmpty) {\n  \
    \          \"\"\n        } else {\n            val evenList = lst1.filter(_ %\
    \ 2 == 0).map(x => x % 2 == 0).filter(x => lst2.contains(x))\n            if(evenList.forall(x=>x)){\n\
    \                \"YES\"\n            } else {\n                \"NO\"\n     \
    \       }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpghu3h0zz.scala:33)\n\tat Problem.main(tmpghu3h0zz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here.\n        var lst3 = lst1.sorted\n        var lst4 = lst2.sorted\n\
    \        var even = 0\n        var odd = 0\n        while (lst3.nonEmpty) {\n\
    \            even += lst3.head._2\n            lst3.remove(lst3.head._1)\n   \
    \     }\n        while (lst4.nonEmpty) {\n            odd += lst4.head._2\n  \
    \          lst4.remove(lst4.head._1)\n        }\n        if ((even.equals(0l))\
    \ && (odd.equals(0l))) {\n            return \"NO\"\n        }\n        if ((even.equals(0l))\
    \ && (odd.equals(0l))) {\n            return \"YES\"\n        }\n        if ((even.equals(0l))\
    \ && (odd.equals(1l))) {\n            return \"NO\"\n        }\n        if ((even.equals(1l))\
    \ && (odd.equals(0l))) {\n            return \"YES\"\n        }\n        if ((even.equals(1l))\
    \ && (odd.equals(1l))) {\n            return \"NO\"\n        }\n        if ((even.equals(2l))\
    \ && (odd.equals(0l))) {\n            return \"YES\"\n        }\n        if ((even.equals(2l))\
    \ && (odd.equals(1l))) {\n            return \"NO\"\n        }\n        if ((even.equals(2l))\
    \ && (odd.equals(2l))) {\n            return \"NO\"\n        }\n        if ((even.equals(3l))\
    \ && (odd.equals(0l))) {\n            return \"YES\"\n        }\n        if ((even.equals(3l))\
    \ && (odd.equals(1l))) {\n            return \"NO\"\n        }\n        if ((even.equals(3l))\
    \ && (odd.equals(2l))) {\n            return \"NO\"\n        }\n        if ((even.equals(3l))\
    \ && (odd.equals(3l))) {\n            return \"NO\"\n        }\n        if ((even.equals(4l))\
    \ && (odd.equals(0l))) {\n            return \"YES\"\n        }\n        if ((even.equals(4l))\
    \ && (odd.equals(1l))) {\n            return \"NO\"\n        }\n        if ((even.equals(4l))\
    \ && (odd.equals(2l))) {\n            return \"NO\"\n        }\n        if ((even.equals(4l))\
    \ && (odd.equals(3l))) {\n            return \"NO\"\n        }\n        if ((even.equals(4l))\
    \ && (odd.equals(4l))) {\n            return \"NO\"\n        }\n        if ((even.equals(5l))\
    \ && (odd.equals(0l))) {\n            return \"YES\"\n        }\n        if ((even.equals(5l))\
    \ && (odd.equals(1l))) {\n            return \"NO\"\n        }\n        if ((even.equals(5l))\
    \ && (odd.equals(2l))) {\n            return \"NO\"\n        }\n        if ((even.equals(5l))\
    \ && (od\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6dtq32pj.scala:92:4 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6dtq32pj.scala:24:17\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            even += lst3.head._2\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp6dtq32pj.scala:24:30 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m            even += lst3.head._2\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value _2 is\
    \ not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6dtq32pj.scala:25:17\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            lst3.remove(lst3.head._1)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6dtq32pj.scala:25:34\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            lst3.remove(lst3.head._1)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        value _1 is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6dtq32pj.scala:28:16 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            odd += lst4.head._2\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6"
  stdout: ''
  timestamp: 1659979876
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val l1 = lst1.toSet\n        val l2 = lst2.toSet\n        if (l1.size != l2.size)\
    \ throw new Exception(\"The lists have different sizes\")\n        // initialize\
    \ result set to empty\n        var result = \"\"\n        // check if there are\
    \ any elements that can be exchanged.\n        if (l1.size == l2.size) {\n   \
    \         // if there are elements that can be exchanged, then add them to result\
    \ list.\n            for (x <- l1) {\n                if (l2.contains(x)) result\
    \ = \"YES\"\n                else result = \"NO\"\n            }\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph_twxh5w.scala:35)\n\tat Problem.main(tmph_twxh5w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.zipWithIndex.zip(lst2.zipWithIndex).map { case ((a, b), (c, d)) =>\n  \
    \          // check whether an even index of each list can be swapped\n      \
    \      val evenIndex = a % 2 == 0 && b % 2 == 0 && c % 2 == 0 && d % 2 == 0\n\
    \            evenIndex && a != d && b != c && lst1(a) == lst1(b) && lst1(b) ==\
    \ lst1(c) && lst1(c) == lst1(d) match {\n                case true => \"YES\"\n\
    \                case _ => \"NO\"\n            }\n        }.last.map { x => x\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4p3ldi75.scala:21:50\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            evenIndex && a !=\
    \ d && b != c && lst1(a) == lst1(b) && lst1(b) == lst1(c) && lst1(c) == lst1(d)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \             Found:    (a : Long)\n\e[31m   |\e[0m                          \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4p3ldi75.scala:21:83 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            evenIndex && a != d && b != c && lst1(a) == lst1(b)\
    \ && lst1(b) == lst1(c) && lst1(c) == lst1(d) \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \               Found:    (c : Long)\n\e[31m   |\e[0m                        \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4p3ldi75.scala:21:94 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            evenIndex && a != d && b != c && lst1(a) == lst1(b)\
    \ && lst1(b) == lst1(c) && lst1(c) == lst1(d) \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \                          Found:    (c : Long)\n\e[31m   |\e[0m             \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your implementation here!\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7im6zprb.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO: Write your implementation here!\e\
    [0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.zip(lst2).filter(x => x._1 % 2 == 0).map { x => x._1.toLong + x._2.toLong\
    \ }.toList.size == lst1.length ? \"YES\" : \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwwmoqgfv.scala:18:116 -----------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst1.zip(lst2).filter(\e[36mx\e[0m => x._1 %\
    \ \e[31m2\e[0m == \e[31m0\e[0m).map { \e[36mx\e[0m => x._1.toLong + x._2.toLong\
    \ }.toList.size == lst1.length ? \e[31m\"YES\"\e[0m : \e[31m\"NO\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                         value ? is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val a1 = lst1.toArray\n        val a2 = lst2.toArray\n\
    \        var i = 1\n        var j = 1\n        var even = true\n        while\
    \ (i < a1.length && j < a2.length){\n            if (a1(j) %% 2 == 0){\n     \
    \           even = false\n            }\n            if (a2(j) %% 2 == 0){\n \
    \               even = false\n            }\n            if (even == true){\n\
    \                if (a1(j) >= a2(j)){\n                    a1(j) -= 1\n      \
    \              a2(j) -= 1\n                }else{\n                    a1(j) +=\
    \ 1\n                    a2(j) += 1\n                }\n            }\n      \
    \      i += 1\n            j += 1\n        }\n        val evens = List(a1.filter(_\
    \ %% 2 == 0).toArray.mkString(\"\"))\n        if(evens.toList.size == 0){\n  \
    \          \"NO\"\n        }else{\n            \"YES\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeqfaz123.scala:25:22 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (a1(j) %% \e[31m2\e[0m == \e\
    [31m0\e[0m){\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value %% is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpeqfaz123.scala:28:22 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            \e[33mif\e[0m (a2(j) %% \e[31m2\e[0m == \e[31m0\e[0m){\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value %% is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpeqfaz123.scala:43:37 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m        \e[33mval\e[0m \e[36mevens\e[0m = List(a1.filter(_ %% \e[31m2\e[0m\
    \ == \e[31m0\e[0m).toArray.mkString(\e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e[0m \
    \                                  ^^^^\e[0m\n\e[31m   |\e[0m                \
    \                   value %% is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      var\
    \ list1 = lst1.toSeq.sortWith(_ < _)\n      var list2 = lst2.toSeq.sortWith(_\
    \ < _)\n      var list1Even = list1.filter(_%2 == 0).map(x => x + list1.indexOf(x)\
    \ + 1)\n      var list2Even = list2.filter(_%2 == 0).map(x => x + list2.indexOf(x)\
    \ + 1)\n      var list1Odd = list1.filter(_%2 != 0).map(x => x + list1.indexOf(x))\n\
    \      var list2Odd = list2.filter(_%2 != 0).map(x => x + list2.indexOf(x))\n\
    \      var newList1 = new mutable.ArrayList[Long]()\n      var newList2 = new\
    \ mutable.ArrayList[Long]()\n      var newList1Even = new mutable.ArrayList[Long]()\n\
    \      var newList2Even = new mutable.ArrayList[Long]()\n      var newList1Odd\
    \ = new mutable.ArrayList[Long]()\n      var newList2Odd = new mutable.ArrayList[Long]()\n\
    \      var index1 = 0\n      var index2 = 0\n      while(index1 < list1.length\
    \ && index2 < list2.length){\n        if(list1Even(index1) == list2Even(index2)){\n\
    \          newList1Even.append(list1Even(index1))\n          newList2Even.append(list2Even(index2))\n\
    \          newList1.append(list1Odd(index1))\n          newList2.append(list2Odd(index2))\n\
    \          index1 += 1\n          index2 += 1\n        } else if(list1Even(index1)\
    \ != list2Even(index2)){\n          newList1Odd.append(list1Odd(index1))\n   \
    \       newList2Odd.append(list2Odd(index2))\n          index1 += 1\n        \
    \  index2 += 1\n        } else if(list1Odd(index1) == list2Odd(index2)){\n   \
    \       newList1Even.append(list1Even(index1))\n          newList2Even.append(list2Even(index2))\n\
    \          index1 += 1\n          index2 += 1\n        } else if(list1Odd(index1)\
    \ != list2Odd(index2)){\n          newList1Odd.append(list1Odd(index1))\n    \
    \      newList2Odd.append(list2Odd(index2))\n          index1 += 1\n         \
    \ index2 += 1\n        } else {\n          newList1Odd.append(list1Odd(index1))\n\
    \          newList2Odd.append(list2Odd(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplhn7bttw.scala:57:38 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m          newList2Odd.append(list2Odd(\n\e[31m\e[31m\
    \   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m      \
    \                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplhn7bttw.scala:70:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmplhn7bttw.scala:24:25 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m      \e[33mvar\e[0m \e[36mnewList1\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmplhn7bttw.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m      \e[33mvar\e[0m \e[36mnewList2\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplhn7bttw.scala:26:29\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m      \e[33mvar\e[0m \e[36mnewList1Even\e\
    [0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplhn7bttw.scala:27:29 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m      \e[33mvar\e[0m \e[36mnewList2Even\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1659979874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1.isEmpty) return \"NO\"\n        if (lst2.isEmpty) return \"NO\"\n \
    \       \n        // A mutable variable for storing number of exchanged elements.\n\
    \        // Initialize to zero.\n        val exchanged = 0\n        \n       \
    \ // Two variables for storing two elements from lst1 and lst2 at a time.\n  \
    \      var elem1 = lst1.head\n        var elem2 = lst2.head\n        \n      \
    \  while (elem1 != elem2){\n            \n            // If elem1 is even and\
    \ elem2 is odd, we can exchange\n            // elem1.\n            if (elem1\
    \ % 2 == 0 && elem2 % 2 == 1) {\n                lst1 ::= elem2.toLong\n     \
    \           lst2 ::= elem1.toLong\n                exchanged += 1\n          \
    \  }\n            \n            // If elem1 is odd and elem2 is even, we can exchange\n\
    \            // elem2.\n            if (elem1 % 2 != 0 && elem2 % 2 != 0) {\n\
    \                lst1 ::= elem1.toLong\n                lst2 ::= elem2.toLong\n\
    \                exchanged += 1\n            }\n            \n            // Update\
    \ elem1.\n            elem1 = lst1.head\n            \n            // Update elem2.\n\
    \            elem2 = lst2.head\n        }\n        \n        // Return string\
    \ \"YES\" if exchanged all elements from lst1 and lst2.\n        if (exchanged\
    \ >= lst1.length) return(\"YES\") else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaujtndl6.scala:34:21 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                lst1 ::= elem2.toLong\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value ::= is not\
    \ a member of List[Long] - did you mean lst1.::?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpaujtndl6.scala:35:21 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                lst2 ::= elem1.toLong\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value ::= is not a member of List[Long]\
    \ - did you mean lst2.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaujtndl6.scala:36:26\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                exchanged\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of Int - did you mean exchanged.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaujtndl6.scala:42:21 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                lst1 ::= elem1.toLong\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value ::= is not\
    \ a member of List[Long] - did you mean lst1.::?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpaujtndl6.scala:43:21 ------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m                lst2 ::= elem2.toLong\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value ::= is not a member of List[Long]\
    \ - did you mean lst2.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaujtndl6.scala:44:26\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                exchanged\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of Int - did you mean exchanged.!=?\n\
    6 errors found\n"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Odd : mutable.Set[Long] = new mutable.HashSet[Long](lst1)\n        val\
    \ lst2Odd : mutable.Set[Long] = new mutable.HashSet[Long](lst2)\n        val newLst\
    \ : mutable.List[Long] = new mutable.ArrayList[Long](lst1.size + lst2.size)\n\
    \        var i = 0\n        while (i < lst1.size) {\n            if (lst1Odd(i)\
    \ == true) newLst.add(lst1(i))\n            if (lst2Odd(i) == true) newLst.add(lst2(i))\n\
    \            i += 1\n        }\n        val newLstOdd : mutable.Set[Long] = new\
    \ mutable.HashSet[Long](newLst)\n        if (lst1.size == lst2.size && lst2Odd.size\
    \ == lst1Odd.size) {\n            if (newLstOdd.size == lst1Odd.size) return \"\
    YES\"\n            return \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3k00jnkk.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mlst1Odd\e[0m : mutable.Set[\e\
    [35mLong\e[0m] = \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m](lst1)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp3k00jnkk.scala:18:46 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mlst1Odd\e[0m : mutable.Set[\e[35mLong\e[0m] =\
    \ \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m](lst1)\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                             Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3k00jnkk.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlst2Odd\e[0m : mutable.Set[\e\
    [35mLong\e[0m] = \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m](lst2)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp3k00jnkk.scala:19:46 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mlst2Odd\e[0m : mutable.Set[\e[35mLong\e[0m] =\
    \ \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m](lst2)\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                             Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3k00jnkk.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewLst\e[0m : mutable.List[\e\
    [35mLong\e[0m] = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m](lst1.size +\
    \ lst2.size)\n\e["
  stdout: ''
  timestamp: 1659979874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.length == 0 || lst2.length == 0){\n            return \"NO\"\n     \
    \   }\n        if(lst1.head == lst2.head){\n            if(lst1.head % 2 == 0){\n\
    \                return \"NO\"\n            }\n        }\n        else if(lst2.head\
    \ == lst1.head){\n            if(lst2.head % 2 == 0){\n                return\
    \ \"NO\"\n            }\n        }\n        else{\n            var lst3 = lst1.tail\n\
    \            var lst4 = lst2.tail\n            val l = lst3.length\n         \
    \   val r = lst4.length\n            var i = 0\n            var j = 0\n      \
    \      for(i <- 0 until l){\n                for(j <- 0 until r){\n          \
    \          if(lst3(j) == lst4(i)){\n                        lst3(j) = lst3(i)\
    \ - lst3(i)\n                        lst4(i) = lst4(j) - lst4(i)\n           \
    \             break\n                    }\n                }\n            }\n\
    \            if(lst3.sum % 2 == 0){\n                return \"NO\"\n         \
    \   }\n        }\n        return \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp71voi_ki.scala:41:24 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        lst3(j) = lst3(i) - lst3(i)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean List[Long].updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp71voi_ki.scala:42:24 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                        lst4(i) = lst4(j) - lst4(i)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Long] - did you mean List[Long].updated?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp71voi_ki.scala:43:24 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1.zip(lst2).map{\n        case (a,b) if (b == 0) a.toLong * 2 == a.toLong\
    \ else a.toLong / b\n    }.takeWhile{ elem => elem % 2 == 0}.isEmpty ? \"YES\"\
    \ : \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_78hgdtn.scala:19:32 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mcase\e[0m (a,b) \e[33mif\e[0m (b == \e\
    [31m0\e[0m) a.toLong * \e[31m2\e[0m == a.toLong \e[33melse\e[0m a.toLong / b\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               expression expected but \e[31m'.'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_78hgdtn.scala:20:30\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m    }.takeWhile{ elem =>\
    \ elem % \e[31m2\e[0m == \e[31m0\e[0m}.isEmpty ? \e[31m\"YES\"\e[0m : \e[31m\"\
    NO\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue % is not a member of Unit, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val evenList = lst1.filter(_ % 2 == 0).toList\n        val oddList = lst1.filter(_\
    \ % 2 != 0).toList\n        val evenList2 = lst2.filter(_ % 2 == 0).toList\n \
    \       val oddList2 = lst2.filter(_ % 2 != 0).toList\n        if(evenList.size\
    \ == 0 && oddList.size == 0){\n            return \"NO\"\n        }else if(evenList.size\
    \ == 0 && oddList.size > 0){\n            return \"NO\"\n        }else if(evenList.size\
    \ > 0 && oddList.size == 0){\n            return \"NO\"\n        }else if(evenList.size\
    \ == 0 && oddList.size >0){\n            return \"YES\"\n        }else if(evenList.size\
    \ == 0 && oddList.size ==0 && evenList2.size ==0){\n            return \"YES\"\
    \n        }else if(evenList.size == 0 && oddList.size == 0 && evenList2.size >0){\n\
    \            return \"YES\"\n        }else if(evenList.size > 0 && oddList.size\
    \ == 0 && evenList2.size ==0){\n            return \"YES\"\n        }else if(evenList.size\
    \ > 0 && oddList.size == 0 && evenList2.size >0){\n            return \"YES\"\n\
    \        }else if(evenList.size == 0 && oddList.size == 0){\n            return\
    \ \"NO\"\n        }else if(evenList.size > 0 && oddList.size == 0){\n        \
    \    return \"YES\"\n        }else if(evenList.size == 0 && oddList.size > 0){\n\
    \            return \"NO\"\n        }else if(evenList.size > 0 && oddList.size\
    \ >0){\n            return \"YES\"\n        }else{\n            return \"NO\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe6ppfcp8.scala:52)\n\tat Problem.main(tmpe6ppfcp8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your code here\n        lst1.toSet.toList.exists(lst2.toSet.toList.contains(_))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr6yd6i2t.scala:19:32\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        lst1.toSet.toList.exists(lst2.toSet.toList.contains(_))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Boolean\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val n1 = lst1.size\n        val n2 = lst2.size\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var count = 0\n        while(i < n1 && j <\
    \ n2){\n            if(lst1(j) == lst2(k)){\n                lst1(k) = lst1(i)\n\
    \                lst1(i) = lst1(j)\n                lst1(j) = lst1(k)\n      \
    \          lst2(k) = lst2(j)\n                lst2(j) = lst2(k)\n            \
    \    lst2(k) = lst2(j)\n                count +=1\n            }\n           \
    \ i += 1\n            j += 1\n            k += 1\n        }\n        if(count\
    \ == n1 && count == n2){\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2sfha1y_.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                lst1(k) = lst1(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of\
    \ List[Long] - did you mean lst1.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2sfha1y_.scala:27:16 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m                lst1(i) = lst1(j)\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did you mean\
    \ lst1.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2sfha1y_.scala:28:16\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                lst1(j) =\
    \ lst1(k)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m value\
    \ update is not a member of List[Long] - did you mean lst1.updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2sfha1y_.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                lst2(k) = lst2(j)\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of\
    \ List[Long] - did you mean lst2.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2sfha1y_.scala:30:16 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                lst2(j) = lst2(k)\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m value update is not a member of List[Long] - did you mean\
    \ lst2.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2sfha1y_.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                lst2(k) =\
    \ lst2(j)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m value\
    \ update is not a member of List[Long] - did you mean lst2.updated?\n6 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var firstEven = lst1.filter(_ % 2 == 0).length\n        var secondEven = lst2.filter(_\
    \ % 2 == 0).length\n\n        if (firstEven != secondEven) {\n            return\
    \ \"NO\"\n        }\n        // we only have odd numbered elements in the list\n\
    \        // we check if each element in lst2 is even\n        lst2.filter(_ %\
    \ 2 == 0).foreach {\n            x => if (lst1.contains(x)) {\n              \
    \  firstEven = lst1.filter(_ % 2 == 0).length\n                lst1.remove(x)\n\
    \            } else {\n                secondEven = lst2.filter(_ % 2 == 0).length\n\
    \                lst2.remove(x)\n            }\n        }\n\n        if (firstEven\
    \ != secondEven) {\n            return \"NO\"\n        }\n        // we have no\
    \ remaining even-numbered elements in the list\n        // we check if each element\
    \ in lst1 is even\n        lst1.filter(_ % 2 == 0).foreach {\n            x =>\
    \ if (lst2.contains(x)) {\n                firstEven = lst1.filter(_ % 2 == 0).length\n\
    \                lst1.remove(x)\n            } else {\n                secondEven\
    \ = lst2.filter(_ % 2 == 0).length\n                lst2.remove(x)\n         \
    \   }\n        }\n        if (firstEven != secondEven) {\n            return \"\
    NO\"\n        }\n        // we have no remaining even-numbered elements in the\
    \ list\n        // we check if each element in lst2 is even\n        lst2.filter(_\
    \ % 2 == 0).foreach {\n            x => if (lst1.contains(x)) {\n            \
    \    firstEven = lst1.filter(_ % 2 == 0).length\n                lst1.remove(x)\n\
    \            } else {\n                secondEven = lst2.filter(_ % 2 == 0).length\n\
    \                lst2.remove(x)\n            }\n        }\n\n        // We have\
    \ all the even-numbered elements in lst1 list\n        // We have all the even-numbered\
    \ elements in lst2 list\n        // We exchange them together to make lst1 a list\
    \ with only even numbered elements\n        // We exchange them together to make\
    \ lst2 a list with only even numbered elements\n        // We check if lst1 and\
    \ lst2 are disjoint set\n        val set1 = new mutable.HashSet[Long]()\n    \
    \    val set2 = new mutable.HashSet[Long]()\n        lst1.foreach {\n        \
    \    x => if (!set1.contains(x)) {\n                set1 += x\n            }\n\
    \        }\n        lst2.foreach {\n            x => if (!set2.contains(x)) {\n\
    \                set2 += x\n            }\n        }\n        if (set1.toSet.subsetOf(set2))\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm64gqb3f.scala:29:21 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                lst1.remove(x)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value remove is not a member\
    \ of List[Long] - did you mean lst1.reduce?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpm64gqb3f.scala:32:21 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m                lst2.remove(x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue remove is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm64gqb3f.scala:44:21\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                lst1.remove(x)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm64gqb3f.scala:47:21\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                lst2.remove(x)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m"
  stdout: ''
  timestamp: 1659979883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // SOLUTION GOES HERE\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx7p8xoqv.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// SOLUTION GOES HERE\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Solution here\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpherib0y7.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Solution here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst2.isEmpty) list1IsEven else list1IsNotEven\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3b2tv0z0.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(lst2.isEmpty) list1IsEven \e[33melse\e\
    [0m list1IsNotEven\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: list1IsEven\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3b2tv0z0.scala:18:42 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(lst2.isEmpty) list1IsEven \e[33melse\e\
    [0m list1IsNotEven\n\e[31m\e[31m   |\e[0m                                    \
    \      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \        Not found: list1IsNotEven\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1len = lst1.size\n        val lst2len = lst2.size\n        var x = 0\n\
    \        var y = 0\n        val arr1 = new mutable.ArrayList[Long]\n        val\
    \ arr2 = new mutable.ArrayList[Long]\n        while (x < lst1len) {\n        \
    \    arr1.add(lst1.get(x))\n            x += 1\n        }\n        while (y <\
    \ lst2len) {\n            arr2.add(lst2.get(y))\n            y += 1\n        }\n\
    \        val lst1even = arr1.filter(x=> x % 2 == 0).length\n        val lst2even\
    \ = arr2.filter(x=> x % 2 == 0).length\n        if (lst1even == lst2even) {\n\
    \            // If list 1 and list 2 have same number of even elements, exchange\n\
    \            // will make them even too.\n            lst1.zipAll(lst2).map(x\
    \ => x(0))\n            val res1 = lst1.foldLeft(true)((acc, x) => {acc && x.toLong\
    \ % 2 == 0})\n            val res2 = lst2.foldLeft(true)((acc, x) => {acc && x.toLong\
    \ % 2 == 0})\n            if (res1 && res2) {\n                return \"YES\"\n\
    \            } else {\n                return \"NO\"\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzeze30to.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr1\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzeze30to.scala:23:23\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36marr2\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpzeze30to.scala:37:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \     lst1.zipAll(lst2).map(\e[36mx\e[0m => x(\e[31m0\e[0m))\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for parameter\
    \ thisElem of \e[33mmethod\e[0m \e[35mzipAll\e[0m in \e[33mtrait\e[0m \e[35mIterableOps\e\
    [0m: (that: Iterable[B], thisElem: A1, thatElem: B): List[(A1, B)]\n3 errors found\n"
  stdout: ''
  timestamp: 1659979880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Your code goes here\n        val even = lst1 filter (_ % 2 == 0)\n\
    \        if(even.nonEmpty) \n            \"YES\"\n        else \n            \"\
    NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb19gjxcv.scala:27)\n\tat Problem.main(tmpb19gjxcv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979886
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val list3 = lst1.take(lst1.size)\n        val list4 = lst2.take(lst2.size)\n\
    \        if (list3.size == list4.size) {\n            val list5 = list3.intersect(list4)\n\
    \            if (list5.size == 0)\n                \"NO\"\n            else\n\
    \                \"YES\"\n        }\n        else {\n            \"NO\"\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpii378k4y.scala:33)\n\tat Problem.main(tmpii378k4y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkyot22ev.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1 filter (_ % 2l.toLong == 0)\n        val odd : List[Long] =\
    \ lst1 filter (_ % 2l.toLong != 0)\n        if (even.isEmpty) odd.toString else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvm9x17q6.scala:23)\n\tat Problem.main(tmpvm9x17q6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // TODO: Write your code here\n        val countLst1 = lst1.count(x => x % 2\
    \ == 0)\n        val countLst2 = lst2.count(x => x % 2 == 0)\n        if(countLst1\
    \ == countLst2){\n            \"NO\"\n        }else{\n            \"YES\"\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj5zhmohf.scala:28)\n\tat Problem.main(tmpj5zhmohf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ //YOUR CODE HERE\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbkglq9lg.scala:17:66\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m//YOUR CODE HERE\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your solution here!\n        lst1.zip(lst2).foldLeft(true) {\n    \
    \        (acc,cur) => {\n                val temp = cur._1\n                val\
    \ temp2 = cur._2\n                if(temp % 2 == 0) {\n                    acc\
    \ && false\n                } else {\n                    acc && true\n      \
    \          }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0tpxi7js.scala:19:38\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        lst1.zip(lst2).foldLeft(\e\
    [31mtrue\e[0m) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m       \
    \ Found:    Boolean\n\e[31m   |\e[0m        Required: String\n\e[31m20 |\e[0m\
    \            (\e[36macc\e[0m,\e[36mcur\e[0m) => {\n\e[31m21 |\e[0m           \
    \     \e[33mval\e[0m \e[36mtemp\e[0m = cur._1\n\e[31m22 |\e[0m               \
    \ \e[33mval\e[0m \e[36mtemp2\e[0m = cur._2\n\e[31m23 |\e[0m                \e\
    [33mif\e[0m(temp % \e[31m2\e[0m == \e[31m0\e[0m) {\n\e[31m24 |\e[0m          \
    \          acc && \e[31mfalse\e[0m\n\e[31m25 |\e[0m                } \e[33melse\e\
    [0m {\n\e[31m26 |\e[0m                    acc && \e[31mtrue\e[0m\n\e[31m27 |\e\
    [0m                }\n\e[31m28 |\e[0m            }\n\e[31m29 |\e[0m        }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n      val\
    \ lst1 = lst1.toSet\n      val lst2 = lst2.toSet\n      if(lst2.isEmpty && lst1.isEmpty)\
    \ \"YES\" else (lst2 ++ lst1).foldLeft(\"\")({\n          case \"YES\" => \"NO\"\
    \n          case \"NO\" => \"\"\n          case (\"\", l1) =>\n            val\
    \ even = (l1.toSet & lst2).toSet.toSeq\n            val odd = (l1 -- even).toSet.toSeq\n\
    \            even.forall { x => odd contains x }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4dhkofiu.scala:18:17 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mlst1\e[0m = lst1.toSet\n\e\
    [31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 Recursive\
    \ \e[33mvalue\e[0m \e[35mlst1\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp4dhkofiu.scala:19:17 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m      \e[33mval\e[0m \e[36mlst2\e[0m = lst2.toSet\n\e\
    [31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 Recursive\
    \ \e[33mvalue\e[0m \e[35mlst2\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var tmp : List[Long] = lst1.toList\n        var a : Boolean = lst1.toList.size\
    \ == lst2.toList.size\n        \n        \n        \n        if(a == true){\n\
    \            var l1 = lst1.toList\n            var l2 = lst2.toList\n        \
    \    var a = false\n            var a : Boolean = false\n            var a : Boolean\
    \ = false\n            \n            while(a != true){\n                \n   \
    \             tmp = l1.takeWhile(a) //l1.takeWhile(x => x != l2.head)\n      \
    \          l1 -= tmp //l1 - tmp\n                tmp = l2.takeWhile(a) //l2.takeWhile(x\
    \ => x != l1.head)\n                l2 -= tmp //l2 - tmp\n                a =\
    \ true\n                \n                \n            }\n            \n    \
    \        l1.zip(l2)\n            .foreach(x => println(x._1 + \", \" + x._2))\n\
    \            \n        }\n        \n        if(a == false){\n            var l1\
    \ = lst1.toList\n            var l2 = lst2.toList\n            var a = true\n\
    \            var a : Boolean = false\n            \n            while(a != false){\n\
    \                \n                tmp = l1.takeWhile(a) //l1.takeWhile(x => x\
    \ != l2.head)\n                l1 -= tmp //l1 - tmp\n                tmp = l2.takeWhile(a)\
    \ //l2.takeWhile(x => x != l1.head)\n                l2 -= tmp //l2 - tmp\n  \
    \              a = false\n                \n                \n            }\n\
    \            \n            l1.zip(l2)\n            .foreach(x => println(x._1\
    \ + \", \" + x._2))\n            \n        }\n        \n        \n        \n \
    \       \n        \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgh9rkg5p.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mvar\e[0m \e[36ma\e[0m : \e[35mBoolean\e\
    [0m = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ma is already defined as \e[33mvariable\e[0m \e[35ma\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgh9rkg5p.scala:28:16 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            \e[33mvar\e[0m \e[36ma\e[0m : \e[35mBoolean\e[0m = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0ma is already defined as \e[33mvariable\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgh9rkg5p.scala:32:35\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                tmp = l1.takeWhile(a)\
    \ \e[34m//l1.takeWhile(x => x != l2.head)\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \         Found:    \e[1m\e[31m(\e[0m\e[1m\e[31ma\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31m:\e[0m Boolean\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                         \
    \          Required: \e[1m\e[32mLong\e[0m \e[1m\e[32m=\e[0m\e[1m\e[32m>\e[0m Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgh9rkg5p.scala:33:19\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                l1 -= tmp\
    \ \e[34m//l1 - tmp\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m\
    \   |\e[0m    value -= is not a member of List[Long] - did you mean List[Long].!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgh9rkg5p.scala:34:35 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                tmp = l2.takeWhile(a) \e[34m//l2.takeWhile(x\
    \ => x != l1.head)\e[0m\n\e[31m\e[31m   |\e[0m                               \
    \    ^\e[0m\n\e[31m   |\e[0m                                   Found:    \e[1m\e\
    [31"
  stdout: ''
  timestamp: 1659979889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your code here\n        var a = lst1\n        var b = lst2\n      \
    \  var c = a\n        var d = b\n        if(b.size > 0){\n            while(b.size\
    \ > 0){\n                if(a(0) < b(0) || (a(0) === b(0) && a(1) < b(1)) || (a(0)\
    \ === b(0) && a(1) === b(1) && a(2) < b(2))){\n                    a = b\n   \
    \                 d = a\n                    b.remove(0)\n                }\n\
    \                else{\n                    c = b\n                    c = a\n\
    \                    a.remove(0)\n                }\n            }\n         \
    \   a foreach println\n        }\n        else if(b.size == 0){\n            a\
    \ foreach println\n        }\n        else{\n            a foreach println\n \
    \       }\n        if(c.size > 0){\n            while(c.size > 0){\n         \
    \       if(a(0) < c(0) || (a(0) === c(0) && a(1) < c(1)) || (a(0) === c(0) &&\
    \ a(1) === c(1) && a(2) < c(2))){\n                    a = c\n               \
    \     d = a\n                    c.remove(0)\n                }\n            \
    \    else{\n                    b = c\n                    b = a\n           \
    \         a.remove(0)\n                }\n            }\n            a foreach\
    \ println\n        }\n        else if(c.size == 0){\n            a foreach println\n\
    \        }\n        else{\n            a foreach println\n        }\n        if(d.size\
    \ > 0){\n            while(d.size > 0){\n                if(a(0) < d(0) || (a(0)\
    \ === d(0) && a(1) < d[1]) || (a(0) === d(0) && a(1) === d(1) && a(2) < d[2])){\n\
    \                    a = d\n                    d = a\n                    d.remove(0)\n\
    \                }\n                else{\n                    b = d\n       \
    \             b = a\n                    a.remove(0)\n                }\n    \
    \        }\n            a foreach println\n        }\n        else if(d.size ==\
    \ 0){\n            a foreach println\n        }\n        else{\n            a\
    \ foreach println\n        }\n        if(b.size > 0){\n            while(b.size\
    \ > 0){\n                if(a(0) < b(0) || (a(0) === b(0) && a(1) < b(1)) || (a(0)\
    \ === b(0) && a(1) === b(1) && a(2) < b(2))){\n                    a = b\n   \
    \                 d = a\n                    b.remove(0)\n                }\n\
    \                else{\n                    c = b\n                    c = a\n\
    \                    a.remove(0)\n                }\n            }\n         \
    \   a foreach println\n        }\n        else if(b.size == 0){\n            a\
    \ foreach println\n        }\n        else{\n            a foreach println\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe5l1d89n.scala:118:0 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe5l1d89n.scala:25:40\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e\
    [0m(a(\e[31m0\e[0m) < b(\e[31m0\e[0m) || (a(\e[31m0\e[0m) === b(\e[31m0\e[0m)\
    \ && a(\e[31m1\e[0m) < b(\e[31m1\e[0m)) || (a(\e[31m0\e[0m) === b(\e[31m0\e[0m)\
    \ && a(\e[31m1\e[0m) === b(\e[31m1\e[0m) && a(\e[31m2\e[0m) < b(\e[31m2\e[0m))){\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m               value === is not a member of Long - did you mean Long.==?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe5l1d89n.scala:25:74 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m(a(\e[31m0\e[0m) < b(\e\
    [31m0\e[0m) || (a(\e[31m0\e[0m) === b(\e[31m0\e[0m) && a(\e[31m1\e[0m) < b(\e\
    [31m1\e[0m)) || (a(\e[31m0\e[0m) === b(\e[31m0\e[0m) && a(\e[31m1\e[0m) === b(\e\
    [31m1\e[0m) && a(\e[31m2\e[0m) < b(\e[31m2\e[0m))){\n\e[31m\e[31m   |\e[0m   \
    \                                                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value === is not a member of Long - did you\
    \ mean Long.==?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe5l1d89n.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    b.remove(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue remove is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe5l1d89n.scala:33:22\
    \ ------------------------\e[0"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst2.isEmpty)\n            \"NO\"\n        else if (lst2.size > lst1.size)\n\
    \            \"NO\"\n        else if (lst2.size == lst1.size) {\n            var\
    \ i = 0\n            while (i < lst1.size) {\n                if (lst2(i) % 2\
    \ == 0) {\n                    lst1(i) = lst2(i)\n                    lst2(i)\
    \ = lst1(i)\n                }\n                i += 1\n            }\n      \
    \  }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphwdztfrx.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    lst1(i) = lst2(i)\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m value update is not a\
    \ member of List[Long] - did you mean lst1.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmphwdztfrx.scala:27:20 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m                    lst2(i) = lst1(i)\n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^\e[0m\n\e[31m   |\e[0m value update is not a member of\
    \ List[Long] - did you mean lst2.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val newList = lst1.filter(x => !lst2.contains(x)).sorted\n        val newLst2\
    \ = lst2.filter(x => !lst1.contains(x))\n        val lst3 = (newList ++ newLst2).distinct\n\
    \        val lst4 = lst3.filter(_ % 2 == 0).sorted\n        if(lst4.size == lst3.size)\
    \ {\n            if(lst3.size == lst1.size || lst3.size == lst2.size) {\n    \
    \            if(lst1.contains(lst3(0)) && lst2.contains(lst3(0))) {\n        \
    \            return \"YES\"\n                }\n            }\n        }\n   \
    \     return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5x8qkhei.scala:32)\n\tat Problem.main(tmp5x8qkhei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ lst1 match {\n            case xs if (xs.isEmpty) => \"NO\"\n            case\
    \ xs if (xs.size != 2) => \"NO\"\n            case xs => lst1 match {\n      \
    \          case xs if (xs.size < 2) => \"NO\"\n                case xs if (xs.size\
    \ == 2) => {\n                    val lst3 = lst1 ::: lst2\n                 \
    \   lst3.foreach( x => {\n                        lst1 += x.toInt/2\n        \
    \                lst2 += x.toInt/2\n                    })\n                 \
    \   lst3.foreach( x => {\n                        lst1 -= x\n                \
    \        lst2 -= x\n                    })\n                    if (lst1 == 0\
    \ :: lst2 == 0 :: Nil => \"NO\"\n                    else if (lst1 == 0 :: lst2\
    \ == 1 :: Nil || lst1 == 1 :: lst2 == 0 :: Nil || lst1 == 1 :: lst2 == 1 :: Nil\
    \ || lst1 == 2 :: lst2 == 0 :: Nil || lst1 == 2 :: lst2 == 1 :: Nil) then \"YES\"\
    \n                    else exchange(lst1, lst2)\n                }\n         \
    \       case xs if (xs.size == 3) => {\n                    val lst3 = lst1 :::\
    \ lst2\n                    lst3.foreach( x => {\n                        lst1\
    \ += x.toInt/3\n                        lst2 += x.toInt/3\n                  \
    \  })\n                    lst3.foreach( x => {\n                        lst1\
    \ -= x\n                        lst2 -= x\n                    })\n          \
    \          if (lst1 == 0 :: lst2 == 0 :: Nil => \"NO\"\n                    else\
    \ if (lst1 == 0 :: lst2 == 1 :: Nil || lst1 == 1 :: lst2 == 0 :: Nil || lst1 ==\
    \ 1 :: lst2 == 1 :: Nil || lst1 == 2 :: lst2 == 0 :: Nil || lst1 == 2 :: lst2\
    \ == 1 :: Nil) then \"YES\"\n                    else exchange(lst1, lst2)\n \
    \               }\n                case xs if (xs.size == 4) => {\n          \
    \          val lst3 = lst1 ::: lst2\n                    lst3.foreach( x => {\n\
    \                        lst1 += x.toInt/4\n                        lst2 += x.toInt/4\n\
    \                    })\n                    lst3.foreach( x => {\n          \
    \              lst1 -= x\n                        lst2 -= x\n                \
    \    })\n                    if (lst1 == 0 :: lst2 == 0 :: Nil => \"NO\"\n   \
    \                 else if (lst1 == 0 :: lst2 == 1 :: Nil || lst1 == 1 :: lst2\
    \ == 0 :: Nil || lst1 == 1 :: lst2 == 1 :: Nil || lst1 == 2 :: lst2 == 0 :: Nil\
    \ || lst\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzy8yzcs8.scala:33:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    \e[33mif\e[0m (lst1 == \e[31m0\e\
    [0m :: lst2 == \e[31m0\e[0m :: Nil => \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                       not a legal formal parameter\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpzy8yzcs8.scala:34:20 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (lst1 == \e[31m0\e\
    [0m :: lst2 == \e[31m1\e[0m :: Nil || lst1 == \e[31m1\e[0m :: lst2 == \e[31m0\e\
    [0m :: Nil || lst1 == \e[31m1\e[0m :: lst2 == \e[31m1\e[0m :: Nil || lst1 == \e\
    [31m2\e[0m :: lst2 == \e[31m0\e[0m :: Nil || lst1 == \e[31m2\e[0m :: lst2 == \e\
    [31m1\e[0m :: Nil) \e[33mthen\e[0m \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^\e[0m\n\e[31m   |\e[0m                    ')' expected,\
    \ but 'else' found\n\e[31m\e[31m-- Error: /tmp/tmpzy8yzcs8.scala:47:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                    \e[33mif\e[0m (lst1 == \e[31m0\e\
    [0m :: lst2 == \e[31m0\e[0m :: Nil => \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                       not a legal formal parameter\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpzy8yzcs8.scala:48:20 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (lst1 == \e[31m0\e\
    [0m :: lst2 == \e[31m1\e[0m :: Nil || lst1 == \e[31m1\e[0m :: lst2 == \e[31m0\e\
    [0m :: Nil || lst1 == \e[31m1\e[0m :: lst2 == \e[31m1\e[0m :: Nil || lst1 == \e\
    [31m2\e[0m :: lst2 == \e[31m0\e[0m :: Nil || lst1 == \e[31m2\e[0m :: lst2 == \e\
    [31m1\e[0m :: Nil) \e[33mthen\e[0m \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^\e[0m\n\e[31m   |\e[0m                    ')' expected,\
    \ but 'else' found\n\e[31m\e[31m-- Error: /tmp/tmpzy8yzcs8.scala:61:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m                    \e[33mif\e[0m (lst1 == \e[31m0\e\
    [0m :: lst2 == \e[31m0\e[0m :: Nil => \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \            "
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val lst1Map = lst1.map(x => x -> 1).toMap\n        val lst2Map = lst2.map(x\
    \ => x -> 1).toMap\n        val newMap = lst1Map ++ lst2Map\n        val newList\
    \ = newMap.map(x => x._1 -> x._2).map(x => x._1).filter(_ % 2 == 0).sortBy(_).toList\n\
    \        if(newList.size == lst1.size)\n        { \n            val newListMap\
    \ = newList.map(x => x -> 1).toMap\n            val newListList = newListMap.map(x\
    \ => x._1).filter(_ % 2 == 0).sortBy(_).toList\n            if(newListList.size\
    \ == lst2.size)\n            {\n                if(newListList.mkString.equals(lst2.mkString))\n\
    \                {\n                    return(\"YES\")\n                }\n \
    \               else\n                {\n                    return(\"NO\")\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      return(\"NO\")\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpyyrlcdyl.scala:21:93 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = newMap.map(\e\
    [36mx\e[0m => x._1 -> x._2).map(\e[36mx\e[0m => x._1).filter(_ % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).sortBy(_).toList\n\e[31m\e[31m   |\e[0m                   \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mMissing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0mI\
    \ could not infer the type of the parameter _$2 of expanded function:\n\e[31m\
    \   |\e[0m_$2 => \n\e[31m   |\e[0m  newMap.map(x => x._1 -> x._2).map(x => x._1).filter(_$1\
    \ => _$1 % 2 == 0).\n\e[31m   |\e[0m    sortBy\n\e[31m   |\e[0m  (_$2).toList.\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyyrlcdyl.scala:21:86 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = newMap.map(\e\
    [36mx\e[0m => x._1 -> x._2).map(\e[36mx\e[0m => x._1).filter(_ % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).sortBy(_).toList\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue sortBy is not a member of scala.collection.immutable.Iterable[Long]\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpyyrlcdyl.scala:25:82 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mnewListList\e[0m = newListMap.map(\e\
    [36mx\e[0m => x._1).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^\e[0m\n\e[31m   |\e[0mMissing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mI could not infer the type of the parameter _$4 of\
    \ expanded function:\n\e[31m   |\e[0m_$4 => newListMap.map(x => x._1).filter(_$3\
    \ => _$3 % 2 == 0).sortBy(_$4).toList.\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpyyrlcdyl.scala:26:12 --------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \            \e[33mif\e[0m(newListList.size == lst2.size)\n\e[31m\e[31m   |\e\
    [0m            ^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m   |\e\
    [0m            Required: String\n\e[31m   |\e[0m            May"
  stdout: ''
  timestamp: 1659979889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty) \"\"\n        if(lst2.isEmpty) \"\"\n        val xs = lst2.toSet\n\
    \        val ys = lst1.toSet\n        val zs = xs.intersection(ys)\n        if(zs.isEmpty)\
    \ \"\"\n        else if(zs.size == xs.size) \"YES\"\n        else \"\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7bji9bzb.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzs\e[0m = xs.intersection(ys)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ intersection is not a member of Set[Long] - did you mean xs.intersect?\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmp7bji9bzb.scala:18:25 ----------------\e\
    [0m\e[0m\n\e[33m18 |\e[0m        \e[33mif\e[0m(lst1.isEmpty) \e[31m\"\"\e[0m\n\
    \e[33m\e[33m   |\e[0m                         ^^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp7bji9bzb.scala:19:25\
    \ ----------------\e[0m\e[0m\n\e[33m19 |\e[0m        \e[33mif\e[0m(lst2.isEmpty)\
    \ \e[31m\"\"\e[0m\n\e[33m\e[33m   |\e[0m                         ^^\e[0m\n\e[33m\
    \   |\e[0mA pure expression does nothing in statement position; you may be omitting\
    \ necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 warnings found\n1 error found\n"
  stdout: ''
  timestamp: 1659979889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst2.isEmpty) return \"NO\"\n        var lst3 = lst1\n        var i = lst2.indexOf(lst1.last)\n\
    \        if (i != -1) lst3 = lst3.remove(i)\n        val x = lst1.last\n     \
    \   val y = lst2.last\n        var j = 0\n        var k = lst2.lastIndexOf(x)\n\
    \        while (k != -1) {\n            lst3.insert(j, lst2(k))\n            j++\n\
    \            k = lst2.lastIndexOf(x)\n        }\n        if (lst1 == lst3) \"\
    YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp522gl_mv.scala:29:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            k = lst2.lastIndexOf(x)\n\e[31m\e[31m   |\e\
    [0m              ^\e[0m\n\e[31m   |\e[0m              end of statement expected\
    \ but '=' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp522gl_mv.scala:21:33\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (i\
    \ != -\e[31m1\e[0m) lst3 = lst3.remove(i)\n\e[31m\e[31m   |\e[0m             \
    \               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member\
    \ of List[Long] - did you mean List[Long].reduce?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp522gl_mv.scala:27:17 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            lst3.insert(j, lst2(k))\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue insert is not a member of List[Long]\
    \ - did you mean List[Long].init?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp522gl_mv.scala:28:13\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            j++\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m            value ++ is not\
    \ a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1659979890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1.isEmpty)\n            (lst2.head % 2 == 0)\n        else\n        \
    \    lst1.takeWhile(x => lst2.head % 2 == 0).last.isEven == exchange(lst1.drop(1),\
    \ lst2.drop(1))\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdkbwf_1m.scala:19:13\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (lst2.head % \e[31m2\e\
    [0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m             Found:    Boolean\n\e[31m   |\e[0m             Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdkbwf_1m.scala:21:57\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            lst1.takeWhile(\e\
    [36mx\e[0m => lst2.head % \e[31m2\e[0m == \e[31m0\e[0m).last.isEven == exchange(lst1.drop(\e\
    [31m1\e[0m), lst2.drop(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value isEven is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var even = 0 //to keep track of even numbers in lst1\n        var odd = 0 //to\
    \ keep track of odd numbers in lst1\n        var evenIndex = 0\n        var oddIndex\
    \ = 0\n        evenIndex = lst1.find(_ % 2 == 0).map(x => even += 1).orElse(evenIndex\
    \ = 0)\n        oddIndex = lst1.find(_ % 2 == 1).map(x => odd += 1).orElse(oddIndex\
    \ = 0)\n        if(evenIndex == 0 && oddIndex == 0){\n            return \"YES\"\
    \n        }\n        if(evenIndex == 0 && oddIndex != 0){\n            return\
    \ \"NO\"\n        }\n        else if(evenIndex != 0 && oddIndex == 0){\n     \
    \       return \"NO\"\n        }\n        else if(evenIndex != 0 && oddIndex !=\
    \ 0){\n            val temp = lst1.take(evenIndex)\n            val temp2 = lst1.drop(evenIndex)\n\
    \            val temp3 = lst2.take(oddIndex)\n            val temp4 = lst2.drop(oddIndex)\n\
    \            if(lst1.size == temp4.size){\n                if(lst2.size == temp3.size){\n\
    \                    return exchange(temp, temp2)\n                }\n       \
    \         else{\n                    return exchange(temp, temp3)\n          \
    \      }\n            }\n            else if(lst2.size == temp3.size){\n     \
    \           return exchange(temp2, temp4)\n            }\n            else{\n\
    \                return exchange(temp2, temp3)\n            }\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpc6gkx7ni.scala:22:79 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        evenIndex = lst1.find(_ % \e[31m2\e[0m == \e\
    [31m0\e[0m).map(\e[36mx\e[0m => even += \e[31m1\e[0m).orElse(evenIndex = \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e[0m \e[35morElse\e\
    [0m in \e[33mclass\e[0m \e[35mOption\e[0m: (alternative: => Option[B]): Option[B]\
    \ does not have a parameter evenIndex\n\e[31m\e[31m-- Error: /tmp/tmpc6gkx7ni.scala:23:76\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ oddIndex = lst1.find(_ % \e[31m2\e[0m == \e[31m1\e[0m).map(\e[36mx\e[0m => odd\
    \ += \e[31m1\e[0m).orElse(oddIndex = \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                                               ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m\e[33mmethod\e[0m \e[35morElse\e[0m in \e[33mclass\e[0m \e\
    [35mOption\e[0m: (alternative: => Option[B]): Option[B] does not have a parameter\
    \ oddIndex\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc6gkx7ni.scala:33:13\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m(evenIndex != \e[31m0\e[0m && oddIndex != \e[31m0\e[0m){\n\e[31m\e[31m   |\e\
    [0m             ^\e[0m\n\e[31m   |\e[0m             Found:    Unit\n\e[31m   |\e\
    [0m             Required: String\n\e[31m   |\e[0m             Maybe you are missing\
    \ an else part for the conditional?\n\e[31m34 |\e[0m            \e[33mval\e[0m\
    \ temp = lst1.take(evenIndex)\n\e[31m35 |\e[0m            \e[33mval\e[0m temp2\
    \ = lst1.drop(evenIndex)\n\e[31m36 |\e[0m            \e[33mval\e[0m temp3 = lst2.take(oddIndex)\n\
    \e[31m37 |\e[0m            \e[33mval\e[0m temp4 = lst2.drop(oddIndex)\n\e[31m38\
    \ |\e[0m            \e[33mif\e[0m(lst1.size == temp4.size){\n\e[31m39 |\e[0m \
    \               \e[33mif\e[0m(lst2.size == temp3.size){\n\e[31m40 |\e[0m     \
    \               \e[33mreturn\e[0m exchange(temp, temp2)\n\e[31m41 |\e[0m     \
    \           }\n\e[31m42 |\e[0m                \e[33melse\e[0m{\n\e[31m43 |\e[0m\
    \                    \e[33mreturn\e[0m exchange(temp, temp3)\n\e[31m44 |\e[0m\
    \                }\n\e[31m45 |"
  stdout: ''
  timestamp: 1659979888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val even = lst1 filter (x => x % 2 == 0)\n        val evenAndOdd = lst2 filter\
    \ (x => x % 2 == 0)\n        if (even.isEmpty || evenAndOdd.isEmpty) {\n     \
    \       return \"NO\"\n        }\n        var a = even(0)\n        var b = evenAndOdd(0)\n\
    \        for (i = 1 until evenAndOdd.size) {\n            a = even(0)\n      \
    \      b = evenAndOdd(i)\n            if (a % 2 == 0) {\n                if (b\
    \ > a && b % 2 == 0) {\n                    even(0) = b\n                } else\
    \ {\n                    even(0) = a\n                }\n            } else {\n\
    \                if (b > a && b % 2 == 1) {\n                    even(0) = b\n\
    \                } else {\n                    even(0) = a\n                }\n\
    \            }\n        }\n        if (even.isEmpty || evenAndOdd.isEmpty) {\n\
    \            return \"NO\"\n        }\n        return \"YES\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l9mmb8z.scala:25:15 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m (i = \e[31m1\e[0m until evenAndOdd.size)\
    \ {\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m             \
    \  ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l9mmb8z.scala:25:42\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m\
    \ (i = \e[31m1\e[0m until evenAndOdd.size) {\n\e[31m\e[31m   |\e[0m          \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                     '<-' expected, but '{' found\n\e[31m\e[31m-- [E032] Syntax\
    \ Error: /tmp/tmp_l9mmb8z.scala:44:9 ----------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m\
    \         pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp_l9mmb8z.scala:41:9 -------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter\
    \ is not a member of Null, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e\
    [0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.list asScalaBuffer\n\e[31m  \
    \ |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if (lst1.length == 0){\n            if (lst2.length == 0){\n               \
    \ return \"NO\"\n            }\n            return \"NO\"\n        }\n       \
    \ var evenNum : List[Long] = lst1\n        var oddNum : List[Long] = lst2\n  \
    \      val newList = if (evenNum.filter(x => x % 2 == 0).length == evenNum.size\
    \ && oddNum.filter(x => x % 2 != 0).length == oddNum.size)\n            evenNum.filter(x\
    \ => x % 2 == 0).zip(oddNum.filter(x => x % 2 != 0)).map(x => (x(0).asInstanceOf[Long],\
    \ x(1).asInstanceOf[Long])).toList\n        else evenNum.filter(x => x % 2 ==\
    \ 0).zip(oddNum.filter(x => x % 2 != 0)).map(x => (x(0).asInstanceOf[Long], x(1).asInstanceOf[Long])).toList\n\
    \        if (newList.length == 0){\n            return \"NO\"\n        }\n   \
    \     else {\n            return \"YES\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb191hhec.scala:38)\n\tat Problem.main(tmpb191hhec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ val result: mutable.HashSet[Long] = mutable.HashSet()\n        lst1.foreach{x=>result.add(x)}\n\
    \        lst2.foreach{x=>result.add(x)}\n        if(result.toSet.size==lst1.size)\n\
    \            return \"YES\"\n        else\n            return \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_39yyjb3.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: mutable.HashSet[\e\
    [35mLong\e[0m] = mutable.HashSet()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_39yyjb3.scala:18:44 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: mutable.HashSet[\e\
    [35mLong\e[0m] = mutable.HashSet()\n\e[31m\e[31m   |\e[0m                    \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your code here\n        val x = lst1.takeWhile(i => !lst2.contains(i))\n\
    \        val y = lst2.filter(i => !lst1.contains(i))\n        if(x == y) \"YES\"\
    \ else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswqvn5y9.scala:27)\n\tat Problem.main(tmpswqvn5y9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ var count = 1\n        for(i <- 0 until lst1.length) yield {\n            if(lst1(count)\
    \ == lst1(count+1)) count += 1\n            else if(lst1(count) != lst1(count+1))\
    \ count = 1\n            else if(lst1(count) == lst1(count-1) && lst1(count) ==\
    \ lst1(count-2)) count += 1\n            else if(lst1(count) != lst1(count-1)\
    \ && lst1(count) != lst1(count-2)) count = 1\n            else count = 1\n   \
    \         if(count == lst1.length) return \"YES\"\n            else return \"\
    NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3aeiw91.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m(i <-\
    \ \e[31m0\e[0m until lst1.length) \e[33myield\e[0m {\n\e[31m\e[31m   |\e[0m  \
    \      ^\e[0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Nothing]\n\e[31m  \
    \ |\e[0m        Required: String\n\e[31m20 |\e[0m            \e[33mif\e[0m(lst1(count)\
    \ == lst1(count+\e[31m1\e[0m)) count += \e[31m1\e[0m\n\e[31m21 |\e[0m        \
    \    \e[33melse\e[0m \e[33mif\e[0m(lst1(count) != lst1(count+\e[31m1\e[0m)) count\
    \ = \e[31m1\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(lst1(count)\
    \ == lst1(count-\e[31m1\e[0m) && lst1(count) == lst1(count-\e[31m2\e[0m)) count\
    \ += \e[31m1\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(lst1(count)\
    \ != lst1(count-\e[31m1\e[0m) && lst1(count) != lst1(count-\e[31m2\e[0m)) count\
    \ = \e[31m1\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m count = \e[31m1\e\
    [0m\n\e[31m25 |\e[0m            \e[33mif\e[0m(count == lst1.length) \e[33mreturn\e\
    [0m \e[31m\"YES\"\e[0m\n\e[31m26 |\e[0m            \e[33melse\e[0m \e[33mreturn\e\
    [0m \e[31m\"NO\"\e[0m\n\e[31m27 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ if(lst1.isEmpty)\n            return lst2.isEmpty\n        else if(lst2.isEmpty)\n\
    \            return lst1.isEmpty\n        else if(lst1.head % 2 == 0 && lst2.head\
    \ % 2 == 0) {\n            val evens = lst1.tail\n            val odds  = lst2.tail\n\
    \            val exchanges = odds - evens\n            if(exchanges.isEmpty)\n\
    \                return \"YES\"\n            else\n                return \"NO\"\
    \n        }\n        else\n            return \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnelh0mx0.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mreturn\e[0m\
    \ lst2.isEmpty\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Found:    Boolean\n\e[31m   |\e[0m           \
    \        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpnelh0mx0.scala:21:24 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            \e[33mreturn\e[0m lst1.isEmpty\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:  \
    \  Boolean\n\e[31m   |\e[0m                   Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnelh0mx0.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mexchanges\e[0m = odds\
    \ - evens\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue - is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659979892
