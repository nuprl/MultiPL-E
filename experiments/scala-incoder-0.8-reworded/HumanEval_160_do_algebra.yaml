name: HumanEval_160_do_algebra
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n    // the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n    // expression and return the evaluation of this\
  \ expression.\n    // The basic algebra operations:\n    // Addition ( + ) \n  \
  \  // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor division (\
  \ // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+', '*',\
  \ '-']\n    // list = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    // => result\
  \ = 9\n    // Note:\n    // The length of operator list is equal to the length of\
  \ operand list minus one.\n    // Operand is a list of of non-negative integers.\n\
  \    // Operator list has at least one operator, and operand list has at least two\
  \ operands.\n    def doAlgebra(op : List[String], operand : List[Long]) : Long =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
  **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
  \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
  //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
  \n}\n"
completions: ["        val operator = op.map(_.toLowerCase).getOrElse(List(\"*\",\"\
    /\",\"+\",\"-\",\"**\",\"//\"))\n        val numList = operand.map(_.toLong)\n\
    \        val opList = operator.toList\n        var sum = 0\n        \n       \
    \ // Use two for loops to compute the sum of operand and operator\n        for(\
    \ i <- 0 until numList.length ) {\n            for(j <- 0 until opList.length\
    \ ) {\n                sum = sum + opList(j) * numList(i)\n            }\n   \
    \     }\n        return sum", "        var opList = op.toList\n        val operand_copy\
    \ = operand.clone()\n        val stack = mutable.Stack[Int]()\n        var count\
    \ = 0\n\n        // Operator list has at least one operator\n        opList.foreach(x\
    \ => {\n            val value = operand_copy(0)\n            val next_value =\
    \ operand_copy(1)\n            val index = operand.indexOf(x)\n            operand_copy\
    \ -= 1\n            if (index > 0) {\n                stack.push(operand(index))\n\
    \                count += 1\n            }\n            else {\n             \
    \   val val = stack.pop()\n                val new_value = operand_copy(val) +\
    \ value\n                operand_copy -= 1\n                stack.push(new_value)\n\
    \                count += 1\n            }\n        })\n\n        // Operand list\
    \ has at least two operands\n        val value2 = operand_copy(0)\n        val\
    \ value3 = operand_copy(1)\n        operand_copy -= 1\n        if (operand_copy.nonEmpty)\
    \ {\n            stack.push(value2)\n            count += 1\n        }\n     \
    \   else {\n            val result2 = stack.pop()\n            val result3 = stack.pop()\n\
    \            val result = value2 + value3 * result2 - result3\n            operand_copy\
    \ -= 1\n            stack.push(result)\n            count += 1\n        }\n  \
    \      operand_copy.foreach(x => {\n            val value = operand_copy(0)\n\
    \            val next_value = operand_copy(1)\n            operand_copy -= 1\n\
    \            if (operand_copy.nonEmpty) {\n                stack.push(operand(index))\n\
    \                count += 1\n            }\n            else {\n             \
    \   val val = stack.pop()\n                val new_value = operand_copy(val) +\
    \ value\n                operand_copy -= 1\n                stack.push(new_value)\n\
    \                count += 1\n            }\n        })\n        stack.pop()",
  "        val operators = op.map(op => Operator.valueOf(op)).toList\n        val\
    \ operands = operand.map(operand => operand.toInt).toList\n        val length\
    \ = operators.length\n        val first = operators.head\n        if (length <\
    \ 1 || length < operands.length) {\n            return 0\n        }\n        var\
    \ ans = 0\n        // Recursive definition\n        def calc(i: Int, j: Int, op\
    \ : String, ops : List[String], o : List[Long]) : Long = {\n            // End\
    \ of recursion\n            if (i == length) {\n                return ans * operands.head\n\
    \            }\n            val a = operators.apply(i)\n            val b = operators.apply(j)\n\
    \            if (a == 0) {\n                calc(i, j + 1, op, ops, o)\n     \
    \       } else {\n                // Handle negative numbers\n               \
    \ val c = if (j == 0) -operands.head\n                else operands.apply(j)\n\
    \                // Recursive call\n                val res = calc(i - 1, j -\
    \ 1, op + a + b, ops, o :+ c)\n                // Handle positive numbers\n  \
    \              val d = if (i == length) 0\n                else operands.apply(i)\n\
    \                // Recursive call\n                val res1 = calc(i, j + 1,\
    \ op + b + a, ops, o :+ d)\n                // Handle zero numbers\n         \
    \       val res = if (a == \"-\") res1 - res\n                else res1 + res\n\
    \                ans = res\n            }\n        }\n        calc(length / 2,\
    \ length / 2, first, operators, operands)", "        // Step 1: Find max length.\n\
    \        var maxLength = 0\n        var oper = 0\n        for (ope <- op) {\n\
    \            if (ope == '+' || ope == '-' || ope == '*' || ope == '/' || ope ==\
    \ '%' || ope == '**') {\n                oper = oper\n                maxLength\
    \ = op.size\n            }\n        }\n        // Step 2: Build a map of operators\
    \ and their corresponding operands.\n        var operatorMap : mutable.Map[String,\
    \ List[Long]] = mutable.Map[String, List[Long]]()\n        var i = 1\n       \
    \ while ( i < maxLength ) {\n            if (i == maxLength) {\n             \
    \   operatorMap += (op(oper.charAt(0).toInt) + oper.charAt(1).toInt) -> operand.take(i).reverse\n\
    \            } else {\n                operatorMap += (oper.charAt(0).toInt) +\
    \ oper.charAt(1).toInt -> operand.take(i).toList\n            }\n            i\
    \ += 1\n        }\n        // Step 3: Calculate the expression and return.\n \
    \       var result = 0L\n        var stack : List[Long] = List()\n        for\
    \ ( key <- operatorMap.toList ) {\n            stack = stack :+ operatorMap(key).head\n\
    \            result += operatorMap(key).last\n        }\n        stack.reverse\n\
    \        result", "        var sum = 0L\n        operand.foreach{i =>\n      \
    \      val op = op(0)\n            if (op == \"+\") {\n                sum +=\
    \ i\n            } else if (op == \"-\") {\n                sum -= i\n       \
    \     } else if (op == \"*\") {\n                sum *= i\n            } else\
    \ if (op == \"//\") {\n                sum /= i\n            } else if (op ==\
    \ \"**\") {\n                sum **= i\n            }\n        }\n        sum",
  "        def doOp(op : List[String], operand : List[Long], r : Long) : Long = {\n\
    \            // Base case\n            if((op.length == 0) || (operand.length\
    \ == 0)) {\n                return r\n            }\n            \n          \
    \  // Recursive case\n            val op = op(0)\n            val operand1 = operand(0)\n\
    \            val operand2 = operand(1)\n            val r = doOp(op,operand1,r)\
    \ + doOp(op,operand2,r)\n            doOp(op,operand,r)\n        }\n        val\
    \ op = op(0)\n        val operand1 = operand(0)\n        val operand2 = operand(1)\n\
    \        val r = doOp(op,operand1,0L) + doOp(op,operand2,0L)\n        doOp(op,operand,0L)",
  "        if (op.size == 0) throw new ArithmeticException(\"operator list is empty\"\
    )\n        if (operand.size == 0) throw new ArithmeticException(\"operand list\
    \ is empty\")\n        var sum = 0\n        val operator = op.head\n        val\
    \ operands = operand.tail\n\n        for (i <- 1 to operands.size) {\n       \
    \     val op = operator.charAt(op.length - i - 1)\n            val temp = if (op\
    \ == '+') operands.head + operands.tail(i) else operands.head - operands.tail(i)\n\
    \            sum =  sum + temp\n        }\n        return sum", "        val operations\
    \ = op zip (operand drop 1)\n        val numOperations = operations.size\n   \
    \     val operands = operations.map(x => x._2)\n        val result = operands.foldLeft(0)((a,\
    \ b) => a ++ b << 1)\n        result", "        // Solution 1: \n        val exp\
    \ = operand.toList.zipWithIndex.flatMap{case (xs, i) =>\n            val op =\
    \ op(i)\n            xs.zip(ops.map(_.apply))\n        }.filter(x => x != 0).sum\n\
    \n        // Solution 2: \n        val exp = operand.toList.zipWithIndex.flatMap{case\
    \ (xs, i) =>\n            val op = op(i)\n            xs.zip(ops.map(_.apply)).filter(_._1\
    \ != 0).sum\n        }\n\n        // Solution 3:\n        val exp = operand.toList.zipWithIndex.flatMap{case\
    \ (xs, i) =>\n            val op = op(i)\n            ops.map(_.apply(xs)).sum\n\
    \        }\n\n        ", "        var total = 0L\n        for(i <- 0 until operand.length)\n\
    \        {\n            total += operand(i)*op.head(i-1)\n        }\n        total",
  "        var stack = mutable.Stack[Long]()\n        for (e <- operand) {\n     \
    \       if (stack.size > 0) {\n                stack.push(e)\n            } else\
    \ if (stack.size != 0) {\n                stack.push(e * stack.pop)\n        \
    \    }\n        }\n        val result = 0L\n        for (f <- op) {\n        \
    \    if (f == \"+\") {\n                result = result + stack.pop()\n      \
    \      } else if (f == \"-\") {\n                result = result - stack.pop()\n\
    \            } else if (f == \"*\") {\n                result = result * stack.pop()\n\
    \            } else if (f == \"//\") {\n                result = result / stack.pop()\n\
    \            } else if (f == \"**\") {\n                result = result ** stack.pop()\n\
    \            } else {\n                throw new Exception(\"Unknown Algebra Operation!\"\
    )\n            }\n        }\n        return result", "        if(!op.isEmpty &&\
    \ !operand.isEmpty) {\n            val ops = op.zipWithIndex\n            val\
    \ ops = ops.filter(_._2 != ops.length - 1)\n            val operands = operand.zipWithIndex\n\
    \            val operands = operands.filter(_._2 != operands.length - 1)\n   \
    \         val left = operands(0)\n            val right = operands(1)\n      \
    \      var sum = 0L\n            val leftMap = ops.map(_._1)\n            val\
    \ rightMap = ops.map(_._2)\n            ops.foreach {\n                case (\"\
    +\", j) => sum = sum + leftMap(j) * rightMap(j)\n                case (\"-\",\
    \ j) => sum = sum - leftMap(j) * rightMap(j)\n                case (\"*\", j)\
    \ => sum = sum + leftMap(j) * rightMap(j)\n                case (\"//\", j) =>\
    \ sum = sum + (leftMap(j) floor / rightMap(j))\n                case (\"**\",\
    \ j) => sum = sum + (leftMap(j) ^ rightMap(j))\n            }\n            sum\n\
    \        } else {\n            0\n        }", "        val length = operand.length\n\
    \        val operator = op.length\n        require(operator > 0 && length >= 2\
    \ && length == operator, \"Invalid parameter values: operator length != operand\
    \ length\")\n        require(op.length > 0 && length >= 1, \"Invalid parameter\
    \ values: operator list has only 1 operator\")\n        val opList = new mutable.LinkedList[Long]()\n\
    \        var sum = 0L\n        var i = 0\n        while (i < length) {\n     \
    \       val op = op.head\n            val operand = operand(i).toLong\n      \
    \      val opVal = operation(op, operand)\n            opList += opVal\n     \
    \       sum += opVal\n            i += 1\n        }\n        sum", "        var\
    \ sum: Long = 0\n        var operatorCount = 0\n        val numList = (operand.size).fill(0L).map(_\
    \ => 0)\n        val opList = (op.size).fill(0).map(_ => 0)\n        numList(0)\
    \ = operand(0)\n        val opList2 = op.tail.map(op2 => numList(0) * op2(1))\n\
    \        for (i in 1 until operand.size-1) {\n            numList(i) = operand(i)\
    \ + numList(i-1)\n        }\n        val listSize = (numList.size)\n        if\
    \ (listSize <= 1) {\n            sum = numList(0)\n        } else if (listSize\
    \ > 2) {\n            for (i in 1 until listSize-1) {\n                sum +=\
    \ opList(operatorCount) * numList(i)\n            }\n            operatorCount\
    \ += 1\n        }\n        sum", "        val opIndex =op.indexWhere(c => c==\"\
    *\").getOrElse(op.size-1)\n        val op1 = opIndex - 1\n        val op2 = opIndex\
    \ + 1\n        var result = 0\n        for (i<-1 to operand.size-1) {\n      \
    \      if (i == op1) result += (operand(i) * operand(op2))\n            if (i\
    \ == op2) result -= (operand(i) * operand(op1))\n        }\n        result", " \
    \       var sum = 0\n        for( i <- 0 until operand.length ) {\n          \
    \  sum += operate(op(i), operand(i))\n        }\n        return sum", "      \
    \  // Solution starts here.\n        // Define an empty list.\n        val res\
    \ = mutable.ListBuffer.empty[Long]\n        \n        // If only one operator,\
    \ append operand to the list.\n        if(op.size === 1) {\n            res +=\
    \ operand(0)\n        }\n        \n        // If two operators, append the result\
    \ of addition to the list.\n        if(op.size === 2) {\n            res += operand(0)\
    \ + operand(1)\n        }\n        \n        // If more than two operators, append\
    \ the result of multiplication to the list.\n        if(op.size >= 3) {\n    \
    \        \n            // Initialize multiplication result.\n            var mulRes\
    \ : Long = 1\n            \n            // Loop through the operandos and operators,\
    \ evaluating \n            // the expression and appending the result to the list.\n\
    \            for(i <- 0 until operand.size - 1) {\n                val op1 = op(0)\n\
    \                val op2 = op(1)\n                val op3 = op(2)\n          \
    \      val op4 = op(3)\n                val op5 = op(4)\n                val op6\
    \ = op(5)\n                val op7 = op(6)\n                val op8 = op(7)\n\
    \                \n                mulRes *= operand(i)\n                \n  \
    \              if(op1 != \"+\") {\n                    if(op2 == \"+\") {\n  \
    \                      res += mulRes\n                    } else if(op2 == \"\
    -\") {\n                        res += mulRes * -1\n                    } else\
    \ if(op2 == \"*\") {\n                        res += mulRes\n                \
    \    } else if(op2 == \"//\") {\n                        res += mulRes / operand(i)\n\
    \                    } else if(op2 == \"**\") {\n                        res +=\
    \ mulRes ** operand(i)\n                    }\n                }\n           \
    \     \n                if(op3 != \"+\") {\n                    if(op4 == \"+\"\
    ) {\n                        res += mulRes\n                    } else if(op4\
    \ == \"-\") {\n                        res += mulRes * -1\n                  \
    \  } else if(op4 == \"*\") {\n                        res += mulRes\n        \
    \            } else if(op4 == \"//\") {\n                        res += mulRes\
    \ / operand(i)\n                    } else if(op4 == \"**\") {\n             \
    \           res += mulRes ** operand(i)\n                    }\n             \
    \   }\n                \n                if(op5 != \"+\") {\n                \
    \    if(op6 == \"+\") {\n                        res += mulRes\n             \
    \       } else if(op6 == \"-\") {\n                        res += mulRes * -1\n\
    \                    } else if(op6 == \"*\") {\n                        res +=\
    \ mulRes\n                    } else if(op6 == \"//\") {\n                   \
    \     res += mulRes / operand(i)\n                    } else if(op6 == \"**\"\
    ) {\n                        res += mulRes ** operand(i)\n                   \
    \ }\n                }\n                \n                if(op7 != \"+\"", " \
    \       val res = 0\n        // build up the expression\n        val operandLength\
    \ = operand.size\n        val operatorLength = op.size\n        var i = operandLength-1\n\
    \        while (i >= 0) {\n            res += operand(i) * op(operatorLength-i-1)\n\
    \            i -= 1\n        }\n        res", "        val length = op.length\n\
    \        if (length < 2 || length != operand.length)\n            throw new Exception(\"\
    Invalid list\")\n        val ops = op.map(x => x.toDouble)\n        val operands\
    \ = operand.map(x => x.toInt)\n        val result = 0.0\n        for (i <- 0 until\
    \ length)\n            for (j <- 0 until length)\n                result += op(j)\n\
    \            for (k <- 0 until operands(length))\n                result -= operands(k)\n\
    \        result", "        val map = Map(op.length -> 0)\n        operand.foreach(\
    \ x => {\n            for(i <- 0 until op.length) map(i) += x % 2\n        })\n\
    \        val op = op.tail\n        operand.foreach( x => {\n            for(i\
    \ <- 0 until op.length) map(i) -= x % 2\n        })\n        operand.foreach(\
    \ x => {\n            for(i <- 0 until op.length) map(i) *= x % 2\n        })\n\
    \        operand.foreach( x => {\n            for(i <- 0 until op.length) map(i)\
    \ /= x % 2\n        })\n        operand.foreach( x => {\n            for(i <-\
    \ 0 until op.length) map(i) //= x % 2\n        })\n        val sum = 0L\n    \
    \    operand.foreach( x => {\n            val r = map(x) // % 2 == 1\n       \
    \     sum -= r\n        })\n        sum", "        def eval(operator: List[String],\
    \ operands: List[Long], index: Int): Long = {\n            if (index >= operator.length){\n\
    \                return operands(0)\n            }\n            val operand1 =\
    \ operands(index)\n            val operand2 = eval(operator, operands, index +\
    \ 1)\n            val operator1 = operator(index)\n            \n            val\
    \ ret = operand1.getClass.getMethod(\"$\"+operator1).invoke(operand1, operand2)\n\
    \            ret\n        }\n        val operatorList = op\n        val operands\
    \ = operand\n        val ret = 0\n        val ret2 = 0\n        val operator1\
    \ = operatorList(0)\n        val operator2 = operatorList(1)\n        val operand1\
    \ = operands(0)\n        val operand2 = operands(1)\n        val ret1 = eval(operatorList,\
    \ operands, 0)\n        val ret2 = eval(operatorList, operands, 1)\n        val\
    \ ret = ret1 + ret2\n        ret", "        if (op.size != operand.size) throw\
    \ new IllegalArgumentException(\"Operator and operand lists must have same length\"\
    )\n        if (op.size == 0) throw new IllegalArgumentException(\"Operator list\
    \ must have at least one operator\")\n        if (operand.size == 0) throw new\
    \ IllegalArgumentException(\"Operand list must have at least two operands\")\n\
    \        val result = 0L\n        val operators = op.tail\n        val operator\
    \ = operators.head\n        val operands = operand.tail\n        val operand =\
    \ operands.head\n        operands.foreach(operand => {\n            if (operator.equals(\"\
    +\")) result += operand\n            else if (operator.equals(\"-\")) result -=\
    \ operand\n            else if (operator.equals(\"*\")) result *= operand\n  \
    \          else if (operator.equals(\"//\")) result /= operand\n            else\
    \ if (operator.equals(\"**\")) result **= operand\n            else throw new\
    \ IllegalArgumentException(\"Illegal operator: \" + operator)\n        })\n  \
    \      result", "        // Initializing the variables\n        val stack : Stack[Int]\
    \ = Stack()\n        var ans = 0.0\n        // The basic operation stack\n   \
    \     stack push 0\n        // The operand stack\n        operand foreach { i\
    \ => stack push i }\n        // The operator stack\n        op foreach { op =>\
    \ {\n            op match {\n                case \"+\" => {\n               \
    \     ans += ((stack pop) * (stack pop))\n                }\n                case\
    \ \"-\" => {\n                    ans -= ((stack pop) * (stack pop))\n       \
    \         }\n                case \"*\" => {\n                    ans *= ((stack\
    \ pop) * (stack pop))\n                }\n                case \"//\" => {\n \
    \                   ans /= (math.pow(stack pop, math.ceil(stack pop)))\n     \
    \           }\n                case \"**\" => {\n                    ans *= (math.pow(stack\
    \ pop, stack pop))\n                }\n                default => {\n        \
    \            throw new IllegalArgumentException(\"Invalid operator.\")\n     \
    \           }\n            }\n            stack push (op match {\n           \
    \     case \"+\" => stack pop\n                case \"-\" => stack pop\n     \
    \           case \"*\" => stack pop\n                case \"//\" => math.pow(stack\
    \ pop, math.ceil(stack pop))\n                case \"**\" => stack pop\n     \
    \           default => throw new IllegalArgumentException(\"Invalid operator.\"\
    )\n            })\n        }}\n        ans.toDouble", "        // (1) Build the\
    \ expression string.\n        var exp = operand(0).toString + op(0).toString\n\
    \        // (2) Add all elements from operand list.\n        for( i <- 1 to operand(1).size\
    \ ) {\n            exp = exp + op(i).toString + \"(\" + operand(0) +\")\"\n  \
    \      }\n        // (3) Build the algebra expression from string.\n        val\
    \ expr = \"(\" + exp + \")\"\n        // (4) Evaluate the expression.\n      \
    \  expr.toLong", "        val operands = operand.map(i => Array(i)).map(a => Array(a))\n\
    \        val operators = op.map(o => Array(o))\n        val result = operands.map\
    \ {\n            a =>\n            operators.map {\n                b =>\n   \
    \             a(b(0))*a(b(1)) + a(b(0))*a(b(1)) - a(b(0))*a(b(1))\n          \
    \  }.sum\n        }.sum\n        result", "        val operandList = new mutable.ArrayBuffer[Long]()\n\
    \        var opIndex = 0\n        var opIndex2 = -1\n        var res = 0L\n  \
    \      var i = 0\n        while(i < operand.length) {\n            if(opIndex\
    \ == op.length) {\n                opIndex = 0\n                opIndex2 = -1\n\
    \                operandList.clear()\n                i = 0\n            }\n \
    \           \n            if(opIndex2 == op.length) {\n                opIndex2\
    \ = 0\n                opIndex2 = -1\n                operandList.clear()\n  \
    \              i = 0\n            }\n            \n            operandList +=\
    \ operand(i)\n            val tmpIndex = operandList.length - 1\n            \n\
    \            if(opIndex == 0 && tmpIndex >= 0) {\n                val tmp = operand(tmpIndex)\n\
    \                opIndex = tmpIndex\n                tmpIndex -= 1\n         \
    \       res = res + tmp\n                i += 1\n                continue\n  \
    \          }\n            \n            if(opIndex2 == 0 && tmpIndex >= 0) {\n\
    \                val tmp = operand(tmpIndex)\n                opIndex2 = tmpIndex\n\
    \                tmpIndex -= 1\n                res = res - tmp\n            \
    \    i += 1\n                continue\n            }\n            \n         \
    \   if(opIndex == op.length - 1) {\n                val tmp = operand(tmpIndex)\n\
    \                opIndex = tmpIndex\n                tmpIndex -= 1\n         \
    \       res = res + tmp\n                i += 1\n                continue\n  \
    \          }\n            \n            if(opIndex2 == op.length - 1) {\n    \
    \            val tmp = operand(tmpIndex)\n                opIndex2 = tmpIndex\n\
    \                tmpIndex -= 1\n                res = res - tmp\n            \
    \    i += 1\n                continue\n            }\n            \n         \
    \   val tmp = operandList.toList\n            var opIndex = op.length - 1 \n \
    \           var opIndex2 = op.length - 1 \n            \n            while(opIndex\
    \ >= 0 && opIndex2 >= 0) {\n                val tmpOp = op(opIndex)\n        \
    \        val tmpOp2 = op(opIndex2)\n                if(tmpOp == tmpOp2) {\n  \
    \                  opIndex -= 1 \n                    opIndex2 -= 1\n        \
    \            operandList.toList -= tmp\n                    i = i - 1\n      \
    \              continue\n                }\n                if(tmpOp == \"\")\
    \ {\n                    opIndex -= 1\n                    continue\n        \
    \        }\n                if(tmpOp2 == \"\") {\n                    opIndex2\
    \ -= 1\n                    continue\n                }\n                \n  \
    \              operandList += operand(i) \n                tmpIndex -= 1\n   \
    \             tmpIndex -= 1\n                val tmpIndex = operandList.length\
    \ - 1 \n                \n                val tmpOp = op(opIndex)\n          \
    \      val tmpOp2 = op(opIndex2)\n                if(tmpOp == tmpOp2) {\n    \
    \                opIndex -= 1 \n                    opIndex2 -= 1\n          \
    \          operandList.toList -= tmp\n                    i = i - 1\n        \
    \            continue\n                }\n                if(tmpOp == \"\") {\n\
    \                    opIndex -= 1\n", "        val list = op.toList\n        val\
    \ operandWithNegative = operand.toList.reverse\n\n        val result = operand\
    \ match {\n            case a :: b :: Nil => a\n            case a :: Nil    \
    \  => b\n            case _ => operandWithNegative.foldLeft(0L)( (a, c) =>\n \
    \               val temp = a + c\n                list.zip(operandWithNegative).foldLeft(temp)(\
    \ (a, (b,c)) => b + c)\n            )\n        }\n        result", "        val\
    \ exprList = List(op(0), operand(0))\n        var i : Int = 0\n        while(i\
    \ < exprList.size) {\n            if(exprList(i) < 0) {\n                throw\
    \ new RuntimeException(\"Not a valid Algebra Expression!\")\n            }\n \
    \           i += 1\n        }\n        val exprList2 = List(op(i - 1), operand(i\
    \ - 1))\n        val operators = op.dropRight(1)\n        val operands = operand.drop(1)\n\
    \        val length = exprList2.size - 1\n        var oppositeIndex = 0\n    \
    \    var oppositeOppositeIndex = 0\n        val result = exprList2.head\n    \
    \    while(i < length) {\n            val opposite = exprList2(oppositeIndex++).toString\n\
    \            val oppositeOpposite = exprList2(oppositeOppositeIndex++).toString\n\
    \            val op = operators(i).toString\n            val operand = operands(i).toString\n\
    \            val expr = (op + operand + opposite).toLong\n            result *=\
    \ expr\n        }\n        result", "        if(op.length != operand.length) \n\
    \            throw new IllegalArgumentException(\"operator list length does not\
    \ match operand list length\")\n        val opMap = Map(op.toList -> 1)\n    \
    \    val opList = new scala.collection.mutable.ListBuffer[String]()\n        var\
    \ opVal: Long = 1\n        operand.foreach(x => {\n            opList += x\n \
    \           opVal += opMap.getOrElse(x, 0)\n        })\n        opVal", "    \
    \    // TODO: Write your code here\n        val operators = op.size\n        val\
    \ operands = operand.size\n        val stack = mutable.Stack[Long]()\n       \
    \ var i = 0\n        while (i < operators) {\n            val operator = operators(i).toChar\n\
    \            val operand = operands(i).toLong\n            if (operator == '+')\
    \ {\n                stack += operand\n            }\n            if (operator\
    \ == '-') {\n                stack -= operand\n            }\n            if (operator\
    \ == '*') {\n                stack *= operand\n            }\n            if (operator\
    \ == '/') {\n                stack /= operand\n            }\n            if (operator\
    \ == '//') {\n                stack /= operand\n            }\n            if\
    \ (operator == '**') {\n                stack **= operand\n            }\n   \
    \         i += 1\n        }\n        return stack.pop()", "        val ops = op.sortBy(op(_))\n\
    \        val result = 0\n        var index = 0\n        while (index < ops.size)\
    \ {\n            if (index == ops.size) {\n                result += (operand(index)\
    \ match {\n                    case _: Float => operand(index).toLong\n      \
    \              case _ => operand(index).toInt\n                })\n          \
    \      break\n            }\n            result += (operand(index) match {\n \
    \               case _: Float => operand(index).toLong\n                case _\
    \ => operand(index).toInt\n            }) * ops(index)(0)\n            index +=\
    \ 1\n        }\n        result", "        var sum = 0L\n        var i = -1\n \
    \       while (i < op.length && i < operand.length - 1) {\n            if (i <\
    \ 0) {\n                val operand2 = operand.drop(1)\n                val operator2\
    \ = op.drop(1).mkString\n                val operand2 = operand2.mkString\n  \
    \              sum += (operand2(0) to operand2(operand.length - 1) map {\n   \
    \                 x => operator2(x) }.reduceLeft((a, b) => a + b).toLong)\n  \
    \          }\n            else {\n                val operand2 = operand.drop(i)\n\
    \                val operator2 = op.drop(i).mkString\n                val operand2\
    \ = operand2.mkString\n                sum += (operand2(0) to operand2(operand.length\
    \ - 1) map {\n                    x => operator2(x) }.reduceLeft((a, b) => a +\
    \ b).toLong)\n            }\n            i += 1\n        }\n        sum", "  \
    \      val operator = op.asInstanceOf[List[String]]\n        val result = operand.foldLeft(0L)\
    \ {\n            case ((sum,index),i) => \n              val leftOperand = operand(index-1)\n\
    \              val rightOperand = operand(index)\n              val operatorName\
    \ = operator(index)\n              val result = leftOperand match {\n        \
    \        case x if x.isInstanceOf[String] => Right((x.asInstanceOf[String]).toLong)\n\
    \                case x if x.isInstanceOf[Int] => Right((x.asInstanceOf[Int]).toLong)\n\
    \                case _ => Left(s\"Invalid Operator (${operatorName}).\")\n  \
    \            }\n              result._1 match {\n                case Right(x)\
    \ => sum + x\n                case Left(msg) => sum\n              }\n       \
    \     case _ => 0L\n          }\n        result._1", "        val op = op.filterNot(_.isEmpty)\n\
    \        val operand = operand.filterNot(_.isEmpty)\n        if (op.size != operand.size)\
    \ \n            throw new ArithmeticException(\"Operator and Operand list length\
    \ is not equal.\")\n        val operator = op.map(f => f.toLowerCase)\n      \
    \  val operandWithOp = operand.zipWithIndex.map(f => f(1))\n        val res =\
    \ operandWithOp.flatMap { case (fst, i) => \n            val op = operator(i)\n\
    \            List(op match {\n                case \"+\" => fst + fst\n      \
    \          case \"-\" => fst - fst\n                case \"*\" => fst * fst\n\
    \                case \"//\" => fst / fst\n                case \"**\" => fst.pow(fst)\n\
    \            })\n        }\n        res.sum", "        val alg = op.length\n \
    \       val operandLength = len(operand)\n        if (operandLength > 0) {\n \
    \           var left = 0\n            var right = 0\n            for (i <- 0 until\
    \ operandLength) {\n                if (operand (i) > 0) {\n                 \
    \   if (right != 0) {\n                        right = left + (operand (i) - right)\
    \ * right\n                    }\n                    left = operand (i) + left\n\
    \                }\n                else {\n                    right = left *\
    \ (-1)\n                }\n            }\n            return right\n        }\n\
    \        return 0", "        var num = 1\n        val opStack = mutable.Stack[String]()\n\
    \        val operandStack = mutable.Stack[Long]()\n        for(x<-op){\n     \
    \       opStack += x\n        }\n        for(x<-operand){\n            operandStack\
    \ += x\n        }\n        while(!opStack.isEmpty || !operandStack.isEmpty){\n\
    \            val op = opStack.pop()\n            val operand = operandStack.pop()\n\
    \            val sum = operand match {\n                case 0 => 0\n        \
    \        case 1 => operand\n                case _ => operand + num * operand\n\
    \            }\n            val num2 = num match {\n                case 0 =>\
    \ 0\n                case 1 => num\n                case _ => num * num\n    \
    \        }\n            opStack += op\n            operandStack += sum\n     \
    \       num = num2\n        }\n        num", "      var i = 1\n      var mul =\
    \ 1\n      var res = operand.head\n      var mul1 = 1\n      for(i <- 1 until\
    \ operand.length){\n          mul = mul * operand(i)\n          mul1 = mul1 *\
    \ operand(i)\n          res = op(res, operand(i))\n          i = i + 1\n     \
    \ }\n      return res", "        def eval(str : String, i : Int, num : Long) :\
    \ Long = {\n            if (i == str.length) num\n            else eval(str.substring(i),\
    \ i + 1, num * str.charAt(i).toLong + operand(i))\n        }\n        eval(op.mkString(),\
    \ 0, 1) // start from index 0 and keep doing index 0 until you get to the end",
  "        // 1. Build the operation list \n        var ops: List[String] = List()\n\
    \        var op: String = operator(op, operand)\n        while (op.nonEmpty) {\n\
    \            ops = ops :+ op\n            op = operator(op, operand)\n       \
    \ }\n        // 2. Evaluate the operation list \n        var res: Long = 0L\n\
    \        for (op <- ops) {\n            if (op eq '+') {\n                res\
    \ = res + operand(operands.length-1)\n            } else if(op eq '-') {\n   \
    \             res = res - operand(operands.length-1)\n            } else if(op\
    \ eq '*') {\n                res = res * operand(operands.length-1)\n        \
    \    } else if(op eq '/') {\n                res = res / operand(operands.length-1)\n\
    \            } else if(op eq '**') {\n                res = res * operand(operands.length-1)\n\
    \            } else if(op eq '%') {\n                res = res / operand(operands.length-1)\n\
    \            } else if(op eq 'floor') {\n                res = math.floor(res\
    \ / operand(operands.length-1))\n            } else if(op eq 'ceil') {\n     \
    \           res = math.ceil(res / operand(operands.length-1))\n            }\n\
    \        }\n        return res", "        // base case: if operator list is empty\
    \ or length is 1, return first operand as result\n        if(op.isEmpty || op.size\
    \ <= 1){\n            return operand(0)\n        }\n        \n        // otherwise,\
    \ divide the first operand by the first operator, \n        // then divide the\
    \ result of the first divide by the second operator, \n        // then divide\
    \ the result of the first divide by the third operator, \n        // then repeat\
    \ the process for the remaining operands.\n        val firstOperand = operand(0)\n\
    \        val firstOperation = op(0) // first operator in operator list\n     \
    \   val firstOperandDividend = firstOperand / firstOperation\n        val remainingOperands\
    \ = operand - firstOperandDividend\n        val nextFirstOperation = op(1) //\
    \ first operator in operator list\n        val nextFirstOperandDividend = nextFirstOperand\
    \ / nextFirstOperation\n        val remainingRemainingOperands = remainingOperands\
    \ - nextFirstOperandDividend\n        val nextSecondOperation = op(2) // first\
    \ operator in operator list\n        val nextSecondOperandDividend = nextSecondOperand\
    \ / nextSecondOperation\n        val remainingRemainingRemainingOperands = remainingRemainingOperands\
    \ - nextSecondOperandDividend\n        val nextThirdOperation = op(3) // first\
    \ operator in operator list\n        val nextThirdOperandDividend = nextThirdOperand\
    \ / nextThirdOperation\n        val remainingRemainingRemainingRemainingOperands\
    \ = remainingRemainingRemainingOperands - nextThirdOperandDividend\n        val\
    \ nextFourthOperation = op(4) // first operator in operator list\n        val\
    \ nextFourthOperandDividend = nextFourthOperand / nextFourthOperation\n      \
    \  val remainingRemainingRemainingRemainingRemainingOperands = remainingRemainingRemainingRemainingOperands\
    \ - nextFourthOperandDividend\n        // recursion case\n        return doAlgebra(op\
    \ ++ remainingRemainingOperands, remainingRemainingRemainingOperands ++ remainingRemainingRemainingRemainingOperands\
    \ ++ remainingRemainingRemainingRemainingRemainingOperands ++ remainingRemainingRemainingRemainingRemainingRemainingOperands\
    \ ++ remainingRemainingRemainingRemainingRemainingRemainingRemainingOperands) ",
  "        require(op.length == operand.length - 1, 'operator list and operand list\
    \ must have the same length')\n        var result = 0L\n        var index = 0\n\
    \        val list1 = operand.drop(1)\n        val list2 = operand.dropRight(1)\n\
    \        while ((index < op.length) && (index < operand.length)) {\n         \
    \   val op = list1(0)\n            val operand1 = list1(index)\n            val\
    \ operand2 = list2(index)\n            result += (math.pow((op.charAt(0)).toInt,\
    \ operand1) * math.pow(operand2, (op.charAt(1)).toInt))\n            index +=\
    \ 1\n        }\n        return result", '        // Write your code here', " \
    \       val opMap = new mutable.LinkedHashMap[String, Long]()\n        val opLen\
    \ = op.size\n        val opVals = op.map(x => x.toLong)\n        val operandMap\
    \ = new mutable.LinkedHashMap[String, Long]()\n        val operandLen = operand.size\n\
    \        if(opLen > operandLen)\n            throw new RuntimeException(\"Too\
    \ many operands\")\n        if(opLen < 1)\n            throw new RuntimeException(\"\
    Too few operators\")\n        for(i <- 0 until operandLen)\n            operandMap(op(i),i)\n\
    \        while(true)\n        {\n            val key = opMap.values.iterator.toList.last\n\
    \            if(key == null)\n                return opMap.lastOption.getOrElse(0)\n\
    \            val value = operandMap.get(key).get\n            if(value == null)\n\
    \                throw new RuntimeException(\"No value at key \" + key)\n    \
    \        val newValue = opMap(key) + value\n            opMap.put(key, newValue)\n\
    \        }", "        val stack = mutable.Stack[String]()\n        var result\
    \ = 0L\n        for(i <- 0 until operand.size) {\n            val value = operand(i)\n\
    \            if(stack.size() == 0) {\n                stack.push(op(0))\n    \
    \            result += value\n            } else {\n                val op = stack.pop()\n\
    \                val newValue = value + op\n                if(newValue > 0) {\n\
    \                    stack.push(op(newValue))\n                } else if(newValue\
    \ < 0) {\n                    stack.push(op(-newValue))\n                }\n \
    \           }\n        }\n        return result", "        def isOperatorValid(operator:\
    \ List[String]): Boolean = operator match {\n            case List(\"+\", \"*\"\
    ) => true\n            case List(\"-\", \"//\") => true\n            case _ =>\
    \ false\n        }\n        val operators = op.map { x => x.toString }\n     \
    \   val operands = operand.map { x => x.toLong }\n        val length = operands.size\
    \ + 1\n        val operatorLength = operators.size + 1\n        val finalResult\
    \ = operands.head\n        operators.headOption match {\n            case Some(operator)\
    \ => \n                val currentOperator = operators.drop(1).head\n        \
    \        operators.drop(1).foreach { x =>\n                    val currentOperand\
    \ = operands.drop(1).head\n                    val finalOperand = operands.drop(1).head\n\
    \                    val result = finalOperand match {\n                     \
    \   case x if currentOperator == \"+\" => x + currentOperand\n               \
    \         case x if currentOperator == \"-\" => x - currentOperand\n         \
    \               case x if currentOperator == \"*\" => x * currentOperand\n   \
    \                     case x if currentOperator == \"//\" => x // currentOperand\n\
    \                        case x if currentOperator == \"**\" => x ** currentOperand\n\
    \                        case _ => \n                            throw new IllegalArgumentException(\"\
    Invalid operator: \" + currentOperator)\n                    }\n             \
    \       finalResult match {\n                        case x if currentOperator\
    \ == \"+\" => finalResult + result\n                        case x if currentOperator\
    \ == \"-\" => finalResult - result\n                        case x if currentOperator\
    \ == \"*\" => finalResult * result\n                        case x if currentOperator\
    \ == \"//\" => finalResult // result\n                        case x if currentOperator\
    \ == \"**\" => finalResult ** result\n                        case _ => \n   \
    \                         throw new IllegalArgumentException(\"Invalid operator:\
    \ \" + currentOperator)\n                    }\n                }\n          \
    \  case None => \n                throw new IllegalArgumentException(\"Invalid\
    \ operator: \" + operators.head)\n        }", '        // Write your code here!',
  "        val nums = operand\n        val ops = op\n        val length = ops.size\n\
    \        val numLength = nums.size\n        if (length < 1 || numLength < 2) 0\n\
    \        else nums.sum / length ** ops(ops.size - 1)", "        val sum = 0L\n\
    \        val size = operand.size - 1\n        for (i<- 0 until size) {\n     \
    \       // for (i<- 0 until size) {\n            // for (i <- 0 until size) {\n\
    \            val currentNum = operand(i)\n            val opNum = if (op(i) ==\
    \ \"+\") {\n                val sum = currentNum + opNum\n                sum\n\
    \            } else if (op(i) == \"-\") {\n                val diff = currentNum\
    \ - opNum\n                diff\n            } else if (op(i) == \"*\") {\n  \
    \              val product = currentNum * opNum\n                product\n   \
    \         } else if (op(i) == \"//\") {\n                val quotient = currentNum\
    \ / opNum\n                quotient\n            } else if (op(i) == \"**\") {\n\
    \                val power = currentNum ** opNum\n                power\n    \
    \        }\n        }\n        return sum", "        // Calculate the result\n\
    \        var result : Long = 0\n        for( x <- operand) {\n            // Get\
    \ the operator and operand\n            var operator : String = op(0)\n      \
    \      var operand : Long = op(1)\n            \n            // Find the operator\
    \ and operand\n            if( operator == \"+\" ) {\n                result +=\
    \ x\n            }else if( operator == \"-\" ) {\n                result -= x\n\
    \            }else if( operator == \"*\" ) {\n                result *= x\n  \
    \          }else if( operator == \"/\" ) {\n                result /= x\n    \
    \        }else if( operator == \"//\" ) {\n                result // = x\n   \
    \         }else if( operator == \"**\" ) {\n                result **= x\n   \
    \         }\n        }\n\n        // Return the result\n        return result",
  "        val op = op.asInstanceOf[List[String]]\n        val operand = operand.asInstanceOf[List[Long]]\n\
    \        val result = 0.0\n        val length = op.size\n        for(i <- 0 until\
    \ length){\n            val op = op(i)\n            val operand1 = operand(i-1)\n\
    \            val operand2 = operand(i)\n            val opMap: Map[String, String]\
    \ = opMap()\n            val opName = opMap.get(op)\n            val op2Name =\
    \ opMap.get(opName)\n            val op2Name = (op2Name != opName)\n         \
    \   val op1Name = op2Name ? op2Name : opName\n            val op2Name1 = op1Name\n\
    \            val op1Name1 = op2Name1 + \"1\"\n            val op1Name2 = op2Name1\
    \ + \"2\"\n            val op2Name2 = op1Name1 + \"2\"\n            val op1Name3\
    \ = op2Name2 + \"3\"\n            val op2Name3 = op1Name2 + \"3\"\n          \
    \  val op1Name4 = op2Name3 + \"4\"\n            val op2Name4 = op1Name3 + \"4\"\
    \n            val op1Name5 = op2Name4 + \"5\"\n            val op2Name5 = op1Name4\
    \ + \"5\"\n            if(op2Name1.equals(\"+\")){\n                result +=\
    \ operand1 + operand2\n            }else if(op2Name1.equals(\"-\")){\n       \
    \         result -= operand1 - operand2\n            }else if(op2Name1.equals(\"\
    *\")){\n                result *= operand1 * operand2\n            }else if(op2Name1.equals(\"\
    //\")){\n                result /= operand1 // operand2\n            }else if(op2Name1.equals(\"\
    **\")){\n                result **= operand1 **= operand2\n            }\n   \
    \         if(op2Name2.equals(\"+\")){\n                result += operand1 + operand2\n\
    \            }else if(op2Name2.equals(\"-\")){\n                result -= operand1\
    \ - operand2\n            }else if(op2Name2.equals(\"*\")){\n                result\
    \ *= operand1 * operand2\n            }else if(op2Name2.equals(\"//\")){\n   \
    \             result /= operand1 // operand2\n            }else if(op2Name2.equals(\"\
    **\")){\n                result **= operand1 **= operand2\n            }\n   \
    \         if(op2Name3.equals(\"+\")){\n                result += operand1 + operand2\n\
    \            }else if(op2Name3.equals(\"-\")){\n                result -= operand1\
    \ - operand2\n            }else if(op2Name3.equals(\"", "        if (op.length\
    \ != operand.length - 1) {\n            throw new IllegalArgumentException(\"\
    Operator and Operand list should be of same length\")\n        }\n        val\
    \ opMap : mutable.Map[String, String] = mutable.Map[String, String]()\n      \
    \  val eval : mutable.Array[Long] = mutable.Array[Long]()\n\n        for (i <-\
    \ 0 to op.length - 1) {\n            opMap(op(i)) = op(i)\n            eval(i\
    \ + (0)) = operand(i)\n        }\n        // print opMap\n        println(opMap)\n\
    \        // print eval\n        println(eval)\n        var i = 0\n        for\
    \ (l <- 0 until op.length) eval(i) = eval(i + (op.length - l))\n        return\
    \ eval(eval.length - 1)", "      require(op.length == operand.size -1)\n     \
    \ var sum = 0\n      for( i <- 0 until operand.size ) {\n        val temp = operand(i)\n\
    \        val op = op(i)\n        val result = temp\n        sum match {\n    \
    \      case 0 =>\n          case 1 =>\n          case _ =>\n            sum match\
    \ {\n              case 0 =>\n              case 1 =>\n              case _ =>\n\
    \                sum match {\n                  case 0 =>\n                  case\
    \ 1 =>\n                  case _ =>\n                    sum match {\n       \
    \               case 0 =>\n                      case 1 =>\n                 \
    \     case _ =>\n                        sum match {\n                       \
    \   case 0 =>\n                          case 1 =>\n                         \
    \ case _ =>\n                            sum match {\n                       \
    \       case 0 =>\n                              case 1 =>\n                 \
    \             case _ =>\n                                sum match {\n       \
    \                           case 0 =>\n                                  case\
    \ 1 =>\n                                  case _ =>\n                        \
    \            sum match {\n                                      case 0 =>\n  \
    \                                    case 1 =>\n                             \
    \         case _ =>\n                                        sum match {\n   \
    \                                       case 0 =>\n                          \
    \                case 1 =>\n                                          case _ =>\n\
    \                                            sum match {\n                   \
    \                           case 0 =>\n                                      \
    \        case 1 =>\n                                              case _ =>\n\
    \                                                sum match {\n               \
    \                                   case 0 =>\n                              \
    \                    case 1 =>\n                                             \
    \     case _ =>\n                                                    sum match\
    \ {\n                                                      case 0 =>\n       \
    \                                               case 1 =>\n                  \
    \                                    case _ =>\n                             \
    \                           sum match {\n                                    \
    \                      case 0 =>\n                                           \
    \               case 1 =>\n                                                  \
    \        case _ =>\n                                                         \
    \   sum match {\n                                                            \
    \  case 0 =>\n                                                              case\
    \ 1 =>\n                                                              case _ =>\n\
    \                                                                sum match {\n\
    \                                                                  case 0 =>\n\
    \                                                                  case 1 =>\n\
    \                                                                  case _ =>\n\
    \                                                                    sum match\
    \ {\n                                                                      case\
    \ 0 =>\n                                                                     \
    \ case 1 =>\n                                                                \
    \      case _ =>\n                                                           \
    \             sum match {\n                                                  \
    \                        case 0 =>\n                                         \
    \                                 case 1 =>\n                                \
    \                                          case _ =>\n                       \
    \                                                     sum match {\n          \
    \                                                                    case 0 =>\n\
    \                                                                            \
    \  case 1 =>\n                                                               \
    \               case _ =>\n                                                  \
    \                              sum match {\n                                 \
    \                                                 case 0 =>\n                \
    \                                                                  case 1 =>\n\
    \                                                                            \
    \      case _ =>\n                                                           \
    \                         sum match {\n                                      \
    \                                                case 0 =>\n                 \
    \                                                                     case 1 =>\n\
    \                                                                            \
    \          case _ =>\n                                                       \
    \                                 sum match {\n                              \
    \                                                            case 0 =>\n     \
    \                                                                            \
    \         case 1 =>\n                                                        \
    \                                  case _ =>\n                               \
    \                                                             sum match {\n  \
    \                                                                            \
    \                case 0 =>\n                                                 \
    \                                             case 1 =>\n                    \
    \                                                                          case\
    \ _ =>\n                                                                     \
    \                           sum match ", "        val opList = op.toList\n   \
    \     val operandList = operand.toList\n        val operandLength = operandList.length\n\
    \        val operatorLength = opList.length\n\n        if(operatorLength == 0)\
    \ {\n            if(operandLength == 1) {\n                operandList(0)\n  \
    \          } else {\n                0\n            }\n        } else {\n    \
    \        val op1 = operandList(0)\n            val op2 = operandList(1)\n\n  \
    \          val op1Operand = opList(0)\n            val op2Operand = opList(1)\n\
    \n            if(op1 == op2) {\n                op1Operand\n            } else\
    \ if(op1Operand == \"+\") {\n                op1 + op2\n            } else if(op1Operand\
    \ == \"-\") {\n                op1 - op2\n            } else if(op1Operand ==\
    \ \"*\") {\n                op1 * op2\n            } else if(op1Operand == \"\
    /\") {\n                op1 / op2\n            } else if(op1Operand == \"**\"\
    ) {\n                Math.pow(op1, op2)\n            }\n        }", "        def\
    \ doOperation(op : String, operand : List[Long], acc : Long) : Long = {\n    \
    \        val opIndex : Int = operator.indexOf(op)\n            opIndex match {\n\
    \                case -1 => acc\n                case index => {\n           \
    \         val nums : List[Long] = operand.take(index + 1)\n                  \
    \  val result : Long = nums.foldLeft(acc)(doOperation(_, nums, acc))\n       \
    \             doOperation(op, nums, result)\n                }\n            }\n\
    \        }\n        doOperation(op.head, operand.take(operand.length - 1), operand.head)\
    \ match {\n            case -1 => operand.head\n            case nums => operand.head\
    \ + doOperation(op.tail, nums, operand.head)\n        }", "        var result\
    \ = 0L\n        op.zip(operand).foreach { case (operator, operand) =>\n      \
    \      operator match {\n                case \"+\" => result += operand\n   \
    \             case \"-\" => result -= operand\n                case \"*\" => result\
    \ *= operand\n                case \"/\" => result /= operand\n              \
    \  case \"**\" => result **= operand\n            }\n        }\n        result",
  "        val operands = operand.map(i => operand(i))\n        val operators = op.map(i\
    \ => op(i))\n        val length = op.size\n        val leftOperand = operand.drop(1)\n\
    \        val leftOperator = op.drop(1)\n        val rightOperand = operand.takeRight(1)\n\
    \        val rightOperator = op.takeRight(1)\n        val left = List(leftOperator(0),\
    \ operands(0), rightOperand(0), rightOperator(0))\n        val right = List(rightOperator(0),\
    \ operands(0), leftOperand(0), leftOperator(0))\n        val leftOperators = List(leftOperator(0),\
    \ leftOperators(1), leftOperators(2), leftOperators(3))\n        val rightOperators\
    \ = List(rightOperator(0), rightOperators(1), rightOperators(2), rightOperators(3))\n\
    \        val expressions = List(left, right)\n        val operatorLength = List(operators(0),\
    \ operators(1))\n        val length = List(length(0), length(1), length(2), length(3))\n\
    \        val leftOperands = List(leftOperand(0), leftOperand(1), leftOperand(2),\
    \ leftOperand(3)) \n        val rightOperands = List(rightOperand(0), rightOperand(1),\
    \ rightOperand(2), rightOperand(3)) \n        val expressionLength = List(expressions(0),\
    \ expressions(1))\n        val leftOperandLength = List(leftOperands(0), leftOperands(1))\n\
    \        val rightOperandLength = List(rightOperands(0), rightOperands(1))\n \
    \       val operandLength = List(operands(0), operands(1))\n        val expression\
    \ = List(expressions(0), expressions(1))\n        val expressionLength = List(expressionLength(0),\
    \ expressionLength(1)) \n        val operator = List(operators(0), operators(1))\n\
    \        val operand = List(operands(0), operands(1))\n        val operatorLength\
    \ = List(operatorLength(0), operatorLength(1)) \n        val leftOperand = List(leftOperands(0),\
    \ leftOperands(1))\n        val rightOperand = List(rightOperands(0), rightOperands(1))\n\
    \        val operandLength = List(operandLength(0), operandLength(1)) \n     \
    \   val result = expression(0) + expression(1) * operator - operand(0)\n     \
    \   result ", "        var result = 0\n        val operators = List(\"+\", \"\
    -\", \"*\", \"/\", \"//\", \"**\")\n        for (i <- 0 until operand.size) {\n\
    \            val temp = operand(i)\n            if (operators.contains(op(i)))\
    \ {\n                result += (temp * operators.indexOf(op(i)))\n           \
    \ } else if (op(i) == \">\") {\n                result += (temp > 0)\n       \
    \     } else if (op(i) == \"<\") {\n                result += (temp < 0)\n   \
    \         } else if (op(i) == \"=\") {\n                result = temp\n      \
    \      }\n        }\n        result", "        if(op.size == 0) throw new Exception(\"\
    invalid operator\")\n        val opArray = op.map(op => op.split(\"\")).toArray\n\
    \        if(opArray.size < 2) throw new Exception(\"invalid operator\")\n    \
    \    val operandArray = operand.toArray\n        if(operandArray.size < 2) throw\
    \ new Exception(\"invalid operator\")\n        val operators = opArray.dropRight(1)\n\
    \        val operatorArray = operators.map(op => op.split(\"\")).toArray\n   \
    \     if(operatorArray.size < 2) throw new Exception(\"invalid operator\")\n \
    \       val operand = operandArray\n        val result = 0\n        for(operator\
    \ <- operatorArray) {\n            if(operator == \"+\") result += operand(0)\n\
    \            else if(operator == \"*\") result *= operand(0)\n            else\
    \ if(operator == \"-\") result -= operand(0)\n            else if(operator ==\
    \ \"/\") result /= operand(0)\n            else if(operator == \"**\") result\
    \ **= operand(0)\n            else if(operator == \"^\") result **= operand(0)\n\
    \            else throw new Exception(\"invalid operator\")\n        }\n     \
    \   return result", "        // write your code here\n        val operator = op.dropRight(1)\n\
    \        val operand = operand.tail\n        val operands = operand :: operand.tail\n\
    \        val op = operator.head\n        val opVal = operand.head\n        val\
    \ opCount = operator.size + 1\n        val opCount = operands.size + 1\n     \
    \   val res = opCount match {\n            case 0 => opVal\n            case 1\
    \ => operands.last\n            case _ => {\n                val opVal1 = operands.last\n\
    \                val opVal2 = operands.dropRight(1)\n                val opCount\
    \ = opCount + 2\n                val opCount2 = opCount + 1\n                val\
    \ res1 = if (opCount > 1) {\n                    opVal1 op opVal2\n          \
    \      } else if (opCount > 0 && opCount < 4) {\n                    opVal1 op\
    \ opVal2\n                } else {\n                    opVal1 op opVal2\n   \
    \             }\n                val res2 = if (opCount > 2) {\n             \
    \       opVal1 op opVal2\n                } else {\n                    opVal1\
    \ op opVal2\n                }\n                val res3 = if (opCount > 3) {\n\
    \                    opVal1 op opVal2\n                } else {\n            \
    \        opVal1 op opVal2\n                }\n                val res4 = if (opCount\
    \ > 4) {\n                    opVal1 op opVal2\n                } else {\n   \
    \                 opVal1 op opVal2\n                }\n                val res5\
    \ = if (opCount > 5) {\n                    opVal1 op opVal2\n               \
    \ } else {\n                    opVal1 op opVal2\n                }\n        \
    \        val res6 = if (opCount > 6) {\n                    opVal1 op opVal2\n\
    \                } else {\n                    opVal1 op opVal2\n            \
    \    }\n                val res7 = if (opCount > 7) {\n                    opVal1\
    \ op opVal2\n                } else {\n                    opVal1 op opVal2\n\
    \                }\n                val res8 = if (opCount > 8) {\n          \
    \          opVal1 op opVal2\n                } else {\n                    opVal1\
    \ op opVal2\n                }\n                val res9 = if (opCount > 9) {\n\
    \                    opVal1 op opVal2\n                } else {\n            \
    \        opVal1 op opVal2\n                }\n                val res10 = if (opCount\
    \ > 10) {\n                    opVal1 op opVal2\n                } else {\n  \
    \                  opVal1 op opVal2\n                }\n                val res11\
    \ = if (opCount > 11) {\n                    opVal1 op opVal2\n              \
    \  } else {\n                    opVal1 op opVal2\n                }\n       \
    \         val res12 = ", "        val len = op.length\n        assert(len > 1\
    \ && len <= operand.length - 1)\n        val operator = op match {\n         \
    \   case x::xs => x\n            case _ => throw new IllegalArgumentException(\"\
    Operator list must have at least one operator\")\n        }\n        val operands\
    \ = operand.toList\n        val operandsLen = operands.length\n        assert(operandsLen\
    \ >= 2)\n        val operand_left = operands(0)\n        val operand_right = operands(1)\n\
    \        val operators = op match {\n            case x::xs => xs\n          \
    \  case _ => throw new IllegalArgumentException(\"Operator list must have at least\
    \ one operator\")\n        }\n        assert(operators.size >= 2)\n        val\
    \ op1 = operators(0)\n        val op2 = operators(1)\n        var eval = 0L\n\
    \        eval match {\n            case 0 => eval = operand_left + op1 * operand_right\n\
    \            case 1 => eval = operand_left * op1 + operand_right\n           \
    \ case 2 => eval = operand_left * op2 * operand_right\n            case _ => throw\
    \ new IllegalArgumentException(\"The length of operator list and operand list\
    \ must be same\")\n        }\n        return eval", "        val operator = op.head\n\
    \        val operand1 = operand.head\n        val operand2 = operand.tail.head\n\
    \        val op1 = operator.charAt(0)\n        val op2 = operator.charAt(1)\n\
    \        if (operand1 == 0) {\n            if (op1 == '+') {\n               \
    \ operand1 + operand2\n            } else if (op1 == '*') {\n                operand1\
    \ * operand2\n            } else if (op1 == '-') {\n                operand1 -\
    \ operand2\n            }\n        } else if (operand1 == 1) {\n            if\
    \ (op1 == '+') {\n                operand1 + operand2\n            } else if (op1\
    \ == '*') {\n                operand1 * operand2\n            } else if (op1 ==\
    \ '-') {\n                operand1 - operand2\n            } else if (op1 == '/')\
    \ {\n                operand1 div operand2\n            } else if (op1 == '%')\
    \ {\n                operand1 mod operand2\n            }\n        } else if (operand1\
    \ == 2) {\n            if (op1 == '+') {\n                operand1 + operand2\n\
    \            } else if (op1 == '*') {\n                operand1 * operand2\n \
    \           } else if (op1 == '-') {\n                operand1 - operand2\n  \
    \          } else if (op1 == '/') {\n                operand1 div operand2\n \
    \           } else if (op1 == '%') {\n                operand1 mod operand2\n\
    \            } else if (op1 == '^') {\n                operand1 ^ operand2\n \
    \           }\n        } else if (operand1 == 3) {\n            if (op1 == '+')\
    \ {\n                operand1 + operand2\n            } else if (op1 == '*') {\n\
    \                operand1 * operand2\n            } else if (op1 == '-') {\n \
    \               operand1 - operand2\n            } else if (op1 == '/') {\n  \
    \              operand1 div operand2\n            } else if (op1 == '%') {\n \
    \               operand1 mod operand2\n            } else if (op1 == '^') {\n\
    \                operand1 ^ operand2\n            } else if (op1 == '~') {\n \
    \               operand1 xor operand2\n            }\n        } else if (operand1\
    \ == 4) {\n            if (op1 == '+') {\n                operand1 + operand2\n\
    \            } else if (op1 == '*') {\n                operand1 * operand2\n \
    \           } else if (op1 == '-') {\n                operand1 - operand2\n  \
    \          } else if (op1 == '/') {\n                operand1 div operand2\n \
    \           } else if (op1 == '%') {\n                operand1 mod operand2\n\
    \            } else if (op1 == '^') {\n                operand1 ^ operand2\n \
    \           } else if (op1 == '~') {\n                operand1 xor operand2\n\
    \            } else if (op1 == '|') {\n                operand1 xor operand2\n\
    \            }\n        } else if (operand1 == 5) {\n            if (op1 == '+')\
    \ {\n                operand1 + operand2\n            } else if (op1 == '*') {\n\
    \                operand1 * operand2\n            } else if (op1 == '-') {\n \
    \               operand", "        val operator = op.map( x => x.toUpperCase()\
    \ )\n        val operands = operand.map( x => x.toLong )\n\n        if(operator.size\
    \ != operands.size)\n            throw new ArithmeticException(\"The length of\
    \ operator list is not equal to the length of operand list.\");\n\n        val\
    \ result = operands.reduce((x, y) => x match {\n            case _ if operator.length\
    \ == 1 => x\n            case _ if operator.length == 2 => x + y\n           \
    \ case _ => throw new ArithmeticException(\"The length of operator list is not\
    \ equal to 2.\");\n        })\n\n        // Evaluate the expression by calling\
    \ the evaluator function with operand and operator\n        def evaluate(x: Long,\
    \ operator: String, y: Long): Long = {\n            val operand = operands(y)\n\
    \            val operator = operators(operator)\n            operands.map(x =>\
    \ x match {\n                case 0 => 0\n                case _ => x + operator\
    \ match {\n                    case \"+\" => evaluate(x, operator, y)\n      \
    \              case \"-\" => evaluate(x, operator, -y)\n                    case\
    \ \"*\" => evaluate(x, operator, y * x)\n                    case \"//\" => evaluate(x,\
    \ operator, y // x)\n                    case \"**\" => evaluate(x, operator,\
    \ y ** x)\n                }\n            })\n        }\n\n        evaluate(result,\
    \ operator(0), operand(0))", "        val op = operand.map(_ => op(1))\n     \
    \   op", "        val op = operator\n        val operand = operand\n        val\
    \ operandLength = operand.size\n        val opLength = op.size\n\n        if(operandLength\
    \ < opLength){\n            throw new ArithmeticException(\"Operand list has less\
    \ than operator list elements\")\n        }\n\n        if(opLength == 0){\n  \
    \          throw new ArithmeticException(\"Operator list is empty\")\n       \
    \ }\n\n        val finalResult = operand(0)\n\n        for(i <- 1 until operandLength){\n\
    \            if(op(i) == '+'){\n                finalResult += operand(i)\n  \
    \          }\n            if(op(i) == '-'){\n                finalResult -= operand(i)\n\
    \            }\n            if(op(i) == '*'){\n                finalResult *=\
    \ operand(i)\n            }\n            if(op(i) == '//'){\n                finalResult\
    \ /= operand(i)\n            }\n            if(op(i) == '**'){\n             \
    \   finalResult **= operand(i)\n            }\n        }\n        return finalResult",
  "        if(op.length !=operand.length -1) {\n            println(\"Error wrong\
    \ input!\")\n            exit\n        }\n        var result : Long = 0\n    \
    \    for(i<-0 until operand.length-1) {\n            result = result + operand(i)\
    \ * op(operand.length - 1 - i)\n        }\n        result", "        val newOperator\
    \ = op.filterNot(c => c != \"-\");\n        var newOperand = operand.filterNot(c\
    \ => c<=0)\n        val operator = Array[String](newOperator.head,newOperator.tail);\n\
    \        val operand = Array[Long](newOperand.head,newOperand.tail);\n       \
    \ var result = operand(0)\n        val length = operator.length\n        var i\
    \ = 1\n        while (i <= operand(length)) {\n            result = result + operator(0)\
    \ * operand(i)\n            i = i + 1\n        }\n        result", "        //\
    \ TODO: Write your code here\n        val operator = op.reverse\n        var result\
    \ : Long = 0\n        \n        var operand : List[Long] = operand.sortBy(x =>\
    \ x)\n        operand = operand.map(x => x - 1)\n        var operand1 : List[Long]\
    \ = operand.sortBy(x => x)\n        \n        for (l1 <- operand1; l2 <- operand)\
    \ {\n            val op = operator(l1) match {\n                case \"+\" =>\
    \ result += l1\n                case \"-\" => result -= l1\n                case\
    \ \"*\" => result *= l1\n                case \"/\" => result /= l1\n        \
    \        case \"//\" => result //= l1\n                case \"**\" => result **=\
    \ l1\n                case _ => 0\n            }\n        }\n        return result",
  "        val operator = op.zipWithIndex.filter(_._2 != 0) // Filter out zero index\
    \ elements\n        val operand1 = operand.zipWithIndex.filter(_._2 != 0) // Filter\
    \ out zero index elements\n        val operand2 = operand1.zipWithIndex.filter(_._2\
    \ != 0) // Filter out zero index elements\n        operand2.map(x => {\n     \
    \       val op1 = operator(x._1)\n            val op2 = operator(x._2)\n     \
    \       op1.reduce(op2)\n        })", "        // TODO: Complete this\n      \
    \  ", "        // Write your code here.\n        val l2 = operand - 1\n      \
    \  val op1 = op.take(1).foreach(x => println(x))\n        val op2 = op.drop(l2).map(x\
    \ => println(x))\n        val op3 = op.take(l2).map(x => println(x))\n       \
    \ println(op1)\n        println(op2)\n        println(op3)\n        val result\
    \ = 0\n        for(i <- op1 until op2.length) {\n            result += operand(i)\
    \ * operand(l2)\n        }\n        println(result)", "        val stack = new\
    \ mutable.Stack[Long]()\n        val stack2 = new mutable.Stack[Long]()\n    \
    \    val result = new mutable.ListBuffer[Long]()\n        val stack3 = new mutable.Stack[Long]()\n\
    \        val opLength = len(op)\n        val operandLength = len(operand)\n  \
    \      for (i <- 0 until operandLength) {\n            val num1 = operand(i)\n\
    \            val num2 = stack2.last\n            val op1 = stack2.last\n     \
    \       val op2 = op(0)\n            if (num1 != 0) {\n                stack.push(num1)\n\
    \            } else {\n                stack.push(num2)\n            }\n     \
    \       val op1Int = op1.toInt\n            if (opLength > 1) {\n            \
    \    val num3 = stack2.last\n                val num4 = stack2.last\n        \
    \        val op3 = stack2.last\n                val op4 = stack2.last\n      \
    \          val num5 = stack2.last\n                val num6 = stack2.last\n  \
    \              val op5 = stack2.last\n                val num7 = stack2.last\n\
    \                val op6 = stack2.last\n                val num8 = stack2.last\n\
    \                val op7 = stack2.last\n                if (num3 != 0) {\n   \
    \                 stack2.push(num3)\n                } else {\n              \
    \      stack2.push(num4)\n                }\n                val num91 = stack2.last\n\
    \                val num10 = stack2.last\n                val num11 = stack2.last\n\
    \                val num12 = -stack2.last\n                val op9 = stack2.last\n\
    \                val num13 = stack2.last\n                val op10 = stack2.last\n\
    \                if (num5 != 0) {\n                    stack2.push(num5)\n   \
    \             } else {\n                    stack2.push(num6)\n              \
    \  }\n                val num14 = stack2.last\n                val num15 = stack2.last\n\
    \                val op11 = stack2.last\n                val op12 = stack2.last\n\
    \                val num16 = stack2.last\n                val op13 = stack2.last\n\
    \                if (num7 != 0) {\n                    stack2.push(num7)\n   \
    \             } else {\n                    stack2.push(num8)\n              \
    \  }\n                val num17 = stack2.last\n                val op14 = stack2.last\n\
    \                val num18 = stack2.last\n                val num19 = stack2.last\n\
    \                val num20 = stack2.last\n                val num21 = stack2.last\n\
    \                val op15 = stack2.last\n                val num22 = stack2.last\n\
    \                val op16 = stack2.last\n                if (num91 != 0) {\n \
    \                   stack2.push(num91)\n                } else {\n           \
    \         ", "        val map = new mutable.LinkedHashMap[String, Long]()\n  \
    \      var exp = 0\n        map.put(\"+\", 0)\n        map.put(\"-\", 0)\n   \
    \     map.put(\"*\", 0)\n        map.put(\"/\", 0)\n        map.put(\"//\", 0)\n\
    \        map.put(\"**\", 0)\n        for (i <- 0 until operand.length) {\n   \
    \         exp += operand(i) * op(i+1) - 1\n            map.put(op(i), exp)\n \
    \       }\n        exp", "        // Your code goes here\n        val operator\
    \ = mutable.ArrayBuffer(op(0), op(1), op(2));\n        val operand2 = mutable.ArrayBuffer(operand(0),\
    \ operand(1), operand(2));\n\n        var sum = 0;\n        for(i <- 0 until operand.size\
    \ by 2){\n            sum = 0\n            for(op <- operator){\n            \
    \    sum += operand(i) * operand2(i)\n            }\n        }\n        sum",
  "        if (operand.length < (op.length-1)) {\n            return null\n      \
    \  }\n        var acc = 0\n        var i = 0\n        for (x <- operand) {\n \
    \           acc += x\n            i = i + 1\n        }\n        var op = op(i-1)\n\
    \        var j = i\n        while(i < operand.length) {\n            var op =\
    \ op\n            acc = acc*operand(j) + doAlgebra(op,operand.dropRight(j))\n\
    \            i = i + 1\n            j = j - 1\n        }\n        acc", "    \
    \    val operator = op.map{\n            str => str.charAt(0)\n        }\n   \
    \     val operands = operand.map{\n            num => math.abs(num)\n        }\n\
    \        var ret = 0\n        val len = operands.length\n        for (i<- 0 until\
    \ len){\n            val temp = 0\n            for(j <- 0 until len){\n      \
    \          if(i != j){\n                    temp += operator(operands(j)) * (operands(i)\
    \ - operands(j))\n                }\n            }\n            ret = ret + temp\n\
    \        }\n        return ret", "        val newList = operand.map(x => if(op.contains(\"\
    **\")) Math.pow(operand, x)  else x )\n        val result = newList.foldLeft(0L)((acc,\
    \ x) => acc + x)\n        result", "        var leftOperand = 0\n        var rightOperand\
    \ = 0\n        var currentOp = 0\n        val result = 0\n        for (a <- 0\
    \ until operand.length) {\n            if (a > operand.length - 1) {\n       \
    \         currentOp = 0\n                leftOperand = operand(a - 1)\n      \
    \          rightOperand = operand(a + 1)\n            }\n            else {\n\
    \                currentOp = operand(a)\n            }\n            result +=\
    \ operList[currentOp](leftOperand, rightOperand)\n            currentOp = currentOp\
    \ - 1\n        }\n        result", "        val list1 = op.zip(operand).map{case\
    \ (opp, op) =>\n            val op = opp._1\n            val op = opp._2\n   \
    \         val op = opp._2\n            val operand = opp._2\n            val opp\
    \ = opp._1\n        }\n        var opp = \"\"\n        var op = 0\n        var\
    \ operand = 0\n        var newOperand = 0\n        var oppNewOp = \"\"\n     \
    \   var opNewOp = 0\n        var newList = 0\n        var op1 = \"\"\n       \
    \ var op2 = 0\n        var newList1 = \"\"\n        var operand1 = \"\"\n    \
    \    var operand2 = 0\n        var newList2 = \"\"\n        var newList1 = 0\n\
    \        var newList2 = 0\n        var list1i = 0\n        var list2i = 0\n  \
    \      var newList1i = 0\n        var newList2i = 0\n        var list1j = 0\n\
    \        var list2j = 0\n        var newList1j = 0\n        var newList2j = 0\n\
    \        var newList1j = 0\n        var newList2j = 0\n        var list1k = 0\n\
    \        var list2k = 0\n        for(i<-list1.length){\n            list1i = list1.apply(i)\n\
    \            list2i = list2.apply(i)\n            list1j = list1.apply(i+1)\n\
    \            list2j = list2.apply(i+1)\n            list1k = list1.apply(i+2)\n\
    \            list2k = list2.apply(i+2)\n            if(list1i == list2i){\n  \
    \              oppNewOp = list1j\n                opNewOp = list2j\n         \
    \   }\n            else if(list1j == list2j){\n                oppNewOp = list1k\n\
    \                opNewOp = list2k\n            }\n            else if(list1i ==\
    \ list2j){\n                oppNewOp = list1j\n                opNewOp = list2k\n\
    \            }\n            else if(list1j == list2k){\n                oppNewOp\
    \ = list1i\n                opNewOp = list2j\n            }\n            else\
    \ if(list1i == list2k){\n                oppNewOp = list1i\n                opNewOp\
    \ = list2i\n            }\n            else if(list1j == list2i){\n          \
    \      oppNewOp = list1j\n                opNewOp = list2j\n            }\n  \
    \          else if(list1k == list2j){\n                oppNewOp = list1k\n   \
    \             opNewOp = list2k\n            }\n            else if(list1k == list2k){\n\
    \                opp", "        val opArray = op.asInstanceOf[Array[String]]\n\
    \        val operandArray = operand.asInstanceOf[Array[Long]]\n        var sum\
    \ = 0\n        var mul = 1\n        for(i <- 0 until operandArray.length) {\n\
    \            sum ++= opArray(opArray.length-i-1) * operandArray(i)\n         \
    \   mul *= operandArray(i)\n        }\n        mul * sum", "        // Write your\
    \ code here\n        var result = 0.0\n        for( i <- 0 until operand.size)\n\
    \        result += (operand(i) match {\n            case 1 => 1\n            case\
    \ x if x > 0 => operator(op(i))(operand(i))\n            case x if x < 0 => -x\
    \ * (-1 * operator(op(i))(operand(i))\n            case _ => operator(op(i))(operand(i))\n\
    \        })\n        result", "        if(op.length != operand.length){\n    \
    \        throw new IllegalArgumentException(\"Operator list and operand list must\
    \ have same length\")\n        }\n        val opList = op.asInstanceOf[List[String]]\n\
    \        val operandList = operand.asInstanceOf[List[Long]]\n        val stack\
    \ = mutable.Stack[Any]()\n        val result = operandList.head\n        val operand\
    \ = operandList.tail\n        for( i <- 0 until operand.length){\n           \
    \ stack.push(operand(i))\n        }\n        for( i <- 1 until operand.length){\n\
    \            while(stack.nonEmpty){\n                val elm = stack.pop()\n \
    \               val op = opList(i)\n                val operand1 = stack.pop()\n\
    \                val operand2 = stack.pop()\n                if( op == \"*\" ){\n\
    \                    result *= operand1\n                    stack.push(result)\n\
    \                }else if( op == \"+\" ){\n                    result += operand1\n\
    \                    stack.push(result)\n                }else if( op == \"-\"\
    \ ){\n                    result -= operand1\n                    stack.push(result)\n\
    \                }else if( op == \"/\" ){\n                    result /= operand1\n\
    \                    stack.push(result)\n                }else if( op == \"//\"\
    \ ){\n                    result %= operand1\n                    stack.push(result)\n\
    \                }else if( op == \"**\" ){\n                    result %= operand1\n\
    \                    stack.push(result)\n                }\n            }\n  \
    \      }\n        result", "        val a = operand.tail\n        val b = operand.init\n\
    \        val operators = op.tail\n        val operands = op.init\n        val\
    \ length = operators.length\n        val res = 0.\n        \n        for(i <-\
    \ 0 until length){\n            val op = operators(i)\n            val operand1\
    \ = operands(i)\n            val operand2 = operands(i+1)\n            val result\
    \ = operand1 op operand2\n            \n            res = res + result\n     \
    \   }\n        res", "        // Initialization\n        val operandMap = mutable.Map[String,\
    \ Long]()\n        operand.toList.reverse.zipWithIndex.foreach { case (operand,\
    \ i) =>\n            if (operandMap.contains(op(i))) {\n                val oldValue\
    \ = operandMap(op(i))\n                val newValue = oldValue + operand\n   \
    \             operandMap(op(i)) = newValue\n            } else {\n           \
    \     val newValue = operand\n                operandMap(op(i)) = newValue\n \
    \           }\n        }\n        \n        val result = 0\n        \n       \
    \ op.zipWithIndex.foreach { case (opr, i) => {\n            val operand = operandMap(opr(i))\n\
    \            val operator = opr(i)\n            if (operator == \"+\") {\n   \
    \             result += operand\n            }\n            if (operator == \"\
    -\") {\n                result -= operand\n            }\n            if (operator\
    \ == \"*\") {\n                result *= operand\n            }\n            if\
    \ (operator == \"/\") {\n                result /= operand\n            }\n  \
    \          if (operator == \"//\") {\n                result %= operand\n    \
    \        }\n            if (operator == \"**\") {\n                result **=\
    \ operand\n            }\n        }}\n        result", "        val stack = new\
    \ mutable.Stack[Long]()\n        val expression = new mutable.Stack[Long]()\n\
    \        val operatorStack = new mutable.Stack[String]()\n        val operator\
    \ = op(0)\n        val operand1 = operand(1)\n        val operand2 = operand(2)\n\
    \        operatorStack.push(operator)\n        expression.append(operand1)\n \
    \       stack += operand1\n        expression.append(operand2)\n        stack\
    \ += operand2\n        while(!operatorStack.isEmpty && !expression.isEmpty) {\n\
    \            val operator = operatorStack.top\n            val operand = expression.pop()\n\
    \            val nextOperand = expression.pop()\n            val nextOperator\
    \ = operatorStack.pop()\n            switch(operator) {\n                case\
    \ \"+\" :\n                    stack += operand\n                    expression.append(nextOperand)\n\
    \                case \" - \" :\n                    stack -= operand\n      \
    \              expression.append(nextOperand)\n                case \" / \" :\n\
    \                    if(operand == 0)\n                        throw new ArithmeticException(\"\
    Divide by Zero Error\")\n                    val result = operand / nextOperand\n\
    \                    stack += result\n                    expression.append(nextOperand)\n\
    \                case \" ^ \" :\n                    if(operand == 0)\n      \
    \                  throw new ArithmeticException(\"Divide by Zero Error\")\n \
    \                   val result = operand ^ nextOperand\n                    stack\
    \ += result\n                    expression.append(nextOperand)\n            \
    \    case \" * \" :\n                    stack *= operand\n                  \
    \  expression.append(nextOperand)\n                case \" ** \" :\n         \
    \           if(operand == 0)\n                        throw new ArithmeticException(\"\
    Divide by Zero Error\")\n                    val result = operand ** nextOperand\n\
    \                    stack += result\n                    expression.append(nextOperand)\n\
    \            }\n            operatorStack.push(nextOperator)\n        }\n    \
    \    stack.pop()", "        val opSet = mutable.Set[String]()\n        val numSet\
    \ = mutable.Set[Long]()\n        // find all possible operations first\n     \
    \   for (x1 <- 0 until operand.size) {\n            for (x2 <- 0 until operand.size)\
    \ {\n                if (x1 < x2) {\n                    val op1 = operator(x1)\n\
    \                    val op2 = operator(x2)\n                    if (op1 <opSet.size)\
    \ {\n                        if (op2 < opSet.size) {\n                       \
    \     opSet += op2\n                            opSet += op1\n               \
    \         } else {\n                            opSet += op2\n               \
    \         }\n                    } else {\n                        opSet += op1\n\
    \                    }\n                } else {\n                    if (op2\
    \ < opSet.size) {\n                        opSet += op2\n                    }\n\
    \                }\n            }\n        }\n        // find all possible numbers\n\
    \        for (x1 <- 0 until operand.size)\n            for (x2 <- 0 until operand.size)\
    \ {\n                if (x1 < x2) {\n                    numSet += operand(x1)\
    \ *operand(x2)\n                } else {\n                    numSet += operand(x1)\n\
    \                }\n            }\n        // find all possible numbers\n    \
    \    var i = 1\n        while (i<operand.size) {\n            numSet += operand(i)\n\
    \            i += 1\n        }\n        // do calculations\n        var result\
    \ = 1\n        for (i<-0 until numSet.size) {\n            val a = numSet(i)\n\
    \            val b = opSet(i)\n            result = result * b * a\n        }\n\
    \        result", "        def doAlgebric(op: String, operand: List[Long]): Long\
    \ = {\n            val opList = op.split(\"\")\n            val operandList =\
    \ operand.split(\"\")\n            val result = new mutable.HashMap[String, Long]\n\
    \            val length = opList.length\n            for (i <- 0 until length)\
    \ {\n                val op = opList(i)\n                val operand = operandList(i)\n\
    \                result += (op -> (op == \"+\" ? (operand + operand) : op == \"\
    -\" ? (operand - operand) : op == \"*\" ? (operand * operand) : op == \"//\" ?\
    \ (operand / operand) : op == \"**\" ? (operand ** operand) : \"\"))\n       \
    \     }\n            val finalResult = result.get(\"+\")\n            return finalResult.getOrElse(\"\
    0\")\n        }\n        return doAlgebric(op(0), operand) + doAlgebric(op(1),\
    \ operand)", "        val opMap = new mutable.HashMap[String, Long]()\n      \
    \  var i = 0\n        while (i < op.length) {\n            opMap.put(op(i), operand(i))\n\
    \            i += 1\n        }\n\n        var j = 0\n        while (j < operand.length\
    \ - 1) {\n            var temp = 0\n            while (j < operand.length - 1)\
    \ {\n                temp += operand(j) * opMap(op[j])\n                j += 1\n\
    \            }\n            val temp2 = temp\n            i += 1\n           \
    \ val temp3 = temp2\n            i += 1\n            val temp4 = temp3\n     \
    \       i += 1\n            val temp5 = temp4\n            i += 1\n          \
    \  val result = temp5\n            return result\n        }\n\n        return\
    \ -1", "        // Declare variables\n        var res = 0\n        var i = 0\n\
    \        var j = 0\n        var operators = List(op(0))\n        var operands\
    \ = List(operand(0))\n        // Remove the first operator and operand from the\
    \ operator and operand lists\n        operators = operators.drop(1)\n        operands\
    \ = operands.drop(1)\n        // Add the new operators and operands to the result\
    \ variable\n        val newOperators = List(op(0)) :: operators\n        val newOperands\
    \ = List(operand(0)) :: operands\n        // Add parentheses if operator is positive\n\
    \        val operatorString = newOperators.reverse.foldLeft(\"\")(_ + _)\n   \
    \     if (operatorString.toString.toInt > 0) {\n            newOperators.reverse.zip(newOperands).foreach\
    \ { \n                case (operator, operand) => res += (operator.toString +\
    \ operand.toString)\n            }\n        }\n        else {\n            newOperators.reverse.zip(newOperands).foreach\
    \ {\n                case (operator, operand) => res += (operator.toString + operand.toString\
    \ + \"(\")\n            }\n        }\n        res += newOperators.reverse.zip(newOperands).map\
    \ {\n            case (operator, operand) => \"-\" + operand.toString\n      \
    \  }.mkString\n        res += \"(\" + newOperands.reverse.mkString(\",\") + \"\
    )\"\n        res += operatorString.toString + operands.reverse.mkString\n    \
    \    eval(res) // Evaluate the expression", '        // Write your code here',
  "        // First get the list of operators from the operator string\n        //\
    \ This will be a list of \"+\"\n        // [\"+\", \"+\", \"+\"]\n        val\
    \ operator = op.map(x => x.toLowerCase)\n        // Here we use the list of operators\
    \ to map the operation to the corresponding function.\n        // This will map\
    \ the operation to the corresponding function \n        // The function can be\
    \ any function that returns the sum of the operand.\n        // The function should\
    \ have the signature: Map[String, Function1[List[Long], Long]]\n        val operation\
    \ = Map(\n            \"+\" -> (x: List[Long]) => x.sum,\n            \"-\" ->\
    \ (x: List[Long]) => x.sum,\n            \"*\" -> (x: List[Long]) => x.sum,\n\
    \            \"//\" -> (x: List[Long]) => x.sum,\n            \"**\" -> (x: List[Long])\
    \ => x.sum\n        )\n        // We now use map to apply the function to each\
    \ element in operand\n        // This will be List[Long] -> List[Long]\n     \
    \   val operandWithOperations = operand.map(operation _)\n        // Now we get\
    \ the final result\n        val result = operandWithOperations.map(operation(_))\n\
    \        // The result is sum of the elements in operand\n        // List[Long]\
    \ -> Long\n        result.sum", "        val operator = op.toList\n        val\
    \ operands = operand.toList\n        val operandLength = operands.length\n   \
    \     val operatorLength = operator.length\n        val result = operands(0)\n\
    \        for ( i <- 1 to operandLength-1) {\n            val leftOperand = operands(i-1)\n\
    \            val rightOperand = operands(i)\n            val operator1 = operator(0)\n\
    \            val operator2 = operator(i-1)\n            val operator3 = operator(operatorLength-1)\n\
    \            val result = leftOperand match {\n                case i if i < rightOperand\
    \ =>\n                    val temp = i\n                    val op1 = operator1\n\
    \                    val op2 = operator2\n                    val op3 = operator3\n\
    \                    if (op3 == \"+\") result = temp + rightOperand\n        \
    \            if (op3 == \"*\") result = temp * rightOperand\n                \
    \    if (op3 == \"-\") result = temp - rightOperand\n                    if (op3\
    \ == \"//\") result = temp div (rightOperand + 1)\n                    if (op3\
    \ == \"**\") result = temp pow (rightOperand + 1)\n                    if (op3\
    \ == \">=\") result = temp geq(rightOperand)\n                    if (op3 == \"\
    <=\") result = temp leq(rightOperand)\n                    if (op3 == \"!=\")\
    \ result = temp neq(rightOperand)\n                    if (op3 == \"==\") result\
    \ = temp eqq(rightOperand)\n                    if (op3 == \">\") result = temp\
    \ gt(rightOperand)\n                    if (op3 == \"<\") result = temp lt(rightOperand)\n\
    \                    if (op3 == \"%\") result = temp mod(rightOperand)\n     \
    \               if (op3 == \"==\") result = temp eqq(rightOperand)\n         \
    \           if (op3 == \"!=\") result = temp neq(rightOperand)\n             \
    \       if (op3 == \"<\") result = temp lt(rightOperand)\n                   \
    \ if (op3 == \"<=\") result = temp leq(rightOperand)\n                    if (op3\
    \ == \">=\") result = temp geq(rightOperand)\n                    if (op3 == \"\
    !=\") result = temp neq(rightOperand)\n                    if (op3 == \"==\")\
    \ result = temp eqq(rightOperand)\n                    if (op3 == \"<\") result\
    \ = temp lt(rightOperand)\n                    if (op3 == \"%\") result = temp\
    \ mod(rightOperand)\n                    if (op3 == \"==\") result = temp eqq(rightOperand)\n\
    \                    if (op3 == \"!=\") result = temp neq(rightOperand)\n    \
    \                if (op3 == \"==\") result = temp eqq(rightOperand)\n        \
    \            if (op3 == \"<\") result = temp lt(rightOperand)\n              \
    \      if (op3 == \"%", "        var list = new Array[String](operand.length)\n\
    \        var i = 0\n        for(i <- 0 until operand.length) {\n            list(i)\
    \ = operand(i).toString\n        }\n        val operation = op.mkString\n    \
    \    val op = list\n        val res = List(operation).reduce( (a,b) => b(a,op))\n\
    \        res", "        assert(op.nonEmpty)\n        assert(operand.nonEmpty)\n\
    \        // get the length of operator list\n        val opLength = op.length\n\
    \        // initialize result with 0\n        var result = operand(0)\n      \
    \  // find the max operator \n        val maxOperator = op.map(_.toInt).max\n\
    \        // get the first operator \n        val operator = op.map(_.toInt).min\n\
    \        // if the operator is +, then just add the operand to the result\n  \
    \      if(maxOperator == 1 ) {\n            result += operand(0)\n        } \n\
    \        // otherwise do the same logic except switch the operands and operators\n\
    \        else {\n            // get max operand \n            val maxOperand =\
    \ operand.map(_.toInt).max\n            // get the first operand \n          \
    \  val operand1 = operand(0)\n            val operand2 = operand(1)\n        \
    \    // if the operands are +, then just add the operands to the result\n    \
    \        if(maxOperand == 1 ) {\n                result += operand1\n        \
    \        result -= operand2\n            }\n            // otherwise do the same\
    \ logic except switch the operands and operators\n            else {\n       \
    \         // get max operator \n                val maxOperator = op.map(_.toInt).max\n\
    \                // if the operator is +, then just add the operand to the result\n\
    \                if(maxOperator == 1 ) {\n                    result += operand1\n\
    \                    result *= operand2\n                }\n                //\
    \ otherwise do the same logic except switch the operands and operators\n     \
    \           else {\n                    val op1 = op.map(_.toInt).min\n      \
    \              val op2 = op.map(_.toInt).max\n                    // if the operator\
    \ is +, then just add the operand to the result\n                    if(op1 ==\
    \ 1 ) {\n                        result += operand1\n                        result\
    \ /= operand2\n                    }\n                    // otherwise do the\
    \ same logic except switch the operands and operators\n                    else\
    \ {\n                        val op1 = op.map(_.toInt).min\n                 \
    \       val op2 = op.map(_.toInt).max\n                        // if the operator\
    \ is +, then just add the operand to the result\n                        if(op1\
    \ == 1 ) {\n                            result += operand1\n                 \
    \           result **= operand2\n                        }\n                 \
    \       // otherwise do the same logic except switch the operands and operators\n\
    \                        else {\n                            val op1 = op.map(_.toInt).min\n\
    \                            val op2 = op.map(_.toInt).max\n                 \
    \           // if the operator is +, then just add the operand to the result\n\
    \                            if(op1 == 1 ) {\n                               \
    \ result += operand1\n                                result <<= operand2\n  \
    \                          }\n                            // otherwise do the\
    \ same logic except switch the operands and operators\n                      \
    \      else {\n                                val op1 = op.map(_.toInt).min\n\
    \                                val op2 = op.map(_.toInt).max\n             \
    \                   // if the operator is +", "        val operators = op.toSet\n\
    \n        // Check if operators is empty \n        if (operators.isEmpty) {\n\
    \            return 0\n        }\n\n        val operator = operators.head\n\n\
    \        // Check if the length of the operator list \n        // is greater than\
    \ 1.\n        if (operators.length < 2) {\n            return 0\n        }\n\n\
    \        // Check if the length of operand list \n        // is greater than or\
    \ equal to 2.\n        if (operand.length < 2) {\n            return 0\n     \
    \   }\n\n        // Check if the operand is of non-negative integers.\n      \
    \  // operand is non-negative\n        if (operand.forall(_.isLessThan(0)) ||\
    \ operand.forall(_.isEqualTo(0)) || operand.forall(_.isGreaterThan(0))) {\n  \
    \          return 0\n        }\n\n        // Get the first element of operand\
    \ list. \n        val operand1 = operand(0)\n\n        // Get the second element\
    \ of operand list.\n        val operand2 = operand(1)\n\n        // Create the\
    \ sum variable. \n        val sum = 0\n\n        // Create a temporary list to\
    \ hold the sum of operand \n        // and operator list. \n        val temp =\
    \ new mutable.ListBuffer[Long]()\n\n        // Loop through all the elements in\
    \ the list. \n        for (i <- operand.indices.reverse) {\n            // Add\
    \ operand to sum variable. \n            sum += operand(i)\n\n            // Add\
    \ operator to temp list. \n            temp += operand(i) * operator(i)\n\n  \
    \          // Subtract the value of the first element of operator list.\n    \
    \        sum -= operator(0) * (operand(i) - 1)\n        }\n\n        // Return\
    \ the sum.\n        return sum", "        // Create a list to store the result.\n\
    \        var res = List[Long]()\n        // Check the length of operator list.\n\
    \        if(op.size() > operand.size())\n            throw new IllegalArgumentException(\"\
    Operator list is longer than operand list.\");\n        // Check the length of\
    \ operator list.\n        if(operand.size < op.size)\n            throw new IllegalArgumentException(\"\
    Operand list is shorter than operator list.\");\n        for(i <- 0 to operand.size-1){\n\
    \            // If the current operator is '+', then add the operand to result\
    \ list.\n            if(op(i) == \"+\")\n                res += operand(i)\n \
    \           // If the current operator is '-', subtract operand from result list.\n\
    \            else if(op(i) == \"-\")\n                res -= operand(i)\n    \
    \        // If the current operator is '*', multiply operand by operand by operand\
    \ by result list.\n            else if(op(i) == \"*\")\n                res(i)\
    \ *= operand(i)\n            // If the current operator is '//', divide operand\
    \ by operand by result list.\n            else if(op(i) == \"//\")\n         \
    \       res(i) /= operand(i)\n            // If the current operator is '**',\
    \ raise operand to the power of operand by result list.\n            else if(op(i)\
    \ == \"**\")\n                res(i) **= operand(i)\n            else\n      \
    \          throw new IllegalArgumentException(\"Invalid operator in operator list.\"\
    )\n        }\n        // Return the result list.\n        res(0)", "        val\
    \ expression = new StringBuilder()\n        // First we build the expression by\
    \ looping through each operator in operator list\n        for (i <- 0 until op.size)\
    \ {\n            val tempString = new StringBuilder()\n            // Then we\
    \ loop through each operand in the operand list \n            for (j <- 0 until\
    \ operand.size) {\n                // And finally we use the operator and operand\
    \ to build up the expression\n                tempString.append(op(i)).append(operand(j))\n\
    \            }\n            // And finally we append the expression to the final\
    \ expression\n            expression.append(tempString)\n        }\n        //\
    \ And finally we evaluate this expression and return the result\n        val result\
    \ = scala.math.eval(expression.toString())\n        result", "        val opList\
    \ = op.map(_.toInt)\n        val opCount = opList.size\n        val opLen = opList.size\n\
    \n        val operandList = operand.map(_.toInt)\n        val operandLen = operandList.size\n\
    \        val operandCount = operandList.size\n\n        //Validate inputs\n  \
    \      if (opCount < 1 || opCount > 3 || operandCount < 2 || operandCount > 4\
    \ || opLen != operandLen - 1) {\n            throw new IllegalArgumentException(\"\
    Invalid inputs: \" + opCount + \" \" + operandCount + \" \" + opLen + \" \" +\
    \ operandLen + \" \" + op)\n        }\n\n        //Create stack\n        val stack\
    \ = new Stack[Int]\n        val opStack = new Stack[Int]\n\n        //Iterate\
    \ through inputs and compute value\n        var result = 0\n        for (i <-\
    \ 0 until operandLen) {\n            //Process operator\n            if (opCount\
    \ == 1) {\n                //Addition\n                if (op(i) == '+') {\n \
    \                   stack.push(operand(i) + stack.last)\n                    opStack.clear()\n\
    \                }\n                //Subtraction\n                else if (op(i)\
    \ == '-') {\n                    stack.push(operand(i) - stack.last)\n       \
    \             opStack.clear()\n                }\n                //Multiplication\n\
    \                else if (op(i) == '*') {\n                    stack.push(operand(i)\
    \ * stack.last)\n                    opStack.clear()\n                }\n    \
    \            //Floor Division\n                else if (op(i) == '/') {\n    \
    \                stack.push(operand(i) / stack.last)\n                    opStack.clear()\n\
    \                }\n                //Exponentiation\n                else if\
    \ (op(i) == '**') {\n                    stack.push(operand(i) ^ stack.last)\n\
    \                    opStack.clear()\n                }\n            }\n     \
    \       else {\n                opStack.push(op(i))\n            }\n\n       \
    \     //Process operands\n            for (j <- 0 until opStack.size) {\n    \
    \            result += opList(j) * operandList(j) * stack.last\n             \
    \   stack.push(-result)\n            }\n\n            //Process operators\n  \
    \          if (opStack.isEmpty) {\n                val currentValue = stack.last\n\
    \                stack.clear()\n                opStack.clear()\n            \
    \    if (currentValue < 0) {\n                    throw new IllegalArgumentException(\"\
    Invalid inputs: \" + opCount + \" \" + operandCount + \" \" + opLen + \" \" +\
    \ operandLen + \" \" + op)\n                }\n                result = currentValue\n\
    \            }\n        }\n        stack.clear()\n        opStack.clear()\n  \
    \      result", "        // Add up all the operands, and then apply the operators\
    \ to them.\n        operand.foldLeft(0) { \n            ((sum, val) => sum + val)\
    \ \n        }", "        var finalresult : Long = 0\n        for {\n         \
    \   i <- operand.indices\n            add = operand(i).asInstanceOf[Long] + operand(i\
    \ - 1).asInstanceOf[Long]\n            subtract = operand(i).asInstanceOf[Long]\
    \ - operand(i - 1).asInstanceOf[Long]\n            multiply = operand(i).asInstanceOf[Long]\
    \ * operand(i - 1).asInstanceOf[Long]\n            divide = operand(i).asInstanceOf[Long]\
    \ % operand(i - 1).asInstanceOf[Long]\n            exponent = operand(i).asInstanceOf[Long]\
    \ ** operand(i - 1).asInstanceOf[Long]\n        } yield {\n            finalresult\
    \ = add.addOp(subtract).addOp(multiply).addOp(divide).addOp(exponent)\n      \
    \  }.foldLeft(finalresult)((a, b) => a.addOp(b))", "        require(op.length\
    \ == operand.length - 1)\n        val result = operand.foldLeft(0)(_ + _ * _)\n\
    \        require(result > 0)\n        result", "      var opList = new mutable.LinkedList[String]()\n\
    \      opList = op\n      var op2 = new mutable.LinkedList[String]()\n      op2\
    \ = op2\n      val result = 0\n      for (i<- 0 to operand.length-1){\n      \
    \  var op1 = new mutable.LinkedList[String]()\n        op1 = opList\n        var\
    \ op3 = new mutable.LinkedList[String]()\n        op3 = op2\n        var op4 =\
    \ new mutable.LinkedList[String]()\n        op4 = op3\n        for (j<- 0 to op.length-1){\n\
    \          op4 = op4\n          if (op(i) == op1(j)){\n            val j2 = j+1\n\
    \            if (op2(j2)!= 0){\n              op4(j) = op(i) + op2(j2)\n     \
    \         op3 = op3\n            }else{\n              op4(j) = op(i) + op2(j)\n\
    \            }\n            op2 = op2\n          }\n        }\n        if (op3(0)\
    \ != 0){\n          result = op(i) + op3(0) * operand(i+1)\n        }else{\n \
    \         result = op(i) + operand(i+1)\n        }\n      }\n      result", " \
    \       val result = operand.foldLeft(0L){ case (acc, val) => acc + (op(0).asInstanceOf[String]\
    \ == \"+\" ? val : -val) }\n        result / 2", '        // Your code goes here',
  "        if (op.length != operand.length + 1) {\n            throw new IllegalArgumentException(\"\
    Not enough operands and operators given\")\n        }\n        // Create new operand\
    \ list with one extra element filled with 0\n        var newOperand = mutable.ListBuffer.empty[Long]\n\
    \        newOperand.++(operand)\n        var newOperator = mutable.ListBuffer.empty[String]\n\
    \        newOperator.++(op)\n        var result = 0L\n\n        // Use for loop\
    \ to iterate over both lists at a time\n        for {\n            i <- 0 until\
    \ newOperator.size\n            op <- newOperator(i)\n            x <- newOperand(i)\n\
    \        } { // Loop body\n            switch op {\n                case \"+\"\
    \ => result += x\n                case \"-\" => result -= x\n                case\
    \ \"*\" => result *= x\n                case \"/\" => result /= x\n          \
    \      case \"**\" => result **= x\n            }\n        }\n        result",
  "        // TODO: write your code here\n        val oplist = op.asInstanceOf[List[String]]\n\
    \        val olist = operand.asInstanceOf[List[Long]]\n        var sum = 0L\n\
    \        var cnt = 0\n        oplist.foreach(x => {\n            if (x == '+')\
    \ {\n                sum += olist.apply(cnt)\n                cnt += 1\n     \
    \       } else if (x == '*') {\n                sum *= olist.apply(cnt)\n    \
    \            cnt += 1\n            } else if (x == '-') {\n                sum\
    \ -= olist.apply(cnt)\n                cnt += 1\n            } else if (x == '/')\
    \ {\n                sum /= olist.apply(cnt)\n                cnt += 1\n     \
    \       } else if (x == '//') {\n                sum // olist.apply(cnt)\n   \
    \             cnt += 1\n            } else if (x == '**') {\n                sum\
    \ **= olist.apply(cnt)\n                cnt += 1\n            }\n        })\n\
    \        sum", "        val algebr = if (operand.size == 0) 0 else operand.head\n\
    \        val ops = List(op:_*)\n\n        var i = 1\n        var j = 0\n     \
    \   var sum = 0\n        val length = operand.last\n        while ( i < length\
    \ ) {\n            val num0 = operand(i)\n            val op0 = ops(j)\n     \
    \       val num1 = operand(i + 1)\n            val op1 = ops(j + 1)\n        \
    \    if (op0 == op1) {\n                sum += num0\n                i += 2\n\
    \                j += 2\n            } else {\n                val op0 = ops(j)\n\
    \                val op1 = ops(j + 1)\n                val num0 = operand(i +\
    \ 1)\n                val num1 = operand(i)\n                if (op0 == \"+\"\
    ) {\n                    sum += num0\n                    i += 2\n           \
    \     } else if (op0 == \"-\") {\n                    sum -= num0\n          \
    \          i += 2\n                } else {\n                    val op0 = ops(j)\n\
    \                    val op1 = ops(j + 1)\n                    if (op0 == \"*\"\
    ) {\n                        sum += num0 * num1\n                        i +=\
    \ 2\n                    } else if (op0 == \"//\") {\n                       \
    \ sum += num0 / (num1 +1)\n                        i += 2\n                  \
    \  } else if (op0 == \"**\") {\n                        sum += num0 * Math.pow(num1,\
    \ 1)\n                        i += 2\n                    } else {\n         \
    \               throw new IllegalArgumentException(\"Incorrect input!\")\n   \
    \                 }\n                }\n                j += 2\n            }\n\
    \        }\n        sum * algebr", "        def doOp(op : String, operand : List[Long])\
    \ : List[Long] = {\n            if (operand.size == 0) List.empty\n          \
    \  else {\n                val opNames = op.toList\n                var accum\
    \ = operand.head\n                for (i <- 1 to operand.size) {\n           \
    \         if (opNames.contains(op)) accum = op(accum, operand(i))\n          \
    \          else accum = opNames(0)(accum, operand(i))\n                }\n   \
    \             accum\n            }\n        }\n        doOp(op.head, doOp(op.tail,\
    \ operand))", "        var result = 0L\n        val len = operand.size\n     \
    \   for(i <- 0 until len){\n            val val = operand(i)\n            val\
    \ op = op(i)\n            if (op == \"-\"){\n                result = result -\
    \ val\n            }else if(op == \"+\"){\n                result = result + val\n\
    \            }else if(op == \"*\"){\n                result = result * val\n \
    \           }else if(op == \"//\"){\n                result = result / val\n \
    \           }else if(op == \"**\"){\n                result = result ** val\n\
    \            }\n        }\n        return result", "        val numOperand = operand.size\n\
    \        val numOper = op.size\n        val operands = operand.toArray\n     \
    \   val operators = op.toArray\n        var operandNum = 0\n        val result\
    \ = mutable.ArrayBuffer.empty[Long]\n        var resultNum = 0\n        var i\
    \ = -1\n        var j = 0\n        while (i < numOperand && j < numOper) {\n \
    \           operandNum = operandNum + 1\n            i = i + 1\n            if\
    \ (operandNum > operands.size) {\n                result += new Long(0)\n    \
    \            resultNum += 1\n            }\n            else if (j == numOper)\
    \ {\n                result += operands(operandNum)\n                resultNum\
    \ += 1\n            }\n            else if (operators(i) == operators(j)) {\n\
    \                result += (operands(operandNum) * operands(operandNum))\n   \
    \             resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j + 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ + 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j - 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ - 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j + 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ + 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j - 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ - 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j)) {\n                result += (operands(operandNum) * operands(operandNum))\n\
    \                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j + 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ + 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j - 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ - 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j + 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ + 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j - 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ - 1))\n                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j)) {\n                result += (operands(operandNum) * operands(operandNum))\n\
    \                resultNum += 1\n            }\n            else if (operators(i)\
    \ == operators(j + 1)) {\n                result += (operands(operandNum) * operands(operandNum\
    \ + 1))\n", '        // Your code goes here', "        val opTable = op.zip(operand).map(t\
    \ => t._1 -> t._2)\n\n        val opList: List[Long] = List()\n        val opMap\
    \ : Map[String, List[Long]] = opTable.toMap\n\n        opList.foreach { t => \n\
    \            opMap match {\n                case Some(map) => map.put(t._1, t._2)\n\
    \                case None => opList += t._1 * t._2\n            }\n        }\n\
    \        opList.sum", "        val opList = op.filter(_ != \"-\").map(op => op(Long.box(operand.head)))\n\
    \        val opListSize = opList.length\n        val operand1 = operand.filter(_\
    \ >= 0).map(_ => Long.box(operand.head))\n        val operand2 = operand.drop(1)\n\
    \        var res = 0\n        var i = 0\n        while (i < opListSize) {\n  \
    \          val op = opList(i)\n            val operand1Size = operand1.length\n\
    \            var j = 0\n            while (j < operand1Size) {\n             \
    \   val operand1 = operand1(j)\n                val operand2Size = operand2.length\n\
    \                var k = 0\n                while (k < operand2Size) {\n     \
    \               val operand2 = operand2(k)\n                    val op = opList(i)\n\
    \                    if (op == \"-\") {\n                        res += operand1\
    \ - operand2\n                    } else if (op == \"+\") {\n                \
    \        res += operand1 + operand2\n                    } else if (op == \"*\"\
    ) {\n                        res += operand1 * operand2\n                    }\
    \ else if (op == \"//\") {\n                        res /= operand2\n        \
    \            } else {\n                        res += (operand1 * operand2).toLong\
    \ ** op\n                    }\n                    k += 1\n                }\n\
    \                j += 1\n            }\n            i += 1\n        }\n      \
    \  if (res == 0) res = Double.PositiveInfinity\n        res", "        val result\
    \ = operand.foldLeft(0) { (result, value) => value match {\n            case value\
    \ if op.length == 1 => result + op(0)(value)\n            case value if op.length\
    \ == 2 => result + op(0)(value) * op(1)(value)\n            case _ => result \n\
    \        }}\n        return result", "        val opList = op\n        val operandList\
    \ = operand\n        val numOfOperands = operandList.size -1\n        val numOfOperators\
    \ = opList.size -1\n        val operators = Array(\"\") ++ (opList map (i => i.toString\
    \ ) )\n        val operands = Array(0) ++ (operandList map ( i => i * i ))\n \
    \       val expression = ( 0 until numOfOperators ) map { i =>\n            var\
    \ opStr = \"\"\n            var operandStr = \"\"\n            var index = i\n\
    \            while (index <= numOfOperands) {\n                opStr += operators\
    \ ((index -1))\n                operandStr += operands ((index -1 ))\n       \
    \         index += 1\n            }\n            opStr\n        } mkString \"\
    (\"\n        val resultStr = expression + \" + \" + operands ((numOfOperands -\
    \ 1) )\n        println (resultStr)\n        return ( 0 until numOfOperands )\
    \ map ( i => operands ((i)) ) reduceLeft ( _ +  _ )", "        def doAlgebraUtil(op\
    \ : List[String], operand : List[Long], result : Long) : Long = {\n          \
    \  val length = operand.size\n            // TODO: error checking\n          \
    \  val index = (length.toDouble - 1.0)\n            if (index < 0) {\n       \
    \         doAlgebraUtil(op, operand.tail, result)\n            }\n           \
    \ else {\n                val lastIndex = index\n                val first = operand(lastIndex).toDouble\n\
    \                val second = operand(lastIndex - 1).toDouble\n              \
    \  val sum = first + op(0) + second + op(1).toDouble\n                doAlgebraUtil(op.tail,\
    \ operand.tail - 2, sum)\n            }\n        }\n\n        // TODO: error checking\n\
    \        val length = operand.size\n        val index = (length.toDouble - 1.0)\n\
    \        if (index < 0) {\n            doAlgebraUtil(op, operand.tail, 0)\n  \
    \      }\n        else {\n            val lastIndex = index\n            val first\
    \ = operand(lastIndex).toDouble\n            val second = operand(lastIndex -\
    \ 1).toDouble\n            val sum = first + op(0) + second + op(1).toDouble\n\
    \            doAlgebraUtil(op.tail, operand.tail - 2, sum)\n        }", "    \
    \    val opLen = op.size\n        val operandLen = operand.size\n        val operatorSet\
    \ = Set(\"*\", \"/\", \"+\", \"-\")\n        var result : Long = 0\n        var\
    \ temp = 0\n        for ( i <- 0 until operandLen ) {\n            val opIndex\
    \ = op.indexOf(\"+\")\n            if ( opIndex >= 0 ) {\n                val\
    \ opVal = operatorSet(op(i))\n                val operandVal = operand(i)\n  \
    \              if ( opIndex < operandLen - 1 ) {\n                    temp = (\
    \ opVal * operand(1 + opIndex) ) \n                    result += temp\n      \
    \          }\n                if ( opIndex == operandLen - 1 ) {\n           \
    \         if ( operatorSet(op(i)) != \"*\" ) {\n                        result\
    \ += operandVal\n                    } else {\n                        result\
    \ += operand(i) * operand(i)\n                    }\n                }\n     \
    \       } else {\n                temp = ( operatorSet(op(i))(operand(i)) )\n\
    \                result += temp\n            }\n        }\n        result", " \
    \       val ops = op.toSet\n        val opSet = op.toList\n        val operands\
    \ = operand.toSet\n        val operandSet = operand.toList\n        var eval =\
    \ 0L\n        for ( i <- 0 until operands.size ) {\n            val o = operands(i)\n\
    \            if ( operandSet.isEmpty ) {\n                eval = o\n         \
    \   } else if ( opSet.isEmpty ) {\n                eval = eval + o\n         \
    \   } else {\n                val oLeft = operandSet(0)\n                val oRight\
    \ = operandSet(1)\n                if ( ops.contains(oLeft) && ops.contains(oRight)\
    \ ) {\n                    val op = ops.find( _ == oLeft || _ == oRight ).get\n\
    \                    eval =  eval + o * ( op(eval))\n                } else if\
    \ ( ops.contains(oLeft) ) {\n                    eval =  eval + o * ( op(eval))\n\
    \                } else if ( ops.contains(oRight) ) {\n                    eval\
    \ =  op( eval) + o\n                } else if ( ops.contains(oLeft) && ops.contains(oRight)\
    \ ) {\n                    val op = ops.find( _ == oLeft || _ == oRight ).get\n\
    \                    eval =  eval + o * ( op(eval))\n                } else {\n\
    \                    eval = o\n                }\n            }\n        }\n \
    \       return eval", "        val opArray = op.filterNot(_ == '-').toArray\n\
    \        val operandArray = operand.filterNot(_ == 0).toArray\n        var sum\
    \ = 0L\n        var exp = 1L\n        var prevExp = 1L\n        val numArray =\
    \ opArray.map(x => prevExp * x).takeWhile(x => x < operandArray.length)\n    \
    \    val denomArray = opArray.takeWhile(_ < operandArray.length).map(x => prevExp\
    \ * x)\n        operandArray.zipWithIndex.foreach { case (num, index) => {\n \
    \           sum = sum + num * exp\n            exp = denomArray(index) * prevExp\n\
    \            prevExp = exp\n        }}\n        sum", "        def add(ops : List[String],\
    \ operand : List[Long]) : Long = {\n            val opArray = ops.toArray\n  \
    \          val operandArray = operand.toArray\n            var result = 0L\n \
    \           for (opIndex = opArray.size ; opIndex > 0 ; opIndex--) {\n       \
    \         val op = opArray(opIndex)\n                val operand = operandArray(opIndex\
    \ - 1)\n                val value = operand match {\n                    case\
    \ _ if op.equals(\"+\") => operand\n                    case _ if op.equals(\"\
    -\") => operand.toLong * -1\n                    case _ if op.equals(\"*\") =>\
    \ operand.toLong * operand\n                    case _ if op.equals(\"/\") =>\
    \ operand.toLong / operand\n                    case _ if op.equals(\"//\") =>\
    \ operand.toLong / (operand.toLong * operand)\n                    case _ if op.equals(\"\
    **\") => operand.toLong * operand\n                    case _ if op.equals(\"\
    %\") => operand.toLong % operand\n                    case _ => 0L\n         \
    \       }\n                result = result + value\n            }\n          \
    \  return result\n        }\n        def multiply(ops : List[String], operand\
    \ : List[Long]) : Long = {\n            val opArray = ops.toArray\n          \
    \  val operandArray = operand.toArray\n            var result = 0L\n         \
    \   for (opIndex = opArray.size ; opIndex > 0 ; opIndex--) {\n               \
    \ val op = opArray(opIndex)\n                val operand = operandArray(opIndex\
    \ - 1)\n                result = result * operand match {\n                  \
    \  case _ if op.equals(\"*\") => operand\n                    case _ if op.equals(\"\
    /\") => operand / operand\n                    case _ if op.equals(\"//\") =>\
    \ operand / (operand * operand)\n                    case _ if op.equals(\"**\"\
    ) => operand.toLong * operand\n                    case _ if op.equals(\"%\")\
    \ => operand.toLong % operand\n                    case _ => 0L\n            \
    \    }\n            }\n            return result\n        }\n        def divide(ops\
    \ : List[String], operand : List[Long]) : Long = {\n            val opArray =\
    \ ops.toArray\n            val operandArray = operand.toArray\n            var\
    \ result = 0L\n            for (opIndex = opArray.size ; opIndex > 0 ; opIndex--)\
    \ {\n                val op = opArray(opIndex)\n                val operand =\
    \ operandArray(opIndex - 1)\n                result = result * operand match {\n\
    \                    case _ if op.equals(\"/\") => operand\n                 \
    \   case _ if op.equals(\"//\") => operand / operand\n                    case\
    \ _ if op.equals(\"**\") => operand.toLong * operand\n                    case\
    \ _ if op.equals(\"%\") => operand.toLong % operand\n                    case\
    \ _ => 0L\n                }\n            }", "        var ops = op.size\n   \
    \     var operands = operand.size\n        if (operands > ops + 1) {\n       \
    \     operands = ops + 1\n        }\n        val opList = op.reverse\n       \
    \ val operandList = operand.reverse\n        val opIndex = opList.indexOf(\"*\"\
    )\n        val operandIndex = operandList.indexOf(0)\n        val opLeft = opIndex\
    \ - operandIndex\n        val operandRight = operandIndex + 1\n        val opRight\
    \ = opIndex + 1\n        val res = opList(0)\n        val result = 0\n       \
    \ while (operandIndex < operandList.length - 1) {\n            res = res + opList(0)\
    \ * operandList(operandIndex + 1)\n            operandIndex += 1\n        }\n\
    \        while (operandIndex < operandList.length - 1) {\n            result =\
    \ result + res\n            res = opList(opLeft) * operandList(operandIndex +\
    \ 1)\n            operandIndex += 1\n        }\n        result = result + res\n\
    \        return result", "        val opMap = scala.collection.mutable.Map[String,\
    \ Long]()\n        var result = 0L\n        operand foreach { operand =>\n   \
    \         opMap(op(0)) match {\n                case None => {\n             \
    \       val currentOperand = operand\n                    val currentOp = op(0)\n\
    \                    opMap += ((currentOp, currentOperand))\n                \
    \    result += currentOperand\n                }\n                case Some(value)\
    \ => result += value\n            }\n        }\n        result", '        // Write
    your code here.', "        val n = new mutable.HashMap[String, Long]\n       \
    \ val e = new mutable.HashMap[String, Long]\n        val eop = new mutable.HashMap[String,\
    \ Long]\n        val eop2 = new mutable.HashMap[String, Long]\n        val temp\
    \ = new mutable.HashMap[String, Long]\n        var total = 0\n        val operator\
    \ = op.asInstanceOf[List[String]]\n        val operand = operand.asInstanceOf[List[Long]]\n\
    \        val length = operand.size\n        for( i <- 0 until length){\n     \
    \       total += (operand(i) match {\n                case 0 => 0\n          \
    \      case 1 => 0\n                case _ => operand(i)\n            })\n   \
    \     }\n        for( i <- 0 until length){\n            total += (operand match\
    \ {\n                case 0 => 0\n                case 1 => 0\n              \
    \  case _ => operand(i)\n            })\n        }\n        for( i <- 0 until\
    \ length){\n            total += (operand match {\n                case 0 => 0\n\
    \                case 1 => 0\n                case _ => operand(i)\n         \
    \   })\n        }\n        for( i <- 0 until length){\n            total += (operand\
    \ match {\n                case 0 => 0\n                case 1 => 0\n        \
    \        case _ => operand(i)\n            })\n        }\n        for( i <- 0\
    \ until length){\n            total += (operand match {\n                case\
    \ 0 => 0\n                case 1 => 0\n                case _ => operand(i)\n\
    \            })\n        }\n        for( i <- 0 until length){\n            total\
    \ += (operand match {\n                case 0 => 0\n                case 1 =>\
    \ 0\n                case _ => operand(i)\n            })\n        }\n       \
    \ for( i <- 0 until length){\n            total += (operand match {\n        \
    \        case 0 => 0\n                case 1 => 0\n                case _ => operand(i)\n\
    \            })\n        }\n        for( i <- 0 until length){\n            total\
    \ += (operand match {\n                case 0 => 0\n                case 1 =>\
    \ 0\n                case _ => operand(i)\n            })\n        }\n       \
    \ for( i <- 0 until length){\n            total += (operand match {\n        \
    \        case 0 => 0\n                case 1 => 0\n                case _ => operand(i)\n\
    \            })\n        }\n        for( i <- 0 until length){\n            total\
    \ += (operand match {\n                case 0 => 0\n                case 1 =>\
    \ 0\n                case _ => operand(i)\n            })\n        }\n       \
    \ for( i <- 0 until length){\n            total += (operand match {\n        \
    \        case 0 => 0\n                case 1 => 0\n                case _ => operand(i)\n\
    \            })\n        }\n        for( ", "        val list = operand ::: List(1L)\n\
    \        if (list.length <= 0) 0\n        else {\n            var sum = 0L\n \
    \           for (i <- 0 until list.length - 1) {\n                val cur = list(i)\n\
    \                val next = list(i + 1)\n                val oper = op(i)\n  \
    \              val num = (oper match {\n                    case \"+\" => next\
    \ + cur\n                    case \"-\" => next - cur\n                    case\
    \ \"*\" => next * cur\n                    case \"//\" => next / cur\n       \
    \             case \"**\" => math.pow(next, cur)\n                }) \n      \
    \          if (num <= 0) \n                    sum \n                else {\n\
    \                    sum += num\n                }\n            }\n          \
    \  return sum\n        }", "        // Write your code here\n        val list\
    \ = operand.takeWhile(_ <= 0).reverse\n        val operator = op.takeWhile(_ ==\
    \ '+' || _ == '-' || _ == '*' || _ == '/' || _ == '**').reverse\n        val newList\
    \ = list\n        for (i <- 1 to operator.length) newList = list.reduceLeft(_\
    \ + operator(i))\n        newList", "        // write your code here\n       \
    \ val opArray = op.toArray\n        val operandArray = operand.toArray\n     \
    \   val expression = opArray(0) + opArray(1) * operandArray(0) -  operandArray(1)\
    \ // + opArray(0) * operandArray(0) \n        return expression", "        val\
    \ ops = op.map { s => s.toLowerCase }\n        val nums = operand.zipWithIndex.map\
    \ { case (n, i) => i + 1 }\n        // For each operator, find the number of operands\n\
    \        var numOfOperands : List[Int] = Nil\n        for (op <- ops) {\n    \
    \        val pos = ops.indexOf(op)\n            numOfOperands = numOfOperands\
    \ :+ nums(pos)\n        }\n        var result = 0L\n        // For each operand,\
    \ compute result\n        for (i <- 0 until numOfOperands(0)) {\n            val\
    \ operand = numOfOperands(i).asInstanceOf[Int]\n            val op = ops.indexOf(\"\
    *\".toLowerCase + ops(i))\n            result += operand.toLong * (ops.indexOf(\"\
    //\".toLowerCase + ops(i)) * operand)\n        }\n        result", "        val\
    \ result = operand.foldLeft(0)((acc, x) => acc + op)\n        return result",
  "        val operator = op.map(_.toLowerCase)\n        var operatorIndex = 0\n \
    \       val operands = operand.map(x => if (x < 0) -x else x).toList\n       \
    \ // if there are operands, and there is a operator at index 0\n        if (operands.size\
    \ > 0 && !operator.isEmpty) {\n            val operIndex = operator.indexOf(\"\
    *\")\n            if (operIndex == -1) {\n                if (operator.equals(\"\
    +\") && operands.size > 0) {\n                    operands.head.toLong + operands.last\n\
    \                }\n                else if (operator.equals(\"-\") && operands.size\
    \ > 0) {\n                    operands.head.toLong - operands.last\n         \
    \       }\n                else if (operator.equals(\"/\") && operands.size >\
    \ 0) {\n                    operands.head.toLong / operands.last\n           \
    \     }\n                else if (operator.equals(\"//\") && operands.size > 0)\
    \ {\n                    operands.head.toLong \xF7 operands.last\n           \
    \     }\n                else if (operator.equals(\"**\") && operands.size > 0)\
    \ {\n                    operands.head.toLong \xD7 operands.last\n           \
    \     }\n            }\n            else\n                // if there is a operator\
    \ at index >= 1\n                if (operIndex >= 1) {\n                    val\
    \ a = operands.head.toLong\n                    val b = operands.last.toLong\n\
    \                    val tmpA = a\n                    val tmpB = b\n        \
    \            while (operatorIndex < operator.size - 1) {\n                   \
    \     val tmp = tmpA\n                        val op = operator(operatorIndex)\n\
    \                        if (op.equals(\"+\")) tmpA = tmpA + tmpB\n          \
    \              else if (op.equals(\"-\")) tmpA = tmpA - tmpB\n               \
    \         else if (op.equals(\"*\")) tmpA = tmpA * tmpB\n                    \
    \    else if (op.equals(\"/\")) tmpA = tmpA / tmpB\n                        else\
    \ if (op.equals(\"//\")) tmpA = tmpA \xF7 tmpB\n                        else if\
    \ (op.equals(\"**\")) tmpA = tmpA \xD7 tmpB\n                        operatorIndex\
    \ += 1\n                    }\n                    tmpA\n                }\n \
    \               else\n                    // if there is no operator at index\
    \ >= 1\n                    if (operands.size > 0) {\n                       \
    \ val tmpA = operands.head.toLong\n                        val tmpB = operands.last.toLong\n\
    \                        while (operatorIndex < operator.size - 1) {\n       \
    \                     val tmp = tmpA\n                            val op = operator(operatorIndex)\n\
    \                            if (op.equals(\"+\")) tmpA = tmpA + tmpB\n      \
    \                      else if (op.equals(\"-\")) tmpA = tmpA - tmpB\n       \
    \                     else if (op.equals(\"*\")) tmpA = tmpA * tmpB\n        \
    \                    else if (op.equals(\"/\")) tmpA = tmpA / tmpB\n         \
    \                   else if (op.equal", "        val operator = op.mkString(\"\
    +\")\n        val nums = operand.map(_.toInt)\n        val length = operand.length\
    \ - 1 \n        val expr = \"\"\n        \n        for(i <- 0 until length) {\n\
    \            expr += operator\n            expr += if (nums(i) > 0) \"(\" + nums(i)\
    \ + \")\" else \"\"\n        }\n\n        val exprStr = expr.substring(1,expr.length-1)\n\
    \        val eval = exprStr.split(\"\\\\W\").map(_.toLong).sum\n        eval",
  "        val operands = operand.map(_.toLong).sort\n        val op = op.filterNot(_\
    \ == \"*\")\n        val op = op.filterNot(_ == \"/\")\n        val op = op.filterNot(_\
    \ == \"**\")\n        val op2 = op.map(x => x.toChar)\n        val op3 = op.map(x\
    \ => (x - '0').toChar)\n        val op4 = op.map(x => (x - '0').toChar)\n    \
    \    val op5 = op.map(x => (x - '0').toChar)\n        if (op2 contains '+') return\
    \ operands.reduceLeft(_ + _)\n        else if (op2 contains '*') return operands.reduceLeft(_\
    \ * _)\n        else if (op2 contains '-') return operands.reduceLeft(_ - _)\n\
    \        else if (op2 contains '//') return operands.reduceLeft(_ // _)\n    \
    \    else if (op2 contains '**') return operands.reduceLeft(_ ** _)\n        if\
    \ (op3 contains '+') return operands.reduceRight(_ + _)\n        else if (op3\
    \ contains '*') return operands.reduceRight(_ * _)\n        else if (op3 contains\
    \ '-') return operands.reduceRight(_ - _)\n        else if (op3 contains '//')\
    \ return operands.reduceRight(_ // _)\n        else if (op3 contains '**') return\
    \ operands.reduceRight(_ ** _)\n        if (op4 contains '+') return operands.reduceRight(_\
    \ + _)\n        else if (op4 contains '*') return operands.reduceRight(_ * _)\n\
    \        else if (op4 contains '-') return operands.reduceRight(_ - _)\n     \
    \   else if (op4 contains '//') return operands.reduceRight(_ // _)\n        else\
    \ if (op4 contains '**') return operands.reduceRight(_ ** _)\n        if (op5\
    \ contains '+') return operands.reduceRight(_ + _)\n        else if (op5 contains\
    \ '*') return operands.reduceRight(_ * _)\n        else if (op5 contains '-')\
    \ return operands.reduceRight(_ - _)\n        else if (op5 contains '//') return\
    \ operands.reduceRight(_ // _)\n        else if (op5 contains '**') return operands.reduceRight(_\
    \ ** _)\n        else throw new Exception(\"Unknown operator\")", "        var\
    \ result = operand(0)\n        for (i <- 1 to operand.size-1) {\n            var\
    \ opName = op(i)\n            var operandNum = operand(i)\n            result\
    \ =\n                if (opName == \"+\") {\n                    result + operandNum\n\
    \                } else if (opName == \"-\") {\n                    result - operandNum\n\
    \                } else if (opName == \"*\") {\n                    result * operandNum\n\
    \                } else if (opName == \"/\") {\n                    result / operandNum\n\
    \                } else if (opName == \"**\") {\n                    result **\
    \ operandNum\n                } else { \n                    result\n        \
    \        }\n        }\n        result", "        var sum = 0\n        val op =\
    \ op.asInstanceOf[List[String]]\n        val operand = operand.asInstanceOf[List[Long]]\n\
    \        val opLen = op.length\n        val opItr = op.iterator\n        val opItr1\
    \ = opItr.next()\n        for (i <- 0 until operand.size) {\n            val operand1\
    \ = operand(i) \n            var opItr2 = opItr1.next()\n            if (opItr1.hasNext)\
    \ {\n                var opItr3 = opItr2.next()\n                while (opItr1.hasNext)\
    \ {\n                    sum = opItr3.asInstanceOf[String]() + opItr2.asInstanceOf[String]()\n\
    \                    opItr2 = opItr1.next()\n                    opItr3 = opItr2.next()\n\
    \                }\n            }\n            sum = sum + operand1\n        }\n\
    \        return sum", "        require(op.length == operand.length-1)\n      \
    \  require(op.filter(_.equals(\"+\") || _.equals(\"-\") || _.equals(\"*\")|| _.equals(\"\
    /\")|| _.equals(\"//\")|| _.equals(\"**\")).isEmpty)\n        var result = 0\n\
    \        for ((i, e) <- operand.zip(op.reverse)) {\n            result += e\n\
    \        }\n        result", "        val operator = op.sorted\n        val operand\
    \ = operand.sorted\n        val result = operand.foldLeft(operand(0)) { (acc,\
    \ item) => item match {\n            case x if x > acc => acc\n            case\
    \ x if x < acc => acc\n            case _ => acc + operator(operand.indexOf(x)\
    \ - 1).asInstanceOf[Long]\n        }}\n        \n        println(\"result: \"\
    \ + result)\n        return result", "        // Complete this function\n    \
    \    var result = operand.foldLeft((List[String](), List[Long]()))((x, v) => ((x\
    \ match {\n            case (\"\", y) => (y :: v).reverse\n            case (x,\
    \ v1) => x + v1 :: v\n        }), v.reverse))\n\n        val operator = op.foldLeft((List[String](),\
    \ List[Long]()))((x, v) => (x match {\n            case (\"\", y) => (y :: v).reverse\n\
    \            case (x, v1) => x + v1 :: v\n        }), v.reverse)\n\n        val\
    \ result = result._2.reduce((x, y) => (x.head + y.head) * x.tail)\n        val\
    \ result = result._2\n\n        val result: Long = (result._1 - operator._2.reduce((x,\
    \ y) => (x.head + y.head) * x.tail)) * (result._2 match {\n            case List(\"\
    *\") => 1\n            case List(\"/\") => 1\n            case List(\"//\") =>\
    \ 1\n            case _ => 0\n        })\n\n        return result", "        //\
    \ Write your code here\n        val firstElement = operand.head\n        val secondElement\
    \ = operand.tail.head\n        val operaElement = operand.tail.tail.head\n\n \
    \       val result = (\n            if( op.contains(\"+\")){\n               \
    \ firstElement + secondElement\n            } else if( op.contains(\"-\")){\n\
    \                firstElement - secondElement\n            } else if( op.contains(\"\
    *\")){\n                firstElement * secondElement\n            } else if( op.contains(\"\
    /\")){\n                firstElement / secondElement\n            } else if( op.contains(\"\
    //\")){\n                firstElement / secondElement\n            } else if(\
    \ op.contains(\"**\")){\n                firstElement ** secondElement\n     \
    \       } else if( op.contains(\"%\")){\n                firstElement % secondElement\n\
    \            }\n\n        )\n        result", "        val opMap : Map[String,Long]\
    \ = new HashMap[String,Long]()\n        val opMap1 = new HashMap[String,Long]()\n\
    \        val opMap2 = new HashMap[String,Long]()\n        val opMap3 = new HashMap[String,Long]()\n\
    \        val opMap4 = new HashMap[String,Long]()\n        for (i <- 0 to operand.length\
    \ - 1) {\n            opMap(op(i)) += operand(i)\n        }\n        for (i <-\
    \ 0 to operand.length - 1) {\n            opMap1(op(i)) *= operand(i)\n      \
    \  }\n        for (i <- 0 to operand.length - 1) {\n            opMap2(op(i))\
    \ -= operand(i)\n        }\n        for (i <- 0 to operand.length - 1) {\n   \
    \         opMap3(op(i)) /= operand(i)\n        }\n        for (i <- 0 to operand.length\
    \ - 1) {\n            opMap4(op(i)) //= operand(i)\n        }\n        val result\
    \ = opMap.get(op(0)) * opMap1.get(op(0)) - opMap2.get(op(0)) * opMap3.get(op(0))\
    \ * opMap4.get(op(0))\n        result", "        val operations = op.map(operation\
    \ => operation to 1)\n        val operands = operand.map(operand => operand to\
    \ 1)\n        val product = operands.foldLeft(0L)((x,y) => x * y)\n        val\
    \ pow = operands.foldLeft(1L)((x,y) => x * y)\n        val operation = operations.head\n\
    \        operands.tail.foldLeft(0L)((x,y) => operation(x) * y * pow)", "     \
    \   val operator = op.toSeq.map(_.toChar).filter(_ != '-').toList\n        if\
    \ (operator == null || operand == null || operator.size == 0) {\n            0\n\
    \        } else {\n            val operand1 = operand.filter(_.isDefined).map(_.get).toList\n\
    \            var total: Long = 0\n            val operators = List[String]()\n\
    \            while (operand1.nonEmpty) {\n                if (operators.size ==\
    \ operator.length) {\n                    val op1 = operators(0)\n           \
    \         if (op1 != '-') {\n                        total += (operand1(0) to\
    \ operand1(operand1.size - 1).toList).foldLeft(0){ case (sum, a) =>\n        \
    \                    val op2 = operators(1)\n                            if (op2\
    \ == '+') sum + a\n                            else if (op2 == '-') sum - a\n\
    \                            else if (op2 == '*') sum * a\n                  \
    \          else if (op2 == '/') sum div a\n                            else if\
    \ (op2 == '//') sum shr a\n                            else if (op2 == '**') sum\
    \ pow a\n                            else throw new IllegalArgumentException(\"\
    Invalid operation \" + op2 + \" at position \" + operand1.size.toString)\n   \
    \                     }\n                        val op2 = operators(1)\n    \
    \                    if (op2 == '+') {\n                            total += operand1.head\n\
    \                            operand1 = operand1.tail\n                      \
    \  } else if (op2 == '-') {\n                            total -= operand1.head\n\
    \                            operand1 = operand1.tail\n                      \
    \  } else if (op2 == '*') {\n                            total *= operand1.head\n\
    \                            operand1 = operand1.tail\n                      \
    \  } else if (op2 == '/') {\n                            total /= operand1.head\n\
    \                            operand1 = operand1.tail\n                      \
    \  } else if (op2 == '//') {\n                            total /= operand1.head\n\
    \                            operand1 = operand1.tail\n                      \
    \  } else if (op2 == '**') {\n                            total **= operand1.head\n\
    \                            operand1 = operand1.tail\n                      \
    \  }\n                    } else {\n                        total = operand1(0)\
    \ to operand1.head - 1.toList\n                        operand1 = operand1.tail\n\
    \                    }\n                    operators = operators.dropRight(1)\n\
    \                } else {\n                    val op1 = operators(0)\n      \
    \              if (op1 != '-') {\n                        total += (operand1(0)\
    \ to operand1.last).foldLeft(0){ case (sum, a) =>\n                          \
    \  val op2 = operators(1)\n                            if (op2 == '+') sum + a\n\
    \                            else if (op2 == '-') sum - a\n                  \
    \          else if (op2 == '*') sum * a\n                            else if (op2\
    \ == '/') sum div a\n                            else if (op2 == '//') sum shr\
    \ a\n                            else if (op2 == '**') sum ", "        val rec\
    \ = new ListBuffer[Long]\n        val mul = operand match {\n            case\
    \ head :: tail => operand.zip(tail).map { case (x, y) => x * y}.reduce(_ + _)\n\
    \            case _ => 0\n        }\n        rec += mul\n        val rec = rec.toList\n\
    \        val exp = op match {\n            case head :: tail => rec.zip(tail).map\
    \ { case (x, y) => math.pow(x, y)}.reduce(_ * _)\n            case _ => 0\n  \
    \      }\n        rec += exp\n        val rec = rec.toList\n        val div =\
    \ operand match {\n            case head :: tail => operand.zip(tail).map { case\
    \ (x, y) => x / y}.reduce(_ % _)\n            case _ => 0\n        }\n       \
    \ rec += div\n        val rec = rec.toList\n        val add = op match {\n   \
    \         case head :: tail => rec.zip(tail).map { case (x, y) => x + y}.reduce(_\
    \ + _)\n            case _ => 0\n        }\n        rec += add\n        val rec\
    \ = rec.toList\n        val neg = op match {\n            case head :: tail =>\
    \ rec.zip(tail).map { case (x, y) => -(-x + y)}.reduce(_ - _)\n            case\
    \ _ => 0\n        }\n        rec += neg\n        val rec = rec.toList\n      \
    \  val add1 = op match {\n            case head :: tail => rec.zip(tail).map {\
    \ case (x, y) => x + y}.reduce(_ + _)\n            case _ => 0\n        }\n  \
    \      rec += add1\n        val rec = rec.toList\n        val mul1 = op match\
    \ {\n            case head :: tail => rec.zip(tail).map { case (x, y) => x * y}.reduce(_\
    \ * _)\n            case _ => 0\n        }\n        rec += mul1\n        val rec\
    \ = rec.toList\n        val div1 = operand match {\n            case head :: tail\
    \ => operand.zip(tail).map { case (x, y) => x / y}.reduce(_ % _)\n           \
    \ case _ => 0\n        }\n        rec += div1\n        val rec = rec.toList\n\
    \        val mult1 = op match {\n            case head :: tail => rec.zip(tail).map\
    \ { case (x, y) => x * y}.reduce(_ * _)\n            case _ => 0\n        }\n\
    \        rec += mult1\n        val rec = rec.toList\n        val exp1 = operand\
    \ match ", "        // your code goes here\n        // use for loop to traverse\
    \ both list\n        // use if statement to compare the list\n        val listLength\
    \ : Long = operand.length\n        val operatorLength : Long = op.length\n   \
    \     for (i<- 0 to listLength - 1) {\n            for (j <- 0 to operatorLength\
    \ - 1) {\n                println(op(i) + \" * \" + operand(j))\n            }\n\
    \        }\n        // use for loop to traverse op list\n        // use if statement\
    \ to compare the list\n        // use if statement to compare the list", "   \
    \     val size = operand.size\n        val opSize = op.size\n        val operators\
    \ = (1 until opSize).map { i => op(size - i) -> i }\n        val stack = Stack.empty[Long]\n\
    \        val left = operand(size - 1)\n        val right = operand(size - 2)\n\
    \        while (stack.size() < size) {\n            val op = operators.reverse.find\
    \ { case (op,index) => op(stack.size() - index) == op(stack.size()) }\n      \
    \      op match {\n                case Some(operator) => stack += operation(left,\
    \ right, operator)\n                case None => stack += operation(right, left,\
    \ operator)\n            }\n        }\n        stack.toArray.reverse.last", " \
    \       var operandCopy = operand.clone\n        // Iterate in reverse order.\n\
    \        for(i <- operand.length to 1 by -1){\n            var product = 0L\n\
    \            // Iterate in reverse order.\n            for(j <- operand.length\
    \ to 1 by -1){\n                product += (operand(i) * operand(j))\n       \
    \     }\n            operandCopy = operandCopy.updated(i, product)\n        }\n\
    \        var finalResult = 0L\n        for(i <- operandCopy.indexWhere { case\
    \ x => operandCopy(i) != 0L} to operand.length by -1){\n            finalResult\
    \ += operandCopy(i) * op(0)\n        }\n        finalResult", "        val size\
    \ = operand.size\n        val opList = op.toList\n        val operandList = operand.map(\
    \ x => math.abs(x) )\n        val operators = opList.dropRight(1)\n        val\
    \ size = operandList.size\n        val expression = new mutable.MutableList[Long]\n\
    \        expression.append(0)\n        var current = 0\n        var power = 0\n\
    \        var lastPower = -1\n        var i = 1\n        while(i < size) {\n  \
    \          if(power==0) {\n                expression.append(operandList(i))\n\
    \                current += 1\n                i += 1\n            } else if(power<0)\
    \ {\n                expression.append(current*operandList(i))\n             \
    \   i += 1\n                current += 1\n                lastPower += 1\n   \
    \         } else {\n                expression.append(current*(operandList(i)\
    \ - lastPower*operandList(i-1)))\n                i += 1\n                current\
    \ = expression(i-1)\n                power -= 1\n            }\n        }\n  \
    \      expression.get(1)", "        def operate(operand : List[Long], operator\
    \ : List[String]) : Long = {\n            def operateRecursive(operand : List[Long],\
    \ operator : List[String], \n                                  result : Long)\
    \ : Long = {\n                if (operator.isEmpty) {\n                    return\
    \ result\n                }\n                val nextOperator = operator(0)\n\
    \                val nextOperand = operand(0)\n                val nextOperand2\
    \ = operand(1)\n                if (nextOperand.isInfinite || nextOperand.isNaN)\
    \ {\n                    if (nextOperand.isInfinite || nextOperand.isNaN) {\n\
    \                        val lastOperator = operator(operator.size - 1)\n    \
    \                    val lastOperand = operand(operand.size - 2)\n           \
    \             val lastOperand2 = operand(operand.size - 3)\n                 \
    \       if (lastOperator.isInfinite || lastOperator.isNaN || lastOperand.isInfinite\
    \ || lastOperand.isNaN || lastOperand2.isInfinite || lastOperand2.isNaN) {\n \
    \                           return 0\n                        }\n            \
    \            return operateRecursive(operand, \n                             \
    \   operator :: nextOperator :: lastOperator :: nextOperand :: lastOperand ::\
    \ nextOperand2, \n                                operateRecursive(operand, \n\
    \                                operator :: nextOperator :: lastOperator :: nextOperand\
    \ :: lastOperand :: nextOperand2, operateRecursive(operand, \n               \
    \                 operator :: nextOperator :: lastOperator :: nextOperand :: lastOperand\
    \ :: nextOperand2, operateRecursive(operand, \n                              \
    \  operator :: nextOperator :: lastOperator :: nextOperand :: lastOperand :: nextOperand2,\
    \ operateRecursive(operand, \n                                operator :: nextOperator\
    \ :: lastOperator :: nextOperand :: lastOperand :: nextOperand2, operateRecursive(operand,\
    \ \n                                operator :: nextOperator :: lastOperator ::\
    \ nextOperand :: lastOperand :: nextOperand2, operateRecursive(operand, \n   \
    \                             operator :: nextOperator :: lastOperator :: nextOperand\
    \ :: lastOperand :: nextOperand2, operateRecursive(operand, \n               \
    \                 operator :: nextOperator :: lastOperator :: nextOperand :: lastOperand\
    \ :: nextOperand2, operateRecursive(operand, \n                              \
    \  operator :: nextOperator :: lastOperator :: nextOperand :: lastOperand :: nextOperand2,\
    \ operateRecursive(operand, \n                                operator :: nextOperator\
    \ :: lastOperator :: nextOperand :: lastOperand :: nextOperand2, operateRecursive(operand,\
    \ \n                                operator :: next", "        // Your code here\n\
    \        def add(x: Long, ys: Long*): Long = {\n           val xs: Seq[Long] =\
    \ ys map x\n           xs reduce(_ + _)\n        }\n        def sub(x: Long, ys:\
    \ Long*): Long = {\n           val xs: Seq[Long] = ys map x\n           xs reduce(_\
    \ - _)\n        }\n        def mul(x: Long, ys: Long*): Long = {\n           val\
    \ xs: Seq[Long] = ys map x\n           xs reduce(_ * _)\n        }\n        def\
    \ div(x: Long, ys: Long*): Long = {\n           val xs: Seq[Long] = ys map x\n\
    \           xs reduce(_ / _)\n        }\n        def pow(x: Long, ys: Long*):\
    \ Long = {\n           val xs: Seq[Long] = ys map x\n           xs reduce(_ **\
    \ _)\n        }\n        def exp(x: Long, ys: Long*): Long = {\n           val\
    \ xs: Seq[Long] = ys map x\n           xs reduce(_ * _)\n        }\n        val\
    \ operator = op.dropRight(1)\n        val operand = operand.drop(1)\n        val\
    \ exps = operand.zip(operator).map {\n           case (x, op) => op(x.toLong,\
    \ ys)\n        }\n        val results = exps.reduce((x, y) => add(x, y))\n   \
    \     results", "        val opArr = op.map(_ => 1)\n        val opMap = (0..size)(i\
    \ => op zip opArr)(i)\n        val exps = opMap map {case(op, a) => op.hashCode\
    \ * a + operand.sum}\n        operand.foldLeft(0) {\n            case (acc, x)\
    \ => acc + exps(x)\n        }", "        val opExpr = op.length\n        val opList\
    \ = List(\"+\" -> \"add\", \"*\" -> \"mul\", \"-\" -> \"sub\", \"/\" -> \"div\"\
    , \"//\" -> \"floorDiv\", \"**\" -> \"pow\")\n        val opMap = opList.zipWithIndex.toMap\n\
    \        val operandList = operand map (_ + 1)\n        val evalExpr = operandList.zipWithIndex.foldLeft(0)\
    \ {\n            case (acc, (i, j)) => acc + (opMap.get(op(i)).getOrElse(op(i))(j)\
    \ * operand(i))\n        }\n        evalExpr", "        val opList: List[String]\
    \ = op\n        val operandList: List[Long] = operand\n        val opListLength:\
    \ Int = opList.length\n        val operandListLength: Int = operandList.length\
    \ - 1\n        var result = 0\n        var index = 0\n        while (index < operandListLength)\
    \ {\n            val op = opList(index).toLowerCase\n            val operand =\
    \ operandList(index)\n            val operandPlusOne = operand + 1\n         \
    \   val operandMinusOne = operand - 1\n            val operandMulti = operand\
    \ * operand\n            val operandDivide = operand / operand\n            val\
    \ operandExponent = operand ** operand\n            var opResult = 0\n       \
    \     switch (op) {\n                case \"plus\" => opResult = operandPlusOne\n\
    \                case \"minus\" => opResult = operandMinusOne\n              \
    \  case \"times\" => opResult = operandMulti\n                case \"floordivide\"\
    \ => opResult = operandDivide\n                case \"xto\" => opResult = operandExponent\n\
    \                case _ => opResult = 0\n            }\n            result +=\
    \ opResult\n            index += 1\n        }\n        return result", "     \
    \   val operator = List(\"+\", \"-\", \"*\", \"/\", \"//\", \"**\")\n        assert(operator.size\
    \ == operand.size - 1)\n        var i = 0\n        var result = 0L\n        while\
    \ (i < operator.size && i < operand.size) {\n            val left = operand(i)\n\
    \            val right = operand(i +1)\n            val oper = operator(i)\n \
    \           val right = operand(i +1)\n            val oper2= operator(i +2)\n\
    \            val oper3 = operator(i +3)\n            val oper4 = operator(i +4)\n\
    \            val oper5 = operator(i +5)\n            if (oper == \"+\") {\n  \
    \              result += (left + right)\n            }\n            else if (oper\
    \ == \"-\") {\n                result -= (left - right)\n            }\n     \
    \       else if (oper == \"*\") {\n                result += (left * right)\n\
    \            }\n            else if (oper == \"/\") {\n                result\
    \ += (left / right)\n            }\n            else if (oper == \"//\") {\n \
    \               result += (left // right)\n            }\n            else if\
    \ (oper == \"**\") {\n                result += (left ** right)\n            }\n\
    \            i += 6\n        }\n        return result", "        val list1 = operand.tail\
    \ // drop the last element\n        val list2 = operand.init // drop the first\
    \ element\n        val operator = op.head\n\n        // The expression has only\
    \ one variable, so return the result of evaluating the expression.\n        if\
    \ (list1.length == 1 && list2.length == 1) return list1.head * list2.head\n\n\
    \        val firstElement = list1(0)\n        val secondElement = list2(0)\n \
    \       val operatorIndex = if (operator == \"-\") -1 else 0\n        val op1\
    \ = list1.slice(0, operatorIndex).map(_.toInt)\n        val op2 = list2.slice(0,\
    \ operatorIndex).map(_.toInt)\n        val result = evalAlgebra(operator)(op1,\
    \ op2)\n        val resultString = result.toString\n        val firstElementString\
    \ = firstElement.toString\n        val secondElementString = secondElement.toString\n\
    \        val sumString = list1.length + list2.length\n        if (sumString ==\
    \ 0) resultString else resultString + \" + \" + op2 + \" \" + resultString + \"\
    \ + \" + op1 + \" = \" + resultString + \" => \" + firstElementString + \" * \"\
    \ + secondElementString + \" = \" + resultString * firstElementString", "    \
    \  var ret = 0\n      for (i <- operand.indices) {\n        for (j <- op.indices)\
    \ {\n          if (i != j) {\n            val f = j - i + 1\n            val x\
    \ = operand(i)\n            val y = op(j)\n            ret += (if (f == 0) {\n\
    \                x + y\n              } else if (f < 0) {\n                x *\
    \ y\n              } else {\n                x / y\n              })\n       \
    \   }\n        }\n      }\n      ret", "        val l1 = operand.size()\n    \
    \    val l2 = op.size()\n        if(l1 != l2){\n            throw new IllegalArgumentException(\"\
    The length of the operator and operand lists must be equal\")\n        }\n   \
    \     var sum = 0L\n        for(i <- l1 to l2){\n            sum += operand(i)\
    \ * op(l1 - 1 - i)\n        }\n        return sum", "        // Initialize result\
    \ to 0\n        var result = 0L\n        \n        // Loop to iterate over each\
    \ element of operand list using index\n        for (i <- 0 until operand.size)\
    \ {\n            // Initialize a temporary variable to hold the result of the\
    \ operation\n            var tempResult = 0L\n            \n            // Loop\
    \ to iterate over each element of operator list using index\n            for (j\
    \ <- 0 until op.size) {\n                // Use switch/case to determine the type\
    \ of operator and operand\n                \n                switch (op(j)) {\n\
    \                    // Addition operation\n                    case \"+\" =>\
    \ tempResult = tempResult + operand(i) \n                        // Break out\
    \ of inner loop\n                        break\n                    \n       \
    \             // Subtraction operation\n                    case \"-\" => tempResult\
    \ = tempResult - operand(i)\n                        // Break out of inner loop\n\
    \                        break\n                    \n                    // Multiplication\
    \ operation\n                    case \"*\" => tempResult = tempResult * operand(i)\n\
    \                        // Break out of inner loop\n                        break\n\
    \                    \n                    // Floor division operation\n     \
    \               case \"//\" => tempResult = tempResult // operand(i)\n       \
    \                 // Break out of inner loop\n                        break\n\
    \                    \n                    // Exponentiation operation\n     \
    \               case \"**\" => tempResult = tempResult ** operand(i)\n       \
    \                 // Break out of inner loop\n                        break\n\
    \                        \n                    // Error handling\n           \
    \         case _ => println(\"Invalid operator\")\n                        //\
    \ Break out of inner loop\n                        break\n                }\n\
    \            }\n            // Use mutable variable to hold the final result\n\
    \            result = result + tempResult\n        }\n        \n        // Return\
    \ final result\n        return result", "        // Write your code here\n   \
    \     var sum = 0\n        var opIndex = -1\n        for (i <- 0 to (operand.length\
    \ - 1) ) {\n            sum +=  operand(i) * Math.pow(Double.PositiveInfinity,\
    \ opIndex * 2)\n            opIndex -=  1\n        }\n        return sum", " \
    \       // For each operator, get the corresponding function in Math object\n\
    \        val operations = op.map(operation => (operation -> Math.getOperator(operation)))\n\
    \        // For each operand, get the corresponding function in Math object\n\
    \        val operands = operand.map(operand => (operand -> Math.getOperand(operand)))\n\
    \        // Build the final expression\n        (0 until operations.length).map(i\
    \ => operations(i)(operands(i)))\n            .foldLeft(0)((x, y) => x + y)",
  "        val operands = new mutable.LinkedList[Long]()\n        for (i<- 0 until\
    \ operand.length) {\n            if (operands(i) > 0 && operands(i) < operand(i))\
    \ {\n                operands(i) = operand(i)\n            } else {\n        \
    \        operands(i) = operands(i) - 1\n            }\n        }\n        val\
    \ operators = new mutable.LinkedList[String]()\n        for (i<- 0 until op.size)\
    \ {\n            operators += op(i)\n        }\n        var expression: Int =\
    \ 1\n        for (i<- 0 to operands.size - 1) {\n            expression = expression\
    \ * operands(i)\n        }\n        for (i<- 0 to operators.size - 1) {\n    \
    \        expression = eval(expression, operators(i))\n        }\n        return\
    \ expression", "        val operator = op.head\n        val operand1 = operand.head\n\
    \        val operand2 = operand.tail\n        val operator1 = List('+', '*', '/',\
    \ '//', '**').find(_ == operator)\n        val operand1 = List(0, -1, -2, 0, -2,\
    \ -1, -1, 1, -1, 1).find(_ == operand1)\n        val operand2 = List(0, -1, -2,\
    \ 0, -2, -1, -1, 1, -1, 1).find(_ == operand2)\n        val operand1 = operand.map\
    \ { i => (i.toInt * i).toLong }\n        val operand2 = operand.map { i => (i.toInt\
    \ * i).toLong }\n        var result = 0L\n        operand match {\n        case\
    \ head :: tail =>\n            result ++= operand1 match {\n            case 0\
    \ => operand2\n            case 1 => operand1 + operand2\n            case 2 =>\
    \ operand1 - operand2\n            case 3 => operand1 * operand2\n           \
    \ case 4 => operand1 <- (operand1 / operand2)\n            case 5 => operand1\
    \ <- (operand1 <- (operand1 / operand2))\n            case 6 => operand1 <- (operand1\
    \ <- (operand1 <- (operand1 / operand2)))\n            case 7 => operand1 <- (operand1\
    \ <- (operand1 <- (operand1 <- (operand1 / operand2))))\n            case 8 =>\
    \ operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1 /\
    \ operand2)))))\n            case 9 => operand1 <- (operand1 <- (operand1 <- (operand1\
    \ <- (operand1 <- (operand1 / operand2))))))\n            case 10 => operand1\
    \ <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1\
    \ / operand2)))))))\n            case 11 => operand1 <- (operand1 <- (operand1\
    \ <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1 / operand2)))))))\n\
    \            case 12 => operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1\
    \ <- (operand1 <- (operand1 <- (operand1 / operand2)))))))\n            case 13\
    \ => operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1\
    \ <- (operand1 <- (operand1 / operand2)))))))\n            case 14 => operand1\
    \ <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1 <- (operand1\
    \ <- (operand1 / operand2)))))))\n            case 15 => operand1 <- (operand1\
    \ <- (operand1 <- (", "        require(op.length == operand.length - 1)\n    \
    \    val opMap = {\n            val (key, value) = op.zip(operand.drop(1)).toMap\n\
    \            require(value >= 0)\n            key\n        }\n        val ops\
    \ = List(\"+\", \"*\", \"/\", \"//\", \"**\")\n        val numOperators = {\n\
    \            val numOperators = ops.map(o => opMap(o).length)\n            require(numOperators.sum\
    \ == ops.length, \"Not all operators have same number of operands\")\n       \
    \     numOperators\n        }\n        val opList = ops.map(o => o + \" \")\n\
    \        val operandList = operand.map(i.toString)\n        val operatorList =\
    \ numOperators.map { n => n + \" \" }\n        val numOperands = operand.length\n\
    \        val result = operandList.toList.foldLeft(0) { (result, o) =>\n      \
    \      if (opMap(o) match {\n                case \"+\" => result + operand(o)\n\
    \                case \"-\" => result - operand(o)\n                case \"*\"\
    \ => result * operand(o)\n                case \"//\" => result / operand(o)\n\
    \                case \"**\" => result ** operand(o)\n                case _ =>\
    \ throw new RuntimeException(\"Unexpected operator\")\n            }) else {\n\
    \                throw new RuntimeException(\"Unexpected operand\")\n        \
    \    }\n        }\n        val resultString = result.toString\n        val resultInt\
    \ = resultString.toInt\n        require(resultInt == result)\n        resultInt",
  "        var stack = mutable.Stack[Long]()\n        stack.push(0)\n        var i\
    \ = 0\n        while (i < operand.size - 1) {\n            val curr = stack.pop()\n\
    \            val next = operand(i + 1)\n            stack.push((op(curr, next)\
    \ * curr) + (op(curr, next) * next))\n            i += 1\n        }\n        stack.pop()",
  "        val operandList = mutable.ListBuffer[Long]()\n        val operatorList\
    \ = mutable.ListBuffer[String]()\n        for (i <- operand.indices)\n       \
    \     operandList += operand(i)\n        for (i <- op.indices) \n            operatorList\
    \ += op(i)\n\n        // check parameters\n        if (operandList.size < 1 ||\
    \ operatorList.size < 2)\n            throw new IllegalArgumentException(\"Not\
    \ enough operands or operators\")\n        val length = operatorList.size\n  \
    \      for (i <- operandList.indices)\n            if (operandList(i) < 0)\n \
    \               throw new IllegalArgumentException(\"Operands must be positive\"\
    )\n\n        // check operators\n        if (length % 2 != 0)\n            throw\
    \ new IllegalArgumentException(\"Not an algebric expression\")\n\n        // build\
    \ the operator expression \n        var exp = List[String]()\n        var temp\
    \ = 0L\n        for (i <- 0 until length / 2)\n            temp += operand(operandList.size\
    \ - 1 - i)\n        for (i = length / 2; i < (length / 2) + length) \n       \
    \     exp += operatorList(i - length)\n        exp = exp :+ operatorList(length\
    \ - 1) \n            \n        // evaluate expression\n        var res = 0L\n\
    \        val l = operandList.size\n        for (i <- 0 until l)\n            res\
    \ = res + exp(i) * temp\n            \n        return res;", "        val ops\
    \ = op.map(c => c.toLong)\n        val operands = operand.map(_.toLong)\n    \
    \    var result = 0\n        // evaluate each operand/operator\n        val opersIterator\
    \ = ops.iterator\n        val operandsIterator = operands.iterator\n        while\
    \ (opersIterator.hasNext && operandsIterator.hasNext) {\n            val op =\
    \ opersIterator.next()\n            val operand = operandsIterator.next()\n  \
    \          result += (op + operand) * operand\n        }\n        result * operands.last",
  "        // Write your code here\n        val res=operand.foldLeft(0)((a,b) => a\
    \ * b)\n        val ops = op.zip(operand).map { case (op, a) => op.asInstanceOf[String]\
    \ + \"(\" + a + \")\" }.mkString(\"+\")\n        val eval = ops.substring(0, ops.length\
    \ - 1) + \"=\" + res\n        val eval2=eval.substring(eval.lastIndexOf('=')+1)\n\
    \        eval2.toLong", "        val operandLength = operand.length\n        val\
    \ operatorLength = op.size\n        if (operandLength < operatorLength) {\n  \
    \          val operandCopy = operand.clone()\n            val operatorCopy = op.clone()\n\
    \            while (operandCopy.length < operatorLength) {\n                operatorCopy.add(\"\
    0\")\n            }\n            val ans = doAlgebra(operatorCopy, operandCopy)\n\
    \            if (operandCopy.length < operatorLength) {\n                val operandCopy\
    \ = operand.clone()\n                val operatorCopy = op.clone()\n         \
    \       while (operandCopy.length < operatorLength) {\n                    operatorCopy.remove(0)\n\
    \                }\n                operandCopy.foreach(x => ans = ans - x)\n\
    \            }\n            ans\n        } else {\n            val ans = doAlgebra(op,\
    \ operand.take(operandLength - operatorLength).map(x => operand(0) - x))\n   \
    \         ans + doAlgebra(op, operand.take(operandLength - operatorLength).reverse.map(x\
    \ => operand(operandLength - 1) - x))\n        }", "        val opArray = operator.get(op(0))\n\
    \        var result : Long = 0\n        for(i <- 1 to operand.length - 1) {\n\
    \            val firstOp = opArray(0) \n            val secondOp = opArray(1)\
    \ \n            val firstOperand = operand(i) \n            val secondOperand\
    \ = operand(i+1) \n            val firstResult = firstOp(firstOperand) \n    \
    \        val secondResult = secondOp(secondOperand)\n            result += (firstResult\
    \ + secondResult)\n        }\n        result", '        // Write your code here',
  "        val op = operand.map(_ toLong)\n        val operators = op.lastOption\n\
    \        val operator = operators.getOrElse(\"\")\n        val operands = operand.drop(1).map(_.toLong)\n\
    \        val numList = List(operands.sum, operands.lastOption)\n        val denList\
    \ = List(operands.last, operands.lastOption)\n        val op = operands.sum.toLong\n\
    \        val den = denList.sum\n        val result = op.pow(den)\n        val\
    \ num = new BigDecimal(op)\n        val den = new BigDecimal(den)\n        val\
    \ result = new BigDecimal(result)\n        num.setScale(den, BigDecimal.ROUND_HALF_UP)\n\
    \        result.setScale(den, BigDecimal.ROUND_HALF_UP)\n        result.setScale(1,\
    \ BigDecimal.ROUND_HALF_UP)\n        result * num", "        if (operand.length\
    \ <= 1) {\n            return 0\n        }\n        // add all operands\n    \
    \    var total = operand(0)\n        // loop through the operands, add each operand\n\
    \        for (i <- 1 to operand.length - 1) {\n            total = add(total,\
    \ operand(i))\n        }\n        // loop through the operators, add the result\
    \ of that\n        var op1 = 0L\n        var op2 = 0L\n        var op3 = 0L\n\
    \        var op4 = 0L\n        var op5 = 0L\n        var op6 = 0L\n        var\
    \ op7 = 0L\n        var op8 = 0L\n        var op9 = 0L\n        var op10 = 0L\n\
    \        var op11 = 0L\n        var op12 = 0L\n        var op13 = 0L\n       \
    \ var op14 = 0L\n        var op15 = 0L\n        var op16 = 0L\n        var op17\
    \ = 0L\n        var op18 = 0L\n        var op19 = 0L\n        var op20 = 0L\n\
    \        var op21 = 0L\n        var op22 = 0L\n        var op23 = 0L\n       \
    \ var op24 = 0L\n        var op25 = 0L\n        var op26 = 0L\n        var op27\
    \ = 0L\n        var op28 = 0L\n        var op29 = 0L\n        var op30 = 0L\n\
    \        var op31 = 0L\n        var op32 = 0L\n        var op33 = 0L\n       \
    \ var op34 = 0L\n        var op35 = 0L\n        var op36 = 0L\n        var op37\
    \ = 0L\n        var op38 = 0L\n        var op39 = 0L\n        var op40 = 0L\n\
    \        var op41 = 0L\n        var op42 = 0L\n        var op43 = 0L\n       \
    \ var op44 = 0L\n        var op45 = 0L\n        var op46 = 0L\n        var op47\
    \ = 0L\n        var op48 = 0L\n        var op49 = 0L\n        var op50 = 0L\n\
    \        var op51 = 0L\n        var op52 = 0L\n        var op53 = 0L\n       \
    \ var op54 = 0L\n        var op55 = 0L\n        var op56 = 0L\n        var op57\
    \ = 0L\n        var op58 = 0L\n        var op59 = 0L\n        var op60 = 0L\n\
    \        var op61 = 0L\n        var op62 = 0L\n        var op63 = 0L\n       \
    \ var op64 = 0L\n        var op65 = 0L\n        var op66 = 0L\n        var op67\
    \ = 0L\n        var op68 = 0L\n        var op69 = 0L\n        var op70 = 0L\n\
    \        var op71 = 0L\n        var op72 = 0L\n        var op73 = 0L\n       \
    \ var op74 = 0L\n        var op75 = 0L\n        var op76 = 0L", "        val sum\
    \ = 0\n        val temp1 = \"\"\n        val temp2 = \"\"\n        var i = operand.head\n\
    \        var j = operand.last\n        while (j > 0) {\n            sum = 0\n\
    \            while (i < j) {\n                sum = sum + operand(i) * op(i -\
    \ 1)\n                i += 1\n            }\n            while (i < j) {\n   \
    \             sum = sum + operand(i) * op(i - 1)\n                i += 1\n   \
    \         }\n            j = j - 1\n            temp1 = \"(\" + operand(0) + \"\
    )\"\n            temp2 = \"(\" + sum + \")\"\n            sum = temp1 + temp2\n\
    \        }\n        sum", "        val evalList = (operand ::: op(0 until operand.length)).map{x\
    \ => math.pow(Double(x), Double(operand.last))}.toList.sum\n        evalList",
  "        val operator = op.map { x => x.toLong }\n        val operand2 = operand.map\
    \ { x => x.toLong }\n        val length = operand2.size + 1\n        val opList\
    \ = new scala.collection.mutable.ArrayBuffer[String](operator.length)\n      \
    \  val opMap = new scala.collection.mutable.HashMap[String, Long]()\n        operator.zipWithIndex.foreach\
    \ { x => opList += x._1 + x._2 }\n        val opMap2 = operand2.zipWithIndex.map{\
    \ x => (x._1, x._2 + 1) }\n        opMap.putAll(opMap2)\n        val value = opList.foldLeft((0L,0L))\
    \ { \n            (acc, x) => { \n                val key = opMap.get(x)\n   \
    \             if (key != null)\n                    acc + (key * x._1) + (key\
    \ * x._2) \n                else\n                    acc + (x._1 * x._2) \n \
    \           }\n        }\n        value._1", "        val opList = op.map(_.toUpperCase()).filterNot(_.equals(\"\
    NOT\"))\n        var opItr = opList.iterator\n        var operandItr = operand.iterator\n\
    \n        while (opItr.hasNext) {\n            var opStr = opItr.next()\n    \
    \        var opVal = operandItr.next()\n\n            if (opStr == \"*\") {\n\
    \                val newVal = opVal * operandItr.next()\n                operandItr.next()\n\
    \                return newVal\n            } else if (opStr == \"/\") {\n   \
    \             val newVal = opVal / operandItr.next()\n                operandItr.next()\n\
    \                return newVal\n            } else if (opStr == \"//\") {\n  \
    \              val newVal = opVal / operandItr.next()\n                operandItr.next()\n\
    \                return newVal\n            } else if (opStr == \"**\") {\n  \
    \              val newVal = opVal ** operandItr.next()\n                operandItr.next()\n\
    \                return newVal\n            } else if (opStr == \"+\") {\n   \
    \             val newVal = opVal + operandItr.next()\n                operandItr.next()\n\
    \                return newVal\n            } else if (opStr == \"-\") {\n   \
    \             val newVal = opVal - operandItr.next()\n                operandItr.next()\n\
    \                return newVal\n            } else {\n                throw new\
    \ Exception(\"Invalid operator \" + opStr)\n            }\n        }\n       \
    \ return 0", "        var res = 0\n        val exprs = op.zip(operand)\n     \
    \   exprs.foreach(e => res = res + e._1 * e._2)\n        return res", "      \
    \  if(op.isEmpty || operand.isEmpty) {\n            println(\"Invalid input\"\
    )\n            return 0\n        }\n\n        var res = 0\n        val ops = op.toSet\n\
    \        val vals = operand.toSet\n        ops foreach (opStr => {\n         \
    \   vals foreach (v => {\n                if(opStr == \"+\" || opStr == \"-\"\
    )\n                    res += v\n                if(opStr == \"*\" || opStr ==\
    \ \"/\")\n                    res += v.toInt\n                if(opStr == \"**\"\
    )\n                    res += v.toLong\n            })\n        })\n        return\
    \ res", "        var result = 0\n        var i = 0\n        while(i < operand.size)\
    \ {\n            var operator = op(i) // The operator at position i of operand\
    \ list \n            var operand1 = operand(i) // The operand at position i of\
    \ operand list \n            var operand2 = operand(i + 1) // The operand at position\
    \ i + 1 of operand list \n            if (operator == \"+\") {\n             \
    \   result += operand1\n                i += 2\n            } else if (operator\
    \ == \"-\") {\n                result -= operand1\n                i += 2\n  \
    \          } else if (operator == \"*\") {\n                result *= operand1\n\
    \                i += 2\n            } else if (operator == \"/\") {\n       \
    \         if (operand2 == 0)\n                    throw new Exception(\"Division\
    \ by zero!\")\n                result /= operand1\n                i += 2\n  \
    \          } else if (operator == \"**\") {\n                result *= operand1\n\
    \                result *= operand2\n                result *= operand1\n    \
    \            i += 2\n            } else {\n                throw new Exception(\"\
    Invalid operator!\")\n            }\n        }\n        return result", "    \
    \    var result = 0\n        // This list will hold the expression generated by\
    \ basic algebra operation on the operand\n        var expressionList: List[String]\
    \ = Nil\n        val operator = op.head\n        // Iterate through the operand\
    \ list\n        for (i <- 1 to operand.size) {\n            val currentOperand\
    \ = operand(i-1).toLong\n            // Construct expression\n            val\
    \ expression = currentOperand match {\n                case 1 : expressionList\
    \ = List(\"1\")\n                case 0 : expressionList = List(\"2\")\n     \
    \           case 2 : expressionList = List(\"2\", \"+\", expressionList(0))\n\
    \                case 3 : expressionList = List(\"2\", \"+\", expressionList(0),\
    \ \"+\", expressionList(0))\n                case 4 : expressionList = List(\"\
    2\", \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0))\n\
    \                case 5 : expressionList = List(\"2\", \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0))\n\
    \                case 6 : expressionList = List(\"2\", \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0))\n                case 7 : expressionList = List(\"\
    2\", \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0))\n                case 8\
    \ : expressionList = List(\"2\", \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0))\n                case 9 : expressionList = List(\"\
    2\", \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0))\n                case 10 : expressionList = List(\"\
    2\", \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0))\n                case 11 : expressionList = List(\"\
    2\", \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0))\n                case 12\
    \ : expressionList = List(\"2\", \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0))\n                case 13 : expressionList = List(\"\
    2\", \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+\", expressionList(0), \"+\", expressionList(0), \"+\", expressionList(0),\
    \ \"+", "        // Your code goes here\n        val sum = 0\n        val stack\
    \ = mutable.Stack[Int]()\n        val result = operand.head \n\n        for(i\
    \ <- 0 until operand.size) {\n            val oper = op(i)\n            val num\
    \ = operand.tail(i)\n            val op = oper\n            if(oper == '+') {\n\
    \                sum += num\n            }\n            if(oper == '-') {\n  \
    \              sum -= num\n            }\n            if(oper == '*') {\n    \
    \            sum *= num\n            }\n            if(oper == '/') {\n      \
    \          sum /= num\n            }\n            if(oper == '%') {\n        \
    \        sum %= num\n            }\n            if(oper == '**') {\n         \
    \       sum **= num\n            }\n        }\n        result", "        val opArray\
    \ = op.map { elem =>\n            elem match {\n                case op1 =>\n\
    \                    val op2Index = operand .indexOf(elem) + 1\n             \
    \       if(op2Index < operand.length)\n                        operand(op2Index)\
    \ else 0\n                case op2 =>\n                    val op1Index = operand\
    \ .indexOf(elem) + 1\n                    if(op1Index < operand.length)\n    \
    \                    operand(op1Index) else 0\n            }\n        }\n    \
    \    // opArray contains [op1, op2] where op1 = opArray(0)\n        // op2 can\
    \ be 0\n        val op1 = opArray(0);\n        val op2 = opArray(1);\n       \
    \ if(op1 == 0)\n            val op1Value = opArray(2)\n            if(op2 == 0)\n\
    \                val op2Value = opArray(3)\n                return op1Value +\
    \ op2Value\n            else\n                val op2Index = operand .indexOf(op2)\n\
    \                if(op2Index < operand.length)\n                    operand(op2Index)\
    \ else 0\n            else\n                val op2Value = opArray(3)\n      \
    \          val op2Index = operand .indexOf(op2)\n                if(op2Index <\
    \ operand.length)\n                    operand(op2Index) else 0\n            val\
    \ op1Index = operand .indexOf(op1)\n                if(op1Index < operand.length)\n\
    \                    operand(op1Index) else 0\n            val op1Value = opArray(2)\n\
    \                if(op1Index < operand.length)\n                    operand(op1Index)\
    \ else 0\n            return op1Value + op2Value\n        else\n            val\
    \ op1Value = opArray(2)\n            val op1Index = operand .indexOf(op1)\n  \
    \          val op2Value = opArray(3)\n            val op2Index = operand .indexOf(op2)\n\
    \            if(op1Index < operand.length && op2Index < operand.length)\n    \
    \            operand(op1Index + op2Index) else 0\n            else\n         \
    \       0", "        // Write your code here\n        val operatorStack = mutable.Stack[String]()\n\
    \        val operandStack = mutable.Stack[Long]()\n        operandStack.clear()\n\
    \        operatorStack.clear()\n        var result = 0L\n        while(!operatorStack.isEmpty\
    \ && !operandStack.isEmpty) {\n            val operator = operatorStack.pop()\n\
    \            val operand = operandStack.pop()\n            val operation = operators(operator)\n\
    \            val operandResult = operation(operand)\n            result += operandResult\n\
    \            operandStack.push(operandResult)\n        }\n        result", " \
    \       val a = operand(0)\n        val b = operand(1)\n        val c = operand(2)\n\
    \n        val opList = op match {\n            case op1 :: op2 :: _ => op1 ::\
    \ op2\n            case _ => List()\n        }\n        val opLength = opList.length\n\
    \n        // For each operator and operand, compute its value\n        // If the\
    \ result is 0, return 0, else return the result from previous recursive call.\n\
    \        def loop(i: Int, acc: Long) : Long = {\n            val op = opList(i)\n\
    \            val n = operand length\n            val left = operand(i + 1)\n \
    \           val right = operand(i + 2)\n            val operation = op match {\n\
    \                case \"+\" => a + b\n                case \"-\" => a - b\n  \
    \              case \"*\" => a * b\n                case \"/\" => a / b\n    \
    \            case \"%\" => a % b\n                case \"**\" => a * b\n     \
    \           case _ => throw new Exception(\"Invalid operator: \" + op)\n     \
    \       }\n            if(operation == 0) {\n                return acc\n    \
    \        }\n            loop(i - 1, operation % a + operation * loop(i + 1, operation\
    \ + left))\n        }\n        loop(opLength, 0) ", "        require(operand.length\
    \ >= 1)\n        require(operator.length >= 1)\n        require(operator.map(\
    \ e => e + 1).sum == 1)\n        val result = 0\n        operand.foreach( e =>\
    \ {\n            val operatorPos = operator.indexOf(e)\n            if (operatorPos\
    \ >= 0)\n                result += operator(operatorPos) * operand(e).toInt\n\
    \        })\n        result", "      var op1 = op(0)\n      var op2 = op(1)\n\
    \      var val1 = operand(0)\n      var val2 = operand(1)\n      var op3 = op2\n\
    \      var op4 = op3\n      var op5 = op4\n      var op6 = op5\n      var op7\
    \ = op6\n      var op8 = op7\n      var op9 = op8\n      var op10 = op9\n    \
    \  var op11 = op10\n      var op12 = op11\n      var op13 = op12\n      var op14\
    \ = op13\n      var op15 = op14\n      var op16 = op15\n      var op17 = op16\n\
    \      var op18 = op17\n      var op19 = op18\n      var op20 = op19\n      var\
    \ op21 = op20\n      var op22 = op21\n      var op23 = op22\n      var op24 =\
    \ op23\n      var op25 = op24\n      var op26 = op25\n      var op27 = op26\n\
    \      var op28 = op27\n      var op29 = op28\n      var op30 = op29\n      var\
    \ op31 = op30\n      var op32 = op31\n      var op33 = op32\n      var op34 =\
    \ op33\n      var op35 = op34\n      var op36 = op35\n      var op37 = op36\n\
    \      var op38 = op37\n      var op39 = op38\n      var op40 = op39\n      var\
    \ op41 = op40\n      var op42 = op41\n      var op43 = op42\n      var op44 =\
    \ op43\n      var op45 = op44\n      var op46 = op45\n      var op47 = op46\n\
    \      var op48 = op47\n      var op49 = op48\n      var op50 = op49\n      var\
    \ op51 = op50\n      var op52 = op51\n      var op53 = op52\n      var op54 =\
    \ op53\n      var op55 = op54\n      var op56 = op55\n      var op57 = op56\n\
    \      var op58 = op57\n      var op59 = op58\n      var op60 = op59\n      var\
    \ op61 = op60\n      var op62 = op61\n      var op63 = op62\n      var op64 =\
    \ op63\n      var op65 = op64\n      var op66 = op65\n      var op67 = op66\n\
    \      var op68 = op67\n      var op69 = op68\n      var op70 = op69\n      var\
    \ op71 = op70\n      var op72 = op71\n      var op73 = op72\n      var ", "  \
    \      // Base Case\n        if (op.size != operand.size || operand.size <= 1)\
    \ {\n            return 0\n        }\n        // Operator list\n        var i\
    \ = 0\n        var opLength = op.size\n        var opArray = Array[String](opLength)\n\
    \        \n        while (i < opLength) {\n            opArray(opLength - i -\
    \ 1) = op(opLength - i - 1)\n            i = i + 1\n        }\n        // operand\
    \ list\n        var j = 0\n        var operandLength = operand.size\n        var\
    \ operandArray = Array[Long](operandLength)\n        \n        while (j < operandLength)\
    \ {\n            operandArray(operandLength - j - 1) = operand(operandLength -\
    \ j - 1)\n            j = j + 1\n        }\n        var result = 0\n        val\
    \ length = opArray.lenth\n        for (i <- 0 until length) {\n            if\
    \ (opArray(i) == \"+\") {\n                result = result + operandArray(i)\n\
    \            } else if (opArray(i) == \"-\") {\n                result = result\
    \ - operandArray(i)\n            } else if (opArray(i) == \"*\") {\n         \
    \       result = result * operandArray(i)\n            } else if (opArray(i) ==\
    \ \"//\") {\n                result = result // operandArray(i)\n            }\
    \ else if (opArray(i) == \"**\") {\n                result = result ** operandArray(i)\n\
    \            }\n        }\n        return result", "        if (operand.length\
    \ < 2) {\n            throw new RuntimeException(\"Not enough operands\")\n  \
    \      }\n        if (op.length < 1) {\n            throw new RuntimeException(\"\
    Not enough operators\")\n        }\n        val newExpr = op flatMap { op =>\n\
    \            op.toCharArray match {\n                case op1 :: op2 :: tail =>\n\
    \                    operand match {\n                        case List() =>\n\
    \                            val newExpr1 = op match {\n                     \
    \           case '+' => operand zip operand.tail map { \n                    \
    \                case (_,r) => r + _\n                                }\n    \
    \                            case '-' => operand zip operand.tail map { \n   \
    \                                 case (_,r) => r - _\n                      \
    \          }\n                                case '*' => operand zip operand.tail\
    \ map { \n                                    case (_,r) => r * _\n          \
    \                      }\n                                case '/' => operand\
    \ zip operand.tail map { \n                                    case (_,r) => r\
    \ / _\n                                }\n                                case\
    \ '%' => operand zip operand.tail map { \n                                   \
    \ case (_,r) => r % _\n                                }\n                   \
    \             case '**' => operand zip operand.tail map { \n                 \
    \                   case (_,r) => r ** _\n                                }\n\
    \                            }\n                            operand match {\n\
    \                                case List() =>\n                            \
    \        val newExpr2 = newExpr1 match {\n                                   \
    \     case List() => List()\n                                        case lst\
    \ => lst.flatten flatMap { \n                                            case\
    \ (x, y) => newExpr1 match {\n                                               \
    \ case List() => List(x * y)\n                                               \
    \ case lst => lst.flatten flatMap { \n                                       \
    \             case (x, y) => newExpr1 match {\n                              \
    \                          case List() => List(x * y)\n                      \
    \                                  case lst => lst.flatten flatMap { \n      \
    \                                                      case (x, y) => newExpr1\
    \ match {\n                                                                case\
    \ List() => List(x * y)\n                                                    \
    \            case lst => lst.flatten flatMap { \n                            \
    \                                        case (x, y) => newExpr1 match {\n   \
    \                                                                     case List()\
    \ => List(x * y)\n                                                           \
    \             case lst => lst.flatten flatMap { \n                           \
    \                                                 case(x, y) => x * y + y\n  \
    \                                                                      }\n   \
    \                                                                 }\n        \
    \                                                        }\n                 \
    \                                           }\n                              \
    \                          }\n                                               \
    \     }\n                                                }\n                 \
    \                           }\n                                        }\n   \
    \                                 }\n                                    newExpr2\
    \ match {\n                                        case List() => List()\n   \
    \                                     case lst => lst.flatten flatMap { \n   \
    \                                         case (x, y) => newExpr2 match {\n  \
    \                                              case List() => ", "        val\
    \ length = op.length\n        val operandCopy = mutable.ListBuffer(operand)\n\
    \        if (operand.size == 0) {\n            return 0L\n        }\n        var\
    \ temp = 0L\n        for (i <- 0 to length-1) {\n            val first = operandCopy(0)\n\
    \            val second = operandCopy(1)\n            operandCopy -= 1\n     \
    \       temp := op(first, second)\n        }\n        if (operand.size == 1) {\n\
    \            val first = operandCopy(0)\n            temp := op(first)\n     \
    \   }\n        return temp", "        val opArray = op.toArray\n        var i\
    \ = 0\n        val res = operand.foldLeft(0) {\n        case (acc,a) => (\n  \
    \          if (a == 0) acc\n            else if (opArray.contains(s\"$a\"))\n\
    \                acc + a\n            else if (opArray.contains(s\"$(a+1)\"))\n\
    \                acc + (a+1)\n            else\n                acc\n        )\n\
    \        }\n        res", "        // Your code here\n        val num = 0L\n \
    \       var sum = 0L\n        for(i <- 0 until operand.size) {\n            sum\
    \ += operand(i) * op(i)\n            num = sum\n        }\n        sum", "   \
    \     var sum = 0\n        for (i<- 0..operand.size - 1) {\n            sum +=\
    \ operand(i) * operator(op.size - 1, i)\n        }\n        sum", "      require(op.size\
    \ == operand.size -1)\n      val operand2 = operand.tail\n      val opList2 =\
    \ op.dropRight(1)\n      val opList1 = op.takeRight(1)\n      val opList3 = op.takeRight(1)\n\
    \      val opList4 = op.takeRight(1)\n      val opList5 = op.takeRight(1)\n  \
    \    val result = operand2(0)\n      opList2.zipWithIndex.foreach { case (op2,\
    \ idx) =>\n        result += op2(1) * operand2(idx + 1)\n      }\n      opList3.zipWithIndex.foreach\
    \ { case (op3, idx) =>\n        result += op3(2) * operand2(idx + 1)\n      }\n\
    \      opList4.zipWithIndex.foreach { case (op4, idx) =>\n        result += op4(3)\
    \ * operand2(idx + 1)\n      }\n      opList5.zipWithIndex.foreach { case (op5,\
    \ idx) =>\n        result += op5(1) * operand2(idx + 1)\n      }\n      result",
  "        if(operand.length == 0 || operator.length == 0) {\n            return 0;\n\
    \        }\n        if(operator.length != operand.length-1) {\n            return\
    \ 0\n        }\n        val operatorMap : Map[String, String] = Map(\"+\" -> \"\
    +\",\"-\" -> \"-\",\"*\" -> \"*\",\"/\" -> \"/\",// -> \"//\",\n            \"\
    ^\" -> \"^\",\"**\" -> \"**\").withDefault(a => throw new NoSuchElementException(a\
    \ + \" is not a valid operator.\"));\n        val numberMap : Map[String, String]\
    \ = Map(\"1\" -> \"+\",\"2\" -> \"*\",\"3\" -> \"-\",\"4\" -> \"/\",// -> \"//\"\
    ,\n            \"5\" -> \"^\",\"6\" -> \"**\").withDefault(a => throw new NoSuchElementException(a\
    \ + \" is not a valid number.\"));\n        val resultMap : Map[String, String]\
    \ = Map(\"+\" -> \"+\",\"-\" -> \"-\",\"*\" -> \"*\",\"/\" -> \"/\",// -> \"//\"\
    ,\n            \"^\" -> \"^\",\"**\" -> \"**\").withDefault(a => throw new NoSuchElementException(a\
    \ + \" is not a valid operator.\"));\n        val operatorName = List(\"Addition\"\
    , \"Subtraction\", \"Multiplication\", \"Floor division\", \"Exponentiation\"\
    );\n        var operands = operand\n        val opList  = op.map(a => operatorMap(a))\n\
    \        val numList  = operand.map(a => numberMap(a))\n        var result = operand(0)\n\
    \        var operator = op.head\n        for(a <- 1 until operand.length) {\n\
    \            if(op(a) == \"+\") {\n                operands = operands.drop(1)\n\
    \                result =  result + operands(a) \n            }\n            else\
    \ if(op(a) == \"-\") {\n                operands = operands.drop(1)\n        \
    \        result =  result - operands(a) \n            }\n            else if(op(a)\
    \ == \"*\") {\n                operands = operands.drop(1)\n                result\
    \ = result * operands(a)\n            }\n            else if(op(a) == \"/\") {\n\
    \                operands = operands.drop(1)\n                result = result\
    \ / operands(a) \n            }\n            else if(op(a) == \"//\") {\n    \
    \            operands = operands.drop(1)\n                result = result % operands(a)\
    \ \n            }\n            else if(op(a) == \"^\") {\n                operands\
    \ = operands.drop(1)\n                result = math.pow(operands(a), operands(a+1))\
    \ \n            }\n            else {\n                operands = operands.drop(1)\n\
    \                result = math.pow(operands(a), operands(a+1)) \n            }\n\
    \        }\n        result(resultMap(operator))", "        // First we check if\
    \ the lists have the same length and that each element exists in the same list\n\
    \        if (op.size != operand.size) throw new RuntimeException(\"Operator and\
    \ Operand lists do not have the same length\")\n        \n        // For each\
    \ element of operand list we find the index in operand list where the corresponding\
    \ \n        // element of operator list exists and add this index to the sum obtained\
    \ so far\n        var index = 0\n        var sum = 0L\n        while (index <\
    \ operand.size && operator(index).contains(op.head)) {\n            sum += 1L\
    \ * operand(index)\n            index += 1\n        }\n        \n        // At\
    \ this point we know what to return\n        return sum", '        // your solution
    code goes here', "        val operations = op.mkString.toList.groupBy( x => x\
    \ )\n        val resultOperator = operations.map( x => x(0) ).toList\n       \
    \ val resultOperand = operations.map( x => x(1) ).toList\n        var result =\
    \ 0\n        operand.zipWithIndex.foreach { case (x,i) => result = result + x\
    \ * resultOperand(i) }\n        resultOperator.reverse.foreach { x => result =\
    \ result + (x + \"!\").toLong }\n        result", '        // TODO: Complete this',
  "        val opList = op.filterNot(_.isEmpty)\n        val numOperands = operand.length\
    \ - 1\n        val operandList = operand.filterNot(_.isEmpty)\n        val operandMap\
    \ : Map[String, Long] = \n            List(opList.head) ++ List(\"*\", \"/\",\
    \ \"//\", \"**\").zip(operandList.tail).map(x => x._1 -> x._2)\n\n        operandList.tail.map(x\
    \ => operandMap(x.toString))\n                .foldLeft(0)((a, b) => a + *(b))",
  "        val ops = op.map(x => x.toString).toSet\n\n        val operands = new mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 0 until operand.length - 1){\n            operands += operand(i)\n\
    \        }\n        val result = operands(0) * 1\n        for (i <- 1 until operands.length\
    \ - 1) {\n            var leftOperand = operands(0)\n            val rightOperand\
    \ = operands(i)\n            if (ops.contains(op(i))) {\n                result\
    \ += leftOperand + rightOperand\n            }\n            if (ops.contains(op(i-1)))\
    \ {\n                result -= leftOperand - rightOperand\n            }\n   \
    \         if (ops.contains(op(i+1))) {\n                result *= leftOperand\
    \ * rightOperand\n            }\n            if (ops.contains(op(i-1))) {\n  \
    \              result /= leftOperand / rightOperand\n            }\n         \
    \   if (ops.contains(op(i+1))) {\n                result // = result * rightOperand\n\
    \            }\n        }\n        return result", "        require(op.length\
    \ == operand.length - 1, s\"Length of op and op's length must be the same.\")\n\
    \        val opList = op.mkString\n        val operandList = operand.mkString\n\
    \        val result = evalAlgebra(opList, operandList)\n        result", "   \
    \     // Use your predefined function\n        val res = opArith(op, 0, operand,\
    \ operand + 1, \"\")\n        //res", "        def iterate(operand : List[Long],\
    \ result : List[Long], acc : mutable.ArrayBuffer[Long], acc : mutable.ArrayBuffer[Long])\
    \ : mutable.ArrayBuffer[Long] = {\n            val newOperand = operand ::: acc\n\
    \            val newResult = result ::: acc\n            val newAcc = newOperand\
    \ ::: newResult\n            if( acc.isEmpty){\n                newAcc\n     \
    \       }\n            else if( op.size == operand.size + 1 ) {\n            \
    \    newAcc\n            }\n            else {\n                iterate(newOperand,\
    \ newResult, newAcc, newAcc)\n            }\n        }\n        iterate(operand,\
    \ mutable.ArrayBuffer[Long](), mutable.ArrayBuffer[Long](), mutable.ArrayBuffer[Long]())"]
stop_tokens:
- "\n    }\n"
