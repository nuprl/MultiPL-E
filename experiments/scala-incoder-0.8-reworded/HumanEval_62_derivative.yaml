name: HumanEval_62_derivative
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // xs represent coefficients of a polynomial.\n    // xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n    // Return derivative of this polynomial in the same form.\n\
  \    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n\
  \    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))\n    // >>> derivative((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 6l.toLong))\n    def derivative(xs\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(derivative((List[Long](3l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong,\
  \ 12l.toLong, 20l.toLong))));\n    assert(derivative((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));\n    assert(derivative((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(derivative((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong,\
  \ 0l.toLong, 16l.toLong))));\n    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["      val xlen = xs.length\n      val dxs = xs.drop(xlen-1)\n     \
    \ dxs.map((x - dxs.sum) * xs.last).reverse", "        val list = new mutable.ArrayList[Long](xs.size+1)\n\
    \        list.add(1l)\n        var i : Int = 0\n        var coeff : Long = 1l\n\
    \        var x = 1l\n        while(i<xs.size){\n            x = xs(i) * x\n  \
    \          list.add(x)\n            i += 1;\n        }\n        list.take(xs.size).toList",
  "        val xs = xs.reverse\n        val dys = xs scanLeft 0l\n        val dysLength\
    \ = dys.length\n        val dysNew = ArrayBuffer(0l)\n        var dysLength =\
    \ dysLength\n        var y = 0\n        var x = 1\n        while (y < dysLength)\
    \ {\n            dysNew += dys(y)\n            y += 1\n        }\n        dysNew",
  "        var d = 0\n        var next = 1\n        var current = 0\n        var i\
    \ = 0\n        while(i < xs.size) {\n            if(next == 0) {\n           \
    \     current = xs(i)\n            } else {\n                d += next * current\n\
    \                current = xs(i)\n                i += 1\n            }\n    \
    \        next = current * current\n        }\n        if(next == 0) d.toList\n\
    \        else d.toList.tail.drop(1).reverse.drop(1).reverse.toList", "       \
    \ val size = xs.size\n        xs match {\n            case List(_, _, _, _, _)\
    \ => xs.reverse.foldLeft(List.empty[Long](0l)) { (xs, x) =>\n                val\
    \ coef = xs.head\n                val newXs = xs.tail\n                newXs.head.toLong\
    \ * coef + newXs.last * coef * xs.last.pow(xs.last)\n            }\n         \
    \   case _ => throw new ArithmeticException(\"Can't compute derivative of polynomial\
    \ with coefficient \" + xs.head + \". Polynomial is non-polynomial\")\n      \
    \  }", "        require(xs.length == 4)\n        val product = xs.foldLeft((1l,\
    \ 1l))((t, x) => t._1 * x + t._2)\n        product match {\n            case (2l,\
    \ 4l) => List(1l.toLong)\n            case (2, 4l) => List(1l.toLong)\n      \
    \      case (2, 2l) => List(1l.toLong)\n            case _ => xs.tail.foldRight(product)((t,\
    \ x) => t._1 * x * xs.tail.last)\n        }", "        // Use dynamic programming\
    \ to compute all derivatives of the polynomial evaluated at the given points.\n\
    \        // The order of the polynomial is fixed and equal to the degree of the\
    \ polynomial.\n        var xsDiff : List[List[Long]] = List.empty\n        for\
    \ (xdiff <- xsDiff.iterator)\n            xsDiff ::= xdiff\n        // Evaluate\
    \ the polynomial at the points.\n        var ys : List[Long] = xs.map(x => x *\
    \ 0L)\n        var i = 1\n        while (xs.exists(x => xs(i) != x)) {\n     \
    \       ys = xs.map(x => x * ys(i - 1))\n            i += 1\n        }\n     \
    \   ysDiff = xsDiff.map(x => List(x - ys(i), x * ys(i - 1)))\n        ysDiff.flatten",
  "        val ys = Nil\n        xs.reverse.foreach { x => ys = ys :+ x * ys.last;\
    \ ys }\n        ys", "        def term(xs : List[Long]) : List[Long] = {\n   \
    \         xs.foldLeft(List[Long]()){\n                case (acc, x) =>\n     \
    \               acc ++ List(x)\n            }\n        }\n        // Calculate\
    \ the derivative of each term.\n        // For example, the derivative of 1 +\
    \ 2 * x = 3 + 4 * x^2 = 7 + 8 * x^3 = 1 + 2 * (3 + 4 * x^2) = 3 + 4 * (7 + 8 *\
    \ x^2)\n        // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n\
    \        // (List[Long](3l.toLong, 6l.toLong))\n        term(xs).foldLeft(List[Long]()){\n\
    \            case (acc, x) =>\n                acc ++ List(-1 * x)\n        }",
  "        var ds : List[Long] = Nil\n        xs.foreach { x =>\n            var newDs\
    \ : List[Long] = Nil\n            if (xs.head == 0l) {\n                newDs\
    \ = Nil\n            } else if (xs.head % 2l == 0l) {\n                newDs =\
    \ Nil\n            } else if (xs.head % 2l == 1l) {\n                newDs = List(xs.head\
    \ - 1l)\n            } else {\n                val div = xs.head + 1l\n      \
    \          val divisor = div / 2l\n                val remainder = div mod (div\
    \ - 1l)\n                val quotient = (div - 1l) / divisor\n               \
    \ newDs = List(1l, divisor, remainder, quotient)\n            }\n            ds\
    \ = ds ++ newDs\n        }\n        ds", "        if (xs.length == 1) {\n    \
    \        xs.head.toLong\n        } else {\n            val x1 = xs.head.toLong\n\
    \            val x2 = xs.tail.head.toLong\n            (x1.toLong + x2.toLong\
    \ * x1 + x2.toLong * x2).toList\n        }", "        val dList = mutable.ListBuffer(1l.toLong)\n\
    \        for (i<-0 until xs.size) {\n            dList(i + 1) = \n           \
    \     if (i == 0) 1l.toLong \n                else xs(i) - dList(i) * xs(i-1)\
    \ \n        }\n        dList.toList", "        val numTerms = xs.length\n    \
    \    val xList = new scala.collection.mutable.MutableList[Long]()\n        val\
    \ ret = new scala.collection.mutable.MutableList[Long]()\n        var i = 0\n\
    \        var j = 0\n        while (i < numTerms) {\n            if (i == 0) {\n\
    \                val temp = xs(i)\n                xList.add(temp)\n         \
    \       i += 1\n            } else if (i % 2 == 0) {\n                val temp\
    \ = (xs(i-1) * xs(j+1) + xs(i) * xs(j)).toLong\n                xList.add(temp)\n\
    \                i += 1\n                j += 1\n            } else {\n      \
    \          val temp = (xs(i-1) * xs(j+1) + xs(i) * xs(j+1)).toLong\n         \
    \       xList.add(temp)\n                i += 1\n            }\n        }\n  \
    \      while (i + 1 < numTerms) {\n            val temp = (xs(i) * xs(i + 1)).toLong\n\
    \            xList.add(temp)\n            i += 1\n        }\n        while (i\
    \ + 1 < numTerms) {\n            val temp = (xs(i) * xs(i + 1)).toLong\n     \
    \       xList.add(temp)\n            i += 1\n            j += 1\n        }\n \
    \       xList.foreach(x => ret.add(x.toLong))\n        ret", "        val x0 =\
    \ xs.head\n        val x1 = xs.tail.head\n        List(x0, x1, x1 * x0)", "  \
    \      if(xs.isEmpty) List(1l.toLong)\n        else derivative(xs.tail) map (x\
    \ => x * xs.head + xs) ++ List(xs.head * xs.head) map (x => x * xs.head)", " \
    \       val len = xs.length - 1\n        xs.take(len) ++ List(1l.toLong)\n   \
    \         .map(x => xs.drop(len + 1).zipWithIndex.\n                  map({ case\
    \ (y, i) => x * y }).\n                  reduceLeft((x, y) => x + y))\n      \
    \      .toList", "        val p = xs.toSeq\n        if (p.isEmpty) Nil\n     \
    \   else {\n            val nx = p.head\n            var d = 1l.toLong\n     \
    \       p.tail.foreach{ n => d = d * (nx + n) }\n            List(d).toList ::\
    \ derivative(xs.drop(1))\n        }", '        xs.zip(Seq(xs.tail).foldLeft(0L)(
    (acc, x) => acc * x + xs.head ) )', "        if (xs.isEmpty) return Nil\n    \
    \    val ys = xs.dropRight(1).toList\n        xs.take(1).foldLeft(ys.head) { (a,\
    \ x) =>\n            val product = x * a + ys.head\n            ys.tail.foldLeft(product)((c,\
    \ x) => x * c + c)\n        }", "        xs match {\n            case Nil => Nil\n\
    \            case _ => {\n                val ys = xs.toStream\n             \
    \   .map(x => 1l - x)\n                .scanLeft(1l) { (result, x) =>\n      \
    \              (result.head * x % result.last).toLong }\n                .iterator\n\
    \                .toList\n                .takeWhile(_ > 0)\n                .reverse\n\
    \                .toList\n                .map(x => (1l - x) / ys.head)\n    \
    \            .tail\n                .map(x => x * ys.head)\n            }\n  \
    \      }", "        def iter(xs : List[Long], acc : List[Long]) : List[Long] =\n\
    \            if (xs.isEmpty) acc\n            else iter(xs.tail, (xs.head * acc\
    \ + xs.head) :: acc)\n        iter(xs, Nil)", "        val nd = xs.length - 1\n\
    \        val deriv = new mutable.ListBuffer[Long]()\n        for (i<- 0 to nd)\
    \ {\n            deriv.append(xs(i))\n            val nx = xs(i)\n           \
    \ val nxt = xs(i + 1)\n            if (nx > nxt) {\n                deriv.append(nxt\
    \ - nx)\n            }\n        }\n        deriv.toList.reverse", "        def\
    \ diff(xs : List[Long], i : Int, dx : List[Long], acc : List[Long]) : List[Long]\
    \ = {\n            if(i == xs.size - 1) {\n                acc\n            }\
    \ else {\n                val a = dx(i + 1l) * xs(i + 1l) + diff(xs, i + 2l, dx\
    \ :+ xs(i+ 1l), acc :+ dx(i + 1l))\n                val b = dx(i + 2l) * xs(i\
    \ + 2l) + diff(xs, i + 3l, dx :+ xs(i + 2l), acc :+ dx(i + 2l))\n            \
    \    diff(xs, i + 2l, dx :+ xs(i + 3l), acc :+ a + b)\n            }\n       \
    \ }\n        diff(xs, 1l, xs :+ 0l, Nil : List[Long])", "        val x = xs(1)\n\
    \        val y = xs(2)\n        val dx = xs.map(_.pow(2) - x * x)\n        val\
    \ dy = xs.map(_.pow(2) - y * y)\n        x :: dx.zip(y).toList", "        val\
    \ m = xs.size\n        if (m == 0) {\n            Nil\n        } else if (m ==\
    \ 1) {\n            Nil\n        } else if (m == 2) {\n            List(1l)\n\
    \        } else {\n            val coeff = List(xs.head)\n            val nxt\
    \ = List(xs.tail.head)\n            val nxtxt = Nil\n            val nxtxtxt =\
    \ List(xs.tail.tail.head).flatten\n            val xtxt = Nil\n            val\
    \ xtxtxt = List(xs.tail.tail.tail.head).flatten\n            val nxtxtxtxt = Nil\n\
    \            val nxtxtxtxtxt = List(xs.tail.tail.tail.tail.head).flatten\n   \
    \         val xtxtxtxt = Nil\n            val xtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.head).flatten\n\
    \            val nxtxtxtxtxtxt = Nil\n            val nxtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val xtxtxtxtxtxt = Nil\n            val xtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val nxtxtxtxtxtxt = Nil\n            val nxtxtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val xtxtxtxtxtxtxt = Nil\n            val xtxtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val nxtxtxtxtxtxtxt = Nil\n            val nxtxtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val xtxtxtxtxtxtxt = Nil\n            val xtxtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val nxtxtxtxtxtxtxt = Nil\n            val nxtxtxtxtxtxtxt = List(xs.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head).flatten\n\
    \            val xtxtxtxt", "        val result: List[Long] = Nil\n        var\
    \ j = 0\n        for(i <- 0 until xs.size) {\n            j += 1\n           \
    \ val current = xs(i) - xs(j)\n            result ::= current\n        }\n   \
    \     result.reverse", "        val result = xs.reverse.foldLeft(List(1l.toLong))\
    \ {\n            (acc, cur) => acc.reverse.foldLeft(List((acc(0) + cur).toLong))\
    \ {\n                (acc, cur) => List((acc(1) * cur).toLong, (acc(2) * cur).toLong)\n\
    \            }\n        }\n        result.reverse", "        val ys = List.fill(x.length)(0)\n\
    \        xs.zipWithIndex.foreach { case (x, i) =>\n            ys(i) = x * ys(i\
    \ - 1)\n        }\n        ys.reverse", "        val y = xs.last\n        val\
    \ y0 = xs.head / y\n        val dx = xs.tail.map(y => 1 / y).reverse\n       \
    \ dx map { x => x0 + x0 * x + x0 * x0 * x + x0 * x0 * x0 * x }", "        var\
    \ newXs = xs\n        // First and last coefficients are zero, so no need to include\
    \ them in the derivative.\n        if (newXs.head == 0L && newXs.last == 0L) return\
    \ Nil\n        val d = 1L\n        var newLast = 0L\n        // Loop through the\
    \ list of coefficients.\n        // If x is 0, then that is the only coefficient\
    \ left.\n        // If x is 1, then we can simply skip that element since it is\
    \ not contributing to the derivative.\n        // If x is not 1, then we need\
    \ to calculate the derivative of 1 divided by x + 2.\n        // And add the new\
    \ partial derivative to the list.\n        for (x <- newXs.init.reverse.tail)\
    \ {\n            if (x == 1L) newLast += 1L\n            else {\n            \
    \    newXs = newXs.tail.map(x => d * (x - 1L) / x + 2L)\n                d *=\
    \ x\n                newLast = 0\n            }\n        }\n        newXs = newXs.init\n\
    \        if (newLast > 0) newXs = newXs ::: (1L :: newLast :: Nil)\n        newXs",
  "        val ys = xs.toList\n        val (y0,y1) = (ys(0),ys(1))\n        if(y1\
    \ == 0) ys ++ List(0l) else ys ++ List(1l)", "        val xpow = xs.take(xs.size\
    \ - 2).map(x => x * x)\n        val ypow = xs.takeRight(xs.size - 1).map(x =>\
    \ x * x)\n        xpow.zip(ypow).map(x => x._1 + x._2).reverse", "        val\
    \ xs1 = xs.zipWithIndex.map { case (_,i) => math.pow(xs(i),i) }\n        val xs2\
    \ = xs1.zipWithIndex.map { case (v1,i) => math.pow(v1,i) }\n        val x3 = xs2.zipWithIndex.map\
    \ { case (v2,i) => v1 + v2 - x2(i) }\n        x3", "        var result = List(1l.toLong)\n\
    \        var current = 1l.toLong\n        xs.foreach {\n          x =>\n     \
    \       result :+ current * (x-1)\n            current *= x\n        }\n     \
    \   result.reverse", "        val n = xs.length\n        // Recurse to handle\
    \ even number of terms, \n        // by dividing by xs[n - 1] until xs[n - 1]\
    \ is 0.\n        if (n % 2 == 0) {\n            // Start by adding the first term\
    \ and recurse with remainder.\n            xs.head :: derivative(xs.tail)\n  \
    \      } else {\n            // The odd case will be to first multiply the first\
    \ term by xs[n - 1]\n            // and then recurse with remainder.\n       \
    \     xs.head * derivative(xs.tail)\n        }", "        var x = xs\n       \
    \ val numOfCoeff = x.size\n        var der = 0L\n        while (x.size > 0) {\n\
    \            val a = x.head\n            x = x.tail\n            der = (der +\
    \ a).toLong\n        }\n        if (der==0) der\n        else List(der)", "  \
    \      val d = List.empty[Long]\n        val n = xs.length\n        if (n == 1)\
    \ d :+ xs.head else d :+ xs.head * (n-1) ::: List.fill(n-1)(d :+ xs.tail.last)",
  "        val n = xs.size\n        xs.foldLeft((List[Long](), List[Long]()))((acc,\
    \ x) => {\n          val dx =\n            if (x == 0) 0 else (xs.last.head.toLong\
    \ * x + acc)\n          (acc :+ dx, acc :+ (x * dx))\n        })", "        val\
    \ xArray = Array[Long](xs.length + 1)\n        xArray(0) = 1\n        xArray(1)\
    \ = xs(0) * xs(1)\n        for (i2 <- 1 until xs.length){\n            xArray(i2)\
    \ = xs(i2 - 1) * xs(i2)\n        }\n        xArray", "        val ys = xs.tail\n\
    \        val one = xs.head\n        (xs zip ys) map { case (y,x) => x*y - (one\
    \ - y)}", "        val n = xs.length\n        val xArray = xs.toArray\n      \
    \  val ys = new Array[Long](n + 1)\n        ys(0) = 1\n        xs.zip(ys).map\
    \ {\n            case (x, y) => x * y\n        }", "        val n = xs.length\n\
    \        var y = xs.head\n        var d = xs.head\n        var dp = 0.0\n    \
    \    var dps = 0.0\n\n        for (ix <- 1 to n-1) {\n            dp = d + 2.0\
    \ * ix * y\n            dps = dps + ix * dx(y) * dx(y)\n            d = dp\n \
    \           y = dps\n        }\n        dps", "        val ret: List[Long] = Nil\n\
    \        val x0 = xs.head\n        val x1 = xs.tail.head\n        val x2 = xs.tail.tail.head\n\
    \        var x3 = xs.tail.tail.tail.head\n        var x4 = xs.tail.tail.tail.tail.head\n\
    \n        val y1 = x0 - x1 * x\n        val y2 = x3 - x2 * x\n        val y3 =\
    \ x4 - x3 * x\n\n        val m1 = y1 - y2\n        val m2 = y3 - y2\n\n      \
    \  var n1: Long = Nil\n        var n2: Long = Nil\n        var n3: Long = Nil\n\
    \        var n4: Long = Nil\n\n        n1 = y1\n        n2 = m2\n        n3 =\
    \ y3\n        n4 = y2 - x2\n\n        var ret1 = Nil\n        var ret2 = Nil\n\
    \        var ret3 = Nil\n        var ret4 = Nil\n\n        if (xs.head == 1l.toLong)\n\
    \            Nil\n        else if (m1 == 0l.toLong && n1 == 0l.toLong && m2 ==\
    \ 0l.toLong && n2 == 0l.toLong && n3 == 0l.toLong && n4 == 0l.toLong)\n      \
    \      Nil\n        else if (m1 == 0l.toLong && m2 != 0l.toLong && y3 == 0l.toLong\
    \ && y2 == 0l.toLong)\n            List(xs.tail.tail.head)\n        else if (m1\
    \ != 0l.toLong && m2 == 0l.toLong && y3 == 0l.toLong && y2 != 0l.toLong)\n   \
    \         List(xs.tail.tail.head, x0l.toLong)\n        else if (m1 != 0l.toLong\
    \ && m2 != 0l.toLong && y3 == 0l.toLong && y2 != 0l.toLong)\n            List(xs.tail.tail.head,\
    \ x0l.toLong, xs.tail.tail.tail.head)\n        else if (m1 != 0l.toLong && m2\
    \ != 0l.toLong && y3 != 0l.toLong && y2 != 0l.toLong)\n            List(xs.tail.tail.head,\
    \ x0l.toLong, xs.tail.tail.tail.head, x0l.toLong, xs.tail.tail.tail.tail.head)\n\
    \        else if (m1 != 0l.toLong && m2 != 0l.toLong && y3 != 0l.toLong && y2\
    \ != 0l.toLong)\n            List(xs.tail.tail.head, x0l.toLong, xs.tail.tail.tail.head, ",
  "        var ds: List[Long] = Nil\n        // find highest power of x in xs\n  \
    \      var highestPower = xs\n        var maxPower = -1\n        for(x <- xs)\
    \ {\n            if(x > maxPower) {\n                highestPower = x\n      \
    \          maxPower = x\n            }\n        }\n        // for each power,\
    \ sum highest power of all x to the power\n        for(powers <- highestPower.until(maxPower))\
    \ {\n            // find sum of x to power\n            var sum = 0\n        \
    \    for(x <- xs) {\n                sum += x*powers\n            }\n        \
    \    // multiply derivative of the sum by x^power to get derivative\n        \
    \    var derivative = sum*powers\n            // sum derivative of x to power\n\
    \            ds = (ds :+ derivative)\n        }\n        return ds", "       \
    \ require(xs.length >= 2)\n        // If last term is 1, just return xs list with\
    \ last term 0.\n        if(!xs.tail.contains(1l))\n            xs.tail.map(0l).reverse\n\
    \        else\n            // Find the index of the largest coefficient which\
    \ is power of two.\n            // If there is no such index, the return xs list.\n\
    \            val largest_power = xs.indexOf(xs.last.pow(2)) match {\n        \
    \        case -1 => xs\n                case idx => xs.take(idx + 1)\n       \
    \     }\n            // Recursively solve the subproblem\n            val sol\
    \ = largest_power.tail.map(2l.toLong).scanLeft(1l) {\n                case (acc,\
    \ _) => acc.pow(2)\n            }\n            sol.reverse", "        xs match\
    \ {\n            case x :: Nil => Nil\n            case x :: y :: tail => x +\
    \ (y * (derivative(tail)) + derivative(tail))\n            case x :: Nil => Nil\n\
    \            case _ => Nil\n        }", "        val n = xs.size\n        if(n\
    \ == 0)\n            Nil\n        else\n            if(n == 1)\n             \
    \   List(1l.toLong)\n            else\n                if(n == 2)\n          \
    \          List(1l.toLong, 2l.toLong)\n                else\n                \
    \    if(n == 3)\n                        List(1l.toLong, 2l.toLong, 3l.toLong)\n\
    \                    else\n                        if(n == 4)\n              \
    \              List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)\n            \
    \            else\n                            if(n == 5)\n                  \
    \              List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)\n \
    \                           else\n                                if(n == 6)\n\
    \                                    List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 6l.toLong)\n                                else\n              \
    \                      if(n == 7)\n                                        List(1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)\n        \
    \                            else\n                                        if(n\
    \ == 8)\n                                            List(1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong)\n        \
    \                                else\n                                      \
    \      if(n == 9)\n                                                List(1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong,\
    \ 9l.toLong)\n                                            else\n             \
    \                                   if(n == 10)\n                            \
    \                        List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)\n                  \
    \                              else\n                                        \
    \            if(n == 11)\n                                                   \
    \     List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong,\
    \ 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong)\n                            \
    \                        else\n                                              \
    \          if(n == 12)\n                                                     \
    \       List(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, ", "     \
    \   def getDerivative(xs : List[Long], i : Int) : List[Long] = {\n           \
    \ if (i < xs.size) xs.slice(0, i + 1) ::: getDerivative(xs.slice(i + 1), i + 1)\n\
    \            else xs ::: Nil\n        }\n        getDerivative(xs, 0) ::: getDerivative(xs,\
    \ xs.size - 1)", "        if (xs.isEmpty) Nil\n        else xs.head :: derivative(drop(xs.tail).map(x\
    \ => x * xs.head))", "        var y : Long = 0\n        var dx : List[Long] =\
    \ Nil\n        // The initial coefficients are a linear combination of x and x^2.\n\
    \        val init: Long = xs.head + xs.tail.head * xs.tail.last\n        // If\
    \ there is no initial coefficient, return 0.\n        if(init < 0){\n        \
    \    return 0\n        }\n        for((x, xs) <- xs zip (xs.tail.tail ::: Nil)){\n\
    \            y = xs.head + x * y\n            dx :+= y\n        }\n        (dx\
    \ :: Nil)", "        // Write your code here.\n        val list = new mutable.Array[Long](3)\n\
    \        var i = 0\n        list.update(i, xs(i))\n        i += 1\n        list.update(i,\
    \ (xs(i) * xs(i - 1)).toLong)\n        i += 1\n        list", "        // The\
    \ function which calculates x^0\n        def xZero(x: Long) : List[Long] = (xs.isEmpty)\
    \ \n            ? List()\n            : (1l.toLong :: xs) match {\n          \
    \      case Nil => List()\n                case head :: tail => \n           \
    \         xZero(head) match {\n                        case Nil => List()\n  \
    \                      case head :: tail1 =>\n                            (tail.zip(tail1).map{\
    \ case (head, tail2) => head.toLong * tail2 }) \n                            \
    \    match { \n                                    case Nil => List()\n      \
    \                              case head :: tail => List(head.toLong * xs.sum)\n\
    \                                }\n                    }\n            }\n   \
    \     // x^0 = 0 \n        val xZeroIter = xZero.toIterator.map(_.toDouble)\n\
    \        // x^0 = 0 \n        val xZeroIterIter = xZero.toIterator.map(_.toLong)\n\
    \        // x^0 = 1 \n        val xZeroIterIterIter = xZero.toIterator.map(_.toInt)\n\
    \        val ys = new mutable.ListBuffer[Long]()\n        val x = xs.head\n  \
    \      for (i <- 0 until xZeroIterIter.size) {\n            ys += xZeroIterIter(i)\
    \ * x\n        }\n        ys.toList", "        val ret = new mutable.ArrayBuffer[Long]\n\
    \        val n = (xs.length - 1)\n        for (i <- 0 until n) ret += xs(i+1)\
    \ - xs(i)\n        ret", "        var coeff = xs\n        var x = coeff match\
    \ {\n            case List() => 1\n            case List(1) => 1\n           \
    \ case List(1l, 2l) => 2l\n            case List(1l, 2l, 3l) => 3l\n         \
    \   case List(1l, 2l, 3l, 4l) => 4l\n            case List(1l, 2l, 3l, 4l, 5l)\
    \ => 5l\n            case List(1l, 2l, 3l, 4l, 5l, 6l) => 6l\n            case\
    \ _ => throw new RuntimeException(\"invalid polynomial: \" + xs)\n        }\n\
    \        var x = coeff match {\n            case List() => 1\n            case\
    \ List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l) => 7l\n            case List(1l, 2l, 3l,\
    \ 4l, 5l, 6l, 7l, 8l, 9l, 10l) => 8l\n            case List(1l, 2l, 3l, 4l, 5l,\
    \ 6l, 7l, 8l, 9l, 10l, 11l) => 9l\n            case List(1l, 2l, 3l, 4l, 5l, 6l,\
    \ 7l, 8l, 9l, 10l, 11l, 12l) => 10l\n            case List(1l, 2l, 3l, 4l, 5l,\
    \ 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l) => 11l\n            case List(1l, 2l, 3l,\
    \ 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l) => 12l\n            case List(1l,\
    \ 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l) => 13l\n     \
    \       case List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l,\
    \ 15l, 16l) => 14l\n            case List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l,\
    \ 10l, 11l, 12l, 13l, 14l, 15l, 16l, 17l) => 15l\n            case List(1l, 2l,\
    \ 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l, 16l, 17l, 18l) =>\
    \ 16l\n            case List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l,\
    \ 13l, 14l, 15l, 16l, 17l, 18l, 19l) => 17l\n            case List(1l, 2l, 3l,\
    \ 4l, 5l, 6l, 7l, 8l, 9l, 10", "        val n = xs.size\n        if (xs(0) ==\
    \ 0) xs.tail\n        else (\n          xs.tail :+ xs(0) - xs(1) * xs(n) / xs(n)\
    \ \n            - xs(n - 1) * xs(n - 2) / xs(n - 2)\n            - xs(n - 1) *\
    \ xs(n - 3) / xs(n - 3)\n            - xs(n - 1) * xs(n - 4) / xs(n - 4)\n   \
    \         - xs(n - 1) * xs(n - 5) / xs(n - 5)\n        ).reverse", "      var\
    \ ans = xs.tail\n      ans.zip(ans.tail.zip(ans.head).map(x => x._2 - x._1))",
  "        var dx = ListBuffer.empty[Long]\n        xs.foreach{ x => dx :+= x*(xs.size\
    \ - 1) }\n        dx", "        // The derivative of a polynomial is defined as:\n\
    \        // d^n(x) = sum(a * x^n for a in xs)\n        // Here we take the derivative:\n\
    \        // d^n(x) = n * d(x^2)\n        // And we start with a list of zeros.\n\
    \        // So we have two lists:\n        // firstList : List[Long] = List[Long]()\n\
    \        // secondList : List[Long] = List[Long]()\n        // Let's say we got\
    \ xs: List[Long] = List[Long](2, 3, 5, 7, 11)\n        // Now we do this:\n  \
    \      // firstList ::: xs\n        // firstList: List[Long] = List(2, 3, 5, 7,\
    \ 11, 2, 5, 7, 11)\n        // secondList ::: xs\n        // secondList: List[Long]\
    \ = List(2, 3, 5, 7, 11, 2, 5, 7, 11)\n        // And now we have two lists with\
    \ our first and second derivatives in them.\n        // Let's continue this process.\n\
    \        // So we have firstList : List[Long] = List(2, 3, 5, 7, 11)\n       \
    \ // secondList : List[Long] = List(2, 3, 5, 7, 11, 2, 5, 7, 11)\n        // We\
    \ need to do this process for every element in the list (xs).\n        // So we\
    \ do this:\n        val firstList = List(xs.head, xs.last, xs.head)\n        //\
    \ So firstList : List[Long] = List(2, 3, 5, 7)\n        // Now we call our derivative\
    \ function:\n        val secondList = derivative(firstList)\n        // So secondList\
    \ : List[Long] = List(2, 5, 7, 11, 6, 14, 21)\n        // And finally we add both\
    \ our lists together:\n        secondList ::: firstList", "        if (xs.length\
    \ < 2) \n            Nil\n        else \n            (1 to xs.length - 1).map(i\
    \ => xs(i) * xs(i - 1)).toList :+ xs(0)", "        var dx : List[Long] = Nil\n\
    \        var n : Int = xs.length\n        var k : Int = 0\n        while (dx eq\
    \ Nil && k < n) {\n            val product = xs(k) * xs(k + 1)\n            dx\
    \ ::= product / xs(k + 1)\n            k += 1\n        }\n        dx", "     \
    \   var y = xs(0)\n        var z = 1\n        var xp = xs\n        var zp = List[Long]()\n\
    \        while (xp.size > 1){\n            zp = zp :+ z*xp.head\n            x\
    \ = xp.tail\n            y = y*x + z*xp.head\n            z = z*xp.head\n    \
    \        xp = xp.tail\n        }\n        zp :+ z", "        // Your code goes\
    \ here\n        val xs = xs.toList\n        var x = 0\n        var x1 = x(0)\n\
    \        val y = xs.size - 1\n        val x2 = xs(y)\n        var y2 = y\n   \
    \     var result = new ListBuffer[Long]\n        while (y < xs.size) {\n     \
    \       val x3 = x(x1)\n            val y3 = y2 - 1\n            val y4 = y3\n\
    \            val y5 = y4\n            val z = (y5 - x3)*(x(x3)*x3 + y4*(x(x3)*x3\
    \ + y3*(x(x3)*x3 + y2*(x(x3)*x3 + y1*(x(x3)*x3)))) / (x(x3)*x(x3) + y4*(x(x3)*x(x3)\
    \ + y3*(x(x3)*x(x3) + y2*(x(x3)*x(x3) + y1*(x(x3)*x(x3)))))\n            val a\
    \ = x(y3)\n            val b = x(y4)\n            val c = x(y5)\n            val\
    \ x6 = x(x3)\n            val y6 = y6 - x6\n            val z = y6*x6*z\n    \
    \        val x7 = x(x3)\n            val y7 = y7 - x7\n            val z = y7*x7*z\n\
    \            val x8 = x(x3)\n            val y8 = y8 - x8\n            val z =\
    \ y8*x8*z\n            val x9 = x(x3)\n            val y9 = y9 - x9\n        \
    \    val z = y9*x9*z\n            val x10 = x(x3)\n            val y10 = y10 -\
    \ x10\n            val z = y10*x10*z\n            val x11 = x(x3)\n          \
    \  val y11 = y11 - x11\n            val z = y11*x11*z\n            val x12 = x(x3)\n\
    \            val y12 = y12 - x12\n            val z = y12*x12*z\n            val\
    \ x13 = x(x3)\n            val y13 = y13 - x13\n            val z = y13*x13*z\n\
    \            val x14 = x(x3)\n            val y14 = y14 - x14\n            val\
    \ z = y14*x14*z\n            val x15 = x(x3)\n            val y15 = y15 - x15\n\
    \            val z = y15*x15*z\n            val x16 = x(x3)\n            val y16\
    \ = y16 - x16\n            val z = y16*x16", "        val d = new ArrayList[Long](xs.length)\n\
    \        var i = 0\n        var p = xs(0) // first value becomes d = 0\n     \
    \   while (i + 1 < xs.length) {\n            val add = p.toLong + xs(i + 1) *\
    \ (1 +\n                i * p.toLong.pow(xs(i).toLong))\n            p.toLong\
    \ = add\n            d(i) = add\n            i += 1\n        }\n        if (i\
    \ == 0) d(0)\n        else d", "      val ys = xs.slice(1, xs.length).map(e =>\
    \ e * e)\n      ys.reverse", "        if (listLength(xs) == 0) {\n           \
    \ List()\n        } else {\n            val x0 = xs(0)\n            val x1 = xs(1)\n\
    \            val x2 = xs(2)\n            val x3 = xs(3)\n            val x4 =\
    \ xs(4)\n            val x5 = xs(5)\n            val dx0 = 1\n            val\
    \ dx1 = (x0 + x2 * x3) - (x1 + x2 * x4)\n            val dx2 = (x1 + x2 * x4)\
    \ - (x0 + x2 * x5)\n            val dx3 = x0\n            val dx4 = (x1 * x5)\
    \ - (x0 * x3)\n            val dx5 = (x0 * x3) - (x1 * x4)\n            List(scala.math.pow(dx0,\
    \ 2) + scala.math.pow(dx1, 2) + scala.math.pow(dx2, 2) + scala.math.pow(dx3, 2)\
    \ + scala.math.pow(dx4, 2) + scala.math.pow(dx5, 2))\n        }", "        xs.foldLeft(List[Long](0l))\
    \ { \n            case (acc, x) => (acc.reverse.head + acc * x)\n        }", " \
    \       val n = (xs.size-2)\n        val f = xs(1)\n        val g = xs(n+1)\n\
    \        val h = xs(n+2)\n        val p = xs(1)\n        val q = xs(n+2)\n   \
    \     val r = xs(n+1)\n        val xi = xs.slice(1, n+1)\n\n        val c1 = new\
    \ Array[Double](x.size)\n        val c2 = new Array[Double](x.size)\n        val\
    \ c3 = new Array[Double](x.size)\n\n        val a1 = new Array[Double](x.size)\n\
    \        val a2 = new Array[Double](x.size)\n        val a3 = new Array[Double](x.size)\n\
    \        val b1 = new Array[Double](x.size)\n        val b2 = new Array[Double](x.size)\n\
    \        val b3 = new Array[Double](x.size)\n        val c12 = new Array[Double](x.size)\n\
    \        val c23 = new Array[Double](x.size)\n        val c13 = new Array[Double](x.size)\n\
    \        val c21 = new Array[Double](x.size)\n        val c11 = new Array[Double](x.size)\n\
    \        val c13 = new Array[Double](x.size)\n        val c31 = new Array[Double](x.size)\n\
    \n        // xi = xi - xi^2 + xi^3\n        // xi = xi - xi^2 + xi^3 - xi^3\n\
    \        // xi = xi - xi^2 - xi^3 - xi^3\n        // xi = xi^2 - xi^3\n      \
    \  // xi = xi^3\n        // xi = xi^2\n        for(i<-0 until (n-1)) {\n     \
    \       c1(i) = 0\n            c2(i) = 0\n            c3(i) = 0\n            c1(i+1)\
    \ = xs(i+2)\n            c2(i+1) = xs(i+1)\n            c3(i+1) = xs(i)\n    \
    \    }\n        a1(0) = p\n        a2(0) = q\n        a3(0) = r\n        b1(0)\
    \ = h\n        b2(0) = g\n        b3(0) = f\n\n        for(i<-0 until (n-1)) {\n\
    \            c12(i) = (a2(i+1) - a2(i))*(xs(i+2) - xs(i+1)) + a2(i)*(xs(i+1) -\
    \ xs(i))\n            c23(i) = (a3(i+1) - a3(i))*(xs(i+2) - xs(i+1)) + a3(i)*(xs(i+1)\
    \ - xs(i))\n            c13(i) = (a3(i+1) - a3(i))*(xs(i+1) - xs(i)) + a3(i)*(xs(",
  "        if(xs.length == 0)\n          List(1l)\n        else {\n          val dList\
    \ = List(xs.head - xs.tail.head)\n          xs.tail foreach { x => dList.head\
    \ += x}\n          dList\n        }", "        val x1 = xs(0)\n        val x2\
    \ = xs(1)\n        val x3 = xs(2)\n        val x4 = xs(3)\n        (x1.toLong\
    \ * (-2l.toLong + x2 * x4) + (x2 * x3.toLong) + (x4 * x3.toLong * x2.toLong)).toList",
  "        def powerSeries(xs : List[Long], acc: List[Long]) : List[Long] = {\n  \
    \          if (xs.isEmpty) return acc\n            powerSeries(xs.tail, (xs.head\
    \ * acc) :: acc)\n        }\n        powerSeries(xs, Nil).reverse", "        val\
    \ n = xs.length\n        val p = xs.tail\n        val d = Array(n+1, n+1)\n  \
    \      val z = Array(xs.head + 1)\n        (0 until n).foreach {i => d(i) = xs(i)\
    \ * z(i+1).toLong}\n        (0 until n).foreach {i => d(i) = d(i) - d(i-n)*p(i).toLong}\n\
    \        d(0)", '        // Write your code here', "        var d = 0\n      \
    \  var n = 0\n        for (i <- 0 until xs.size) {\n            d += xs(i) * n\n\
    \            n += 1\n        }\n        n", "        if(xs.isEmpty) List()\n \
    \       else {\n            val result = new ListBuffer[Long]()\n            for(i<-xs.indices-1\
    \ to 0 by -1){\n                result.insert(i, (xs(i)*xs(i-1)))\n          \
    \  }\n            result\n        }", "        if (xs.isEmpty)\n            xs\
    \ :: Nil\n        else\n            xs.tail.head :: derivative(xs.tail)", "  \
    \      if (xs.size < 1) return Nil\n        var res : List[Long] = Nil\n     \
    \   var d = 0\n        var j = 0\n        while (j < xs.size) {\n            val\
    \ d = xs(j)\n            // calculate first derivative of xs from 1 to j\n   \
    \         val f = (j +  1) * d\n            res = res.::(f + xs(j + 1))\n    \
    \        j += 1\n        }\n        return res", "        val x = xs.head\n  \
    \      val ys = xs.tail\n        val result = new mutable.ListBuffer[Long]()\n\
    \        ys.zip(1l) {\n        case (y, x) => result.append(x * y)\n        }\n\
    \        result.headOption.toList ++ result.tail", "        if(xs.length == 0)\
    \ throw new RuntimeException(\"Must be a polynomial of at least 2 terms.\")\n\
    \        val xs1 = xs.reverse\n        val ys = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        // Use binary search to find next term to add\n        // This step takes\
    \ O(log n) time\n        def bisearch(i: Long, value: Long, lo: Long, hi : Long)\
    \ : Option[Long] = {\n            if(lo > hi) None\n            else if(lo ==\
    \ hi)\n                if(i == value) Some(i)\n                else None\n   \
    \         else if(value < xs(i))\n                bisearch(i + 1, value, lo, (lo\
    \ + hi) / 2)\n            else if(value > xs(i))\n                bisearch(i +\
    \ 1, value, (lo + hi) / 2 + 1, hi)\n            else\n                None\n \
    \       }\n        for(i <- 0 until xs.length - 1) {\n            val value =\
    \ xs(i)\n            val low = xs1(i).asInstanceOf[Long]\n            val high\
    \ = xs1(i + 1).asInstanceOf[Long]\n            val lo = bisearch(i, value, low,\
    \ high).flatMap(_.asInstanceOf[Long])\n            val hi = bisearch(i, value,\
    \ lo, high).flatMap(_.asInstanceOf[Long])\n            val dx = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \            for(i <- lo until hi) dx += (xs(i) - value)\n            ys += dx\n\
    \        }\n        ys.reverse", "        var ys = List(xs.toDouble)\n       \
    \ ys.zipWithIndex.foreach { case (x, i) =>\n            if ((i % 2) == 0)\n  \
    \              ys.updated(i, x * ys.last)\n        }\n        ys", "        def\
    \ rec(l : List[Long], d : List[Long], acc : List[Long]) : List[Long] = {\n   \
    \         if (l.length == 0) {\n                acc.reverse\n            } else\
    \ {\n                val p = xs(l.head) - l.tail.head * d\n                rec(l.tail,\
    \ p :: d, acc :+ p)\n            }\n        }\n        rec(xs.tail, xs.head ::\
    \ Nil, Nil)", "        val coefficients = xs.tail\n        val powers = xs.head\n\
    \        val firstCoefficient = coefficients.head\n        val secondCoefficient\
    \ = coefficients.tail.head\n        val powerFirst = powers.head\n        val\
    \ powerSecond = powers.tail.head\n\n        coefficients.tail.foldLeft(firstCoefficient)\
    \ {\n          case (firstCoefficient, secondCoefficient) =>\n            secondCoefficient\
    \ + (firstCoefficient * powerFirst)\n        }", "        // Initialize xs to\
    \ point at x0 by copying xs to xs then setting xs to point at x1.\n        //\
    \ This is done because we want to preserve the original xs list while modifying\
    \ it.\n        // xs contains x0 through x(n-1) as one element and the coefficient\
    \ of x(n) in the derivative\n        // is the same as the coefficient of x(n-1).\n\
    \        // x(n) = x(n-1) * x(n-1) * x(n-1) * x(n-1) * ... * x(n-1) * x0 ... x0\n\
    \        // Initialize x0 to xs(0).\n        var x0 = xs(0);\n        // Initialize\
    \ x1 to xs(1).\n        var x1 = xs(1);\n        // Initialize xd1 to x0.\n  \
    \      var xd1 = x0;\n        var j : Int = 0;\n        while(j < xs.length-1)\
    \ {\n            // Set xd1 to xd1 + x1(j) * x1(j) * x1(j) * ... * x1(j) * x0.\n\
    \            xd1 = xd1 + x1(j) * x1(j) * x1(j) * ... * x1(j) * x0;\n         \
    \   // Set x1 to xd1 + x1(j+1).\n            x1 = xd1 + x1(j+1);\n           \
    \ // Set xd1 to x1.\n            xd1 = x1;\n            j += 1\n        }\n  \
    \      // Return xd1 to x0.\n        xd1", "        val n = xs.size\n        xs\
    \ match {\n            case Nil => Nil\n            case first :: Nil => List(1l.toLong).reverse\n\
    \            case first :: next => List(xs(0).toLong, first.toLong).reverse ::\
    \ derivative(next)\n            case first :: rest => List(first.toLong, xs(1).toLong).reverse\
    \ :: derivative(rest)\n        }", "        // Write your code here\n        val\
    \ result: mutable.MutableList[Long] = mutable.MutableList(1)\n        for (x <-\
    \ xs) {\n            result += x\n        }\n        result", "        def dp(prev:\
    \ Long, x: Long) : List[Long] = {\n            if (x == 0L)\n                List(0L)\n\
    \            else if (x == 1L)\n                List(1L)\n            else if\
    \ (x == xs!!(1L)) // x^0\n                List(0L)\n            else if (x ==\
    \ 1L)\n                List(0L)\n            else\n                prev + x *\
    \ dp(prev, x - 1L)\n        }\n        dp(0L, xs!!(0L))", "        val result:\
    \ List[Long] = Nil\n        xs.foreach( x => result ::= x.toLong )\n        result.reverse",
  "        val x = List(xs.head)\n        var n = (1l.toLong)\n        val xn = x.map(_\
    \ * n)\n        val xn1 = xn.map(_ + n)\n        val xn2 = xn1.map(_ * n)\n  \
    \      val xn3 = xn2.map(_ + n)\n        val xn4 = xn3.map(_ * n)\n        val\
    \ xn5 = xn4.map(_ + n)\n        val xn6 = xn5.map(_ * n)\n        val xn7 = xn6.map(_\
    \ + n)\n        val xn8 = xn7.map(_ * n)\n        val xn9 = xn8.map(_ + n)\n \
    \       (xn9.toList ++ xn8.map(x => 2 * x))", "      val dCoeff = xs.tail.foldLeft(0.toLong){(a,b)\
    \ => a * x(b) + b}\n      val dCoeffs = dCoeff.zip(1 to xs.head - 1).map(x =>\
    \ x * dCoeff)\n      dCoeffs.reverse.tail", "        val newXs = new mutable.ListBuffer[Long]()\n\
    \        var j : Long = 1\n        for ( i <- xs.reverse) {\n            newXs\
    \ += (xs.size - i)\n            newXs += i\n        }\n        if (newXs.size\
    \ < 2) \n            xs\n        else\n            newXs.reverse.foldLeft(xs)\
    \ { case (newXs, x) => newXs + (x - newXs(xs.size - 1)) }", "        var i = 0\n\
    \        var j = 0\n        val ys = xs map (_ * (j - i))\n        var k = 0\n\
    \        var n = xs.size - 1\n        while(n>0) {\n            k += 1\n     \
    \       i += 1\n            j += 1\n        }\n        ys", "        val coeff\
    \ = xs.toArray.map(_.toLong).toArray\n        val poly = (coeff.length - 1) to\
    \ 1\n        val p = 1l to 0l\n        val p1 = coeff.slice(1, coeff.length -\
    \ 1)\n        val p2 = coeff.slice(0, 1)\n        val d = (p - 1) * p2.map(x =>\
    \ x * p1 - coeff(0)).toArray\n        d ++ poly", "        var x0 : Long = xs(0)\n\
    \        var x1 : Long = xs(1)\n        var x2 : Long = xs(2)\n        var x3\
    \ : Long = xs(3)\n        var ys : List[Long] = Nil\n        var count : Int =\
    \ -1\n        var i : Long = -1\n\n        while(count < xs.size) {\n        \
    \    i = i + 1\n            var xi : Long = xs(i) * x0 + x1 * x1 + x2 * x2 + x3\
    \ * x3\n            x0 = xi\n            x1 = xi\n            x2 = xi\n      \
    \      x3 = xi\n            ys = ys ::: List(count).toList\n            count\
    \ = count + 1\n        }\n        ys", "        var ret = 0\n        var temp\
    \ = 0\n        xs.foreach(x => ret = ret * x + temp)\n        temp = 1\n     \
    \   ret :: xs.reverse.foreach(x => temp = temp * x)\n        xs.reverse.tail.reverse.foreach(x\
    \ => temp = temp * x)\n        return ret.toList", "        assert(xs.nonEmpty,\
    \ \"List of coefficients can't be empty.\")\n        if (xs.head == 0) {\n   \
    \         xs.tail.map(_.toLong).reverse\n        }\n        else {\n         \
    \   xs.tail.map(x => x * xs.head + derivative(xs.tail))\n        }", "       \
    \ xs match {\n            case Nil => Nil\n            case x :: xs => List(1l\
    \ +  x * x * xs.sum,\n                              2l +  x * x * xs.sum,\n  \
    \                            3l +  x * x * xs.sum,\n                         \
    \     4l +  x * x * xs.sum,\n                              5l +  x * x * xs.sum,\n\
    \                              6l +  x * x * xs.sum,\n                       \
    \       7l +  x * x * xs.sum,\n                              8l +  x * x * xs.sum,\n\
    \                              9l +  x * x * xs.sum,\n                       \
    \       10l +  x * x * xs.sum)\n        }", "        var x : Long = 0\n      \
    \  var ys: List[Long] = Nil\n        xs.foreach { e => \n            x += 1\n\
    \            ys = ys :+ x * e\n        }\n        ys", "        def diff(xs :\
    \ List[Long], acc : List[Long]) : List[Long] = {\n            if (xs.isEmpty)\
    \ {\n                acc\n            } else {\n                val x = xs.head\n\
    \                xs.tail.map(v => diff (xs.tail :: v :: acc, v :: acc))\n    \
    \        }\n        }\n        diff(xs, List()).reverse", "        var result\
    \ : List[Long] = xs.clone\n        val size    = xs.size\n        val start  \
    \ = size - 1\n        for (i<-start...0) result = xs.slice(0, i) + xs.slice(i+1)\
    \ * result + xs.slice(i+2) * result.map(_ * _) + xs.slice(i+3) * result.map(_\
    \ * _ * _) + xs.slice(i+4) * result.map(_ * _ * _ * _) + xs.slice(i+5) * result.map(_\
    \ * _ * _ * _ * _)\n        result", "        // Find the derivative of a polynomial\
    \ using Newton-Raphson method.\n        var x = xs(0)\n        var f = xs(1)\n\
    \        var i = 0\n        while (true) {\n            x -= f / Math.pow(xs(i),\
    \ xs(0))\n            i += 1\n            if (Math.abs(x) < 1e-10) break;\n  \
    \      }\n        List(x)", "        if (List(xs.length).isEmpty) Nil\n      \
    \  val result = new Array[Long](xs.length + 1)\n        result(0) = 1\n      \
    \  // Compute nth derivative\n        for (n<-xs.length to 1) result(n) = result(n-xs.length)\
    \ * xs(n)/(xs(n-1) * xs(n-xs.length))\n        result", "        val ys = xs.map\
    \ { x => x * x }\n        // xs contains coefficients of a polynomial. Evaluate\
    \ derivative\n        // of polynomial using Horner's method.\n        ys.reverse.map\
    \ { y => xs.last * y }.sum", "        val ds : List[Long] = Nil\n        for(i\
    \ <- 0 until xs.size) {\n            val x = xs(i)\n            xs zip (xs drop\
    \ i) foreach { case (x,y) => ds ::= x * y}\n        }\n        ds", "        def\
    \ derivative(xs: List[Long], prevCoefficients: List[Long]) : List[Long] = {\n\
    \            val result = xs.head :: prevCoefficients\n            result :: xs.tail.map(x\
    \ => x * result(0))\n        }\n        xs match {\n            case Nil => Nil\n\
    \            case head :: tail =>\n                val coefficients = head ::\
    \ tail\n                derivative(tail, coefficients)\n        }", "        //\
    \ The derivative of 0th term is 0\n        if(xs.size == 1) Nil else if (xs.size\
    \ == 0) Nil\n        else {\n            // Use xs[0] as starting point.\n   \
    \         var x0 = xs.head\n            var xd = x0\n\n            // Iterate\
    \ over remaining terms.\n            xs ::: for {\n                x <- xs\n \
    \               dx <- dx + (x.toLong * xd) * (1l / x)\n                xd <- dx\n\
    \            }\n\n            xd\n        }", "        if (xs.isEmpty) List(1L)\n\
    \        else {\n            def helper(xs: List[Long], acc : Long) : List[Long]\
    \ = (xs.isEmpty) ? acc : helper(xs.tail, acc + (xs.head * xs.last))\n        \
    \    helper(xs, 1L)\n        }", "        var n = 1L\n        var n2 = 1L\n  \
    \      var n3 = 0L\n        var xs2 = xs\n        var dList: List[Long] = Nil\n\
    \        for( i <- xs.indices(xs.last) + 1 to xs.length){\n            n3 = n\
    \ * xs(i)\n            n2 = n2 * xs(i)\n            n = (n + n2) / n3\n      \
    \      dList = n3 :: dList\n        }\n        return dList.reverse", "      \
    \  val n = xs.size\n        if (n == 0) Nil\n        else (1 to n-1).flatMap {\
    \ n =>\n            xs.init\n            .scanLeft(Nil: List[Long]){ (res, x)\
    \ =>\n                x :: res\n            }\n            .take(n).reverse\n\
    \            .foldLeft(List[Long]()){ (res, x) =>\n                xs map (x ->\
    \ _)\n                res.init ++ List(x -> res.last._2 :+ res.last._1 -> res.last._3)\n\
    \            }\n        }", "        var x = 1\n        var der = 0\n        val\
    \ xl = xs.asInstanceOf[List[Long]]\n        val n = xl.length\n        while (xl\
    \ ne Nil) {\n            der = xl diff der\n            xl diff der\n        \
    \    x = x * x - x\n        }\n        xl.toList", "        if(xs.isEmpty) {\n\
    \            List[Long]()\n        }\n        if(xs.head == 1l.toLong) {\n   \
    \         List[Long](xs.tail)\n        }\n        else {\n            val result\
    \ = new mutable.ListBuffer[Long](xs.head + 2l.toLong)\n            for(i: Int\
    \ <- 1 until xs.size) {\n                result.add(xs(i) + 2l.toLong * result.last)\n\
    \            }\n            result\n        }", "        xs match {\n        \
    \    case Nil => Nil\n            case (x0 :: x1 :: xs :: Nil) => List(1l.toLong,\
    \ x1 * derivative(xs))\n            case (x0 :: x1 :: x2 :: xs :: Nil) => List(1l.toLong,\
    \ x1 * x2 + x2 * derivative(xs))\n            case (x0 :: x1 :: x2 :: x3 :: xs\
    \ :: Nil) => List(1l.toLong, x1 * x2 + x2 * x3 + x3 * derivative(xs))\n      \
    \      case (x0 :: x1 :: x2 :: x3 :: x4 :: xs :: Nil) => List(1l.toLong, x1 *\
    \ x2 + x2 * x3 + x3 * x4 + x4 * derivative(xs))\n            case (x0 :: x1 ::\
    \ x2 :: x3 :: x4 :: x5 :: xs :: Nil) => List(1l.toLong, x1 * x2 + x2 * x3 + x3\
    \ * x4 + x4 * x5 + x5 * derivative(xs))\n            case (x0 :: x1 :: x2 :: x3\
    \ :: x4 :: x5 :: x6 :: xs :: Nil) => List(1l.toLong, x1 * x2 + x2 * x3 + x3 *\
    \ x4 + x4 * x5 + x5 * x6 + x6 * derivative(xs))\n            case (x0 :: x1 ::\
    \ x2 :: x3 :: x4 :: x5 :: x6 :: x7 :: xs :: Nil) => List(1l.toLong, x1 * x2 +\
    \ x2 * x3 + x3 * x4 + x4 * x5 + x5 * x6 + x6 * x7 + x7 * derivative(xs))\n   \
    \         case (x0 :: x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: x7 :: x8 :: xs :: Nil)\
    \ => List(1l.toLong, x1 * x2 + x2 * x3 + x3 * x4 + x4 * x5 + x5 * x6 + x6 * x7\
    \ + x7 * x8 + x8 * derivative(xs))\n            case (x0 :: x1 :: x2 :: x3 ::\
    \ x4 :: x5 :: x6 :: x7 :: x8 :: x9 :: xs :: Nil) => List(1l.toLong, x1 * x2 +\
    \ x2 * x3 + x3 * x4 + x4 * x5 + x5 * x6 + x6 * x7 + x7 * x8 + x8 * x9 + x9 * derivative(xs))\n\
    \            case (x0 :: ", "      def new(xs : List[Long], result : List[Long],\
    \ i : Int, coeff : Long) : List[Long] = {\n          def new(xs : List[Long],\
    \ result : List[Long], i : Int, coeff : Long) : List[Long] =\n            if (i\
    \ == xs.size - 1) {\n              result ::: List(coeff * xs(i).toLong)\n   \
    \         } else {\n              new(xs, result :+ coeff * xs(i).toLong, i+1,\
    \ xs(i+1).toLong)\n            }\n          new(xs, result, i, coeff)\n      }\n\
    \      new(xs, Nil, 0, 1)", "        // Find highest power of x that is a multiple\
    \ of 2.\n        // If xs[2] not multiple of 2, then return zero list.\n     \
    \   // If xs[2] == 0, then return all 1.\n        val pow2 : Long = xs.filter(x\
    \ => x == 0l).toList.max\n        var res: List[Long] = List[Long]()\n       \
    \ xs.filter(x => x % 2l).foreach { x =>\n            xs.filter(x => x == 0l).foreach\
    \ { y =>\n                if (x == y) {\n                    val powerOfTwo =\
    \ pow2\n                    res :+= pow2l * (pow2l - 1) * 2l\n               \
    \ } else {\n                    if (y != 0l) {\n                        pow2l\
    \ -= 1\n                        pow2 -= 1\n                    }\n           \
    \     }\n            }\n        }\n        res", "        // First compute number\
    \ of terms.\n        val termsCount = xs.length - 1\n        // If termsCount\
    \ is even, we have an uneven polynomial.\n        if (termsCount % 2 == 0) {\n\
    \            // Compute and return the value of the first term alone.\n      \
    \      val x = xs(0)\n            val dydx = 0l\n            for (i <- 0 until\
    \ termsCount / 2)\n                dydx += (2 * xs(i + 1) - xs(i)) * x\n     \
    \       List(dydx)\n        }\n        else {\n            // Compute and return\
    \ the value of the first term and the\n            // value of the second term.\n\
    \            val x = xs(0)\n            val dy = xs(1)\n            val dydx =\
    \ 0l\n            for (i <- 0 until termsCount / 2)\n                dydx += (2\
    \ * xs(i + 2) - xs(i + 1)) * x\n            List(dy, dydx)\n        }", "    \
    \    val a = xs.tail\n        val b = xs.tail.tail\n\n        val nx = a.size\n\
    \n        val dx = new Array[Long](3 * nx)\n\n        for (i <- 0 until nx) {\n\
    \            val d = xs.head\n            val a = a(i - 1)\n            val b\
    \ = b(i - 1)\n            dx(3 * i) = d * (b + xs.last)\n        }\n        dx",
  "        val n = xs.size\n        if (n < 1) {\n            return Nil\n       \
    \ }\n        val n = xs.size\n        val d = (xs zip xs').toList.map { case (x,\
    \ y) => x * y }\n        (0 until n -1)\n            .filter(i => d.take(i + 1).sum\
    \ >= d.take(i).sum)\n            .map(i => d.drop(i).sum)", "        xs.foldLeft(List[Long](xs.head.toLong))\
    \ {\n            (acc, x) => acc :+ acc.last * x + acc.last * x\n        }", " \
    \       val ncoeff = xs.size\n        val dcoeff = xs.size\n        val d = 0\n\
    \        val p = new ListBuffer(1)\n        for ((i <- 0 until ncoeff)) {\n  \
    \          d += xs(i) * dcoeff\n            p.append(d)\n        }\n        p.toList",
  "        val ys = xs.reverse.tail\n        ys.foldRight(List.empty[Long])((ya, yb)\
    \ => yb * ya) reverse", "        val nx = xs.size // degree\n        val dx =\
    \  xs.last\n        val y = xs.init dropRight nx\n        val dx = xs.init dropRight\
    \ nx\n        val yx =\n            y.foldLeft((List.fill(ndx)(0l.toLong), List.fill(ndx)(0l.toLong))){\n\
    \                case ((xs, ys), x) => (xs.updated(ndx-1), ys.updated(ndx-1, x\
    \ * dx))\n            }\n        (y.reverse, yx.reverse)", "        require(xs.length\
    \ >= 1, \"xs must be >= 1\")\n        val n = xs.length\n        val result =\
    \ mutable.ArrayBuffer.empty[Long]\n        result.push(xs(n))\n        var i =\
    \ n - 1\n        while(i>0) {\n            result(i) = result(i + 1)\n       \
    \     i--\n        }\n        result", "        val n = xs.length\n        val\
    \ deriv = new mutable.ArrayList[Long](n)\n        for( i <- 0 to (n - 1) ) {\n\
    \            deriv(i) =  xs(i) * xs.drop(i + 1).sum\n        }\n        deriv",
  "        var dydx : List[Long] = Nil\n        var xprev = xs(0)\n        xs.drop(1).foreach\
    \ { x =>\n            val xx = xprev * x\n            dydx ::= xx\n          \
    \  xprev = x\n        }\n        (dydx ::: xs) // return derivative of (xprev\
    \ * x) for each x in xs", "        val n = xs.length\n        var dx :List[Long]\
    \ = List.fill(n - 1)(0.0).toList\n        var j = 0\n        while (j < n) {\n\
    \            val xx = xs.apply(j)\n            dx.apply(j) = -xx\n           \
    \ j += 1\n        }\n        dx", "        // Initialize variables\n        var\
    \ ys = List[Long]()\n        var y = 0\n        var i = 0\n\n        // Compute\
    \ value of y\n        for( _ <- 0 until xs.size ) {\n            y += xs(i)\n\
    \            i += 1\n        }\n\n        // Compute value of derivative of y\n\
    \        for( _ <- 0 until xs.size ) {\n            ys(i) = x * y\n          \
    \  i += 1\n        }\n\n        // Return values of derivative polynomial\n  \
    \      ys", "        var n = 1L\n        var d = 0L\n        for (i <- 0 until\
    \ xs.size) {\n            n = xs(i) * n\n            d = d + xs(i) * xs(i)\n \
    \       }\n        for (i <- 0 until xs.size) {\n            xs(i) * ((xs(i) -\
    \ d) / n)\n        }", "        var x = 1l\n        var n = 1\n        val result\
    \ = new mutable.ArrayBuffer[Long]()\n        while(x <= xs.last.toLong){\n   \
    \         result += xs.drop(n).scanLeft(x.toLong * n){(a,b) => a + b}\n      \
    \      n += 1\n            x += 1l\n        }\n        result.take(xs.last.toLong)",
  "        val n = xs.size\n        if (n == 0) {\n            Nil\n        } else\
    \ {\n            val x0 = xs.head\n            xs.tail.zipWithIndex.map { case\
    \ (x, i) => if (i != n-1) (x-(x0 * xs.tail.head)) else (x-x0) }\n        }", '        xs.reverse
    map {x => if (x == 1l.toLong) 0 else x * derivative(List(xs.tail)) }', "     \
    \   // The derivative is the sum of the products of the powers of the coefficients.\n\
    \        // xs[0] * (xs[1] * x + xs[2] * x^2 + ....)\n        var sum : Long =\
    \ 0\n        val xArray = xs.toArray\n        for( i <- 0 until xArray.length\
    \ )\n            sum += xArray(i) * xArray(i)\n        List(sum)", "        var\
    \ result : List[Long] = List()\n        val n = xs.size\n        val x2 = xs.last.pow(2)\n\
    \        for(i <- 0 until n-1 ) {\n            // calculate derivative\n     \
    \       val dx2 = (xs(i) - xs(i+1)) / (xs(i+1) + xs(i))\n            result +=\
    \ List(dx2)\n        }\n        result", "        xs match {\n            case\
    \ head :: tail =>\n                val d = tail.foldLeft(head.toLong)((r, c) =>\
    \ r + c * Math.pow(x, 2))\n                List(d)\n            case Nil => List()\n\
    \        }", "        if (xs.size == 0) List(1l.toLong).reverse\n        else\
    \ {\n            val (l0, l1) = xs.unzip\n            (1l.toLong, 4l.toLong *\
    \ l1 + l0 * l1.product).toList\n        }", "      def loop(xs1 : List[Long],\
    \ xs2 : List[Long], sum : List[Long], i : Int) : List[Long] = {\n        if (i\
    \ == 0) {\n          sum\n        } else {\n          loop(xs2, xs1 :+ xs2.head,\
    \ sum :+ xs2.last / (xs2.head - xs2.last), i - 1)\n        }\n      }\n      loop(xs,\
    \ Nil, Nil, 0)", "        def getDerivative(x : Long, p : List[Long], acc : List[Long])\
    \ : List[Long] = {\n            if(p == Nil)\n                acc\n          \
    \  else\n                getDerivative(xs.last, p::(acc.last * x), acc::acc)\n\
    \        }\n        getDerivative(xs.last, Nil, Nil)", "        var sum = 0\n\
    \        var tmp = 0\n        var tmp2 = 0\n        var i = 0\n        val newXs\
    \ = List(xs.tail, xs.head)\n        for (x0 <- newXs)\n            tmp2 += x0\n\
    \        tmp += tmp2 * tmp2\n        val x1 = newXs.head\n        for (x1 <- newXs.tail)\
    \ {\n            tmp2 += x1\n            tmp += x0 * x0 * x1\n        }\n    \
    \    val x1 = newXs.head\n        for (x1 <- newXs.tail) {\n            tmp2 +=\
    \ x1\n            tmp += x1 * x1\n        }\n        val x1 = newXs.head\n   \
    \     for (x1 <- newXs.tail) {\n            tmp2 += x1\n            tmp += x1\n\
    \        }\n        val x1 = newXs.head\n        for (x1 <- newXs.tail) {\n  \
    \          tmp += x1\n        }\n        val x1 = newXs.head\n        for (x1\
    \ <- newXs.tail) {\n            sum += x1\n        }\n        sum", "      val\
    \ n  = xs.size\n      var d  = 0\n      var dp = xs\n      for(i <- 0 until n-1)\n\
    \        d += xp(i) * xp(i+1)\n      dp += List(1l to  d, 0 until n - 1 to  d,\
    \ -1 to n)", "        if (xs.isEmpty) Nil\n        else {\n            val first\
    \ = List(xs(0).toLong)\n            val rest = derivative(xs.drop(1))\n      \
    \      rest ::: List((first - rest).product)\n        }", "        var result\
    \ = List(xs.reverse.tail.sum)\n        result ::= xs.reverse.tail.init\n     \
    \   result", "        if(!xs.isEmpty) {\n            var ret: List[Long] = Nil\n\
    \            val l = xs.head\n            val a = xs.tail\n            var j:\
    \ Long = 0\n            for(i <- 0 until a.size) {\n                ret :+= a(i)\n\
    \                for(k <- 0 until j + 1) {\n                    ret :+= a(i) *\
    \ xs(j - k + 1)\n                }\n                j += 1\n            }\n  \
    \          ret\n        }\n        else {\n            Nil\n        }", "    \
    \    require(xs.size == 3)\n        xs.foldLeft(List[Long](1l.toLong, 2l.toLong))((a,c)\
    \ => {\n            val p = new Long\n            a :+ (c.toLong * p)\n      \
    \  })", "        val result = new ListBuffer[Long]()\n        val d = xs.head\
    \ - xs.last\n        result.add(xs.last)\n        result.add(xs.last * d)\n  \
    \      result.add(xs.last * (d * d))\n        result.add(xs.last * (d * d * d))\n\
    \        result.toList", "        val dxs = new mutable.ListBuffer[Long](xs.size+1)\n\
    \        dxs.update(0, 1l)\n        for (ix <- 1 to xs.size) {\n            dxs(ix)\
    \ *= ix\n            for (ix <- ix + 1 to xs.size) {\n                dxs(ix)\
    \ += xs(ix) * dxs(ix-1)\n            }\n        }\n        dxs.toList", "    \
    \    require(xs.length == 1)\n        val result = xs.map(x => 1l).reverse\n \
    \       var xx = xs.head\n        xx -= 1\n        var y = xs\n        y -= 1\n\
    \        while (y > 0) {\n            x = xx\n            xx -= 1\n          \
    \  x += 1\n            y -= 1\n            result += xs.map(x => x.toLong).map(x\
    \ => x * y)\n        }\n        result", "        val result: List[Long] = Nil\n\
    \        for( x <- xs ) {\n            if( x != 0 ) {\n                result\
    \ += List(-x, xs.tail.sum / x)\n            }\n        }\n        result", " \
    \       val n = xs.length\n        if (n != 2)\n            throw new RuntimeException(\"\
    Only two values are supported.\")\n        val p = xs(0) * xs(1) + xs(0)\n   \
    \     xs.drop(1).map((xs(0) * (xs(1) + p))).toList", "        var d = xs.init.reverse\n\
    \        val n = d.size\n        var d = d.init.reverse\n\n        // If n is\
    \ even, multiply all even by -1\n        if(n % 2 == 0) {\n            d = d.map{x\
    \ => -x }\n        }\n        var x = 0\n        var y = 1\n        var z = 2\n\
    \        var d = d.reverse\n        for(i <- 0 until n) {\n            x += (y\
    \ * d(i))\n            y *= z\n            z *= x\n        }\n        d = d.reverse\n\
    \        x", "        val n = xs.size\n        if (n < 2) xs\n        else xs.zip(0\
    \ until n).map(x => (x._2 - x._1) * x._1) :+ xs", "        var y = xs(0)\n   \
    \     val result = Nil\n        for (n in 1 until xs.size) {\n            y *=\
    \ xs(n)\n            val dY = (y).toLong - xs(n - 1).toLong\n            result\
    \ :+= dY\n        }\n        result.reverse", "        val result = new mutable.ListBuffer[Long]\n\
    \        val a = xs\n        var i = a.length - 1\n        while (i > 0) {\n \
    \           result.append((xs(i) - xs(i - 1)) * (a.size - i).abs)\n          \
    \  i -= 1\n        }\n        result.reverse", "        // We add zero and last\
    \ element to xs\n        // to create a list of coefficients from zero to last.\n\
    \        // Then we add first element and last element to each other.\n      \
    \  // xs + 0\n        // xs + last\n        val xs_0 : List[Long] = xs.copy(0l,\
    \ xs.last)\n        val xs_last : List[Long] = xs.copy(xs.first, xs.last)\n  \
    \      // xs_0 + xs_last\n        val result : List[Long] = xs_0 + xs_last\n \
    \       result", "        var x = 0l\n        var dy = 1l\n        var p = 0\n\
    \        var n = 0\n        var d = 0\n        var sum = 0l\n\n        while(xs.tail.isEmpty){\n\
    \            x += 1l\n            y = xs.head * x\n            sum += y\n    \
    \        n += 1l\n            p += 1l\n            d += 1l\n\n            if(d\
    \ == 1){\n                x = 0l\n            }\n        }\n\n        dy = (xs.head\
    \ - sum) / n\n\n        xs.take(n).drop(n).reverse.map{x => x * dy}", "      \
    \  // First derivative is the same as second derivative.\n        // Second derivative\
    \ is the product of 2nd-degree polynomials.\n        // We multiply all the polynomials\
    \ by 2 first derivatives.\n        // This way we can solve the polynomial equation\
    \ for 2nd-degree polynomial.\n        // xs.head * 2\n        // xs.tail.map(x\
    \ => (xs.head * 2 * x) ++ xs.tail)\n        // 2 * xs.tail.map(x => 2 * x)\n \
    \       xs.tail.map(x => (2 * x) ++ xs.tail)", "        if (xs.length <= 1l) Nil\n\
    \        else {\n            def f(x: Long, y : List[Long]) : List[Long] = if\
    \ (y == Nil) Nil else {\n                if (x == 0l) y :: else y :+ f(x-1l, f(x\
    \ - 1l, y))\n            }\n            f(0l, xs)\n        }", "        var ys\
    \ = xs.drop(1)\n        ys.foldLeft(ys.head)(_ + _ * ys.head)", "        var x0\
    \ = xs.head\n        var x1 = xs.tail.head\n        var x2 = xs.tail.tail.head\n\
    \        var x3 = xs.tail.tail.tail.head\n        var x4 = xs.tail.tail.tail.tail.head\n\
    \        var x5 = xs.tail.tail.tail.tail.tail.head\n        var x6 = xs.tail.tail.tail.tail.tail.tail.head\n\
    \        xs.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.",
  "        var n = 0\n        var dx = 0L\n        var i = 0\n        while ( i <\
    \ xs.size ) {\n            if ( n != xs.size - 1 ) {\n                dx = (xs(i\
    \ + 1) * x(n)) - (xs(i) * x(i + 1))\n            }\n            n += 1\n     \
    \       i += 1\n        }\n        if ( n == xs.size ) {\n            dx\n   \
    \     } else {\n            throw new RuntimeException(\"xs contains more values\
    \ than are present in the derivative\")\n        }", "        val (x1, x2, x3,\
    \ x4, x5) = xs.span(_ < 0)\n        var dx1 = 0\n        var dx2 = 0\n       \
    \ var dx3 = 0\n        var dx4 = 0\n        var dx5 = 0\n        if (x1.nonEmpty)\
    \ {\n            val x12 = x1.head + x2.head * x1.head + x3.head * x1.head * x2.head\
    \ + x4.head * x1.head * x2.head * x3.head + x5.head * x1.head * x2.head * x3.head\
    \ * x4.head\n            var dx1 = 0\n            var dx2 = 0\n            var\
    \ dx3 = 0\n            var dx4 = 0\n            var dx5 = 0\n            var dx6\
    \ = 1\n            if ((x12 > 0L) && (x12 < (1L.toLong + 2L.toLong))) {\n    \
    \            var dx2 = 0\n                var dx3 = 0\n                var dx4\
    \ = 0\n                var dx5 = 0\n                var dx6 = 1\n            \
    \    if ((x12 > 0L) && (x12 < (2L.toLong + 3L.toLong))) {\n                  \
    \  var dx3 = 0\n                    var dx4 = 0\n                    var dx5 =\
    \ 0\n                    var dx6 = 1\n                    if ((x12 > 0L) && (x12\
    \ < (3L.toLong + 4L.toLong))) {\n                        var dx4 = 0\n       \
    \                 var dx5 = 0\n                        var dx6 = 1\n         \
    \               if ((x12 > 0L) && (x12 < (4L.toLong + 5L.toLong))) {\n       \
    \                     var dx5 = 0\n                            var dx6 = 1\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }\n        if (x2.nonEmpty) {\n            val x22 = x2.head +\
    \ x3.head * x2.head + x4.head * x2.head * x3.head + x5.head * x2.head * x3.head\
    \ * x4.head\n            var dx1 = 0\n            var dx2 = 0\n            var\
    \ dx3 = 0\n            var dx4 = 0\n            var dx5 = 0\n            var dx6\
    \ = 1\n            if ((x22 > 0L) && (x22 < (1L.toLong + 2L.toLong))) {\n    \
    \            var dx2 = 0\n                var dx3 = 0\n                var dx4\
    \ = 0\n                var dx5 = 0\n                var dx6 = 1\n            \
    \    if ((x22 > 0L) && (x22 < (2L.toLong + 3L.toLong))) {\n                  \
    \  var dx3 = 0\n                    var dx4 = 0\n                    var dx5 =\
    \ 0\n                    var dx6 = 1\n                    if ((x22 > 0L) && (x22\
    \ < (3L.toLong + 4L.toLong))) {\n", "        // Base case: No derivatives\n  \
    \      if (xs.isEmpty) return xs\n        \n        // Recursive case\n      \
    \  // Derive the polynomial before the first coefficient\n        val (coeff,\
    \ tail) = xs.span(_ > 0)\n        \n        // Start with last coefficient as\
    \ initial value\n        val (der, tail2) = tail.span(_ != 0)\n        \n    \
    \    // Calculate derivative by recursion\n        // Derivative is (value - initial\
    \ value) * coefficient + der\n        for {\n            value <- tail\n     \
    \       initial <- coeff\n        } yield (value - initial) * der + der", "  \
    \      def recurse(xs : List[Long], acc : List[Long]) : List[Long] = {\n     \
    \       val x = acc.last\n            if(xs.isEmpty) acc\n            else {\n\
    \                val x0 = xs.head\n                xs.tail match {\n         \
    \           case Nil => acc\n                    case h::t => recurse(t,List(x0\
    \ +* h) :: acc)\n                }\n            }\n        }\n        recurse(xs,Nil)",
  "        if (xs.size == 0)\n            Nil\n        else {\n            val p =\
    \ xs.tail\n            val q = xs.take(p.size)\n            val p1 = p.map(x =>\
    \ x*x)\n            val p2 = p.zip(q).map(p => p._1*p._2)\n            p1 :+ p2\
    \ :+ p.map(x => x*x.toDouble)\n        }", "        var result : List[Long] =\
    \ Nil\n        var x = 1\n        for (i <- 0 until xs.size) {\n            x\
    \ += 1\n            result += List(xs.size - i - 1, x)\n        }\n        result.reverse",
  "        // xs: coefficient x of first order (highest degree).\n        // xs: coefficient\
    \ x of second order (second highest degree).\n        // ...\n        // xs: coefficient\
    \ x of n order (n-1 highest degree).\n        // xs: coefficient of highest degree.\n\
    \        // Return derivative of this polynomial in the same form.\n        val\
    \ xs_pow = pow(xs, 0)\n        val xs_pow_pow_2 = pow(xs_pow, 1)\n        val\
    \ xs_pow_pow_2_2 = pow(xs_pow_pow_2, 2)\n        // ...\n        // xs: coefficient\
    \ of n highest degree.\n        // xs: coefficient of n-1 highest degree.\n  \
    \      // Return derivative of this polynomial in the same form.\n        val\
    \ xs_pow_pow_n = pow(xs_pow_pow_2, n)\n        xs_pow_pow_n", "        xs.reverse.foldRight(xs.reverse.map(x\
    \ => 2 * x)) {\n          case ((xs, y) => y + (xs.head * y))\n        }.reverse",
  "        def dy(x : Long, y : Long) = x * y + xs.reverse.drop(1).sum\n        List(1l).init\
    \ ++ xs.drop(1).map { x =>\n            val res = y\n            val ys = xs.takeWhile(_\
    \ <= x).zipWithIndex.filter(_._2 > x).map { case (ys, i) => (ys, i) }\n      \
    \      for ((ys, i) => res + (dy(x, ys)) -> (ys zip ys).foldLeft(0l)(_ + _))\n\
    \        }", "        xs.foldLeft(List.empty[Long]) { (xs, coeff) => \n      \
    \      coeff :: (xs.drop(1).map(x => x * (x.toLong + coeff.toLong))) }", "   \
    \     var dydxs : List[Long] = Nil\n        var x       = 0\n        val len \
    \   = xs.length\n        var pow     = 0\n        for(x <- 0 until len){\n   \
    \         pow = xs.apply(x)\n            dydxs = dydxs.drop(1) + pow\n       \
    \ }\n        pow", "        if (xs.isEmpty) Nil\n        else xs.head :: derivative(xs.tail)",
  "        var deriv = xs.tail\n        var last = deriv.last\n        var power =\
    \ 0\n        for( i <- deriv.indices) {\n            power = power + deriv(i)\n\
    \            deriv(i) -= last * power\n            last = power\n            power\
    \ = 0\n        }\n        deriv", "        val N = len(xs)\n        xs match {\n\
    \            case Nil => List()\n            case x::xs => xs.zipWithIndex.map\
    \ { case (x, i) => x * (i - 1) }\n        }", "        var n = 1\n        var\
    \ d = 0\n        val poly = xs.toList.map(x => d * x).toList\n        poly.reverse.zipWithIndex.foreach\
    \ { case (d,i) => d = i * n; n = n * xs(i); poly.push(d)}\n        poly.reverse",
  "        // Get number of terms.\n        val terms = xs.size\n        // Use first\
    \ term as the constant.\n        val constant = xs.head\n\n        // Create empty\
    \ list of coefficients.\n        val coefficients = List.fill(terms)(constant)\n\
    \n        // Loop through the rest of the terms.\n        for(i <- 1 until terms)\
    \ {\n            // Calculate ith term of derivative.\n            val term =\
    \ xs(i)\n            // Add ith term to coefficient.\n            coefficients(i)\
    \ = term * coefficients(i - 1)\n        }\n\n        // Return new list of coefficients.\n\
    \        coefficients", "        val size = xs.size\n        var d1 : List[Long]\
    \ = Nil\n        var d2 : List[Long] = Nil\n        var i : Int = 0\n        while\
    \ (i < size) {\n            if (i == 0) {\n                d1 :+= xs(i)\n    \
    \        }\n            i -= 1\n            if (i == 1) {\n                d2\
    \ :+= xs(i)\n            }\n            i -= 1\n        }\n        if (size !=\
    \ 0) {\n            var x = xs(size - 1)\n            var y = xs(size - 2)\n \
    \           for (i = size - 3; i >= 0; i -= 1) {\n                var m = xs(i)\
    \ * x\n                if (i != 0) {\n                    m = m + xs(i - 1)\n\
    \                }\n                x = y\n                y = y\n           \
    \     xs(i) =- m\n            }\n        }\n        (d1, d2)", "        xs.zip(ys).zip(xs.tail).map\
    \ {\n            case ((x1, x2), y) => y*(2*x1 - x2)\n        }", "        xs.reverse.foldLeft(List[Long]())((acc:\
    \ List[Long], x: Long) => {\n            val x2 = x.toDouble\n            acc\
    \ :+ x2\n            acc.reverse :: acc\n        })", "        def new(xs: List[Long],\
    \ x: Long, y: Long) : List[Long] =\n            if (x == 0) Nil\n            else\
    \ (xs match {\n                case head :: tail if head == x => new(xs.tail,\
    \ x, y + head);\n                case head :: tail => new(xs.tail, head * y, y\
    \ + head);\n                case Nil => Nil\n            }) \n        new(xs,\
    \ 0l, 1l) match {\n            case Nil => Nil\n            case head :: tail\
    \ => head :: tail.map(x => new(xs, x, 1l))\n        }", "        // Calculate\
    \ first derivative\n        var d1 : List[Long] = Nil\n        var x = 0\n   \
    \     while (x < xs.size - 1) {\n            d1 ::= (xs.head * x) + xs.tail.tail.head\n\
    \            x += 1\n        }\n        d1 ::= (xs.head * x)\n        val d1 =\
    \ d1 ::: d1 map { x => x*x }\n\n        // Calculate second derivative\n     \
    \   var d2 : List[Long] = Nil\n        var x1 = d1(0)\n        var x2 = d1(1)\n\
    \        while (x < d1 size -1) {\n            d2 ::= (x1 * x) + d1(x + 1)\n \
    \           x1 = x2\n            x2 = d2(1)\n            x += 1\n        }\n \
    \       d2 ::= (x1 * x)\n\n        // Return list with first and second derivatives\n\
    \        d1 ::: d2", "        // Get number of coefficients, i.e. degree of polynomial\n\
    \        var degree : Int = xs.size\n        val polyLength = degree\n       \
    \ // Copy xs into a buffer before we start appending new coefficients.\n     \
    \   val buffer = new mutable.MutableList[Long]()\n        for(i <- 0 until polyLength)\
    \ {\n            buffer.append(xs(i).toLong)\n        }\n        // Initialize\
    \ first derivative as 1. To do this, we add polynomial (1) to buffer and store\
    \ in buffer\n        var sum: Long = 1\n        for(i <- 0 until polyLength -\
    \ 1) {\n            buffer.append((buffer.head * sum).toLong)\n            sum\
    \ = sum * xs(polyLength - i - 1).toLong\n        }\n        // Return copy of\
    \ buffer\n        buffer.toList", "        val n = xs.length - 1\n        val\
    \ d = new ListBuffer[Long](n)\n        var i = 0\n        while (i < n) {\n  \
    \          val f = xs(i) * xs(i+1) - xs(i)\n            d += f\n            i\
    \ += 1\n        }\n        d(0)", "        xs match {\n            case Nil =>\
    \ Nil\n            case x::xs => \n                val x0 = xs.head\n        \
    \        val x1 = xs.last\n                val xSum = x0 + x1\n              \
    \  val n = xSum.asInstanceOf[Int]\n                val xDer = (n-1) / (n+1)\n\
    \                xSum.asInstanceOf[List[Long]](xs.init, xDer.toLong)\n       \
    \ }", "        val n = xs.length\n        var result : List[Long] = Nil\n    \
    \    var i = 0\n        while (i < n) {\n            result ::= xs.head * xs.tail.head\
    \ + xs.tail.tail\n            i += 1\n        }\n        result", "        val\
    \ x0 = xs.head\n        val xs = xs.tail\n        val x1 = xs.head\n        val\
    \ x2 = xs.tail.head\n        val x3 = xs.tail.tail.head\n        xs.zip(List(1l,\
    \ x2 * x1 * x2 + x1 * x3)).filter(_._1 == 1).map(_._2).reverse", "        val\
    \ result = new mutable.ListBuffer[Long]()\n        val x = xs.head\n        var\
    \ j = xs.last\n        var i = 2\n        while (i != 0) {\n            val newCoefficient\
    \ = xs(j) * x\n            j += 1\n            result += newCoefficient\n    \
    \        i -= 1\n        }\n        return result", "        val newXs: List[Long]\
    \ = xs map { x => x * x }\n        xs zip (newXs).filter{ case (x, x) => x ==\
    \ 0l } map { case (x, y) => y }", "        val zero = List(1l)\n        val one\
    \ = List(xs.last)\n        val two = List(xs.init)\n        val three = List(xs.reverse\
    \ drop 1)\n        val four = List(xs.reverse drop 2)\n        val five = List(xs.reverse\
    \ drop 3)\n        val six = List(xs.reverse drop 4)\n        val seven = List(xs.reverse\
    \ drop 5)\n        val eight = List(xs.reverse drop 6)\n\n        val zero1 =\
    \ List(zeros.last)\n        val one1 = List(zeros.init)\n        val two1 = List(zeros.init.reverse)\n\
    \        val three1 = List(zeros.reverse.drop(1))\n        val four1 = List(zeros.reverse.drop(2))\n\
    \        val five1 = List(zeros.reverse.drop(3))\n        val six1 = List(zeros.reverse.drop(4))\n\
    \        val seven1 = List(zeros.reverse.drop(5))\n        val eight1 = List(zeros.reverse.drop(6))\n\
    \n        val zero2 = List(zeros.init.reverse.last)\n        val one2 = List(zeros.init.reverse.init)\n\
    \        val two2 = List(zeros.init.reverse.init.reverse)\n        val three2\
    \ = List(zeros.init.reverse.reverse.drop(1))\n        val four2 = List(zeros.init.reverse.reverse.drop(2))\n\
    \        val five2 = List(zeros.init.reverse.reverse.drop(3))\n        val six2\
    \ = List(zeros.init.reverse.reverse.drop(4))\n        val seven2 = List(zeros.init.reverse.reverse.drop(5))\n\
    \        val eight2 = List(zeros.init.reverse.reverse.drop(6))\n\n        val\
    \ zero3 = List(zeros.init.reverse.reverse.init.reverse.last)\n        val one3\
    \ = List(zeros.init.reverse.reverse.init.reverse.init)\n        val two3 = List(zeros.init.reverse.reverse.init.reverse.init.reverse)\n\
    \        val three3 = List(zeros.init.reverse.reverse.init.reverse.reverse.drop(1))\n\
    \        val four3 = List(zeros.init.reverse.reverse.init.reverse.drop(2))\n \
    \       val five3 = List(zeros.init.reverse.reverse.init.reverse.drop(3))\n  \
    \      val six3 = List(zeros.init.reverse.reverse.init.reverse.drop(4))\n    \
    \    val seven3 = List(zeros.init.reverse.reverse.init.reverse.drop(5))\n    \
    \    val eight3 = List(zeros.init.reverse.reverse.init.reverse.drop(6))\n\n  \
    \      val zero4 = List(zer", "        val newXs = xs.drop(1).tail.map(x => x\
    \ * x)\n        val newY = xs.head * xs.last\n        (newXs zip newY).map(x =>\
    \ x._1 + x._2)", "        val y = xs.sum\n        xs.init filter (_ != y) match\
    \ {\n            case List() => List()\n            case x :: xs => x * derivative(xs)\n\
    \        }", "        val nx = xs.length\n        val derivs = new Array[Long](nx)\n\
    \        var i = 0\n        while (i < nx) {\n            derivs(i) = xs(i+1)\n\
    \            i += 1\n        }\n        if (nx < 2) {\n            derivs(0)\n\
    \        } else {\n            derivs(0) = xs(1)\n            derivs(1) = xs(0)\n\
    \            for (i = 1; i < (nx - 1); i++) {\n                derivs(i) = derivs(i-1)\
    \ + (xs(i) * derivs(i-1))\n            }\n        }\n        derivs", "      \
    \  // xs is a polynomial which has at least two coefficients.\n        // Return\
    \ derivative of the polynomial at given xs.\n        // >>> derivative((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n        // (List[Long](2l.toLong, 6l.toLong))\n   \
    \     if(!xs.isEmpty) {\n            val n = xs.size - 1\n            val x =\
    \ xs(n)\n            val terms = xs.drop(n+1)\n            terms match {\n   \
    \             case Nil => Nil\n                case x :: Nil => Nil\n        \
    \        case x :: xs => xs.take(n).map(t => x*t).toList :: derivative(xs)\n \
    \           }\n        }\n        else {\n            Nil\n        }", "     \
    \   var result: List[Long] = Nil\n        // If xs is empty or contains only zeros,\
    \ return empty list\n        if(xs.isEmpty) result\n        else {\n         \
    \   // If xs contains only zeros, return xs with same length\n            if(xs.head\
    \ == 0) xs.tail.zip(Nil).map(x => x._2).reverse\n            else {\n        \
    \        // Compute coefficients of xs by adding xs[0] to each x\n           \
    \     // xs.tail.zip(Nil).map(x => x._1).reverse\n                // xs.tail.zip(Nil).map(xs\
    \ => xs.head + xs._2).reverse\n                result = xs.tail.zip(Nil).map(x\
    \ => x._1).reverse\n                // Compute coefficients of result by multiplying\
    \ each result by x\n                // result.map(x => x * xs.head).reverse\n\
    \                result = result.map(x => x * xs.head).reverse\n            }\n\
    \        }\n        return result", "        require(xs.length >= 2, s\"derivative\
    \ requires at least two coefficients\")\n        val (c0, c1) = xs.splitAt(1)\n\
    \        val n = c1.length\n        require(n == 1, c1.mkString(\",\") + \" not\
    \ a constant\")\n        require(c0.nonEmpty, xs.mkString(\",\") + \" not containing\
    \ at least one term\")\n        val x = xs.last\n        val x0 = xs.head\n  \
    \      val ys = c0.map(x => ((x0 - x) * x - x) / x)\n        y :: derivative(ys)",
  "        // Initialize derivative to zero.\n        val der = new ArrayList[Long](xs.length+1)\n\
    \        der(0) = 0\n\n        // Initialize and add up all the terms in the polynomial.\n\
    \        val terms = new mutable.LinkedHashSet[Long]\n        terms.add(xs(0).toLong)\n\
    \        for(i  <- 1 to xs.length-1) {\n            terms.add(xs(i).toLong + xs(i-1).toLong\
    \ * terms.last)\n        }\n\n        // Add up the derivatives.\n        val\
    \ d = 0\n        for(term <- terms){\n            d += term * der(xs.length)\n\
    \            der = xs.reverse map {x => d / x}\n        }\n\n        // Return\
    \ the result.\n        der", "        val n = xs.size\n        val dy = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        for (x <- 0 until n) {\n            val y = xs.sum\n            val dy_j\
    \ = scala.collection.mutable.ListBuffer.empty[Long]\n            if (y == 0) {\n\
    \                dy_j.append(1)\n            } else {\n                val k =\
    \ n - 1\n                for (j <- 0 until k) {\n                    if (j ==\
    \ 0 || dy_j(0) == 0) dy_j.append(0)\n                    else dy_j.append(dy_j(j-1)\
    \ / dy_j(j))\n                }\n                dy_j.reverse.head\n         \
    \   }\n            dy.append(dy_j.sum)\n        }\n        dy.reverse", "    \
    \    // TODO: Do something with the xs and return derivative.\n        val deriv\
    \ = xs match {\n            case Nil   => Nil\n            case head :: tail =>\
    \ head.toLong * derivative(tail)\n        }\n        return deriv", "        val\
    \ n  = xs.length\n        val dp = new Array[Long](n)\n        dp.foreach { x\
    \ => dp(n - 1) }\n        var x = 1\n        var y = 1\n        while(x < n) {\n\
    \            val term = xs(x)\n            if(term != 0) {\n                val\
    \ newX    = y * x\n                val newY    = y * y\n                val newTerm\
    \  = term * x\n                val newDp   = dp(x - 1)\n                val newDp1\
    \  = newDp + newTerm\n                val newDp2  = newDp1 - newTerm\n       \
    \         dp(x - 1) = newDp1\n                y = newY\n                x = newX\n\
    \            }\n        }\n        dp", "        val length = xs.size\n      \
    \  if(length == 0) {\n            return List.empty\n        }\n        val one\
    \ = xs(0)\n        val two = xs(1)\n        val three = xs(2)\n        if(length\
    \ == 1) {\n            return List(one - two)\n        }\n        val result =\
    \ xs.tail.foldLeft(new List[Long](one - two))((acc, next) => acc.zipWith(List.fill(next.length\
    \ - 1).map(_ * _) + List(next)))\n        result.map(a => a / three)", "     \
    \   // TODO: Implement this function\n        xs.zipWithIndex.map {\n        \
    \    case (x, i) =>\n                if (i == 0 || i == xs.size) {\n         \
    \           throw new Exception(\"not valid polynomial\")\n                }\n\
    \                (xs.size - i - 1) * xs.take(i + 1).sum\n        }", "      var\
    \ n = xs.length\n      if (n == 0) Nil\n      else {\n        val dxs = xs.scanLeft(0l)((x,acc)\
    \ => x.toLong + acc * x.toLong)\n        val res = new ListBuffer[Long]\n    \
    \    for (i <- 0 to xs.length-1) {\n          val dx = dxs(i)\n          res +=\
    \ xs(i) * dx\n          res += (dxs(i+1) - dx) * xs(i-1)\n        }\n        res.toList\n\
    \      }", "        require(xs.length >= 2)\n        val coeff = xs.tail\n   \
    \     val term = xs.head * coef.reverse\n        coef.reverse :+ term", "    \
    \    val n = xs.size\n        require(n == 0 || n == 1)\n\n        val first =\
    \ xs.head\n        val rest = xs.tail\n        var result: List[Long] = Nil\n\
    \        for (i<-0 until rest.length)\n        { \n            val x = rest(i)\n\
    \            var sum: Long = 0\n            for (i<-0 until n) \n            {\
    \ \n                val y = first * x(i) + sum\n                sum = y + xs(i)\n\
    \            }\n            result = result :+ sum\n        }\n        result",
  "        if(xs.length == 0)\n            List()\n        else\n            xs.tail.foldLeft(1l)\
    \ { (d, x) => d * x  }"]
stop_tokens:
- "\n    }\n"
