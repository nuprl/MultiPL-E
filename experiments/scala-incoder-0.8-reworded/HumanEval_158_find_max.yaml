name: HumanEval_158_find_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that accepts a list of strings.\n    // The list contains\
  \ different words. Return the word with maximum number\n    // of unique characters.\
  \ If multiple strings have maximum number of unique\n    // characters, return the\
  \ one which comes first in lexicographical order.\n    // >>> findMax((List[String](\"\
  name\", \"of\", \"string\")))\n    // (\"string\")\n    // >>> findMax((List[String](\"\
  name\", \"enam\", \"game\")))\n    // (\"enam\")\n    // >>> findMax((List[String](\"\
  aaaaaaa\", \"bb\", \"cc\")))\n    // (\"aaaaaaa\")\n    def findMax(words : List[String])\
  \ : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findMax((List[String](\"\
  name\", \"of\", \"string\"))).equals((\"string\")));\n    assert(findMax((List[String](\"\
  name\", \"enam\", \"game\"))).equals((\"enam\")));\n    assert(findMax((List[String](\"\
  aaaaaaa\", \"bb\", \"cc\"))).equals((\"aaaaaaa\")));\n    assert(findMax((List[String](\"\
  abc\", \"cba\"))).equals((\"abc\")));\n    assert(findMax((List[String](\"play\"\
  , \"this\", \"game\", \"of\", \"footbott\"))).equals((\"footbott\")));\n    assert(findMax((List[String](\"\
  we\", \"are\", \"gonna\", \"rock\"))).equals((\"gonna\")));\n    assert(findMax((List[String](\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"))).equals((\"nation\")));\n    assert(findMax((List[String](\"\
  this\", \"is\", \"a\", \"prrk\"))).equals((\"this\")));\n    assert(findMax((List[String](\"\
  b\"))).equals((\"b\")));\n    assert(findMax((List[String](\"play\", \"play\", \"\
  play\"))).equals((\"play\")));\n    }\n\n}\n"
completions: ["        var maxCount = words.map(_.length).max\n        var maxString\
    \ = \"\"\n        var maxCountIndex = 0\n        var curString = \"\"\n      \
    \  var curCount = 0\n\n        for (word <- words) {\n            val count =\
    \ word.count(_ != \" \")\n\n            if (maxCount > count) {\n            \
    \    maxCount = count\n                maxString = \"\"\n                maxCountIndex\
    \ = 0\n            } else if (maxCount == count) {\n                if (maxCountIndex\
    \ < words.length - 1) {\n                    maxCountIndex += 1\n            \
    \        maxString = \"\"\n                    maxCountIndex = 0\n           \
    \     }\n            }\n            \n            if (curCount == maxCount) {\n\
    \                if (curString == \"\") {\n                    curString = word\n\
    \                    curCount = count\n                } else {\n            \
    \        if (curString != word) {\n                        curString = word\n\
    \                        curCount = count\n                    } else {\n    \
    \                    curCount = count\n                    }\n               \
    \ }\n            } else {\n                if (curString != \"\") {\n        \
    \            curString = \"\"\n                    curCount = 0\n            \
    \    }\n            }\n        }\n        \n        if (maxCount == maxCountIndex\
    \ + 1) {\n            words.sortWith(_.length < _.length)\n            words.head\n\
    \        } else {\n            words.sortWith(_.length < _.length).head\n    \
    \    }", "        val counts = mutable.Map[Char, Int]()\n        for (str <- words)\
    \ {\n            for(ch <- str.toCharArray) {\n                if(!counts.contains(ch))\
    \ {\n                    counts += (ch -> 1)\n                } else {\n     \
    \               counts += (ch -> (counts(ch) + 1).toInt)\n                }\n\
    \            }\n        }\n        counts.maxBy(_._2)._1", "        val wordSet\
    \ = HashSet[String]()\n        for (word <- words) {\n            val unique =\
    \ word.map(_.toInt).distinct.length\n            val count = wordSet(word)\n \
    \           if (unique<count) wordSet(word)=unique\n            else wordSet(word)=count\n\
    \        }\n        wordSet.max match {\n            case Some(m) =>\n       \
    \         words.takeWhile(w => w < m).sorted\n            case _ =>\n        \
    \        words.reverse.takeWhile(w => w < wordSet.max).sorted\n        }", " \
    \       var bestIndex = 0\n        var bestLength = words.length\n        var\
    \ bestValue = words(bestIndex).length\n        var bestWord = words(bestIndex)\n\
    \        var nextIndex = 1\n        var nextLength = words.length\n        var\
    \ nextValue = words(nextIndex).length\n        var nextWord = words(nextIndex)\n\
    \n        while (bestIndex < nextIndex) {\n            if (nextValue > bestValue)\
    \ {\n                bestValue = nextValue\n                bestIndex = nextIndex\n\
    \                bestLength = nextLength\n                bestWord = nextWord\n\
    \                nextIndex = nextIndex + 1\n                nextLength = words.length\n\
    \                nextValue = words(nextIndex).length\n                nextWord\
    \ = words(nextIndex)\n            } else if (nextValue == bestValue) {\n     \
    \           nextLength = nextLength + 1\n                nextValue = words(nextIndex).length\n\
    \                nextWord = words(nextIndex)\n            } else {\n         \
    \       nextIndex = nextIndex + 1\n                nextLength = words.length\n\
    \                nextValue = words(nextIndex).length\n                nextWord\
    \ = words(nextIndex)\n            }\n        }\n        return bestWord", "  \
    \      val wordsGroup = words.groupBy(x => x).mapValues(_.size)\n        val maxValue\
    \ = wordsGroup.max\n        val maxKeys = wordsGroup.keySet.filter(x => x == maxValue)\n\
    \        val max = maxKeys.head\n        return max", "        val counts = mutable.Map[String,\
    \ Int]()\n        for (word <- words) {\n            val count = counts(word)\n\
    \            if (count == null) counts(word) = 1 else {\n                counts(word)\
    \ = count + 1\n            }\n        }\n        counts\n                .sortWith(_._2\
    \ > _._2)\n                .map(_._1)\n                .head", "        var maxCount\
    \ : Int = 0\n        var maxCount : String = \"\"\n        var maxIndex = 0\n\
    \        var maxWord : String = \"\"\n        var i = 0\n        var j = words.length\n\
    \        var c = new scala.collection.mutable.HashSet[String]()\n\n        while\
    \ (i < j) {\n            val tempCount = c.size\n            if (tempCount > maxCount)\
    \ {\n                maxIndex = i\n                maxWord = words(i)\n      \
    \          maxCount = tempCount\n            }\n            i += 1\n        }\n\
    \        if (maxCount == 0) maxWord\n        else words(maxIndex)", "        val\
    \ uniqueWords = words.groupBy(x => x).map(x => (x._1,x._2.size)).toList.sortWith(_._2\
    \ > _._2)\n        uniqueWords(0)", "        val chars = words.map(_.toList).flatten\n\
    \        chars.groupBy(identity).maxBy(_._2.size).toList(0).get", "        val\
    \ characters = words.flatMap(word => word.distinct)\n        characters.foldLeft((\"\
    \", 0))( (acc: (String, Int), word: Char) => {\n            val n = acc._1 + word.length\n\
    \            if (n > acc._2) {\n                acc._1 -> n\n            } else\
    \ acc\n        })\n        .get._1.reverse", "        val count = mutable.Map[Char,\
    \ Int]()\n        for (w <- words) count(w) += 1\n\n        if (count.size ==\
    \ 0) \"None\"\n        else {\n            var max = -1000\n            var maxWord\
    \ = \"None\"\n            for ((c,i) <- count.iterator)\n                if (i\
    \ < max) {\n                    max = i\n                    maxWord = w\n   \
    \             }\n            maxWord\n        }", "        val charCounts = words.map(_.toCharArray).flatten.foldLeft(Map[Char,\
    \ Int]())((m, c) => {\n            m + (c -> (m.getOrElse(c,0) + 1)))\n      \
    \  })\n        charCounts.maxBy(_._2)._1", "        val wordsWithMaxCharacters\
    \ =  new mutable.HashMap[String, Int]()\n        for(word <- words){\n       \
    \     val uniqueCharCount = word.distinct\n            if(uniqueCharCount.length>wordsWithMaxCharacters.size){\n\
    \                wordsWithMaxCharacters +=((word, uniqueCharCount.length))\n \
    \           }\n        }\n        var maxWord = \"\"\n        if(wordsWithMaxCharacters.isEmpty)\n\
    \            return \"\"\n        wordsWithMaxCharacters.foreach{\n          \
    \  case (word, uniqueCharCount) =>\n                if(maxWord.length<uniqueCharCount)\n\
    \                    maxWord = word\n        }\n        wordsWithMaxCharacters.toSeq.sortWith(_.1\
    \ < _.1)\n            .map(_.key)\n            .headOption", "        var max\
    \ = 0\n        var maxWord = \"\"\n        for(word <- words){\n            val\
    \ count = word.count(c => c.isLetter)\n            if(count > max){\n        \
    \        max = count\n                maxWord = word\n            }\n        }\n\
    \        return maxWord", "        val numUniqueChars = words.map(x => x.size).reduceLeft(_\
    \ + _)\n        if(numUniqueChars == 0) \"no unique characters\"\n        else\
    \ {\n            val sortedWords = words.sortWith(_ < _)\n            val maxLen\
    \ = sortedWords.map(_.length).max\n            val maxLenIndex = sortedWords.map(_.length).indexOf(maxLen)\
    \ + 1\n            if(maxLenIndex == sortedWords.length) sortedWords(maxLenIndex)\n\
    \            else sortedWords(maxLenIndex - 1)\n        }", "        val uniqueLetters\
    \ = HashMap[String, Int]()\n        words.foreach{\n            word => word.foreach{\n\
    \                letter => uniqueLetters(letter) += 1\n            }\n       \
    \ }\n        val maxLetter = uniqueLetters.maxBy(_._2)\n        if (uniqueLetters.length\
    \ == 1) {\n            return words(0)\n        }\n        if (uniqueLetters(maxLetter)\
    \ > uniqueLetters.count(_._1 == maxLetter)) {\n            return words(0)\n \
    \       } else {\n            return words(0)\n        }", "        val charsCount\
    \ = words.foldLeft(Map[Char, Int]())((m, word) =>\n            word foreach (c\
    \ =>\n                m + (c -> (m.getOrElse(c, 0) + 1))))\n        val max =\
    \ charsCount.maxBy(_._2.toInt).toChar\n        val found = words.find(word =>\
    \ charsCount.filter(_._1 == word.toChar).exists(_._2 == max))\n        found.orElse\
    \ {\n            // if none of the words have max number of unique chars, return\
    \ first word in lexicographical order\n            val sortedWords = charsCount.toList.sortBy(_._1)\n\
    \            sortedWords(0)\n        }", "        var maxChars = 0\n        var\
    \ maxWord = \"\"\n        for (w <- words)\n        {\n            var charCount\
    \ = 0\n            var wordCount = 0\n            for (c <- w)\n            {\n\
    \                charCount += 1\n                wordCount += 1\n            \
    \    if (charCount > maxChars)\n                {\n                    maxChars\
    \ = charCount\n                    maxWord = w\n                }\n          \
    \  }\n        }\n        if (maxChars > 0)\n        {\n            for (w <- words)\n\
    \            {\n                for (c <- w)\n                {\n            \
    \        if (c != maxWord.charAt(maxWord.length - 1)) w += c\n               \
    \ }\n            }\n        }\n        maxWord", "        var maxCount = 0\n \
    \       var result = \"\"\n        for (word <- words){\n            val count\
    \ = word.length()\n            if(count > maxCount){\n                result =\
    \ word\n                maxCount = count\n            }\n        }\n        return\
    \ result", "        val unique = words.length.toLong\n        if (unique > 1)\
    \ {\n            val max = scala.collection.mutable.Map[Int, String]()\n     \
    \       for (word <- words) {\n                val numChars = word.split(\" \"\
    ).length\n                val chars = if (numChars > 1) \"many\" else \"char\"\
    \n                max.getOrElse(numChars, chars) = word\n            }\n     \
    \       max.max._2\n        } else words.head", "      val map = scala.collection.mutable.Map.empty[Int,\
    \ String]\n      words.foreach(x => {\n        x match {\n          case \"name\"\
    \ => map.update(0, x)\n          case \"of\" => map.update(1, x)\n          case\
    \ \"string\" => map.update(2, x)\n          case _ => map.update(3, x)\n     \
    \   }\n      })\n      val ordered = map.toList\n      ordered.sortWith((x,y)\
    \ => x._1 < y._1).head._2", "        val nums = words.groupBy(w => w.length).maxBy(_._2)._1\n\
    \        words.find(w => w.length == nums)", "        val m = Map(words.toSet.toSeq.groupBy(x\
    \ => x).mapValues(_.size).maxBy(_._1))\n        words(m.keys.toSeq.maxBy(x =>\
    \ m.get(x)).get)", "        val chars = words.map(_.length)\n        val uniqueChars\
    \ = chars.distinct\n        uniqueChars.max match {\n            case Some(max)\
    \ => chars.find(_ == max).head\n            case None => \"\"\n        }", " \
    \       val count = words.foldLeft(Map[Char,Int]())(_ + (_._2.toInt -> 1))\n \
    \       val maxKey = count.maxBy(_._2)._2\n        val maxValue = count.maxBy(_._2)._1\n\
    \        val maxWord = words.filter(w => w.length == maxValue).filter(_._2 ==\
    \ maxValue).head\n        if(maxKey.toString.toCharArray.sortedList.nonEmpty){\n\
    \            words(\"sort\") match {\n                case x => x.substring(maxKey.toString.toCharArray.sortedList.indexOf(maxKey),x.toString.length).trim\n\
    \            }\n        }else{\n            maxWord\n        }", "        // Write\
    \ your answer here\n        words.foldLeft(\"\")( (maxWord, word) => maxWord.length\
    \ + (word.length max 1) )", "        val wordMap : mutable.Map[Int, List[String]]\
    \ = words.groupBy(word => {\n            val len = word.length\n            if\
    \ (len > 1) 1\n            else if (len == 1) 0\n            else {\n        \
    \        val lw = word.toLowerCase\n                val lwo = lw\n           \
    \         .replaceAll(\" \", \"\")\n                    .replaceAll(\"[^a-z]\"\
    , \"\")\n                    .length\n                lw > lwo ? 1 : 0\n     \
    \       }\n        }).mapValues(_.toList).toMap\n        var maxCount = 0\n  \
    \      var maxWord = \"\"\n        val keys = wordMap.keys\n        val values\
    \ = wordMap.values.sortWith(_.length < _.length).reverse\n        for (k <- keys)\
    \ {\n            var count = 0\n            for (l <- values) {\n            \
    \    if (k == l) count += 1\n            }\n            if (count > maxCount)\
    \ {\n                maxCount = count\n                maxWord = k\n         \
    \   }\n        }\n        maxWord", "      var maxCount = 1\n      var maxWord\
    \ = \"\"\n      for ( word <- words ) {\n        var count = word.distinct().length\n\
    \        if (count > maxCount) {\n          maxCount = count\n          maxWord\
    \ = word\n        }\n      }\n      return maxWord", "        val chars = words.map(_.toChar).distinct.sorted\n\
    \        chars.takeWhile(char.isLetter).length == 1\n          match {\n     \
    \       case true => words.last\n            case false => word(words.length)\n\
    \          }", "        val maxCharNum = words.foldLeft(Map[String, Int]())(_\
    \ + _._2.toInt)\n        val result = words.filter(_._2.toInt == maxCharNum).sortBy(-_._1)\n\
    \        result.getOrElse(words.get(0))", "        val uniqueCount = mutable.HashSet[String]()\n\
    \        var maxCount = 0\n        var maxWord = \"\"\n        for(word <- words)\
    \ {\n            uniqueCount += word.distinct\n            if(uniqueCount.length\
    \ >= maxCount) {\n                maxCount = uniqueCount.length\n            \
    \    maxWord = word\n            }\n        }\n        uniqueCount += maxWord\n\
    \        maxWord", "        def uniqueWords(w : String, i : Int) : Int = {\n \
    \           val l = words(i)\n            val l = l.toUpperCase\n            val\
    \ l = l.toLowerCase\n            val l = l.split(\"\")\n            val l = l.distinct\n\
    \            val l = l.length\n            l == w.toUpperCase\n        }\n\n \
    \       val maxLength = words.map( w =>  w.length ).max\n        val maxLength\
    \ = if (maxLength == 0) 0 else maxLength\n\n        val uniqueWordsMap = words.map(w\
    \ =>  (w, uniqueWords(w, words.indexOf(w))) ).toMap\n        uniqueWordsMap.filter(_._2\
    \ > maxLength).map(_._1).headOption", "        val counts = words.map(word =>\
    \ word.toSet).foldLeft(Map[String,Int]())((acc, element) => {\n            val\
    \ set = acc(element.head)\n            if (set == null) {\n                val\
    \ count = element.size\n                acc((element.head) -> count)\n       \
    \     } else {\n                val count = acc((element.head) -> acc((element.head)\
    \ -> 1) + 1)\n                acc((element.head) -> count)\n            }\n  \
    \      })\n        var maxCount = 0\n        for (e <- counts.keySet) {\n    \
    \        if (counts(e) > maxCount) {\n                maxCount = counts(e)\n \
    \           }\n        }\n        counts.keys.find(e => e == maxCount).map(_ +\
    \ \"\").head", "        val wordsWithUniqueChars = words.groupBy(c => (c))\n \
    \       val maximum = wordsWithUniqueChars.maxBy(_._2.size)\n        val wordWithMaxChars\
    \ = wordsWithUniqueChars.filter(_._2.size == maximum._2.size)\n        val wordWithMaxCharsWithMaxCharsFirst\
    \ = wordWithMaxChars.minBy(_._2._1)\n        wordWithMaxCharsWithMaxCharsFirst._1",
  "        var counts : scala.collection.mutable.Map[Char, Int] = scala.collection.mutable.HashMap[Char,\
    \ Int]()\n        var maxCount : Int = words.size\n        var maxWord = \"\"\n\
    \        for (word <- words) {\n            val charCount = word.chars.distinct.size\n\
    \            if (charCount > maxCount) {\n                maxCount = charCount\n\
    \                maxWord = word\n            }\n            if (charCount > 0)\
    \ {\n                counts.put(charCount, charCount)\n            }\n       \
    \ }\n        if (counts.size == 0) {\n            return \"\"\n        }\n   \
    \     val highestCountKeys = counts.keys.toList.sortWith(_ < _)\n        val highestCountValues\
    \ = counts.values.toList.sortWith(_ < _)\n        if (highestCountValues.head\
    \ > highestCountValues.last)\n            return highestCountKeys(0)\n       \
    \ else\n            return highestCountKeys.head", "        def countMap(word:String,\
    \ map:Map[Char,Int]) : Map[Char,Int] = {\n            val newMap = map.updated(word.charAt(0),\
    \ map.getOrElse(word.charAt(0),0)+1)\n            val newMap = map.updated(word.charAt(word.length-1),\
    \ map.getOrElse(word.charAt(word.length-1),0)+1)\n            newMap\n       \
    \ }\n        def getMaxCount(words : List[String], map: Map[Char,Int]) : Map[Char,Int]\
    \ = {\n            var maxCount = Map[Char,Int]()\n            words.foreach(word\
    \ => {\n                val count = map.getOrElse(word.charAt(0),0)\n        \
    \        val newCount = count + 1\n                if (maxCount.exists(_._2 >\
    \ newCount)) {\n                    maxCount = getMaxCount(words.filterNot(_.contains(word)),\
    \ map).updated(word.charAt(0),newCount)\n                }\n            })\n \
    \           maxCount\n        }\n        val sortedWords = words.sorted\n    \
    \    val sortedMap = countMap(sortedWords.head, Map[Char,Int]())\n        val\
    \ maxCount = getMaxCount(sortedWords, sortedMap)\n        maxCount.map(_._1).headOption.getOrElse(\"\
    empty\")", "      val mc = new scala.collection.mutable.HashMap[String, Int]()\n\
    \      words.foreach { word =>\n        val chars = word.grouped(2).toList\n \
    \       if(chars.isEmpty) mc.put(word, 1) else mc.put(word, chars.count(_._2).max)\n\
    \      }\n      if(mc.isEmpty) words.getOrElse(\"NULL\", null)\n      else {\n\
    \        mc.toList.sortBy(-_._2).head\n      }", "        val sortedWords = words.sortBy(_.length)\n\
    \        val uniqueChars = mutable.Map[Char, Int]()\n        val resultString\
    \ = sortedWords.map((_, uniqueChars)).foldLeft(\"\"){ (result, word) =>\n    \
    \        val uniqueCharCount = uniqueChars(word.charAt(0))\n            if(uniqueCharCount\
    \ > result.length){\n                result\n            }else{\n            \
    \    result + word.substring(0, uniqueCharCount)\n            }\n        }\n \
    \       resultString", "        // Write the code here\n        var maxUnique\
    \ = -1;\n        var maxChar = 0;\n        var maxCharIndex = 0;\n        var\
    \ maxCharValue = 0;\n        var maxValue = words.size\n\n        for (i <- 0\
    \ until words.size) {\n            var curUnique = 0;\n            var curChar\
    \ = 0;\n            var curValue = 0;\n            for (j <- 0 until words.size)\
    \ {\n                if (j == i) {\n                    continue;\n          \
    \      }\n                val w1 = words(i)\n                val w2 = words(j)\n\
    \                val len = w1.length \n\n                if (w1 equals w2) {\n\
    \                    continue;\n                }\n\n                val chars\
    \ = w1.charCount\n                val charsCount = w2.charCount\n            \
    \    val value = len - chars - charsCount\n\n                if (curUnique ==\
    \ 0) {\n                    curUnique = chars\n                    curChar = charsCount\n\
    \                    curValue = value\n                }\n                if (curUnique\
    \ < chars) {\n                    curUnique = chars;\n                    curChar\
    \ = charsCount;\n                    curValue = value;\n                }\n  \
    \              if (curUnique == chars && (len - charsCount > maxChar)) {\n   \
    \                 maxUnique = curUnique;\n                    maxChar = chars;\n\
    \                    maxCharIndex = j;\n                    maxCharValue = value;\n\
    \                }\n            }\n        }\n        words(maxCharIndex)", " \
    \       val max = words.foldLeft(0){\n            case (max, word) => if (word.length()\
    \ > max) word.length else max\n        }\n\n        val charSet = new mutable.HashSet[String]()\n\
    \        words.foreach(word => charSet += word)\n\n        if(charSet.size ==\
    \ max)\n            charSet.min\n        else if (charSet.size == 1)\n       \
    \     charSet.head\n        else\n            \"\"", "        val map = scala.collection.mutable.Map[String,\
    \ Int]()\n        words.foreach( word => {\n            val count = map.get(word)\
    \ match {\n                case Some(c) => c + 1;\n                case None =>\
    \ {\n                    map.put(word, 1); word\n                }\n         \
    \   }\n        })\n        map.maxBy(_._2)._1", "        val uniqueCountMap =\
    \ mutable.Map[Char, Int]()\n        val sortedWords = words.toList.sortWith((word1,\
    \ word2) => word1.length < word2.length)\n        val uniqueWord = sortedWords.foldLeft((\"\
    \", List[String]()))((uniqueWord, word) => {\n            val uniqueChar = word.uniqueChar\n\
    \            if (uniqueCountMap.contains(uniqueChar)) {\n                (uniqueWord._1\
    \ + uniqueChar, uniqueWord._2 :+ word)\n            } else {\n               \
    \ (uniqueWord._1 + uniqueChar, uniqueWord)\n            }\n        })._2\n   \
    \     uniqueWord.head //uniqueWord._2", "        var maxCount: Int = 0\n     \
    \   var maxWord: String = null\n        words.foreach(str => {\n            if\
    \ (maxCount < str.unique.length) {\n                maxCount = str.unique.length\n\
    \                maxWord = str\n            }\n        })\n        return maxWord",
  "        val maxCountMap : mutable.Map[Char, Int] = mutable.Map.empty\n        var\
    \ maxCount : Int = Integer.MIN_VALUE\n        var maxWord = \"\"\n        var\
    \ nextMaxWord = \"\"\n        for(word <- words){\n            val charCount =\
    \ word.map(c => (c, 1)).reduceByKey((a, b) => a + b)\n            if(charCount\
    \ > maxCount){\n                maxWord = word\n                maxCount = charCount\n\
    \            }\n            else if(charCount == maxCount){\n                nextMaxWord\
    \ = word\n            }\n        }\n        if(maxCount > maxCountMap.values.max)\n\
    \            maxWord\n        else\n            nextMaxWord", "      val set =\
    \ scala.collection.mutable.Set[String]()\n      words.foreach(x => set.add(x))\n\
    \      set.size match {\n        case 1 => \"abc\".find(x => set.contains(x))\n\
    \        case 2 => \"abbc\".find(x => set.contains(x))\n        case 3 => \"abbbc\"\
    .find(x => set.contains(x))\n        case 4 => \"abbbbc\".find(x => set.contains(x))\n\
    \        case 5 => \"abbbbcc\".find(x => set.contains(x))\n        case 6 => \"\
    abbbbccc\".find(x => set.contains(x))\n        case 7 => \"abbbbcccc\".find(x\
    \ => set.contains(x))\n        case 8 => \"abbbbccccc\".find(x => set.contains(x))\n\
    \        case 9 => \"abbbbcccccc\".find(x => set.contains(x))\n        case 10\
    \ => \"abbbbccccccc\".find(x => set.contains(x))\n        case 11 => \"abbbbcccccccc\"\
    .find(x => set.contains(x))\n        case 12 => \"abbbbccccccccc\".find(x => set.contains(x))\n\
    \        case 13 => \"abbbbcccccccccc\".find(x => set.contains(x))\n        case\
    \ 14 => \"abbbbccccccccccc\".find(x => set.contains(x))\n        case 15 => \"\
    abbbbccccccccccc\".find(x => set.contains(x))\n        case 16 => \"abbbbccccccccccc\"\
    .find(x => set.contains(x))\n        case 17 => \"abbbbccccccccccc\".find(x =>\
    \ set.contains(x))\n        case 18 => \"abbbbcccccccccccc\".find(x => set.contains(x))\n\
    \        case 19 => \"abbbbccccccccccccc\".find(x => set.contains(x))\n      \
    \  case 20 => \"abbbbccccccccccccc\".find(x => set.contains(x))\n        case\
    \ 21 => \"abbbbccccccccccccc\".find(x => set.contains(x))\n        case 22 =>\
    \ \"abbbbccccccccccccc\".find(x => set.contains(x))\n        case 23 => \"abbbbccccccccccccc\"\
    .find(x => set.contains(x))\n        case 24 => \"abbbbccccccccccccc\".find(x\
    \ => set.contains(x))\n        case 25 => \"abbbbccccccccccccc\".find(x => set.contains(x))\n\
    \        case 26 => \"abbbbccccccccccccc\".find(x => set.contains(x))\n      \
    \  case 27 => \"abbbbccccccccccccc\".find(x => set.contains(x))\n        case\
    \ 28 => \"abbbb", "        // Write code here\n        val freqMap = mutable.HashMap[String,\
    \ Int]()\n        words.foreach(x => freqMap += x -> 1)\n        freqMap.foldLeft(List[(String,\
    \ Int)]()){(acc, e) => \n          if (acc.last == 0 || e._2 > acc.last._2) e\
    \ :: acc else acc ++ List(e)}\n            .sortBy(x => x._2)\n            .map(x\
    \ => x._1)\n            .head", "        val charSet = mutable.HashMap[Char, Int]()\n\
    \        val sortedWords = words.sortWith(_ < _)\n        val maxCount = sortedWords.foldLeft(Map[Char,\
    \ Int]()){ (map, word) =>\n            val charCountMap = (map + (word -> (map.getOrElse(word.charAt(0),\
    \ 0) + 1))).withDefaultValue(0)\n            charCountMap + (word.charAt(0) ->\
    \ (charCountMap.getOrElse(word.charAt(0), 0) + 1))\n        }\n        sortedWords.map{word\
    \ => (word, charSet(word.charAt(0)).getOrElse(0))}.\n            filter{case (word,\
    \ count) => count > maxCount.getOrElse(word.charAt(0))}\n            .head._1",
  "        val uniqueChars = words.length\n        val maxWord = scala.math.max(words.map(_.length))\n\
    \        val maxChar = words.filter(_.length == maxWord).map(_.length).max\n \
    \       val maxUniqueChars = words.map(_.toSet.size)\n        val firstWord =\
    \ words.filter(_.length == maxChar).map(_.toLowerCase).min\n        val firstUniqueChars\
    \ = words.map(_.toSet.head).min\n        val firstChar = words.map(_.toSet.head).head\n\
    \n        if (uniqueChars == maxUniqueChars) {\n            firstWord\n      \
    \  } else {\n            val firstWordInAlphabetOrder = words.filter(_.length\
    \ == firstChar).map(_.toLowerCase).min\n            firstWordInAlphabetOrder\n\
    \        }", "        // Write your code here\n        val strMap: mutable.Map[String,Long]\
    \ = words.toList.groupBy(x => x).map(x => (x._1,x._2.length)).toMap\n        var\
    \ max = 0L\n        var str = \"\"\n        strMap.foreach {\n        case (str,\
    \ count) => {\n            if(count > max){\n                max = count\n   \
    \             str = str\n            }\n        }\n        }\n        if(max >\
    \ 0)\n            str\n        else\n            \"\"", "        val wordSet =\
    \ mutable.HashSet[String]()\n        val maxCount = 0\n        var maxWord = \"\
    \"\n        var maxWordCount = 0\n        var index = -1\n        for(word <-\
    \ words){\n            val count = wordSet.getOrElse(word, 0) + 1\n          \
    \  if(count > maxCount) {\n                maxCount = count\n                maxWord\
    \ = word\n                maxWordCount = count\n            }\n            wordSet.put(word,\
    \ count)\n        }\n        wordSet.get(maxWord)", "        var maxWord = \"\"\
    \n        var maxCount = 0\n        words.foreach{ word =>\n            var count\
    \ = 0\n            word.foreach{ c =>\n                if (c != maxWord(0)) {\n\
    \                    count = count + 1\n                }\n            }\n   \
    \         if (count > maxCount) {\n                maxCount = count\n        \
    \        maxWord = word\n            }\n        }\n        maxWord", "       \
    \ var maxCount = 0\n        var maxWord = null\n        for (word <- words) {\n\
    \            var uniqueCharCount = 0\n            for (c <- word) {\n        \
    \        if (!uniqueChars.contains(c)) {\n                    uniqueCharCount\
    \ += 1\n                    uniqueChars += c\n                }\n            }\n\
    \            if (uniqueCharCount > maxCount) {\n                maxCount = uniqueCharCount\n\
    \                maxWord = word\n            }\n        }\n        return maxWord",
  "        var maxCount = 0\n        var maxWord = \"\"\n        var maxChar = \"\"\
    \n        for (word <- words) {\n            val uniqueChar = word.distinct\n\
    \            val wordLen = word.length\n            val uniqueCharCount = uniqueChar.length\n\
    \            if(uniqueCharCount > maxCount) {\n                maxCount = uniqueCharCount\n\
    \                maxWord = word\n                maxChar = uniqueChar\n      \
    \      }\n            if(wordLen > maxCount) {\n                maxCount = wordLen\n\
    \                maxWord = word\n                maxChar = uniqueChar\n      \
    \      }\n        }\n        return maxWord", "        //val wordsSorted = words.toSeq.sortWith((a,b)\
    \ => a.compareTo(b) < 0)\n        val wordsSorted = words.toSeq.sortWith((a,b)\
    \ => a.compareTo(b) > 0)\n        wordsSorted.headOption.map { s => s.count(c\
    \ => c.toChar == 'a') } getOrElse \"NO\"", "        val wordCountMap = mutable.HashMap[(String,\
    \ Int), Int]()\n        for (str <- words) {\n            val s = str.split(\"\
    \ \")\n            for (word <- s) {\n                if (wordCountMap.get((word,\
    \ s.length)) < s.length) wordCountMap += ((word, s.length))\n            }\n \
    \       }\n        val maxKey = wordCountMap\n            .filter(_._2 > 0)\n\
    \            .sortWith(_._2 > _._2).head\n        val maxValue: Int = wordCountMap.getOrElse(maxKey,\
    \ 0)\n        var max = List[String]()\n        for (key <- wordCountMap.keySet)\
    \ {\n            val count = wordCountMap.getOrElse(key, 0)\n            if (count\
    \ > maxValue) maxValue = count\n            max = key :: max\n        }\n    \
    \    max(0)", "        val wordSet = words.toSet.asInstanceOf[Set[String]]\n \
    \       val maxCount = words.map(x => wordSet.count(x)).max.toInt\n        val\
    \ maxIndex = words.zipWithIndex.\n          filter(_._2 == maxCount).\n      \
    \    map(_._1).\n          toList.\n          sortWith(_ < _).\n          head\n\
    \        words(maxIndex)", "        // your code here\n        val maxNumCharactersMap\
    \ = words.map(x => (x, 1)).toMap\n        val maxNumCharacters = maxNumCharactersMap.values.max\n\
    \        val maxNumCharactersMap = maxNumCharactersMap.filter(_._2 > 1).map(_._1)\n\
    \        maxNumCharactersMap.headOption.getOrElse(words.head)", "        val counts\
    \ = words.map((_, 1)).toMap\n        var maxKey = counts.keys.head\n        var\
    \ maxValue = counts.values.head\n\n        for (key <- counts.keys.tail) {\n \
    \           if (counts.get(key) < counts.get(maxKey))\n                maxKey\
    \ = key\n            else if (counts.get(key) > counts.get(maxKey))\n        \
    \        maxValue = counts.get(key)\n        }\n\n        if (maxKey == counts.keys.head)\n\
    \            maxValue\n        else maxKey", "        val unique = words.map(w\
    \ => w.toSet.size).reduce((a, b) => if (b > a) a else b)\n        var max: Int\
    \ = -1\n        var maxStr = \"\"\n        words.foreach { w =>\n            if\
    \ (w.toSet.size > max) {\n                max = w.toSet.size\n               \
    \ maxStr = w\n            }\n        }\n        return maxStr", "        val wl\
    \ = words.map(_.distinct)\n        val xl = wl.map(x => x.size -> x)\n       \
    \ val max = xl.maxBy(_._1)._1\n        xl.find(_._1 == max).map(x => x._2).head",
  "        var result = \"\"\n        val mutableSet = scala.collection.mutable.Set[String]()\n\
    \        for (word <- words) {\n            mutableSet+=word\n        }\n    \
    \    var maxSize = 0\n        var max = \"\"\n        for (word <- words) {\n\
    \            val size = word.length\n            if (size >= maxSize) {\n    \
    \            max = word\n                maxSize = size\n            }\n     \
    \   }\n        if (!mutableSet.contains(max)) {\n            max = \"aa\"\n  \
    \          maxSize = 2\n        }\n        result+=max\n        return result",
  "        var max = 0\n        var cur = \"\"\n        val res = words.foldLeft((cur,max))\
    \ {\n            (cur,max)=> {\n                val current = cur._2.toList.distinct\n\
    \                if(current.length>max) {\n                    (cur, max)\n  \
    \              } else {\n                    current\n                }\n    \
    \        }\n        }\n        res", "        // Write your code here\n      \
    \  val unique = words.map(x => (x, words.count(x => x == x)))).toMap\n       \
    \ var max = \"zzzzzzz\"\n        unique.foreach {\n            x =>\n        \
    \        if (max < x._2) max = x._1\n        }\n        max", "        val uniqueSet\
    \ = mutable.Set[String]()\n        words.foreach( word => {\n            for(\
    \ c <- word.chars ) {\n                if(!uniqueSet.contains(c)) {\n        \
    \            uniqueSet += c\n                }\n            }\n        })\n  \
    \      if(uniqueSet.size > 0) {\n            val maxElemSet = uniqueSet.toSeq.sortBy(\
    \ _.length)\n            val maxElem = maxElemSet(0)\n            val maxElemCount:\
    \ Int = maxElemSet.filter(_.length == maxElem.length).size\n            if(maxElemCount\
    \ > 1) {\n                return maxElem\n            } else {\n             \
    \   val firstElemSet = uniqueSet.toSeq.sortBy( _.length)\n                val\
    \ firstElem = firstElemSet(0)\n                val firstElemCount: Int = firstElemSet.filter(_.length\
    \ == firstElem.length).size\n                if(firstElemCount > 1) {\n      \
    \              return firstElem\n                } else {\n                  \
    \  return \"\"\n                }\n            }\n        } else {\n         \
    \   return \"\"\n        }", "        words.foldLeft(Set.empty[String]) { (s,\
    \ word) => s ++ word.count() }\n            .maxBy(s => s)", "        def count(str\
    \ : String) : Int = {\n            val counts = HashMap();\n            for(i\
    \ <- 0 until str.length)\n                if(counts.getOrElse(str, 0) + 1 > counts.getOrElse(str,\
    \ i))\n                    counts.put(str.charAt(i), counts.getOrElse(str, i)\
    \ + 1)\n            counts.getOrElse(str, 1)\n        }\n        val maxCount\
    \ = words.map(count(_)).reduce(_ + _).max\n        words.sortBy(count(_))(maxCount\
    \ == count(_)).get", "        val counts = words.groupBy(x => x).map(x => (x._2,\
    \ x._1.size)).toMap\n        val maxKey = counts.maxKey\n        val maxVal =\
    \ counts.maxValue\n        if (maxVal == 1) {\n            words(maxKey.toInt)\n\
    \        } else {\n            words(maxKey.toInt)\n        }", "        val count\
    \ = words.foldLeft(0)(_ + _.length)\n        val unique = words.foldLeft(0)(_.distinct)\n\
    \        val max = (count.toInt, unique.toInt)\n        words(max match {\n  \
    \          case (count, unique) if (count == unique) => words\n            case\
    \ _                               => words.sortWith(_ < _)\n        })", "   \
    \     val counts = words.foldLeft(mutable.Map.empty[String, Int]) (\n        \
    \    (m, str) => m.updated(str, m.getOrElse(str, 0) + 1)\n        )\n        val\
    \ maxVal = counts.maxBy(_._2)._2\n        counts.values.toList.maxBy(_.toString.length).last",
  "        val wordCount = mutable.Map[String, Int]()\n        for (word <- words)\n\
    \            wordCount(word) = wordCount(word) + 1;\n        val highestCount\
    \ = wordCount.values.max;\n        val highestWord = wordCount.keys.max;\n   \
    \     val highestChar = wordCount(highestWord).max;\n        if (highestCount\
    \ == 0) {\n            highestChar\n        } else {\n            val key = highestWord\
    \ +\n                    \" with \" + highestCount + \" unique characters and\
    \ \" +\n                    highestChar + \" characters in lexicographical order.\"\
    \n            val value = if (highestCount == highestChar) {\n               \
    \ highestWord\n            } else {\n                key\n            }\n    \
    \        key -> value\n        }", "        var charCount : Map[Char, Int] = Map()\n\
    \        for (word <- words) {\n            charCount += word.foldLeft(Map[Char,\
    \ Int]())((map, character) => {\n                map.updated(character, map.getOrElse(character,\
    \ 0) + 1)\n                map\n            })\n        }\n        val max = charCount.keys.max\n\
    \        val charsWithMaxCount = charCount.filter(_._2 == max).map(_._1)\n   \
    \     charsWithMaxCount.toList.sorted.head", "        val sortedWords = word.toList.sortWith(_\
    \ < _)\n        var max = 0\n        var i = 0\n        var maxWord = \"\"\n \
    \       while (i < sortedWords.size) {\n            if (sortedWords(i).length\
    \ <= max) {\n                max = sortedWords(i).length\n                maxWord\
    \ = sortedWords(i)\n                i = i + 1\n            } else {\n        \
    \        i = i + 1\n            }\n        }\n        maxWord", "        val wordsWithUniqueChars\
    \ = words.groupBy(word => word.length).maxBy(_._2).map(_._1)\n        val wordWithMaxNumberOfUniqueChars\
    \ = wordsWithUniqueChars.head\n        val wordWithFirstOccur = words.find(word\
    \ => wordWithMaxNumberOfUniqueChars.count(_ == word.length) == words.count(_ ==\
    \ word))\n        wordWithFirstOccur match {\n            case Some(word) => word\n\
    \            case None => words.head\n        }", "        var max : Option[String]\
    \ = None\n        var count = 0\n        for (str <- words) {\n            count\
    \ += str.length\n            if (max != None) if (count > max.get + 1) max = Some(str)\
    \ else if (count == max.get + 1) max = Some(str)\n        }\n        if (!max.isEmpty)\
    \ max.get else words.head", "        val chars = words.map(_.toUpperCase()).groupBy(identity).mapValues(_.size)\n\
    \        chars.maxBy(_._1)._1", "      val uniqueChars = mutable.Set[Char]()\n\
    \      var maxChar = 0\n      var maxWord = \"\"\n      words.foreach{ word =>\n\
    \        val characterCount = word.count(x => uniqueChars.contains(x))\n     \
    \   val charCount  = word.count(x => uniqueChars.contains(x) && uniqueChars.contains(x))\n\
    \        uniqueChars += word.charAt(0)\n        if(characterCount > maxChar){\n\
    \          maxChar = characterCount\n          maxWord = word\n        }\n   \
    \   }\n      return maxWord", "        // Use a Set to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track the words with maximum\
    \ number of unique characters.\n        // Use a map to track", "        val wordsCount\
    \ = words.map(_.length).reduce((x, y) => x + y)\n        val maxUnique = words.map(x\
    \ => x.toSet.size).reduce((x, y) => x max y)\n        val maxChar = words.map(x\
    \ => x.toSet.size).reduce((x, y) => x min y)\n        val result = words.filter(x\
    \ => x.toSet.size == maxUnique && x.toSet.size == maxChar).toList\n        result.map(x\
    \ => x(0))", "        val uniqueSet = new mutable.LinkedHashSet[String]()\n  \
    \      var max = \"\"\n        words.foreach{ word =>\n            val len = word.length\n\
    \            var count = 0\n            for(x <- uniqueSet) {\n              \
    \  count += x.length\n                if( x.startsWith(word) && x.endsWith(word)\
    \ ) {\n                    uniqueSet.remove(word)\n                    break\n\
    \                }\n            }\n            if( count > len ) {\n         \
    \       uniqueSet += word\n                max = word\n            }\n       \
    \ }\n        return max", "        val maxWords = new mutable.HashMap[Int, String]()\n\
    \        val maxLen = new mutable.HashMap[Int, Int]()\n        words.foreach(word\
    \ => {\n            if (maxLen(word.get.length) < (maxLen(word.length) +1)) {\n\
    \                maxLen(word.length) = maxLen(word.get.length) + 1\n         \
    \       maxWords(word.length) = word\n            }\n        })\n        val sortedList\
    \ = maxWords.toList.sortWith(x => x._2.length < x._1.length)\n        val result\
    \ = sortedList(0).get\n        result", "        if (words.isEmpty) {\n      \
    \      return \"\"\n        }\n        var max = 0\n        var maxWord = \"\"\
    \n        var maxWordLength = 0\n        var wordLength = words.head.length\n\
    \        var sortedWord = words.sorted\n        for (x<-0 to words.length-1) {\n\
    \            var uniqueCount = 0\n            var currentWord = words(x)\n   \
    \         var indexOfCurrentWord = sortedWord.indexOf(0)\n            for (i<-0\
    \ to indexOfCurrentWord-1) {\n                if (currentWord.substring(i, i+wordLength)\
    \ == sortedWord(i).substring(i, i+wordLength)) {\n                    uniqueCount++\n\
    \                }\n            }\n            if (uniqueCount > max) {\n    \
    \            max = uniqueCount\n                maxWord = currentWord\n      \
    \          maxWordLength = wordLength\n            }\n        }\n        if (max\
    \ > words.length-1) {\n            return findMax(words.tail)\n        } else\
    \ {\n            return maxWord\n        }", "        val chars = words.map(_.toList).reduce(_\
    \ ++ _)\n        val count = chars.groupBy(_).map(x => (x._1, x._2.length))\n\
    \        val max = count.max._2\n        var word = \"\"\n        for (word <-\
    \ chars if count.exists(x => x == max)) {\n            if (count > max) {\n  \
    \              break\n            }\n        }\n        word", "        val map\
    \ = mutable.Map[Int, String]()\n        words.map(word => {\n            val count\
    \ = map.getOrElseUpdate(0, \"\")\n            count += word.distinct\n       \
    \     map.update(0, count)\n        })\n        map max map getOrElse \"\"", " \
    \       //Your code here\n        val maxCountMap = new HashMap[Int, String]()\n\
    \        for(word <- words){\n            val count = maxCountMap.get(word.length)\n\
    \            if(count == null){\n                maxCountMap.put(word.length,\
    \ word)\n            }else{\n                if(count > maxCountMap.get(word.length)){\n\
    \                    maxCountMap.put(word.length, word)\n                }\n \
    \           }\n        }\n        val max = maxCountMap.keys.toList.max\n    \
    \    if(maxCountMap.values.toList.size < max){\n            return maxCountMap.values.toList.head\n\
    \        }\n        else{\n            return maxCountMap.values.toList.sortBy(_).head\n\
    \        }", "        var highestValue = 0\n        var highestWord = \"\"\n\n\
    \        for (word <- words) {\n            var uniqueCharactersCount = 0\n  \
    \          for (char <- word) {\n                uniqueCharactersCount += word.count(_\
    \ == char)\n            }\n            if (uniqueCharactersCount > highestValue)\
    \ {\n                highestValue = uniqueCharactersCount\n                highestWord\
    \ = word\n            }\n        }\n\n        highestWord", "        var maxCount\
    \ : Int = 0\n        var maxWord : String = \"\"\n        words.foreach { x =>\n\
    \            val count = getUniqueCount(x)\n            if (count > maxCount)\
    \ {\n                maxCount = count\n                maxWord = x\n         \
    \   }\n        }\n        maxWord", "        if (words.length < 1) {\n       \
    \     \"\"\n        } else {\n            val wordsCount = words.foldLeft(Map[String,\
    \ Int]()){\n                case (map, (word, count)) => {\n                 \
    \   val newCount = map.getOrElse(word, 0) + 1\n                    if (newCount\
    \ > count) {\n                        (map + ((word -> newCount) -> count))\n\
    \                    } else {\n                        (map + ((word -> count)\
    \ -> newCount))\n                    }\n                }\n            }\n   \
    \         val maxCount = wordsCount.max._2\n            val maxKey = wordsCount.maxKey\n\
    \            wordsCount.keys.find(_.toString.length == maxKey.toString.length).flatMap\
    \ {\n                case key if key.toString.length == maxKey.toString.length\
    \ => wordsCount.getOrElse(key, 0)\n            }.getOrElse(\"\")\n        }",
  "        // Write code here\n        val maxLength = words.length\n        val charMap\
    \ = scala.collection.mutable.HashMap[Char, Int]()\n        words.foreach { word\
    \ =>\n            word.chars.distinct.foreach { c =>\n                if (charMap.getOrElse(c,\
    \ 0) == 0) {\n                    charMap += ((c) -> (charMap.getOrElse(c, 0)\
    \ + 1))\n                } else {\n                    if (charMap.getOrElse(c,\
    \ 0) > charMap.getOrElse(c, 1))\n                        charMap += ((c) -> (charMap.getOrElse(c,\
    \ 1) + 1))\n                }\n            }\n        }\n        charMap.maxBy(_._2)._1.mkString",
  "        val maxKeys = words.map(_.length).max\n        var maxValue = words.filter(_.length\
    \ == maxKeys)(0)\n        var maxIndex = 0\n        val list = new collection.mutable.ListBuffer[String]()\n\
    \        for (word <- words) {\n            if (word.length > maxKeys) {\n   \
    \             list.add(word)\n            } else if (word.length == maxKeys) {\n\
    \                var count = 0\n                for (c <- word) {\n          \
    \          if (c.toInt < maxValue.toInt) {\n                        count += 1\n\
    \                    }\n                }\n                if (count > maxValue.toInt)\
    \ {\n                    maxValue = count\n                    maxIndex = list.indexOfLast(word)\n\
    \                }\n            }\n        }\n        list.take(maxIndex).reverse.mkString(\"\
    \")", "      words.foldLeft((\"\", \"\", 0))((max, str) => {\n        (max, str.distinct().length,\
    \ str)\n      })._2", "        val uniqueLetters = words.foldLeft(new mutable.HashMap[Int,\
    \ String]()) ((a,b) => { \n            a.update(b, (if (a.getOrElse(b) != null)\
    \ a.get(b) + 1 else 1).toString)\n        })\n\n        val maxLetter = uniqueLetters.values.max\n\
    \n        uniqueLetters.maxBy(_._1)._1\n", "        val wordsCount = words.map(word\
    \ => (word, 1)).toMap\n        val maxWord = wordsCount.max._1._1\n        val\
    \ maxCount = wordsCount.max max 1\n        wordsCount.filter(_._2 == maxCount).map\
    \ { case (word, count) =>\n            val index = words.indexOf(word)\n     \
    \       val otherWords = words.filter(_ != word)\n            otherWords.drop(index\
    \ + 1)\n        }.sortBy(_.length).head", "        val uniques = words.foldLeft(Set[String]())(\n\
    \            (uniques, word) => uniques.union(word.split(\"\").distinct))\n  \
    \      var maxCount = 0\n        var maxWord = \"\"\n        words.foreach(word\
    \ => {\n            val currentCount = uniques.count(word => word == word)\n \
    \           if (currentCount > maxCount) {\n                maxCount = currentCount\n\
    \                maxWord = word\n            }\n        })\n        return maxWord",
  "        // write your code here\n        var max = 0\n        var maxWrd = ''\n\
    \        var maxUniqueChars = 0\n        var maxStrWrd = ''\n        for (word\
    \ <- words) {\n            val counts = word.groupBy(_).mapValues(_.size)\n  \
    \          if (counts.max().toInt == maxUniqueChars) maxStrWrd = maxUniqueChars\n\
    \            else maxUniqueChars = counts.max().toInt\n            if (counts.max().toInt\
    \ == max) maxWrd = maxUniqueChars\n            else max = counts.max().toInt\n\
    \        }\n        words.reverse.head.swapWith(maxStrWrd)", "        val counts\
    \ = words.map(x => x -> 1).groupBy(x => x).mapValues(_.size)\n        val maxCount\
    \ = counts.max\n        val maxString = counts.find(x => x._2 == maxCount)\n \
    \       val maxChar = maxString._1.map(x => x.toChar).mkString\n        val index\
    \ = words.indexOf(maxString._1)\n        if (maxString._2 > 1) words(index)\n\
    \        else maxChar", "        words.map { x => (x, words.count(y => x == y))\
    \ }\n            .sortBy(x => -x._2)\n            .headOption\n            .map(_._1)",
  "        val wordSet = mutable.HashSet[String]()\n        words.sortWith(_ < _).foreach(word\
    \ => {\n            wordSet.toSet.toSeq.foreach(c => {\n                if (word.length\
    \ == 1 && word.charAt(0) == c) {\n                    wordSet.toSet -= word\n\
    \                    wordSet.toSet += word\n                }\n              \
    \  if (word.length == 1 && word.charAt(0) > c) {\n                    wordSet.toSet\
    \ -= word\n                    wordSet.toSet += word\n                }\n    \
    \        })\n        })\n        wordSet.map { w => w }.max", "        val freq\
    \ = mutable.Map[String, Int]()\n        words.foreach(word => {\n            freq\
    \ += (word -> 1)\n        })\n        freq.maxBy(_._2)._1", "        // initialize\
    \ to empty strings\n        var uniqueCharCount : Int = 0\n        var maxStr\
    \ = \"\"\n        var maxCount = 0\n        var str = \"\"\n        var maxStr\
    \ = \"\"\n        var maxCount = 0\n\n        // traverse through all words\n\
    \        for(word <- words){\n            // find number of unique characters\n\
    \            val nChar = word.length\n            val newCharSet = new mutable.HashSet[Char]()\n\
    \            val tempCharSet = new mutable.HashSet[Char]()\n            val duplicateCharSet\
    \ = new mutable.HashSet[Char]()\n            for(i<-0 until (nChar-1)) {\n   \
    \             val char = word.charAt(i)\n                val charInWord = word.indexOf(char,i)\n\
    \                if(charInWord != i) {\n                    tempCharSet.add(char)\n\
    \                } else {\n                    newCharSet.add(char)\n        \
    \        }\n                duplicateCharSet.add(char)\n            }\n      \
    \      val nUniqueChar = tempCharSet.size + newCharSet.size - duplicateCharSet.size\n\
    \n            // set max string\n            if(maxCount < nUniqueChar) {\n  \
    \              maxStr = \"\"\n                maxCount = 0\n            }\n  \
    \          // set max string\n            if(maxCount < nUniqueChar) {\n     \
    \           maxStr = \"\"\n                maxCount = 0\n            }\n     \
    \       // set max string\n            if(maxCount < nUniqueChar) {\n        \
    \        maxStr = \"\"\n                maxCount = 0\n            }\n        \
    \    // update max string and count for current word\n            if(!maxStr.isEmpty)\
    \ {\n                if(maxCount < nUniqueChar) {\n                    maxStr\
    \ = \"\"\n                    maxCount = 0\n                }\n            }\n\
    \            if(!maxStr.isEmpty) {\n                if(maxCount < nUniqueChar)\
    \ {\n                    maxStr = \"\"\n                    maxCount = 0\n   \
    \             }\n            }\n            if(!maxStr.isEmpty) {\n          \
    \      if(maxCount < nUniqueChar) {\n                    maxStr = \"\"\n     \
    \               maxCount = 0\n                }\n            }\n\n           \
    \ // update max string and count for current word\n            if(!maxStr.isEmpty)\
    \ {\n                if(maxCount < nUniqueChar) {\n                    maxStr\
    \ = \"\"\n                    maxCount = 0\n                }\n            }\n\
    \            if(!maxStr.isEmpty) {\n                if(maxCount < nUniqueChar)\
    \ {\n                    maxStr = \"\"\n                    maxCount = 0\n   \
    \             }\n            }\n            if(!maxStr.isEmpty) {\n          \
    \      if(maxCount < nUniqueChar) {\n                    maxStr = \"\"\n     \
    \               maxCount = 0\n                }\n            }\n\n           \
    \ // update max string and count for current word\n            if(!maxStr.isEmpty)\
    \ {\n                if(maxCount < nUniqueChar) {\n                    maxStr\
    \ = \"\"", "        val unique = words.distinct\n        val maxUnique = unique.toSet.size\n\
    \        val indexMap = new mutable.HashMap[Int, Int]()\n        words.length\
    \ match {\n            case 1 => return words(0)\n            case _ => {\n  \
    \              val uniqueMap = unique.toMap\n                for (word <- words)\
    \ {\n                    uniqueMap.foreach(x => {\n                        if\
    \ (x == word) {\n                            indexMap += (x -> 1)\n          \
    \              }\n                        else {\n                           \
    \ indexMap += (x -> indexMap.getOrElse(x, 0) + 1)\n                        }\n\
    \                    })\n                }\n                val maxVal = indexMap.maxBy(_._2)._2\n\
    \                val res = if (maxVal == uniqueMap.size) {\n                 \
    \   words(0)\n                } else if (maxVal > uniqueMap.size) {\n        \
    \            words(0)\n                } else if (maxVal == uniqueMap.size) {\n\
    \                    words(0)\n                } else {\n                    words(0)\n\
    \                }\n                return res\n            }\n        }", " \
    \     var maxCount = 0;\n      var currentWord = \"\"\n      for(word <- words)\
    \ {\n        // check if the current word has already been stored\n        if\
    \ (currentWord.length == 0) {\n          currentWord = word\n        } else {\n\
    \          // check if the current word contains all unique characters\n     \
    \     if (word.distinct.length == maxCount) {\n            // if it does\n   \
    \         if (word.distinct < currentWord) {\n              // check if it comes\
    \ first\n              currentWord = word\n            }\n          } else {\n\
    \            // if it doesn't\n            maxCount = word.distinct\n        \
    \    currentWord = word\n          }\n        }\n      }\n      return currentWord",
  "        val maxCount = words.foldLeft(0) { (maxCount, word) =>\n            val\
    \ uniqueCount = word.filter(_ != word).length\n            if (maxCount > uniqueCount)\
    \ maxCount else uniqueCount\n        }\n        val maxWords = words.filter(_\
    \ != words).sortWith(_.length < maxCount)\n        if (maxCount > maxWords.last.length)\
    \ maxWords.last else maxWords.head", '        words.toList.flatMap(_.toList).groupBy(_).maxBy(_.size).toList(0).getOrElse("No
    words")', "        val maxCharMap = new mutable.HashMap[Int, String]()\n     \
    \   words.foreach(word => {\n            word.foreach(char => {\n            \
    \    if (maxCharMap.contains(char)) maxCharMap(char) = word\n                else\
    \ maxCharMap(char) = 1\n            })\n        })\n        words.maxBy(maxCharMap.values.toList)",
  "        val wordCounts = words.map(word => word -> word.count(_ == 'a')).toMap\n\
    \        val max = wordCounts.maxBy(_._2)._1\n        wordCounts.filter { case\
    \ (word, count) => count == max }.toList.sortWith(_._1 < _._1).head", "      \
    \  var maxCount : Int = 1\n        var maxWord = \"\"\n        for (w <- words){\n\
    \            var count : Int = 1\n            w :+ count match {\n           \
    \     case word :: _ :: tail if word.forall(c => c != w(0)) => count = 1\n   \
    \             case _ => count = count + 1\n            }\n            if (count\
    \ > maxCount){\n                maxCount = count\n                maxWord = w\n\
    \            }\n        }\n        maxWord", "        val wordsWithCounts = words.foldLeft(Map[(String,\
    \ Int), String])(\n            (map, word) => map+(word -> (map.get(word).getOrElse(0)\
    \ += 1)))\n        val max = wordsWithCounts.maxBy(_._2)._2\n        wordsWithCounts.minBy(_._1)._2",
  "        var maxString : String = null\n        var maxCount = -1\n        for(word\
    \ <- words) {\n            if(maxCount == -1 || word.count(_ == maxCount) > 0)\
    \ {\n                maxCount = word.count(_ == maxCount)\n                maxString\
    \ = word\n            }\n        }\n        maxString", "        val wordCount\
    \ = words.size\n        var maxString = \"\";\n        var maxCount = 0;\n   \
    \     var currentCount = 0;\n        for(i <- 0 to wordCount - 1) {\n        \
    \    currentCount = words.count(x => x == words(i));\n            if(currentCount\
    \ > maxCount) {\n                maxCount = currentCount;\n                maxString\
    \ = words(i);\n            }\n        }\n        return maxString;", "       \
    \ // The variable \"max\" stores the maximum number of unique characters\n   \
    \     // present in the given words.\n        var max = words.length\n       \
    \ // The variable \"maxCount\" stores the number of occurrences of each\n    \
    \    // unique character. This variable is initialized to 0 for all unique\n \
    \       // characters.\n        var maxCount = 0\n        for (word <- words)\
    \ {\n            val chars = word.distinct\n            // Count the number of\
    \ occurrences of each unique character\n            var count = 0\n          \
    \  for (c <- chars) {\n                if (maxCount < count) {\n             \
    \       maxCount = count\n                    max = c\n                }\n   \
    \             count += 1\n            }\n        }\n        // Return the word\
    \ with maximum number of unique characters\n        if (maxCount == words.length)\
    \ max else words.head", "        val uniqueCount = mutable.Map[String, Int]()\n\
    \        words.foreach(word => {\n            uniqueCount += word -> word.length\n\
    \        })\n        var maxCount : Int = Integer.MIN_VALUE\n        var maxWord\
    \ : String = \"\"\n        var maxUniqueCharCount : Int = Integer.MIN_VALUE\n\
    \        uniqueCount.foreach(word => {\n            val count = uniqueCount(word)\n\
    \            if(count > maxCount && count > maxUniqueCharCount) {\n          \
    \      maxWord = word\n                maxCount = count\n                maxUniqueCharCount\
    \ = word.length\n            }\n        })\n        if(maxCount == maxUniqueCharCount)\
    \ {\n            maxWord\n        } else if(maxCount > maxUniqueCharCount) {\n\
    \            val sortedWords = uniqueCount.toSeq.sortBy(_._1).reverse\n      \
    \      sortedWords(0)._1\n        } else {\n            words.reverse.head.head\n\
    \        }", "        val unique = mutable.Set[Char]()\n        val characterMap\
    \ = mutable.Map[Char,Int]()\n\n        for (word <- words)\n        {\n      \
    \      val len = word.length()\n            for (i <- 0 until len)\n         \
    \   {\n                val c = word.charAt(i)\n                if (!unique.contains(c))\n\
    \                    unique += c\n                val count = characterMap.getOrElse(c,0)\n\
    \                characterMap += (c->count+1);\n            }\n        }\n   \
    \     if (characterMap.size >= unique.size)\n            characterMap.maxBy(_._2)(words)\
    \ else words.sorted", "        val unique = words.foldLeft(Map[Char,Int]())((m,w)\
    \ => m.updated(w.charAt(0),(m.getOrElse(w,0)) + 1))\n        unique.maxBy(unique.values)",
  "        val wordsMap : Map[String, Int] = words.toSet.map(word => (word, 1)).toMap\n\
    \        val sortedMap : Map[String, Int] = wordsMap.sortWith((word1, word2) =>\
    \ word1._2 > word2._2)\n        var maxCount : Int = 0\n        val maxCharMap\
    \ : Map[String, Int] = sortedMap.toList.sortWith((word1, word2) => word1._2 >\
    \ word2._2).map((_, 1)).toMap\n        var maxChar : String = \"\"\n        var\
    \ count = 0\n        for (key <- sortedMap) {\n            if (key._2 == maxCount)\
    \ {\n                maxChar = key._1\n            }\n            count += 1\n\
    \        }\n        if (maxCharMap.isEmpty) {\n            return \"NONE\"\n \
    \       }\n        if (maxCount > sortedMap.getOrElse(\"NONE\", 0)) {\n      \
    \      val keys = sortedMap.keySet\n            val vals = sortedMap.values.toList\n\
    \            if (vals.tail.lastOption.isDefined && vals.tail.lastOption.get.isDefined)\
    \ {\n                val max = vals.tail.lastOption.get\n                if (keys.get(keys.size\
    \ - 1) == max) {\n                    maxChar = keys.last\n                } else\
    \ {\n                    maxChar = keys.last\n                }\n            }\
    \ else {\n                maxChar = keys.last\n            }\n        } else {\n\
    \            maxChar = \"NONE\"\n        }\n        return maxChar", '        words.toList.map(_.toUpperCase).groupBy(_.size).maxBy(_._2)._1._1',
  "        // Write your code here\n        val map = scala.collection.mutable.Map(\"\
    a\" -> 1, \"b\" -> 2, \"c\" -> 2, \"d\" -> 3, \"e\" -> 3, \"f\" -> 3, \"g\" ->\
    \ 4, \"h\" -> 4)\n        words.foreach(word => {\n            val maxVal = map.get(word).fold(0){\
    \ (x, a) => x > a }\n            map += (word -> maxVal)\n        })\n\n     \
    \   val max = map.values.max\n        val min = map.values.min\n        val maxKey\
    \ = map.keys.max\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.keySet.max\n        val maxVal =\
    \ map.values.max\n\n        val minKey = map.keySet.min\n        val minVal =\
    \ map.values.min\n\n        val maxKey = map.key", "        val result = words.foldRight((\"\
    \",0)) ((word, (count, max) ) =>\n            val chars = word.distinct\n    \
    \        if(chars.length > max) ( word, chars.length)\n            else if(chars.length\
    \ == max) ( word, max)\n            else (word, chars.length)\n        )\n   \
    \     result._1", "        var maxIndex = 0\n        var maxValue = words(0)\n\
    \        var uniqueChars = Set.empty[Char]\n        var maxLen = 0\n        for\
    \ (word <- words) {\n            val chars = word.count\n            uniqueChars\
    \ = uniqueChars + chars\n            if (chars > maxLen) {\n                maxIndex\
    \ = words.index(words.length-1)\n                maxValue = word\n           \
    \     maxLen = chars\n            } else if (chars == maxLen) {\n            \
    \    if (chars > uniqueChars.size)\n                    maxValue = word\n    \
    \            maxIndex = words.index(words.length-1)\n                maxLen =\
    \ chars\n            }\n        }\n        return maxValue", "        var maximum\
    \ = words.head.filter(x => x.toString.length == words.head.size)\n        for\
    \ (i<-words.tail){\n            val l = i.toString.toList\n            var j =\
    \ maximum.toString.toList\n            for (x <- l){\n                if(!j.toList.contains(x)){\n\
    \                    j.toList += x\n                }\n            }\n       \
    \     maximum = j.sortWith((a, b) => a.compareTo(b))\n        }\n        maximum.toString.mkString",
  "        var max = \"\"\n        var maxCount = -1\n        for(word <- words){\n\
    \            val count = word.toString.count(_ == 'a')\n            if(count >\
    \ maxCount){\n                max = word\n                maxCount = count\n \
    \           }\n        }\n        return max", "        // Write your code here\n\
    \        var uniques = HashMap[Char,Int]()\n        var largest = 0\n        var\
    \ result = None\n        for(word <- words){\n            val uniqueCount = uniques.filter(_._1\
    \ == word(0)).map(_._2).reduceLeft((a, b) => math.max(a, b))\n            if(uniqueCount\
    \ > largest){\n                largest = uniqueCount\n                result =\
    \ word\n            }\n            uniques += (word(0) -> 1)\n        }\n    \
    \    if(result != None) result\n        else words.sortWith((w1, w2) => w1.length\
    \ < w2.length)", "        // Write your solution here\n        var maxCount =\
    \ 0\n        val wordsWithCounts = words.groupBy(_.length).sortBy(-_._2).map(x\
    \ => (x._1, x._2)).toList\n        val maxWord = wordsWithCounts.head._1\n   \
    \     val maxCount = wordsWithCounts.head._2\n        var found = false\n    \
    \    words.foreach(word => {\n            val thisCount = wordsWithCounts.filter(w\
    \ => w._2 == maxCount).size\n            if(!found && thisCount == maxCount &&\
    \ word < maxWord) {\n                found = true\n                maxWord = word\n\
    \            }\n        })\n        if(!found) {\n            wordsWithCounts.head._1\n\
    \        } else {\n            wordsWithCounts.sortBy(-_._2).head._1\n       \
    \ }", "        val wordCount = mutable.Map[String, Int]()\n        words.foreach(word\
    \ => wordCount(word) += 1)\n        val maxWord = wordCount.maxBy(_._2)\n    \
    \    if(wordCount.get(maxWord) > 1) {\n            wordCount.remove((maxWord))\n\
    \            wordCount.minBy(_._1)._1\n        }\n        else maxWord", "   \
    \     var characters = scala.collection.mutable.Map.empty[String, Int]\n     \
    \   var max = \"\"\n        var maxIndex = 0\n\n        for( word <- words){\n\
    \            var count = 0\n            for( char<- word){\n                if(characters.contains(char)){\n\
    \                    count += 1\n                }\n            }\n          \
    \  characters += (word -> count)\n        }\n\n        characters.foreach((k,v)\
    \ => {\n            if(v > max){\n                max = v\n                maxIndex\
    \ = k\n            }\n        })\n\n        words(maxIndex)", "      var maxCount\
    \ = 0\n      var maxWord = \"\"\n      for(word <- words) {\n        if(word.count(_).max\
    \ > maxCount) {\n          maxCount = word.count(_).max\n          maxWord = word\n\
    \        }\n      }\n      return maxWord", "        val uniqueCount = words.foldLeft(Map[Char,\
    \ Int]()) {\n            (accumulator, next) => \n                val numOccurences\
    \ = accumulator.getOrElse(next(0), 0) + 1\n                (next.toChar -> numOccurences)\n\
    \        }\n\n        val maxValues = uniqueCount.maxBy(_._2)\n\n        if (maxValues._2\
    \ == uniqueCount.getOrElse(maxValues._1, 0))\n            \"\"\n        else\n\
    \            maxValues._1", "        val maxCount = new mutable.HashMap[String,\
    \ Int]\n        for (word <- words) {\n            val uniqueCount = new mutable.HashSet[String]\n\
    \            for (letter <- word) {\n                if (!uniqueCount.contains(letter))\
    \ {\n                    uniqueCount.add(letter)\n                } else {\n \
    \                   uniqueCount.remove(letter)\n                }\n          \
    \  }\n            if (uniqueCount.size == word.length) {\n                if (uniqueCount.size\
    \ == 1) {\n                    maxCount.put(word, uniqueCount.size)\n        \
    \        } else {\n                    maxCount.put(word, uniqueCount.min.size)\n\
    \                }\n            }\n        }\n        maxCount.max.foreach(key\
    \ => {\n            val maxCount = maxCount.get(key)\n            val count =\
    \ maxCount.toString.toInt\n            if (count == maxCount.size) {\n       \
    \         println(key)\n            } else {\n                println(key + \"\
    :\" + count)\n            }\n        })\n        return words.max", "        val\
    \ unique = mutable.Set[Char]()\n        val charCount = words.map( word => word.count(_)).max\n\
    \        words.filter(word => word.count(_) == charCount).map( word => word).max",
  "        val map = scala.collection.mutable.Map[Char, Int]()\n        var max =\
    \ 0\n        for(s1 <- words) {\n            for(s2 <- words) {\n            \
    \    if(s1 === s2) {\n                    continue\n                }\n      \
    \          for(c1 <- s1.toCharArray) {\n                    val c2 = s2.toCharArray\n\
    \                    if(c2 == null) {\n                        map.delete(c1)\n\
    \                        map.putIfAbsent(c1, 0)\n                    } else {\n\
    \                        if(c1 == c2(c1)) {\n                            map.get(c1)\
    \ += 1\n                            map.putIfAbsent(c1, 0)\n                 \
    \           continue\n                        } else {\n                     \
    \       val count = map.get(c1)\n                            map.putIfAbsent(c1,\
    \ 0)\n                            map.putIfAbsent(c1, count + 1)\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n        map.foreach(x => if(x > max) max = x)\n        words.filter(_.toString.length\
    \ == max.toString).head", "        // TODO: Write your code here\n        var\
    \ maxCount = 0\n        var maxWord = \"\"\n        var maxWordIdx :Int = 0\n\
    \        var word = words.get(0) // Get the first word in the list.\n        for(i\
    \ <- 1 to words.size){\n            var wordCount = 0\n            var wordIdx\
    \ = 0\n            for(j <- 1 to words.size){\n                if(i != j){\n \
    \                   if(words.get(j).equals(word))\n                        wordCount\
    \ += 1\n                }\n            }\n            if(wordCount > maxCount){\n\
    \                maxCount = wordCount\n                maxWord = word\n      \
    \          maxWordIdx = i\n            }\n        }\n        maxWord", "     \
    \   val unique = new mutable.HashSet[String]\n        val result = scala.math.Ordering.natural().on\
    \ (_.length).reverse.compare(_, _)\n        val words = words.toSet\n        words.foreach(word\
    \ => {\n            val newWord = word.map {\n                char => char match\
    \ {\n                    case 'a' =>'A'\n                    case 'b' =>'B'\n\
    \                    case 'c' =>'C'\n                    case 'd' =>'D'\n    \
    \                case 'e' =>'E'\n                    case 'f' =>'F'\n        \
    \            case 'g' =>'G'\n                    case 'h' =>'H'\n            \
    \        case 'i' =>'I'\n                    case 'j' =>'J'\n                \
    \    case 'k' =>'K'\n                    case 'l' =>'L'\n                    case\
    \ 'm' =>'M'\n                    case 'n' =>'N'\n                    case 'o'\
    \ =>'O'\n                    case 'p' =>'P'\n                    case 'q' =>'Q'\n\
    \                    case 'r' =>'R'\n                    case 's' =>'S'\n    \
    \                case 't' =>'T'\n                    case 'u' =>'U'\n        \
    \            case 'v' =>'V'\n                    case 'w' =>'W'\n            \
    \        case 'x' =>'X'\n                    case 'y' =>'Y'\n                \
    \    case 'z' =>'Z'\n                    case _ =>'?'\n                }\n   \
    \         }\n            unique.addAll(newWord)\n        })\n        var max =\
    \ \"\"\n        unique.foreach(char => {\n            max = char + max\n     \
    \   })\n        if(unique.size == 0) max\n        else max", "        var max\
    \ = 0\n        var word = \"\"\n        for (str <- words){\n            val counts\
    \ = mutable.Map[Char, Int]()\n            for (word <- str) {\n              \
    \  if(counts(word.charAt(0)) isEmpty){\n                    counts(word.charAt(0))\
    \ = 1\n                }\n                else{\n                    counts(word.charAt(0))\
    \ = counts(word.charAt(0))+1\n                }\n            }\n            if(counts(_)\
    \ >= max){\n                max = counts(_)\n                word = str\n    \
    \        }\n        }\n        return word", "        var max = 0\n        var\
    \ maxWord = \"\"\n        var maxWordLength = 0\n        var i = 0\n        var\
    \ j = 0\n        val chars = scala.collection.mutable.HashSet[Char]()\n\n    \
    \    for(word <- words) {\n            for(char <- word) {\n                if(!chars.contains(char))\
    \ {\n                    chars += char\n                }\n            }\n\n \
    \           if(chars.size > max) {\n                max = chars.size\n       \
    \         maxWord = word\n                maxWordLength = word.length\n      \
    \      }\n            chars.clear()\n        }\n\n        if(chars.size > 0) {\n\
    \            chars.sortWith(_.compare(maxWord.charAt(0)) > 0)\n        }\n\n \
    \       return maxWord", "      val map = mutable.Map[String, Int]()\n      words.foreach{word\
    \ =>\n         word match {\n           case x if !map.contains(x) =>\n      \
    \       map.put(x, 1)\n           case x => \n             val currentCount =\
    \ map.getOrElse(x, 0)\n             val newCount = currentCount + 1\n        \
    \     map.put(x, newCount)\n         }\n      }\n      val max = map.maxBy(_._2)._1\
    \ // sort by descending number of unique chars\n      words.find(_ == max) //\
    \ return the word which appears first in lexicographical order", "        val\
    \ characterCounts = words.map(word => word.map(c => c).distinct).map(words =>\
    \ words.toSeq.toSet).map(words => words.map(_ => words.size)).toMap\n        var\
    \ max = characterCounts.keys.max\n        var maxChars = characterCounts.get(max)\n\
    \        var maxCharsIndex = 0\n        for (key <- characterCounts.keys) {\n\
    \            if (characterCounts.get(key) > maxChars) {\n                max =\
    \ key\n                maxChars = characterCounts.get(key)\n                maxCharsIndex\
    \ = characterCounts.keys.indexOf(key) + 1\n            }\n        }\n        characterCounts.keys.toList.take(maxCharsIndex).last",
  "        val wordsWithUniqueCharactersCount = words.map(x => x.toUpperCase().distinct.length).toSet.size\n\
    \        val maxString = words.sortWith(_.toUpperCase.distinct.length < _.toUpperCase.distinct.length).head\n\
    \        val maxStringWithUniqueCharactersCount = words.sortWith(_.toUpperCase.distinct.length\
    \ < _.toUpperCase.distinct.length).last\n        (maxString, maxStringWithUniqueCharactersCount)",
  "        var maxCount = 0\n        var maxWord = List[String]()\n        for (word\
    \ <- words) {\n            val count = countChars(word)\n            if (count\
    \ > maxCount) {\n                maxWord = word\n                maxCount = count\n\
    \            }\n        }\n        if (maxCount != 0) maxWord\n        else \"\
    \"", "        val result = mutable.HashMap.empty[String, Int]\n\n        words.foreach{w\
    \ => \n            val tmp = w.toSet.count\n            if(result.contains(w))\
    \ {\n                if(result(w) < tmp) {\n                    result(w) = tmp\n\
    \                }\n            } else result(w) = tmp\n        }\n\n        val\
    \ maxKey = result.maxBy(_._2)._1\n        val index = words.indexWhere{ w => w\
    \ == maxKey }\n        words(index)", "        val maxValues = words.foldLeft(Map[Char,\
    \ Int]()){\n            (acc, word) => acc + (word -> (acc(word) + 1))\n     \
    \   }\n        var max = 0\n        for (word <- words) {\n            if (maxValues(word)\
    \ > max) {\n                max = maxValues(word)\n            }\n        }\n\
    \        words.foldLeft((List[String](), max)) { (acc,word) => \n            if\
    \ (acc._2.contains(word._1)) {\n                acc match {\n                \
    \    case (list, max) => (word :: word, max)\n                    case (list,\
    \ max) => (word :: word, acc._2)\n                    case (list, max) => (word\
    \ :: acc, max)\n                }\n            } else {\n                (word\
    \ :: acc._1, acc._2)\n            }\n        }", "        val res = new scala.collection.mutable.HashSet[String]\n\
    \        words.foreach { word =>\n            if (res.contains(word)) res.remove(word)\n\
    \            else res += word\n        }\n        res.toList.sortWith(_ <- res.size,\
    \ _.compareTo(_) == 0).last", "        val wordSet = scala.collection.mutable.Set.empty[String]\n\
    \        wordList.foreach(word => {\n            val unique = word.map(i => i\
    \ -32).map(i => word.indexOf(i))\n            if (unique.length > wordSet.size)\
    \ {\n                wordSet = unique\n            }\n        })\n        wordSet.head",
  "        // (1) Create a map of each character to how many times that character\
    \ appears.\n        val map = words.foldLeft(Map[Char, Int]()) { (map, word) =>\
    \ \n            word.foreach(c => map += ((c, map.getOrElse(c, 0) + 1))) \n  \
    \      }\n        // (2) Get the maximum value from map.\n        val max = (map\
    \ map max _)\n        // (3) Return the corresponding key value pair.\n      \
    \  (map filter { case (_, value) => value == max } map { case (char, count) =>\
    \ char })", "        val wordList = words.toList\n        val map1 = wordList.foldLeft(Map[String,\
    \ Int]().withDefaultValue(0) { (map, word) =>\n            if (map.contains(word))\
    \ map else map + (word -> (map.getOrElse(word, 0) + 1)))\n        }\n        val\
    \ map2 = map1.groupBy(_._1).mapValues(_.length)\n        val maxKey = map2.maxBy(_._2)._1\n\
    \        wordList.find(w => w.startsWith(maxKey)).head", "        val map = words.map(w\
    \ => (w, w.length)).toMap\n        val count = words.map(w => map.getOrElse(w,0)).sum\n\
    \        val maxValue = words.filter( w => map.getOrElse(w,0) > count)\n     \
    \   if (maxValue.size > 1)\n            maxValue.reduce((a, b) => a.compareTo(b)\
    \ < 0) ? maxValue.getOrElse(maxValue.get(1)) : maxValue.getOrElse(maxValue.get(0))\n\
    \        else\n            maxValue.getOrElse(words.get(0))", "        val wordsSorted\
    \ = words.toList\n        wordsSorted.sortBy(x => x.length)\n        var maxWord\
    \ = wordsSorted.head\n        var maxCharCount = 0\n        for(word <- wordsSorted)\
    \ {\n            val count = word.groupBy(x => x).size\n            if(count >\
    \ maxCharCount) {\n                maxCharCount = count\n                maxWord\
    \ = word\n            }\n        }\n        maxWord", "        var maxCount =\
    \ 0\n        var maxWord = null\n        for(word <- words) {\n            var\
    \ count = word.distinct().length\n            if(count > maxCount) {\n       \
    \         maxCount = count\n                maxWord = word\n            }\n  \
    \      }\n        if(maxCount > 0) {\n            maxWord\n        } else {\n\
    \            \"no words with same number of unique characters\"\n        }", " \
    \       val result = new collection.mutable.ListBuffer[String]\n        for(w\
    \ <- words) {\n            val counters = w.distinct.groupBy(c => c).toSeq\n \
    \           val maxCounter = counters.maxBy(_._2)._1\n            val maxChar\
    \ = w.toSet.filter(c => c == maxCounter).head\n            result += ((maxCounter\
    \ + maxChar) ++ w)\n        }\n        \n        val list = result.toSeq\n   \
    \     if (list.size == 1) list.head else list.sortWith((a, b) => a > b)", "  \
    \      // Write your code here\n        var charCountMap = new HashMap[String,\
    \ Int]()\n        var maxCharCount = 0\n        for (w <- words){\n          \
    \  for (c <- w.toCharArray){\n                if (!charCountMap.contains(c)){\n\
    \                    charCountMap.put(c, charCountMap.getOrElse(c, 0) + 1)\n \
    \               }\n            }\n            if (charCountMap.getOrElse(w, 0)\
    \ > maxCharCount){\n                maxCharCount = charCountMap.getOrElse(w, 0)\n\
    \            }\n        }\n        charCountMap.foreach {\n            case (k,\
    \ v) => if (v == maxCharCount) k else \"\"\n        }\n        return \"\"", " \
    \       var res = \"\"\n        var count = words.foldLeft(Map[String, Int]())\
    \ {\n            case (acc: Map[String, Int], word : String)\n               \
    \ if (acc.contains(word)) acc ++ Map(word -> acc.get(word) + 1)\n            \
    \    else {\n                    acc + (word -> 1)\n                }\n      \
    \  }\n        var max = 0\n        words.foreach { word =>\n            if (count.contains(word))\
    \ {\n                if (count.get(word) > max) {\n                    max = count.get(word)\n\
    \                    res = word\n                }\n            }\n        }\n\
    \        res", "        var max = \"\"\n        var maxCount = 1\n        for\
    \ (str <- words) {\n            val c = str.toCharArray\n            val count\
    \ = c.length\n            if (count > maxCount) {\n                maxCount =\
    \ count\n                max = str\n            }\n        }\n        max", " \
    \       var max = 0\n        var i = 0\n        while(i < words.length) {\n  \
    \          val word = words(i)\n            val count = word.length\n        \
    \    val chars = word.toCharArray\n            val unique = chars.distinct\n \
    \           val uniqueSize = unique.size\n            if(uniqueSize > max) {\n\
    \                max = uniqueSize\n            }\n            i += 1\n       \
    \ }\n        words(0)", "        val maxKeyValMap : Map[Char, Int] = words.foldLeft(Map[Char,\
    \ Int]()) { case (acc, x) => acc ++ x.toCharArray.groupBy(_).mapValues(_.length).toMap\
    \ }\n        if (maxKeyValMap.size == 0) \"\"\n        else if (maxKeyValMap.size\
    \ > 1) maxKeyValMap.minKey() match {\n            case (k, v) => \"string\"\n\
    \        }\n        else maxKeyValMap.maxKey() match {\n            case (k, v)\
    \ => k\n        }", "        var max = 0\n        var word = \"\"\n        for\
    \ (word <- words) {\n            if (word.count(_ == 'a') > max) {\n         \
    \       max = word.count(_ == 'a')\n                word = word\n            }\
    \ else if (word.count(_ == 'a') < max) {\n                max = word.count(_ ==\
    \ 'a')\n                word = word\n            } else if (word.count(_ == 'a')\
    \ == max) {\n                var j = 0\n                for (i <- 0 until word.length)\n\
    \                    if (word.count(_ == 'a', i) > max) {\n                  \
    \      max = word.count(_ == 'a', i)\n                        word = word\n  \
    \                  }\n            }\n        }\n        return word", "      \
    \  val counts = words.map(word => count(word)).foldLeft(Map[String, Int]()) {\n\
    \            case (acc, current) => {\n                acc ++ current.toMap.map(_\
    \ -> 1)\n            }\n        }\n        val maxValue = counts.values.max\n\
    \        val maxKey = counts.keys.find(_ == maxValue)\n        val maxString =\
    \ if(maxKey.isEmpty) None else Some(words.find(w => count(w) == maxValue))\n \
    \       maxString.orElse(words.reverse.find(_ == maxValue))", '        // TODO:
    Write your solution', "        val map = mutable.LinkedHashMap[Char, Int]()\n\
    \        for (word <- words) {\n            val charCount = word.map(c => c).distinct.size\n\
    \            if (map.contains(charCount)) {\n                val value = map.getOrElse(charCount,\
    \ 0)\n                if (value < charCount) {\n                    map.clear()\n\
    \                }\n            }\n            map.update(charCount, charCount)\n\
    \        }\n        val maxValue = map.values.max\n        if (map.size == maxValue)\
    \ map.maxBy(_._1)._1\n        else if (maxValue > map.size) map.minBy(_._1)._1\n\
    \        else \"\"", "        var maxNum = 1\n        var result = \"\"\n    \
    \    for (word <- words) {\n            val characters = word.chars\n        \
    \    val uniqueChars = characters.distinct\n            val uniqueCharsCount =\
    \ uniqueChars.length\n            if (uniqueCharsCount > maxNum) {\n         \
    \       result = word\n                maxNum = uniqueCharsCount\n           \
    \ }\n        }\n        result", "        val result = new mutable.HashSet[Char]()\n\
    \        words.foreach(word => {\n            word.map(c => {\n              \
    \  if (!result.contains(c)) {\n                    result += c\n             \
    \   }\n            })\n        })\n        val max = Math.max(result.size, words.length)\n\
    \        if (result.size != max) {\n            val sortedWords = words.sortWith((a,\
    \ b) => a.size - b.size)\n            sortedWords(0)\n        } else {\n     \
    \       val sortedWords = words.sortWith((a, b) => a.compareTo(b) < 0)\n     \
    \       sortedWords(0)\n        }", "        var max: String = \"\"\n        var\
    \ maxCount: Int = 0\n        var newWords = words.toSet\n        for (word <-\
    \ newWords) {\n            if (word.length > (maxCount + 1)) {\n             \
    \   maxCount = word.length\n                max = word\n            }\n      \
    \  }\n        if (maxCount == words.length) {\n            maxCount = newWords.size\n\
    \            max = \"a\"\n        }\n        if (maxCount == newWords.size) {\n\
    \            newWords.find(word.toList.sorted.head == word.toList.sorted.last)\n\
    \        }", "        val hashSet = mutable.HashSet[String]()\n        words.map(x\
    \ => hashSet.add(x))\n        val max = hashSet.toList.sortWith(_ > _).head\n\
    \        max.head", "        val uniqueCount = mutable.HashMap.empty[String, Int]\n\
    \        words.foreach( word => {\n            val uniques = uniqueCount(word)\
    \ match {\n                case None =>\n                    uniqueCount += (word\
    \ -> 1)\n                case Some(count) => if (count > uniqueCount(word)) uniqueCount\
    \ += (word -> count) else ()\n            }\n        })\n        var max = 0\n\
    \        var maxWord = words.head\n        uniqueCount.foreach((word, count) =>\
    \ {\n            if (count > max) max = count\n            maxWord = word\n  \
    \      })\n        return maxWord", "       val charcount = mutable.Map[Char,\
    \ Int]()\n       for ( word <- words) {\n          var n = 0\n          for (c\
    \ <- word.charIterator.toList) {\n             val oldn = charcount(c)\n     \
    \        if (oldn == 0)\n                charcount(c) = n+1\n             else\n\
    \                 charcount(c) = oldn\n          }\n       }\n\n       val maxCount\
    \ = charcount.maxBy(_._2)\n       val maxKey = charcount.keys.toList.max\n   \
    \    val maxValues = charcount.values.toList.sortBy(_.toString.length)\n     \
    \  val maxValue = maxValues.max\n\n       println(s\"Max count of unique characters\
    \ ${maxCount}, max key ${maxKey}, max value ${maxValue}\")\n       maxKey.toString",
  "        words.foldLeft((List[String](), 0, 0)) { (temp, cur, i) =>\n          \
    \  val (max, num) = temp._2\n            if (num < max) {\n                (temp._1\
    \ :+ cur, num + 1, i)\n            } else if (num == max) {\n                (temp._1\
    \ :+ cur, i + 1, i)\n            } else {\n                (temp._1 :+ cur, max,\
    \ i)\n            }\n        }._1.head", "        val countMap = new mutable.HashMap[Int,\
    \ String]\n        for (word <- words) countMap += word.size -> word\n       \
    \ var max = -1\n        var result: String = null\n        for ( (k, v) <- countMap\
    \ ) {\n            if (v.length > max) {\n                result = v\n       \
    \         max = v.length\n            }\n        }\n        result", "       \
    \ var result : String = \"none\"\n        var max = 0\n        var maxCount =\
    \ 0\n        val chars = scala.collection.mutable.HashSet[String]()\n        words.foreach{w\
    \ => chars += w}\n        chars.foreach{c => {\n            if(charCount(c) >\
    \ maxCount) {\n                result = c\n                max = charCount(c)\n\
    \            }\n        }}\n        if(result == \"none\") {\n            result\
    \ = words.toList.head\n        }\n        result", "        val set = new mutable.HashSet[String]\n\
    \        for(word <- words){\n            if(set.contains(word)){\n          \
    \      set.update(word)\n            }\n            else{\n                set.add(word)\n\
    \            }\n        }\n        val maxCount = set.size\n        if(maxCount\
    \ > 1){\n            set.iterator.toList.sortBy(x => x.length).last\n        }\n\
    \        else{\n            set.iterator.toList.head\n        }", "        //\
    \ Code goes here\n        val uniqueChar = new mutable.HashSet[String]()\n   \
    \     words.foreach(word => {\n            uniqueChar.addAll(word.split(\"\").toList)\n\
    \        })\n        val sorted = uniqueChar.toList.sortWith((a, b) => a.compareTo(b)\
    \ == 0)\n        sorted.headOption", "        // write code here\n        val\
    \ set = Set[String]()\n        for (w <- words) {\n            val ch = w.toSet.toList\n\
    \            if (ch.size >= set.size) {\n                return w\n          \
    \  }\n            set ++= ch\n        }\n        return words.head", "       \
    \ val list = new scala.collection.mutable.ListBuffer[String]()\n        for (word\
    \ <- words) {\n            list.add(word)\n        }\n        if (list.size ==\
    \ 0) \"\"\n        else {\n            val res = list.foldLeft(List[String]())((acc,\
    \ word) =>\n                val count = acc.count(_ == word)\n               \
    \ if (count > 0) (word, count) else acc\n            )\n            res.sortWith(_.length\
    \ > _.length).head\n        }", "        var max: String = \"\"\n        var maxCount:\
    \ Int = 0\n        var newWords = words\n        while(newWords.length > 0) {\n\
    \            newWords = newWords.filter(word => word.isEmpty)\n            var\
    \ newCount: Int = 0\n            for (word <- newWords) {\n                var\
    \ counter = new mutable.HashSet[Char]()\n                for (char <- word.toCharArray)\
    \ {\n                    if (!counter.contains(char)) {\n                    \
    \    counter.add(char)\n                        newCount = newCount + 1\n    \
    \                }\n                }\n                if (newCount > maxCount)\
    \ {\n                    maxCount = newCount\n                    max = word\n\
    \                }\n            }\n            newWords = newWords.filter(word\
    \ => !word.isEmpty)\n        }\n        return max", "        var maxCount = 0\n\
    \        var maxWord = \"\"\n        var chars = \"\"\n        val wordCounts\
    \ = words.groupBy(w => w).toList\n\n        for (word <- words) {\n          \
    \  if (wordCounts(word).size > maxCount) {\n                maxCount = wordCounts(word).size\n\
    \                maxWord = word\n            }\n            chars += word.map(c\
    \ => c.toChar).distinct\n        }\n        maxWord", "        def findMax1(words1\
    \ : List[String], words2 : List[String]) : List[String] = {\n            if(words1.isEmpty){\n\
    \                return words2\n            }\n            if(words2.isEmpty){\n\
    \                return words1\n            }\n            val maxWord1 = words1.takeWhile(word\
    \ => !words2.contains(word)).iterator\n            val maxWord2 = words2.takeWhile(word\
    \ => !words1.contains(word)).iterator\n            if(maxWord1.equals(maxWord2)){\n\
    \                return findMax1(words1.dropWhile(word => !words2.contains(word)).iterator,\
    \ words2.dropWhile(word => !words1.contains(word)).iterator)\n            }\n\
    \            else{\n                val maxWord = maxWord1.concat(maxWord2)\n\
    \                return findMax1(words1.dropWhile(word => !maxWord.contains(word)).iterator,\
    \ words2.dropWhile(word => !maxWord.contains(word)).iterator)\n            }\n\
    \        }\n        val result = words.foldLeft(List[String]())((acc, x) => acc.head\
    \ == x.length ? acc :+ x.length)\n        val maxWord = result.max\n        if(maxWord\
    \ > result.head){\n            result.head\n        }\n        else{\n       \
    \     result.head\n        }", "        val map = mutable.HashMap[(List[String],\
    \ Int), String]()\n        for (word <- words) {\n            var count = 1\n\
    \            for(c <- word) {\n                map.getOrElseUpdate((List(c, word),\
    \ count), c)\n                count += 1\n            }\n        }\n        val\
    \ max = map.values.max\n        val minKey = map.keys.min\n        if (max > 1)\
    \ map[minKey]\n        else map.keys.sorted", "        var max = \"\"\n      \
    \  var maxNumber = 0\n        var count = 0\n        for(word <- words) {\n  \
    \          val length = word.length\n            var currentNumber = 0\n     \
    \       var currentWord = \"\"\n            for(c <- word) {\n               \
    \ currentNumber += 1\n                if((currentNumber == 1) || (length > currentNumber))\
    \ {\n                    currentWord = c\n                    currentNumber =\
    \ 1\n                }\n            }\n            count = count + 1\n       \
    \     if(length > maxNumber) {\n                max = word\n                maxNumber\
    \ = length\n            }\n        }\n        if(count > maxNumber) {\n      \
    \      max = max\n        }\n        return max", "        var max: String = \"\
    \"\n        var count = new mutable.Map[Char, Int]()\n        words.foreach(w\
    \ => {\n            w.toList\n            .map(c => c -> 1)\n            .foreach(pair\
    \ => count+=pair)\n        })\n        val maxKey = count.keys.max\n        if(count.contains(maxKey))\
    \ {\n            max = count.keys.find(c => c == maxKey)\n        } else {\n \
    \           max = \"\"\n        }\n        return max", "        var result =\
    \ List[String]()\n        var maxChar = 0\n        var maxWord = \"\"\n      \
    \  for(word <- words)\n            for(char <- word)\n                if(char\
    \ == 'a')\n                    maxChar = char\n                if(char == 'a'\
    \ && maxChar < char)\n                    maxChar = char\n            if(maxChar\
    \ != 0)\n                result ::= word\n        if(result.length == 0)\n   \
    \         return \"\"\n        if(result.length == 1)\n            return result(0)\n\
    \        var maxIndex = 0\n        for(i <- 0 until result.length)\n         \
    \   if(result(i) > result(i+1))\n                maxIndex = i\n        return\
    \ result(maxIndex)", "        val result = mutable.HashMap.empty[String, Int]\n\
    \        words.foreach { word =>\n            word.toList.toSet.foreach(x => result(x,\
    \ 1)) //result(x,1) means word has only one char\n        }\n        val maxKey\
    \ = result.maxBy(_._1)\n        val maxValue = result.getOrElse(maxKey, 0)\n \
    \       if (maxValue > 1) maxKey else \"\"", "        val maxList: mutable.List[String]\
    \ = new mutable.ListBuffer[String]\n        val list: List[String] = words.toList\n\
    \        for (str <- list) {\n            val uniqueChar = str.size\n        \
    \    if (uniqueChar > maxList.size) {\n                maxList += str\n      \
    \      } else {\n                val cur = maxList.iterator\n                if\
    \ (uniqueChar > cur._1.size) {\n                    maxList += str\n         \
    \       }\n            }\n        }\n        val minList: mutable.List[String]\
    \ = new mutable.ListBuffer[String]\n        for (str <- list) {\n            val\
    \ uniqueChar = str.size\n            if (uniqueChar < minList.size) {\n      \
    \          minList += str\n            } else {\n                val cur = minList.iterator\n\
    \                if (uniqueChar < cur._1.size) {\n                    minList\
    \ += str\n                }\n            }\n        }\n        (minList ++ maxList).sortWith(_\
    \ < _).last", "        val map = scala.collection.mutable.Map[String,Int]()\n\
    \        words.foreach(x => {\n            val value = map.getOrElse(x,0)\n  \
    \          val old = map.getOrElse(x,0)\n            map.put(x,value + 1)\n  \
    \          if(value > old) {\n                word = x\n            }\n      \
    \  })\n        words.find(x => x._1.length == words.map(x => x._1.length).max)",
  "        var res = \"\"\n        val counts = new mutable.HashMap[String, Int]()\n\
    \        for (wd <- words) {\n            var cnt = counts(wd)\n            if\
    \ (cnt == null) {\n                cnt = 1\n            } else {\n           \
    \     cnt = cnt + 1\n            }\n            counts.put(wd, cnt)\n        }\n\
    \        for (k <- counts.keySet) {\n            if (counts(k) > counts.getOrElse(k,\
    \ 0)) {\n                res = k\n            }\n        }\n        if (res ==\
    \ \"\") {\n            Console.err.println(\"No such word exists\")\n        \
    \    System.exit(-1)\n        }\n        res", "        val maxSizes = words.map(word\
    \ => (word, word.length)).toSet\n        words.map(word => (word, maxSizes(word))).sortBy(_._2).map(_._1).head",
  "        var maxCount = 0.0\n        var maxWord = \"\"\n        var wordsWithMaxCount\
    \ = mutable.Set[String]()\n        for (word <- words) {\n            var countOfWord\
    \ = word.distinct().length\n            if (countOfWord > maxCount) {\n      \
    \          maxCount = countOfWord\n                maxWord = word\n          \
    \  }\n            wordsWithMaxCount += word\n        }\n        if (wordsWithMaxCount.size\
    \ == 1) {\n            maxWord = wordsWithMaxCount.head\n        }\n        if\
    \ (maxCount == 0.0) {\n            return \"\"\n        }\n        wordsWithMaxCount.toList.sortBy(_.length).reverse.head",
  "        val map = new scala.collection.mutable.TreeMap[String, Int]()\n       \
    \ for (word <- words) {\n            val count = map.get(word).map(_ + 1)\n  \
    \          if (count.toInt > 1)\n                map.put(word, count.toInt)\n\
    \            else\n                map.put(word, count.toInt)\n        }\n   \
    \     val maxKey = map.maxKey\n        val maxValue = map.get(maxKey).getOrElse(0)\n\
    \        words.get(words.indexOf(maxKey))", "        def count(word : String,\
    \ count : Map[Char, Int]) : (Int, Char) = { \n            if (count.contains(char))\
    \ {\n                val count = count(word, count) + 1\n                val newCount\
    \ = mutable.Map(count + (char -> 1))\n                (count, char)\n        \
    \    }\n            else {\n                val count = mutable.Map(count + (char\
    \ -> 1))\n                (count.size + 1, char)\n            }\n        }\n\n\
    \        val maxCount = mutable.Map(0 -> 0)\n        val maxChar = scala.math.Ordering.Int.MinValue\n\
    \n        words.foreach(word => {\n            val count = mutable.Map[Char, Int]()\n\
    \            word.foreach(char => count(char, count))\n            if (count.size\
    \ > maxCount.size) {\n                maxCount = count\n                maxChar\
    \ = scala.math.Ordering.Int.MinValue\n            }\n        })\n\n        val\
    \ result = words.find(word => {\n            word.size == maxCount.size && count(word,\
    \ maxCount) >= maxCount\n        })\n\n        if (result != None) {\n       \
    \     result.head\n        }\n        else {\n            None\n        }", " \
    \       val uniqueCount = mutable.Map[Char,Int]()\n        var max = \"\"\n  \
    \      var maxCount = 0\n        for(word <- words){\n            for(char <-\
    \ word.toCharArray){\n                val count = uniqueCount(char) + 1\n    \
    \            uniqueCount(char) = count\n                if(count > maxCount){\n\
    \                    maxCount = count\n                    max = char\n      \
    \          }\n            }\n        }\n        max", "        val uniqueCharactersCount\
    \ = mutable.Map[String, Int]()\n        words.foreach{word =>\n            val\
    \ uniqueCharactersCount = word.distinct.length\n            uniqueCharactersCount(word)\
    \ = uniqueCharactersCount(word) + 1\n        }\n        val maxValue = uniqueCharactersCount.max\n\
    \n        val sortedWords = words.sortWith(_.length < maxValue)\n        val indexOfMaxValue\
    \ = sortedWords.indexOf(maxValue)\n\n        if (indexOfMaxValue < 0) {\n    \
    \        \"\"\n        } else {\n            sortedWords(indexOfMaxValue)\n  \
    \      }", "      val chars = mutable.HashSet[Char]()\n      val max = -math.pow(26,\
    \ words.length)\n      for (word <- words) {\n        for (c <- word.toCharArray)\
    \ {\n          if (!chars(c))\n            chars += c\n        }\n      }\n  \
    \    val maxChar = chars.max\n      if (maxChar == 0)\n        \"\"\n      else\n\
    \        chars.find(c => c == maxChar).orNull", "        val countMap = mutable.Map[Char,\
    \ Int]()\n        val sortedWords = words.toList.sortWith(\n            (a, b)\
    \ => b.length == a.length || (b.length == a(b.length).length)\n        )\n   \
    \     for (word <- sortedWords) {\n            for (chr <- word.toCharArray) {\n\
    \                if (countMap.get(chr) == null) {\n                    countMap.put(chr,\
    \ 1)\n                } else {\n                    countMap.get(chr) += 1\n \
    \               }\n            }\n        }\n        if (countMap.values.toSeq.max()\
    \ > 1) sortedWords.head\n        else sortedWords.last", "        var maxCount\
    \ = 0\n        var maxIndex = -1\n        for(res <- words) {\n            var\
    \ currentCount = 1\n            for(i <- 0 until res.length) {\n             \
    \   if(res.length(i) == res.count(_.equalsIgnoreCase(res.charAt(i)))) {\n    \
    \                currentCount += 1\n                }\n            }\n       \
    \     if(currentCount > maxCount) {\n                maxCount = currentCount\n\
    \                maxIndex = res\n            }\n        }\n        if(maxIndex\
    \ == -1) return \"\"\n        if(maxCount > 1) return maxIndex\n        else return\
    \ \"Unknow\"", "        var max = \"\"\n        var maxC = 0\n        for (word\
    \ <- words) {\n            val uniqueC = _.distinct\n            val c = _.distinct.length\n\
    \            if (c > maxC) {\n                maxC = c\n                max =\
    \ word\n            }\n        }\n        max", "        val map = mutable.Map[String,\
    \ Int]()\n        for (word <- words) map.update(word, map.getOrElse(word, 0)\
    \ + 1); \n        val max = map.maxBy(_._2)._1\n        words.reverse.find(_._2\
    \ == max).getOrElse(words.head)", "        val uniqueCharCounts = mutable.Map.empty[String,\
    \ Int]\n        val wordsWithMaxNumberOfUniqueCharacters = mutable.List.empty[String]\n\
    \        for (word <- words) {\n            for (c <- word.chars) {\n        \
    \        if (!uniqueCharCounts.contains(c)) {\n                    uniqueCharCounts\
    \ += ((c) -> 1)\n                } else {\n                    uniqueCharCounts(c)\
    \ += 1\n                }\n            }\n        }\n        if (uniqueCharCounts.values.toList.max\
    \ > 1) return wordWithMaxNumberOfUniqueCharacters(uniqueCharCounts)\n        else\
    \ wordsWithMaxNumberOfUniqueCharacters(uniqueCharCounts)(0)", "        val map\
    \ = words.foldLeft(Map[Int, String]())((map, word) =>\n            map + ((word.length\
    \ -> (word :: map.getOrElse(word.length, List())))))\n        map.values.toList.sortWith(_.length\
    \ < _.length).head.head", "        words.foldLeft(\"\"){(word, currentString)\
    \ =>\n            val unique = currentString.distinct\n            if (current.length\
    \ < unique.length) current else unique\n        }", "        var max = 0;\n  \
    \      var maxWord = \"\"\n        for(word <- words){ // iterating over each\
    \ words\n            var freq = words.filter(x => x == word).length; // count\
    \ the number of unique characters in that word\n            if(freq > max){ //\
    \ if the count of unique characters is greater than the max so far\n         \
    \       max = freq; // make max equal to count of unique characters for this word\n\
    \                maxWord = word; // make maxWord the word with maximum number\
    \ of unique characters\n            }\n        }\n        return maxWord", " \
    \       val set = mutable.LinkedHashSet[String]()\n        for(word <- words){\n\
    \            for(char <- word.chars){\n                if(set.contains(char)){\n\
    \                    set.remove(char);\n                }else{\n             \
    \       set.add(char);\n                }\n            }\n        }\n        if(set.size\
    \ == words.size){\n            set.max\n        }else{\n            set.min\n\
    \        }", "        var maxCount = 0\n        var maxIndex = -1\n        for\
    \ (i <- 0 until words.length) {\n            val count = mutable.ListBuffer.empty[Char]\n\
    \            for (j <- 0 until words(i).length) {\n                count += words(i)(j)\n\
    \            }\n            if (count.length >= maxCount) {\n                maxCount\
    \ = count.length\n                maxIndex = i\n            }\n        }\n   \
    \     if (maxIndex >= 0) {\n            val sortedWords = words.map(x => (x, x.length))\n\
    \                .sortWith(x => (x._2, x._1))\n            sortedWords.head._1\n\
    \        } else {\n            words.head\n        }", "        val map = mutable.Map[Char,\
    \ Int]()\n        words.foreach{ word =>\n            for (c <- word.toCharArray())\
    \ {\n                val count = map.getOrElse(c, 0)\n                map.update(c,\
    \ count + 1)\n            }\n        }\n\n        val maxCounts = map.values.max\n\
    \        val maxKey = map.keys.max\n        words.find(word => maxCounts(word)\
    \ == maxCounts(maxKey))", "        val counts = new mutable.HashMap[String, Int]()\n\
    \        words.foreach(word => {\n            val count = (word, counts.getOrElse(word,\
    \ 0) + 1)\n            counts.put(word, count)\n        })\n        var max =\
    \ \"\"\n        for(entry <- counts.entrySet().sortWith(_.count < _.count))\n\
    \            max = entry.get._1 if (entry.get._2 > counts.getOrElse(max, 0))\n\
    \        counts.getOrElse(max, 0)", "        val counts = words.map{x => x.count('a')}.sortBy(-_)\n\
    \        counts(0)"]
stop_tokens:
- "\n    }\n"
