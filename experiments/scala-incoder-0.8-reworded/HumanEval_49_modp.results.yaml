language: scala
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if(n <= p) return n\n        var result : Long = 0\n   \
    \     var divisor : Long = p\n        while(divisor > 1l) {\n            result\
    \ += (n >>> 1) % divisor\n            divisor >>= 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3olfpzi3.scala:27)\n\tat Problem.main(tmp3olfpzi3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (p == 0 || n == 0) 0\n        else n ^ ((n&p)-1)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1jzv0y3.scala:21)\n\tat Problem.main(tmpj1jzv0y3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = n % p\n        if (result < 0)\n          \
    \  result += p\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxwbtc595.scala:23)\n\tat Problem.main(tmpxwbtc595.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val x = n >>> 0\n        val y = p >>> 0\n        while\
    \ (x >= y) {\n            x = (x & y) | (~x & -y)\n        }\n        if (x !=\
    \ 0L)\n            1L << x\n        else\n            -1L\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpus1ndl3l.scala:19:14 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            x = (x & y) | (~x & -y)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010145
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = n % p\n        if (a < p) p * 2 - a + 1 else a\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphghpfkaf.scala:20)\n\tat Problem.main(tmphghpfkaf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def mod2(n: Long, d: Long) : Long = {\n            val q:\
    \ Long = (n % d).toInt\n            n / d\n        }\n\n        // Calculate d's\
    \ square root modulo p\n        // by dividing by (p - 1) until\n        // we\
    \ get an integral quotient.\n        val d: Long = p - 1\n        var d: Long\
    \ = 0\n        while ((n % d) != 0) {\n            d = mod2(n, d)\n        }\n\
    \n        // Now d is between 0 and p-1\n        // We can get the square root\
    \ of the number by using the modulo operator\n        var sqroot: Long = n\n \
    \       while (!(n % d)) {\n            n /= d\n            sqroot = n\n     \
    \   }\n\n        // Return the square root modulo p as a long\n        sqroot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpupkm8n49.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36md\e[0m: \e[35mLong\e[0m\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpupkm8n49.scala:27:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            d = mod2(n,\
    \ d)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \          Reassignment to val d\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpupkm8n49.scala:33:15 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m        \e[33mwhile\e[0m (!(n % d)) {\n\e[31m\e[31m   |\e[0m              \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m      value unary_! is not a member of Long -\
    \ did you mean Long.unary_+?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpupkm8n49.scala:34:14\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            n /= d\n\e[31m\e\
    [31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value /= is not\
    \ a member of Long - did you mean n.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var modP = BigInteger.ZERO\n        while(modP.compareTo(p)\
    \ >= 0) {\n            modP = modP.multiply(p)\n        }\n        return modP.mod(p)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpidlxhh.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mmodP\e[0m = BigInteger.ZERO\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \              Not found: BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val s = 1l\n        val result = 1l\n        while (n >\
    \ 1l) {\n            val temp = n % p\n            n -= temp\n            result\
    \ += temp\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6jwd3y7.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            n -= temp\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of Long -\
    \ did you mean n.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6jwd3y7.scala:21:19\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            result += temp\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Long - did you mean result.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1\n        while (res <= n) {\n            res\
    \ = (res * res) % p\n        }\n        if (res == n) {\n            res = 1\n\
    \        }\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_atou1ke.scala:18:18\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            res = (res * res)\
    \ % p\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Found:    Long\n\e[31m   |\e[0m                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0L)\n            return 0L\n        val res = n\
    \ % p\n        if (res == 0L)\n            return n\n        res + (p - res)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzz8cvuv6.scala:24)\n\tat Problem.main(tmpzz8cvuv6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = 2l\n        val res = 1l\n        while (m <= n)\
    \ res = (res*m) % p\n        res % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpcds4herq.scala:18:27 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mwhile\e[0m (m <= n) res = (res*m) % p\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       Reassignment to val res\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        for (i <- 2 to math.pow(2,\
    \ math.floor(math.log(n, 2))))\n        {\n            result *= 2\n         \
    \   result %= p\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd_eq4p1p.scala:17:55\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m2\e[0m to math.pow(\e[31m2\e[0m, math.floor(math.log(n, \e[31m2\e[0m))))\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    (Long, Int)\n\e[31m   |\e[0m                                            \
    \       Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var m : Long = 0\n        while (n >= p) m = p; m := m +\
    \ (n % p)\n        m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcdkc_7uv.scala:17:32 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mwhile\e[0m (n >= p) m = p; m := m + (n\
    \ % p)\n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m \
    \  |\e[0m                value := is not a member of Long - did you mean Long.!=?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = n & (p - 1L);\n        while (n > 0L && res <\
    \ p) { res = res + 1L; n /= 2L; }\n        n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpswh86zn2.scala:17:54 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mwhile\e[0m (n > \e[31m0L\e[0m && res <\
    \ p) { res = res + \e[31m1L\e[0m; n /= \e[31m2L\e[0m; }\n\e[31m\e[31m   |\e[0m\
    \                                                    ^^^^\e[0m\n\e[31m   |\e[0m\
    \                   value /= is not a member of Long - did you mean n.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // 2^n modulo p\n        var result : Long = scala.math.pow(2,\
    \ n)\n        val mask : Long = p^result\n        result = result*mask & p\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpthpke3qn.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mresult\e\
    [0m : \e[35mLong\e[0m = scala.math.pow(\e[31m2\e[0m, n)\n\e[31m\e[31m   |\e[0m\
    \                            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      Found:    Double\n\e[31m   |\e[0m                     \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            return 1l\n        } else if\
    \ (n <= p) {\n            return 1l\n        } else if (n < p) {\n           \
    \ return 1l + (n - p)\n        }\n        val a = n.toInt\n        val r = a %\
    \ p\n        r + (if (a == p) 0 else p - r)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpikvw8vq1.scala:28)\n\tat Problem.main(tmpikvw8vq1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var bits = n.toInt\n        var rem = n % p\n        while\
    \ (bits and rem != 0) {\n            bits -= 1;\n            rem += p\n      \
    \  }\n        bits += rem\n        if (bits > 0)\n            bits += p\n    \
    \    bits\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg_sl57x0.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mwhile\e[0m (bits and rem != \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \         value and is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpg_sl57x0.scala:22:13 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        bits += rem\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpg_sl57x0.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            bits += p\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        while(n > result) {\n   \
    \         result += (n % result)\n            n /= result\n        }\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxnlv8xfl.scala:19:14 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            n /= result\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member of Long\
    \ - did you mean n.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if( n.toInt < p.toInt) 1l + (n % p).toInt\n        else\
    \ n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt_uo_4yv.scala:20)\n\tat Problem.main(tmpt_uo_4yv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def mod(n : Long, p : Long) : Long = {\n            val\
    \ m = math.abs(n) % p\n            if (m == 0) n else m\n        }\n        mod(n,\
    \ p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppl8e95td.scala:24)\n\tat Problem.main(tmppl8e95td.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var result = n\n      while(result > p) {\n        result\
    \ = result % p\n      }\n      result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfglyrhb5.scala:24)\n\tat Problem.main(tmpfglyrhb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) throw new IllegalArgumentException\n        if\
    \ (p < 1) throw new IllegalArgumentException\n        if (p.compareTo(0l) < 0)\
    \ throw new IllegalArgumentException\n        var result = 1l\n        while (n\
    \ > 1) {\n            if (p.compareTo(n) < 0) {\n                result = result\
    \ * p\n                if (n != 0l)\n                    result %= n\n       \
    \     }\n            n -= 1\n            p = p / 2l\n        }\n        if (n\
    \ != 0l)\n            result %= n\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3yep5gnm.scala:26:14 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            n -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of\
    \ Long - did you mean n.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3yep5gnm.scala:27:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            p = p /\
    \ \e[31m2l\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val p\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1 else if (n % p == 0) n % p else n % p + modp(n-n,\
    \ p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4_xqtk3z.scala:19)\n\tat Problem.main(tmp4_xqtk3z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        require(n > 0 && p > 0, \"modp requires n and p > 0\")\n\
    \        var n2 = n % p\n        if (n2 < 0) { n2 = p + n2 }\n        n / p2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3d2t4oy9.scala:19:12 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        n / p2\n\e[31m\e[31m   |\e[0m            ^^\e\
    [0m\n\e[31m   |\e[0m            Not found: p2\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n % p == 0) n else n - (n % p)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp46e_18rw.scala:19)\n\tat Problem.main(tmp46e_18rw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val s = modPow(2, n, p)\n        val t = s % p\n       \
    \ if (t == 0)\n            s\n        else\n            s\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt6bmoygi.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = modPow(\e[31m2\e\
    [0m, n, p)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Not found: modPow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val x = n % p;\n        if(x == 0) 1l else x\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzc51yqjz.scala:21)\n\tat Problem.main(tmpzc51yqjz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0L)\n            return n\n        else\n     \
    \       if (p == 0)\n                return 1L\n            else\n           \
    \     if (p < n)\n                    modp(n - 1, p-1)\n                else if\
    \ (p > n)\n                    modp(n, p % n)\n                else\n        \
    \            modp(n + (p - (n % p)) % n, p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ylmv5nk.scala:30)\n\tat Problem.main(tmp9ylmv5nk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q : Long = BigInteger(n)\n        val r : Long = BigInteger(p)\n\
    \        // TODO: implement modp with BigInteger.\n        val qBig = BigInt(q)\n\
    \        val rBig = BigInt(r)\n        BigInt(qBig modPow BigInt(rBig))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpphfadqam.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m : \e[35mLong\e[0m\
    \ = BigInteger(n)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: BigInteger\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpphfadqam.scala:17:23 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m : \e[35mLong\e[0m\
    \ = BigInteger(p)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: BigInteger\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpphfadqam.scala:21:27 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        BigInt(qBig modPow BigInt(rBig))\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mobject\e[0m \e[35mBigInt\e\
    [0m with types\n\e[31m   |\e[0m (x: java.math.BigInteger): BigInt\n\e[31m   |\e\
    [0m (x: String, radix: Int): BigInt\n\e[31m   |\e[0m (x: String): BigInt\n\e[31m\
    \   |\e[0m (numbits: Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (bitlength:\
    \ Int, certainty: Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (signum:\
    \ Int, magnitude: Array[Byte]): BigInt\n\e[31m   |\e[0m (x: Array[Byte]): BigInt\n\
    \e[31m   |\e[0m (l: Long): BigInt\n\e[31m   |\e[0m (i: Int): BigInt\n\e[31m  \
    \ |\e[0mmatch arguments ((rBig : BigInt))\n3 errors found\n"
  stdout: ''
  timestamp: 1660010157
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def pow(i : Long, d : Long) : Long = {\n            if (i\
    \ >= d) {\n                return 1l\n            } else if (i == d) {\n     \
    \           return 1l\n            } else {\n                return i * pow(i\
    \ , d-1)\n            }\n        }\n        pow(n, p.toLong).toLong % p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph_cu2is_.scala:28)\n\tat Problem.main(tmph_cu2is_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val ans = n\n        while (ans > p) {\n            ans\
    \ = ans % p\n        }\n        ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpsykq7808.scala:18:16 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            ans = ans % p\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val ans\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n = n.toInt\n        val p = p.toInt\n        val result\
    \ = n.toLong\n        while (n > 0) {\n            result %= p\n            n\
    \ -= 1\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp06swk2rj.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp06swk2rj.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val pow = pow(n, p)\n        val mod = pow % p\n       \
    \ if (mod < 0) mod+p\n        else mod\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfc2h3_k3.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpow\e[0m = pow(n, p)\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35mpow\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n % p\n        if (r == 0)\n            r\n    \
    \    else\n            modp(n, p - r)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwk4hrza1.scala:23)\n\tat Problem.main(tmpwk4hrza1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if(n == 0)\n            return 1l\n        if(n == p)\n\
    \            return n\n        val x = scala.math.pow(n, (-1l))\n        val y\
    \ = scala.math.mod(x, p)\n        if(x == 0)\n            return y\n        val\
    \ z = scala.math.mod(y, p)\n        if(z == 0)\n            return y\n       \
    \ if(z < p)\n            return modp(z, p)\n        modp(y, p)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplmnb6f5x.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = scala.math.mod(x,\
    \ p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmplmnb6f5x.scala:24:27 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mz\e[0m = scala.math.mod(y, p)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          value mod is not a member of math\n2 errors found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Convert n and p to BigDecimal\n        val bn = BigDecimal(n);\n\
    \        val bp = BigDecimal(p);\n\n        // Multiply by the mod power of bp\
    \ and subtract from b.\n        val b = bn.multiply(BigDecimal(\"%\").multiply(bp)).subtract(BigDecimal(\"\
    0\"));\n\n        // Truncate to Long\n        val ln = b.intValue().toLong;\n\
    \n        // Return Long\n        return ln\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpziwix6mu.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = bn.multiply(BigDecimal(\e\
    [31m\"%\"\e[0m).multiply(bp)).subtract(BigDecimal(\e[31m\"0\"\e[0m));\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ value multiply is not a member of BigDecimal\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpziwix6mu.scala:21:44 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = bn.multiply(BigDecimal(\e[31m\"\
    %\"\e[0m).multiply(bp)).subtract(BigDecimal(\e[31m\"0\"\e[0m));\n\e[31m\e[31m\
    \   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                            value multiply is not a member of BigDecimal\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = n - p;\n        if (d < 0l)\n            throw new\
    \ ArithmeticException(\"modp failed: negative operands \" + n + \" and \" + p);\n\
    \        if (d == 0l)\n            return n;\n        val m = (1l << d) - 1l;\n\
    \        if (m < p) // not in the domain\n            throw new ArithmeticException(\"\
    modp failed: no such exponent \" + d + \" modulo \" + p);\n        return m;\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: modp failed: negative operands 3 and 5\n\
    \tat Problem$.modp(tmpvy4kk_kc.scala:18)\n\tat Problem$.main(tmpvy4kk_kc.scala:27)\n\
    \tat Problem.main(tmpvy4kk_kc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val z = n % p\n        if (z == 0) {\n            return\
    \ n\n        } else {\n            return z\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp83ui3ym9.scala:25)\n\tat Problem.main(tmp83ui3ym9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        while (n > p) {\n       \
    \     if (n >= p) {\n                result += 1\n                n -= p\n   \
    \         }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgfbwn0d.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                n -= p\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a member of\
    \ Long - did you mean n.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = 1L\n        res *= n\n        res %= p\n     \
    \   res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpanamgo8u.scala:17:12 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        res *= n\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value *= is not a member of Long - did you mean res.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpanamgo8u.scala:18:12 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        res %= p\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value %= is not a member of Long - did you mean res.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val t = math.pow(n.toLong, p.toLong)\n        t.mod(p).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfjgog34w.scala:17:10 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        t.mod(p).toLong\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^\e[0m\n\e[31m   |\e[0m        value mod is not a member of Double\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        for(i <- 1l until n.toInt) {\n     \
    \       r = (r * p) % n\n        }\n        if(r > n)\n            (n-r)\n   \
    \     else\n            r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpilmzwdnh.scala:26)\n\tat Problem.main(tmpilmzwdnh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = n.toDouble\n        val e = p.toDouble\n       \
    \ val q = d.quot(e)\n        return q * (p / q)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqwpgj6fe.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = d.quot(e)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0mvalue quot is not a member\
    \ of Double, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.BigDecimal.double2bigDecimal\n\e[31m   |\e[0m\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = math.min(p.abs,n.abs)\n        val result = n %\
    \ m\n        if (result < 0) -result else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp18woyyat.scala:21)\n\tat Problem.main(tmp18woyyat.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = n % p\n        while (r != 0) {\n            r =\
    \ (r + p) % p\n        }\n        r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // TODO Implement this function.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1dgh11fy.scala:15:42\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m    \e[33mdef\e[0m \e[36mmodp\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m, \e[36mp\e[0m : \e[35mLong\e[0m) : \e[35mLong\e\
    [0m = {\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                          Found:    Unit\n\e[31m\
    \   |\e[0m                                          Required: Long\n\e[31m16 |\e\
    [0m        \e[34m// TODO Implement this function.\e[0m\n\e[31m17 |\e[0m    }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if((n & (n-1)) == 0) (n + p) % p\n        else modp(n/2,\
    \ p) % (p*2)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzd2r4yft.scala:20)\n\tat Problem.main(tmpzd2r4yft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val pow = math.pow(n, 2)\n        math.modf(pow)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl03vzj72.scala:17:13 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        math.modf(pow)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value modf is not a member of math\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1l else (2l*((n % p) + p - 1) + (n % p))\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjpjtsqpa.scala:19)\n\tat Problem.main(tmpjpjtsqpa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010167
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        return ((n.toLong + p.toLong) % p.toLong).toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpov8tjkww.scala:20)\n\tat Problem.main(tmpov8tjkww.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010166
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = 1\n        for(i <- 1 until n) {\n        \
    \    result *= p\n            result %= p\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgq_jc48d.scala:17:25\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m1\e[0m until n) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e\
    [31m   |\e[0m                         Found:    (n : Long)\n\e[31m   |\e[0m  \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgq_jc48d.scala:18:19 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            result *= p\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Int -\
    \ did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgq_jc48d.scala:19:19\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            result %= p\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ %= is not a member of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010168
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modpMod2(n : Long, p : Long) : Long = {\n          \
    \  // The magic number in modular arithmetic: x^n mod p\n            val q = ((p\
    \ * n) % p).toLong\n            n - (q * (q % p))\n        }\n\n        if (n\
    \ == 0l) return 1l\n        if (p == 0l) return 0l\n\n        // The base case:\
    \ the exponent must be less than or equal to the\n        // modulus \"p\".\n\
    \        if (n < p)\n            modpMod2(n,p)\n\n        // The recursive case:\
    \ we must take \"p\" digits out of \"n\" digits.\n        val rem = modpMod2(n,p)\n\
    \        if ((rem == 0l) && ((rem % p) == 0l)) {\n            // We must not take\
    \ 0 digits out of \"n\" digits.\n            rem + 1\n        } else {\n     \
    \       // We must take \"p\" digits out of \"n\" digits.\n            (rem) %\
    \ p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8swn42mf.scala:42)\n\tat Problem.main(tmp8swn42mf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010168
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def mod2(a : Long) : Long = (a%p)*(a%p)\n        def mod3a(a1\
    \ : Long) : Long = (101l % a1)\n        def mod3(a1 : Long) : Long = mod3a(a1)\
    \ + mod2(a1)\n        def mod4(a1 : Long) : Long = mod3(a1) ^ mod2(a1)\n     \
    \   val l = ((n%p)*(n%p)) % p\n        if (l == 0)\n            1\n        else\n\
    \            mod4(l) * mod3(n)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp65y7f95l.scala:27)\n\tat Problem.main(tmp65y7f95l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = BigDecimal(n).mod(BigDecimal(p))\n        val s\
    \ = m.toDouble\n        val e = 1l\n        // If s is an integer and e is even,\n\
    \        // then n is in the form p * 2^e * 2^(n/e)\n        if ((s % e == 0)\
    \ && BigInt(s) % 2 == 0) else BigInt(s * e)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpesq_fzu5.scala:21:48 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m ((s % e == \e[31m0\e[0m) && BigInt(s)\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) \e[33melse\e[0m BigInt(s * e)\n\e[31m\e[31m\
    \   |\e[0m                                                ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                       'then' expected, but 'else' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpesq_fzu5.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = BigDecimal(n).mod(BigDecimal(p))\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \ value mod is not a member of BigDecimal - did you mean BigDecimal.max?\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpesq_fzu5.scala:22:4 -----------------\e\
    [0m\e[0m\n\e[33m21 |\e[0m        \e[33mif\e[0m ((s % e == \e[31m0\e[0m) && BigInt(s)\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) \e[33melse\e[0m BigInt(s * e)\n\e[33m22 |\e\
    [0m    }\n\e[33m\e[33m   |\e[0m                                              \
    \                    ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in\
    \ statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val p = p.toInt\n        val n = n.toInt\n        val r\
    \ : Long = Math.pow(2l, n % p)\n        r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdbm5cuqy.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpdbm5cuqy.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpdbm5cuqy.scala:18:31 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m : \e[35mLong\e[0m = Math.pow(\e\
    [31m2l\e[0m, n % p)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    Double\n\e[31m   |\e[0m \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val nBits = n.bitLength\n        val pBits = p.bitLength\n\
    \        var rem = 0L\n        var i = 0\n        while (i < nBits || rem < pBits)\
    \ {\n            val a = if (i < nBits) n else (rem & p)\n            val b =\
    \ if (rem < pBits) rem.pow(i) else (rem & p).pow(i)\n            val res = a *\
    \ b\n            rem += res\n            i += 1\n        }\n        rem\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16smkvwk.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnBits\e[0m = n.bitLength\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ bitLength is not a member of Long, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16smkvwk.scala:17:22\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mpBits\e[0m = p.bitLength\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue bitLength is not a member of Long, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following\
    \ import might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16smkvwk.scala:22:41\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m\
    \ \e[36mb\e[0m = \e[33mif\e[0m (rem < pBits) rem.pow(i) \e[33melse\e[0m (rem &\
    \ p).pow(i)\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pow is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp16smkvwk.scala:22:63 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mb\e[0m = \e[33mif\e\
    [0m (rem < pBits) rem.pow(i) \e[33melse\e[0m (rem & p).pow(i)\n\e[31m\e[31m  \
    \ |\e[0m                                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue pow is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import "
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n >= p) n % p else n % p + p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpruif81wd.scala:19)\n\tat Problem.main(tmpruif81wd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (p mod n) match {\n            case 0 => n\n           \
    \ case 1 => p\n            case _ => (p mod n) match {\n                case 0\
    \ => n\n                case 1 => p\n                case _ => p % n\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_ydlap5.scala:16:11 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        (p mod n) \e[33mmatch\e[0m {\n\e[31m\e[31m  \
    \ |\e[0m         ^^^^^\e[0m\n\e[31m   |\e[0mvalue mod is not a member of Long,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7_ydlap5.scala:19:25 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m _ => (p mod n) \e[33mmatch\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ mod is not a member of Long, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val result = n\n        var i = 1\n        while (i <= p)\
    \ {\n            if (n % i == 0) {\n                result = result - n%i\n  \
    \          }\n            i += 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp149je8jn.scala:20:23 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result = result - n%i\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010168
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val ret = scala.math.BigInt(n).mod(p)\n        if(ret ==\
    \ 0)\n            ret.longValue()\n        else\n            ret.longValue()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp70_pkv30.scala:24)\n\tat Problem.main(tmp70_pkv30.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n = n\n        val p = p\n\n        val x = BigInteger.valueOf(n)\n\
    \        val y = BigInteger.valueOf(p)\n\n        val q = x.mod(y)\n        if\
    \ (q.signum < 0)\n            q.add(BigInteger.ONE)\n        q\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsh5phzi4.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpsh5phzi4.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e\
    [0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsh5phzi4.scala:19:16 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mx\e[0m = BigInteger.valueOf(n)\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsh5phzi4.scala:20:16\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36my\e[0m = BigInteger.valueOf(p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: BigInteger\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010168
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val x = n.toDouble\n        val y = p.toDouble\n       \
    \ val r = scala.math.mod(x,y)\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp78envlm5.scala:18:27 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(x,y)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = n.toInt\n        val b = p.toInt\n        if (a\
    \ < 0 || b < 0) 0\n        else b * a * ModPow(b, a)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzreaclg_.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m b * a * ModPow(b, a)\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \      Not found: ModPow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010168
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      val (x, y) =  n.divmod(p)\n      y + (x % p) match {\n   \
    \     case 0    => 0\n        case n    => n\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpubokkjwh.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      \e[33mval\e[0m (x, y) =  n.divmod(p)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      value divmod is not a member of Long\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpubokkjwh.scala:16:11 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m      \e[33mval\e[0m (x, y) =  n.divmod(p)\n\e[31m\e[31m   |\e[0m    \
    \       ^\e[0m\n\e[31m   |\e[0m           Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpubokkjwh.scala:16:14\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m      \e[33mval\e[0m (x,\
    \ y) =  n.divmod(p)\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m\
    \              Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0)\n            return 1\n        if (n == 1)\n\
    \            return p\n        if (n < p)\n            return modp(n - 1, p) %\
    \ p\n        return (n % p + modp((n - 1) % p, p)) % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_j0felep.scala:25)\n\tat Problem.main(tmp_j0felep.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      val x = 2\n      val y = p // p is odd, so (p - 1) must be\
    \ even and will overflow\n      val z = (n - 1) * (x + y) //(x * y) mod p\n  \
    \    // z mod p is still > p but is closer than x - y\n      // So we just have\
    \ to add one more.\n      val m = z + p + 1\n      if (m < n)\n        m\n   \
    \   else\n        x\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppgpiv4tf.scala:28)\n\tat Problem.main(tmppgpiv4tf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = math.pow(p.toLong, n)\n        if (m % p != 0) (m\
    \ % p).toLong else m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplq4kfqj0.scala:17:44\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (m % p\
    \ != \e[31m0\e[0m) (m % p).toLong \e[33melse\e[0m m\n\e[31m\e[31m   |\e[0m   \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                Found:    (m : Double)\n\e[31m   |\e[0m     \
    \                                       Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = n - p\n        if (d < 0L) d + (p - 1L)\n      \
    \  else d\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6icp_u28.scala:21)\n\tat Problem.main(tmp6icp_u28.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val pmod = p % (p % p % p) // prime modulo p\n        if(n\
    \ == 0) 1l else n & (pmod - 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmpg38cqh7s.scala:16)\n\
    \tat Problem$.main(tmpg38cqh7s.scala:20)\n\tat Problem.main(tmpg38cqh7s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n = n % p\n        if (n == 0) 1\n        else 2 * n\
    \ % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqdfkk0sv.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n % p\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = n\n        while (result > 0) {\n         \
    \   result = result % p\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010178
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = n.toLong.pow(p).toLong\n        if(n.toLong >\
    \ 0) res = (p.toLong * res) % p\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp75hk2et.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = n.toLong.pow(p).toLong\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ pow is not a member of Long, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\e[31m\
    \   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpp75hk2et.scala:17:29 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mif\e[0m(n.toLong > \e[31m0\e[0m) res = (p.toLong\
    \ * res) % p\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Reassignment to val res\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val l = n.toInt\n        if(l < 0)\n            -l\n   \
    \     else\n            n - (l % (p.toInt))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5jfd6nt6.scala:23)\n\tat Problem.main(tmp5jfd6nt6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010179
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      val r = n % (p - 1)\n      if (r == 0) {\n        r\n    \
    \  } else {\n        modp(r, p)\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010182
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = math.max(n.toInt, p.toInt)\n        val r = n %\
    \ m\n        if (m == 0)\n            r\n        else\n            modp(r, m)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010182
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if( n <= 0 || p == 0 ) return 0;\n        var remainder\
    \ = 0;\n        var quotient = 0;\n        val result = ((n << 32) >> 32) % p;\n\
    \        val mask = (1 << 32) - 1;\n        for(i <- 0 until 32) {\n         \
    \   quotient = ((result & mask) >> i) % p;\n            if( quotient != 0 ) {\n\
    \                remainder = (remainder << i) + quotient;\n            }\n   \
    \         mask = mask - 1;\n        }\n        if( remainder != 0 ) {\n      \
    \      return remainder;\n        } else {\n            return result;\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmbt72jb0.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            quotient = ((result\
    \ & mask) >> i) % p;\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m   \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpmbt72jb0.scala:26:17 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            mask = mask - \e[31m1\e[0m;\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val mask\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = ((n & p) >>> 1) + ((n & p) >>> 1) >>> 1\n    \
    \    if (res < p)\n            (res << 1) + 1\n        else\n            res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpek70m4rf.scala:23)\n\tat Problem.main(tmpek70m4rf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var x : Long = (1l*p).scalb(n).toInt\n        if (x <= 0)\
    \ x = 0\n        (x-1l).scalb(n).toInt\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr8kd76ib.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mx\e[0m : \e[35mLong\e[0m\
    \ = (\e[31m1l\e[0m*p).scalb(n).toInt\n\e[31m\e[31m   |\e[0m                  \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value scalb is\
    \ not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr8kd76ib.scala:18:15\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        (x-\e[31m1l\e[0m).scalb(n).toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value scalb\
    \ is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val modP = scala.math.pow(2, n)\n        val divModP = scala.math.divMod(modP,\
    \ p)\n        divModP._1\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzpymmnu7.scala:17:33 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdivModP\e[0m = scala.math.divMod(modP,\
    \ p)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      value divMod is not a member of math\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val bits = n.toInt\n        val n = bits % p\n        if\
    \ (n == 0) 1L else 2L << n\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1n1gsqkm.scala:17:16 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = bits % p\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mbits\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010177
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q = n/p\n        if(p%q > 0) q else q + p\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmp2_bigfn3.scala:17)\n\
    \tat Problem$.main(tmp2_bigfn3.scala:20)\n\tat Problem.main(tmp2_bigfn3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = n % p\n        if(r > 0) {\n            r = p +\
    \ r\n        }\n        r %= p\n        return r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpez9rbmh8.scala:25)\n\tat Problem.main(tmpez9rbmh8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q = n / p\n        if (q >= p) {\n            q - p\n\
    \        } else {\n            q * p\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3dipsmr4.scala:24)\n\tat Problem.main(tmp3dipsmr4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        require(n >= 0, \"Negative arguments\")\n        require(p\
    \ >= 0, \"Negative modulus\")\n        if (n % p == 0) {\n            return n\n\
    \        } else {\n            val r : Long = modp(p & (p - 1), p) %  p\n    \
    \        val k : Long = n % p\n            if (r == 0) {\n                return\
    \ k\n            } else {\n                return k + r\n            }\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.scala:21)\n\tat Problem$.modp(tmpj1z9i29k.scala:21)\n\
    \tat Problem$.modp(tmpj1z9i29k.sc"
  stdout: ''
  timestamp: 1660010183
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n.toInt > p.toInt)\n            modp(n.toInt, p)\n \
    \       else\n            ((n - (n * p.toInt)).abs).mod\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplrqtpu46.scala:19:38 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            ((n - (n * p.toInt)).abs).mod\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ mod is not a member of Long, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010184
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = n % (p - 1l)\n        if (m == 0l)\n           \
    \ m\n        else\n            m\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc7cdyb0e.scala:24)\n\tat Problem.main(tmpc7cdyb0e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = (n^2)%p\n        if (m==0) 1l else m\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp319p8479.scala:20)\n\tat Problem.main(tmp319p8479.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else n % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxgxq5k50.scala:21)\n\tat Problem.main(tmpxgxq5k50.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010183
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      def div(x : Long, y : Long) : Long = Math.max(x / y, y / x)\n\
    \      val n = ((n - p) / p).toInt\n      if (n == 0) 1l else div((1l), n).abs.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx51_4_fb.scala:17:16 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m      \e[33mval\e[0m \e[36mn\e[0m = ((n - p) / p).toInt\n\
    \e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0l) {\n            return 0l\n        } else if\
    \ (n == 1l) {\n            return p\n        } else {\n            var res : Long\
    \ = 0l\n            var m : Long = n & p.toLong\n            while (m != 0l) {\n\
    \                res = (res << 1) + (m & 1l)\n                m >>>= 1l\n    \
    \        }\n            res\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5z96kvu6.scala:31)\n\tat Problem.main(tmp5z96kvu6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010184
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val z : Long = n % p\n        val q = p * p - n\n      \
    \  if (q < 0) (-q) + p\n        else q\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc1tmlz5n.scala:22)\n\tat Problem.main(tmpc1tmlz5n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010184
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val rem = n % p\n        if (rem == 0l)\n            n\n\
    \        else\n            n - (rem + p) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4as24kiq.scala:23)\n\tat Problem.main(tmp4as24kiq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            return 0\n        }\n       \
    \ val m = 1l\n        val q = p\n        val r = n % p\n        val x = n % q\n\
    \        val xq = x * q\n        val y = (n-1) * r\n        val yq = y * q\n \
    \       val z = ((n-1) * x) % q\n        val zz = z * q\n        var i = 1l\n\
    \        while (xq < zz) {\n            m = m ^ m\n            i = i + 1l\n  \
    \          xq = xq + (xq * i)\n            yq = yq + y\n            zz = zz +\
    \ (zz * i)\n        }\n        (m*q) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkiue42yh.scala:30:14 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            m = m ^ m\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpkiue42yh.scala:32:15 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            xq = xq + (xq * i)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val xq\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkiue42yh.scala:33:15\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            yq = yq\
    \ + y\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        Reassignment to val yq\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpkiue42yh.scala:34:15 -----------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            zz = zz + (zz * i)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val zz\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (1l << (n %  p)) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5db8op_.scala:20)\n\tat Problem.main(tmpb5db8op_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010187
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = n % p\n        if (d < 0L) d + p else d\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6rj5kerm.scala:21)\n\tat Problem.main(tmp6rj5kerm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var res = 0\n      var power = 2L\n      while(power <= n)\
    \ {\n        res = (res + power) % p\n        power = power * 2L\n      }\n  \
    \    res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdjfqyl9f.scala:19:14\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        res = (res + power) %\
    \ p\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              Found:    Long\n\e[31m   |\e[0m              Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = modPow(n.toInt,p)\n        if(result\
    \ == 0)\n            result = (n.toLong.toInt).toLong % p.toLong\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu3bscdkc.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m : \e[35mLong\e\
    [0m = modPow(n.toInt,p)\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: modPow\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val mod = if (n >= p) p else p\n        val rem = n - (mod\
    \ * mod)\n        (mod * mod)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5fs1cwq2.scala:21)\n\tat Problem.main(tmp5fs1cwq2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // TODO: implement it (return 0)\n        /*\n        val\
    \ r = scala.util.Random(123)\n        if (n <= 0) {\n            return 1\n  \
    \      } else if (n % 2 == 0) {\n            if (n % p == 0) {\n             \
    \   return n // no remainder\n            } else {\n                return n -\
    \ 1\n            }\n        } else {\n            if (n % p == 0) {\n        \
    \        return n // no remainder\n            } else {\n                return\
    \ r.getInt() % p\n            }\n        }\n        */\n        return 0\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjc4ilggs.scala:38)\n\tat Problem.main(tmpjc4ilggs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = p.asInstanceOf[BigInteger]\n        val x = n.asInstanceOf[BigInteger]\n\
    \        val y = x.modPow(x, m).asInstanceOf[BigInteger]\n        val z = y.modPow(y,\
    \ m)\n        if (z.equals(BigInteger.valueOf(1))) z\n        else z\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoc6a0g8k.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = p.asInstanceOf[\e\
    [35mBigInteger\e[0m]\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: type BigInteger\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoc6a0g8k.scala:17:31\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mx\e[0m = n.asInstanceOf[\e[35mBigInteger\e[0m]\n\e[31m\e[31m   |\e[0m    \
    \                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              Not found: type BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpoc6a0g8k.scala:18:44 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = x.modPow(x, m).asInstanceOf[\e\
    [35mBigInteger\e[0m]\n\e[31m\e[31m   |\e[0m                                  \
    \          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \          Not found: type BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val b = 2l\n        val r = p.toLong\n        val m = n.toLong\n\
    \        (m * b) % (r * r) match {\n            case 0 => 0l\n            case\
    \ a => (2l * b) % r\n            case _ => (n * r) % r\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n \
    \   assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n\
    \    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n\
    \    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_z0z77t.scala:26)\n\tat Problem.main(tmpa_z0z77t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = 1\n        while (n > 0) {\n            result\
    \ *= p\n            result %= p\n            n -= 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaqsxc16w.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result *= p\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaqsxc16w.scala:19:19\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            result %= p\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ %= is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpaqsxc16w.scala:20:14 ------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m            n -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of Long - did\
    \ you mean n.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n = n.toInt\n        val p = p.toInt\n        n & (-p)\
    \ == 0\n            ? ((n & (-p)) | (n << (32 - (p * 32))))\n            : ((n\
    \ & (-p)) | (n << (32 - (p * 32))))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_aw47qpa.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            : ((n & (-p)) | (n << (\e[31m32\e[0m - (p\
    \ * \e[31m32\e[0m))))\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       an identifier expected, but ')' found\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_aw47qpa.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp_aw47qpa.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_aw47qpa.scala:20:16 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            : ((n & (-p)) | (n << (\e[31m32\e[0m - (p * \e\
    [31m32\e[0m))))\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m\
    \                Not found: type n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_aw47qpa.scala:20:31 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            : ((n & (-p)) | (n << (\e[31m32\e[0m - (p * \e[31m32\e[0m))))\n\
    \e[31m\e[31m   |\e[0m                               ^^\e[0m\n\e[31m   |\e[0m \
    \                              Not found: type <<\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def pow2(n : Long) : Long = {\n            if(n > p) {\n\
    \                n * n\n            } else {\n                n * (n * 2)\n  \
    \          }\n        }\n        pow2(math.pow(n, 1 / 2.0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk6g3gyke.scala:23:21\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        pow2(math.pow(n, \e[31m1\e\
    [0m / \e[31m2.0\e[0m))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Double\n\e[31m   |\e[0m           \
    \  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val mod = n % p\n        mod\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7n294vwn.scala:21)\n\tat Problem.main(tmp7n294vwn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010194
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = n\n        var rem = n\n        while(n > p)\
    \ {\n            rem = (rem % p) + p\n            n -= rem\n            result\
    \ += 1\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_vi5v5z.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            n -= rem\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of Long - did\
    \ you mean n.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Use scala.math.BigDecimal instead of scala.math.BigInt\
    \ if you want to\n        // have exact results (no rounding).\n        scala.math.BigDecimal(n).mod(scala.math.BigDecimal(p))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpayk_zi4e.scala:18:33 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        scala.math.BigDecimal(n).mod(scala.math.BigDecimal(p))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \  value mod is not a member of BigDecimal - did you mean BigDecimal.max?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        n mod p match {\n            case 0 => n\n            case\
    \ p => modp(n + p, p)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdtwca6r9.scala:16:10 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        n mod p \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e\
    [0m        ^^^^^\e[0m\n\e[31m   |\e[0mvalue mod is not a member of Long, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import\
    \ math.BigInt.long2bigInt\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val z = n % p\n        val a = p / z\n        val c = z\
    \ * a - n\n        if (c < p) c else p // overflow\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfwmarr42.scala:22)\n\tat Problem.main(tmpfwmarr42.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010194
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = scala.math.modPow(2, n, p)\n        if (a >= p)\
    \ a - (p << 1)\n        else a\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv7cms77e.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = scala.math.modPow(\e\
    [31m2\e[0m, n, p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value modPow is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val result = BigInt(n) << (p % BigInt(2l))\n        if (result\
    \ < 0) (result + BigInt(2l))\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48ppngr3.scala:16:35\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = BigInt(n) << (p % BigInt(\e[31m2l\e[0m))\n\e[31m\e[31m   |\e[0m        \
    \                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                      Found:    BigInt\n\e[31m   |\e[0m                     \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp48ppngr3.scala:17:25 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (result < \e[31m0\e[0m) (result + BigInt(\e[31m2l\e\
    [0m))\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    BigInt\n\e[31m   |\e[0m    \
    \                     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp48ppngr3.scala:18:13 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m    \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (result : BigInt)\n\
    \e[31m   |\e[0m             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var q = p\n        while (true) {\n            q = q * 2\
    \ // unroll loop\n            q %= p\n            if (n == q)\n              \
    \  return q\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw3pnlhrp.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mwhile\e[0m (\e\
    [31mtrue\e[0m) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m       \
    \ Found:    Unit\n\e[31m   |\e[0m        Required: Long\n\e[31m18 |\e[0m     \
    \       q = q * \e[31m2\e[0m \e[34m// unroll loop\e[0m\n\e[31m19 |\e[0m      \
    \      q %= p\n\e[31m20 |\e[0m            \e[33mif\e[0m (n == q)\n\e[31m21 |\e\
    [0m                \e[33mreturn\e[0m q\n\e[31m22 |\e[0m        }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = (p.toLong ^ (p.toLong >>> 32)) % p.toLong\n    \
    \    if ((n % p.toLong) == 0) {\n            d % p.toLong\n        } else {\n\
    \            d + n % p.toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprmxcxhna.scala:25)\n\tat Problem.main(tmprmxcxhna.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = n.toInt % p.toInt\n        if (m == 0) m else p\
    \ + (p - m)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdwi530v8.scala:20)\n\tat Problem.main(tmpdwi530v8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = n % p\n        val div = if (res == 0) p else\
    \ p\n        (n / div) % p\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvj00jexe.scala:21)\n\tat Problem.main(tmpvj00jexe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0l) 1l\n        else n % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmjwe24p5.scala:21)\n\tat Problem.main(tmpmjwe24p5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q = p / (n / p)\n        p % q\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmpbfrgwukf.scala:16)\n\
    \tat Problem$.main(tmpbfrgwukf.scala:20)\n\tat Problem.main(tmpbfrgwukf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var r = 1\n      var q = p / 2\n      var m = 0\n      while\
    \ (q != 0) {\n        if (n % q == 0) {\n          m = m+1\n          n = q\n\
    \        }\n        q = (q / 2)\n      }\n      r += (n % p) % p\n      r\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4g_ig47s.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m          n = q\n\e[31m\e[31m   |\e[0m          ^^^^^\e\
    [0m\n\e[31m   |\e[0m          Reassignment to val n\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4g_ig47s.scala:26:8 -------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      r += (n % p) % p\n\e[31m\e[31m   |\e[0m      ^^^^\e\
    [0m\n\e[31m   |\e[0m      value += is not a member of Int - did you mean Int.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var p = p\n      var mod = 0\n      while (n != 0) {\n   \
    \     mod = mod * (n % p)\n        n /= p\n        p = p * p\n      }\n      if\
    \ (p == 1) 0\n      else mod\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0f5x81_8.scala:16:14 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      \e[33mvar\e[0m \e[36mp\e[0m = p\n\e[31m\e[31m \
    \  |\e[0m              ^\e[0m\n\e[31m   |\e[0m              Recursive \e[33mvariable\e\
    [0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0f5x81_8.scala:20:10 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        n /= p\n\e[31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m   \
    \     value /= is not a member of Long - did you mean n.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = scala.math.mod(n, p)\n        if (res < 0) res\
    \ + p else res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkqtg9irp.scala:16:29 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      if(n < p)\n        modp(2 * n + 1, p)\n      else\n      \
    \  n & (p-1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9oo0swws.scala:22)\n\tat Problem.main(tmp9oo0swws.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = modInv(p, 2)\n        val q = n / d\n        n %\
    \ d == 0 ? q : modp(q, p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpdgqusbd3.scala:18:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        n % d == \e[31m0\e[0m ? q : \e[35mmodp\e[0m(q,\
    \ p)\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m\
    \                             end of statement expected but '(' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdgqusbd3.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = modInv(p, \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          Not found: modInv\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var remainder = n\n        while(remainder > 0) {\n    \
    \        val quotient = remainder / p\n            remainder = remainder % p\n\
    \            n = quotient\n        }\n        n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpg1k7o7en.scala:20:14 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            n = quotient\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val n\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010198
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // The multiplication by 2 is very cheap, so we compute\
    \ it only once.\n        // We also check that the value is in range.\n      \
    \  val m = (2 * n) % (p + 1)\n        if (m < 0 || m > p + 1) {\n            throw\
    \ new ArithmeticException(\"modp called with negative value\")\n        }\n  \
    \      m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8g9l_e62.scala:25)\n\tat Problem.main(tmp8g9l_e62.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n % p\n        if (r > 0) (r + p) else r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn_1378yc.scala:20)\n\tat Problem.main(tmpn_1378yc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = n % p\n        if(a == 0) a else p\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm8rp0mmx.scala:20)\n\tat Problem.main(tmpm8rp0mmx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var mod = n\n        while (mod>p)\n            mod = mod\
    \ & (-mod)\n        mod\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_w8vuo6.scala:23)\n\tat Problem.main(tmp2_w8vuo6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = 2l\n        val r = n % m\n        if (r < 0l) m\
    \ + r else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1mir9vdu.scala:21)\n\tat Problem.main(tmp1mir9vdu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (n << 1) | (n >>> 63) % (p << 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvry9h3kz.scala:19)\n\tat Problem.main(tmpvry9h3kz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (n >>> 0) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp18uvym3.scala:20)\n\tat Problem.main(tmpp18uvym3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n.toString match {\n            case \"0\" => 0\n\
    \            case \"1\" => 1\n            case \"2\" => 2\n            case \"\
    3\" => 3\n            case \"4\" => 4\n            case \"5\" => 5\n         \
    \   case \"6\" => 6\n            case \"7\" => 7\n            case \"8\" => 8\n\
    \            case \"9\" => 9\n            case x =>\n                throw new\
    \ Exception(s\"modp: invalid number $n\")\n        }\n        p.pow(r)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp618fl6y2.scala:30:10 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        p.pow(r)\n\e[31m\e[31m   |\e[0m        ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pow is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) {\n            n % p\n        } else {\n    \
    \        n\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2x948dxv.scala:24)\n\tat Problem.main(tmp2x948dxv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n % p\n        if (r < 0) -r + p else r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp05xpl33t.scala:21)\n\tat Problem.main(tmp05xpl33t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1l else n >>> 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxawcvas6.scala:19)\n\tat Problem.main(tmpxawcvas6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n2 = n\n        val m = (n2 & 0x55555555) << 1\n   \
    \     val m1 = ((n2 & 0xAAAAAAA) >> 1) | ((n2 & 0x55555555) << 1)\n        val\
    \ r = ((n2 & 0xCCCCCCCC) >> 2) | ((n2 & 0x33333333) << 2)\n        val r1 = ((n2\
    \ & 0xF0F0F0F0) >> 4) | ((n2 & 0x0F0F0F0F) << 4)\n        val r2 = ((n2 & 0xF3F3F3F3)\
    \ >> 6) | ((n2 & 0x33333333) << 6)\n        val d = (n2 & 0xFF00FFFF) >> 8\n \
    \       val u = ((n2 & 0xFFFF0000) >> 16) | ((n2 & 0x0000FFFF) << 16)\n      \
    \  val a = ((n2 & 0xF8000000) >> 20) | ((n2 & 0x3F000000) << 20)\n        val\
    \ p1 = (n2 & 0xFFFF0000) | ((n2 & 0x0000FFFF) << 16)\n        val c = ((n2 & 0xC0000000)\
    \ >> 21) | ((n2 & 0x0000000F) << 21)\n        var b = ((n2 & 0xFF00FF00) >> 8)\n\
    \        var b = ((n2 & 0x00FF00FF) << 8) | ((n2 & 0xFF00FF00) << 8)\n       \
    \ b = ((b & 0x00FF00FF) | (b >> 8))\n        var n = n2\n        var c = 0\n \
    \       var d = n - p\n        while ((d & 0x80000000) != 0) d = d << 1\n    \
    \    b = ((d & 0xFF00FF00) >> 8) | ((d & 0x00FF00FF) << 8)\n        b = ((b &\
    \ 0x00FF00FF) | (b >> 8))\n        n = ((n - b) | a)\n        n = ((n & 0x00FFFF00)\
    \ | (n >> 16))\n        n = (n1 ^ d)\n        n = (m ^ n ^ p1)\n        n = ((n\
    \ & 0x55555555) << 1) | ((n & 0xAAAAAAA) >> 1) | ((n & 0x55555555) << 1)\n   \
    \     n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC)\
    \ >> 2) | ((n & 0x33333333) << 2)\n        n = ((n & 0x0F0F0F0F) << 4) | ((n &\
    \ 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4)\n    \
    \    n = ((n & 0xF3F3F3F3) << 6) | ((n & 0xF3F3F3F3) >> 6) | ((n & 0xF3F3F3F3)\
    \ << 6) | ((n & 0xF3F3F3F3) >> 6)\n        n = ((n & 0xFF00FFFF) << 8) | ((n &\
    \ 0xFFFF\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmjo1eatj.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmjo1eatj.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mb\e[0m = ((n2 & \e[31m0x00FF00FF\e[0m) << \e[31m8\e[0m) | ((n2 & \e[31m0xFF00FF00\e\
    [0m) << \e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mb is already defined as \e[33mvariable\e[0m \e[35mb\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmjo1eatj.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mvar\e[0m \e[36mc\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defined as \e[33mvalue\e\
    [0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpmjo1eatj.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36md\e[0m = n - p\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined as\
    \ \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpmjo1eatj.scala:30:16 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = n2\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mn2\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpmjo1eatj.scala:33:40 -----------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mwhile\e[0m ((d & \e[31m0x80000000\e[0m) != \e\
    [31m0\e[0m) d = d << \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     \
    \    "
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        require(n > 0 && p > 0)\n        if (n <= p) {\n       \
    \     return n\n        }\n        if (n >= (p.toLong - n)) {\n            return\
    \ p.toLong\n        }\n        val m = p.toLong - n\n        (p - (n & m)).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp32sxp15y.scala:28)\n\tat Problem.main(tmp32sxp15y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var ret = n\n        var p2 = 1l\n        while (n > p2)\
    \ {\n            ret %= p2\n            if (ret < p)\n                ret += 1\n\
    \            p2 *= 2\n        }\n        return ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvic34guv.scala:27)\n\tat Problem.main(tmpvic34guv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n % p\n        if(p > n)\n            modp(r, p)\n\
    \        else\n            r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0 || p == 0)\n            0\n        else if (n\
    \ % p == 0)\n            n\n        else\n            modp(n / p, p)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp1h6vkbf.scala:24)\n\tat Problem.main(tmpp1h6vkbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = n % p\n        val b = a % p\n        if(a == 0\
    \ || b == 0) 1\n        else if(a == p) n\n        else ((n % p) + p) % p\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6qhzufzd.scala:24)\n\tat Problem.main(tmp6qhzufzd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Simpler approach: use binary division instead of powers\
    \ of 2 modulo.\n        // Use bitmasks for simplicity.\n        val b1 = n &\
    \ 0xff\n        val b2 = ((n>>8)&0xff) & 0xff\n        val b3 = ((n>>16)&0xff)\
    \ & 0xff\n        val b4 = ((n>>24)&0xff) & 0xff\n\n        val p0 = p & 0xff\n\
    \        val p1 = ((p>>8)&0xff) & 0xff\n        val p2 = ((p>>16)&0xff) & 0xff\n\
    \        val p3 = ((p>>24)&0xff) & 0xff\n\n        val r1 = b1 | (((b1&b2)<<1)\
    \ | (((b1&b3)<<2) | ((b1&b4)<<3)) | (((b2&b3)<<1) | (((b2&p0)<<2) | ((b2&p1)<<3))\
    \ | ((b3&p1)<<1) | ((b3&p2)<<2) | ((b3&p3)<<3)) & 0xff\n        val r2 = ((b1&p0)\
    \ | (b1&p1) | (b1&p2) | (b1&p3)) & 0xff\n        val r3 = ((b2&p0) | (b2&p1) |\
    \ (b2&p2) | (b2&p3)) & 0xff\n        val r4 = ((b3&p0) | (b3&p1) | (b3&p2) | (b3&p3))\
    \ & 0xff\n\n        r1 | (r2<<8) | (r3<<16) | (r4<<24) & 0xff\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpecscxo3j.scala:29:8 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mr2\e[0m = ((b1&p0) | (b1&p1)\
    \ | (b1&p2) | (b1&p3)) & \e[31m0xff\e[0m\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\
    \e[31m   |\e[0m        ')' expected, but 'val' found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpecscxo3j.scala:34:5 ---------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        n == 0 ? n : modp(n / 2, p) + (n % 2 * p) % p\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpv20othpp.scala:16:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        n == \e[31m0\e[0m ? n : \e[35mmodp\e[0m(n / \e\
    [31m2\e[0m, p) + (n % \e[31m2\e[0m * p) % p\n\e[31m\e[31m   |\e[0m           \
    \              ^\e[0m\n\e[31m   |\e[0m                         end of statement\
    \ expected but '(' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv20othpp.scala:16:15\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        n == \e[31m0\e[0m\
    \ ? n : \e[35mmodp\e[0m(n / \e[31m2\e[0m, p) + (n % \e[31m2\e[0m * p) % p\n\e\
    [31m\e[31m   |\e[0m             ^^^\e[0m\n\e[31m   |\e[0m             value ?\
    \ is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = (p - 1) << (32 - 32 - n)\n        ((n & d) + d)\
    \ % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28lj_23k.scala:20)\n\tat Problem.main(tmp28lj_23k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = 1L\n        val r = scala.math.pow(m, n)\n     \
    \   r.modPow(p, m)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl68ktcap.scala:18:10 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        r.modPow(p, m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value modPow is not a member of Double\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (2l) ^ (n) % (p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_vkrvji0.scala:19)\n\tat Problem.main(tmp_vkrvji0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val nbin = Binary.fromLong(n).toBinaryString\n        val\
    \ pbin = Binary.fromLong(p).toBinaryString\n        val mod = nbin.substring(nbin.length\
    \ - 1) == '1' ^ pbin.substring(pbin.length - 1) == '1'\n        (mod ? 1l : n)\
    \ % (1l * p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg6za3pp1.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnbin\e[0m = Binary.fromLong(n).toBinaryString\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \          Not found: Binary\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpg6za3pp1.scala:17:19 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        \e[33mval\e[0m \e[36mpbin\e[0m = Binary.fromLong(p).toBinaryString\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \          Not found: Binary\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpg6za3pp1.scala:19:20 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        (mod ? \e[31m1l\e[0m : \e[35mn\e[0m) % (\e[31m1l\e[0m * p)\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Not\
    \ found: type n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      val mod = (n ^ (n * p)) & ((-1l) * p + 1)\n      if (mod <\
    \ p) mod else n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdvt7ztnx.scala:21)\n\tat Problem.main(tmpdvt7ztnx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n.mod(p)\n        if(!r != 0) r else p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9n_riosw.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n.mod(p)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue mod is not a member\
    \ of Long, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q = 2l / p\n        ((n % q) * (p % q)) % q\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmp4niz0cf_.scala:17)\n\
    \tat Problem$.main(tmp4niz0cf_.scala:20)\n\tat Problem.main(tmp4niz0cf_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = n\n        while (result != 0) {\n        \
    \    result := result % p\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb37z9okd.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result := result % p\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value := is not a member\
    \ of Long - did you mean Long.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val ans = n.xor(p).and(0xFFFFFFFF).shiftRightUnsigned(32);\n\
    \        if (ans.lessThan(p)) ans else 0l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk5ftp4t7.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = n.xor(p).and(\e\
    [31m0xFFFFFFFF\e[0m).shiftRightUnsigned(\e[31m32\e[0m);\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                  value xor is not\
    \ a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (n << 1) ^ (n & p - 1l)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzdbcxz9b.scala:19)\n\tat Problem.main(tmpzdbcxz9b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = p.toLong\n        val r = n.toLong\n        val\
    \ t = r % m;\n        if(t == 0L) 1L else t % m;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrqmp0bv.scala:23)\n\tat Problem.main(tmpnrqmp0bv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = n >>> 0\n        val b = p >>> 0\n        var r\
    \ = a\n        var q = 0\n        // Start from right to left because we will\
    \ need to do \n        // modulo 2^n for every value we subtract from n.\n   \
    \     // We will also add 1 to the result of modulo when we \n        // subtract\
    \ from n. \n        while(n != 0) {\n            // We subtract 2^n from n. The\
    \ result is 0 when \n            // subtraction result is 0. \n            val\
    \ r = (n % 2L) - (b << 1) - (a << 2) - (a << 3)\n            // If r has a lower\
    \ bit than the value we are subtracting\n            // then we have to add 2^q\
    \ to r. \n            if(r < 0) r = r + 2L << q\n            q = q + 1\n     \
    \       a = a + (r << 1)\n            // Remember to do modulo 2^n for every value\
    \ we subtract from\n            // n.\n            n = n >>> 1\n        }\n  \
    \      // Return a.\n        a\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpyc_urw4i.scala:30:24 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(r < \e[31m0\e[0m) r = r + \e\
    [31m2L\e[0m << q\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Reassignment to val r\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpyc_urw4i.scala:32:14 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            a = a + (r << \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val a\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpyc_urw4i.scala:35:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            n = n >>>\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        assert(n % p == 0, s\"n must be multiple of p $n %  p $p\"\
    )\n        if (n % p == 0) {\n            return n\n        }\n        val r =\
    \ n / p\n        modp(r, p)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed: n must be multiple of p 3 %\
    \  p 5\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\
    \tat Problem$.modp(tmpuijdc5zt.scala:16)\n\tat Problem$.main(tmpuijdc5zt.scala:24)\n\
    \tat Problem.main(tmpuijdc5zt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q = scala.util.hashing.MurmurHash3.apply(n).asInstanceOf[Long]\n\
    \        (q % p).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq2j69hwc.scala:16:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = scala.util.hashing.MurmurHash3.apply(n).asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m\e[33mclass\e[0m \e[35mMurmurHash3\e[0m cannot be accessed\
    \ as a member of (scala.util.hashing : scala.util.hashing.type) from module class\
    \ Problem$.\n1 error found\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (p == 0) 1\n        else n % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv58yujne.scala:21)\n\tat Problem.main(tmpv58yujne.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = n\n        val mask = (p + 1l) - 1\n        while\
    \ (mask != 0l) {\n            val a = res\n            res = ((a & mask) ^ p)\
    \ % (p - 1l)\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010221
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = n % p\n        if (m == 0)\n            m\n    \
    \    else\n            modp(m, p)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (1l <<< n.toInt) * (n + 1l <<< p.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3uu3rug_.scala:16:12 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        (\e[31m1l\e[0m <<< n.toInt) * (n + \e[31m1l\e\
    [0m <<< p.toInt)\n\e[31m\e[31m   |\e[0m         ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       value <<< is not a member of Long - did you mean (\e[31m1L\e[0m : Long).<<?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val c = 1l\n        (n.toLong - p.toLong) * c\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_uxd4os.scala:20)\n\tat Problem.main(tmp9_uxd4os.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = n % p\n        if (r > 0) {\n            return\
    \ r;\n        }\n        else {\n            return n % p;\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdlogrres.scala:26)\n\tat Problem.main(tmpdlogrres.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n1 = n % p\n        if (n1 == 0) n1 else n1 + p\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0zegvt8r.scala:20)\n\tat Problem.main(tmp0zegvt8r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val rd = n % p\n        if(!rd.equals(0)) {\n          \
    \  val rf = p % rd\n            n + (p - rd) * (rf / rd) % p\n        } else {\n\
    \            n\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpptjxl08j.scala:26)\n\tat Problem.main(tmpptjxl08j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val result = n\n        result %= p\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6fb0brm.scala:17:15 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        result %= p\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value %= is not a member of Long - did you mean result.!=?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        n == 0 \n            ? 0\n            : (n % p + p) % p\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfw0khldh.scala:18:26 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            : (n % p + p) % p\n\e[31m\e[31m   |\e[0m\
    \                          ^\e[0m\n\e[31m   |\e[0m                          Not\
    \ found: type %\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfw0khldh.scala:17:12\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        n == \e[31m0\e[0m\
    \ \n\e[31m17 |\e[0m            ? \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m         \
    \    ^\e[0m\n\e[31m   |\e[0m            value ? is not a member of Int.\n\e[31m\
    \   |\e[0m            Note that `?` is treated as an infix operator in Scala 3.\n\
    \e[31m   |\e[0m            If you do not want that, insert a `;` or empty line\
    \ in front\n\e[31m   |\e[0m            or drop any spaces behind the operator.\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val p3 = p.pow(3l)\n        val p5 = p.pow(5l)\n       \
    \ val p7 = p5.pow(7l)\n        val p10 = p7.pow(10l)\n        val p12 = p10.pow(12l)\n\
    \        val p15 = p12.pow(15l)\n        val p18 = p15.pow(18l)\n        val p20\
    \ = p18.pow(20l)\n        val p23 = p20.pow(23l)\n        val p26 = p23.pow(26l)\n\
    \        val p29 = p26.pow(29l)\n        val p32 = p29.pow(32l)\n        val p35\
    \ = p32.pow(35l)\n        val p40 = p35.pow(40l)\n        val p45 = p40.pow(45l)\n\
    \        val p48 = p45.pow(48l)\n        val p51 = p48.pow(51l)\n        val p54\
    \ = p51.pow(54l)\n        val p57 = p54.pow(57l)\n        val p60 = p57.pow(60l)\n\
    \        val p63 = p60.pow(63l)\n        val p68 = p63.pow(68l)\n        val p71\
    \ = p68.pow(71l)\n        val p74 = p71.pow(74l)\n        val p77 = p74.pow(77l)\n\
    \        val p80 = p77.pow(80l)\n        val p83 = p80.pow(83l)\n        val p86\
    \ = p83.pow(86l)\n        val p89 = p86.pow(89l)\n        val p92 = p89.pow(92l)\n\
    \        val p95 = p92.pow(95l)\n        val p98 =  p95.pow(98l)\n        val\
    \ p101 = p98.pow(101l)\n        val p104 = p101.pow(104l)\n        val p107 =\
    \ p104.pow(107l)\n        val p110 = p107.pow(110l)\n        val p113 = p110.pow(113l)\n\
    \        val p116 = p113.pow(116l)\n        val p119 = p116.pow(119l)\n      \
    \  val p122 = p119.pow(122l)\n        val p125 = p122.pow(125l)\n        val p128\
    \ = p125.pow(128l)\n        val p131 = p128.pow(131l)\n        val p134 = p131.pow(134l)\n\
    \        val p137 = p134.pow(137l)\n        val p140 = p137.pow(140l)\n      \
    \  val p143 = p14\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq623__3d.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mp3\e[0m = p.pow(\e[31m3l\e\
    [0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0mvalue pow\
    \ is not a member of Long, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\e[31m\
    \   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpq623__3d.scala:17:19 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp5\e[0m = p.pow(\e[31m5l\e[0m)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0mvalue pow is\
    \ not a member of Long, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\e[31m\
    \   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpq623__3d.scala:62:19 ------------------------\e[0m\e\
    [0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mp143\e[0m = p14\n\e[31m\e[31m\
    \   |\e[0m                   ^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ p14\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq623__3d.scala:63:5\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // we do not need to check for negative powers and mod p\
    \ by n\n        // since we only care about the last few digits of n, mod p by\
    \ n\n        val a = n % p\n        val b = n / p\n        val c = modp(b, p)\
    \ % p\n        a * p + c\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpn8a8n124.scala:15)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.scala:20)\n\tat Problem$.modp(tmpn8a8n124.scala:20)\n\
    \tat Problem$.modp(tmpn8a8n124.sc"
  stdout: ''
  timestamp: 1660010222
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = n % p\n        while(result < 0 && result\
    \ != p - 1){\n            result -= p\n        }\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptdj4_i5p.scala:24)\n\tat Problem.main(tmptdj4_i5p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val m = math.pow(2 * n, p / 2)\n        m - (n * (n % p\
    \ == 0 ? 1 : 0))\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx0zl0hx1.scala:17:29 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        m - (n * (n % p == \e[31m0\e[0m ? \e[31m1\e[0m\
    \ : \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\
    \e[31m   |\e[0m                           value ? is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val c = n.toInt\n        if (c.isEven) {\n            if\
    \ (c.mod(p) == 0) {\n                return 1\n            } else {\n        \
    \        return 0\n            }\n        }\n        val npow = (n << 1).toLong\n\
    \        val cpow = c.pow(p).toLong\n        val res = npow.mod(cpow)\n      \
    \  if (res == 0l) {\n            return 1\n        }\n        return res\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprgng25rc.scala:17:14 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (c.isEven) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value isEven is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprgng25rc.scala:18:18\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m\
    \ (c.mod(p) == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue mod is not a member of Int, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.int2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprgng25rc.scala:25:21\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mcpow\e[0m = c.pow(p).toLong\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pow is not a member of Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.int2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.int2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprgng25rc.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = npow.mod(cpow)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue mod\
    \ is not a member of Long, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var rem = n\n        var q : Long = 1\n        while (n\
    \ > q && rem >= p) {\n            q = q * 2\n            rem -= p\n        }\n\
    \        if (rem < 0) {\n            n = q - rem\n        }\n        if (n ==\
    \ 2l) {\n            q\n        } else {\n            throw new java.lang.ArithmeticException(\"\
    modp overflow\")\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpo6k6yqy9.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = q - rem\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val n\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val d = n - p\n        if (d == 0) 1\n        else if (d\
    \ == 1) 0\n        else ((d * modp(d, p)) % p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.scala:19)\n\tat Problem$.modp(tmpr245aptv.scala:19)\n\
    \tat Problem$.modp(tmpr245aptv.sc"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0l) {\n            return n\n        }\n      \
    \  else if (n < p * n) { // in case the result would overflow\n            return\
    \ p\n        }\n        else {\n            val m = n % p\n            if (m ==\
    \ 0l) {\n                return n / p\n            }\n            else\n     \
    \       {\n                val q = p / m\n                return m * modp(q, n)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeipmzj_j.scala:35)\n\tat Problem.main(tmpeipmzj_j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      if (n % p == 0) n else n % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpltp288gl.scala:20)\n\tat Problem.main(tmpltp288gl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        for(i <- 0 until n) {\n \
    \           result *= p\n            result += i\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt0knxadr.scala:17:25\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m0\e[0m until n) {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e\
    [31m   |\e[0m                         Found:    (n : Long)\n\e[31m   |\e[0m  \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n = n % p\n        if (n == 0) n else n + p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppw__wzl8.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n % p\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      val m = ((p + n) mod p).asInstanceOf[Long]\n      m ^ p.abs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplm6jcyck.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      \e[33mval\e[0m \e[36mm\e[0m = ((p + n) mod p).asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue mod is not a member of Long, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def pow(n: Long): Long = {\n            if (n == 0) 1\n\
    \            else if (n == 1) 1\n            else n * pow(n-1)\n        }\n  \
    \      // This can overflow, though, so use Long.maxVal instead.\n        // http://scala-programming-language.1934581.n4.nabble.com/Overflow-on-powa-bigDecimal-pow-a-long-long-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptzcqrddr.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < p) 1l else 2l % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsh96ieu1.scala:19)\n\tat Problem.main(tmpsh96ieu1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = ((n >>> 0) % p).toLong\n        (r.toInt + p) %\
    \ p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgr9e9hts.scala:21)\n\tat Problem.main(tmpgr9e9hts.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n%p==0) n else modp(n/p, p)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwx9urvb2.scala:19)\n\tat Problem.main(tmpwx9urvb2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val p = BigDecimal(p)\n        val n = BigDecimal(n)\n \
    \       val c = n.divide(p) // We want c to be the exact (integer) division of\
    \ the two numbers. c.toLong will fail because it would round down.\n        c.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmporwqymg6.scala:16:27 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = BigDecimal(p)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmporwqymg6.scala:17:27 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = BigDecimal(n)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        n == 0 ? 1l : modp(n.shr(1), p) * p + n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkqv3an9z.scala:16:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        n == \e[31m0\e[0m ? \e[31m1l\e[0m : \e[35mmodp\e\
    [0m(n.shr(\e[31m1\e[0m), p) * p + n\n\e[31m\e[31m   |\e[0m                   \
    \       ^\e[0m\n\e[31m   |\e[0m                          end of statement expected\
    \ but '(' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkqv3an9z.scala:16:15\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        n == \e[31m0\e[0m\
    \ ? \e[31m1l\e[0m : \e[35mmodp\e[0m(n.shr(\e[31m1\e[0m), p) * p + n\n\e[31m\e\
    [31m   |\e[0m             ^^^\e[0m\n\e[31m   |\e[0m             value ? is not\
    \ a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = n.toInt\n        val b = p.toInt\n        if((a\
    \ % b) == 0) {\n            return n\n        } else {\n            val m = a\
    \ % b\n            val r = ((a - ((m * m) % b)) % b)\n            return (2 *\
    \ r) + m\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkrkhe3qd.scala:27)\n\tat Problem.main(tmpkrkhe3qd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val q = n / p\n        val r = n % p\n        if (q == 0\
    \ && r == 0) {\n            return 0\n        } else if (q == 0 && r != 0) {\n\
    \            return p\n        } else if (q != 0 && r == 0) {\n            return\
    \ 1\n        } else if (q != 0) {\n            return (p - 1) * q + r\n      \
    \  } else {\n            return 0\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfwga7d8e.scala:31)\n\tat Problem.main(tmpfwga7d8e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r : Long = Math.abs(n)\n        val m : Long = Math.abs(p)\n\
    \        if (r > m) {\n            val tm : Long = m % r\n            if (tm !=\
    \ 0) {\n                p += tm\n            }\n        }\n        r + p\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuvlw7qu3.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                p += tm\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Long - did you mean p.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val bit = n % p\n        if (bit > 0)\n            ((n /\
    \ p) + (1L << bit))\n        else\n            (((n / p) -1) + (1L << bit))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvkfgthig.scala:23)\n\tat Problem.main(tmpvkfgthig.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val nn = n & (-n)\n        val p2 = p * p\n        val q\
    \  = ((nn - p2 + p) % p).abs & (-p2)\n        val r = ((nn - p2 + q) % p).abs\
    \ & (-p2)\n        q | (r + 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfvzj6bwm.scala:23)\n\tat Problem.main(tmpfvzj6bwm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val n = (n % p).toInt\n        ((2L * n) % p)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfm44a4g8.scala:16:17 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = (n % p).toInt\n\
    \e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                \
    \ Recursive \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else n % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxgxq5k50.scala:21)\n\tat Problem.main(tmpxgxq5k50.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010183
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result = n\n        while (n > 1) {\n            if\
    \ ((n % p) == 0) {\n                result -= 1\n            }\n            n\
    \ /= p\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptqfmvx_l.scala:21:14 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n /= p\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member of Long - did\
    \ you mean n.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (p == 0) {\n            1l\n        }\n        else if\
    \ (n == 0) {\n            n\n        }\n        else {\n            modp(n / 2,\
    \ p * p) % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa9bm9qyw.scala:27)\n\tat Problem.main(tmpa9bm9qyw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val z = math.pow(n, p)\n        z % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpomqy0yjj.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        z % p\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m\
    \   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val a = math.pow(2,n) // 2^n\n        val b = math.pow(2,n-1)\
    \ // 2^(n-1)\n        val result = a % b  // a%b\n        if (result < 0) a else\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphrt74kf0.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (result\
    \ < \e[31m0\e[0m) a \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m            \
    \            ^\e[0m\n\e[31m   |\e[0m                        Found:    (a : Double)\n\
    \e[31m   |\e[0m                        Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphrt74kf0.scala:19:31 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (result < \e[31m0\e[0m) a \e[33melse\e\
    [0m result\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    (result : Double)\n\e[31m\
    \   |\e[0m                               Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val result = 1\n        while (n > p) {\n            result\
    \ = (result * (n - p) + p) % p\n            n = (n - (result * result)) % p\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfgpgc666.scala:18:21\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            result = (result\
    \ * (n - p) + p) % p\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Long\n\e[31m   |\e[0m     \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpfgpgc666.scala:19:14 -----------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            n = (n - (result * result)) % p\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // If n < 0 raise a ValueError.\n        if (n < 0) throw\
    \ new IllegalArgumentException(\"Negative numbers not allowed\")\n\n        //\
    \ If p is negative raise a ValueError.\n        if (p < 0) throw new IllegalArgumentException(\"\
    Negative numbers not allowed\")\n\n        // If p > p raise a ValueError.\n \
    \       if (p > p) throw new IllegalArgumentException(\"Positive numbers out of\
    \ range\")\n\n        // Return 0 when n = 0.\n        if (n == 0) 0\n\n     \
    \   // Return 0 when p > n.\n        else if (p > n) 0\n\n        // Return 1\
    \ when p < n.\n        else if (p < n) 1\n\n        // Use modular exponentiation.\n\
    \        else (n * n) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp31_hk3qj.scala:38)\n\tat Problem.main(tmp31_hk3qj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val pow = BigInt(2)\n        while (n >= pow) {\n      \
    \      n -= pow\n            pow += p\n        }\n        n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9poffyp1.scala:18:14 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            n -= pow\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of Long - did\
    \ you mean n.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9poffyp1.scala:19:16\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            pow += p\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of BigInt - did you mean pow.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0l) 1l\n        else n % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmjwe24p5.scala:21)\n\tat Problem.main(tmpmjwe24p5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        (n >>> p & 0x3fffffffffffffff) % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgpy5tk9h.scala:16:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        (n >>> p & \e[31m0x3fffffffffffffff\e[0m) % p\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   number too large\n1 error found\n"
  stdout: ''
  timestamp: 1660010233
