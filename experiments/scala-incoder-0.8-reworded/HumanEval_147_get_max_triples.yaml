name: HumanEval_147_get_max_triples
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a positive integer n. You have to create an integer list a\
  \ of length n.\n    // For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n    // Return the number of triples (a[i], a[j], a[k]) of a where\
  \ i < j < k, \n    // and a[i] + a[j] + a[k] is a multiple of 3.\n    // Example\
  \ :\n    // >>> getMaxTriples((5l))\n    // (1l)\n    // Explanation: \n    // a\
  \ = [1, 3, 7, 13, 21]\n    // The only valid triple is (1, 7, 13).\n    def getMaxTriples(n\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getMaxTriples((5l))\
  \ == (1l));\n    assert(getMaxTriples((6l)) == (4l));\n    assert(getMaxTriples((10l))\
  \ == (36l));\n    assert(getMaxTriples((100l)) == (53361l));\n    }\n\n}\n"
completions: ["        val array = new Array[Long](n)\n        val triplesCount =\
    \ 0\n        for(i <- 1 to n) {\n            for(j <- i to n) {\n            \
    \    for(k <- j to n) {\n                    if(i != j && j != k) {\n        \
    \                array(i) = i * i - i + 1\n                        if(array(i)\
    \ == array(i + 1) + array(j) + array(k) && array(i) % 3 == 0) {\n            \
    \                triplesCount += 1\n                        }\n              \
    \      }\n                }\n            }\n        }\n        return triplesCount",
  "        var result = 0\n        for (i <- 1l to n) {\n            for (j <- 1l\
    \ to i) {\n                for (k <- i to j) {\n                    result = result\
    \ + (i + j + k) * (i + j + k) / 2\n                }\n            }\n        }\n\
    \        return result", "      var a = new mutable.ArrayList[Int](n+1);\n   \
    \   for(i<- 1 to n){\n        a(i) = i*i-i+1;\n      }\n      var triples = 0\n\
    \      var tripleCount = 0\n      for(i<- 1 to n){\n        for(j<- i to n){\n\
    \          for(k <- j to n){\n            if(k<i){\n              triples+=(k+1)\n\
    \            }else{\n              triples+=(a(i+k+j));\n            }\n     \
    \     }\n        }\n        if(triples%3 != 0){\n          triples+=tripleCount\n\
    \        }\n      }\n      return triples.toLong", "        // Initialize our\
    \ list of triples and our counter of invalid triples.\n        var triples = Vector.empty[Int]\n\
    \        var invalidTriples = 0\n        // We start with n = 5\n        var a\
    \ = List.fill(5)(1l)\n        for (i <- 1 until n) {\n            // We have two\
    \ possible candidates for a[i]\n            val min = a(i).min(j)\n          \
    \  val max = a(i).max(j)\n            // If a[i] < min and a[i] < max, then we\
    \ found an invalid triple\n            // and we update our list of invalid triples.\n\
    \            if (a(i) < min && a(i) < max) {\n                invalidTriples +=\
    \ 1\n            }\n            // If a[i] >= min and a[i] >= max, then we found\
    \ a valid triple.\n            // We add our triple.\n            if (a(i) >=\
    \ min && a(i) >= max) {\n                triples += i\n            }\n       \
    \     // If a[i] > max or < min, then we know we have an invalid triple.\n   \
    \         // We increase our invalid triple.\n            if (a(i) > max || a(i)\
    \ < min) {\n                invalidTriples += 1\n            }\n            //\
    \ We increment our candidate for a[i]\n            i += 1\n        }\n       \
    \ // We found 1 invalid triple (which we can also find with a single loop over\
    \ the list of triples),\n        // so we return 1.\n        return invalidTriples\
    \ + 1", "        var a : mutable.MutableList[Long] = mutable.MutableList(1l)\n\
    \        var i : Int = 0\n        var count : Int = 0\n        var j : Int = 0\n\
    \        while (i < n){\n            while (j < n && a(j) < 0){\n            \
    \    j = j + 1\n            }\n            while (i < n && a(j) >= 0){\n     \
    \           i = i + 1\n                j = j + 1\n            }\n            a.add(i)\n\
    \            count = count + a.size()\n            j = j + 1\n        }\n    \
    \    count = count + 1\n        return count", "        def findNextIndex(i: Long)\
    \ : Long = {\n            while (i > 0) {\n                if (a[i - 1] < i +\
    \ 1) {\n                    i -= 1\n                } else {\n               \
    \     val ret = a[i - 1] + i + 1\n                    if (ret >= 3) ret\n    \
    \                else i\n                }\n            }\n        }\n       \
    \ val a = List.fill(n.toInt)(0)\n        for (i = 1; i < n; i += 1)\n        \
    \    a(i) = i * i - i + 1\n        a(0) = 1\n        a.toList.reverse.takeWhile(i\
    \ => i >= 3)\n            .map(i => (i, findNextIndex(i))).foldLeft((0l), 0)(_\
    \ + _._2)", "        var count = 0\n        val a = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 1 to n) a += (i * i - i + 1)\n        for (i <- 1 to n) {\n\
    \            val c = a(i) + a(i+1) + a(i-1)\n            count += if (c % 3 ==\
    \ 0) 1 else 0\n        }\n        count", "        // Write your code here.\n\
    \        val a = Vector(1 to n).map(x => (x * x - x + 1))\n        val b = Vector(a)(0)\
    \ to a(n)(1)\n        val c = b.drop(1) to a(n)(n)\n        c.filter(x => x %\
    \ 3 == 0).length", "        var count = 0\n        var triple = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for(i<-0 until (n-1)) {\n            for(j <-0 until (n-1)) {\n     \
    \           for(k <-0 until (n-1)) {\n                    if(j<k) {\n        \
    \                triple+=(i*i)+(i*j+i+1)+(i*k+k+1)\n                    } else\
    \ {\n                        triple+=(i*i)+(i*j+k+1)+(i*k+k+1)\n             \
    \       }\n                    count += triple.lastOption match {\n          \
    \              case Some(i) => i\n                        case None => 0\n   \
    \                 }\n                }\n            }\n        }\n        triple.lastOption\
    \ match {\n            case Some(i) => count\n            case None => 0\n   \
    \     }", "        val m = n / 3\n        var triple : Long = 0\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        val result = mutable.ArrayBuffer.empty[Int]\n\
    \        val list = mutable.ArrayBuffer.empty[Int]\n        while (i <= n && j\
    \ <= n && k <= n){\n            if (i == 0 || j == 0 || k == 0 || a(i) == a(j)\
    \ + a(k)) {\n                triple = triplet + a(i) + a(j) + a(k) \n        \
    \        result.add(triple)\n            }\n            i += 1\n            j\
    \ += 1\n            k += 1\n        }\n        (result.max)", "        val result\
    \ = new mutable.Array[Long](n)\n        // Use forAll in scala collection\n  \
    \      (0 to n-1).forall(_ => { \n            val a = 2l\n            (0 to n-1).foreach(j\
    \ => { \n                (0 to n-1).foreach(k => { \n                    if (j\
    \ < k) {\n                        result(k) = a\n                    } else if\
    \ (j == k) {\n                        result(k) = a\n                    } else\
    \ {\n                        result(k) = a + a + a\n                    }\n  \
    \              }) \n            })\n        })\n        // Use foldLeft in scala\
    \ collection\n        result.foldLeft(1l) { (sum, a) => { \n            (sum,\
    \ a) => if (sum + a + a + a == 3l) sum + a + a + a else sum + a + a + a + 1\n\
    \        }}", "        var a = Array.fill(n)(0)\n        var count = 0\n     \
    \   for (i <- 0 until n) {\n            val tmp = i * i - i + 1\n            val\
    \ pos = a.indexOf(tmp)\n            val j = (pos + 1) until (pos + n).find(_ ==\
    \ tmp)\n            if (j.isDefined) {\n                val k = j.get\n      \
    \          if (i + j + k == 3 * tmp) {\n                    count += 1\n     \
    \               a(pos) = i\n                    a(j) = k\n                   \
    \ a(k) = j\n                }\n            }\n        }\n        count", "   \
    \     val a = Array.fill(n.toInt)(0l).toList\n        var count = 0\n        for\
    \ (i1 <- 0 until n) {\n            for (i2 <- i1 until n if i1 < i2) {\n     \
    \           for (i3 <- i2 until n if i2 < i3) {\n                    if (i1 +\
    \ i2 + i3 == 3 && i1 + i2 + i3 == i1 +i3 + i2){\n                        a(i1)\
    \ = a(i1) + 1\n                        a(i2) = a(i2) + 1\n                   \
    \     a(i3) = a(i3) + 1\n                        count += 1\n                \
    \    }\n                }\n            }\n        }\n        count", "       \
    \ var a = mutable.ArrayBuffer(1l)\n        var i = 1\n        var j = 1\n    \
    \    var k = 1\n        var max = Integer.MIN_VALUE\n        while( i <= n ){\n\
    \            a(i) = (i*i)-(i+1) + 1\n            if( (i+j+k) ==  (i*i)-(i+1)){\n\
    \                val t = a(i) + a(i+j) + a(i+k)\n                if(t > max){\n\
    \                    max = t\n                }\n            }\n            i\
    \ += 1\n        }\n        return max", "        if (n <= 0) return 0l\n     \
    \   val a = mutable.ArrayBuffer.fill(n.toInt)(0)\n        val result = mutable.ListBuffer[Long]()\n\
    \        for (i1 <- 1l to n) {\n            val a1 = a(i1)\n            val sum\
    \ = a1.toLong + a(i1) + a(i1)\n            if (sum % 3 == 0l) {\n            \
    \    result.add(a(i1) + a(i1) + a(i1))\n            }\n        }\n        result.size",
  "        val a = mutable.ArrayBuffer(n)\n        for( i <- 1 until n ) {\n     \
    \       a(i) = i*i - i + 1 // 1 \u2264 i \u2264 n\n        }\n        val m =\
    \ a.max\n        for( i <- 1 until m ) {\n            val j = a.drop(i).max\n\
    \            val k = a.take(i).min\n            val sum = a.drop(i).take(j).sum\n\
    \            if(sum == 0) return 0\n            if(sum == 1) return 1\n      \
    \      if(sum > 1) return sum\n        }\n        return -1", "        val a =\
    \ mutable.ArrayBuffer.fill(n)(i)\n        val m = a.map(_.asInstanceOf[Int]).filterNot(_.isZero)\n\
    \        (m.filter(_ + _ + _.isOdd).length)", "        var a = ListBuffer(1)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var max = 0\n\
    \        while(i < n) {\n            i = i + 1\n            while(j < n && k<n)\
    \ {\n                j = j + 1\n                while(k < n && a(j) == a(k) +\
    \ a(i)) {\n                    k = k + 1\n                }\n                max\
    \ = Math.max(max, a(i) + a(j) + a(k))\n            }\n            a = a :+ i*i\
    \ - i + 1\n        }\n        max = Math.max(max, a(n))\n        return max",
  "        var max = 0L\n        var a = new mutable.ArrayBuffer[Long](n)\n      \
    \  for (i <- 1 to n){\n            a.clear()\n            for (j <- 1 to n){\n\
    \                for (k <- 1 to n){\n                    val temp = a(j)\n   \
    \                 if (temp != 0L) a(k) += temp\n                }\n          \
    \      if (a(j) != 0L) a(j) += 1\n                if (a(j) != 0L) a(j) += 1\n\
    \            }\n            max = Math.max(max, a(j))\n        }\n        return\
    \ max", "        var count = 0\n        // use mutable.HashMap\n        var map\
    \ = scala.collection.mutable.HashMap[Long, Long]()\n        // use mutable.ListBuffer\n\
    \        var list = scala.collection.mutable.ListBuffer[Long]()\n        while(n\
    \ > 1) {\n            list.clear()\n            map = scala.collection.mutable.HashMap[Long,\
    \ Long]()\n            // use mutable.ListBuffer\n            var list = scala.collection.mutable.ListBuffer[Long]()\n\
    \            for(i <- 1 to n) {\n                map = scala.collection.mutable.HashMap[Long,\
    \ Long]()\n                var list = scala.collection.mutable.ListBuffer[Long]()\n\
    \                for(j <- 1 to n) {\n                    if(i != j && map.get(i\
    \ + j) != null) {\n                        val triple = i + j\n              \
    \          val val = map.get(i + j)\n                        if(val % 3 == 0)\
    \ {\n                            map.remove(triple.toString)\n               \
    \             count += triple.toLong\n                            list+=triple.toLong\n\
    \                        }\n                    }\n                }\n       \
    \         while(map.size > 0) {\n                    val value = map.firstEntry\n\
    \                    map.remove(value._1)\n                    count += value._2.toLong\n\
    \                    list+=value._2.toLong\n                }\n            }\n\
    \            while(map.size > 0) {\n                val value = map.firstEntry\n\
    \                map.remove(value._1)\n                count += value._2.toLong\n\
    \                list+=value._2.toLong\n            }\n            n -= 1\n  \
    \      }\n        count += list.size - 1\n        map", "        val m = math.pow(n,\
    \ 3) \n        var a = (1 to n).map(i => (i * i - i + 1): Long)\n        \n  \
    \      var count = 0\n        while (a.size != 0) {\n            val n = a.head\n\
    \            val m = a.last\n            val m1 = a.size - 1\n            val\
    \ m2 = a.size - 2\n            val p = (n * (n + 1)) / 2\n            if (p <\
    \ m1) {\n                if (p < m2) {\n                    println(\"Invalid\
    \ triple.\")\n                    System.exit(0)\n                } else {\n \
    \                   println(\"Invalid triple.\")\n                    System.exit(0)\n\
    \                }\n            } else {\n                println(\"Invalid triple.\"\
    )\n                System.exit(0)\n            }\n            count += m\n   \
    \         a -= m\n        }\n        count.toLong", "        val a = new Array[Long](n)\n\
    \        val b = mutable.ArrayBuffer.empty[Long]\n        a.map(_ => b += _)\n\
    \        for (i<-0 until n) {\n            var k = 0\n            for(j <- 0 until\
    \ n) {\n                if(b(i) + b(j) + b(k) % 3 == 0) k += 1\n            }\n\
    \            a += i\n            a += i\n            a += k\n        }\n     \
    \   a.sum", "        val a = mutable.ArrayBuffer.fill(n)(0)\n        // Find the\
    \ max value.\n        for(i <- 1 to n){\n            if(a(i) != 0){\n        \
    \        a(i) = a(i)*a(i)-a(i)+1\n            }\n        }\n        // Find the\
    \ index of maximum.\n        val maxIndex = a.indexOf(a(a.length-1))\n       \
    \ // Get the value at maximum.\n        val maxValue = a(a.length-1)\n       \
    \ // Get the last 3 indexes and sum them up\n        val count = (maxIndex+1)+maxIndex+maxIndex+2\n\
    \        if(count % 3 == 0)\n            count\n        else\n            count+1",
  "        def getMaxTriple(a: mutable.Array[Long]) = {\n            val max = (Math.pow(3,\
    \ a.length) - 1)\n            val maxIndex = a.length\n            var index =\
    \ 0\n            while (index != maxIndex) {\n                val aMinus1 = a(index\
    \ + 1) - a(index)\n                if (aMinus1 % 3 == 0) {\n                 \
    \   index++\n                } else {\n                    return a\n        \
    \        }\n            }\n            return a\n        }\n        val res =\
    \ mutable.Array[Long](n)\n        for (i <- 0 until n) {\n            res(i) =\
    \ i * i - i + 1\n        }\n        val a = res.toArray\n        getMaxTriple(a)",
  "        val a = Array(n+1)\n        // a[0] = 1\n        // a[1] = 3\n        //\
    \ a[2] = 7\n        // ...\n        // a[n] = 21\n        a.init \n        a.map(_+1).foreach\
    \ {\n            i => \n            val a = i+1\n            val a1 = a*a-1\n\
    \            val a2 = a1*a-1\n            val a3 = a2*a-1\n            val a4\
    \ = a3*a-1\n            val a5 = a4*a-1\n            val a6 = a5*a-1\n       \
    \     val a7 = a6*a-1\n            val a8 = a7*a-1\n            val a9 = a8*a-1\n\
    \            val a10 = a9*a-1\n            val a11 = a10*a-1\n            val\
    \ a12 = a11*a-1\n            val a13 = a12*a-1\n            val a14 = a13*a-1\n\
    \            val a15 = a14*a-1\n            val a16 = a15*a-1\n            val\
    \ a17 = a16*a-1\n            val a18 = a17*a-1\n            val a19 = a18*a-1\n\
    \            val a20 = a19*a-1\n            val a1 = a2*a\n            val a2\
    \ = a1*a\n            val a3 = a2*a\n            val a4 = a3*a\n            val\
    \ a5 = a4*a\n            val a6 = a5*a\n            val a7 = a6*a\n          \
    \  val a8 = a7*a\n            val a9 = a8*a\n            val a10 = a9*a\n    \
    \        val a11 = a10*a\n            val a12 = a11*a\n            val a13 = a12*a\n\
    \            val a14 = a13*a\n            val a15 = a14*a\n            val a16\
    \ = a15*a\n            val a17 = a16*a\n            val a18 = a17*a\n        \
    \    val a19 = a18*a\n            val a20 = a19*a\n            val a1 = a2*a\n\
    \            val a2 = a1*a\n            val a3 = a2*a\n            val a4 = a3*a\n\
    \            val a5 = a4*a\n            val a6 = a5*a\n            val a7 = a6*a\n\
    \            val a8 = a7*a\n            val a9 = a8*a\n            val a10 = a9*a\n\
    \            val a11 = a10*a\n            val a12 = a11*a\n            val ",
  "        var triplets = mutable.ArrayBuffer.empty[Long]\n        var max = 0\n \
    \       var sum = 0\n        for(i <- 1l to n){\n            sum += i\n      \
    \      triplets += i\n            if(sum > n) sum = 0\n        }\n        for(i\
    \ <- 1l to n){\n            val triple = triplets get i - 1\n            val triple2\
    \ = triplets get i\n            if(triple + triple2 > max) max = triple + triple2\n\
    \        }\n        return max", "        var a : mutable.MutableList[Int] = mutable.MutableList(n)\n\
    \        for( i <- 1 to n-1 ) {\n            a(i) = i*i - i+1\n        }\n   \
    \     var b = 0\n        var c = 0\n        var d = 0\n        for( i <- 1 to\
    \ n-1 ) {\n            for( j <- i+1 to n ) {\n                for( k <- j+1 to\
    \ n ) {\n                    val temp = a(i) + a(j) + a(k) \n                \
    \    if( temp % 3 == 0 ) {\n                        b+=1\n                   \
    \     c = temp\n                        d = k\n                    }\n       \
    \         }\n            }\n        }\n        return b*3", "        val a = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var sum = 0\n        for(i<- 1 until n){\n            val x = i * i -\
    \ i + 1\n            val y = i * i + i + 3\n            if(x < 0){\n         \
    \       sum += (x * x) / 3\n            } else if(y < 0){\n                sum\
    \ = (y * y) / 3\n            } else {\n                sum += x\n            }\n\
    \            a.append(sum)\n        }\n        return a.max", "        var i =\
    \ 0\n        var a = scala.collection.mutable.ListBuffer[Long]()\n        for\
    \ (j <- 1 until n) {\n            if (i == a(j)) {\n                i -= 1\n \
    \           } else {\n                a.update(i)\n                i += 1\n  \
    \          }\n            a.update(i)\n            a.update(i)\n        }\n  \
    \      a.update(i)\n        a.remove(1)\n        a.filter(_.toString.length ==\
    \ 3).toList.length", "        var sum : Long = 0\n        for (i <- 0 until n){\n\
    \            for (j <- 0 until i){\n                for (k <- 0 until j){\n  \
    \                  sum = sum + a(i) * a(j) * a(k)\n                }\n       \
    \     }\n        }\n        if (sum % 3 == 0){\n            return 1l\n      \
    \  }\n        return 0l", "        val a = mutable.MutableList(1 until n).map(i\
    \ => i * i - i + 1).asInstanceOf[mutable.MutableList[Int]]\n        val c = mutable.MutableList(1\
    \ until n).map(i => i * i + 1).asInstanceOf[mutable.MutableList[Int]]\n      \
    \  val d = mutable.MutableList(1 until n).map(i => i * i - 1).asInstanceOf[mutable.MutableList[Int]]\n\
    \        val res = mutable.MutableList(0l).asInstanceOf[mutable.MutableList[Int]]\n\
    \        for (i <- 0 until n) {\n            for (j <- 1 until n) {\n        \
    \        for (k <- 0 until n) {\n                    if (i == j && i == k || j\
    \ == k && i == j) continue \n                    else if (a(i) == a(j) && a(j)\
    \ == a(k) || a(i) == a(k) && a(j) == a(i)) continue\n                    else\
    \ \n                    {\n                        if (res(0) == 0 && a(i) + a(j)\
    \ + a(k) > 0) res += 1\n                    }\n                }\n           \
    \ }\n        }\n        res", "       val a = scala.collection.mutable.ListBuffer.fill(n){0l}\n\
    \       for (i <- 0 until (n-1)){\n         val x = i * i - i + 1\n         for\
    \ (j <- i + 1 until (n)){\n             val y = i * i + j + 1\n             for\
    \ (k <- j until (n)){\n                 val z = j * j + k + 1\n              \
    \   if (x*x + y*y + z*z == 3 && x*i + y*j + z*k == 0){\n                     a.remove(i)\n\
    \                     a.remove(j)\n                     a.remove(k)\n        \
    \             return a.size\n                 }\n             }\n         }\n\
    \       }\n       return 0l", "        val a = scala.collection.mutable.ArrayBuffer.fill(n.toInt)\
    \ {\n            (i * i - i + 1).asInstanceOf[Long]\n        }.toList\n      \
    \  a.sortWith(_.lt(_.asInstanceOf[Long]))\n        a.takeWhile(_ < n).count",
  "        val a = (0 until n).map(x=>x*x-x+1).toArray\n        a.foreach(x => {\n\
    \            val min = math.min(math.min(a(0),a(1)),a(2))\n            val max\
    \ = math.max(math.max(a(0),a(1)),a(2))\n            val middle = math.min(min,max)\n\
    \            val sum = (a(0) + a(1) + a(2))\n            if (sum % 3 == 0) {\n\
    \                return sum\n            }\n        })\n        return 0", " \
    \      val a = mutable.ArrayBuffer(1l) :+ n\n\n       val l = a.length\n     \
    \  for (i<-0 until (l - 1) ) yield {\n          if ( a(i) < 3 )\n            \
    \ 0\n          else if ( a(i) > 3 ) {\n             if ( a(i) == (a(i-1) + a(i-2)\
    \ + a(i-3))%3 )\n                1\n             else\n                0\n   \
    \       }\n          else\n             0\n       }", "        // base case\n\
    \        if (n==0) return 1\n        // recursive case\n        else return getMaxTriples(n-1)\
    \ + getMaxTriples(n-2) + getMaxTriples(n-3)", "        val a = Vector.tabulate(n)(i\
    \ => i * i - i + 1).map(_.toLong)\n        val b = Vector.tabulate(n)(i => a(i)\
    \ + a(i) + a(i))\n        if (b.sum % 3 == 0) 1\n        else 0", "        var\
    \ count = 0\n        var i = 0\n        var j = 1\n        var k = 2\n       \
    \ var a = new Array[Long](n+1)\n        while (i < n && j < n && k < n) {\n  \
    \          count += 1 // add 1 to the count\n            a(i) = i * i - i + 1\n\
    \            i += 1\n            j += 1\n            k += 1\n        }\n     \
    \   val triples = a.toSeq.groupBy(_ + _ + _)\n        count += triples.map(_._3.toLong).reduce(_\
    \ + _)\n        count", "        val a = Array.fill(Long(n))(_ + _ + _)\n    \
    \    a.map { i => (i,i,i) }.filter(_._2 % 3 == 0).length", "        var m = n\
    \ - 1\n        var a = new mutable.ArrayBuffer[Long](n)\n        var i = 1l\n\
    \        while (i < n) {\n            a += (i to i + (i + 1l)).toArray\n     \
    \       i += 2\n        }\n        var j = 1l\n        while (j < n) {\n     \
    \       a += (i + j to i + (i + j + 1l)).toArray\n            j += 2\n       \
    \ }\n        var k = 1l\n        while (j < n) {\n            a += (i + j + k\
    \ to i + (i + j + k + 1l)).toArray\n            k += 2\n        }\n        var\
    \ s = 0\n        a.zipWithIndex.foreach { case (v, i) => s += (v.min * v.min *\
    \ v.min * v.min * v.min).toLong }\n        val l = (s * 3).toLong\n        if\
    \ (l > n) l else n", "        val m = mutable.ArrayBuffer(n)\n        val a =\
    \ mutable.ArrayBuffer(n to 0)\n        val i = mutable.ArrayBuffer(n to 0)\n \
    \       def findTriples(i : Long) : Unit = {\n            val x = a(i).product\n\
    \            m += (x to 0)\n            i += (i to 0)\n            if (x % 3 !=\
    \ 0) {\n                return\n            }\n            a(i) = a(i) + a(i).product\
    \ + 1 \n            a(m) = a(m) + a(m).product + 1\n        }\n        i foreach\
    \ { x => findTriples(x) }\n        val sum = a(m)\n        a(m) = a(m) + a(n).product\
    \ + 1\n        a(n) = a(m)\n        sum", "        val a = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 1l to n) a += i * i - i + 1\n        val triples = a.filter\
    \ { t => t % 3 == 0 }\n        if (triples.length != 0l) triples.max\n       \
    \ else 0l", "        val a = Array.ofDim[Long](n+1)\n        a(0) = 1\n      \
    \  for (i<- 1 to n-1) a(i) = i * i - i + 1\n        val res = a.filter(_ % 3 ==\
    \ 0)\n        res.count(_ > 3) * 3", "        val a = scala.collection.mutable.MutableList(1L)\n\
    \        var count = 0\n        while(n > 0){\n            a.update(0, n * (n-1)\
    \ + n)\n            count = count + 1\n            n = n-1\n        }\n      \
    \  a.toList.last", "        var a = mutable.ListBuffer(1l)\n        for (i <-\
    \ 1 until n) {\n            a += (i * i - i + 1)\n        }\n        return a.count{\
    \ x => x % 3 == 0 }", "        val a = new mutable.ListBuffer[Long]()\n      \
    \  // If n is odd, then there is no possible triple, so return 0\n        if (n%2\
    \ == 1) return 0\n        // If n is even, then there are two possibilities:\n\
    \        //     (a) n = 1: there is no triple\n        //     (b) n = 3: there\
    \ is one triple\n        if (n == 1) return 1\n        // If n is odd, there are\
    \ two possibilities:\n        //     (a) n = 3: there is one triple\n        //\
    \     (b) n = 3: there is one triple\n        if (n == 3) return 1\n        //\
    \ The second possibility is when n = 6\n        if (n == 6) return 1\n       \
    \ // The third possibility is when n = 9\n        if (n == 9) return 1\n\n   \
    \     // Initialise the array a\n        for (i<- 1 until n) {\n            a.append(i\
    \ * i - i + 1)\n        }\n        val size = a.size\n        // Iterate from\
    \ i = 1 to n-1, and count the triples (i, j, k)\n        // which can be satisfied\
    \ by a[i] = i * i - i + 1 and a[j], a[k]\n        // and a[i] and a[j] are multiples\
    \ of 3\n        var count = 0\n        var last = -1L\n        for (i<- 1 until\
    \ n) {\n            val a = a(i) - 1 + last\n            last += 1\n         \
    \   if (a%3 == 0) count += 1\n            if (a%3 == 0 && i%2 == 0) count += 1\n\
    \            if (i == n - 1) {\n                if (a == 3) count += 1\n     \
    \       }\n        }\n        return count", "        val a = scala.collection.mutable.ArrayBuffer.fill(n)(0)\n\
    \        a(0) = 1\n        a(n - 1) = 2 * n - 1\n        val count = 3 * a(0)\
    \ - n\n        val minI = n - 1\n        val maxI = n - 1\n        \n        var\
    \ isMinTriple = false\n        var isMaxTriple = false\n        \n        for\
    \ (i <- 0 until n) {\n            val sum = i * i - i + 1\n            \n    \
    \        isMinTriple |= i < minI\n            isMinTriple |= sum < 3 * minI\n\
    \            isMaxTriple |= i >= maxI\n            isMaxTriple |= sum < 3 * maxI\n\
    \            \n            if (sum % 3 == 0) {\n                a += 1\n     \
    \       }\n        }\n        \n        if (count) {\n            count += a.size\
    \ - n\n        }\n        if (isMinTriple && isMaxTriple) {\n            count\n\
    \        } else {\n            0\n        }", "        val list = ListBuffer[Long]()\n\
    \        for (i <- 1 until n){\n            list.append((i * i - i + 1).abs)\n\
    \        }\n        val res = list.toArray\n        list.clear()\n        res",
  "        val a = Array.fill(n)((0l))\n        a.foreach(x => a(x) = x*x - x + 1)\n\
    \        val triples = a.zipWithIndex.filter(p => p._2 < n).flatMap(p => a(p))\n\
    \        return triples.distinct.reduce((a, b) => a + b)", '        // Code here.',
  "      var num = 3 * (n - 1l)\n      var arr = ListBuffer[Long]()\n      for (i\
    \ <- 1l to n) {\n        arr = arr.:+ i * i - i + 1\n      }\n      arr.sortWith(_\
    \ < _)\n      val result: Array[Long] = (arr(0) + arr(1l) + arr(2l)) % 3 == 0\n\
    \      arr.remove(0)\n      (num + result.sum) %% (3l) == 0", "        val count\
    \ = scala.collection.mutable.ArrayBuffer.empty[Int]\n        val array = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- 1l to n) { \n            count += i\n            if (i % 2\
    \ != 0 && i % 3 != 0) array += i\n        }\n        val ans = array.length -\
    \ count.sum\n        if (ans > 0) ans else 0", "        val a = mutable.ListBuffer.empty[Int]\n\
    \        for (i <- 1 to n) a += i * i - i + 1\n        if (a.length != n) throw\
    \ new Exception(\"Invalid input\")\n        val n = a.length\n        val triples\
    \ = mutable.ListBuffer.empty[Int]\n        var max = 0\n        var i = 0\n  \
    \      for (j <- 1 to n - 1) {\n            for (k <- j + 1 to n) {\n        \
    \        val sum = a(i) + a(j) + a(k)\n                if (sum == 3)\n       \
    \             triples += 1\n                if (sum > max)\n                 \
    \   max = sum\n                i += 1\n            }\n        }\n        a.clear()\n\
    \        a.append(triples)\n        return max", "        val a = mutable.ArrayBuffer(1L)\n\
    \        var count = 0\n        for(i <- 1L until (n)){\n            val j = i\
    \ * i - i + 1\n            for(j <- 1 until (n)){\n                val k = i *\
    \ i + j + 1\n                if((j <- k) % (3L) == 0L){\n                    count\
    \ += (i + 1L) * (j + 1L) * (k + 1L)\n                }\n            }\n      \
    \      a.push(i)\n        }\n        count", "        val a = mutable.ListBuffer[Long]()\n\
    \        (1l to n).map { x =>\n            a.clear()\n            val k = x.toInt\n\
    \            val i = x - k\n            val j = x + k\n            val v = i *\
    \ i - i + 1\n            a += k\n            a += j\n            a += v\n    \
    \        a.size\n        }.foldLeft(0l)(_ + _)", "        var a : mutable.MutableList[Int]\
    \ = mutable.MutableList(n)\n        var c : scala.collection.mutable.ListBuffer[Int]\
    \ = scala.collection.mutable.ListBuffer(0, 0, 0)\n        var i : Long = 0\n \
    \       var j : Long = 0\n        var k : Long = 0\n        while (i < n) {\n\
    \            val a1 = i * i - i + 1\n            val a2 = a1 * i - i - 1\n   \
    \         if (a2 < k) {\n                k = a2\n            }\n            a.add(i)\n\
    \            if (i < n - 1) {\n                val a3 = a2 * i - i - 1\n     \
    \           val a4 = a3 * i - i + 1\n                if (a4 < k) {\n         \
    \           k = a4\n                }\n                a.add(i)\n            \
    \    if (i < n - 2) {\n                    val a5 = a4 * i - i + 1\n         \
    \           val a6 = a5 * i + i + 1\n                    if (a6 < k) {\n     \
    \                   k = a6\n                    }\n                    a.add(i)\n\
    \                    j += k\n                }\n            }\n            i +=\
    \ j\n            j = 0\n        }\n        c(0) = a.size\n        for (i <- 1\
    \ to a.size) {\n            c(i) = c(i) - c(i-1) * 3\n        }\n        c(a.size)",
  "        val a = scala.collection.mutable.ArrayBuffer(0l)\n        var k = 0\n \
    \       var i = 1\n        var j = 2\n        while (i <= n && j <= n) {\n   \
    \         a(i) = i * i - i + 1\n            i = j\n            j += 2\n      \
    \  }\n        a.filter(_ % 3 != 0).foreach(k += 1)\n        a.reduce(_ + _)",
  "        var counter = mutable.Map[Long, Long]()\n        var a = (0 until n).map(i\
    \ => (i * i - i + 1l).toLong)\n        for (i <- 0 until n) {\n            val\
    \ j = i + a.length\n            val k = j + a.length\n            if (counter.contains((i\
    \ * i - i + 1l) + a)) {\n                continue\n            }\n           \
    \ counter += 1\n            if (k == a.length) {\n                counter += 1\n\
    \            }\n            counter.put((i * i - i + 1l) + a, counter.getOrElse((i\
    \ * i - i + 1l) + a, 0L))\n        }\n        for (i <- 0 until n) {\n       \
    \     if (counter.contains((i * i - i + 1l) + a)) {\n                continue\n\
    \            }\n            counter += 1\n        }\n        counter.valuesIterator.max",
  "        val a = ArrayBuffer.fill(n)(0)\n        for( i <- 1 until n)\n        \
    \    if(a(i) + a(i-1) + a(i-2) % 3 > 0) a(i) += 1\n        val result = a(n)\n\
    \        return result", "        var counter = 0\n        // The input is not\
    \ empty\n        if ((n> 0l)){\n            val a = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \            // The list to add the values of each of the triples.\n         \
    \   val list = scala.collection.mutable.ListBuffer.empty[Long]\n            //\
    \ To add the values of each of the triples.\n            for (i <- 1l to n){\n\
    \                val temp = a(i).plus(a(i+1)).plus(a(i+2))\n                //\
    \ We add one to the value because of the constraint of the problem.\n        \
    \        a.update(i,temp+1)\n                list += temp\n                //\
    \ We update the counter to count the number of triples\n                counter\
    \ += 1\n            }\n            val max = list.max\n            // We check\
    \ if the max is divisible by 3\n            if ((max % 3 = 0l)){\n           \
    \     counter\n            }else{\n                // If it isn't we return -1\n\
    \                -1\n            }\n        }else{\n            // If n is negative\
    \ we return -1\n            -1\n        }", "        var ans : Long = 0\n    \
    \    val list = Array[Long](n)\n        list.init\n        list foreach {i =>\
    \ \n            list foreach {j =>\n                list foreach {k =>\n     \
    \               if((i + j + k) % 3 == 0)\n                        ans += ((i +\
    \ j + k) / 3)\n                }\n            }\n        }\n        ans", "  \
    \      val a = ListBuffer.empty[Long]\n        for (i <- 1 to n) {\n         \
    \   val r = i * i - i + 1\n            a += r\n        }\n        val b = a.toList\n\
    \        var count = 0\n        val set = Set()\n        val size = b.size\n \
    \       for (i <- 1 to size) {\n            val r1 = a(i) + a(i+1) + a(i+2)\n\
    \            set.add(s\"$r1\")\n            count += r1\n        }\n        set.forall(_.isMultipleOf(3,\
    \ _))\n        count + (set.size - count) * 3", "        val arr = new Array[Int](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var cnt = 0\n\
    \n        while (i < n) {\n            if (j < i && j > k) {\n               \
    \ arr(i) = i * i - i + 1\n                i += 1\n                j = 0\n    \
    \            k += 1\n            }\n            else if (k < i && k < j) {\n \
    \               arr(i) = arr(i) + arr(j) + arr(k)\n                i += 1\n  \
    \              k += 1\n                j += 1\n            }\n            else\
    \ {\n                arr(i) = arr(i) + arr(j) + arr(k)\n                i += 1\n\
    \                k += 1\n            }\n\n            if (arr(i) % 3 == 0) {\n\
    \                cnt += 1\n                i = 0\n                j = 0\n    \
    \            k = 0\n            }\n        }\n        cnt * 3", "        val arr\
    \ = new ArrayList[Long](n)\n        for (i <- 0 until n) {\n            arr(i)\
    \ = i * i - i + 1\n        }\n        val m = arr.toList sortBy { x => x }\n \
    \               .sliding(2) filterNot { case (a, b) => a + b == 0 }\n        \
    \        .sum\n        arr.toList filter { x => m % x == 0 } size", "        def\
    \ loop(i: Int, j: Int, k: Int): Long = {\n            val res = if (i < j && j\
    \ < k) (i * i * i + i + 1) else 0\n            if (res == 0) {\n             \
    \   if (i == k) i\n                else if (j == k) j\n                else k\n\
    \            } else {\n                if (res > res) res else loop(i, j, k)\n\
    \            }\n        }\n        val ls = scala.collection.mutable.ListBuffer.empty[Int]\n\
    \        for (i <- 1l until n) ls += loop(i ,i ,i)\n        ls.length", "    \
    \    val a = scala.collection.mutable.ArrayBuffer.fill(n)(0)\n        for (i <-\
    \ 1 to n) \n            for (j <- 1 to n) \n                if (i + j + 1 == 3\
    \ * n) a.update(i)(_ + _ + _)\n        a.sum", "        val a = new mutable.MutableList[Long]()\n\
    \        for(i <- 1 until n) {\n            for(j <- 1 until n) {\n          \
    \      if(i != j && j != i && a(i) + a(j) + a(k)% 3 == 0) {\n                \
    \    a.append(i)\n                    a.append(j)\n                    a.append(k)\n\
    \                    //println(a.length)\n                }\n            }\n \
    \       }\n        return a.length", "        val nums = mutable.ArrayBuffer.fill(n)((0l))\n\
    \        val triples = mutable.ArrayBuffer.fill(n.toInt)((0l))\n        \n   \
    \     for(i <- 0 until n) {\n            for(j <- 0 until i) {\n             \
    \   for(k <- 0 until j) {\n                    val sum = 3 * (nums(i) + nums(j)\
    \ + nums(k)) \n                    if(sum % 3 == 0) {\n                      \
    \  triples(i) += 1\n                    }\n                }\n            }\n\
    \        }\n        triples", "        val a = mutable.ArrayBuffer.fill(n)(0)\n\
    \        a(0) = 1 // First element\n        a(1) = 2 // First element\n      \
    \  a(2) = 4 // First element\n        val temp = a(0) // First element of the\
    \ result\n        val result = new ArrayBuffer[(Long, Long, Long)]\n        for\
    \ (i<-0 to n-1) result += (a,a(temp), a(i))\n        temp = a(n)\n        result\
    \ += (a,a(temp), a(n))\n        result.maxBy(_._1)._2._1", "      val a = mutable.MutableList[Long]()\n\
    \      for(i<- 1 to n){\n        a+=(i * i - i + 1)\n      }\n      \n      a.map(x\
    \ => ((x - 1l) % 3l)).map(x => (x+1l)).filter(x => x % 3l == 0).length", "   \
    \     var result = 0\n        var a = new mutable.MutableList[Long](n+1)\n   \
    \     a.set(0)\n        \n        // iterate over each element in the list\n \
    \       a.foreach(i => {\n            val temp = a.remove(0)\n            // iterate\
    \ over each element in the list\n            for (j => a.remove(j)) {\n      \
    \          for (k => a.remove(k)) {\n                    if (i!=j && i!=k && j!=k)\
    \ {\n                        if ((i*i + j*j + k*k) % 3 == 0) {\n             \
    \               result = result + 1\n                            println((i*i\
    \ + j*j + k*k))\n                        }\n                    }\n          \
    \      }\n            }\n            a.add(temp)\n        })\n        \n     \
    \   return result", "        val a = scala.collection.mutable.ArrayBuffer.fill(n.toInt)(0)\n\
    \        var i = 0\n        while(i < n) {\n            a(i) = i * i - i + 1\n\
    \            i += 1\n        }\n        val count = mutable.HashMap.empty[(Long,\
    \ Long, Long)]\n        a.foreach { x =>\n            val key = x.asInstanceOf[Int]\n\
    \            val key1 = (key * key) - (key + 1) + 1\n            val key2 = (a(x)\
    \ - a(key1)) - (a(key1) - a(x) + 1) + 1\n            val key3 = key2 % 3\n   \
    \         if (key3 != 0)\n                count += ((key, key1, key3))\n     \
    \   }\n        (count.toSet * 3).length", "        val a = Array.fill(n)(0)\n\
    \        a.zipWithIndex.foreach(x => a(x) = x(0) + x(1) + x(2))\n        val sum\
    \ = 0\n        for (i <- 0 until a.length) sum += 1\n        sum % 3", "     \
    \   var i = 0\n        var a = new mutable.MutableList[Int](n)\n        while\
    \ (a.isEmpty) {\n            i += 1\n            var b = 0\n            for (j\
    \ <- 0 until i) {\n                b += 1\n                var k = j + 1\n   \
    \             a.set(j, k - j + b - 1)\n            }\n            a.retainAll(a)\
    \ // to remove triples (a, b, c) where b > c\n        }\n        a", "       \
    \ var a = ListBuffer[Long]()\n        var i = -1\n        while(i < n) {\n   \
    \         i = i + 1\n            a += (i * i).toLong\n            i = i + 1\n\
    \            a += (i * i - i + 1).toLong\n        }\n        return a.groupBy(_\
    \ % 3).maxBy(_._2).length", "        val a = scala.collection.mutable.ArrayBuffer.fill(n.toInt)(0)\n\
    \        var i = 0\n        while(i < a.length) a(i) = i * i - i + 1 // fill a\
    \ with 0\n        val n = a.size - 1 // number of valid elements\n        var\
    \ count = 1\n        var j = 1\n        while(j < n) {\n            val r = a(i\
    \ + a[j])\n            count += r\n            j++\n        }\n        a.last",
  "        def getMax(i: Int, j: Int, k: Int) : List[Int] = if (i == j && i == k)\
    \ List(i) else List[Int]() \n        def max(i: Int, j: Int, k: Int): Int = if\
    \ (i > j && i > k) j else k\n        def count(i: Int, j: Int, k: Int) : Int =\
    \ a(i) + a(j) + a(k) - max(i + 1, j + 1, k)\n        a: mutable.Buffer[Int] =\
    \ mutable.Buffer()\n        val temp: MutableList[Int] = MutableList(1, n)\n \
    \       val temp2: MutableList[Int] = MutableList(1, n)\n        val temp3: MutableList[Int]\
    \ = MutableList(1, n)\n        val temp4: MutableList[Int] = MutableList(1, n)\n\
    \        val temp5: MutableList[Int] = MutableList(1, n)\n        val temp6: MutableList[Int]\
    \ = MutableList(1, n)\n        val temp7: MutableList[Int] = MutableList(1, n)\n\
    \        val temp8: MutableList[Int] = MutableList(1, n)\n        val temp9: MutableList[Int]\
    \ = MutableList(1, n)\n        val temp10: MutableList[Int] = MutableList(1, n)\n\
    \        var i: Int = 1\n        val res: Int = 1\n        while(i < temp.length)\
    \ {\n            while(temp(i) < temp(i + 1))\n                i += 1\n      \
    \      while(temp(i) > temp(i + 1))\n                i += 1\n            while(temp(i)\
    \ == temp(i + 1))\n                i += 1\n            while(temp(i) == temp(i\
    \ + 2))\n                i += 1\n            while(temp(i) > temp(i + 2))\n  \
    \              i += 1\n            while(temp(i) == temp(i + 3))\n           \
    \     i += 1\n            while(temp(i) == temp(i + 4))\n                i +=\
    \ 1\n            while(temp(i) == temp(i + 5))\n                i += 1\n     \
    \       while(temp(i) == temp(i + 6))\n                i += 1\n            while(temp(i)\
    \ == temp(i + 7))\n                i += 1\n            while(temp(i) == temp(i\
    \ + 8))\n                i += 1\n            while(temp(i) == temp(i + 9))\n \
    \               i += 1\n            while(temp(i) == temp(i + 10))\n         \
    \       i += 1\n            while(temp(i) == temp(i + 11))\n                i\
    \ += 1\n            while(temp(i) == temp(i + 12))\n                i += 1\n \
    \           while(temp(i) == temp(i + 13))\n                i += 1\n         \
    \   while(temp(i) == temp(i + 14))\n                i += 1\n            while(temp(i)\
    \ == temp(i + 15))\n                i += 1\n            while(temp(i) == temp(i\
    \ + 16))\n                i += 1\n            while(temp", "        val a = scala.collection.mutable.ArrayBuffer.fill(n.toInt)(0).iterator\n\
    \        for (i <- 1 to n) {\n            for (j <- 1 to n) {\n              \
    \  for (k <- 1 to n) {\n                    if(i+j+k == n.toInt) {\n         \
    \               if(a(i) == 0) a(i) = i+j+k\n                        else if(a(j)\
    \ == 0) a(j) = i+j+k\n                        else if(a(k) == 0) a(k) = i+j+k\n\
    \                        else if(a(i) + a(j) + a(k) == n.toInt) a(i) = a(i) +\
    \ a(j) + a(k) \n                        else a(i) = a(i) + a(j) + a(k) - n.toInt\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ ans = scala.collection.mutable.ArrayBuffer.empty[Long]\n        for (i <- 0\
    \ until a.length) {\n            ans(i) = a(i).toLong\n        }\n        ans.sum",
  "      require(n >= 0, s\"n is ${n}\")\n      val a = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \      for (i <- 1 until n){\n        for ((j <- i; j <- i + 1 to n) if (j > 0)){\n\
    \          val k = j - i\n          if (a(k) < 3 * i + j * j + k){\n         \
    \   a += k\n          }\n        }\n      }\n      a.sum", "        val a = Array.fill(n)(0l)\n\
    \        a(0) = 1\n        for(i  <- 1 to n) {\n            for(j <- 1 to n) {\n\
    \                for(k <- 1 to n) {\n                    if((i==j)&&(j==k)) {\n\
    \                        a(i) = a(i) + a(k) + a(i)\n                    } else\
    \ {\n                        a(i) = a(i) + a(j) + a(k)\n                    }\n\
    \                    if((a(i) & 3) == 0) {\n                        return 1l\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ 0l", "        val a = Array.fill(n.toInt)(1)\n        val res = (1l, 0l, 0l)\n\
    \        val res2 = (1l, 0l, 0l)\n        \n        val l = (n-1).toInt\n    \
    \    for(i <- 0 until l) {\n            val j = (i+1).toInt\n            val k\
    \ = (i+2).toInt\n            val t = (a(i) * a(i) - a[i] + a[j] + a[k])\n    \
    \        val t2 = (a(i) * a(i) - a[i] + a[j] + a[k]) * (a(i) * a(i) - a[i] + a[j]\
    \ + a[k])\n            if(t > res(2)) {\n                res = (t, i, j)\n   \
    \             res2 = t\n            }\n        }\n        res2", "      var a\
    \ = mutable.ListBuffer[Long](1l)\n      for (i <- 1 to n) {\n        for (j <-\
    \ i to n) {\n          if (j - i > 1) { \n            for (z <- i to j)\n    \
    \          if (j - z > 1) { \n                a += (i * i * i - i * j + j * z\
    \ + z * z) - 3\n              }\n          }\n        }\n      }\n      a.toList.length",
  "        var a: mutable.MutableList[Long] = mutable.MutableList.empty[Long]\n  \
    \      var i: Long = 1\n        while (i < n) {\n            if (a.contains(i\
    \ * i - i + 1)) {\n                i += 1\n            } else {\n            \
    \    a += i * i - i + 1\n            }\n        }\n        // This loop will be\
    \ terminated when i == n\n        var j: Long = 1\n        var k: Long = 1\n \
    \       var m: Long = 0\n        while (j < n) {\n            while (k < n &&\
    \ a.get(j + k - 1) < 3 * m) {\n                k += 1\n            }\n       \
    \     m += 3 * a.get(j)\n            if (m) % 3 = 0\n            if (m = 0)\n\
    \                m = 1\n            k += 1\n            j += 1\n        }\n  \
    \      // We need this because if a.get(k) % 3 != 0, then m can not be 0.\n  \
    \      m = 1\n        var total: Long = 1\n        while (j < n) {\n         \
    \   while (k < n && a.get(j + k - 1) < 3 * m) {\n                k += 1\n    \
    \        }\n            total += m\n            m = 1\n            k += 1\n  \
    \          j += 1\n        }\n        // Return the number of triples (a[i], a[j],\
    \ a[k]) of a where i < j < k,\n        // and a[i] + a[j] + a[k] is a multiple\
    \ of 3.\n        return total", "        val a = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 until n) {\n            val tmp = a.remove(0)\n          \
    \  a.append((i * i) - i + 1)\n            if(tmp % 3 == 0) a.append(tmp)\n   \
    \     }\n        if(a.isEmpty) return 0\n        a.toList.filter(_ % 3 == 0).size",
  "      val n = n.toInt\n      val a = collection.mutable.ListBuffer[Long](n)\n \
    \     for(i <- 1 until n){\n        a(i) = i*i - i + 1\n      }\n      a.zipWithIndex.filter(_._1\
    \ + _._1 + _._2 % 3 == 0).size", "        var triple = 0L\n        var max = Long.MinValue\n\
    \        var k = 0L\n        for (i<- 1 to n) {\n            k = i\n         \
    \   triple = 0\n            while (k < (n + 1) ) {\n                if (a(k) ==\
    \ a(k + 1) && a(k) == a(k + 2)) {\n                    triple += 1\n         \
    \       }\n                k += 1\n            }\n            if (triple > max)\
    \ {\n                max = triple\n            }\n        }\n        return max",
  "        // The list is initially empty\n        var a = ListBuffer[Long]()\n  \
    \      // To add the first element\n        a += n\n        // To find the next\
    \ triples\n        val triples = a.drop(1).zipWithIndex.filter(_._2 % 3 != 0)\n\
    \        // To add the next triples\n        var i : Long = 0\n        for(triple\
    \ <- triples)\n            a += triple._1\n        // Return triples sum\n   \
    \     triples.sum", "        val a = Array.fill(n.toInt)(0)\n        var count\
    \ = 0\n        var i = 0\n        while (i < n.toInt) {\n            a(i) = i\
    \ * i + i + 1\n            i += 1\n        }\n        var j = 0\n        while\
    \ (j < n.toInt) {\n            var k = j + 1\n            var num = a(j) + a(k)\n\
    \            while (num % 3 != 0) {\n                k += 1\n                num\
    \ = a(j) + a(k)\n            }\n            count += 1\n            j += 1\n \
    \       }\n        count", "        val a = scala.collection.mutable.ArrayBuffer.fill(n)(0)\n\
    \        for (i<-0 until n) {\n            a(i) = i * i - i + 1\n        }\n \
    \       val res: Long = 0\n        for (i<-0 until n-1) {\n            for (j<-(i+1)\
    \ until n) {\n                for (k<-(j+1) until n) {\n                    if\
    \ (a(i) + a(j) + a(k) == 3 * i * i * i * i)\n                        res += 1\n\
    \                }\n            }\n        }\n        res", "        val l = scala.collection.mutable.ArrayBuffer(scala.math.BigInt(1))\n\
    \        l += scala.math.BigInt(1)\n        l += scala.math.BigInt(2)\n      \
    \  l += scala.math.BigInt(3)\n        l += scala.math.BigInt(4)\n        l +=\
    \ scala.math.BigInt(5)\n        l += scala.math.BigInt(6)\n        l += scala.math.BigInt(7)\n\
    \        l += scala.math.BigInt(8)\n        l += scala.math.BigInt(9)\n      \
    \  l += scala.math.BigInt(10)\n        l.toList.zipWithIndex.foreach{\n      \
    \      case (i : BigInt, j : Int) => {\n                var k = i + j\n      \
    \          if (k < n && k % 3 == 0) {\n                    val temp = scala.math.BigInt(k).asInstanceOf[scala.math.BigInt]\n\
    \                    if (l.getOrElse(temp) == null) l.set(temp, scala.math.BigInt(1))\
    \ else l.set(temp, l.getOrElse(temp) + 1)\n                }\n            }\n\
    \        }\n        l.getOrElse(scala.math.BigInt(0))", "        val a = new Array[Int](n)\n\
    \        for(i <- 0 to n){\n            for(j <- 0 to n){\n                val\
    \ m = (i * i * i) + (j * j) + (k * (k * (k - 1)))\n                if(m == 3)\
    \ {\n                    a(i) = j\n                    a(j) = i\n            \
    \        a[k] = i\n                    k = 1\n                } else if (m > 3){\n\
    \                    k+=1\n                    a(i) = j\n                    a(j)\
    \ = i\n                }\n            }\n        }\n        \n        a.foldLeft((0,0,0)){\
    \ (acc, triple) => triple._1 + triple._2 + triple._3 }._1", "        val a = Array.fill(n)(0l)\n\
    \        a.drop(1).zipWithIndex.foreach { case (i, iIdx) =>\n            for (jIdx\
    \ <- i + 1 until n; jIdx < n; jIdx++) {\n                for (kIdx <- jIdx until\
    \ n if kIdx >= i) {\n                    val k = jIdx - i + 1\n              \
    \      a(iIdx) = a(iIdx)\n                    a(jIdx) = a(jIdx)\n            \
    \        a(kIdx) = a(kIdx)\n                    a(iIdx + 1) = a(iIdx + 1) + 1\n\
    \                    a(kIdx) = a(kIdx + 1)\n                }\n            }\n\
    \        }\n        val maxSum = a(0) + (a(1) + a(2) + a(n))\n        a.drop(1).filter(_\
    \ > maxSum).size", "        val a = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        val count = 3l\n        for(i <- 1 to n) {\n            for(j <- 1 to\
    \ n) {\n                for(k <- 1 to n) {\n                    if(i>j && i>k)\
    \ {\n                        a.add(i*i-i+1)\n                        a.add(j*j-i+1)\n\
    \                        a.add(k*k-i+1)\n                        count = a.filter(_%3\
    \ === 0).sum\n                        break\n                    }\n         \
    \       }\n            }\n        }\n        a", "        val a = List.fill(n.toInt)(0l).map(x\
    \ => x * x - x + 1).toList\n        val b = List(1l).foldLeft(List[Long]()) {\
    \ (acc, cur) =>\n            if(cur < acc.last) acc :+ acc.last\n            else\
    \ {\n                if(cur.last + 1 > 3) acc.last :+ (cur.last + 1)\n       \
    \         else acc :+ cur\n            }\n        }\n        val l = b.size\n\
    \        val r = 3 * (l - 1)\n        val q = r.toDouble / 3\n        val ans\
    \ = math.ceil(q)\n        if(ans > 3L) ans else {\n            val n = math.ceil((n\
    \ - ans + 1) / 3)\n            if(n < 3) ans else n\n        }", "        val\
    \ a = Array[Int](n, 0)\n        a(0) = 1\n        for (i <- 1 until a.size) {\n\
    \            for (j <- i until a.size) {\n                for (k <- j+1 until\
    \ a.size) {\n                    val v = a(i) + a(j) + a(k) + 3\n            \
    \        if (v % 3 == 0) \n                        a(i) = v\n                }\n\
    \            }\n        }\n        a(0) match {\n            case 0 => 1\n   \
    \         case _ => a.size\n        }", "        val a = mutable.ListBuffer[Long]()\n\
    \        for (i <- 1 to n) {\n            val temp = a(i)\n            val temp2\
    \ = temp * temp - temp + temp\n            if (temp2 % 3 == 0) {\n           \
    \     a.add(temp)\n            }\n        }\n        a.length", "        var max\
    \ = 0\n        var result = 0\n        val a = Array[Int](n)\n        // fill\
    \ array a\n        for (i <- 1 until a.length) {\n            a(i) = i * i - i\
    \ + 1\n        }\n        // find max triples\n        for (j <- 1 until a.length)\
    \ {\n            for (k <- 1 until a.length) {\n                if (j == k) {\n\
    \                    continue;\n                }\n                result += (a(j)\
    \ * a(j) + a(k)) * 3\n                if (result > max) {\n                  \
    \  max = result\n                }\n            }\n        }\n        // print\
    \ max\n        println(max)\n        return max", "        val a = Vector.fill(n)(3l)\n\
    \        val v = Vector.fill(n)(3l)\n        val k = Vector.fill(n)(3l)\n\n  \
    \      var i = 0\n        var j = 1\n        var k = 2\n        while(i < n &&\
    \ j < n && k < n) {\n            if(i+j+k == n) i += 1\n            else if(j+k\
    \ == n) j += 1\n            else k += 1\n            a(i) = i * i - i + 1\n  \
    \          v(j) = i * i - i + 1\n            v(k) = i * i - i + 1\n        }\n\
    \        i = 2\n        j = 1\n        k = 2\n        while(i < n && j < n &&\
    \ k < n) {\n            if(i+j+k == n) i += 1\n            else if(j+k == n) j\
    \ += 1\n            else k += 1\n            a(i) = i * i - i + 1\n          \
    \  v(j) = i * i - i + 1\n            v(k) = i * i - i + 1\n        }\n       \
    \ i = 2\n        j = 3\n        k = 2\n        while(i < n && j < n && k < n)\
    \ {\n            if(i+j+k == n) i += 1\n            else if(j+k == n) j += 1\n\
    \            else k += 1\n            a(i) = i * i - i + 1\n            v(j) =\
    \ i * i - i + 1\n            v(k) = i * i - i + 1\n        }\n        i += 1\n\
    \        j = 2\n        k = 2\n        while(i < n && j < n && k < n) {\n    \
    \        if(i+j+k == n) i += 1\n            else if(j+k == n) j += 1\n       \
    \     else k += 1\n            a(i) = i * i - i + 1\n            v(j) = i * i\
    \ - i + 1\n            v(k) = i * i - i + 1\n        }\n        i += 1\n     \
    \   j = 3\n        k = 3\n        while(i < n && j < n && k < n) {\n         \
    \   if(i+j+k == n) i += 1\n            else if(j+k == n) j += 1\n            else\
    \ k += 1\n            a(i) = i * i - i + 1\n            v(j) = i * i - i + 1\n\
    \            v(k) = i * i - i + 1\n        }\n        i += 1\n        j = 3\n\
    \        j = k = 3\n        while(i < n && j < n && k < n) {\n            if(i+j+k\
    \ == n) i += 1\n            else if(j+k == n) j += 1\n            else k += 1\n\
    \            a(i) = i * i - i + 1\n            v(j) = i * i - i + 1\n        \
    \    v(k) = i * i - i + 1\n        }\n        i += 1\n        j = k = 3\n    \
    \    k = k = 2\n        while(i < n && j < n && k < n) {\n            if(i+j+k\
    \ == n) i += 1\n            else if(j+k == n", "        if (n%3 != 0) {\n    \
    \        return 0\n        }\n        val a = mutable.ArrayBuffer.empty[Long]\n\
    \        (1 until n).foreach(i => a += i*i*i+1)\n        a.toList // return mutable\
    \ list\n            .sortBy (_ % 3) // sort on multiples of 3\n            .sliding(3)\
    \ // split list into chunks of 3\n            .foldLeft(0)((sum, chunk) => {\n\
    \                if (sum + chunk.last % 3 == 0) sum + chunk.last else 0\n    \
    \        })", "        var sum = 0l\n        for (i<-0 until n)\n            sum\
    \ += i * i - i + 1\n        sum % 3 == 0", "        var a : mutable.ListBuffer[Long]\
    \ = mutable.ListBuffer[Long]()\n        var cnt = 0\n        for( i <- 1 to n){\
    \ \n            for( j <- 1 to n){\n                for( k <- 1 to n ){\n    \
    \                if ( i != j && i != k && j != k ){\n                        var\
    \ triple = ( i * i - i + 1, i * j + i + 1, i * k + j + 1 )\n                 \
    \       if ( triple.sum % 3 == 0 ) a.append(triple)\n                    }\n \
    \               }\n            }\n        }\n        cnt = a.sum\n        return\
    \ cnt", "        var triples = 0\n        var list = mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 to n){\n            list+=i\n        }\n        for(i<-list.indices)\
    \ {\n            for(j <- list.indices) {\n                for(k <- list.indices)\
    \ {\n                    if (i < j < k) {\n                        if (list(i)\
    \ * list(i) - list(i) * list(j) * list(k) % 3 == 0){\n                       \
    \     triples = triples + 1\n                        }\n                    }\n\
    \                }\n            }\n        }\n        list.clear()\n        triples.toLong",
  "        val a = mutable.ArrayBuffer.empty[Long]\n        (1l to n).foreach {\n\
    \            i =>\n            val j = i * i - i + 1\n            val k = i *\
    \ i - i + 1\n            a += i\n            a += j\n            a += k\n    \
    \    }\n        val count = a.count(_ % 3 == 0)\n        count", "        var\
    \ a : mutable.Array[Long] = Array()\n        var count : Long = 0\n        \n\
    \        for (i <- 1 to n) {\n            val j = i*i-1\n            val k = i*i+1\n\
    \            val iAdj : Long = i + j\n            val jAdj : Long = i + k\n  \
    \          val kAdj : Long = j + k\n            \n            if (iAdj + jAdj\
    \ + kAdj == n) { a += i; a += j; a += k; count += 1}\n        }\n        \n  \
    \      a", "        val a = Array.fill(n.toInt)(0L)\n        for (i<-0 until n)\
    \ {\n            a(i) = i*i.toLong + i.toLong + 1L\n        }\n        var max\
    \ = 0L\n        for (i<-0 until n) {\n            for (j<-0 until n) {\n     \
    \           for (k<-0 until n) {\n                    if (a(i) + a(j) + a(k) >\
    \ max) {\n                        max = a(i) + a(j) + a(k) \n                \
    \    }\n                }\n            }\n        }\n        max", "        val\
    \ a = ListBuffer.empty[Long]\n        var i = 0\n        while (i < n) {\n   \
    \         val x = i * i - i + 1\n            a.append(x)\n            i += 1\n\
    \        }\n        val re = a.map(x => x * x - x + 1L).filter(x => x % 3 == 0)\n\
    \        re.size", "        val a = Vector.fill(n.toInt)(((n * n - n * n + 1)\
    \ * 3).toInt)\n        a.sortWith((a, b) => a.compareTo(b) == -1)\n        a(0)",
  "        val a = Array(1, 3, 7, 13, 21)\n        val result = a.reduceLeft((i,j,k)\
    \ =>\n                if(i < j && j < k) (i+j+k) % 3 == 0\n                else\
    \ ( (j-i)*(k-j))\n        )\n        result match {\n            case 0 => 1l\n\
    \            case _ => result\n        }", "        val a = mutable.ArraySeq.fill(3).toList\n\
    \        for (i <- 1 until n){\n            a(i) = i * i - i + 1\n        }\n\
    \        a.filter(i => i < a.size && a(i) == a.last).size match {\n          \
    \  case 0 => 0\n            case 1 => 1\n            case _ => (a.last).filter(_\
    \ % 3 == 0).size\n        }", "        var triplesCount : Long = 0\n        val\
    \ numTriples = 2l\n        for (i <- 1l to n) {\n            val a = i * i - i\
    \ + 1\n            val b = i * i - i + 1\n            if (b % 3 == 0){\n     \
    \           triplesCount += 1\n            }\n        }\n        return triplesCount",
  "        var a = scala.collection.mutable.ListBuffer[Long]()\n        var count\
    \ = 0\n        for (i<-1 to n) {\n            for (j <- i until n) {\n       \
    \         for (k <- j to n) {\n                    if ((i+j+k) == i*i*k && (i+j+k)\
    \ == j*j*k && (i+j+k) == k*k) {\n                        count += 1\n        \
    \                a.add(i)\n                        a.add(j)\n                \
    \        a.add(k)\n                    }\n                }\n            }\n \
    \       }\n        a.size", "        var list : Array[Int] = Array.fill(n)(0)\n\
    \        var max = 1l\n        var min = 0l\n        while(n > 0){\n         \
    \   val t = list.sum\n            if(t > max) max = t\n            if(t < min)\
    \ min = t\n            n-=1\n        }\n        var count = 0l\n        for(i\
    \ <- 0 to n){\n            for(j <- 0 to n){\n                val k = (i + j)\
    \ * 3 - min\n                for(k <- 0 to n){\n                    if((i+j)*3\
    \ + k == min){\n                        count += 1\n                        break\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ count", "        val arr = new mutable.ListBuffer[Int](n)\n        var count\
    \ = 1\n        var temp = 1\n        while (count != n) {\n            if (count\
    \ < n) arr(count) = count\n            val mid = n / 2\n            while (count\
    \ <= mid - 1) {\n                count += 1\n                arr(count) = count\n\
    \            }\n            val mid2 = mid / 2\n            while (count > mid2)\
    \ {\n                count -= 1\n                arr(count) = count\n        \
    \    }\n            temp = arr(0)\n            val temp2 = arr(mid2)\n       \
    \     for (i <- 1 until arr.length) {\n                val value = arr(i)\n  \
    \              val temp3 = value + temp\n                val temp4 = temp2 + temp3\n\
    \                if (temp4 % 3 == 0) return count\n            }\n        }\n\
    \        return -1", "        var count = 0\n        val a = scala.collection.mutable.ArrayBuffer.fill(n)(0)\n\
    \        a.view.zipWithIndex.foreach { case (i, j) =>\n            if (j < i)\
    \ return\n            a(i) = a(i) + 1\n            if (a(i) + a(i + 1) == 0) count\
    \ += 2\n            else if (a(i) + a(i + 2) == 0) count += 2\n            else\
    \ count += 3\n        }\n        count", "        var count : Long = 0\n     \
    \   val nums = mutable.ListBuffer[Long]()\n        var i = 0\n        while(i\
    \ < n) {\n            val j = i\n            val k = i + j\n            val m\
    \ = i * i + j * j + k * k\n            if(m == 3L) {\n                count =\
    \ count + 1\n                nums += k\n            }\n            i = k\n   \
    \     }\n        (count).asInstanceOf[Long]", "        var a = Vector.empty[Int]\n\
    \        var sum = 0\n        var max = 0\n        var k = 0\n        var i =\
    \ 0\n        while (i < n) {\n            sum = sum + i\n            k += 1\n\
    \            while (j < k) {\n                j++\n            }\n           \
    \ while (k < n) {\n                sum = sum + k\n                max += 1\n \
    \               while (j < k) {\n                    j++\n                }\n\
    \                while (j < n) {\n                    k = k + 1\n            \
    \    }\n            }\n            i = i + 1\n        }\n        sum", "     \
    \   var max = 0\n        val a = mutable.ArrayBuilder.make[Long](n)\n        for\
    \ (i <- 1 until n) {\n            a(i) = i * i - i + 1\n            max = a.max(max)\n\
    \        }\n        return max", "        var m = 2\n        var count = Long.MinValue\n\
    \        var a = mutable.ArrayBuffer(n)\n        for(i <- 0 until n){\n      \
    \      for(j <- 0 until n){\n                for(k <- 0 until n){\n          \
    \          if(j > i){\n                        if(k > j){\n                  \
    \          a(i+1).map(a(j+1).map(a(k+1).+))\n                            if(a(i+1).sum\
    \ % 3 != 0 || a(i+1).sum ==0) return Long.MinValue\n                         \
    \   if(a(j+1).sum % 3 != 0 || a(j+1).sum == 0) return Long.MinValue\n        \
    \                    if(a(k+1).sum % 3 != 0 || a(k+1).sum == 0) return Long.MinValue\n\
    \                        }\n                        else{\n                  \
    \          if(i+1 > j){\n                                if(k > j){\n        \
    \                            a(i+1).map(a(j+1).map(a(k+1).+))\n              \
    \                      if(a(i+1).sum % 3 != 0 || a(i+1).sum == 0) return Long.MinValue\n\
    \                                    if(a(j+1).sum % 3 != 0 || a(j+1).sum == 0)\
    \ return Long.MinValue\n                                    if(a(k+1).sum % 3\
    \ != 0 || a(k+1).sum == 0) return Long.MinValue\n                            \
    \    }\n                                else{\n                              \
    \      a(i+1).map(a(j+1).map(a(k+1).+))\n                                    if(a(i+1).sum\
    \ % 3 != 0 || a(i+1).sum == 0) return Long.MinValue\n                        \
    \            if(a(j+1).sum % 3 != 0 || a(j+1).sum == 0) return Long.MinValue\n\
    \                                    if(a(k+1).sum % 3 != 0 || a(k+1).sum == 0)\
    \ return Long.MinValue\n                                }\n                  \
    \          }\n                            else{\n                            \
    \    if(i+1 > j){\n                                    if(k > j){\n          \
    \                              a(i+1).map(a(j+1).map(a(k+1).+))\n            \
    \                            if(a(i+1).sum % 3 != 0 || a(i+1).sum == 0) return\
    \ Long.MinValue\n                                        if(a(j+1).sum % 3 !=\
    \ 0 || a(j+1).sum == 0) return Long.MinValue\n                               \
    \         if(a(k+1).sum % 3 != 0 || a(k+1).sum == 0) return Long.MinValue\n  \
    \                                  }\n                                    else{\n\
    \                                        a(i+1).map(a(j+1).map(a(k+1).+))\n  \
    \                                      if(a(i+1).sum % ", "        val a = new\
    \ Array[Long](n)\n        for (i = 1; i < a.length; ++i) {\n            a(i) =\
    \ i * i - i + 1\n        }\n        var count = 0\n        for (i = 1; i < a.length;\
    \ ++i) {\n            var j = 0\n            while (j + 1 < a.length && a(j +\
    \ 1) < a(i)) {\n                j = j + 1\n            }\n            while (j\
    \ < a.length && a(j) < a(i)) {\n                count = count + 1\n          \
    \      j = j + 1\n            }\n        }\n        count + 1", "      val (a,\
    \ b) = (n, n) -+ 1\n      var triples = scala.math.ceil(b / 3).toInt\n      for\
    \ (i = 1 until n) (a += a) += a\n      for((x, y, z) <- a zip b zip a with ((a,\
    \ b) => if (x + y + z % 3 == 0) (triples = triples + 1, triples)) ) yield (x,\
    \ y, z)", "        val list = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        for (i<-0 until n) list += i*i*(i+1)\n        list.foldLeft(0)((x,y)\
    \ => x+y)", "        val a = Array.fill(n.toInt)(0)\n        a.update(0, 1l)\n\
    \        var sum = 0l\n        for(i <- 1 to n)\n            sum += a[i]\n   \
    \     for(i <- 1 to n-1)\n            sum += a[i] - a[i+1]\n        for(i <- 1\
    \ to n-1)\n            sum += a[i] - a[i-1]\n        for(i <- 1 to n-1)\n    \
    \        sum += a[i] - a[i+1]\n        for(i <- 1 to n-1)\n            sum +=\
    \ a[i] - a[i-1]\n        if(sum % 3 != 0)\n            return -1\n        1",
  "        var i = n / 3\n        var j = (3 * i) / 2\n        var k = n - 3 * i -\
    \ j\n        var a = new Array[Int](3 * n)\n        a(0) = 1\n        a(1) = 3\n\
    \        a(2) = 7\n        while(i-- > 0){\n            a(3 * i + 1) = i * i -\
    \ i + 1\n        }\n        var ans = 0\n        for(i<-0 to n-1){\n         \
    \   for(j<-0 to n-1){\n                for(k <-0 to n-1){\n                  \
    \  if(i!=j&&i!=k&&j!=k&&a(i+1) + a(j+1) + a(k+1) + 3(a(i) + a(j) + a(k)) % 3 !=\
    \ 0)\n                        ans++\n                }\n            }\n      \
    \  }\n        ans", "        val a = Array.fill(n.toInt)(0l)\n        a(0) = 1\n\
    \        a(1) = 2\n        val numTriples = 0 \n        val pairs = mutable.Stack[mutable.Seq[(Long,\
    \ Long, Long)]]()\n        for (i <- 1 until n) \n        { \n            for\
    \ (j <- 1 until n) \n            {\n                for (k <- 1 until n) \n  \
    \              {\n                    if (i != j &&  j != k) \n              \
    \      {\n                        val sum = (i * i - i + 1) * (j * j - j + 1)\
    \ * (k * k - k + 1)\n                        if (sum % 3 == 0) \n            \
    \            {\n                            val triple = (a(i), a(j), a(k))\n\
    \                            pairs += triple\n                            numTriples\
    \ += 1\n                        } \n                    }\n                }\n\
    \            }\n        }\n        val result = {\n            if (pairs.size\
    \ == 0) 0 else pairs.last.head._3 * numTriples\n        }\n        return result",
  "        val a = mutable.ArrayBuffer(1l)\n        val sum = mutable.ArrayBuffer(1l)\n\
    \        val counter = mutable.ArrayBuffer(1l)\n        val counter2 = mutable.ArrayBuffer(1l)\n\
    \        var k = 1l\n        a.clear()\n        sum.clear()\n        counter.clear()\n\
    \        counter2.clear()\n        val j = 0\n        while(j<n){\n          \
    \  a(j) = j\n            sum += a(j)\n            counter(j) = counter2(j) = k\n\
    \            if((sum % k) == 0){\n                k+=1\n                j+=1\n\
    \            }else{\n                k=1\n                j+=1\n            }\n\
    \        }\n        return counter.last", "        val a = mutable.ArrayBuffer(n)\n\
    \        for( i <- 0 until n ) a.update(i) = i * i - i + 1\n        \n       \
    \ val aList = a.toList\n        \n        var count = 0\n        var triplesMax\
    \ = 0\n        for(i <- 0 until aList.size) {\n            val triples = aList.filter(_\
    \ <= i)\n            triplesMax = math.max(triplesMax, triples.size)\n       \
    \     for(j <- 0 until aList.size) {\n                if(i != j) {\n         \
    \           val triples = aList.filter(_ <= i && _ > j)\n                    count\
    \ = math.max(count, triples.size)\n                }\n            }\n        }\n\
    \        count", "        val a = mutable.ListBuffer(1, 2, 3, n).reverse\n   \
    \     var sum = 0L\n        for(i <- 0 until a.length) {\n            for(j <-\
    \ 0 until a.length) {\n                for(k <- 0 until a.length) {\n        \
    \            sum += a(i) * a(j) * a(k)\n                    if(sum % 3 == 0) {\n\
    \                        return sum\n                    }\n                }\n\
    \            }\n        }\n        return -1", "        var a = ListBuffer.empty[Long]\n\
    \        a.append(1)\n        \n        (1 to n) foreach (i => a(i) = i * i -\
    \ i + 1)\n        \n        var triples = ListBuffer.empty[Int]\n        \n  \
    \      for (i <- a.indices) {\n            if (a(i) < 0) {\n                triples.append(-1)\n\
    \            } else {\n                triples.append(a.take(i + 1).sum)\n   \
    \         }\n        }\n        \n        triples.toList match {\n           \
    \ case a if a.sum % 3 == 0 => a.sum\n            case _ => 0\n        }", "  \
    \      val a = (0 until n)\n        val b = (0 until n)\n        val c = a.toList\n\
    \        \n        var count = 0\n        \n        for(i <- 0 until n){\n   \
    \         for(j <- 0 until n){\n                for(k <- 0 until n){\n       \
    \             if(j > i){\n                        if(k > j){\n               \
    \             if(c.contains((a(i), a(j), a(k)))){\n                          \
    \      count += 1\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        \n\
    \        count", "        val count = scala.collection.mutable.HashSet[Long]()\n\
    \        for(i <- 1 until n) if(scala.math.gcd(i * i - i + 1, 3) == 0) count +=\
    \ i\n        count.toSet.count(_ * _ * _ == 3)", "        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var c = 0\n        var b : Array[Long] = new\
    \ Array[Long](n)\n        var a : Array[Long] = new Array[Long](n)\n        var\
    \ a0 = 1\n        var a1 = 1\n        var a2 = 1\n        var b0 = 1\n       \
    \ var b1 = 1\n        var b2 = 1\n        var a3 : Array[Long] = new Array[Long](n)\n\
    \        while (i < n && j < n && k < n) {\n            b[i] = a0\n          \
    \  a[i] = a0\n            a[j] = a0\n            b[j] = a0\n            b[k] =\
    \ a0\n            k += 1\n        }\n        while (i < n) {\n            b[i]\
    \ = a0\n            a[i] = a0\n            a[j] = a0\n            b[j] = a0\n\
    \            b[k] = a0\n            i += 1\n        }\n        while (j < n) {\n\
    \            b[i] = a0\n            a[i] = a0\n            a[j] = a0\n       \
    \     b[j] = a0\n            b[k] = a0\n            j += 1\n        }\n      \
    \  while (j < n) {\n            b[i] = a0\n            a[i] = a0\n           \
    \ a[j] = a0\n            b[j] = a0\n            b[k] = a0\n            j += 1\n\
    \            k += 1\n        }\n        while (k < n) {\n            b[i] = a0\n\
    \            a[i] = a0\n            a[j] = a0\n            b[j] = a0\n       \
    \     b[k] = a0\n            k += 1\n        }\n        b0 = a[0]\n        b1\
    \ = a[0]\n        b2 = a[0]\n        b3 = a[0]\n        for (i = 1; i < n; i++)\
    \ {\n            b[i] = bi - b1\n            a[i] = ai\n            k = i + 1\n\
    \            while (k < n) {\n                a[k] = aj\n                j = k\
    \ + 1\n            }\n            while (i < n) {\n                a[i] = aj\n\
    \                i += 1\n            }\n            while (j < n) {\n        \
    \        a[i] = aj\n                j += 1\n            }\n            b3 = ai\n\
    \            b2 = ai\n            b1 = ai\n            ai = a0\n            aj\
    \ = a1\n            a0 = a0 + 1\n            a1 = aj\n            a2 = ai\n  \
    \      }\n        c = b0 + b1 + b2\n        for (i = 1; i < n; i++) {\n      \
    \      c += a[i];\n        }\n        return c;", "        val a = new Array[Int](n)\n\
    \        for( i <- 0 until n){\n            a(i) = i * i - i + 1\n        }\n\
    \        val ans = a.filter(i => i % 3 == 0).size\n        a", "        val a\
    \ = Array.fill(n.toInt)(math.pow(3,n.toInt)).toArray\n        for (i<-0 until\
    \ n-1) {\n            a(i) = math.pow(a(i),2)\n        }\n        for (i<-0 until\
    \ n-1) {\n            for(j<-0 until n-1) {\n                for (k<-0 until n-1)\
    \ {\n                    if(i<j && i<k && a(i)+a(j)+a(k) == math.pow(a(i)+a(j),2))\
    \ {\n                        return i+j+k\n                    }\n           \
    \     }\n            }\n        }\n        return 0", "        val a = Array[Long](n)\n\
    \        for (i <- 1 until n) {\n            val j = i * i - i + 1 \n        \
    \    if (j < 3) {\n                a(i - 1) = a(i - 1) + 1\n                a(j)\
    \ = a(j) + 1 \n            }\n        }\n        var sum = 0\n        for (i <-\
    \ 0 until n) {\n            val k = a(i) + a(i) + a(i)\n            if (k == 3)\
    \ sum = sum + 1\n        }\n        sum", "        var a : mutable.ArrayBuffer[Long]\
    \ = new mutable.ArrayBuffer[Long](n)\n        for(i <- 1 until n){\n         \
    \   for(j <- 1 until n){\n                if(i<j){\n                    if(j<n){\n\
    \                        if(a(i) + a(j) + a(j+1) <= 3*a(i+1))\n              \
    \              a.insert(i, a(i) + a(j) + a(j+1))\n                    }\n    \
    \            }\n            }\n        }\n        a.toList.length", "        val\
    \ a = Array[Int](n+1)\n        val b = Array[Int](n+1)\n        val c = Array[Int](n+1)\n\
    \        a(0) = 1\n        a(n) = n+1\n        b.updated(0,0) = a(0)\n       \
    \ c.updated(0,0) = a(0)\n        // Update b and c using previous values of a\n\
    \        for(i <- 0 until a.length-1)\n            b.updated(i,0) = a(i) * a(i)\
    \ - a(i) + b(i+1)\n        for(i <- 0 until a.length-1)\n            c.updated(i,0)\
    \ = a(i) * a(i) - a(i) + c(i+1)\n        val sum = a(0) * b(0) * (a.length-1)\
    \ + c(0) * c((a.length-1))\n        if(sum % 3 == 0) \n            1\n       \
    \ else\n            return 0", "        var sum = 0\n        val a = Array.fill(n.toInt)(1l)\n\
    \        a.update(1l,2l)\n        for(i <- 1l to n) sum += a(i) * a(i) - a(i)\
    \ + a(i)\n        if(sum % 3 == 0) 1\n        else 0", "        var arr : mutable.Seq[Long]\
    \ = mutable.Seq.empty[Long]\n        var i : Long = 1\n        while(i <= n) {\n\
    \            arr = arr :+ (i * i - i + 1)\n            i = i + 1\n        }\n\
    \        var res = 0\n        for (i <- 0 until arr.size) {\n            val sum\
    \ = arr(i)\n            if (sum % 3 == 0) {\n                res += 1\n      \
    \      }\n        }\n        res", "        val a = mutable.MutableList(1 to n)\n\
    \        var sum = 0\n        for(i<- 1 to n) {\n            sum += a(i) * a(i)\
    \ * a(i)\n            if((sum % 3) == 0) {\n                val temp = a(i) *\
    \ a(i) * a(i) - 1\n                sum = sum + temp\n                a(i) = temp\n\
    \            }\n        }\n        a.toSeq.length", "        var i = 0\n     \
    \   var j = n\n        var count = 0\n        while(i <= j) {\n            i +=\
    \ 1\n            if(i % 3 == 0) count = 3 * count\n            if(i % 5 == 0)\
    \ count = 3 * count + 1\n            if(i % 7 == 0) count = 3 * count + 2\n  \
    \          if(i % 11 == 0) count = 3 * count + 3\n            j += 1\n       \
    \ }\n        return count", "        var triplesCount : Long = 0\n        var\
    \ tripletList : mutable.MutableList[Long] = mutable.MutableList()\n        for\
    \ (i<- 1 to n) {\n            val j = (i * i) - i + 1\n            val k = i *\
    \ i\n            if (j < k) tripletList += k\n            else if (tripletList.contains(k))\
    \ triplesCount += 1\n            else tripletList += k\n        }\n        triplesCount",
  "        var a : mutable.MutableList[Long] = mutable.MutableList(1)\n        for\
    \ (i<-0 to n-1) a += i * i - i + 1\n        val triples = a.filter(_ % 3 == 0).size\n\
    \        return triples ", "        if (n < 3L) {\n            return 0L\n   \
    \     }\n        val a = mutable.ArrayBuffer.fill(3L)(0L)\n        a(3L) = n\n\
    \        for (i <- 3L to (n + 1L)) {\n            a(i) = a(i + 1L) + a(i + 1L\
    \ + 1L)\n        }\n        val triples = a.sliding(3).filter(_(_) * _(_) * _(_)\
    \ == 3).toList\n        return triples.map(s => s.last).sum", "        val a =\
    \ mutable.ArrayBuffer(1l)\n        var count : Long = 0\n        for (i <- 1l\
    \ to n){\n            if (a.contains(i * i - i + 1) && i * a[i] - i - i % 3 ==\
    \ 0){\n                count += 1\n                a.remove(i)\n            }\n\
    \        }\n        count", "        val a = scala.collection.mutable.ArrayBuffer.fill(n)(0)\n\
    \        val m = scala.math.pow(n, 3) - 1\n        for(i <- 0 until n ) {\n  \
    \          for(j <- 0 until n) {\n                for(k <- 0 until n) {\n    \
    \                if(i >= j && i >= k && j >= k) {\n                        if(m\
    \ * a[i] + a[j] + a[k] == m) {\n                            a.update(i,1)\n  \
    \                          a.update(j,1)\n                            a.update(k,1)\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        a.length", "        val a = mutable.ArrayBuffer.fill(n.toInt)(0l)\n\
    \        var i = 0l\n        while(i < a.length) {\n            val x = i * i\
    \ - i + 1\n            a.update(i)(x)\n            i += 1\n        }\n       \
    \ a.toSet.count(_ % 3 == 0)", "        val a = scala.collection.mutable.ListBuffer(1\
    \ to n)\n        \n        for (i = 1 until n by 3) {\n            val triple\
    \ = scala.collection.mutable.ListBuffer((a(i), a(i + 1), a(i + 2)))\n        \
    \    \n            for( k <- a if a(i) < a(k) && a(i + a(a(i))) < a(k + a(a(k))))\
    \ triple.append(a(i))\n            \n            if(triple.length == 3 && triple.forall(x=>\
    \ x == x*x + x - 1))\n                a.append(triple)\n        }\n        a.size",
  "        var a = mutable.ArrayBuffer.fill(n)\n        a.update(0, 1l)\n        var\
    \ tripleCount = 0\n        var i = 2\n        var j = a.length - 1\n        while\
    \ (i < j) {\n            var k = i\n            while (k <= j) {\n           \
    \     val product = a.updateOrElse(k, (a.get(k) + a.get(k + 1)) * 3)\n       \
    \         val currentSum = a.get(k) + a.get(k + 1)\n                if (product\
    \ % 3 == 0 && currentSum == 3) {\n                    tripleCount += 1\n     \
    \           }\n                k -= 1\n            }\n            i += 1\n   \
    \         j = k - 1\n        }\n        return tripleCount", "        var sum\
    \ = 0\n        var a = Array[Long](n)\n        for (i <- 1 to a.length) {\n  \
    \          a(i) = i * i - i + 1\n        }\n        for (i <- 1 to a.length -\
    \ 1) {\n            for(j <- 1 to a.length - 1) {\n                for(k <- 1\
    \ to a.length - 1) {\n                    if(i != j && j != k && k != i) {\n \
    \                       sum += a(i) + a(j) + a(k) == 3\n                    }\n\
    \                }\n            }\n        }\n        return sum", "        var\
    \ count = 0\n        for (i <- 1L until n) count += compute(i, i, i)\n       \
    \ count", "        var a : mutable.WrappedArray[Long] = mutable.WrappedArray.empty[Long]\n\
    \        for (i<- 0 until n)\n            a += i * i - i + 1\n        var count\
    \ : Long = 0\n        for (i<- 1 until a.length) {\n            var sum = 0\n\
    \            for (var j <- 1 until a.length) {\n                var k = 0\n  \
    \              var jk : Long = 0\n                for (k <- 0 until a.length)\
    \ {\n                    jk = j + k\n                    if (a(i) == a(ik) &&\
    \ a(j) == a(jk) && a(k) == a(ik+jk))\n                        sum++\n        \
    \        }\n            }\n            if (sum > 3) {\n                count =\
    \ count + 1\n                println(\"count : \"+count)\n            }\n    \
    \    }\n        return count", "        val a = new Array[Long](n)\n        var\
    \ i = 0\n        for (i <- 0 until n) {\n            val j = i + 1\n         \
    \   val k = i + 2\n            a(i) = i * i - i + 1\n            a(j) = (j + 1)\
    \ * j - j + 1\n            a(k) = (k + 1) * k - k + 1\n        }\n        val\
    \ triples = a.map(_ * _ * _)\n        val valid = triples.filter(_ % 3 != 0)\n\
    \        valid.length", "        val a = new Array[Long](n.toInt)\n        //\
    \ Fill the array with n (i = 1...n) values.\n        for (i <- 1 to a.length)\
    \ a(i) = i * i - i + 1\n        // Scan from right to left.\n        var max =\
    \ 0\n        var i = 0\n        for (j <- (a.length to 1) by -1)\n           \
    \ for (k <- (j + 1 to a.length) by -1)\n                if (a(i) > a(j) + a(k)\n\
    \                    && a(i) > max {\n                    max = a(i)\n       \
    \             i = j\n                    k = k\n                }\n        return\
    \ max", "        var counter = 0\n        var max = 0\n        var index = 0\n\
    \        val a = new Array[Long](n)\n        for (i <- 0 until n) {\n        \
    \    a(i) = i * i - i + 1\n        }\n        for (i <- 0 until n) {\n       \
    \     if (a(i) >= max) {\n                max = a(i)\n                index =\
    \ i\n            }\n        }\n        if (max % 3 == 0) {\n            counter\
    \ = counter + 1\n        }\n        return (counter, max)", "        val a = mutable.ArrayBuffer(n)\n\
    \        var i = 0\n        while (i < a.size) {\n            val j = (i + 1)\
    \ %a.size\n            val k = (j + 1) %a.size\n            a(i) = i * i - i +\
    \ 1\n            i += 1\n        }\n        return a.foldLeft(0)((x, y) => math.max(x,\
    \ y)).asInstanceOf[Long]", "        // Initialize an array\n        var array\
    \ = new Array[Long](n)\n        val a = new mutable.MutableList[Long]\n\n    \
    \    // Initialization\n        a(0) = 1\n        for(i<- 1 to (n-1)){\n     \
    \       a(i) = i * i - i + 1\n        }\n\n        // Get the number of triples\
    \ that satisfy our condition\n        var totalTriple = 0\n        for(i <- 0\
    \ to a.size - 1){\n            val j = a.size - i - 1\n            val k = a.size\
    \ - j - 1\n            // We only want to count the triple where i < j < k\n \
    \           val temp = if (i < j) i else j\n            val triple_num = temp\
    \ * temp\n            // The number should equal the square of i\n           \
    \ val isTriple = triple_num == i\n            // We only want to count the triple\
    \ where a[i] + a[j] + a[k] is multiple of 3\n            val isMultipleOfThree\
    \ = triple_num % 3 == 0\n            val total = if (isTriple && isMultipleOfThree)\
    \ totalTriple + 1\n            else totalTriple\n            array.update(i)(total)\n\
    \        }\n\n        array.size + 1", '        // your implementation here',
  "        var maxTriples = 0 // initialize maximum triples count\n        var a :\
    \ mutable.ListBuffer[Long] = mutable.ListBuffer(1l) // (1) Initialize an integer\
    \ list \n        val max = (1l) // (2) Initialize the max value as 1\n       \
    \ val aLen = a.length\n        val numTriplets = (3l) // (3) Initialize the number\
    \ of triplets \n        for (i = 1 until n) // (4) For each index i, do ...\n\
    \        {\n            val current = a.last // (5) Get the last value in a\n\
    \            a.remove(current) // (6) Remove it from a\n            val next =\
    \ aLen // (7) Get the length of a\n            if (current < next) // (8) If the\
    \ current value is smaller than the next one\n            {\n                val\
    \ newValue = (current + next - 1) // (9) Get the current value + the next value\
    \ - 1 and store it in newValue\n                a = (a :+ newValue) // (10) Add\
    \ newValue to the end of a\n            }\n            else // (11) Else\n   \
    \         {\n                val newValue = (current * 3 - 3) // (12) Get the\
    \ current value * 3 - 3 and store it in newValue\n                a = (a :+ newValue)\
    \ // (13) Add newValue to the end of a\n            }\n            if (newValue\
    \ % 3 = 0) // (14) If the newValue is a multiple of 3\n            {\n       \
    \         maxTriples = numTriplets++ // (15) Increment the number of triples by\
    \ 1\n            }\n        }\n        return maxTriples", "        val a = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 1 until n) {\n            a += (i * i - i + 1)\n        }\n\
    \        val b = 0\n        for (i <- a.view.zipWithIndex) {\n            if (b\
    \ == 3) break\n            val t = (a(i), a(i+1), a(i+2))\n            if (t*t\
    \ % 3 == 0) {\n                b+=1\n            }\n        }\n        b", " \
    \       val a = Array.fill[Long](n)(0l)\n        for(i <- 1 to n) {\n        \
    \    a(i) = i * i - i + 1\n        }\n        val pairs = (0 until n).map( i =>\
    \ {\n            (i, a(i), a(i + 1))\n        })\n        val triples = (0 until\
    \ n).filter( i => \n            pairs.exists { case (i, j, k) => \n          \
    \      if((j < k) && (j > i) && (k > i))\n                    a(i) + a(i + 1)\
    \ + a(k + 1) === 3\n                else\n                    false\n        \
    \    }\n        ).size\n        if(n > 3) {\n            triples - (triples %\
    \ (triples % (triples * 2)))\n        } else {\n            triples * (triples\
    \ * (triples * 2))\n        }", "        var result : Long = 0\n        val a\
    \ = List(n)\n        for (i = 1 until n) {\n            val j = i + 1\n      \
    \      val k = n - 1\n            result += if (a[i] + a[j] + a[k] == 3) 1 \n\
    \                else 0\n        }\n        return result", "        val a = scala.collection.mutable.ArrayBuffer.fill(n.toInt)(0)\n\
    \        var i = 0\n        while(i < n) {\n            a(i) = i * i - i + 1 \n\
    \            i += 1\n        }\n        var count = 0\n        a.foreach { x =>\n\
    \            val xx = x + x\n            if (xx < 3) count = count + 1\n     \
    \   }\n        a.clear()\n        return count", "        val a = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        var triplesCounter = 0\n        var i = scala.math.BigInt(1l)\n     \
    \   while(i <  n) {\n            var j = scala.math.BigInt(i)\n            while(j\
    \ <  n) {\n                var k = scala.math.BigInt(j)\n                while(k\
    \ < n) {\n                    val result = i * i * i + j * j + k * k\n       \
    \             if (result % 3 == 0) {\n                        triplesCounter +=\
    \ 1\n                        a.clear()\n                        a.append(i)\n\
    \                        a.append(j)\n                        a.append(k)\n  \
    \                  }\n                    k += 1\n                }\n        \
    \        j += 1\n            }\n            i += 1\n        }\n        a.toList.size",
  "        val a = mutable.ListBuffer.empty[Long]\n        (1 to n).foreach { i =>\n\
    \            (1 to i).foreach { j =>\n                val k = i + j\n        \
    \        if ((i <  j) && (j < k)) {\n                    if (a(i) + a(j) + a(k)\
    \ == 9) {\n                        a += i\n                    }\n           \
    \     }\n            }\n        }\n        if (a exists (_ % 3 == 0)) {\n    \
    \        a.length\n        } else {\n            -1\n        }", "        var\
    \ result = new collection.mutable.ArrayBuffer[(Long, Long, Long)]\n        for\
    \ (i <- 1 to n) {\n            var sum = 0L\n            for (j <- i to n) {\n\
    \                sum += i\n                if (sum < 3L)\n                   \
    \ sum = sum + 3L\n            }\n            if (sum == 3L)\n                result\
    \ += (i -> i -> i).toArray\n        }\n        result.foldLeft(0L)(_ maxBy (_\
    \ _))", "        // Create a list a with length n\n        var a : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        // For each i from 1 to n, add the\
    \ value a[i]\n        for(i<- 1 to n){\n            a += i\n        }\n      \
    \  // Now a = [1, 3, 7, 13, 21]\n        // For each a[i], add a[j], a[k]\n  \
    \      var ans : Long = 0\n        for(i<- 0 until a.size){\n            for(j\
    \ <- i until a.size){\n                for(k <- j until a.size){\n           \
    \         if(i + j + k == a(i) * a(j) * a(k)) ans += 1\n                }\n  \
    \          }\n        }\n        // Return the answer\n        return ans", " \
    \       val a = mutable.ArrayBuffer.fill(n.toInt)(0l)\n        for (i <- 1l to\
    \ n + 1l) {\n            for (j <- i + 1 to n + 1l) {\n                if (i *\
    \ i + j * j == n * (n + 1) * (n + 1))\n                    a(i) += 1\n       \
    \     }\n        }\n        a.foldLeft(0l)(_ + _)", "      val a = Array.ofDim[Long](n)\n\
    \      var i = 0\n      var j = 0\n      var k = 0\n      var count = 0\n    \
    \  while (i < n && j < n && k < n) {\n        a(i) = i * i - i + 1\n        i\
    \ += 1\n        if (i < n) {\n          j += 1\n          if (j < n) {\n     \
    \       k += 1\n          }\n        }\n        count += 1\n      }\n      count",
  "      var counts = mutable.HashMap[Long, Long]()\n      for( i <- 1L to n by 1L\
    \ ) {\n        val tmp = 1L\n        var k = 1L\n        for(j <- 1L to n by 1L\
    \ ) {\n          val tmp2 = k + j\n          if( tmp2 < n) k = tmp2\n        }\n\
    \        val count = (i * i - i + 1) * (k - j + 1)\n        counts(i) = counts.getOrElse(i,\
    \ count) + 1\n      }\n      var max = 0L\n      for( i <- 1 to n by 1L ) {\n\
    \        val count = counts(i)\n        if( count > max ) max = count\n      }\n\
    \      max", "        val a = List.fill(n)(math.abs(1l)).toList\n        for (i\
    \ <- 1l to n) a(math.abs(i)).foreach(t => a(t).foreach(x => a(t).map(b => a(t).filter(_\
    \ != b).map(c => a(t).filter(_ != c).filter(d => d != b).map(_ != c).filter(d\
    \ => d != c).filter(f => f != c).map(_ != c).filter(d => d != c).filter(f => f\
    \ != c).filter(_ != d).map(e => a(t).filter(_ != d).filter(e != b).map(e => a(t).filter(_\
    \ != d).filter(e != c).filter(e != d).filter(f => f != d).filter(_ != e).map(e\
    \ => a(t).filter(_ != e).filter(e != b).map(e => a(t).filter(_ != e).filter(e\
    \ != c).filter(e != d).filter(f => f != e).filter(_ != f).map(f => a(t).filter(_\
    \ != f).filter(f != b).map(f => a(t).filter(_ != f).filter(f != c).filter(f !=\
    \ d).filter(f != e).filter(f != f).filter(_ != g).map(g => a(t).filter(_ != g).filter(g\
    \ != b).map(g => a(t).filter(_ != g).filter(g != c).filter(g != d).filter(g !=\
    \ e).filter(g != f).filter(g != g).filter(_ != h).map(h => a(t).filter(_ != h).filter(h\
    \ != b).map(h => a(t).filter(_ != h).filter(h != c).filter(h != d).filter(h !=\
    \ e).filter(h != f).filter(h != g).filter(h != h).filter(_ != i).map(i => a(t).filter(_\
    \ != i).filter(i != b).map(i => a(t).filter(_ != i).filter(i != c).filter(i !=\
    \ d).filter(i != e).filter(i != f).filter(i != g).filter(i != h).filter(i != i).filter(_\
    \ != j).map(j => a(t).filter(_ != j).filter(j != b).map(j => a(t).filter(_ !=\
    \ j).filter(j != c).filter(j != d).filter(j != e).filter(j != f).filter(j != g).filter(j\
    \ != h).filter(j != i).filter(j != j).filter(_", "        val a = mutable.ArrayBuffer(1l)\n\
    \        for (i <- 1 to n)\n            a += (i * i - i + 1l)\n        val max\
    \ = a.max\n        val result = a.filter { i => max == (i * i - i + 1l) }.size\n\
    \        result", "        var a = Vector.tabulate(n)((_, _) => 0)\n        var\
    \ m = 1\n        a.map(_ + 1).foreach { n =>\n            a.map(_ + 2).foreach\
    \ { m =>\n                if((n + m + 3) % 3 == 0)\n                    println(a._1,\
    \ a._2, a._3)\n            }\n        }\n        a.map(_ + 1).foreach { n =>\n\
    \            a.map(_ + 2).foreach { m =>\n                if((n + m + 3) % 3 ==\
    \ 0)\n                    println(a._1, a._2, a._3)\n            }\n        }\n\
    \        a.map(_ + 1).foreach { n =>\n            a.map(_ + 2).foreach { m =>\n\
    \                if((n + m + 3) % 3 == 0)\n                    println(a._1, a._2,\
    \ a._3)\n            }\n        }\n        a.map(_ + 1).foreach { n =>\n     \
    \       a.map(_ + 2).foreach { m =>\n                if((n + m + 3) % 3 == 0)\n\
    \                    println(a._1, a._2, a._3)\n            }\n        }\n   \
    \     a.map(_ + 1).foreach { n =>\n            a.map(_ + 2).foreach { m =>\n \
    \               if((n + m + 3) % 3 == 0)\n                    println(a._1, a._2,\
    \ a._3)\n            }\n        }\n        a.map(_ + 1).foreach { n =>\n     \
    \       a.map(_ + 2).foreach { m =>\n                if((n + m + 3) % 3 == 0)\n\
    \                    println(a._1, a._2, a._3)\n            }\n        }\n   \
    \     return a.sum.toLong", "        val a = new Array[Long](n)\n        val sum\
    \ = 0\n        for (i <- 0 until a.size) {\n            a(i) = i * i - i + 1\n\
    \            sum += a(i)\n        }\n        sum", "        val a = new mutable.MutableList[Int](n)\n\
    \        var c = 0\n        val b = n - 1\n        while (b >= 0) {\n        \
    \    val d = (n * b) - 3\n            a(c) = d\n            c += 1\n         \
    \   b -= 1\n        }\n        var triples = 0\n        for (a <- a.view.zipWithIndex)\
    \ {\n            triples += a._1 * a._2 * a._3\n        }\n        triples", " \
    \       var a = new Array[Int](n)\n        var i = 0\n        var j = 0\n    \
    \    var k = 0\n        var numTriples = 0\n\n        while(i < a.length && j\
    \ < a.length && k < a.length) {\n            if(i == j && j == k) {\n        \
    \        a(i) = a(i) + a(i) + a(i)\n                numTriples += 1\n        \
    \    }\n            else if(i == j) {\n                a(i) = a(i) + a(i)\n  \
    \              numTriples += 1\n            }\n            else if(i == k) {\n\
    \                a(i) = a(i) + a(i)\n                numTriples += 1\n       \
    \     }\n            else if(i == j) {\n                a(i) = a(i) + a(i)\n \
    \               numTriples += 1\n            }\n            else if(i == k) {\n\
    \                a(i) = a(i) + a(i)\n                numTriples += 1\n       \
    \     }\n            else if(i == j && j != k) {\n                a(i) = a(i)\
    \ + a(i) + a(i)\n                numTriples += 1\n            }\n            else\
    \ {\n                a(i) = a(i) + a(i) + a(i)\n                numTriples +=\
    \ 1\n            }\n            i += 1\n            j += 1\n            k += 1\n\
    \        }\n        \n        if(numTriples == 0) {\n            for(i <- 0 until\
    \ a.length) {\n                a(i) = a(i) + a(i)\n                numTriples\
    \ += 1\n            }\n        }\n        return numTriples", "      val a = List.fill(n.toInt)(0l)\n\
    \      a(0) = 1l\n      for(i <- 1 to n.toInt) {\n        for(j <- i to (if (i\
    \ > 0) n else 1l)) {\n          for(k <- i to (if (i > 0) n else 1l)) {\n    \
    \        if(a(i) + a(j) + a(k)%3 == 0) \n              return a(i) + a(j) + a(k)\n\
    \          }\n        }\n      }\n      return 0l", "        var count = 0\n \
    \       val a = Array.ofDim[Long](n)\n        for(i<- 1 to n-1){\n           \
    \ for(j<- i+1 to n){\n                for(k<- j+1 to n){\n                   \
    \ if(i<j && i<k && j<k){\n                        count += (a(i)+a(j)+a(k))\n\
    \                    }\n                }\n            }\n        }\n        count",
  "        var triples = mutable.ArrayBuffer.empty[Long]\n        for (i<- 1 to n)\
    \ {\n            var maxValue = 0\n            for (j<- i to n) {\n          \
    \      var value = j * (j + 1) - 1\n                if (value == maxValue) {\n\
    \                    triples += 1\n                }\n                if (value\
    \ != maxValue) {\n                    break\n                }\n            }\n\
    \        }\n        triples.toList", "        val m = ListBuffer.empty[Long]\n\
    \        for (i <- 1 to n){\n            val m = i*i*i\n            m += i * i\
    \ // +1 is for symmetry\n            m += i + 1 // +1 is for symmetry\n      \
    \      m += i + 1\n            m += i + 1\n            m += i + 2\n          \
    \  m += i + 3\n            if (m%3 == 0) m.push(i)\n        }\n        m match\
    \ {\n            case x if x.isEmpty => 1l\n            case x => x.size\n   \
    \     }", "        var list : mutable.MutableList[Long] = mutable.MutableList.empty\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while(i < n\
    \ && j < n && k < n) {\n            list = list :+ i*i - i + j\n            i\
    \ = i + 1\n            j = j + 1\n            k = k + 1\n        }\n        var\
    \ count = 0\n        while(i < n && j < n && k < n) {\n            if(list(i)\
    \ > list(j) && list(i) > list(k)) {\n                count = count + 1\n     \
    \       }\n            i = i + 1\n            j = j + 1\n            k = k + 1\n\
    \        }\n        count", "        // O(n), O(n)\n        val list = collection.mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 1 until n) list += (i * i - i + 1)\n        list.foldRight(0)((n,\
    \ acc) => acc + 3 * n % acc)", "        def getMax(n: Long, sum : Long, current\
    \ : Long) : Long = {\n            if (sum > n) sum\n            else getMax(n,\
    \ sum, current + sum)\n        }\n        val a = List.range(1, n+1)\n       \
    \ a.filter(a => a.sum % 3 == 0).map(a => (a(0), a(1), a(2))).count(_._1 + _._2\
    \ + _._3 == 0)", "        var a = Vector.fill(n)(0l).asInstanceOf[mutable.WrappedArray[Long]]\n\
    \        for (i <- 1 to n) {\n            a(i) = i * i - i + 1\n        }\n  \
    \      a.zipWithIndex.filter(_._2 % 3 == 0).size", "        val a = Array.ofDim[Long](n)\n\
    \        var sum = 0\n        for (i <- 1 to n) {\n            a(i) = i * i -\
    \ i + 1\n            sum += a(i)\n        }\n        if (sum % 3 == 0) 1 else\
    \ 0", "        val a = new Array[Long](n)\n        val inc = new mutable.HashMap[Long,\
    \ Int]()\n        val res = new mutable.HashMap[Long, Int]()\n        val max\
    \ = new mutable.HashMap[Long, Long]()\n        var i = 1;\n        while (i <=\
    \ n) {\n            a(i) = i * i - i + 1\n            inc.put(a(i), inc.getOrElse(a(i),\
    \ 0) + 1)\n            i += 1\n        }\n        inc.foreach {\n            case\
    \ (k, v) =>\n            if (v > 0) max.put(k, Math.max(v*v - v + k, v))\n   \
    \     }\n        if (max.isEmpty) 0\n        else {\n            val res = 0\n\
    \            max.foreach {\n                case (k, v) =>\n                res\
    \ += Math.max(v, v*v - v + k)\n            }\n            res\n        }", " \
    \       var ans = 0\n        var triplesList = new mutable.ListBuffer[Int]\n \
    \       for ( i <- 1 to n-1) {\n            if (triplesList.contains(i)) {\n \
    \               triplesList += i\n                continue\n            }\n  \
    \          for ( j <- i to n -1) {\n                if (triplesList.contains(j))\
    \ {\n                    triplesList += j\n                    continue\n    \
    \            }\n                for (k <- i to j -1) {\n                    if\
    \ (triplesList.contains(k)) {\n                        triplesList += k\n    \
    \                    continue\n                    }\n                    ans\
    \ = triplesList.foldLeft(0)((a,v) => a + v) % 3\n                    if (ans ==\
    \ 0) return ans\n                }\n            }\n        }\n        return ans",
  "        val a = mutable.ArrayBuffer.fill(n)(0l)\n        a(0) = 3\n        a(1)\
    \ = -3\n        for(i<-1 to n-1 by -1){\n            for(j<-1 to n-1 by -1){\n\
    \                for(k<-1 to n-1 by -1){\n                    if(i>=j && i>=k\
    \ && j>=k){\n                        if(a(i) + a(j) + a(k) == 0){\n          \
    \                  a(i) = a(i) + a(j) + a(k) - 1\n                        }\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ result = a.sum\n        return result.toLong", "        val a = Array.fill(n.toInt)((n+1l).toInt)\n\
    \        a(0) -= 1\n        var sum = 0\n        for (i <- 0 until a.size) {\n\
    \            val j = i\n            var k = i\n            while (a(k) > 0 &&\
    \ a(j) > 0 && a(k) > a(j)) {\n                k += 1\n            }\n        \
    \    sum += k - a(i)\n            val kk = k\n            while (a(kk) > 0 &&\
    \ a(kk) > a(j)) {\n                kk += 1\n            }\n            a(i) =\
    \ kk\n            a(j) = kk\n            val kj = k\n            while (a(kj)\
    \ > 0 && a(kj) > a(k)) {\n                kj += 1\n            }\n           \
    \ a(i) = kj\n        }\n        val sum2 = sum.toLong\n        if (sum2 < 3l)\
    \ sum2 else sum2", "        val a = List.range(1, n).toArray\n        var result\
    \ : Long = 0\n        for (i1 <- 0 until a.length-1 )\n        for (i2 <- 0 until\
    \ a.length-1 )\n        for (j1 <- 0 until a.length-1 )\n        {\n         \
    \   result += (if(a(i1)>a(i2)) 1 else 0)\n            result += if(a(i1)>a(j1))\
    \ 1 else 0\n            result += if(a(i2)>a(j1)) 1 else 0\n        }\n      \
    \  result", "        val a = Array[Long](n)\n        for (i<- 1 to n) {\n    \
    \        a(i) = i*i-1+i+1\n        }\n        var i = 0\n        var j = 0\n \
    \       var k = 0\n        var sum = 0\n        while (i < n) {\n            while\
    \ (j < n && k<n) {\n                if (a(i) > a(j)) {\n                    j\
    \ = j+1\n                }\n                else {\n                    k = 0\n\
    \                }\n            }\n            sum = sum + a(i)\n            i\
    \ = i+1\n        }\n        sum % 3 == 0", "        val a = new mutable.ArrayList[Long](n)\n\
    \        for ( i <- 0 until n ) {\n            a(i) = i * i - i + 1\n        }\n\
    \        val sum = (a: collection.mutable.Buffer[Long])(0 until a.size).foldLeft(0l)(_\
    \ + _)\n        val result = a.toList.zipWithIndex.filter(_._1 + _._2 < 3L).map(_._1.toLong\
    \ + _._2.toLong).foldLeft((0l, 0l))((_,i) => {\n            val v = (i + 2L) *\
    \ i - 2 * i + 1\n            if (v == 3L) (v,1L) else (i,v)\n        })._1\n \
    \       sum - result", "        val a = mutable.ListBuffer[Long]()\n        for\
    \ (i<-0 until n) {\n            a += i\n        }\n        var i = 0\n       \
    \ var j = 0\n        var k = 0\n        var triple = 0\n        var triplesCount\
    \ = 0\n        while (i < a.length) {\n            triple = a(i) + a(j) + a(k)\n\
    \            if (triple % 3 == 0) {\n                triplesCount += 1\n     \
    \       }\n            if (k > 0) {\n                k -= 1\n            } else\
    \ {\n                j += 1\n                if (j > a.length - 1) {\n       \
    \             i += 1\n                    j = 0\n                }\n         \
    \   }\n        }\n        (triplesCount, a(0), a(1))", "        val a = Array(n,\
    \ 3L) \n        var i = 0\n        var j = 0\n        var k = 0\n        var triples\
    \ = 1\n        while(i < n && j < n && k < n) {\n            if (i == j && j ==\
    \ k) {\n                triples += 1\n            }\n            else if (j >\
    \ i && j > k) {\n                a(i) = a(i) + a(j)\n                a(i) = a(i)\
    \ + a(k)\n                a(i) = a(i) - a(k)\n            }\n            else\
    \ if (k > i && k > j) {\n                a(j) = a(j) + a(k)\n                a(j)\
    \ = a(j) - a(i)\n                a(j) = a(j) - a(k)\n            }\n         \
    \   else if (j > i && k < j) {\n                a(i) = a(i) + a(k)\n         \
    \       a(i) = a(i) - a(i)\n                a(i) = a(i) - a(k)\n            }\n\
    \            else if (k < i && i < k) {\n                a(j) = a(j) + a(k)\n\
    \                a(j) = a(j) - a(i)\n                a(j) = a(i) - a(j)\n    \
    \        }\n            else if (k < i && j > i) {\n                a(j) = a(j)\
    \ + a(k)\n                a(j) = a(j) - a(i)\n                a(j) = a(i) - a(k)\n\
    \            }\n            else if (i < j && j < k) {\n                a(i) =\
    \ a(i) + a(k)\n                a(i) = a(i) - a(i)\n                a(i) = a(i)\
    \ - a(k)\n            }\n            else if (k < j && i < j) {\n            \
    \    a(j) = a(j) + a(k)\n                a(j) = a(j) - a(i)\n                a(j)\
    \ = a(i) - a(k)\n            }\n            else if (i < j && k > j) {\n     \
    \           a(j) = a(j) + a(k)\n                a(j) = a(j) - a(i)\n         \
    \       a(j) = a(i) - a(k)\n            }\n            else if (j < k) {\n   \
    \             a(i) = a(i) + a(k)\n                a(i) = a(i) - a(i)\n       \
    \         a(i) = a(i) - a(k)\n            }\n            i += 1\n            j\
    \ += 1\n            k += 1\n        }\n        return a(n) ", "        val a =\
    \ new mutable.Array[Int](n)\n        a.init {\n            if (_ < 0 || _ >= n)\
    \ throw new IndexOutOfBoundsException\n            (_ + 1) = 2 * _ - 2\n     \
    \   }\n        var sum = 0\n        for (i1 <- 0 until n) {\n            for (i2\
    \ <- 0 until i) {\n                for (i3 <- 0 until i) {\n                 \
    \   if (!(i1 <= i2 || i2 <= i3 || i1 <= i3)) {\n                        val tmp\
    \ = a(i1) + a(i2) + a(i3)\n                        if (tmp > sum) sum = tmp\n\
    \                    }\n                }\n            }\n        }\n        sum",
  "        var count = 0\n        val a = mutable.ArrayBuilder.makeBuilder(3)\n  \
    \      for (i <- 0 until n) {\n            val triple = (a(i), a(i+1), a(i+2))\
    \ match {\n                case (i1, i2, i3) if (i1 + i2 + i3) % 3 == 0 => (i1,\
    \ i2, i3)\n                case _ =>\n            }\n            count += 1\n\
    \        }\n        a.result", "        val a = scala.collection.mutable.ArrayBuffer(3L).withMutable\
    \ { mutable.ArrayBuffer(0L) }\n        for (i<- 1 to n)\n            a(i) = i\
    \ * i - i + 1\n        a.filter {\n            case(a,b,c) => b+c == a*a + a\n\
    \        }.length", "        val a = Array.fill(n)(0).filter(_.isEven)\n     \
    \   val d = a.zip(a).zip(a).count{case ((a1, a2), (a3, a4)) => a1 == a2 && a2\
    \ == a3 && a3 == a4}\n        if (d == 3l)\n            1l\n        else\n   \
    \         d", "        var count = 0\n        var i = 0\n        var j = 0\n \
    \       var k = 0\n        val a = new Array[Long](n)\n        while(i < n) {\n\
    \            val j = 0\n            while(j < i) {\n                val k = i\n\
    \                while(k >= j && a(k) > a(k + 1) + a(k + 2))\n               \
    \     k -= 1\n                count += 1\n                a(i) = a(i) * 3 - a(i\
    \ + 1) + a(k + 2)\n                j -= 1\n            }\n            i += 1\n\
    \        }\n        count + 1", "        val a = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 1 to n)\n            a += i * i - i + 1\n        a", "    \
    \    var a : Array[Int] = Array()\n        for(i <- 0 until n)\n            a\
    \ += i\n        \n        val nRes = a.filter(_ % 3 == 0).length\n        val\
    \ maxRes = a.filter(_ % 3 == 0).max\n        \n        a.filter(_ % 3 != 0).map(x\
    \ => if(x > maxRes) x else maxRes)"]
stop_tokens:
- "\n    }\n"
