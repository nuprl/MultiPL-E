language: scala
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        val result = \"db\" + binary.substring(binary.length\
    \ - 3, binary.length)\n        result ++ \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmp0l6znnus.scala:16)\n\tat Problem$.main(tmp0l6znnus.scala:20)\n\
    \tat Problem.main(tmp0l6znnus.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val base = 10\n\
    \        val binary = decimal.toString.reverse.foldLeft(\"\") { (s, dec) => s\
    \ + dec.toChar(base) }\n        val pad = \"\" * ((decimal.toString.length + 1)\
    \ - binary.length)\n        (pad + binary + \"db\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpf1yu5qe8.scala:16:81 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = decimal.toString.reverse.foldLeft(\e\
    [31m\"\"\e[0m) { (\e[36ms\e[0m, \e[36mdec\e[0m) => s + dec.toChar(base) }\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \e[33mmethod\e\
    [0m \e[35mtoChar\e[0m in \e[33mclass\e[0m \e[35mChar\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009514
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal ==\
    \ 0) {\n          return \"0\"\n        }\n        \n        var result: String\
    \ = \"1\"\n        var remainder: Long = decimal % 2\n        \n        for(i\
    \ <- 0 until 8) {\n          if(remainder > 0) {\n            result = (remainder.toString.charAt(0)\
    \ + result) \n          }\n          remainder = (decimal / 2).toLong\n      \
    \  }\n        \n        result += (remainder.toString.charAt(0) + result) \n \
    \       \n        result += \"db\"\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp29qnu61u.scala:35)\n\tat Problem.main(tmp29qnu61u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalStr\
    \ = Integer.toString(decimal)\n        val binary = mutable.ListBuffer.empty[String]\n\
    \        var i = decimalStr.length - 1\n        while (i >= 0) {\n           \
    \ if (decimalStr(i) == '0') {\n                binary.append(\"1\")\n        \
    \    } else {\n                binary.append(\"0\")\n            }\n         \
    \   i--\n        }\n        binary.reverse.toList.reverse.mkString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp6eoyg5c.scala:24:15 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            i--\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp6eoyg5c.scala:15:42\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalStr\e\
    [0m = Integer.toString(decimal)\n\e[31m\e[31m   |\e[0m                       \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \              Found:    (decimal : Long)\n\e[31m   |\e[0m                   \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpp6eoyg5c.scala:16:21 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal <\
    \ 0) decimal = -1l - decimal\n        val binary = Decimal.bits(decimal).toList\n\
    \        binary.reverse.foreach(e => println(e.toBinaryString))\n        binary.reverse.tail.foreach(e\
    \ => println(e.toBinaryString))\n        binary.reverse.tail.head + binary.reverse.head\
    \ + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp75h6jnt4.scala:15:33 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mif\e[0m (decimal < \e[31m0\e[0m) decimal\
    \ = -\e[31m1l\e[0m - decimal\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Reassignment to val decimal\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp75h6jnt4.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = Decimal.bits(decimal).toList\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: Decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009512
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ scala.collection.mutable.ArrayBuffer.empty[String]\n        decimal match {\n\
    \            case 0 => binary.append(\"0\")\n            case x => for(num <-\
    \ 0 until decimal.toInt by 2){\n                if(num == 0){\n              \
    \      binary.append(\"0\")\n                }\n                else if(num %\
    \ 2 == 0){\n                    binary.append(\"1\")\n                }\n    \
    \            else{\n                    binary.append(\"0\")\n               \
    \ }\n            }\n        }\n        binary.append(\"db\")\n        binary.toList.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7to2ocx_.scala:34)\n\tat Problem.main(tmp7to2ocx_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // write your\
    \ code here\n        var binaryString = StringBuilder()\n        var remainder\
    \ = decimal\n        while (remainder > 0) {\n            binaryString.append(remainder\
    \ % 2)\n            remainder = remainder / 2\n        }\n        binaryString.reverse\n\
    \        binaryString.append('db')\n        binaryString.reverse\n        binaryString.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpt36jbi5u.scala:23:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        binaryString.append(\e[31m'db\e[0m')\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpt36jbi5u.scala:23:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ binaryString.append(\e[31m'db\e[0m')\n\e[31m\e[31m   |\e[0m                \
    \            ^\e[0m\n\e[31m   |\e[0msymbol literal 'db is no longer supported,\n\
    \e[31m   |\e[0muse a string literal \"db\" or an application Symbol(\"db\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{db} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n2 errors found\n"
  stdout: ''
  timestamp: 1660009514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ : String = \"\"\n        decimalToBinaryImpl(decimal, 0, 0)\n        binaryString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcb34o7yn.scala:16:8 -------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        decimalToBinaryImpl(decimal, \e[31m0\e[0m, \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Not found: decimalToBinaryImpl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009512
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result :\
    \ StringBuilder = new StringBuilder\n        decimal match {\n            case\
    \ n if n <= 0 => \"db\"\n            case n if n == 1 => \"db1\"\n           \
    \ case n if n == 2 => \"db10\"\n            case n if n == 3 => \"db11\"\n   \
    \         case n if n == 4 => \"db100\"\n            case n if n == 5 => \"db101\"\
    \n            case n if n == 6  => \"db110\"\n            case n if n == 7  =>\
    \ \"db111\"\n            case n if n == 8  => \"db1000\"\n            case n if\
    \ n == 9  => \"db1001\"\n            case n if n == 10 => \"db1010\"\n       \
    \     case n if n == 11 => \"db1011\"\n            case n if n == 12 => \"db1100\"\
    \n            case n if n == 13 => \"db1101\"\n            case n if n == 14 =>\
    \ \"db1110\"\n            case n if n == 15 => \"db1111\"\n        }\n       \
    \ decimal match {\n            case n if n > 15 => \"\"\n            case n if\
    \ n > 14 => result.append(\"db1111\")\n            case n if n > 13 => result.append(\"\
    db1110\")\n            case n if n > 12 => result.append(\"db1100\")\n       \
    \     case n if n > 11 => result.append(\"db10\")\n            case n if n > 10\
    \ => result.append(\"db101\")\n            case n if n > 9 => result.append(\"\
    db100\")\n            case n if n > 8 => result.append(\"db1001\")\n         \
    \   case n if n > 7 => result.append(\"db1000\")\n            case n if n > 6\
    \ => result.append(\"db1100\")\n            case n if n > 5 => result.append(\"\
    db110\")\n            case n if n > 4 => result.append(\"db1101\")\n         \
    \   case n if n > 3 => result.append(\"db11\")\n            case n if n > 2 =>\
    \ result.append(\"db111\")\n            case n if n > 1 => result.append(\"db101\"\
    )\n            case n if n > 0 => result.append(\"db1\")\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.MatchError: 0 (of class java.lang.Long)\n\tat Problem$.decimalToBinary(tmp4hycn61w.scala:50)\n\
    \tat Problem$.main(tmp4hycn61w.scala:55)\n\tat Problem.main(tmp4hycn61w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = decimal.toBinaryString\n\
    \        val db = \"db\".toCharArray\n\n        val res =\n            bits.padTo(8,\
    \ \"0\") + db + bits.dropRight(8).toCharArray\n\n        \"db\" + res.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_vnd801.scala:19:31 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            bits.padTo(\e[31m8\e[0m, \e[31m\"0\"\e[0m)\
    \ + db + bits.dropRight(\e[31m8\e[0m).toCharArray\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of IndexedSeq[Matchable],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val remainder\
    \ = decimal.toInt\n        val decimal2 = decimal - remainder\n        val stringBuilder\
    \ = new StringBuilder()\n        var i = 0\n        while(decimal2 != 0) {\n \
    \           stringBuilder.append(if (decimal2 % 2 == 0) \"0\" + \"1\" + \"0\"\
    \ else \"1\" + \"0\" + \"0\")\n            decimal2 /= 2\n            i += 1\n\
    \        }\n        stringBuilder.append(if (remainder != 0) \"0\" + \"1\" else\
    \ \"1\" + \"0\")\n        stringBuilder.append(\"db\")\n        stringBuilder.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp87x_uk5m.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            decimal2 /= \e[31m2\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not\
    \ a member of Long - did you mean decimal2.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val n = decimal.toInt\n\
    \        val str = \"\"\n        while(decimal > 0) {\n            str +=(decimal.toInt\
    \ % 2).toString\n            decimal /= 2\n        }\n        str + \"db\"+ str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeevuv9bu.scala:18:16 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            str +=(decimal.toInt % \e[31m2\e[0m).toString\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean str.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpeevuv9bu.scala:19:20 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val reversed\
    \ = decimal.toString.reverse.grouped(2).map(_.mkString).reverse\n        val extra\
    \ = \"db\".toCharArray.mkString\n        (reversed + extra + reversed + extra).padToString(16,\
    \ '0')\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjgmwwobu.scala:15:75 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mreversed\e[0m = decimal.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result :\
    \ String = \"\"\n        var remainder : Long = decimal\n        var i = decimal.toInt\n\
    \n        // Convert the number to binary\n        for(j <- 0 until i) {\n   \
    \         if(remainder < 1) {\n                result += \"0\"\n             \
    \   remainder = 0\n            } else if(remainder < 2) {\n                result\
    \ += \"1\"\n                remainder = 0\n            } else {\n            \
    \    result += \"0\"\n                remainder = remainder - 2\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdiwt761_.scala:35)\n\tat Problem.main(tmpdiwt761_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ new mutable.MutableList[Char]\n        for (i <- decimal.toInt until decimal\
    \ + 1) {\n            if (i >= 10) binary.addOne()\n            else binary.addZero()\n\
    \        }\n        if (decimal.equals(1l)) {\n            binary.addOne()\n \
    \       }\n        binary.addOne()\n        binary.addOne()\n        binary.addZero()\n\
    \        binary.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnwv8u0k5.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mChar\e[0m]\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwv8u0k5.scala:16:38\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i <-\
    \ decimal.toInt until decimal + \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m       \
    \                               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                          Found:    Long\n\e[31m   |\e[0m                   \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var bitString\
    \ = decimal.toBinaryString()\n        var result : String = \"\"\n        for(i\
    \ <- 0 to bitString.length -2){\n            result += \"0b\"\n        }\n   \
    \     result += \"0\"\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppstvr_5l.scala:15:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mbitString\e[0m = decimal.toBinaryString()\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (i: Int): Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ decimal.toBinaryString()\n        if (decimal.isLeadingZero) binary = \"db\"\
    \ + binary\n        var lastIndex = binary.length - 1\n        var zeros = 0\n\
    \        while (zeros < decimal.asInstanceOf[Long] - lastIndex) {\n          \
    \  binary = binary + \"0\"\n            lastIndex--\n            zeros++\n   \
    \     }\n        return binary\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpavcyqirv.scala:22:19 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            zeros++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpavcyqirv.scala:15:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ \e[33mvar\e[0m \e[36mbinary\e[0m = decimal.toBinaryString()\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringOps\e[0m: (i: Int): Char\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpavcyqirv.scala:16:20 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mif\e[0m (decimal.isLeadingZero) binary = \e[31m\"db\"\e[0m +\
    \ binary\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value isLeadingZero is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val num = (decimal.toString\
    \ + \"\")\n        val binary = new mutable.MutableList[Char]()\n        var index\
    \ = 0\n        while (index < num.length) {\n            val remainder = num.charAt(index)\
    \ - '0';\n            if (remainder >= 10) {\n                val newValue = remainder\
    \ % 10;\n                binary.add('0' + newValue);\n                index +=\
    \ 1\n            } else {\n                binary.add('0' + remainder)\n     \
    \           index += 1\n            }\n        }\n        binary.add('d')\n  \
    \      binary.add('b')\n        binary.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt8rdoqxo.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def decimalToBin(num:Long)\
    \ : String = {\n            val bits = num.toBits\n            var result = \"\
    \"\n            var i = bits.length - 1;\n            while (i >= 0) {\n     \
    \           result += bits.toChar(i).toString.reverse\n                i--;\n\
    \            }\n            return result;\n        }\n        // We want to keep\
    \ the first few bits and shift everything else over\n        val bits = decimal.toBits\n\
    \        val numBits = bits.length\n        val firstBits = bits.take(numBits\
    \ - 2)\n        val rest = bits.drop(numBits - 2)\n        // We need the first\
    \ bit to determine what position the next bit should be at\n        val firstDigit\
    \ = if (firstBits.isEmpty) 0 else 1\n        val numDigits = numBits - firstDigit\
    \ - 1\n        val result = \"db\"\n        if (numDigits == 0) {\n          \
    \  // No remainder, just a single digit\n            result += decimalToBin(decimal)\n\
    \        } else {\n            // There are remainders.  Add leading zeros and\
    \ place remainder at correct position\n            val firstRemainder = if (firstDigit\
    \ == 1) 0 else rest.toChar(0).toString.reverse\n            val remainderIndex\
    \ = firstDigit - 1\n            var remainder = \"\"\n            for (i <- 0\
    \ until numDigits) {\n                remainder = \"0\" + (remainder + decimalToBin(rest.dropRight(1)))\
    \ + remainder\n                remainderIndex -= 1\n            }\n          \
    \  result = firstRemainder + remainder\n        }\n        return result;\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1hxfphl1.scala:21:19 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                i--;\n\e[31m\e[31m   |\e[0m         \
    \          ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1hxfphl1.scala:16:27\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbits\e[0m = num.toBits\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         value toBits is not a member of Long - did you mean\
    \ num.toByte?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1hxfphl1.scala:26:27\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbits\e[0m = decimal.toBits\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     value toBits is not a member of Long - did you mean decimal.toByte?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1hxfphl1.scala:36:19 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            result += decimalToBin(decimal)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of String - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp1hxfphl1.scala:44:31 ------------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m                remainderIndex -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value -=\
    \ is not a member of Int - did you mean remainderIndex.!=?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp1hxfphl1.scala:46:19 -----------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m            result = firstRemainder + remainder\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val b = BigInt(decimal).toBinaryString\n\
    \        val pad = \"db\".repeat(decimal.toString.length + 1)\n        val result\
    \ = pad + b + pad\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpad42upzr.scala:15:32 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = BigInt(decimal).toBinaryString\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value toBinaryString is not a member of BigInt\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ here\n        val binary = new mutable.StringBuilder\n        for(i <- 0 until\
    \ decimal.toInt) {\n            val power = decimal.toInt - i\n            if(power\
    \ > 1) \n                binary.append(1l)\n            else if(power == 1)\n\
    \                binary.append(0)\n            else\n                binary.append(1)\n\
    \        }\n        binary.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyzdmy97m.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ decimal.toString(2).reverse.map(x => (x == '1').toString)\n        (result.tail,\
    \ result.head) match {\n            case (Array(), _) => result.toString\n   \
    \         case (Array(head), Array(_)) => head + result.toString\n           \
    \ case (_, Array(tail)) => head + tail.reverse.map(x => (x == '1').toString).toString\
    \ + result.toString\n            case _ => result.toString\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp85fmmu2w.scala:15:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = decimal.toString(\e\
    [31m2\e[0m).reverse.map(\e[36mx\e[0m => (x == \e[31m'1'\e[0m).toString)\n\e[31m\e\
    [31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m   \
    \      too many arguments for \e[33mmethod\e[0m \e[35mtoString\e[0m in \e[33mclass\e\
    [0m \e[35mAny\e[0m: (): String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp85fmmu2w.scala:18:49\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e\
    [0m (Array(head), Array(_)) => head + result.toString\n\e[31m\e[31m   |\e[0m \
    \                                           ^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.properties AsScalaMap\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp85fmmu2w.scala:19:37\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e\
    [0m (_, Array(tail)) => head + tail.reverse.map(x => (x == \e[31m'1'\e[0m).toString).toString\
    \ + result.toString\n\e[31m\e[31m   |\e[0m                                   \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                     Not found: head\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ new mutable.StringBuilder\n        var decimal2 = decimal\n        var bit =\
    \ 1\n\n        while(decimal2 > 0) {\n            if(decimal2 % 2 == 0) {\n  \
    \              binary.append(\"0\")\n            } else {\n                binary.append(\"\
    1\")\n            }\n\n            decimal2 /= 2\n        }\n\n        binary\
    \ += binary.reverse\n\n        binary = binary.reverse\n\n        binary.insert(0,\"\
    db\")\n        binary.append(\"db\")\n\n        return binary.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqhpnebwt.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        val binaryLength = binary.length\n        val\
    \ output = new StringBuilder(binary.length)\n        var i = 0\n        while(i\
    \ < binaryLength) {\n            val curr = binary(i)\n            output.append('0')\n\
    \            i += 1 while (i + 1 < binaryLength && curr != binary(i + 1))\n  \
    \          output.append('1')\n            i += 1 while (i + 1 < binaryLength\
    \ && curr == binary(i + 1))\n        }\n        output + binary.takeRight(binaryLength)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzsrvq3z4.scala:22:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            i += \e[31m1\e[0m \e[33mwhile\e[0m (i + \e\
    [31m1\e[0m < binaryLength && curr != binary(i + \e[31m1\e[0m))\n\e[31m\e[31m \
    \  |\e[0m                   ^^^^^\e[0m\n\e[31m   |\e[0m                   end\
    \ of statement expected but 'while' found\n\e[31m\e[31m-- Error: /tmp/tmpzsrvq3z4.scala:24:19\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \     i += \e[31m1\e[0m \e[33mwhile\e[0m (i + \e[31m1\e[0m < binaryLength && curr\
    \ == binary(i + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   end of statement expected but 'while' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzsrvq3z4.scala:26:15 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        output + binary.takeRight(binaryLength)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of\
    \ StringBuilder, but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009525
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ decimal.toBinaryString\n        if(result.length > 32) {\n            result.substring(0,31)\
    \ + \"db\"\n        }\n        else {\n            result + \"db\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpefpp6n0o.scala:24)\n\tat Problem.main(tmpefpp6n0o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        for( i <- decimal to 2l toInt by 1 ){\n            binary += if(\
    \ (i.toLong.toBinaryString).length < 8 )\n                (\"0\" * (8 - i.toLong.toBinaryString.length)).toBinaryString\
    \ + i.toLong.toBinaryString\n            else\n                i.toLong.toBinaryString\n\
    \        }\n        binary += \"db\"\n        binary += binary.substring( binary.length\
    \ - 4 )\n        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwb_vm76k.scala:16:41 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m( i <- decimal to \e[31m2l\e[0m\
    \ toInt by \e[31m1\e[0m ){\n\e[31m\e[31m   |\e[0m                            \
    \             ^\e[0m\n\e[31m   |\e[0m                                 ')' expected,\
    \ but integer literal found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwb_vm76k.scala:17:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            binary +=\
    \ \e[33mif\e[0m( (i.toLong.toBinaryString).length < \e[31m8\e[0m )\n\e[31m\e[31m\
    \   |\e[0m                      ^^\e[0m\n\e[31m   |\e[0m                     \
    \ expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpwb_vm76k.scala:16:32 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m( i <- decimal to \e[31m2l\e[0m\
    \ toInt by \e[31m1\e[0m ){\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toInt is not a member of scala.collection.immutable.NumericRange.Inclusive[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwb_vm76k.scala:16:38 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m( i <- decimal to \e[31m2l\e[0m\
    \ toInt by \e[31m1\e[0m ){\n\e[31m\e[31m   |\e[0m                            \
    \          ^^\e[0m\n\e[31m   |\e[0m                                      Not found:\
    \ by\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal ==\
    \ 0) {\n            return \"0\"\n        } else if (decimal > 0) {\n        \
    \    var binary = String.empty\n            while (decimal > 0) {\n          \
    \      binary += decimalToBinary(decimal - 1)\n                decimal -= 1\n\
    \            }\n            return binary + \"b\"\n        } else {\n        \
    \    var binary = \"1b\"\n            while (decimal < 0) {\n                binary\
    \ += \"0\" + decimalToBinary(-decimal)\n                decimal += 1\n       \
    \     }\n            return \"db\" + binary + \"db\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmtpf5y5l.scala:18:32 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mvar\e[0m \e[36mbinary\e[0m = String.empty\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value empty is not a member of object String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpmtpf5y5l.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                decimal -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value -=\
    \ is not a member of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpmtpf5y5l.scala:28:24 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m                decimal += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value += is not\
    \ a member of Long - did you mean decimal.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var currentBin\
    \ : String = \"\"\n        var binary : Int = 0\n        var remainder : Long\
    \ = decimal\n        while (decimal != 0) {\n            binary = decimal % 2\n\
    \            currentBin = binaryToBinary(binary)\n            decimal /= 2\n \
    \           if (decimal != 0) {\n                remainder = remainder + decimal\n\
    \            }\n        }\n        currentBin + binaryToBinary(remainder)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm9vz8u5d.scala:19:21\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            binary = decimal\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Found:    Long\n\e[31m   |\e[0m          \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpm9vz8u5d.scala:20:25 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            currentBin = binaryToBinary(binary)\n\e[31m\e[31m   |\e[0m    \
    \                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \      Not found: binaryToBinary\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpm9vz8u5d.scala:21:20 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value /= is not a member of Long - did you mean\
    \ decimal.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm9vz8u5d.scala:26:21\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        currentBin + binaryToBinary(remainder)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: binaryToBinary\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ = \"\"\n        var decimalToBinary = decimal.toBinaryString\n        var numberOfDigits\
    \ = decimalToBinary.length\n        \n        // Removing extra characters at\
    \ the begining and at the end\n        if(decimalToBinary.length < 3)\n      \
    \  decimalToBinary = Array(0,decimalToBinary)\n        \n        if(decimalToBinary.length\
    \ > 4)\n        decimalToBinary = Array(decimalToBinary.dropRight(decimalToBinary.length-4),\
    \ decimalToBinary(0), decimalToBinary(decimalToBinary.length-4))\n        \n \
    \       \n        for(i <- 0 until decimalToBinary.length-1)\n        {\n    \
    \        if(decimalToBinary(i) != \"0\")\n            {\n                binaryString\
    \ += decimalToBinary(i)\n            }\n        }\n        \n        for(i <-\
    \ 0 until numberOfDigits - 1)\n        {\n            binaryString += \"0\"\n\
    \        }\n        \n        \n        binaryString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ecw_5yg.scala:21:26\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        decimalToBinary = Array(\e\
    [31m0\e[0m,decimalToBinary)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Array[Matchable]\n\e[31m\
    \   |\e[0m                          Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8ecw_5yg.scala:24:26 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        decimalToBinary = Array(decimalToBinary.dropRight(decimalToBinary.length-\e\
    [31m4\e[0m), decimalToBinary(\e[31m0\e[0m), decimalToBinary(decimalToBinary.length-\e\
    [31m4\e[0m))\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Array[Matchable]\n\e[31m\
    \   |\e[0m                          Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp8ecw_5yg.scala:29:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m(decimalToBinary(i) != \e[31m\"\
    0\"\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1660009525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // The code below\
    \ solves the problem in one line. First we convert decimal to binary format. Then\n\
    \        // we append an extra character ('d') to mark the beginning and end of\
    \ the string to be returned\n        // (note that in python, we could directly\
    \ use \"'%s'\" % str(decimal). The reason why we use \"'%s'\" is\n        // because\
    \ the string is converted to string in scala's toString() function, which is different\
    \ from\n        // python's). Then we append 'd' and 'b' at the beginning and\
    \ end of binary string\n        (decimal.toBinaryString.reverse).padToLength(8,\
    \ 'd') + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr4csd1cs.scala:20:41 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        (decimal.toBinaryString.reverse).padToLength(\e\
    [31m8\e[0m, \e[31m'd'\e[0m) + \e[31m\"db\"\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ padToLength is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660009524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      var binary = \"\
    \"\n      var numOfDigits = 0\n      while (decimal > 0 ) {\n        binary =\
    \ binary + decimalToBinary(decimal % 2) + if (numOfDigits % 2 == 0) \"0\" else\
    \ \"1\"\n        decimal = decimal / 2\n        numOfDigits = numOfDigits + 1\n\
    \      }\n      return binary.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr5ahzl12.scala:18:57 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        binary = binary + decimalToBinary(decimal % \e\
    [31m2\e[0m) + \e[33mif\e[0m (numOfDigits % \e[31m2\e[0m == \e[31m0\e[0m) \e[31m\"\
    0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m             \
    \                                            ^^\e[0m\n\e[31m   |\e[0m        \
    \                                expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr5ahzl12.scala:19:16 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        decimal = decimal / \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var ret = \"\"\
    \n        var remainder = decimal\n        var remainderI = 0\n        var remainderII\
    \ = 0\n        var remainderIII = 0\n        var remainderIV = 0\n        var\
    \ remainderV = 0\n        var remainderVI = 0\n        var remainderVII = 0\n\
    \        var remainderIX = 0\n        var remainderX = 0\n        var remainderXI\
    \ = 0\n        var remainderXI = 0\n        var remainderXII = 0\n        var\
    \ remainderXIII = 0\n        var remainderXIV = 0\n        var remainderXV = 0\n\
    \        var remainderXVI = 0\n        var remainderXVII = 0\n        var remainderXX\
    \ = 0\n        var remainderXXI = 0\n        var remainderXXII = 0\n        var\
    \ remainderXXIII = 0\n        var remainderXXIV = 0\n        var remainderXXV\
    \ = 0\n        var remainderXXVI = 0\n        var remainderXXVII = 0\n       \
    \ var remainderXXX = 0\n        var remainderXXXI = 0\n        var remainderXXXII\
    \ = 0\n        var remainderXXXIII = 0\n        var remainderXXXIV = 0\n     \
    \   var remainderXXXV = 0\n        var remainderXXXVI = 0\n        var remainderXXXVII\
    \ = 0\n        var remainderXXXX = 0\n        var remainderXXIX = 0\n        var\
    \ remainderXXXIII = 0\n        var remainderXXXIV = 0\n        var remainderXXXV\
    \ = 0\n        var remainderXXXVI = 0\n        var remainderXXXVII = 0\n     \
    \   var remainderXXV = 0\n        var remainderXXVI = 0\n        var remainderXXVII\
    \ = 0\n        var remainderXXIX = 0\n        var remainderXIX = 0\n        var\
    \ remainderXXI = 0\n        var remainderXI = 0\n        var remainderI = 0\n\
    \        var remainder = 0\n        var temp = 0\n        var temp1 = \"\"\n \
    \       var temp2 = \"\"\n        var temp3 = \"\"\n        var temp4 = \"\"\n\
    \        var temp5 = \"\"\n        var temp6 = \"\"\n        var temp7 = \"\"\n\
    \        var temp8 = \"\"\n        var temp9 = \"\"\n        var temp10 = \"\"\
    \n        var temp11 = \"\"\n        var temp12 = \"\"\n        var temp13 = \"\
    \"\n        var temp14 = \"\"\n        var temp15 = \"\"\n        var temp16 =\
    \ \"\"\n        var temp17 = \"\"\n        var temp18 = \"\"\n        var temp19\
    \ = \"\"\n        var temp20 = \"\"\n        var temp21 = \"\"\n        var temp22\
    \ = \"\"\n        var temp23 = \"\"\n        var temp24 = \"\"\n        var temp25\
    \ = \"\"\n        var temp26 = \"\"\n        var temp27 = \"\"\n        var temp28\
    \ = \"\"\n        var temp29 = \"\"\n        var temp30 = \"\"\n        var temp31\
    \ = \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2vpamxi4.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mremainderXI\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mremainderXI\
    \ is already defined as \e[33mvariable\e[0m \e[35mremainderXI\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2vpamxi4.scala:52:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mremainderXXXIII\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremainderXXXIII is already defined as \e[33mvariable\e[0m\
    \ \e[35mremainderXXXIII\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2vpamxi4.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mvar\e[0m \e[36mremainderXXXIV\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mremainderXXXIV is already defined as \e[33mvariable\e[0m \e[35mremainderXXXIV\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2vpamxi4.scala:54:12 ---------------------------\e[0m\e[0m\n\e\
    [31m54 |\e[0m        \e[33mvar\e[0m \e[36mremainderXXXV\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mremainderXXXV\
    \ is already defined as \e[33mvariable\e[0m \e[35mremainderXXXV\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2vpamxi4.scala:55:12 ---------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m        \e[33mvar\e[0m \e[36mremainderXXXVI\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mremainderXXXVI\
    \ is already defined as \e[33mvariable\e[0m \e[35mremainderXXXVI\e[0m\n\e[31m\
    \   |\e[0m"
  stdout: ''
  timestamp: 1660009526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalBits\
    \ = (decimal.toString.toLong).reverse\n        var binary = \"\"\n        var\
    \ power = 1\n        decimalBits foreach { b => binary += if (b == '1'){\n   \
    \         power\n        } else {\n            power = \"1\"\n            power\
    \ = power + \"0\"\n        }\n        }\n        binary += if (decimalBits !=\
    \ 0) \"1\" + \"0\"\n        binary + if (decimalBits == 0) \"0\"\n        binary\
    \ + if (decimalBits == 1) \"1\"\n        binary + if (decimalBits == 2l) \"10\"\
    \n        binary + if (decimalBits == 3l) \"100\"\n        binary + if (decimalBits\
    \ == 4l) \"1000\"\n        binary + if (decimalBits == 5l) \"10000\"\n       \
    \ binary + if (decimalBits == 6l) \"100000\"\n        binary + if (decimalBits\
    \ == 7l) \"1000000\"\n        binary + if (decimalBits == 8l) \"10000000\"\n \
    \       binary + if (decimalBits == 9l) \"10000000\"\n        binary + if (decimalBits\
    \ == 10l) \"100000000\"\n        binary + if (decimalBits == 11l) \"1000000000\"\
    \n        binary + if (decimalBits == 12l) \"10000000000\"\n        binary + if\
    \ (decimalBits == 13l) \"100000000000\"\n        binary + if (decimalBits == 14l)\
    \ \"1000000000000\"\n        binary + if (decimalBits == 15l) \"10000000000000\"\
    \n        binary + if (decimalBits == 16l) \"100000000000000\"\n        binary\
    \ + if (decimalBits == 17l) \"1000000000000000\"\n        binary + if (decimalBits\
    \ == 18l) \"10000000000000000\"\n        binary + if (decimalBits == 19l) \"100000000000000000\"\
    \n        binary + if (decimalBits == 20l) \"1000000000000000000\"\n        binary\
    \ + if (decimalBits == 21l) \"10000000000000000000\"\n        binary + if (decimalBits\
    \ == 22l) \"100000000000000000000\"\n        binary + if (decimalBits == 23l)\
    \ \"1000000000000000000000\"\n        binary + if (decimalBits == 24l) \"10000000000000000000000\"\
    \n        binary + if (decimalBits == 25l) \"100000000000000000000000\"\n    \
    \    binary + if (decimalBits == 26l) \"1000000000000000000000000\"\n        binary\
    \ + if (decimalBits == 27l) \"10000000000000000000000000\"\n        binary + if\
    \ (decimalBits == 28l) \"100000000000000000000000000\"\n        binary + if (decimalBits\
    \ == 29l) \"1000000000000000000000000000\"\n        binary + if (decimalBits ==\
    \ 30l) \"10000000000000000000000000000\"\n        binary + if (decimal\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxx6oxj6f.scala:18:45 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        decimalBits foreach { \e[36mb\e[0m => binary\
    \ += \e[33mif\e[0m (b == \e[31m'1'\e[0m){\n\e[31m\e[31m   |\e[0m             \
    \                                ^^\e[0m\n\e[31m   |\e[0m                    \
    \                    expression expected but \e[31mif\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxx6oxj6f.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        binary += \e[33mif\e[0m (decimalBits != \e[31m0\e\
    [0m) \e[31m\"1\"\e[0m + \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m              \
    \    ^^\e[0m\n\e[31m   |\e[0m                  expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxx6oxj6f.scala:26:17\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        binary + \e[33mif\e\
    [0m (decimalBits == \e[31m0\e[0m) \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m    \
    \             ^^\e[0m\n\e[31m   |\e[0m                 expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxx6oxj6f.scala:27:17\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        binary + \e[33mif\e\
    [0m (decimalBits == \e[31m1\e[0m) \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m    \
    \             ^^\e[0m\n\e[31m   |\e[0m                 expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxx6oxj6f.scala:28:17\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        binary + \e[33mif\e\
    [0m (decimalBits == \e[31m2l\e[0m) \e[31m\"10\"\e[0m\n\e[31m\e[31m   |\e[0m  \
    \               ^^\e[0m\n\e[31m   |\e[0m                 expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/t"
  stdout: ''
  timestamp: 1660009526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ = \"\"\n        var index = 0\n        while (decimal != 0) {\n            val\
    \ remainder = decimal % 2l\n            binaryString = remainder.toString + binaryString\n\
    \            decimal = decimal / 2l\n        }\n        binaryString = \"db\"\
    \ + binaryString + \"db\"\n        return binaryString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpg605qf4h.scala:20:20 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            decimal = decimal / \e[31m2l\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    Reassignment to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = decimal.toBinaryString\n\
    \        val bArray = bits.toCharArray\n        val b = new Array[String](bits.length\
    \ / 2)\n        for (i <- 0 to bArray.length - 1) {\n            b(i) = if(i %\
    \ 2 == 0) \"0\" + bArray(i) else \"1\" + bArray(i)\n        }\n        b.toList.take(b(bArray.length)).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2709d590.scala:21:23\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        b.toList.take(b(bArray.length)).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    String\n\e[31m   |\e[0m  \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalBin\
    \ = decimal.toBinaryString\n        val binaryBin = decimalBin.length\n      \
    \  val db = \"db\"\n        var binaryString : String = \"\"\n        for ((index,\
    \ _) <- decimalBin.indices) {\n            binaryString += decimalBin(index).asInstanceOf[Char]\n\
    \        }\n        binaryString += db\n        for ((index, _) <- decimalBin.indices)\
    \ {\n            binaryString += decimalBin(index).asInstanceOf[Char]\n      \
    \  }\n        binaryString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphbnwowwb.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            binaryString += decimalBin(index).asInstanceOf[\e\
    [35mChar\e[0m]\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphbnwowwb.scala:20:39 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            binaryString += decimalBin(index).asInstanceOf[\e\
    [35mChar\e[0m]\n\e[31m\e[31m   |\e[0m                                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    (index :\
    \ Any)\n\e[31m   |\e[0m                                       Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphbnwowwb.scala:24:25\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            binaryString\
    \ += decimalBin(index).asInstanceOf[\e[35mChar\e[0m]\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a\
    \ member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphbnwowwb.scala:24:39 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            binaryString += decimalBin(index).asInstanceOf[\e[35mChar\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                       ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       Found:    (index : Any)\n\
    \e[31m   |\e[0m                                       Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val str = decimal.toBinaryString\n\
    \        val len = str.size\n        if(len < 10) {\n            // pad with a\
    \ '0'.\n            val spaces = 10 - len\n            for((_,i) <- 0 until spaces)\
    \ str += \"0\"\n        }\n        str ++ \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg9dvcjye.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mfor\e[0m((_,i) <- \e[31m0\e[0m until\
    \ spaces) str += \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m                     \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not\
    \ a member of String - did you mean str.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val str = \"\"\
    \n        for(i <- 0 until decimal.toInt)\n            str=str+\"1\";\n      \
    \  for(i <- 0 until decimal.toInt)\n            str=str+\"0\";\n        str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpb1keidoi.scala:17:15 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            str=str+\e[31m\"1\"\e[0m;\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val str\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpb1keidoi.scala:19:15\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            str=str+\e\
    [31m\"0\"\e[0m;\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val str\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits: Array[Char]\
    \ = (decimal toString 2).toCharArray\n        val result = \"\"\n        for {\n\
    \            i <- 0 until bits.length\n        } yield {\n            if (bits(i)\
    \ == '1')\n                result += \"0\"\n            else\n               \
    \ result += \"1\"\n        }\n\n        result + (if (bits.length != result.length)\
    \ result.length.toString() + Character.toString('0') else \"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpv4zma_r8.scala:15:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m: \e[35mArray\e\
    [0m[\e[35mChar\e[0m] = (decimal toString \e[31m2\e[0m).toCharArray\n\e[31m\e[31m\
    \   |\e[0m                                                  ^\e[0m\n\e[31m   |\e\
    [0m         too many arguments for \e[33mmethod\e[0m \e[35mtoString\e[0m in \e\
    [33mclass\e[0m \e[35mAny\e[0m: (): String\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpv4zma_r8.scala:21:23 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m                result += \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ String - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv4zma_r8.scala:23:23\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                result +=\
    \ \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value += is not a member of String - did you mean result.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n       var binary = \"\
    \"\n       while(decimal != 0) {\n           binary += (decimal % 2).asInstanceOf[String]\n\
    \           decimal /= 2\n       }\n       binary += \"db\"\n       binary\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp85g1iuw4.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m           decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value /= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Write your\
    \ code here\n        val bits = decimal.toInt\n        var binary = \"\"\n   \
    \     var last = 0\n        var pow = 15\n        var i = 1\n        var j = 1\n\
    \        while (i*j < bits) {\n            val temp = bits(i*j)\n            i\
    \ += 1\n            j += 1\n            if (temp < pow) {\n                val\
    \ temp1 = bits(i*j - 1)\n                if (temp1 < pow) {\n                \
    \    binary = binary + \"0\"\n                } else {\n                    binary\
    \ = binary + \"1\"\n                }\n            } else {\n                binary\
    \ = binary + \"1\"\n            }\n            pow /= 2\n        }\n        //\
    \ The extra characters needed to help with the format\n        binary = \"db\"\
    \ + binary + \"db\"\n        return binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp322p0e8z.scala:23:23 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = bits(i*j)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                \e[33mvalue\e[0m \e[35mbits\e[0m does not take parameters\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp322p0e8z.scala:27:28 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mtemp1\e[0m = bits(i*j\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                            ^^^^\e[0m\n\
    \e[31m   |\e[0m                            \e[33mvalue\e[0m \e[35mbits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      decimal match {\n\
    \        case x if x < 0 => \"\"\n        case x => decimalToBinary(math.abs(x)).dropRight(2).mkString\n\
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\tat Problem$.decimalToBinary(tmpu3zg_586.scala:17)\n\
    \tat"
  stdout: ''
  timestamp: 1660009528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryStr\
    \ = \"\"\n        var binary = decimal.toBinaryString()\n        for( i <- 0 until\
    \ binary.length){\n            if( binary(i) ==\"0\"){\n                binaryStr\
    \ += \"0\"\n            }\n            else{\n                binaryStr += \"\
    1\"\n            }\n        }\n        if(decimal<0){\n            binaryStr +=\
    \ \"db\"\n        }\n        return binaryStr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpt3fyw0p_.scala:16:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mbinary\e[0m = decimal.toBinaryString()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (i: Int): Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Only go up\
    \ to 2^53\n        val maxNumber = 2L * 2L * 2L * 2L * 2L * 2L * 2L * 2L * 2L\
    \ * 2L * 2L\n        val binary = if (decimal < 0L) {\n            // negative\n\
    \            decimal.toString(2)\n        } else {\n            // positive\n\
    \            decimal.toString(2) + (\n                if (decimal > maxNumber)\
    \ \"\" else \"0\"\n            )\n        }\n\n        binary += \"db\"\n    \
    \    binary.take(binary.length-1)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprkmjplzz.scala:19:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            decimal.toString(\e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m         too\
    \ many arguments for \e[33mmethod\e[0m \e[35mtoString\e[0m in \e[33mclass\e[0m\
    \ \e[35mAny\e[0m: (): String\n\e[31m\e[31m-- Error: /tmp/tmprkmjplzz.scala:22:29\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     decimal.toString(\e[31m2\e[0m) + (\n\e[31m\e[31m   |\e[0m              \
    \               ^\e[0m\n\e[31m   |\e[0m         too many arguments for \e[33mmethod\e\
    [0m \e[35mtoString\e[0m in \e[33mclass\e[0m \e[35mAny\e[0m: (): String\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009525
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        binary.reverse + \"db\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpem7b0nmp.scala:19)\n\tat Problem.main(tmpem7b0nmp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ : String = \"\"\n        for(digit <- decimal.toString.reverse.filter {\n  \
    \          char => char != '0'}) {\n            binaryString +=(digit == '1' ?\
    \ \"1\" : \"0\")\n        }\n        binaryString +=\"db\"\n        return binaryString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpac84ilud.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            binaryString +=(digit == \e[31m'1'\e[0m ?\
    \ \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpac84ilud.scala:18:41\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            binaryString\
    \ +=(digit == \e[31m'1'\e[0m ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     value ? is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def numBits(n:Long):\
    \ Int = {\n            val res = Long.bitCount(n)\n            if (res == 0) 1\
    \ else res\n        }\n        def toBinary(n:Long): String = {\n            var\
    \ res: String = n.toString\n            for (i <- 1 to numBits(n)) {\n       \
    \         res = (res + \"0\").toString + res\n            }\n            return\
    \ res\n        }\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while (decimal != 0) {\n            binary = toBinary(remainder) + binary\n\
    \            remainder = decimal % 2\n        }\n        binary = \"db\" + binary\
    \ + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb4fdfasb.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = Long.bitCount(n)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      value bitCount is not a member of object Long\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb4fdfasb.scala:32:15 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        binary = \e[31m\"db\"\e[0m + binary + \e[31m\"\
    db\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n       decimal.asInstanceOf[Long].reverse\
    \ match {\n           case 0 => \"0\"\n           case 1 => \"1\"\n          \
    \ case _ =>\n               var result = \"\"\n               while (decimal !=\
    \ 0) {\n                   result += decimal.asInstanceOf[Long] % 2 == 0 ? \"\
    0\" : \"1\"\n                   decimal /= 2\n               }\n             \
    \  result += decimal.asInstanceOf[Long].reverse match {\n                   case\
    \ 0 => \"0\"\n                   case 1 => \"1\"\n                   case _ =>\n\
    \                       while (decimal != 0) {\n                           result\
    \ += decimal.asInstanceOf[Long] % 2 == 0 ? \"0\" : \"1\"\n                   \
    \        decimal /= 2\n                       }\n               }\n          \
    \     \"db\" + result\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpya6jshjd.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m       decimal.asInstanceOf[\e[35mLong\e[0m].reverse\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       value reverse is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpya6jshjd.scala:21:26 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                   result += decimal.asInstanceOf[\e\
    [35mLong\e[0m] % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m\"0\"\e[0m : \e[31m\"1\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of String - did you mean String.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpya6jshjd.scala:21:65 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                   result += decimal.asInstanceOf[\e\
    [35mLong\e[0m] % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m\"0\"\e[0m : \e[31m\"1\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                                                 \
    \              ^^^\e[0m\n\e[31m   |\e[0m                                     \
    \     value ? is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpya6jshjd.scala:22:27\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                   decimal\
    \ /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             value /= is not a member of Long - did you mean decimal.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpya6jshjd.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m               result += decimal.asInstanceOf[\e[35mLong\e\
    [0m].reverse \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpya6jshjd.scala:24:52\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m               result +=\
    \ decimal.asInstanceOf[\e[35mLong\e[0m].reverse \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         value reverse is not a mem"
  stdout: ''
  timestamp: 1660009535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ mutable.StringBuilder()\n        decimal until (decimal shr 1) = 1 append \"\
    0\" append decimalToBinary((decimal div 1))\n        decimal until (decimal shr\
    \ 1) = 0 append \"1\" append decimalToBinary((decimal div 1))\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpsais__ys.scala:16:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        decimal until (decimal shr \e[31m1\e[0m) = \e\
    [31m1\e[0m append \e[31m\"0\"\e[0m append decimalToBinary((decimal div \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m\
    \   |\e[0m                                 end of statement expected but '=' found\n\
    \e[31m\e[31m-- Error: /tmp/tmpsais__ys.scala:17:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        decimal until (decimal shr \e[31m1\e[0m) = \e\
    [31m0\e[0m append \e[31m\"1\"\e[0m append decimalToBinary((decimal div \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m\
    \   |\e[0m                                 end of statement expected but '=' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsais__ys.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsais__ys.scala:16:31 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        decimal until (decimal shr \e[31m1\e[0m) = \e[31m1\e[0m append \e[31m\"\
    0\"\e[0m append decimalToBinary((decimal div \e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \     value shr is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsais__ys.scala:17:31 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        decimal until (decimal shr \e[31m1\e[0m) = \e[31m0\e[0m append \e[31m\"\
    1\"\e[0m append decimalToBinary((decimal div \e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \     value shr is not a member of Long\n5 errors found\n"
  stdout: ''
  timestamp: 1660009536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bInt = scala.math.pow(2,\
    \ decimal.toInt).toInt\n        val binary = scala.collection.mutable.ListBuffer[String]()\n\
    \        // We don't need to worry about negatives because we only need to convert\
    \ negative numbers here.\n        for( i <- 0 to bInt ) {\n            if( i %\
    \ 2 == 1 ) {\n                binary.append(0)\n            }\n            if(\
    \ i % 8 == 0 ) {\n                binary.append(\"db\")\n            }\n     \
    \       binary.append( (decimal % 2) == 0 ? '0' : '1' )\n            decimal /=\
    \ 2\n        }\n        return binary.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc3xijzc5.scala:20:23 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                binary.append(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e\
    [0m with types\n\e[31m   |\e[0m (elems: String*): (binary : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0m (elem: String): (binary : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0mmatch arguments ((\e[31m0\e[0m : Int))\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpc3xijzc5.scala:25:46 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            binary.append( (decimal % \e[31m2\e[0m) == \e[31m0\e\
    [0m ? \e[31m'0'\e[0m : \e[31m'1'\e[0m )\n\e[31m\e[31m   |\e[0m               \
    \                             ^^^\e[0m\n\e[31m   |\e[0m                      \
    \                    value ? is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpc3xijzc5.scala:25:19 -----------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            binary.append( (decimal % \e[31m2\e[0m) == \e[31m0\e\
    [0m ? \e[31m'0'\e[0m : \e[31m'1'\e[0m )\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e[0m with types\n\e[31m   |\e\
    [0m (elems: String*): (binary : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0m (elem: String): (binary : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0mmatch arguments ((\e[31m'1'\e[0m : Char))\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpc3xijzc5.scala:26:20 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString(2)\n        if(binary.length < 64){\n            binary\
    \ += \"0\" * (64 - binary.length)\n        }\n        binary += \"db\"\n     \
    \   binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpebbwh9mj.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m(binary.length < \e[31m64\e[0m){\n\
    \e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \ value length is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpebbwh9mj.scala:17:19 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m            binary += \e[31m\"0\"\e[0m * (\e[31m64\e[0m - binary.length)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Char - did you mean binary.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpebbwh9mj.scala:17:41 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            binary += \e[31m\"0\"\e[0m * (\e[31m64\e[0m -\
    \ binary.length)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value length is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpebbwh9mj.scala:19:15\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        binary += \e[31m\"\
    db\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  value += is not a member of Char - did you mean binary.!=?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpebbwh9mj.scala:20:8 ---------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        binary\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (binary : Char)\n\e[31m   |\e[0m       \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var b = \"\"\n\
    \        var i = 0\n        for( d <- decimal){\n            if( i%2 == 0){\n\
    \                b += d.toString.toChar\n            }\n            i += 1\n \
    \       }\n        if(i == 0){\n            b += \"b\"\n        }\n        if(i\
    \ == 1){\n            b += \"b\"\n        }\n        b += \"db\"\n        return\
    \ b\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9y2wf7iz.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m( d <- decimal){\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  value\
    \ foreach is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def binary(i:\
    \ Long, j: Int) : String = {\n            var binaryString = \"\"\n          \
    \  while(i>0) {\n                binaryString = (i mod 2)+binaryString\n     \
    \           i /= 2\n            }\n            if(i>0 && (j>0) && j<=binaryString.length)\
    \ {\n                binaryString = binaryString.substring(0, j)+binaryString.charAt(binaryString.length-1)+\"\
    db\"\n            }\n            binaryString\n        }\n        if(decimal ==\
    \ 0) return \"0\"\n        var binaryString = \"\"\n        if(decimal>0 && decimal<=1)\
    \ {\n            binaryString = (decimal mod 2)+\"0\"\n        }\n        decimal/=2\n\
    \        while(decimal > 0) {\n            binaryString = binary(decimal,binaryString.length-1)+binaryString\n\
    \            decimal-=2\n        }\n        if(binaryString.length>0) {\n    \
    \        binaryString = binaryString.substring(0,binaryString.length-1)+\"db\"\
    \n        }\n        binaryString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo4er2rxa.scala:18:34 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                binaryString = (i mod \e[31m2\e[0m)+binaryString\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue mod is not a member of Long, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo4er2rxa.scala:19:18\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                i /= \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value /= is not a member of Long - did you mean i.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpo4er2rxa.scala:29:36 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            binaryString = (decimal mod \e[31m2\e[0m)+\e\
    [31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue mod is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo4er2rxa.scala:31:15\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        decimal/=\e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ /= is not a member of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpo4er2rxa.scala:34:19 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            decimal-=\e[31m2\e[0m\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean decimal.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val digits =\
    \ \"0123456789\"\n        val binary = new mutable.LinkedHashMap[Char, Char]()\n\
    \n        for(i <- 0 to decimal.toInt) {\n            val key = digits(i / 2)\n\
    \            val value = digits(i % 2)\n            binary.put(key, value)\n \
    \       }\n\n        // If the length is odd then add an extra character to complete\
    \ the binary string.\n        if(binary.size.toInt == digits.size.toInt) {\n \
    \           binary.put('d, 'b')\n        }\n\n        val str = binary.values.toSeq\n\
    \        str += (\"db\" + str.mkString(\"\"))\n        str\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmparegi5u7.scala:26:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            binary.put(\e[31m'd\e[0m, \e[31m'b'\e[0m)\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0msymbol literal\
    \ 'd is no longer supported,\n\e[31m   |\e[0muse a string literal \"d\" or an\
    \ application Symbol(\"d\") instead,\n\e[31m   |\e[0mor enclose in braces '{d}\
    \ if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can also `import\
    \ language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe idiom, but\
    \ this possibility might no longer be available in the future.\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmparegi5u7.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.LinkedHashMap[\e[35mChar\e[0m, \e[35mChar\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        decimal.toString.takeWhile(!('0','1')).map(c\
    \ => if (c.toString.isDigit) c else ('0') -> '1') ++ (\"db\" + (decimal.toString.takeWhile(!('0','1')).map(c\
    \ => if (c.toString.isDigit) c else ('0') -> '1')))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptlo4nzeu.scala:15:35 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        decimal.toString.takeWhile(!(\e[31m'0'\e[0m,\e\
    [31m'1'\e[0m)).map(\e[36mc\e[0m => \e[33mif\e[0m (c.toString.isDigit) c \e[33melse\e\
    [0m (\e[31m'0'\e[0m) -> \e[31m'1'\e[0m) ++ (\e[31m\"db\"\e[0m + (decimal.toString.takeWhile(!(\e\
    [31m'0'\e[0m,\e[31m'1'\e[0m)).map(\e[36mc\e[0m => \e[33mif\e[0m (c.toString.isDigit)\
    \ c \e[33melse\e[0m (\e[31m'0'\e[0m) -> \e[31m'1'\e[0m)))\n\e[31m\e[31m   |\e\
    [0m                                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                    value unary_! is not a member of (Char, Char)\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmptlo4nzeu.scala:15:71 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        decimal.toString.takeWhile(!(\e[31m'0'\e[0m,\e\
    [31m'1'\e[0m)).map(\e[36mc\e[0m => \e[33mif\e[0m (c.toString.isDigit) c \e[33melse\e\
    [0m (\e[31m'0'\e[0m) -> \e[31m'1'\e[0m) ++ (\e[31m\"db\"\e[0m + (decimal.toString.takeWhile(!(\e\
    [31m'0'\e[0m,\e[31m'1'\e[0m)).map(\e[36mc\e[0m => \e[33mif\e[0m (c.toString.isDigit)\
    \ c \e[33melse\e[0m (\e[31m'0'\e[0m) -> \e[31m'1'\e[0m)))\n\e[31m\e[31m   |\e\
    [0m                                                            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value isDigit is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptlo4nzeu.scala:15:140\
    \ -----------------------\e[0m\e[0m\n\e[31m15 |\e[0m        decimal.toString.takeWhile(!(\e\
    [31m'0'\e[0m,\e[31m'1'\e[0m)).map(\e[36mc\e[0m => \e[33mif\e[0m (c.toString.isDigit)\
    \ c \e[33melse\e[0m (\e[31m'0'\e[0m) -> \e[31m'1'\e[0m) ++ (\e[31m\"db\"\e[0m\
    \ + (decimal.toString.takeWhile(!(\e[31m'0'\e[0m,\e[31m'1'\e[0m)).map(\e[36mc\e\
    [0m => \e[33mif\e[0m (c.toString.isDigit) c \e[33melse\e[0m (\e[31m'0'\e[0m) ->\
    \ \e[31m'1'\e[0m)))\n\e[31m\e[31m   |\e[0m                                   \
    \                                                                            \
    \                             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \            value unary_! is not a member of (Char, Char)\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptlo4nzeu.scala:15:176 ----------------"
  stdout: ''
  timestamp: 1660009537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ decimal.toBinaryString\n        val firstChar = \"db\" + result.charAt(0)\n\
    \        val lastChar = result.charAt(result.length - 1)\n        if (firstChar\
    \ == \"0\" && lastChar == \"1\") \"\"\n        else firstChar + lastChar\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2__746zo.scala:18:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (firstChar == \e[31m\"0\"\e[0m\
    \ && lastChar == \e[31m\"1\"\e[0m) \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m    \
    \                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660009536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val digit = decimal.toInt\n\
    \        val power = digit.pow(2)\n        val bitString = (power / 2).map(_ =>\
    \ if (power % 2 == 0) '0' else '1').mkString\n        val db = (bitString + bitString.reverse).take(bitString.length\
    \ / 2).mkString\n        (db + \"db\" + db).take((bitString.length + 3) / 2).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptis8zrx6.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpower\e[0m = digit.pow(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue pow is not a member of Int, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.int2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.int2bigInt\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toString.reverse.map {\n            char => if (char >= '0' && char\
    \ <= '1') char + '0' else '1'\n        }\n        binary.mkString('0', binary.length,\
    \ 'db')\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpw5pgh9jj.scala:18:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        binary.mkString(\e[31m'0'\e[0m, binary.length,\
    \ \e[31m'db\e[0m')\n\e[31m\e[31m   |\e[0m                                    \
    \        ^\e[0m\n\e[31m   |\e[0msymbol literal 'db is no longer supported,\n\e\
    [31m   |\e[0muse a string literal \"db\" or an application Symbol(\"db\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{db} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- Error: /tmp/tmpw5pgh9jj.scala:18:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \ binary.mkString(\e[31m'0'\e[0m, binary.length, \e[31m'db\e[0m')\n\e[31m\e[31m\
    \   |\e[0m                                               ^\e[0m\n\e[31m   |\e\
    [0m                                              unclosed character literal\n\e\
    [31m\e[31m-- Error: /tmp/tmpw5pgh9jj.scala:20:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpw5pgh9jj.scala:18:24 --------------------\e[0m\e[0m\n\e[31m18 |\e[0m\
    \        binary.mkString(\e[31m'0'\e[0m, binary.length, \e[31m'db\e[0m')\n\e[31m\e\
    [31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m               \
    \         Found:    (\e[31m'0'\e[0m : Char)\n\e[31m   |\e[0m                 \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpw5pgh9jj.scala:18:36 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        binary.mkString(\e[31m'0'\e[0m, binary.length, \e[31m'db\e[0m')\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                             Found:    "
  stdout: ''
  timestamp: 1660009538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ \"0\"\n        val decimalAsString = (decimal.toString).drop(1).dropRight(1)\n\
    \        val stringLength = decimalAsString.length\n\n        var index = 0\n\
    \        var power = 0\n        var powerString = \"\"\n        while (index <\
    \ stringLength) {\n            if (decimalAsString(index) == \"1\") {\n      \
    \          binary += powerString\n            }\n            powerString = (binary\
    \ + powerString).reverse\n            power += 1\n            if (power > 9) {\n\
    \                power = 0\n                index += 1\n            }\n      \
    \  }\n        if (index == 0) {\n            binary += \"0\"\n        }\n    \
    \    if (index == stringLength) {\n            binary += \"1\"\n        }\n  \
    \      binary += \"db\"\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8hkgp9mu.scala:23:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (decimalAsString(index) ==\
    \ \e[31m\"1\"\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8hkgp9mu.scala:24:23\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                binary +=\
    \ powerString\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value += is not a member of String - did you mean binary.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp8hkgp9mu.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            binary += \e[31m\"0\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean binary.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp8hkgp9mu.scala:37:19 ------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            binary += \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of String\
    \ - did you mean binary.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8hkgp9mu.scala:39:15\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        binary += \e[31m\"\
    db\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  value += is not a member of String - did you mean binary.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var finalString\
    \ : String = \"\"\n        decimal match {\n            case x: Long => {\n  \
    \              for {\n                    i<- 0 to 15\n                    j <-\
    \ 0 to 15\n                    if ((decimal & 1l) ==  0) || ((decimal & 1l) ==\
    \ 1) {\n                        finalString += \"0\"\n                    } else\
    \ {\n                        finalString += \"1\"\n                    }\n   \
    \                 decimal = decimal >>> 1\n                } yield finalString\n\
    \            }\n            case _ => finalString\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5r9njgip.scala:23:22 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    } \e[33melse\e[0m {\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0m                   \
    \   '}' expected, but 'else' found\n\e[31m\e[31m-- Error: /tmp/tmp5r9njgip.scala:27:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \         } \e[33myield\e[0m finalString\n\e[31m\e[31m   |\e[0m              \
    \    ^^^^^\e[0m\n\e[31m   |\e[0m                  end of statement expected but\
    \ 'yield' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5r9njgip.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e\
    [0m _ => finalString\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e\
    [0m            '}' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp5r9njgip.scala:39:0 ----------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected, but '}' found\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmp5r9njgip.scala:21:50 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    \e[33mif\e[0m ((decimal & \e[31m1l\e\
    [0m) ==  \e[31m0\e[0m) || ((decimal & \e[31m1l\e[0m) == \e[31m1\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35m==\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m does not take more parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp5r9njgip.scala:26:28 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    decimal = decimal >>> \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Reassignment to val decimal\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5r9njgip.scala:33:11 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    assert(decimalToBinary((\e[31m0l\e[0m)).equals((\e\
    ["
  stdout: ''
  timestamp: 1660009535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // (1) Convert\
    \ to binary in place\n        decimal to { x =>\n            // The last digit\
    \ in binary is (decimal modulo 2).\n            // The next binary digit is (decimal\
    \ modulo 2).\n            // So just divide decimal by 2 to get the last digit,\
    \ then divide by 2 to get the next\n            // digit.\n            x % 2 match\
    \ {\n                case true => x to { y => decimal / 2 }\n                case\
    \ false => x to { y => decimal / 2 + 1 }\n            }\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpja_ac6fi.scala:16:21 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        decimal to { \e[36mx\e[0m =>\n\e[31m\e[31m  \
    \ |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                     I could\
    \ not infer the type of the parameter x.\n1 error found\n"
  stdout: ''
  timestamp: 1660009535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinary(decimal.bitLength)\n        val lengthBinary = binary.length\n\
    \        val addBinary = binary.reverse\n        val final = addBinary.reverse\n\
    \        val lengthFinal = (final.length)\n        val db = \"db\"\n        val\
    \ addDb = \"db\"\n        val final2 = \"db\"\n        val lengthFinal2 = (lengthFinal\
    \ * 2)\n        val addFinal2 = final.concat(\"db\")\n\n        val final3 = addFinal2.reverse\n\
    \        val lengthFinal3 = (lengthFinal2 * 2)\n        val addFinal3 = final3.concat(\"\
    db\")\n        val final4 = addFinal3.reverse\n        val lengthFinal4 = (lengthFinal3\
    \ * 2)\n        val addFinal4 = final4.concat(\"db\")\n        val final5 = addFinal4.reverse\n\
    \        val lengthFinal5 = (lengthFinal4 * 2)\n        val addFinal5 = final5.concat(\"\
    db\")\n        val final6 = addFinal5.reverse\n        val lengthFinal6 = (lengthFinal5\
    \ * 2)\n        val addFinal6 = final6.concat(\"db\")\n        val final7 = addFinal6.reverse\n\
    \        val lengthFinal7 = (lengthFinal6 * 2)\n        val addFinal7 = final7.concat(\"\
    db\")\n        val final8 = addFinal7.reverse\n        val lengthFinal8 = (lengthFinal7\
    \ * 2)\n        val addFinal8 = final8.concat(\"db\")\n        val final9 = addFinal8.reverse\n\
    \        val lengthFinal9 = (lengthFinal8 * 2)\n        val addFinal9 = final9.concat(\"\
    db\")\n        val final10 = addFinal9.reverse\n        val lengthFinal10 = (lengthFinal9\
    \ * 2)\n        val addFinal10 = final10.concat(\"db\")\n\n        val final11\
    \ = addFinal10.reverse\n        val lengthFinal11 = (lengthFinal10 * 2)\n    \
    \    val addFinal11 = final11.concat(\"db\")\n        val final12 = addFinal11.reverse\n\
    \        val lengthFinal12 = (lengthFinal11 * 2)\n        val addFinal12 = final12.concat(\"\
    db\")\n        val final13 = addFinal12.reverse\n        val lengthFinal13 = (lengthFinal12\
    \ * 2)\n        val addFinal13 = final13.concat(\"db\")\n        val final14 =\
    \ addFinal13.reverse\n        val lengthFinal14 = (lengthFinal13 * 2)\n      \
    \  val addFinal14 = final14.concat(\"db\")\n        val final15 = addFinal14.reverse\n\
    \        val lengthFinal15 = (lengthFinal14 * 2)\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvdvo2dpz.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[33mfinal\e[0m = addBinary.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m            pattern\
    \ expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvdvo2dpz.scala:19:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlengthFinal\e[0m = (\e[33mfinal\e[0m.length)\n\e[31m\e[31m   |\e[0m  \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \   expression expected but \e[31mfinal\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpvdvo2dpz.scala:24:24 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36maddFinal2\e[0m = \e[33mfinal\e\
    [0m.concat(\e[31m\"db\"\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^\e\
    [0m\n\e[31m   |\e[0m                        expression expected but \e[31mfinal\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvdvo2dpz.scala:15:29\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mbinary\e[0m = decimal.toBinary(decimal.bitLength)\n\e[31m\e[31m   |\e[0m \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   value toBinary is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvdvo2dpz.scala:15:46 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mbinary\e[0m = decimal.toBinary(decimal.bitLength)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue bitLength is not a member of Long, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following\
    \ import might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvdvo2dpz"
  stdout: ''
  timestamp: 1660009540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def bitsToBits(bits:\
    \ Array[Long]): Array[String] = bits map { bits => (if (bits == 1) \"0\" else\
    \ \"1\") }\n        def bitsToBits(bits: Array[String]): Array[Long] = bits map\
    \ { bits => (if (bits == \"0\") 0 else 1) }\n        def bitsToBits(bits: Array[Long]):\
    \ Array[String] = {\n            def bitsLength(l: Int): Int = {\n           \
    \     if (l < 2) 1 else l - 1\n            }\n            def bitsLength(l: Long):\
    \ Int = {\n                if (l < 2) 1 else l - 1\n            }\n          \
    \  val bitLength : Int = bitsLength(bits.length)\n            val bitsAsString\
    \ = bits.map { bit => bit.toString().padLeft(bitLength, '0') }.mkString\n    \
    \        val bitsAsLong = bitsAsString.split('').map(_.toLong).reverse\n     \
    \       bitsAsLong.map { bits => bitsToBits(bits) }\n        }\n\n        val\
    \ bits = decimal.toBits.reverse\n        val bitsLength = bits.length\n      \
    \  val bitsAsString = bits.map { bit => bit.toString().padLeft(bitsLength, '0')\
    \ }.mkString\n        val bitsAsLong = bitsAsString.split('').map(_.toLong).reverse\n\
    \        val bitsAsString = bitsAsLong.map { bits => bitsToBits(bits) }\n    \
    \    bitsAsString.mkString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvsru6fsj.scala:26:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mbitsAsLong\e[0m = bitsAsString.split('').map(_.toLong).reverse\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                                empty character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpvsru6fsj.scala:33:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbitsAsLong\e[0m = bitsAsString.split('').map(_.toLong).reverse\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                            empty character literal\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsru6fsj.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mdef\e[0m \e[36mbitsToBits\e[0m(\e[36mbits\e\
    [0m: \e[35mArray\e[0m[\e[35mString\e[0m]): \e[35mArray\e[0m[\e[35mLong\e[0m] =\
    \ bits map { \e[36mbits\e[0m => (\e[33mif\e[0m (bits == \e[31m\"0\"\e[0m) \e[31m0\e\
    [0m \e[33melse\e[0m \e[31m1\e[0m) }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbitsToBits is already defined as \e[33mmethod\e[0m \e[35mbitsToBits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvsru6fsj.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbitsAsString\e[0m = bitsAsLong.map {\
    \ \e[36mbits\e[0m => bitsToBits(bits) }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbitsAsString is already defined as \e[33mvalue\e[0m \e[35mbitsAsString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvsru6fsj.scala:21:16 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m            \e[33mdef\e[0m \e[36mbitsLength\e[0m(\e[36ml\e["
  stdout: ''
  timestamp: 1660009541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def binaryStringToDecimal(s\
    \ : String) : Long = {\n            val len = s.length\n            var binNum\
    \ : Long = 0\n            var temp : Long = 0\n            for( i <- 0 until len\
    \ ) {\n                if( s.charAt(i) == '1' ) {\n                    temp =\
    \ temp + 1\n                } else {\n                    binNum = binNum * 2\
    \ + temp\n                    temp = 0\n                }\n            }\n   \
    \         binNum = binNum * 2\n            if( len != 0 ) {\n                binNum\
    \ = binNum * 2 + temp\n                temp = 0\n            }\n            binNum\n\
    \        }\n        val dec = decimal\n        val n = dec / 2\n        var binary\
    \ = new StringBuilder()\n        for( i <- 0 until dec ) {\n            if( i\
    \ % 2 == 0 ) {\n                binary.append( '1' )\n            } else {\n \
    \               binary.append( '0' )\n            }\n        }\n        val newDecimal\
    \ = binaryStringToDecimal(binary.toString)\n        if( dec % 2 == 0 ) {\n   \
    \         val newDecimal2 = binaryStringToDecimal(\"1\")\n            newDecimal\
    \ = newDecimal2 * 2 + newDecimal\n            newDecimal.toString\n        } else\
    \ {\n            val newDecimal3 = binaryStringToDecimal(\"0\")\n            newDecimal\
    \ = newDecimal3 * 2 + newDecimal\n            newDecimal.toString\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mcj5v1c.scala:37:26\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mfor\e[0m( i <-\
    \ \e[31m0\e[0m until dec ) {\n\e[31m\e[31m   |\e[0m                          ^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (dec : Long)\n\e[31m \
    \  |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp1mcj5v1c.scala:47:23 -----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            newDecimal = newDecimal2 * \e[31m2\e[0m +\
    \ newDecimal\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val newDecimal\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp1mcj5v1c.scala:51:23 -----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            newDecimal = newDecimal3 * \e[31m2\e[0m +\
    \ newDecimal\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val newDecimal\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryStr\
    \ = \"0\"\n        for(i <- 0 to decimal.toInt - 1){\n            val ones = decimal.toInt\
    \ % 2\n            val rem = decimal.toInt / 2\n            binaryStr = ones +\
    \ binaryStr\n            decimal = rem.toInt\n        }\n        binaryStr +=\
    \ \"db\"\n        binaryStr\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqzfvjlz_.scala:20:20 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            decimal = rem.toInt\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009536
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // convert decimal\
    \ to binary by converting decimal number to string\n        // then convert it\
    \ to string with each character being represented by '0' or '1'\n        val decimalToBinaryString\
    \ = decimal.toString\n        // keep track of how long the binary string should\
    \ be\n        var binaryStringLength = 0\n        // keep a flag to indicate if\
    \ the current character should be '1' or '0'\n        var currentChar = 0\n  \
    \      // iterate through each character in the string\n        for (i <- 0 until\
    \ decimalToBinaryString.length) {\n            // if the current character should\
    \ be '1', add the current character to the binary string\n            if (currentChar\
    \ == 1) {\n                binaryStringLength += 1\n                // if the\
    \ current character is too large for the binary string, add the character '0'\n\
    \                if (binaryStringLength > 6) {\n                    binaryStringLength\
    \ += 1\n                }\n            }\n            // otherwise add the character\
    \ '1'\n            else {\n                binaryStringLength += 1\n         \
    \   }\n            // update the current character\n            currentChar =\
    \ if (decimalToBinaryString(i) == '1') 1 else 0\n        }\n        // append\
    \ a 'db' character before the binary string\n        binaryStringLength += 1\n\
    \        // append a 'db' character at the end of the binary string\n        binaryStringLength\
    \ += 1\n        // return binary string with extra characters to help with format\n\
    \        binaryStringLength.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvp5_8dum.scala:47)\n\tat Problem.main(tmpvp5_8dum.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binaryArray\
    \ = Array.ofDim[Boolean](64)\n        val remainder = decimal.toInt % 2\n    \
    \    while(decimal > 0) {\n            val binary = decimal.toInt / 2\n      \
    \      binaryArray.update(binary-1, remainder == 1)\n            remainder = decimal\
    \ % 2\n            decimal /= 2\n        }\n        val result = binaryArray.toArray.map(x\
    \ => if (x) \"1\"  else \"0\").mkString\n        result + (if (result == \"\"\
    ) \"\" else \"db\")\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1kl1vzgb.scala:20:24\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            remainder = decimal\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Found:    Long\n\e[31m   |\e[0m       \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp1kl1vzgb.scala:21:20 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value /= is not a member of Long - did you mean\
    \ decimal.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ new mutable.MutableStringBuilder\n        while (decimal > 0 && !(decimal %\
    \ 2)) {\n            result.append(decimalToBinary(decimal / 2l))\n        }\n\
    \        result.append(decimalToBinary(decimal % 2l))\n        result + result.charAt(0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0i3y7bsr.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.MutableStringBuilder\n\e[31m\e[31m   |\e[0m                      \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0i3y7bsr.scala:16:30\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mwhile\e[0m\
    \ (decimal > \e[31m0\e[0m && !(decimal % \e[31m2\e[0m)) {\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value\
    \ unary_! is not a member of Long - did you mean Long.unary_+?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        require(!decimal.isZero)\n\
    \        val n = decimal.asInstanceOf[Long]\n        if (n >= 10) {\n        \
    \    // n is greater than 10.\n            decimalToBinary(decimal.toInt % 10)\n\
    \        } else {\n            // n is less than or equal to 10\n            val\
    \ remainder = decimal.toInt % 2\n            val bits = (remainder + 1).asInstanceOf[Int]\n\
    \            var binaryString = \"\"\n            var i = 0\n            while\
    \ (i < bits) {\n                binaryString += i.toString\n                i\
    \ += 1\n            }\n            binaryString += \"0\" * (bits - i)\n      \
    \      binaryString\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoc8d8ru_.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        require(!decimal.isZero)\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ isZero is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        if(binary.length > decimalDecimalSize){\n  \
    \          binary = binary.substring(binary.length - decimalDecimalSize)\n   \
    \     }\n        \"db\" + binary + binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg2ikvqg1.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m(binary.length > decimalDecimalSize){\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Not found: decimalDecimalSize\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg2ikvqg1.scala:17:54 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            binary = binary.substring(binary.length -\
    \ decimalDecimalSize)\n\e[31m\e[31m   |\e[0m                                 \
    \                     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                            Not found: decimalDecimalSize\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // convert decimal\
    \ number to binary string\n        def decToBinary(num: Long): String = {\n  \
    \          // if number is odd, just add \"0\"\n            if (num % 2 != 0)\
    \ \"0\" + decToBinary(num / 2)\n            // if number is even, divide by 2\
    \ and continue with the new number\n            else decToBinary(num / 2 + \"\
    0\") +\n                    // if number is odd, add \"1\", otherwise add \"0\"\
    \n                    if (num % 2 == 1) \"1\" + decToBinary(num / 2)\n       \
    \             else \"0\" + decToBinary(num / 2)\n        }\n        // convert\
    \ decimal number to string\n        decToBinary(decimal)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0e23mm6o.scala:20:45 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33melse\e[0m decToBinary(num / \e[31m2\e\
    [0m + \e[31m\"0\"\e[0m) +\n\e[31m\e[31m   |\e[0m                             \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \   expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp0e23mm6o.scala:20:29 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33melse\e[0m decToBinary(num / \e[31m2\e\
    [0m + \e[31m\"0\"\e[0m) +\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    String\n\e[31m   |\e\
    [0m                             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def bits(n: Long,\
    \ s: String): String = {\n            val res = if (n <= 0) \"0\" + s\n      \
    \      else bits(n / 2, s + (\"0\" + (n % 2)));\n            res\n        }\n\
    \        val bin = mutable.BitSet(decimal.toString.length)\n        for (i <-\
    \ decimal.toString.reverse.iterator) bin(i) = (i != '0');\n        if (bin(0)\
    \ == true) bin(0) += \"1\"\n        if (bin(decimal.toString.length - 1) == true)\
    \ bin(decimal.toString.length - 1) += \"1\"\n        bin.toString.reverse\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1sh4ikg6.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbin\e[0m = mutable.BitSet(decimal.toString.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        if(binary.charAt(0) == '1') binary.substring(1).toString\
    \ + \"db\"\n        else binary + \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2t25bzmv.scala:20)\n\tat Problem.main(tmp2t25bzmv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ new scala.collection.mutable.StringBuilder()\n        for ((index, value) <-\
    \ 0 until decimal.toInt.toString.length) \n            if (decimal.toString.charAt(index)\
    \ == '1') \n                result.append(\"1\")\n            else\n         \
    \       result.append(\"0\")\n        return result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmdrgggrm.scala:17:40\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (decimal.toString.charAt(index)\
    \ == \e[31m'1'\e[0m) \n\e[31m\e[31m   |\e[0m                                 \
    \       ^^^^^\e[0m\n\e[31m   |\e[0m                                        Found:\
    \    (index : Any)\n\e[31m   |\e[0m                                        Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ decimal.toBinaryString.toLowerCase\n        binary += \"db\"\n        binary\
    \ += (decimal.toInt).toBinaryString\n        binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2pgm5xig.scala:21)\n\tat Problem.main(tmp2pgm5xig.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009548
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        var i = 0\n        while ( i < decimal.toString.length ) {\n \
    \           binary = binary + decimal.toString.charAt(i).toChar.toString\n   \
    \         if ( i < decimal.toString.length - 1 ) {\n                binary = binary\
    \ + \"0\"\n                i += 1\n            }\n            else {\n       \
    \         binary = binary + \"1\"\n                i += 1\n            }\n   \
    \     }\n        binary = binary + \"db\"\n        binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpknz826a5.scala:32)\n\tat Problem.main(tmpknz826a5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      var binary = 0\n\
    \      var decimalToBinaryCharArray = \"\"\n      var i = 0\n      decimal match\
    \ {\n        case d if d < 0b1000000000000000 => decimalToBinaryCharArray = \"\
    0\"\n        case d if d < 0b10000000000001 => decimalToBinaryCharArray = \"1\"\
    \n        case d if d < 0b10000000000010 => decimalToBinaryCharArray = \"a\"\n\
    \        case d if d < 0b10000000000100 => decimalToBinaryCharArray = \"b\"\n\
    \        case d if d < 0b10000000000111 => decimalToBinaryCharArray = \"c\"\n\
    \        case d if d < 0b100000000010000 => decimalToBinaryCharArray = \"d\"\n\
    \        case d if d < 0b100000000010010 => decimalToBinaryCharArray = \"e\"\n\
    \        case d if d < 0b100000000010100 => decimalToBinaryCharArray = \"f\"\n\
    \        case d if d < 0b100000000011000 => decimalToBinaryCharArray = \"g\"\n\
    \        case d if d < 0b100000000100000 => decimalToBinaryCharArray = \"h\"\n\
    \        case d if d < 0b100000000100100 => decimalToBinaryCharArray = \"i\"\n\
    \        case d if d < 0b100000000101000 => decimalToBinaryCharArray = \"j\"\n\
    \        case d if d < 0b100000000110000 => decimalToBinaryCharArray = \"k\"\n\
    \        case d if d < 0b10000000100000 => decimalToBinaryCharArray = \"l\"\n\
    \        case d if d < 0b10000000100100 => decimalToBinaryCharArray = \"m\"\n\
    \        case d if d < 0b10000000101000 => decimalToBinaryCharArray = \"n\"\n\
    \        case d if d < 0b10000000110000 => decimalToBinaryCharArray = \"o\"\n\
    \        case d if d < 0b100000010000000 => decimalToBinaryCharArray = \"p\"\n\
    \        case d if d < 0b100000010000001 => decimalToBinaryCharArray = \"q\"\n\
    \        case d if d < 0b1000000100000010 => decimalToBinaryCharArray = \"r\"\n\
    \        case d if d < 0b1000000100000011 => decimalToBinaryCharArray = \"s\"\n\
    \        case d if d < 0b1000000100000100 => decimalToBinaryCharArray = \"t\"\n\
    \        case d if d < 0b1000000100000101 => decimalToBinaryCharArray = \"u\"\n\
    \        case d if d < 0b1000000100000111 => decimalToBinaryCharArray = \"v\"\n\
    \        case d if d < 0b10000001000000100 => decimalToBinaryCharArray = \"w\"\
    \n        case d if d < 0b10000001000000101 => \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjjwknnoc.scala:19:41 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mcase\e[0m d \e[33mif\e[0m d < \e[31m0\e\
    [0mb1000000000000000 => decimalToBinaryCharArray = \e[31m\"0\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                         ^^\e[0m\n\e[31m   |\e[0m\
    \                                        expression expected but \e[31m=>\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjjwknnoc.scala:54:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpjjwknnoc.scala:19:23 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mcase\e[0m d \e[33mif\e[0m d < \e[31m0\e[0mb1000000000000000\
    \ => decimalToBinaryCharArray = \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m      \
    \            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  value\
    \ b1000000000000000 is not a member of Boolean\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjjwknnoc.scala:53:1 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpjjwknnoc.scala:46:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m46 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009548
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryStr\
    \ = \"\"\n        var count = 0\n        var digit = decimal\n        while (count\
    \ < 32){\n            binaryStr += (digit % 2).toChar\n            digit /= 2\n\
    \            count += 1\n        }\n        binaryStr += (digit % 2).toChar\n\
    \        while(count != 0){\n            binaryStr += (digit % 2).toChar\n   \
    \         digit /= 2\n            count += 1\n        }\n        binaryStr +=\
    \ \"db\"\n        return binaryStr\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var num : Int\
    \ = 0\n        var str = \"\"\n        var pow2 : int = 0\n        while(decimal\
    \ > 0){\n            num += 1\n            pow2 = math.pow(2,num)\n          \
    \  str = (math.abs(decimal%pow2)) + \"db\" + str\n            decimal = math.floor(decimal/pow2)\n\
    \        }\n        str = str + \"db\"\n        str = str.substring(1)\n     \
    \   str\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw0te8l7w.scala:17:19 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mpow2\e[0m : \e[35mint\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: type int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpw0te8l7w.scala:22:32 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            decimal = math.floor(decimal/pow2)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Found:    Double\n\e[31m   |\e[0m                   \
    \   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      val binaryDigits\
    \ = mutable.ArrayBuffer.empty[String]\n      binaryDigits = decimalToBinary(decimal.toInt,\
    \ binaryDigits)\n      binaryDigits.toString.replace(\"db\", \"b\") + (\"db\"\
    \ * decimal.toString)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps_l7l2mi.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      \e[33mval\e[0m \e[36mbinaryDigits\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps_l7l2mi.scala:16:37 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      binaryDigits = decimalToBinary(decimal.toInt, binaryDigits)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    (Int, Nothing)\n\
    \e[31m   |\e[0m                                     Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n       val decimalAsString\
    \ = decimal.toString\n       val decimalAsStringLength = decimalAsString.length\n\
    \       var temp : String = \"\"\n       var temp2 : String = \"\"\n       var\
    \ binaryNumberLength = 0\n       while (decimalAsString.length >= decimalAsStringLength)\
    \ {\n          temp = decimalAsString.substring(0, decimalAsStringLength)\n  \
    \        decimalAsString = decimalAsString.substring(decimalAsStringLength, 1)\n\
    \          binaryNumberLength += 1\n          if (binaryNumberLength <= decimalAsStringLength)\
    \ {\n             temp2 = temp + \"0\"\n          } else {\n             temp2\
    \ = temp + \"1\"\n          }\n       }\n       return temp2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5810fz5j.scala:22:26 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m          decimalAsString = decimalAsString.substring(decimalAsStringLength,\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m          Reassignment to val decimalAsString\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n       val power = math.pow(2,decimal)\n\
    \       val result = power.toInt\n       val powerString = power.toString.reverse\n\
    \       val extraChars = \"db\".toCharArray.zip(powerString.toCharArray).map(c\
    \ => c._1 + c._2).mkString\n       val binary = result.map(c => c+extraChars)\n\
    \       binary.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsf3dcm4a.scala:19:27 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m       \e[33mval\e[0m \e[36mbinary\e[0m = result.map(\e\
    [36mc\e[0m => c+extraChars)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value map is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val x = decimal\n\
    \        var bin = \"\"\n        var count = 0\n        while (x >= 1) {\n   \
    \         count += 1\n            x /= 2\n        }\n        bin = bin.reverse\
    \ ++ \"0\".repeat(count)\n        while (x < 1) {\n            count += 1\n  \
    \          x *= 2\n        }\n        bin = bin.reverse ++ \"1\".repeat(count)\n\
    \        bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7jk8lifp.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            x /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member of\
    \ Long - did you mean x.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7jk8lifp.scala:25:14\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            x *= \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ *= is not a member of Long - did you mean x.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009548
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toString.reverse.map(x => ((x & 1l) << 7) | ((x & 2l) << 6) | ((x &\
    \ 4l) << 5) | ((x & 8l) << 4) | ((x & 16l) << 3) | ((x & 32l) << 2) | ((x & 64l)\
    \ << 1) | ((x & 128l)))\n        binary.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphykykg19.scala:19)\n\tat Problem.main(tmphykykg19.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal <\
    \ 0)\n        {\n            decimalToBinary(-decimal)\n        }\n        else\n\
    \        {\n            var binary = \"\"\n            var remainder = 0\n   \
    \         var i = 0\n            while (decimal != 0)\n            {\n       \
    \         remainder = (decimal % 2)\n                decimal /= 2\n          \
    \      if (remainder > 0)\n                {\n                    binary += \"\
    1\"\n                }\n                else\n                {\n            \
    \        binary += \"0\"\n                }\n                i += 1\n        \
    \    }\n            binary = binary + \"db\" + binary.take(i) + \"db\"\n     \
    \       binary\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp82jd26c9.scala:26:29\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                remainder = (decimal\
    \ % \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    Long\n\e[31m   |\e\
    [0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp82jd26c9.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                decimal /= \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value /=\
    \ is not a member of Long - did you mean decimal.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal <\
    \ 0) \"0\" * (-decimal.toInt) + \"db\" else \"\" + (decimal % 2).toString + (decimalToBinary(decimal\
    \ / 2).toString.reverse)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat java.base/java.lang.StringBuilder.<init>(StringBuilder.java:119)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\
    \tat Problem$.decimalToBinary(tmpamqbbciw.scala:15)\n\tat Problem$.decimalToBinary(tmpamqb"
  stdout: ''
  timestamp: 1660009551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result =\
    \ \"\"\n        var remainder = decimal\n        var temp = \"\"\n        var\
    \ place = 0\n        // While we have remainders\n        while(decimal != 0){\n\
    \            // Get the remainder after division by 2\n            var remainderPart\
    \ = decimal % 2\n            decimal /= 2\n            \n            // Convert\
    \ the remainder to binary string\n            var binaryPart = 0\n           \
    \ while(remainderPart != 0){\n                binaryPart *= 10\n             \
    \   binaryPart += remainderPart % 2\n                remainderPart /= 2\n    \
    \        }\n            // Convert it to string, add the part we took, and set\
    \ the place\n            // to one more than the remainder\n            temp +=\
    \ binaryPart.toString\n            result += temp\n            \n            //\
    \ If we've finished the current binary number, add extra char\n            if(decimal\
    \ != 0){\n                result += \".\"\n                place += 1\n      \
    \      }\n        }\n        // Add the 'db' characters to the front and the end\
    \ of the string\n        return \"db\" + result + temp + \"db\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpagu0eszj.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpagu0eszj.scala:29:27\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                binaryPart\
    \ += remainderPart % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value += is not a member of Int - did you\
    \ mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val buffer =\
    \ new mutable.BitSet(decimal.toInt)\n        buffer.set(decimal.toInt/2).map{\
    \ buffer(\"_\") }\n        buffer.map{ buffer(\"_\") }.mkString(\"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpitqjw19b.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbuffer\e[0m = \e[33mnew\e\
    [0m mutable.BitSet(decimal.toInt)\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary: String\
    \ = \"\"\n        var i = 0\n        while (decimal > 0) {\n            binary\
    \ += (decimal & 1).toChar\n            decimal >>= 1\n            i += 1\n   \
    \     }\n        binary += \"db\"\n        binary ++= i.toString\n        binary\
    \ += \"db\"\n        return binary\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf74eeg__.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            decimal >>= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value >>= is\
    \ not a member of Long - did you mean decimal.>=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ new mutable.LinkedList[String]()\n        while(decimal != 0){\n           \
    \ binary.push(decimal.toBinaryString)\n            decimal /= 2\n        }\n \
    \       binary.reverse.take(2).toString + \"db\" + binary.reverse.take(2).toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq44sl2l2.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq44sl2l2.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            decimal /= \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value /= is not a member of Long - did you mean decimal.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalInt\
    \ = decimal\n        var binaryString = \"\"\n        var remainder = 0\n    \
    \    while (decimalInt > 0) {\n            remainder = decimalInt % 2\n      \
    \      decimalInt /= 2\n            binaryString = remainder.toString + binaryString\n\
    \        }\n        binaryString = binaryString.reverse\n        binaryString\
    \ = binaryString.drop(1) + binaryString.take(1)\n        binaryString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl1wcrhuu.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            remainder = decimalInt\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    Long\n\e[31m   |\e[0m  \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpl1wcrhuu.scala:20:23 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            decimalInt /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value /= is not a\
    \ member of Long - did you mean decimalInt.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result :\
    \ String = \"\";\n        val binary = new mutable.BitSet(decimal.toString.length.toInt);\n\
    \        binary.set(decimal.toString.length.toInt-1);\n        while(binary.size\
    \ > 0) {\n            result += (binary.get(binary.size-1) == 0) ? '0' : '1';\n\
    \            binary.set(binary.size-1);\n        }\n        result = \"db\" +\
    \ result + \"db\";\n        result;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2z7cblft.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.BitSet(decimal.toString.length.toInt);\n\e[31m\e[31m   |\e[0m    \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2z7cblft.scala:19:12\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            result += (binary.get(binary.size-\e\
    [31m1\e[0m) == \e[31m0\e[0m) ? \e[31m'0'\e[0m : \e[31m'1'\e[0m;\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            Found:    Unit\n\e[31m   |\e[0m            Required:\
    \ (\e[31m'1'\e[0m : Char)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ scala.collection.mutable.BitSet()\n        binary.set(decimal)\n        val\
    \ bin = binary.toArray\n        val res = \"db\" + new String(bin) + \"db\"\n\
    \        val res = res.substring(0, res.length - 2)\n        return res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxajqc7qp.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = res.substring(\e\
    [31m0\e[0m, res.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mres is already defined as \e[33mvalue\e[0m \e[35mres\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxajqc7qp.scala:16:15 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        binary.set(decimal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue set is not a member of scala.collection.mutable.BitSet -\
    \ did you mean binary.seq?\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxajqc7qp.scala:18:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e\
    [0m \e[36mres\e[0m = \e[31m\"db\"\e[0m + \e[33mnew\e[0m \e[35mString\e[0m(bin)\
    \ + \e[31m\"db\"\e[0m\n\e[31m\e[31m   |\e[0m                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mconstructor\e\
    [0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m\
    \   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m (x$0: StringBuffer):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e\
    [0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\
    \e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1:\
    \ Int, x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String):\
    \ String\n\e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((bin : Array[Int]))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val x = decimal.toInt\n\
    \        var bin = \"\"\n        var x = x\n        while(x>0){\n            bin\
    \ = (x % 2l).toChar + bin\n            x = x/2\n        }\n        if(bin.equals(\"\
    0\") && x.equals(0) )\n            return \"db\" + bin\n        if(bin.equals(\"\
    1\") && x.equals(1))\n            return \"db\" + bin\n        bin\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpenm25se5.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mx\e[0m = x\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already defined as \e[33mvalue\e\
    [0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpenm25se5.scala:20:14 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            x = x/\e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val x\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        //convert decimal\
    \ to binary string\n        var binaryString = \"\"\n        while (decimal >\
    \ 0) {\n            val remainder = decimal % 2\n            decimal /= 2\n  \
    \          binaryString = remainder.toString + binaryString\n        }\n     \
    \   //add extra character 'db' to the beginning and end\n        binaryString\
    \ = \"db\" + binaryString + \"db\"\n        return binaryString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzt1kbt6j.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def binaryToDigit(binaryNum\
    \ : String) : String = {\n            val numbers = binaryNum.split('')\n    \
    \        val result = for (number <- numbers) yield {\n                number\
    \ match {\n                    case \"0\" => \"0\"\n                    case \"\
    1\" => \"1\"\n                    case _ => throw new NumberFormatException(\"\
    Binary number \" + binaryNum + \" has non binary digits: \" + number.toInt)\n\
    \                }\n            }\n            result mkString \"\"\n        }\n\
    \        def digitToBinary(digits : String) : String = {\n            val binary\
    \ = for (digit <- digits) yield {\n                digit match {\n           \
    \         case \"0\" => \"0\"\n                    case \"1\" => \"1\"\n     \
    \               case _ => throw new NumberFormatException(\"Decimal number \"\
    \ + digits + \" has non binary digits: \" + digit.toInt)\n                }\n\
    \            }\n            binary mkString \"\"\n        }\n        var binaryStr\
    \ = \"\"\n        var digitStr = \"\"\n        var tempStr = decimal.toString\n\
    \        while (tempStr.length > 0) {\n            binaryStr += digitToBinary(digitStr)\n\
    \            tempStr = tempStr.substring(1) + tempStr.substring(0, tempStr.length\
    \ - 1)\n            digitStr = \"\"\n        }\n        if (tempStr.length ==\
    \ 0) {\n            return binaryStr\n        } else {\n            binaryStr\
    \ += \"1\"\n            binaryStr += digitToBinary(tempStr)\n            binaryStr\
    \ += \"0\"\n            binaryStr\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnfoxhrq1.scala:16:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mnumbers\e[0m = binaryNum.split('')\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                                          empty character literal\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpnfoxhrq1.scala:17:23 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = \e[33mfor\e\
    [0m (number <- numbers) \e[33myield\e[0m {\n\e[31m\e[31m   |\e[0m            \
    \           ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnfoxhrq1.scala:17:12 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m            \e[33mval\e[0m \e[36mresult\e[0m = \e[33mfor\e[0m (number <- numbers)\
    \ \e[33myield\e[0m {\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e\
    [0m            Not found: 'val\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnfoxhrq1.scala:24:12 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m            result mkString \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: result\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpnfoxhrq1.scala:29:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mcase\e[0m \e[31m\"0\"\e[0m\
    \ => \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpnfoxhrq1.scala:30:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mcase\e[0m \e[31m\"1\"\e[0m\
    \ => \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with"
  stdout: ''
  timestamp: 1660009555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ decimal.toBinaryString()\n        binary = binary.replace(\"0\",\"0\")\n   \
    \     binary = binary.replace(\"1\",\"1\")\n        binary = binary.replace(\"\
    l\",\"L\")\n        binary = binary.replace(\"I\",\"l\")\n        binary = binary.replace(\"\
    I\",\"I\")\n        binary = binary.replace(\"l\",\"I\")\n        binary = binary.replace(\"\
    L\",\"I\")\n        binary = binary.replace(\"d\",\"D\")\n        binary = binary.replace(\"\
    D\",\"D\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"b\",\"B\")\n        binary = binary.replace(\"\
    B\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n        binary = binary.replace(\"\
    b\",\"B\")\n        binary = binary.replace(\"B\",\"B\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpx848ow9t.scala:15:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mbinary\e[0m = decimal.toBinaryString()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (i: Int): Char\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx848ow9t.scala:61:15 --------------------\e[0m\e\
    [0m\n\e[31m61 |\e[0m        binary = binary.replace(\e[31m\"B\"\e[0m,\e[31m\"\
    B\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009556
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString.reverse\n        val result = binary.foldLeft(\"\")((acc,\
    \ val) => acc + val)\n        result + \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuew5owfh.scala:16:47 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = binary.foldLeft(\e\
    [31m\"\"\e[0m)((\e[36macc\e[0m, \e[33mval\e[0m) => acc + \e[33mval\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                               ^^^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31mval\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuew5owfh.scala:16:61\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresult\e[0m = binary.foldLeft(\e[31m\"\"\e[0m)((\e[36macc\e[0m, \e[33mval\e\
    [0m) => acc + \e[33mval\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \                                    ^^^\e[0m\n\e[31m   |\e[0m               \
    \                        expression expected but \e[31mval\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = decimal.toBinaryString\n\
    \        if (bits.length == decimal.length) {\n            bits\n        } else\
    \ {\n            val remainder = (decimal.toInt - decimal.truncate % decimal).toBinaryString\n\
    \            s\"db${remainder}\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo2xberfy.scala:16:35 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (bits.length == decimal.length)\
    \ {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value length is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpo2xberfy.scala:19:53 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mremainder\e[0m = (decimal.toInt\
    \ - decimal.truncate % decimal).toBinaryString\n\e[31m\e[31m   |\e[0m        \
    \                                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                 value truncate is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009557
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        binary.reverse.takeWhile(_ != '0') ++ binary.reverse.dropWhile(_\
    \ != '0') ++ \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6tbrmmwf.scala:19)\n\tat Problem.main(tmp6tbrmmwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryStr\
    \ = \"\"\n        var digit = 0\n\n        while (decimal > 0) {\n           \
    \ digit = decimal % 2l\n            decimal /= 2l\n            binaryStr += if\
    \ (digit == 0) \"1\" else \"0\"\n        }\n        \"db\" + binaryStr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt99c5ht7.scala:21:25 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            binaryStr += \e[33mif\e[0m (digit == \e[31m0\e\
    [0m) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                         ^^\e[0m\n\e[31m   |\e[0m                         expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpt99c5ht7.scala:19:20 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            digit = decimal % \e[31m2l\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Long\n\e[31m   |\e[0m                    Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpt99c5ht7.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            decimal /= \e[31m2l\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not\
    \ a member of Long - did you mean decimal.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ Decimal(decimal).toBinaryString\n        val binaryArray = binary.toArray.filter(_\
    \ != '0')\n        val binaryString = binaryArray.mkString\n        val prefix\
    \ = \"db\"\n        binaryString.insert(prefix.length, prefix)\n        binaryString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpufafh9tv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = Decimal(decimal).toBinaryString\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: Decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009554
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val numberBits\
    \ = decimal.toBinaryString\n        val binaryBits = numberBits.split(\"(?<=\\\
    \\G.{8})\").map(x => x.toInt)\n        binaryBits.mkString(\"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx4okevqs.scala:20)\n\tat Problem.main(tmpx4okevqs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val res = new\
    \ mutable.StringBuilder\n        val dividend = decimal\n        val divisor =\
    \ 2 //decimal to binary\n        val digitCount = 0\n        while (dividend >\
    \ 0) {\n            val remainder = dividend % divisor\n            res.append(remainder)\n\
    \            dividend /= divisor\n            digitCount+=1\n        }\n     \
    \   res.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmegrimva.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpmegrimva.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            dividend /= divisor\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean dividend.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmegrimva.scala:23:22 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            digitCount+=\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value += is not a member of Int - did you mean\
    \ digitCount.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal match {\n            case x if x >= 0 && x < 2 => \"0\"\n          \
    \  case x if x >= 2 && x < 8 => \"1\"\n            case x if x >= 8 && x < 16\
    \ => \"10\"\n            case x if x >= 16 && x < 32 => \"11\"\n            case\
    \ x if x >= 32 && x < 64 => \"100\"\n            case x if x >= 64 && x < 128\
    \ => \"111\"\n            case x if x >= 128 && x < 256 => \"1000\"\n        \
    \    case x if x >= 256 && x < 512 => \"1111\"\n            case x if x >= 512\
    \ && x < 1024 => \"100000\"\n            case x if x >= 1024 && x < 2048 => \"\
    1000001\"\n            case x if x >= 2048 && x < 4096 => \"1000000\"\n      \
    \      case x if x >= 4096 && x < 8192 => \"10000001\"\n            case x if\
    \ x >= 8192 && x < 16384 => \"10000000\"\n            case x if x >= 16384 &&\
    \ x < 32768 => \"100000000\"\n            case x if x >= 32768 && x < 65536 =>\
    \ \"1000000001\"\n            case x if x >= 65536 && x < 131072 => \"10000000000\"\
    \n            case x if x >= 131072 && x < 262144 => \"100000000000\"\n      \
    \      case x if x >= 262144 && x < 524288 => \"1000000000000\"\n            case\
    \ x if x >= 524288 && x < 1048576 => \"10000000000000\"\n            case x if\
    \ x >= 1048576 && x < 2097152 => \"100000000000000\"\n            case x if x\
    \ >= 2097152 && x < 4194304 => \"1000000000000000\"\n            case x if x >=\
    \ 4194304 && x < 8388608 => \"10000000000000000\"\n            case x if x >=\
    \ 8388608 && x < 16777216 => \"100000000000000000\"\n            case x if x >=\
    \ 16777216 && x < 33554432 => \"1000000000000000000\"\n            case x if x\
    \ >= 33554432 && x < 67108864 => \"10000000000000000000\"\n            case x\
    \ if x >= 67108864 && x < 134217728 => \"100000000000000000000\"\n           \
    \ case x if x >= 134217728 && x < 268435456 => \"1000000000000000000000\"\n  \
    \          case x if x >= 268435456 && x < 536870912 => \"10000000000000000000000\"\
    \n            case x if x >= 536870912 && x < 1073741824 => \"100000000000000000000000\"\
    \n            case x if x >= 1073741824 && x < 2147483648 => \"1000000000000000000000000\"\
    \n            case x if x >= 2147483648 && x < 4294967296 => \"10000000000000000000000000\"\
    \n            case x if x >= 42949\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc1p2hpp9.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc1p2hpp9.scala:57:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m57 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmpc1p2hpp9.scala:45:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m45 |\e[0m       \
    \     \e[33mcase\e[0m x \e[33mif\e[0m x >= \e[31m1073741824\e[0m && x < \e[31m2147483648\e\
    [0m => \e[31m\"1000000000000000000000000\"\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpc1p2hpp9.scala:46:27 -----------------------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x >= \e[31m2147483648\e\
    [0m && x < \e[31m4294967296\e[0m => \e[31m\"10000000000000000000000000\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           number too large\n\e[31m\e[31m-- Error: /tmp/tmpc1p2hpp9.scala:46:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m46 |\e[0m       \
    \     \e[33mcase\e[0m x \e[33mif\e[0m x >= \e[31m2147483648\e[0m && x < \e[31m4294967296\e\
    [0m => \e[31m\"10000000000000000000000000\"\e[0m\n\e[31m\e[31m   |\e[0m      \
    \                                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                        number too large\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpc1p2hpp9.scala:56:1 ---------------------\e[0m\e\
    [0m\n\e[31m56 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpc1p2hpp9.scala:49:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m49 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e["
  stdout: ''
  timestamp: 1660009559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = decimal.toInt\n\
    \        var binaryString = \"\"\n        while (bits>0){\n            if (bits%2==0)\n\
    \                binaryString = \"1\" + binaryString\n            else\n     \
    \           binaryString = \"0\" + binaryString\n            bits = bits/2\n \
    \       }\n        binaryString + \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2efw4m_o.scala:22:17 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            bits = bits/\e[31m2\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val bits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009556
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = decimal.toBits\n\
    \        val length = bits.length\n        val result = new mutable.StringBuilder\n\
    \        var i = 0\n        while (i < length) {\n            val x = bits(i).toInt\n\
    \            if (x > 0) {\n                result.append(if (x == 1) \"1\" else\
    \ \"0\")\n            } else {\n                result.append(if (x == 1) \"0\"\
    \ else \"1\")\n            }\n            i += 1\n        }\n        result ++=\
    \ if (bits.toString.equals(\"1000000000000000000000000000000000000000000000000000000000000000b\"\
    )) {\n            \"\"\n        } else {\n            \"db\"\n        }\n    \
    \    return result.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuppq4ac3.scala:28:19 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        result ++= \e[33mif\e[0m (bits.toString.equals(\e\
    [31m\"1000000000000000000000000000000000000000000000000000000000000000b\"\e[0m))\
    \ {\n\e[31m\e[31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m        \
    \           expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpuppq4ac3.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m = decimal.toBits\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \    value toBits is not a member of Long - did you mean decimal.toByte?\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuppq4ac3.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        require(decimal\
    \ > 0 && decimal < 1l, \"The decimal number must be greater than 0 and less than\
    \ or equal to 1l\")\n        val remainder = decimal % (2l << 63)\n        if\
    \ (remainder == 0) {\n            return \"0\"\n        } else {\n           \
    \ val remainderString = decimalToBinary(remainder)\n            val powerString\
    \ = remainderString + if (remainderString.length < 6) \"0\" + if (remainderString.length\
    \ < 7) \"0\" + if (remainderString.length < 8) \"0\" + if (remainderString.length\
    \ < 9) \"0\" else \"1\"\n            return powerString\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb47t3zp6.scala:21:48 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mpowerString\e[0m = remainderString\
    \ + \e[33mif\e[0m (remainderString.length < \e[31m6\e[0m) \e[31m\"0\"\e[0m + \e\
    [33mif\e[0m (remainderString.length < \e[31m7\e[0m) \e[31m\"0\"\e[0m + \e[33mif\e\
    [0m (remainderString.length < \e[31m8\e[0m) \e[31m\"0\"\e[0m + \e[33mif\e[0m (remainderString.length\
    \ < \e[31m9\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                ^^\e[0m\n\e[31m \
    \  |\e[0m                                        expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcv80xah2.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36mdecimalToBinary\e\
    [0m(\e[36mdecimal\e[0m : \e[35mLong\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                   ^\e[0m\n\e[31m  \
    \ |\e[0m                                                   Found:    Unit\n\e\
    [31m   |\e[0m                                                   Required: String\n\
    \e[31m15 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m16 |\e[0m    }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ decimal.toString\n        if (binary.length < 8)\n            binary = (\"0\"\
    \ + binary)\n        if (binary.length < 16)\n            binary = (\"db\" + binary)\n\
    \        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvlo9utlg.scala:23)\n\tat Problem.main(tmpvlo9utlg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def binaryToDecimal(binary:\
    \ String) = {\n            def sum(n: String) = {\n                n.map(x =>\
    \ x == '1').foldLeft(0){(sum, n) => sum + Long(x)}\n            }\n          \
    \  val n = binary.toLong\n            val reverse = n.toString.reverse\n     \
    \       val first = sum(reverse.substring(0,reverse.length/2))\n            val\
    \ last = sum(reverse.substring(reverse.length/2))\n            (last - first).toString()\
    \ + first.toString() + n\n        }\n        val binary = decimal.toString.reverse\n\
    \        val first = binaryToDecimal(binary)\n        val last = binaryToDecimal(binary.substring(binary.length/2))\n\
    \        binary.substring(0, binary.length/2) + \"db\" + first + \"db\" + last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpmqdq_sx1.scala:17:67 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                n.map(\e[36mx\e[0m => x == \e[31m'1'\e\
    [0m).foldLeft(\e[31m0\e[0m){(\e[36msum\e[0m, \e[36mn\e[0m) => sum + Long(x)}\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                   \e[33mobject\e[0m \e\
    [35mLong\e[0m in \e[33mpackage\e[0m \e[35mscala\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmqdq_sx1.scala:17:72\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                n.map(\e\
    [36mx\e[0m => x == \e[31m'1'\e[0m).foldLeft(\e[31m0\e[0m){(\e[36msum\e[0m, \e\
    [36mn\e[0m) => sum + Long(x)}\n\e[31m\e[31m   |\e[0m                         \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                                      Not found: x\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"0\"\n        while(decimal > 0) {\n            binary += \"1\"\n         \
    \   decimal -= 1\n        }\n        return binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyzr4at43.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            decimal -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        decimal.toString(2)\
    \ match {\n            case \"\" => \"0\"\n            case c => if (c % 2 ==\
    \ 0) \"1\" + decimalToBinary(decimal / 2l) else \"0\" + decimalToBinary(decimal\
    \ / 2l)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppektsi8a.scala:15:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        decimal.toString(\e[31m2\e[0m) \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m \
    \        too many arguments for \e[33mmethod\e[0m \e[35mtoString\e[0m in \e[33mclass\e\
    [0m \e[35mAny\e[0m: (): String\n1 error found\n"
  stdout: ''
  timestamp: 1660009560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ = \"\"\n        var i = 0\n        while (decimal > 0) {\n            val bit\
    \ = decimal % 2\n            decimal /= 2\n            binaryString = bit + binaryString\n\
    \            i = i + 1\n        }\n        if (i <= 1) {\n            binaryString\
    \ = if (i == 0) \"0\" else binaryString + \"0\"\n            binaryString += \"\
    db\"\n        }\n        return binaryString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqm2dl6vs.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ scala.collection.mutable.ListBuffer.empty[String]\n        decimal match {\n\
    \            case 0 => binary += \"0\"\n            case 1 => binary += \"1\"\n\
    \            case _ => while (decimal > 0) {\n                    binary += decimalToBinary(decimal\
    \ / 2)\n                    decimal %= 2\n                }\n        }\n     \
    \   binary.reverse + \"db\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq922dsx8.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    decimal %= \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \ value %= is not a member of Long - did you mean decimal.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpq922dsx8.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        binary.reverse + \e[31m\"db\"\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of scala.collection.mutable.ListBuffer[String], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal ==\
    \ 0) {\n            return \"0\"\n        } else if (decimal < 0) {\n        \
    \    return \"-\" + decimalToBinary(-decimal)\n        }\n        // Here are\
    \ your base cases.\n        if (decimal < 10) {\n            return \"0\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100) {\n            return \"d\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 1000) {\n            return \"b\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 10000) {\n            return \"a\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100000) {\n            return \"9\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 1000000) {\n            return \"8\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 10000000) {\n            return \"7\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100000000) {\n            return \"6\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 1000000000) {\n            return \"5\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 10000000000) {\n            return \"4\" + decimalToBinary(decimal)\n\
    \        }\n        if (decimal < 100000000000) {\n            return \"3\" +\
    \ decimalToBinary(decimal)\n        }\n        if (decimal < 1000000000000) {\n\
    \            return \"2\" + decimalToBinary(decimal)\n        }\n        if (decimal\
    \ < 10000000000000) {\n            return \"1\" + decimalToBinary(decimal)\n \
    \       }\n        if (decimal < 100000000000000) {\n            return \"0\"\
    \ + decimalToBinary(decimal)\n        }\n        if (decimal < 1000000000000000)\
    \ {\n            return \"db\" + decimalToBinary(decimal)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmd58xmo3.scala:48:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mif\e[0m (decimal < \e[31m10000000000\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                      number too large\n\e[31m\e[31m-- Error: /tmp/tmpmd58xmo3.scala:51:22\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m51 |\e[0m       \
    \ \e[33mif\e[0m (decimal < \e[31m100000000000\e[0m) {\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \ number too large\n\e[31m\e[31m-- Error: /tmp/tmpmd58xmo3.scala:54:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mif\e[0m (decimal < \e[31m1000000000000\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      number too large\n\e[31m\e[31m-- Error: /tmp/tmpmd58xmo3.scala:57:22\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m57 |\e[0m       \
    \ \e[33mif\e[0m (decimal < \e[31m10000000000000\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    number too large\n\e[31m\e[31m-- Error: /tmp/tmpmd58xmo3.scala:60:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mif\e[0m (decimal < \e[31m100000000000000\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      number too large\n\e[31m\e[31m-- Error: /tmp/tmpmd58xmo3.scala:63:22\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m63 |\e[0m       \
    \ \e[33mif\e[0m (decimal < \e[31m1000000000000000\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \        number too large\n6 errors found\n"
  stdout: ''
  timestamp: 1660009561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val list = mutable.ListBuffer[String]()\n\
    \        while(decimal >= 1) {\n            decimal %= 2\n            list +=\
    \ decimal.toString\n            decimal /= 2\n        }\n        list += decimal.toString\n\
    \        list += (\"db\")\n        list.toList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp95yapsne.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp95yapsne.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            decimal %= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not a member\
    \ of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp95yapsne.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            decimal /= \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value /= is not a member of Long - did you mean decimal.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var sum : Long\
    \ = 0\n        while(decimal > 0){\n            sum = sum + decimal % 2\n    \
    \        decimal = decimal >> 1\n        }\n        while(sum > 0){\n        \
    \    val remainder = sum % 2\n            sum = sum / 2\n            if(remainder\
    \ == 1)\n                sum = sum + 1\n        }\n        val result: mutable.Queue[String]\
    \ = mutable.Queue[String]()\n        while(sum > 0){\n            val remainder\
    \ = sum % 2\n            sum = sum / 2\n            if(remainder == 1)\n     \
    \           result.enqueue(\"1\")\n            else\n                result.enqueue(\"\
    0\")\n        }\n        val result = result.mkString(\"\")\n        val db =\
    \ \"db\"\n        if(result.head == db) result else db + result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptbb1wkqd.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmptbb1wkqd.scala:18:20 -----------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m            decimal = decimal >> \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptbb1wkqd.scala:26:20\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: mutable.Queue[\e[35mString\e[0m] = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptbb1wkqd.scala:26:44 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: mutable.Queue[\e\
    [35mString\e[0m] = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                                           ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                        Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val power2Binaries\
    \ = decimal.toBinaryString\n        val power2BinariesLength = power2Binaries.length\n\
    \        val power2BinariesPadded = power2Binaries.padTo(power2BinariesLength,\
    \ \"0\")\n\n        val base2Binaries = power2BinariesPadded.reverse\n       \
    \ val base2BinariesLength = base2Binaries.length\n        val base2BinariesPadded\
    \ = base2Binaries.padTo(base2BinariesLength, \"0\")\n\n        val result = base2BinariesPadded\
    \ + power2BinariesPadded\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgoivwa5r.scala:23:41 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = base2BinariesPadded\
    \ + power2BinariesPadded\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of IndexedSeq[Matchable], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val dec = decimal\n\
    \        val binary = dec toString 2 times \"0\"\n        var binary = binary.substring(binary.length\
    \ - 2) +\n            if (dec % 2 == 0) \"1\" + binary.substring(binary.length\
    \ - 2) else binary\n        binary.substring(binary.length - 2) +\n          \
    \  if (dec % 2 != 0) \"1\" + binary.substring(binary.length - 2) else binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxuko570w.scala:17:58 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m) +\n\e[31m\e[31m   |\e[0m                                   \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \          expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpxuko570w.scala:19:45 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        binary.substring(binary.length - \e[31m2\e[0m)\
    \ +\n\e[31m\e[31m   |\e[0m                                             ^\e[0m\n\
    \e[31m   |\e[0m                                        expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpxuko570w.scala:16:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbinary\e[0m = dec toString \e[31m2\e[0m times \e[31m\"\
    0\"\e[0m\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m\
    \   |\e[0m         too many arguments for \e[33mmethod\e[0m \e[35mtoString\e[0m\
    \ in \e[33mclass\e[0m \e[35mAny\e[0m: (): String\n3 errors found\n"
  stdout: ''
  timestamp: 1660009564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = long2bits(decimal)\n\
    \        val res = bits.map(_ + 32).toList\n        res.take(2).toString + s\"\
    db$res(2 to ${res.size - 2})\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeped0x91.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m = long2bits(decimal)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \             Not found: long2bits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val n = decimal.toBinaryString\n\
    \        val len = n.length()\n        val binary = scala.collection.mutable.MutableList[Char]()\n\
    \        binary.add(\"0\")\n        for(i <- 0 to len - 1){\n            binary.add(\"\
    0\")\n        }\n        for(i <- 1 to len){\n            binary.add(\"1\")\n\
    \        }\n        if(len == 0){\n            val binary1 = binary.mkString\n\
    \            val binary2 = binary.mkString\n            val binary3 = binary.mkString\n\
    \            val binary4 = binary.mkString\n            val binary5 = binary.mkString\n\
    \            val binary6 = binary.mkString\n            val binary7 = binary.mkString\n\
    \            val binary8 = binary.mkString\n            val binary9 = binary.mkString\n\
    \            val binary10 = binary.mkString\n            val binary11 = binary.mkString\n\
    \            val binary12 = binary.mkString\n            val binary13 = binary.mkString\n\
    \            val binary14 = binary.mkString\n            val binary15 = binary.mkString\n\
    \            val binary16 = binary.mkString\n            val binary17 = binary.mkString\n\
    \            val binary18 = binary.mkString\n            val binary19 = binary.mkString\n\
    \            val binary20 = binary.mkString\n            val binary21 = binary.mkString\n\
    \            val binary22 = binary.mkString\n            val binary23 = binary.mkString\n\
    \            val binary24 = binary.mkString\n            val binary25 = binary.mkString\n\
    \            val binary26 = binary.mkString\n            val binary27 = binary.mkString\n\
    \            val binary28 = binary.mkString\n            val binary29 = binary.mkString\n\
    \            val binary30 = binary.mkString\n            val binary31 = binary.mkString\n\
    \            val binary32 = binary.mkString\n            val binary33 = binary.mkString\n\
    \            val binary34 = binary.mkString\n            val binary35 = binary.mkString\n\
    \            val binary36 = binary.mkString\n            val binary37 = binary.mkString\n\
    \            val binary38 = binary.mkString\n            val binary39 = binary.mkString\n\
    \            val binary40 = binary.mkString\n            val binary41 = binary.mkString\n\
    \            val binary42 = binary.mkString\n            val binary43 = binary.mkString\n\
    \            val binary44 = binary.mkString\n            val binary45 = bin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwu3n986q.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwu3n986q.scala:17:46\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mbinary\e[0m = scala.collection.mutable.MutableList[\e[35mChar\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value MutableList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwu3n986q.scala:70:27 ------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m            \e[33mval\e[0m \e[36mbinary45\e[0m = bin\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Not found: bin\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwu3n986q.scala:79:1 ---------------------\e[0m\e\
    [0m\n\e[31m79 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpwu3n986q.scala:72:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m72 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ new collection.mutable.ListBuffer[String]\n        binary.toList.map{\n    \
    \        case x if (x % 2==0) => x+1\n            case x if (x % 2==1) => x+2\n\
    \        }\n        binary.reverse.toString.zipWithIndex.map { case (x,i) if (i==0\
    \ || i==binary.length) =>\n            if(x==0) \"0\" else if(x==1) \"1\" else\
    \ x\n        }.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9heb15s2.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m (x % \e[31m2\e\
    [0m==\e[31m0\e[0m) => x+\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \     ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of String, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might make progress towards fixing the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9heb15s2.scala:18:25\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e\
    [0m x \e[33mif\e[0m (x % \e[31m2\e[0m==\e[31m1\e[0m) => x+\e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a\
    \ member of String, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary_num\
    \ = decimal.toBinaryString\n        binary_num = binary_num.reverse\n        binary_num\
    \ = binary_num.dropWhile(_ == '0').drop(1).dropWhile(_ == '1').drop(1)\n     \
    \   binary_num = binary_num.reverse\n        binary_num\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1qhn48vh.scala:22)\n\tat Problem.main(tmp1qhn48vh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val n = math.pow(2,decimal.toInt).toInt\n\
    \        var binary = \"\"\n        var index = 0\n        while (n>0){\n    \
    \        index = n.toInt\n            n -= 1\n            binary += if(index==0)\
    \ \"1\" else \"0\"\n        }\n        \"db\" + binary + \"db\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4z8gts59.scala:21:22 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            binary += \e[33mif\e[0m(index==\e[31m0\e\
    [0m) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                      ^^\e[0m\n\e[31m   |\e[0m                      expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp4z8gts59.scala:20:14 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            n -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\
    \e[31m   |\e[0m            value -= is not a member of Int - did you mean n.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        val result = if (binary.startsWith(\"0\")) binary.drop(1).reverse.tail\
    \ else \"db\" + binary.reverse.tail\n        result + result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcd5sxydc.scala:20)\n\tat Problem.main(tmpcd5sxydc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val str = new\
    \ StringBuilder(decimal.toString.length + 2).append('0').append('b').append('1')\n\
    \        val decimals = Decimal(decimal)\n        decimals.toBinary(str.toCharArray.tail.head)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbka15jzf.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mdecimals\e[0m = Decimal(decimal)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: Decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binaryNumbers\
    \ = (decimal % 2)\n        val decimal = decimal / 2\n        val binaryNumbers\
    \ = (decimal % 2)\n        var binaryNumbers = \"\"\n        while(decimal >=\
    \ 1) {\n            binaryNumbers = (decimal % 2) + binaryNumbers\n          \
    \  decimal = decimal / 2\n        }\n        binaryNumbers + binaryNumbers\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp5xz2j6b.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbinaryNumbers\e[0m = (decimal\
    \ % \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinaryNumbers is already defined as \e[33mvalue\e[0m \e[35mbinaryNumbers\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp5xz2j6b.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mvar\e[0m \e[36mbinaryNumbers\e[0m = \e[31m\"\"\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinaryNumbers\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinaryNumbers\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp5xz2j6b.scala:16:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimal\e[0m = decimal / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m         \
    \             ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35mdecimal\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpp5xz2j6b.scala:20:26 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            binaryNumbers = (decimal % \e[31m2\e[0m) + binaryNumbers\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val binaryNumbers\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpp5xz2j6b.scala:21:20 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            decimal = decimal / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   Reassignment to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        var bit = decimal.toInt\n        val digits = decimal.pow(2.toDouble)\n\
    \n        while(decimal != 0) {\n            binary += if (bit % 2 == 0) \"0\"\
    \ else \"1\"\n            bit /= 2\n        }\n\n        binary ++ \"db\" + binary.dropRight(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpccumfqyk.scala:20:22 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            binary += \e[33mif\e[0m (bit % \e[31m2\e\
    [0m == \e[31m0\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                      ^^\e[0m\n\e[31m   |\e[0m                  \
    \    expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpccumfqyk.scala:17:29 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = decimal.pow(\e\
    [31m2\e[0m.toDouble)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pow is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ = \"\"\n        var bits = decimal & (1l << 63)\n        while(bits != 0) {\n\
    \            val result = bits & 1l\n            val newBits = bits >> 1l\n  \
    \          binaryString += if (result == 0) \"0\" else \"1\"\n            bits\
    \ = newBits\n        }\n        binaryString + binaryString.reverse\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfn2rf_1v.scala:20:28 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            binaryString += \e[33mif\e[0m (result ==\
    \ \e[31m0\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                            ^^\e[0m\n\e[31m   |\e[0m               \
    \             expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009567
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binaryDecimal\
    \ = decimal.toBinaryString\n        val binaryString = \"db\" + binaryDecimal.substring(2)\
    \ + \"db\"\n        binaryString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmprfhcs_vu.scala:16)\n\
    \tat Problem$.main(tmprfhcs_vu.scala:20)\n\tat Problem.main(tmprfhcs_vu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        require(!decimal.toString.isEmpty)\n\
    \        val binary = decimal.toBinaryString\n        val firstTwoChars = binary.substring(0,2)\n\
    \        val lastTwoChars = binary.substring(binary.length-2, binary.length-1)\n\
    \        val result = firstTwoChars + lastTwoChars\n        val binary = result\
    \ + result.substring(result.length-1)\n        val length = binary.length()\n\
    \        val extraChars = binary.substring(0,2)\n        val dbChars = binary.substring(length-4)\n\
    \        val resultString = extraChars + dbChars\n        return resultString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_11bjdzb.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = result + result.substring(result.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009568
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryNum\
    \ = decimal.toBinaryString\n        binaryNum = binaryNum.substring(0,binaryNum.length-1)\n\
    \        var extraChars = \"db\"\n        if (decimal.toInt > Integer.MAX_VALUE){\n\
    \            extraChars = \"ddb\"\n        }\n        binaryNum = extraChars.charAt(0)+binaryNum\n\
    \        val length = binaryNum.length\n        val binary = binaryNum.substring(0,length-1)\n\
    \        return binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn1w7q6nr.scala:27)\n\tat Problem.main(tmpn1w7q6nr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var bits = \"\
    \"\n        while(decimal > 0) {\n            bits = bits + \"0\"\n          \
    \  decimal -= 1\n        }\n        while(bits.length() != 5) {\n            bits\
    \ = bits + \"0\"\n        }\n        bits = bits + \"db\"\n        while(bits.length\
    \ > 0) {\n            bits = bits + \"0\"\n        }\n        return bits\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8y7l7geh.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            decimal -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ new mutable.ArrayBuffer[String]\n        var power = 1\n        val maxDecimal\
    \ = decimal.toInt\n        val powersOfTen = List(10l, 100l, 1000l, 10000l, 100000l,\
    \ 1000000l, 10000000l, 100000000l, 1000000000l, 10000000000l, 100000000000l, 1000000000000l,\
    \ 10000000000000l, 100000000000000l, 1000000000000000l, 10000000000000000l, 100000000000000000l,\
    \ 1000000000000000000l, 10000000000000000000l)\n        for (i <- 0 until maxDecimal)\
    \ {\n            val current = decimal.toInt\n            val previous = power\n\
    \            while (current > 0) {\n                binary.append(powersOfTen(previous).toString)\n\
    \                current -= powersOfTen(previous)\n                power += 1\n\
    \            }\n            power = previous\n        }\n        binary.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9qhg7ub8.scala:18:274 ----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mpowersOfTen\e[0m = List(\e\
    [31m10l\e[0m, \e[31m100l\e[0m, \e[31m1000l\e[0m, \e[31m10000l\e[0m, \e[31m100000l\e\
    [0m, \e[31m1000000l\e[0m, \e[31m10000000l\e[0m, \e[31m100000000l\e[0m, \e[31m1000000000l\e\
    [0m, \e[31m10000000000l\e[0m, \e[31m100000000000l\e[0m, \e[31m1000000000000l\e\
    [0m, \e[31m10000000000000l\e[0m, \e[31m100000000000000l\e[0m, \e[31m1000000000000000l\e\
    [0m, \e[31m10000000000000000l\e[0m, \e[31m100000000000000000l\e[0m, \e[31m1000000000000000000l\e\
    [0m, \e[31m10000000000000000000l\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp9qhg7ub8.scala:19:0 ----------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until maxDecimal) {\n\e\
    [31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m')' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9qhg7ub8.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9qhg7ub8.scala:24:24\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                current -=\
    \ powersOfTen(previous)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m              value -= is not a member of Int - did you mean current.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        decimal.toBinaryString.take(decimal.toBinaryString.length%2).mkString(\"\
    0\")\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkgzwyad_.scala:18)\n\tat Problem.main(tmpkgzwyad_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        if (binary.length > 7) {\n            binary.substring(0,\
    \ 7) + \"db\" + binary.substring(binary.length - 7)\n        } else {\n      \
    \      binary + \"db\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppt4bbjgb.scala:23)\n\tat Problem.main(tmppt4bbjgb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        require(decimal\
    \ > 0, \"The decimal number must be positive\")\n        val length = decimal.toString.length\n\
    \        val binary = decimal.toString.reverse.foldLeft(\"\")((res, digit) =>\
    \ res + (digit match {\n            case 0 => \"0\"\n            case 1 => \"\
    1\"\n            case _ => \"0\"\n        })).reverse\n        binary.take(length)\
    \ + (\"db\" + binary.drop(length))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: requirement failed: The decimal number\
    \ must be positive\n\tat scala.Predef$.require(Predef.scala:337)\n\tat Problem$.decimalToBinary(tmpokh89w58.scala:15)\n\
    \tat Problem$.main(tmpokh89w58.scala:25)\n\tat Problem.main(tmpokh89w58.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // your implementation\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp170i3tq_.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36mdecimalToBinary\e\
    [0m(\e[36mdecimal\e[0m : \e[35mLong\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                   ^\e[0m\n\e[31m  \
    \ |\e[0m                                                   Found:    Unit\n\e\
    [31m   |\e[0m                                                   Required: String\n\
    \e[31m15 |\e[0m        \e[34m// your implementation here\e[0m\n\e[31m16 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        binary.takeWhile(_.length != 1).mkString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwl2hpofk.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        binary.takeWhile(_.length != \e[31m1\e[0m).mkString\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                        value length is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result =\
    \ \"\"\n        var remainder = 0\n        var tempDecimal = decimal\n       \
    \ while (tempDecimal > 0) {\n            remainder = tempDecimal % 2\n       \
    \     tempDecimal = (tempDecimal / 2)\n            result += (if (remainder ==\
    \ 0) \"0\" else \"1\")\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2kfx12pl.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            remainder = tempDecimal\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    Long\n\e[31m   |\e[0m  \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result =\
    \ \"\"\n        while (decimal > 0 ) {\n            decimal -= power(2, decimal)\n\
    \            result += if (decimal > 0) \"1\" + \"0\"\n            else \"0\"\n\
    \        }\n        if (result.isEmpty) result += \"0\"\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkshmil5y.scala:18:22 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result += \e[33mif\e[0m (decimal > \e[31m0\e\
    [0m) \e[31m\"1\"\e[0m + \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m              \
    \        ^^\e[0m\n\e[31m   |\e[0m                      expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkshmil5y.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            decimal -= power(\e\
    [31m2\e[0m, decimal)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value -= is not a member of Long - did you mean decimal.!=?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkshmil5y.scala:17:23 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            decimal -= power(\e[31m2\e[0m, decimal)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 Not found: power\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        val binary = binary.replace(\"1\", \"0\")\n\
    \        val binary = binary.replace(\"0\", \"1\")\n        \"db\" + binary +\
    \ \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfena6tna.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e\
    [31m\"1\"\e[0m, \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfena6tna.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e[31m\"\
    0\"\e[0m, \e[31m\"1\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binaryString\
    \ = new mutable.StringBuilder\n        val decimalPart = decimal % 2l\n      \
    \  decimal /= 2l\n        // binary representation of the remainder of the decimal\
    \ number\n        // starting from the least significant digit and going in reverse\
    \ order\n        var currentDecimalPart = decimalPart\n        while(currentDecimalPart\
    \ != 0l) {\n            binaryString.append('0')\n            currentDecimalPart\
    \ -= 1\n        }\n\n        // now move the decimal part to least significant\
    \ digit and append '1'\n        decimal += 1l\n        while(decimal != 0l) {\n\
    \            binaryString.append('1')\n            decimal -= 1l\n        }\n\n\
    \        // add extra characters\n        binaryString.append('b')\n        binaryString.append('b')\n\
    \n        return binaryString.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcvay6gfw.scala:15:31 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinaryString\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                             \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcvay6gfw.scala:17:16\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        decimal /= \e[31m2l\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ /= is not a member of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcvay6gfw.scala:27:16 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        decimal += \e[31m1l\e[0m\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member of Long\
    \ - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcvay6gfw.scala:30:20\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            decimal -= \e\
    [31m1l\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value -= is not a member of Long - did you mean decimal.!=?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ scala.collection.mutable.StringBuilder()\n        decimal match {\n        \
    \    case 0 => binary.append(\"0\")\n            case _ =>\n                decimal\
    \ % (10l) match {\n                    case 0 => binary.append(\"0\")\n      \
    \              case _ =>\n                        decimal % (100l) match {\n \
    \                           case 0 => binary.append(\"000\")\n               \
    \             case _ =>\n                                decimal % (1000l) match\
    \ {\n                                    case 0 => binary.append(\"0000\")\n \
    \                                   case _ =>\n                              \
    \          decimal % (10000l) match {\n                                      \
    \      case 0 => binary.append(\"00000\")\n                                  \
    \          case _ =>\n                                                decimal\
    \ % (100000l) match {\n                                                    case\
    \ 0 => binary.append(\"000000\")\n                                           \
    \         case _ =>\n                                                        decimal\
    \ % (1000000l) match {\n                                                     \
    \       case 0 => binary.append(\"0000000\")\n                               \
    \                             case _ =>\n                                    \
    \                            decimal % (10000000l) match {\n                 \
    \                                                   case 0 => binary.append(\"\
    00000000\")\n                                                                \
    \    case _ =>\n                                                             \
    \           decimal % (100000000l) match {\n                                 \
    \                                           case 0 => binary.append(\"000000000\"\
    )\n                                                                          \
    \  case _ =>\n                                                               \
    \                 decimal % (1000000000l) match {\n                          \
    \                                                          case 0 => binary.append(\"\
    0000000000\")\n                                                              \
    \                      case _ =>\n                                           \
    \                                             decimal % (10000000000l) match {\n\
    \                                                                            \
    \                case 0 => binary.append(\"00000000000\")\n                  \
    \                                                                          case\
    \ _ =>\n                                                                     \
    \                           decimal % (100000000000l) match {\n              \
    \                                                                            \
    \          case 0 => binary.append(\"000000000000\")\n                       \
    \                                                                            \
    \ case _ =>\n                                                                \
    \                                        decimal % (1000000000000l) match {\n\
    \                                                                            \
    \                                case 0 => binary.append(\"0000000000000\")\n\
    \                                                                            \
    \                                case _ =>\n                                 \
    \                                                                            \
    \   decimal % (10000000000000l) match {\n                                    \
    \                                                                            \
    \    case 0 => binary.append(\"00000000000000\")\n                           \
    \                                                                            \
    \             case _ =>\n                                                    \
    \                                                                    decimal %\
    \ (100000000000000l) match {\n                                               \
    \                                                                            \
    \ case 0 => binary.append(\"000000000000000\")\n                             \
    \                                                                            \
    \                   case _ =>\n                                              \
    \                                                                            \
    \      decimal % (1000000000000000000l) match {\n                            \
    \                                                                            \
    \                            case 0 => binary.append(\"0000000000000000\")\n \
    \                                                                            \
    \                                                       case _ =>\n          \
    \                                                                            \
    \                                                  decimal % (10000000000000000000l)\
    \ match {\n                                                                  \
    \                                                                          case\
    \ 0 => binary.append(\"00000000000000000\")\n                                \
    \                                                                            \
    \                                case _ =>\n                                 \
    \                                                                            \
    \                                   decimal % (100000000000000000000l) match {\n\
    \                                                                            \
    \                                                                        case\
    \ 0 => binary.append(\"000000000000000000\")\n                               \
    \                                                                            \
    \                                         case _ =>\n                        \
    \                                                                            \
    \                                                    decimal % (1000000000000000000000l)\
    \ match {\n                                                                  \
    \                                                                            \
    \              case 0 => \n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpc_ifznl0.scala:64:147 ----------------------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m                                                    \
    \                                                                            \
    \        decimal % (\e[31m10000000000000000000l\e[0m) \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \       ^\e[0m\n\e[31m   |\e[0m                                              \
    \          number too large\n\e[31m\e[31m-- Error: /tmp/tmpc_ifznl0.scala:67:155\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m67 |\e[0m        \
    \                                                                            \
    \                                                            decimal % (\e[31m100000000000000000000l\e\
    [0m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                               \
    \                                                                            \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                                   number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpc_ifznl0.scala:70:163 ----------------------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m                                                    \
    \                                                                            \
    \                        decimal % (\e[31m1000000000000000000000l\e[0m) \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                                                 \
    \                                                                            \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                                         number too large\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpc_ifznl0.scala:73:4 ----------------------------\e[0m\e\
    [0m\n\e[31m73 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    ')' expected, but unindent found\n\e[31m\e[31m-- [E040] Syntax "
  stdout: ''
  timestamp: 1660009581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ decimalToBinString(decimal, new StringBuilder)\n        result ++ \"db\"\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6zfapihh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = decimalToBinString(decimal,\
    \ \e[33mnew\e[0m \e[35mStringBuilder\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ decimalToBinString\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val dec = decimal\n\
    \        var bin = \"\"\n        val power2 = dec / 2\n        var remainder =\
    \ dec\n        var i = 1\n        while(i < power2){\n            i += 1\n   \
    \         remainder *= 2\n        }\n        while(remainder > 0){\n         \
    \   if (remainder >= 10){\n                bin = bin+\"0\"+remainder\n       \
    \     }else {\n                bin = bin+\"1\"+remainder\n            }\n    \
    \        remainder = remainder / 10\n        }\n        bin+=\"db\"\n        bin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpylxi1csr.scala:36)\n\tat Problem.main(tmpylxi1csr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        var temp = decimal\n        while(temp != 0){\n            binary\
    \ += temp % 2 == 1 ? \"1\" : \"0\"\n            temp /= 2\n        }\n       \
    \ binary = binary + \"db\"\n        return binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcnk0xih_.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            binary += temp % \e[31m2\e[0m == \e[31m1\e\
    [0m ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcnk0xih_.scala:18:36\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            binary += temp\
    \ % \e[31m2\e[0m == \e[31m1\e[0m ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                  ^^^\e[0m\n\e[31m   |\e[0m     \
    \                             value ? is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val list = decimal.toBinaryString\n\
    \        val db = \"db\"\n        val res = (list + db).reverse\n        res(0)\
    \ +: res(1 to res.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ny4xnut.scala:18:22\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        res(\e[31m0\e[0m) +:\
    \ res(\e[31m1\e[0m to res.length)\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:    scala.collection.immutable.Range.Inclusive\n\
    \e[31m   |\e[0m                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        decimal.toString.reverse.grouped(2).map\
    \ { case (x, y) => y % 2 == 0 ? '1' : '0' }.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp82msme15.scala:15:67 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        decimal.toString.reverse.grouped(\e[31m2\e[0m).map\
    \ { \e[33mcase\e[0m (x, y) => y % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m'1'\e[0m\
    \ : \e[31m'0'\e[0m }.mkString\n\e[31m\e[31m   |\e[0m                         \
    \                                        ^^^\e[0m\n\e[31m   |\e[0mvalue % is not\
    \ a member of Any, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits: Array[Boolean]\
    \ = decimal.toBinaryString().toCharArray().map(bit => bit == '1')\n        val\
    \ numBits = bits.length\n        val result = new mutable.StringBuilder\n    \
    \    result.append(\"db\")\n        for (i <- 0 until numBits) {\n           \
    \ if (bits(i) == true) {\n                result.append('1')\n            } else\
    \ {\n                result.append('0')\n            }\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7ghrw1uk.scala:15:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m: \e[35mArray\e\
    [0m[\e[35mBoolean\e[0m] = decimal.toBinaryString().toCharArray().map(\e[36mbit\e\
    [0m => bit == \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m: (i: Int): Char\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ghrw1uk.scala:17:25\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ 0\n        var bit = 0\n        var decimalStr = decimal.toString\n        var\
    \ binStr = \"\"\n        while (decimalStr.length > 0) {\n            if ((decimal\
    \ mod 2) != 0) {\n                binary += 1\n                if (bit % 8 ==\
    \ 0) {\n                    binStr += \"0\"\n                } else {\n      \
    \              binStr += \"1\"\n                }\n            }\n           \
    \ decimal >>= 1\n            bi += 1\n        }\n        binStr += \"db\" + binStr.drop(binStr.length\
    \ - 1) + binStr.take(binStr.length - 2)\n        binStr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi6b1eod_.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m ((decimal mod \e[31m2\e[0m)\
    \ != \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue mod is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi6b1eod_.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            decimal >>= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value >>= is not a member of Long - did you mean decimal.>=?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6b1eod_.scala:29:12 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            bi += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^\e[0m\n\e[31m   |\e[0m            Not found: bi\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        var power = 1\n        var remainder = decimal\n        while\
    \ (decimal.isMultipleOf(power)) {\n            power *= 2\n        }\n       \
    \ while (true) {\n            if (remainder >= power) {\n                remainder\
    \ -= power\n                binary = binary + \"0\"\n            } else {\n  \
    \              binary = binary + \"1\"\n                remainder += power\n \
    \           }\n            power /= 2\n            if (remainder == 0) {\n   \
    \             break\n            }\n        }\n        // The last two binary\
    \ digits are \"db\"\n        binary += \"db\" + binary.substring(binary.length\
    \ - 2)\n        binary += \"db\"\n        return binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppzhcqauo.scala:18:23 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mwhile\e[0m (decimal.isMultipleOf(power))\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value isMultipleOf is not a member of Long\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppzhcqauo.scala:31:16 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                break\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalString\
    \ = \"\" + decimal\n        val bits = decimalString.length\n\n        val binary\
    \ = decimalString.reverse.grouped(2).map { i =>\n            if(i.size < bits)\
    \ i.toChar\n            else i.take(bits).mkString(\"0\") + i.drop(bits).mkString(\"\
    1\")\n        }\n        binary.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp06hgijkq.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(i.size < bits) i.toChar\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value toChar is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp06hgijkq.scala:22:15 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        binary.reverse\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String]\
    \ - did you mean binary.reversed?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalString\
    \ = decimal.toString\n        var binary = \"\"\n        for (i <- decimalString.indices)\
    \ {\n            if (decimal % 2 != 0) {\n                binary = binary + decimalString.charAt(i)\
    \ + \" \"\n            } else {\n                binary = binary + decimalString.charAt(i)\
    \ + \"0\"\n            }\n            decimal = decimal / 2\n        }\n     \
    \   return \"db\" + binary + \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpp2c4xj53.scala:23:20 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            decimal = decimal / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   Reassignment to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val str = \"\"\
    \n        val binary = scala.collection.mutable.ListBuffer.empty[String]\n   \
    \     for(i <- 1 until decimal.asInstanceOf[Int]) {\n            val bit = if\
    \ (decimal % 2 == 0) 1 else 0\n            str += \"0\"\n            val digit\
    \ = decimal % 10\n            decimal /= 10\n            str += digitToBinary(digit,\
    \ bit)\n            binary += str\n        }\n        binary += str\n        binary.dropRight(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfvvlu8v6.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            str += \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of String - did you mean str.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfvvlu8v6.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            decimal /= \e\
    [31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value /= is not a member of Long - did you mean decimal.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfvvlu8v6.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            str += digitToBinary(digit, bit)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean str.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfvvlu8v6.scala:22:19 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m            str += digitToBinary(digit, bit)\n\e[31m\e[31m   |\e[0m       \
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ digitToBinary\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfvvlu8v6.scala:26:24\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    scala.collection.mutable.ListBuffer[String]\n\e[31m   |\e[0m\
    \        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      var binary = \"\
    \"\n      var count = 1\n      while (decimal != 0) {\n        decimal = decimal\
    \ / 2\n        binary = binary + decimalToBinary(decimal).toChar\n        count\
    \ = count + 1\n      }\n      binary = binary + decimalToBinary(decimal)\n   \
    \   binary = binary + \"db\"\n      binary = binary + binary.tail\n      binary.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzakyda6u.scala:18:16 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        decimal = decimal / \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzakyda6u.scala:19:51\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        binary = binary +\
    \ decimalToBinary(decimal).toChar\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \        value toChar is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      var result : String\
    \ = \"\"\n      var decimalPart : Long = decimal\n      var binaryPart : String\
    \ = \"\"\n      for(i <- 1 until decimal.toInt) {\n        decimalPart /= 2\n\
    \        binaryPart = decimalPart.toString.toString.reverse +  binaryPart\n  \
    \    }\n      result = binaryPart\n      result += \"db\"\n      result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6mn31wtn.scala:27)\n\tat Problem.main(tmp6mn31wtn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        require(decimal\
    \ >= 0)\n        require(decimal <= (1L * 10^100))\n\n        var binary = new\
    \ StringBuilder(100)\n        decimalToBinary(decimal, \"\", binary)\n       \
    \ binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5l8wlmxf.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        decimalToBinary(decimal,\
    \ \e[31m\"\"\e[0m, binary)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    (Long, String, StringBuilder)\n\
    \e[31m   |\e[0m                        Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5l8wlmxf.scala:20:15 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        binary.reverse\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\e[31m\
    \   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        val resultString = binary.substring(binary.length-1)\n\
    \        val dbChar = \"db\"\n        val lengthDiff = decimal.asInstanceOf[Long].toString.length\
    \ - resultString.length\n        val extraChar = if (lengthDiff > 0) \"db\" else\
    \ \"\"\n        resultString.substring(0,resultString.length-1).insert(lengthDiff,\
    \ dbChar+extraChar)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo03kbu9v.scala:20:56 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        resultString.substring(\e[31m0\e[0m,resultString.length-\e\
    [31m1\e[0m).insert(lengthDiff, dbChar+extraChar)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    value insert is not a member of String - did you mean String.indent?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        def toBinary(decimal\
    \ : Long) : List[String] = decimal match {\n            case 0 => List(\"0\")\n\
    \            case 1 => List(\"1\")\n            case _ => {\n                if\
    \ (decimal > 1) toBinary(decimal / 2).toList else List(\"0\")\n            }\n\
    \        }\n        toBinary(decimal).reverse.mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpida5hmu2.scala:25)\n\tat Problem.main(tmpida5hmu2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var str = new\
    \ StringBuilder()\n        var i = 0\n        while (decimal > 0) {\n        \
    \    if (decimal % 2 == 0) {\n                str.append(\"1\")\n            }\n\
    \            else {\n                str.append(\"0\")\n            }\n      \
    \      decimal -= 1\n            i += 1\n        }\n        str ++= str.drop(i)\n\
    \        str ++= str\n        str ++= str.drop(1).dropRight(1)\n        str ++=\
    \ str\n        str ++= str.drop(1).dropRight(1)\n        return str\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi1pjjfpj.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            decimal -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpi1pjjfpj.scala:32:15 --------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \        \e[33mreturn\e[0m str\n\e[31m\e[31m   |\e[0m               ^^^\e[0m\n\
    \e[31m   |\e[0m               Found:    (str : StringBuilder)\n\e[31m   |\e[0m\
    \               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val result =\
    \ new mutable.LinkedList[String]()\n        while(decimal != 0){\n           \
    \ if(decimal % 2 == 1){\n                result.addFirst(s\"${decimal.toChar}1\"\
    )\n            } else {\n                result.addFirst(s\"${decimal.toChar}0\"\
    )\n            }\n            decimal /= 2\n        }\n        result.reverse()\n\
    \        val pad = result.tail.mkString(\"\")\n        val head = result.head\n\
    \        val head = if(head.equals(\"0\")) s\"db$pad\" else s\"$headdb$pad\"\n\
    \        head\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg5qne6fr.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhead\e[0m = \e[33mif\e[0m(head.equals(\e\
    [31m\"0\"\e[0m)) \e[31ms\"db\e[0m$pad\e[31m\"\e[0m \e[33melse\e[0m \e[31ms\"\e\
    [0m$headdb$pad\e[31m\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhead is already defined as \e[33mvalue\e[0m \e[35mhead\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpg5qne6fr.scala:15:25 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.LinkedList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpg5qne6fr.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        for( a <- decimal until decimal + 31)\n            binary += (a\
    \ & 1l).toChar\n        binary += \"db\"\n        for( a <- decimal until decimal\
    \ + 63)\n            binary += (a & 1l).toChar\n        return binary\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1s9r64zg.scala:24)\n\tat Problem.main(tmp1s9r64zg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val power = math.pow(2,decimal).toInt\n\
    \        var result: String = \"\"\n        for(i <- 0 until power) {\n      \
    \      result += if (decimal % 2 != 0) '0' else '1'\n            decimal /= 2\n\
    \        }\n        result ++ \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8s5znjd8.scala:18:22 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result += \e[33mif\e[0m (decimal % \e[31m2\e\
    [0m != \e[31m0\e[0m) \e[31m'0'\e[0m \e[33melse\e[0m \e[31m'1'\e[0m\n\e[31m\e[31m\
    \   |\e[0m                      ^^\e[0m\n\e[31m   |\e[0m                     \
    \ expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8s5znjd8.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        // Keep track of the current and previous digits to keep track\
    \ of where we are\n        var current = 0\n        var previous = 0\n       \
    \ while(current < decimal){\n            binary = binary + ((decimal % 2) != 0)\
    \ ? \"1\" : \"0\"\n            decimal /= 2\n            current += 1\n      \
    \  }\n        // Now that the decimal is done looping, add in the extra characters\n\
    \        binary = \"db\" + binary + \"db\"\n        binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0chdnku3.scala:20:51 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            binary = binary + ((decimal % \e[31m2\e[0m)\
    \ != \e[31m0\e[0m) ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                            value ? is not a member of Boolean\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0chdnku3.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ new mutable.MutableList[Char]()\n        var i = 0\n        while(decimal !=\
    \ 0) {\n            binary.append((decimal % 2).asInstanceOf[Char])\n        \
    \    decimal = decimal / 2\n        }\n        binary.reverse.foreach(binary.append)\n\
    \        binary.reverse.tail.foreach(binary.append)\n        binary.reverse.prepend('b')\n\
    \        binary.reverse.prepend('d')\n        binary.reverse.prepend('b')\n  \
    \      binary.reverse.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpia7f9of_.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpia7f9of_.scala:19:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            decimal\
    \ = decimal / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val decimal\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Convert decimal\
    \ to binary\n        var binary : String = \"\"\n\n        // Loop over decimal\
    \ number\n        while (decimal > 0) {\n            // Determine which half is\
    \ 1 or 0\n            val remainder = decimal % 2\n            // Add character\
    \ to string \n            binary += remainder\n            // Convert number to\
    \ binary in reverse order\n            decimal = decimal / 2\n        }\n\n  \
    \      // Add extra characters\n        binary += \"db\"\n        binary += \"\
    0\"\n        binary += \"0\"\n\n        return binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpobfdmhuf.scala:25:20 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            decimal = decimal / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   Reassignment to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Initialize\
    \ the string variable\n        var binaryString = \"\"\n\n        // Convert decimal\
    \ to binary\n        binary <- decimalToBinary(decimal, 2)\n\n        // Append\
    \ binary to the string variable\n        binaryString += binary\n\n        //\
    \ Return the string variable\n        binaryString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzks4xg6_.scala:19:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        binary <- decimalToBinary(decimal, \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m               ^^\e[0m\n\e[31m   |\e[0m           \
    \    end of statement expected but '<-' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpzks4xg6_.scala:19:8 -------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        binary <- decimalToBinary(decimal, \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Not found: binary\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzks4xg6_.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        binaryString += binary\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member\
    \ of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzks4xg6_.scala:22:24 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        binaryString += binary\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: binary\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ here\n        val str: String = \"\"\n        for(i <- 0 until decimal.toInt){\n\
    \            str ++= if(decimal.toInt%2==1) \"1\" else \"0\"\n        }\n    \
    \    str ++= \"db\"\n        return str\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpeqz8eigg.scala:18:20 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            str ++= \e[33mif\e[0m(decimal.toInt%\e[31m2\e\
    [0m==\e[31m1\e[0m) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpeqz8eigg.scala:18:16 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m            str ++= \e[33mif\e[0m(decimal.toInt%\e[31m2\e[0m==\e[31m1\e[0m)\
    \ \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m            value ++= is not a member of\
    \ String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeqz8eigg.scala:20:12\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        str ++= \e[31m\"\
    db\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ ++= is not a member of String\n3 errors found\n"
  stdout: ''
  timestamp: 1660009589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if (decimal ==\
    \ 0) {\n            return \"0\"\n        }\n        val result = \"\"\n     \
    \   val remainder = decimal.toLong % 2\n        val quotient = decimal.toLong\
    \ / 2\n        while (quotient > 0) {\n            val decimal = quotient % 2\n\
    \            result += decimal.toString\n            quotient = quotient / 2\n\
    \        }\n        result += remainder.toString\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcgd55iyr.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            result += decimal.toString\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean result.!=?\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpcgd55iyr.scala:24:21 -----------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            quotient = quotient / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val quotient\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcgd55iyr.scala:26:15\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result += remainder.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is\
    \ not a member of String - did you mean result.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        decimalToBinary(decimal.toDouble)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyg5xn9en.scala:15:32\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        decimalToBinary(decimal.toDouble)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    Double\n\e[31m   |\e[0m                 \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalToBin\
    \ = decimal.toBinaryString\n        val extraChars = Array.fill[String](1, \"\
    db\").map(\"0\").mkString\n        val extraCharsString = extraChars + \"db\"\n\
    \        val binary = decimalToBin.substring(extraCharsString.length)\n      \
    \  binary.toUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvvsleco0.scala:16:47\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraChars\e\
    [0m = Array.fill[\e[35mString\e[0m](\e[31m1\e[0m, \e[31m\"db\"\e[0m).map(\e[31m\"\
    0\"\e[0m).mkString\n\e[31m\e[31m   |\e[0m                                    \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \        Found:    (\e[32m\"db\"\e[0m : String)\n\e[31m   |\e[0m             \
    \                                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val num: Long\
    \ = decimal.toInt\n        var binary: String = \"\"\n        var decimalPart\
    \ = decimal\n        while (decimalPart > 0) {\n            binary += \"0\"\n\
    \            decimalPart -= 1\n        }\n        while (decimal > 0) {\n    \
    \        binary += \"1\"\n            decimal -= 1\n        }\n        binary\
    \ += \"db\"\n        binary\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplv3x9pu1.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            decimal -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val digits =\
    \ decimal.toString.reverse.grouped(2).map{ \n            c => (c.toInt%2 match\
    \ {\n                case 0 => \"0\"\n                case 1 => \"1\"\n      \
    \      }).reverse\n        }\n        val binaryString = digits.reduceLeft{ acc,\
    \ d => acc+d}\n        (binaryString.substring(0,binaryString.length-2) + \"db\"\
    \ + binaryString.substring(binaryString.length-2,binaryString.length))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6jfao_sx.scala:21:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbinaryString\e[0m = digits.reduceLeft{\
    \ acc, d => acc+d}\n\e[31m\e[31m   |\e[0m                                    \
    \             ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but ',' found\n1 error found\n"
  stdout: ''
  timestamp: 1660009589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val digits =\
    \ mutable.ArrayBuffer.empty[Char]\n        while(decimal > 0){\n            digits\
    \ += decimal.toChar\n            decimal -= 1\n        }\n        digits reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpryi6i1r7.scala:20:22 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        digits reverse\n\e[31m\e[31m   |\e[0m       \
    \               ^\e[0m\n\e[31m   |\e[0m                      expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpryi6i1r7.scala:15:21 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mdigits\e[0m = mutable.ArrayBuffer.empty[\e[35mChar\e\
    [0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpryi6i1r7.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            decimal -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean decimal.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ here\n        // Your code here\n        // Your code here\n        // Your\
    \ code here\n        // Your code here\n        // Your code here\n        //\
    \ Your code here\n        // Your code here\n        // Your code here\n     \
    \   // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your code here\n        // Your code here\n        // Your code here\n\
    \        // Your \n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ur6ww_8.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m 14 |\e[0m    \e[33mdef\e[0m \e[36mdecimalToBinary\e\
    [0m(\e[36mdecimal\e[0m : \e[35mLong\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \    |\e[0m                                                   ^\e[0m\n\e[31m \
    \   |\e[0m                                                   Found:    Unit\n\e\
    [31m    |\e[0m                                                   Required: String\n\
    \e[31m 15 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 16 |\e[0m       \
    \ \e[34m// Your code here\e[0m\n\e[31m 17 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m 18 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 19 |\e[0m  \
    \      \e[34m// Your code here\e[0m\n\e[31m 20 |\e[0m        \e[34m// Your code\
    \ here\e[0m\n\e[31m 21 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 22 |\e\
    [0m        \e[34m// Your code here\e[0m\n\e[31m 23 |\e[0m        \e[34m// Your\
    \ code here\e[0m\n\e[31m 24 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m\
    \ 25 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 26 |\e[0m        \e[34m//\
    \ Your code here\e[0m\n\e[31m 27 |\e[0m        \e[34m// Your code here\e[0m\n\e\
    [31m 28 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 29 |\e[0m        \e\
    [34m// Your code here\e[0m\n\e[31m 30 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m 31 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 32 |\e[0m  \
    \      \e[34m// Your code here\e[0m\n\e[31m 33 |\e[0m        \e[34m// Your code\
    \ here\e[0m\n\e[31m 34 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 35 |\e\
    [0m        \e[34m// Your code here\e[0m\n\e[31m 36 |\e[0m        \e[34m// Your\
    \ code here\e[0m\n\e[31m 37 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m\
    \ 38 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 39 |\e[0m        \e[34m//\
    \ Your code here\e[0m\n\e[31m 40 |\e[0m        \e[34m// Your code here\e[0m\n\e\
    [31m 41 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 42 |\e[0m        \e\
    [34m// Your code here\e[0m\n\e[31m 43 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m 44 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m 45 |\e[0m  \
    \      \e[34m// Your code here\e[0m\n\e[31m 46 |\e[0m        \e[34m// Your code\
    \ here\e[0m\n\e[31m 47 |\e[0m        \e[34m// Y"
  stdout: ''
  timestamp: 1660009592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.toBinaryString\n        val string = new Array[String](1)\n        string(0)\
    \ = binary\n        string.mkString(\"db\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptcm_zg69.scala:21)\n\tat Problem.main(tmptcm_zg69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalBinary\
    \ = scala.math.BigInt(decimal).binary.toBinaryString\n        val binaryString\
    \ = decimalBinary.reverse.take(decimalBinary.length - 2).reverse\n        binaryString\
    \ + (if (decimalBinary.length == 2) \"0db\" else \"db\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj9yr19dl.scala:15:55 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalBinary\e[0m = scala.math.BigInt(decimal).binary.toBinaryString\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value binary is not a member of\
    \ BigInt\n1 error found\n"
  stdout: ''
  timestamp: 1660009593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ scala.collection.mutable.StringBuilder()\n        for (digit <- decimal.toBinaryString\
    \ drop 32) {\n            binary += digit\n        }\n        if (binary.length\
    \ > 0) {\n            binary += scala.collection.mutable.StringBuilder(32 - binary.length)\n\
    \        }\n        if (decimal == 0) {\n            binary.toString + \"db\"\n\
    \        } else {\n            binary.toString + \"db\"\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy0l69l42.scala:20:60\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            binary += scala.collection.mutable.StringBuilder(\e\
    [31m32\e[0m - binary.length)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    StringBuilder\n\e[31m   |\e\
    [0m                      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result :\
    \ String = \"\"\n        while(decimal != 0){\n            if(decimal % 2 == 0){\n\
    \                decimal /= 2\n                result += \"1\"\n            }else{\n\
    \                decimal /= 2\n                result += \"0\"\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprf2ftz7b.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                decimal /= \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value /=\
    \ is not a member of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmprf2ftz7b.scala:21:24 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m                decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value /= is not\
    \ a member of Long - did you mean decimal.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcv80xah2.scala:14:51\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36mdecimalToBinary\e\
    [0m(\e[36mdecimal\e[0m : \e[35mLong\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                   ^\e[0m\n\e[31m  \
    \ |\e[0m                                                   Found:    Unit\n\e\
    [31m   |\e[0m                                                   Required: String\n\
    \e[31m15 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m16 |\e[0m    }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binaryString\
    \ = s\"db\"\n        var remainder = decimal\n        while(decimal != 0){\n \
    \           if(decimal % 2 == 0) {\n                binaryString += \"0\"\n  \
    \          }else{\n                binaryString += \"1\"\n            }\n    \
    \        remainder = remainder - decimal\n            decimal = remainder / 2\n\
    \        }\n        binaryString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpid4if7ud.scala:24:20 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            decimal = remainder / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Reassignment to val decimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bits = (new\
    \ scala.collection.mutable.BitSet(decimal.asInstanceOf[Long])).bits\n        val\
    \ length = bits.count\n        val stringBuilder = new StringBuilder\n       \
    \ bits.foreach((bit: Boolean) => {\n            stringBuilder += if(bit) \"1\"\
    \ else \"0\"\n        })\n        stringBuilder.reverse\n\n        // Now create\
    \ the 'db' string\n        val extraCharacters = if(length < decimal.asInstanceOf[Long])\
    \ (length.toString.length + 2) else 0\n        stringBuilder ++= new Array[Char](extraCharacters)\n\
    \        val extraStringBuilder = new StringBuilder(stringBuilder.length)\n  \
    \      extraStringBuilder ++= \"db\"\n        extraStringBuilder.reverse\n\n \
    \       // Add the extra characters to the front and back of the string\n    \
    \    stringBuilder ++= extraStringBuilder.toString\n        stringBuilder.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzt3hddyq.scala:19:29 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            stringBuilder += \e[33mif\e[0m(bit) \e[31m\"\
    1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m             \
    \                ^^\e[0m\n\e[31m   |\e[0m                             expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpzt3hddyq.scala:15:24 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m = (\e[33mnew\e[0m scala.collection.mutable.BitSet(decimal.asInstanceOf[\e\
    [35mLong\e[0m])).bits\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mconstructor\e\
    [0m \e[35mBitSet\e[0m in \e[33mclass\e[0m \e[35mBitSet\e[0m with types\n\e[31m\
    \   |\e[0m (): scala.collection.mutable.BitSet\n\e[31m   |\e[0m (initSize: Int):\
    \ scala.collection.mutable.BitSet\n\e[31m   |\e[0m (elems: Array[Long]): scala.collection.mutable.BitSet\n\
    \e[31m   |\e[0mmatch arguments (Long)\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpzt3hddyq.scala:32:22 --------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \        stringBuilder.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ here\n        val powers = mutable.ArrayBuffer.fill(decimal.toInt/2).map(_*2)\n\
    \        val decimalDigits = (decimal.toInt-decimal.toInt%2).toInt\n        powers(decimalDigits).map(_+1)\n\
    \            .zip(powers.reverse)\n            .filter(_._2 < decimalDigits)\n\
    \            .map { case (power, decimalDigitsLeft) => decimalDigitsLeft.toChar\
    \ + power }\n            .reverse\n            .toList\n            .foldLeft(new\
    \ StringBuilder) { (builder, char) => builder += char }\n            .toString.stripPrefix(\"\
    db\")\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmlnuzp7_.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpowers\e[0m = mutable.ArrayBuffer.fill(decimal.toInt/\e\
    [31m2\e[0m).map(_*\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val arr = new\
    \ Array[Int](decimal.toInt + 2)\n        val maxLength = arr.length - 1\n    \
    \    val bits = decimal.toInt\n        var i = maxLength\n        while(i > 0)\
    \ {\n            val remainder = (bits % 2).toInt\n            arr(i) = remainder\n\
    \            bits /= 2\n            i -= 1\n        }\n        val decimalString\
    \ = arr.take(arr.length - 2).mkString(\"0\") +\n            arr.takeRight(arr.length\
    \ - 2).mkString(\"0\")\n        val bitString = decimalString.take(decimalString.length\
    \ - 1).mkString(\"0\")\n        val dbString = bitString + \"db\"\n        arr.last\n\
    \        dbString + decimalString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg7s9dk51.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            bits /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Int - did you mean bits.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var result =\
    \ \"\"\n        val powers = decimal.asInstanceOf[Long]\n        while(powers\
    \ > 0) {\n            val remainders = powers % 2\n            powers /= 2\n \
    \           if(remainders > 0) {\n                result = \"1\" + result\n  \
    \          }\n            else {\n                result = \"0\" + result\n  \
    \          }\n        }\n        result = \"db\" + result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplbrgl3w7.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            powers /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean powers.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmplbrgl3w7.scala:27:15 --------------------\e[0m\e[0m\n\e[31m27 |\e[0m\
    \        result = \e[31m\"db\"\e[0m + result\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val numberBits\
    \ = Long.bitCount(decimal).toInt\n        val result: List[String] = for {\n \
    \           divisor <- if (decimal == 0) 1 else 2\n        } yield {\n       \
    \     val bits = BigInt(decimal).bitCount() / divisor\n            BigInt(decimal).shiftLeft(bits\
    \ - 1).bits.toString.reverse\n        }.reverse\n\n        result.init.take(numberBits\
    \ + 1).mkString + result.reverse.take(numberBits + 1).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkptaqas7.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnumberBits\e[0m = Long.bitCount(decimal).toInt\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value bitCount is not a member of object Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpkptaqas7.scala:17:23 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            divisor <- \e[33mif\e[0m (decimal == \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         value map is not a member of (\e[31m1\e[0m : Int) | (\e[31m2\e[0m :\
    \ Int)\n2 errors found\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalStr\
    \ : String = decimal.toString\n        val binaryStr : StringBuilder = new StringBuilder(decimalStr.length)\n\
    \        decimalStr.charAt(0).toInt match {\n            case 0 => binaryStr.append(\"\
    1\")\n            case 1 => binaryStr.append(\"0\")\n            case _ => \n\
    \        }\n        while (decimalStr.length > 1) {\n            decimalStr.charAt(decimalStr.length\
    \ - 2).toInt match {\n                case 0 => binaryStr.append(\"1\")\n    \
    \            case 1 => binaryStr.append(\"0\")\n                case _ =>\n  \
    \          }\n        }\n        binaryStr.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8b2eve4j.scala:32)\n\tat Problem.main(tmp8b2eve4j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.asBinary.toInt\n        var binaryString = \"\"\n        while(binary\
    \ > 0) {\n            val result = math.pow(2,binary-1)\n            binaryString\
    \ = result + binaryString\n            binary = math.trunc(result).toLong\n  \
    \      }\n        if(binary.toInt == 0)\n            binaryString = (\"0\")\n\
    \        else\n            binaryString = (\"1\")\n        binaryString + \"db\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsbn0ob0k.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = decimal.asBinary.toInt\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     value asBinary is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsbn0ob0k.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            binary = math.trunc(result).toLong\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \          value trunc is not a member of math\n2 errors found\n"
  stdout: ''
  timestamp: 1660009597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ mutable.StringBuilder.newBuilder\n        binary.append(\"00000000\").\n   \
    \         append(decimalToBinary(decimal >>> 32)).\n            append(decimalToBinary(decimal\
    \ & 0XFFFFFFFF)).\n            reverse.\n            toString\n        binary.insert(binary.length\
    \ - 2, \"db\")\n        binary.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6kuggl0m.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = mutable.StringBuilder.newBuilder\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        var binary =\
    \ \"\"\n        var x = decimal\n        while (x > 0) {\n            binary =\
    \ if (x / 2 == 0) \"0\" + \"1\" + \"0\"\n            else (if (x % 2 == 0) \"\
    1\" + \"0\"\n            else \"\") + \"0\" + \"0\"\n            x = x / 2\n \
    \       }\n        binary += \"db\"\n        binary ++= decimal\n        return\
    \ binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiqixa03h.scala:24:15 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        binary ++= decimal\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value ++= is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val binary =\
    \ decimal.abs % 2 == 0\n        if (decimal > 1l){\n            val decimal2 =\
    \ decimal - decimal.toInt\n            binary = decimal2 % 2 == 0\n        }\n\
    \        if (decimal > 1l) {\n            decimalToBinary(decimal2)\n        }\n\
    \        val res = new collection.mutable.StringBuilder\n        if(binary){\n\
    \            res.append(\"1\")\n        }\n        else {\n            res.append(\"\
    0\")\n        }\n        res.append(res.length)\n        res.append(\"db\")\n\
    \        res\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmph2373ob0.scala:18:19 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            binary = decimal2 % \e[31m2\e[0m == \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Reassignment to val binary\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmph2373ob0.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            decimalToBinary(decimal2)\n\e[31m\e[31m \
    \  |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                  Not found: decimal2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmph2373ob0.scala:32:8 ---------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m        res\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (res : StringBuilder)\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      val bits = decimal.toBinaryString\n\
    \      if (bits.length < 32) {\n        bits.reverse.drop(32 - bits.length)\n\
    \      }\n      bits.reverse.foldLeft(\"\") { (a, c) => a + c}\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplao4f1pa.scala:22)\n\tat Problem.main(tmplao4f1pa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val digits =\
    \ decimal.toString.reverse.grouped(2).map(_.mkString)\n        val binaryString\
    \ = (digits take decimal.toString.length).zip(digits)\n        binaryString.map\
    \ {\n            case x => (x(0), x(1))\n        }.mkString(\"db\")\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: next on empty iterator\n\tat scala.collection.Iterator$$anon$19.next(Iterator.scala:966)\n\
    \tat scala.collection.Iterator$$anon$19.next(Iterator.scala:964)\n\tat scala.collection.StringOps$GroupedIterator.next(StringOps.scala:57)\n\
    \tat scala.collection.StringOps$GroupedIterator.next(StringOps.scala:53)\n\tat\
    \ scala.collection.Iterator$$anon$9.next(Iterator.scala:577)\n\tat scala.collection.Iterator$$anon$14.next(Iterator.scala:793)\n\
    \tat scala.collection.Iterator$$anon$14.next(Iterator.scala:789)\n\tat scala.collection.Iterator$$anon$9.next(Iterator.scala:577)\n\
    \tat scala.collection.IterableOnceOps.addString(IterableOnce.scala:1184)\n\tat\
    \ scala.collection.IterableOnceOps.addString$(IterableOnce.scala:1179)\n\tat scala.collection.AbstractIterator.addString(Iterator.scala:1293)\n\
    \tat scala.collection.IterableOnceOps.mkString(IterableOnce.scala:1129)\n\tat\
    \ scala.collection.IterableOnceOps.mkString$(IterableOnce.scala:1127)\n\tat scala.collection.AbstractIterator.mkString(Iterator.scala:1293)\n\
    \tat scala.collection.IterableOnceOps.mkString(IterableOnce.scala:1142)\n\tat\
    \ scala.collection.IterableOnceOps.mkString$(IterableOnce.scala:1142)\n\tat scala.collection.AbstractIterator.mkString(Iterator.scala:1293)\n\
    \tat Problem$.decimalToBinary(tmpe0ues0t1.scala:19)\n\tat Problem$.main(tmpe0ues0t1.scala:22)\n\
    \tat Problem.main(tmpe0ues0t1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extensio"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        if(decimal ==\
    \ 0) return \"0\"\n        if(decimal == 1) return \"1\"\n        var decimalToBinary\
    \ : Long = 0\n        for(i <- 0 until decimal.asInstanceOf[Long]) {\n       \
    \     decimalToBinary = decimalToBinary | (1l << i)\n        }\n        // now\
    \ we just need to append a bunch of '0' and '1's until we have a total of 64\n\
    \        var binaryString = \"0\";\n        while(decimalToBinary > 64) {\n  \
    \          binaryString += \"1\"\n            decimalToBinary -= 64\n        }\n\
    \        if(decimalToBinary == 0) return binaryString + \"0\"\n        if(decimalToBinary\
    \ == 1) return binaryString + \"1\"\n        binaryString += \"0\"\n        var\
    \ binaryIndex = 0\n        var decimalToBinaryShifted = decimalToBinary\n    \
    \    while(decimalToBinaryShifted != 0) {\n            binaryString += decimalToBinaryShifted\
    \ % 2 + \"0\"\n            decimalToBinaryShifted = decimalToBinaryShifted >>\
    \ 1\n            binaryIndex += 1\n            if(binaryIndex > 31) binaryIndex\
    \ = 0\n        }\n        binaryString += decimalToBinaryShifted % 2 + \"0\"\n\
    \        return binaryString + \"1\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphmwsav1x.scala:18:45\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m0\e[0m until decimal.asInstanceOf[\e[35mLong\e[0m]) {\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val bBits = decimal.bits.toList\n\
    \        val bLength = if (bBits.isEmpty) 0 else bBits.last\n        val bList\
    \ = new Array[Int](bLength + 1)\n        for (b <- 0 to bLength) {\n         \
    \   bList(b) = if (bBits.contains) 1 else 0\n        }\n        val finalList\
    \ = bList.drop(1).take(bList.length - 1).toString.reverse + \"db\" + bList.toString.reverse\n\
    \        return finalList\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbiarcvas.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = decimal.bits.toList\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value bits is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        // Your code\
    \ goes here.\n        val digits = scala.collection.mutable.ListBuffer(\"0\")\n\
    \        val remainder = decimal\n        val quotient = decimal\n        while\
    \ (quotient > 0)\n        {\n            digits += remainder % 2\n           \
    \ remainder = quotient / 2\n            quotient = quotient / 2\n        }\n \
    \       val finalDigits = scala.collection.mutable.ListBuffer(\"0\",\"1\")\n \
    \       digits.reverse.foreach(x => finalDigits += x)\n        finalDigits.append(decimal)\n\
    \        finalDigits.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2i2artpo.scala:21:22\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            digits += remainder\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m         \
    \             Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp2i2artpo.scala:22:22 -----------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            remainder = quotient / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val remainder\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2i2artpo.scala:23:21\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            quotient\
    \ = quotient / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val quotient\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp2i2artpo.scala:27:20 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        finalDigits.append(decimal)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e[0m\
    \ with types\n\e[31m   |\e[0m (elems: String*): (finalDigits : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0m (elem: String): (finalDigits : scala.collection.mutable.ListBuffer[String])\n\
    \e[31m   |\e[0mmatch arguments ((decimal : Long))\n4 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n      val bit = decimal.toBinaryString\n\
    \      val binaryNum = bit.dropRight(8).drop(8).map(_.toInt)\n      val firstBit\
    \ = bit.take(8)\n      val rest = bit.drop(8).take(8)\n      val result = binaryNum.zip(firstBit).take(rest.size).map\
    \ {\n        case (x, 0) => x + \"0\"\n        case (x, 1) => x + \"1\"\n    \
    \  }.mkString(\"\")\n      result + \"db\" + rest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp_d9qebe.scala:26)\n\tat Problem.main(tmpp_d9qebe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    // >>> decimalToBinary((15l))\n\
    \    // (\"db1111db\")\n    // >>> decimalToBinary((32l))\n    // (\"db100000db\"\
    )\n    def decimalToBinary(decimal : Long) : String = {\n        val decimalList\
    \ = DecimalBitVector(decimal).toList\n        val binaryList = decimalList.map(bv\
    \ => bv.toBinaryString).reverse\n        (0 until binaryList.size).map(i => binaryList(i)\
    \ match {\n            case \"\" => \"\"\n            case i => i\n        }).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboydz_ic.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalList\e[0m = DecimalBitVector(decimal).toList\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          Not found: DecimalBitVector\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009598
