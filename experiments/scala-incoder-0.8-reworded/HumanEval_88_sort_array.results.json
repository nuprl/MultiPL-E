{
  "language": "scala",
  "name": "HumanEval_88_sort_array",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer[Long]()\n        for ( i <- 0 until array.size ) {\n            newList += array(i)\n        }\n        if (newList.sum % 2 != 0) {\n            newList.sortBy(-_)\n        } else {\n            newList.sortBy(_)\n        }\n        return newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmm4qhl1_.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpmm4qhl1_.scala:26:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            newList.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => newList.sortBy(_$2).\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029364
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val res = new mutable.LinkedList[Long]()\n        val len = array.size\n        var i = 0\n        val res = []\n        while(i < len){\n            val min = i\n            val max = (i + len) - 1\n            var sum = 0\n            while(min < max){\n                sum = sum + array(min)\n                min = min + 1\n            }\n            if(sum % 2 == 0){\n                res.clear()\n                res.add(array(min))\n                res.add(array(max))\n                return res\n            }\n            else{\n                res.clear()\n                res.add(array(max))\n                res.add(array(min))\n                return res\n            }\n            i = min + 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp01fbejm6.scala:22:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = []\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp01fbejm6.scala:23:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mwhile\u001b[0m(i < len){\n\u001b[31m\u001b[31m   |\u001b[0m^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp01fbejm6.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.LinkedList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp01fbejm6.scala:28:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                sum = sum + array(min)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp01fbejm6.scala:29:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                min = min + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val min\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029367
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty)\n            array\n        else {\n            val firstValue = array.head\n            val lastValue = array.last\n            val sumFirst = firstValue + lastValue\n            if (sumFirst % 2L)\n                sortArray(array.dropRight(1)).++(array.dropLeft).++(sortArray(array.drop(1)))\n            else\n                sortArray(array.dropRight(1)).++(sortArray(array.drop(1)))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5bt460kz.scala:25:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (sumFirst % \u001b[31m2L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5bt460kz.scala:26:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                sortArray(array.dropRight(\u001b[31m1\u001b[0m)).++(array.dropLeft).++(sortArray(array.drop(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value dropLeft is not a member of List[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029367
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.length\n        if(n < 2) array\n        else if(n % 2 == 0) array.sort[Long]( _.toLong - _.toLong)\n        else array.sort[Long]( _.toLong - _.toLong).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg9s7cn87.scala:21:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(n % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) array.sort[Long]( _.toLong - _.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value sort is not a member of List[Long] - did you mean array.sortBy?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg9s7cn87.scala:22:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33melse\u001b[0m array.sort[Long]( _.toLong - _.toLong).reverse\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Your code here\n        if (array.isEmpty) array\n        val list = new mutable.ListBuffer[Long]()\n        var sum = 0L\n        var i = 0\n        while (i < array.size) {\n            sum += array(i)\n            i += 1\n        }\n        var j = 0\n        while (j < array.size) {\n            if (j == array.size) list += 0\n            if (sum % 2 != 0 && (j + 1) != array.size) list += array.get(j + 1)\n            j += 1\n        }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdyyto2zl.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpdyyto2zl.scala:20:27 ----------------\u001b[0m\u001b[0m\n\u001b[33m20 |\u001b[0m        \u001b[33mif\u001b[0m (array.isEmpty) array\n\u001b[33m\u001b[33m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029364
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var i = 0\n        var j = 1\n        var n = array.length\n        var sum = 0\n        var reverse = array.head % 2 == 0\n        var l = array.size\n\n        var result = new mutable.ArrayBuffer[Long]()\n        var temp = 0\n        array.foreach {\n            i =>\n                sum = array(i)\n                while (j < n) {\n                    sum = sum + array(j)\n                    j++\n                }\n                if (sum % 2 == 0) {\n                    temp = sum\n                    sum = 0\n                } else if (sum % 2 == 1) {\n                    temp = sum\n                    sum = temp\n                }\n                result.add((reverse ? temp : -temp).toLong)\n                i = i + 1\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpp8rl8qqp.scala:33:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    j++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp8rl8qqp.scala:42:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                result.add((reverse ? temp : \u001b[35m-temp\u001b[0m).toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but ')' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8rl8qqp.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp8rl8qqp.scala:30:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                sum = array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (i : Long)\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp8rl8qqp.scala:32:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    sum = sum + array(j)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Long\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpp8rl8qqp.scala:43:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                i = i + \u001b[31m1\u001b[0",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var i = 0\n        val len = array.length\n\n        if(len == 1)\n            array\n        else\n            while(i < len) {\n                if(array[i] + array[i+1] < array[i]) {\n                    val temp = array(i + 1)\n                    array(i + 1) = array(i)\n                    array(i) = temp\n                }\n                i += 1\n            }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_c9h6fw.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m(array[\u001b[35mi\u001b[0m] + array[\u001b[35mi+\u001b[31m1\u001b[0m] < array[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_c9h6fw.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    array(i + \u001b[31m1\u001b[0m) = array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_c9h6fw.scala:29:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    array(i) = temp\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val arrayList = mutable.ListBuffer.empty[Long]\n        array.foreach( x => arrayList += x )\n\n        val odd = arrayList.toSet\n        val even = arrayList.toSeq.reverse\n        val sorted = arrayList.toSeq.sortBy( x => x < odd )\n        val reverseSorted = arrayList.toSeq.reverse.sortBy( x => x < even )\n        if( (odd + even).length == sorted.length ) sorted ++ reverseSorted\n        else sorted ++ reverseSorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjnmkf3jo.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrayList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029363
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum = array.foldLeft(0l) { (sum: Long, num: Long) => sum + num }\n        val remain = sum % 2\n        val odd = sum.toInt / 2\n        if (remain == 1) array else array.sortBy(x => -x)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmph6ln47ei.scala:27)\n\tat Problem.main(tmph6ln47ei.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) {\n            return array\n        }\n        val sums = array.reduceLeft((a, b) => a + b).toLong\n        if (sums.isEven) {\n            array.sortWith((a, b) => a < b)\n        } else {\n            array.sortWith((a, b) => a > b)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_xlukbe1.scala:23:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (sums.isEven) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value isEven is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029367
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val ms = collection.mutable.ArrayBuffer.empty[Long]\n        val n = array.length\n        for (i <- 0 until n) {\n            ms += array(i)\n        }\n        val n = ms.size\n        val m0 = ms.head\n        val m1 = ms.last\n        var flag = m1.toLong\n        for (i <- 0 until n) {\n            ms.update(i + 1, array(i))\n            val m2 = ms.last\n            if (m0 > m2) {\n                flag = m0.toLong\n            }\n            if (m2 > flag) {\n                m0 = m2\n            }\n        }\n        if (m0.toLong % 2 == 0) {\n            ms.reverse\n        } else {\n            ms.reverse.tail\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2xma3984.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = ms.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp2xma3984.scala:35:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                m0 = m2\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val m0\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2xma3984.scala:39:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            ms.reverse\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    scala.collection.mutable.ArrayBuffer[Long]\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2xma3984.scala:41:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            ms.reverse.tail\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    scala.collection.mutable.ArrayBuffer[Long @uncheckedVariance]\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        array.foreach(x => sum += x)\n        if(sum % 2 == 1) array.sortedWith(_ > _) else array.sortedWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjf9gz7k2.scala:20:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        array.foreach(\u001b[36mx\u001b[0m => sum += x)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjf9gz7k2.scala:21:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m(sum % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) array.sortedWith(_ > _) \u001b[33melse\u001b[0m array.sortedWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sortedWith is not a member of List[Long] - did you mean array.sortWith?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjf9gz7k2.scala:21:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m(sum % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) array.sortedWith(_ > _) \u001b[33melse\u001b[0m array.sortedWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sortedWith is not a member of List[Long] - did you mean array.sortWith?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029369
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum = array.sum\n        val res = if (sum % 2 == 0) array.sorted.reverse\n        else array.sorted\n        res \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpka3_e49l.scala:28)\n\tat Problem.main(tmpka3_e49l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var i = 0\n        var j = 0\n        var temp = 0\n        var temp2 : List[Long] = new mutable.ArrayList[Long]()\n        val newArray = array.clone()\n        newArray.sort{ (a , b) => (a < b) } //sort ascending\n        for(i <- 0 until newArray.length ) {\n            for(j <- i + 1 until newArray.length) {\n                temp = newArray(j)\n                temp2 = newArray(i)\n                if (temp + temp2 % 2 == 0) {\n                    newArray(i) = temp + temp2 //swap if odd sum is found\n                    newArray(j) = temp2\n                }\n            }\n        }\n        newArray.sort{ (a , b) => (a > b) } //sort descending\n        return newArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6_zslslh.scala:22:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mtemp2\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6_zslslh.scala:23:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = array.clone()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (array : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6_zslslh.scala:29:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mif\u001b[0m (temp + temp2 % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val length = array.length\n        var flag : Boolean = false\n        val index = 0\n        var temp = 0\n        while(index < length){\n            temp = 0\n            while(index < length && flag == true){\n                temp = temp + array[index]\n                index++\n            }\n            if(temp % 2 == 0){\n                array.updated(index, array.last)\n                flag = false\n            }\n            else{\n                array.reverse()\n                array.updated(index, array.last)\n                flag = true\n            }\n        }\n        return array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpur_qbvzv.scala:27:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                index++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpur_qbvzv.scala:26:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                temp = temp + array[\u001b[35mindex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpur_qbvzv.scala:34:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                array.reverse()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029364
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val length = array.length\n        val temp = new Array[Long](length)\n        var sum = 0\n        var tempSum = 0\n        for(i <- 0 until length) {\n            sum += array(i)\n            tempSum = sum\n            for(j <- 0 until length) {\n                if(tempSum > array(i)) {\n                    tempSum -= array(j)\n                }\n            }\n            temp(i) = tempSum\n        }\n        temp.sortWith((x, y) => x - y)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0sbv9rw1.scala:24:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            sum += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0sbv9rw1.scala:28:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    tempSum -= array(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value -= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0sbv9rw1.scala:33:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        temp.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x - y)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumArray = array.foldLeft(0l) {\n            case (sum, value) => sum + value\n        }\n\n        var tempArray = array.sortWith(_ > _)\n        var sum = 0\n        var result = tempArray.toList\n\n        if(sumArray % 2L == 0) result = tempArray.reverse\n        \n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0l6vwl0c.scala:34)\n\tat Problem.main(tmp0l6vwl0c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029370
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sorted = array.sortWith(compareLong)\n        if(sorted.sum % 2 == 0) sorted else sorted.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl77qx_ht.scala:19:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msorted\u001b[0m = array.sortWith(compareLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: compareLong\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029364
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        def sum(i : Long, j : Long): Long = if (i == 0) 0 else i + j\n        def isEven(i : Long, j : Long): Boolean = (i != 0) && (j != 0) && i % 2 == 0 && j % 2 == 0\n\n        // sort list in descending order\n        val array2 = array.sortBy(i => i).reverse\n\n        val list = new mutable.ListBuffer[Long]()\n        var lastSum = 0\n        var lastIsEven = false\n        val evenList = array2.tail\n        val oddList = array2.head\n\n        for (i<-evenList) {\n            if (sum(i,lastSum) % 2 != 0) {\n                list += i\n            }\n            lastSum += i\n        }\n\n        for (i<-oddList) {\n            if (sum(i,lastSum) % 2 == 0) {\n                list += i\n            }\n            lastSum += i\n        }\n\n        list.sortBy(i => i)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp797kqw5x.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp797kqw5x.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            lastSum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp797kqw5x.scala:38:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mfor\u001b[0m (i<-oddList) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value foreach is not a member of Long\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newArray = array.toList\n        newArray.sortWith(compareLongList)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqmo62vrg.scala:20:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        newArray.sortWith(compareLongList)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: compareLongList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029363
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sums = array\n            .zip(array.tail)\n            .map { case (a,b) => (a,b) }\n            .groupBy(_._1).map(_._2.map(_._2)).toList\n            .sortWith(_._1 < _._1) // ascending order\n            .sortWith(_._1 > _._1) // descending order\n        sums.reverse.map(_._1).reduceLeft(_+_)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp02t0tugx.scala:23:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            .sortWith(_._1 < _._1) \u001b[34m// ascending order\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value _1 is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp02t0tugx.scala:24:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            .sortWith(_._1 > _._1) \u001b[34m// descending order\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value _1 is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp02t0tugx.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        sums.reverse.map(_._1).reduceLeft(_+_)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value _1 is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp02t0tugx.scala:25:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        sums.reverse.map(_._1).reduceLeft(_+_)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.size\n        val m = n / 2\n        var left = array\n        var right = array.drop(m).toList\n        var left = List[Long]()\n        var right = List[Long]()\n\n        val firstElement = left.head\n        var previousSum = 0\n        for (i <- 0 until n) {\n            if (i % 2 == 0) {\n                val sum = left(i) + right(i)\n                if (sum > previousSum) {\n                    left.add(i)\n                    right.add(i + 1)\n                } else {\n                    right.add(i)\n                    left.add(i + 1)\n                }\n            } else {\n                val sum = left(i) + right(i)\n                if (sum < previousSum) {\n                    left.add(i)\n                    right.add(i + 1)\n                } else {\n                    right.add(i)\n                    left.add(i + 1)\n                }\n            }\n            previousSum = sum\n        }\n        return left.reverse ++ right.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp00thoz9l.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleft\u001b[0m = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleft is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp00thoz9l.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mright\u001b[0m = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mright is already defined as \u001b[33mvariable\u001b[0m \u001b[35mright\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp00thoz9l.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    left.add(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value add is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp00thoz9l.scala:33:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    right.add(i + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue add is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp00thoz9l.scala:35:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    right.add(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1660029370
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var index = 0\n        var max = 0\n        var sum = 0\n        var list = array.tail.head\n        while(list != null) {\n            sum = sum +list\n            if(sum > max ) {\n                max = sum\n            }\n            index += 1\n            list = array.tail.lift(index).head\n        }\n        if(sum % 2 == 0) {\n            list = array.lift(max).reverse\n        } else {\n            list = array.lift(max)\n        }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpdmc7wk47.scala:23:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mwhile\u001b[0m(list != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Long and Null cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdmc7wk47.scala:24:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            sum = sum +list\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdmc7wk47.scala:32:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            list = array.lift(max).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value reverse is not a member of Option[Long]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdmc7wk47.scala:34:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            list = array.lift(max)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Option[Long]\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdmc7wk47.scala:36:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        list\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (list : Long)\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        require(array.nonEmpty)\n        val longArray = array.map(x => x.toLong).toList\n        longArray.sortWith((x, y) => x.toLong <=> y.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpri3t4lls.scala:21:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        longArray.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x.toLong <=> y.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value <=> is not a member of Long - did you mean Long.<=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029374
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) throw new IllegalArgumentException\n        val indexMap = mutable.Map[Long, Int]()\n        val newArray = mutable.ArrayBuffer.empty[Long]\n        var i = array.length - 1\n        while (i >= 0) {\n            val cur = array(i)\n            var index = indexMap.get(cur)\n            if (index == -1) {\n                index = newArray.length\n                newArray += cur\n                indexMap += cur -> index\n            } else {\n                val pre = newArray(index - 1)\n                if (cur > pre) newArray += cur\n            }\n            i -= 1\n        }\n        if (newArray.length % 2 != 0) {\n            newArray += newArray(newArray.length - 1)\n        }\n        newArray.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vrnl9rp.scala:20:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mindexMap\u001b[0m = mutable.Map[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vrnl9rp.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029373
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.size < 2)\n            return array\n        val sum : Long = array(0) + array(array.size - 1)\n        if(sum % 2 != 0)\n            array.reverse\n        else\n            array.sortWith((x : Long, y : Long) => if (x > y) 1 else -1)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6tjt0mb4.scala:25:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            array.sortWith((\u001b[36mx\u001b[0m : \u001b[35mLong\u001b[0m, \u001b[36my\u001b[0m : \u001b[35mLong\u001b[0m) => \u001b[33mif\u001b[0m (x > y) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                                     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6tjt0mb4.scala:25:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            array.sortWith((\u001b[36mx\u001b[0m : \u001b[35mLong\u001b[0m, \u001b[36my\u001b[0m : \u001b[35mLong\u001b[0m) => \u001b[33mif\u001b[0m (x > y) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                                    Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029376
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val numbers = array.toArray\n        var sum = 0\n        for ( i <- 0 until numbers.length ) {\n            sum = numbers(i) + sum\n        }\n        val odd = sum % 2 == 1\n        var index = odd.toLong\n        if (odd) {\n            while (odd.toLong < numbers.length - 1) {\n                val temp = numbers(index).toLong\n                numbers(index) = numbers(odd.toLong)\n                numbers(odd.toLong) = temp\n                odd = numbers(index) + numbers(odd.toLong)\n                index = odd.toLong\n            }\n        } else {\n            while (odd.toLong > 0) {\n                val temp = numbers(index).toLong\n                numbers(index) = numbers(odd.toLong)\n                numbers(odd.toLong) = temp\n                odd = numbers(index) - numbers(odd.toLong)\n                index = odd.toLong\n            }\n        }\n        numbers.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprf3bmw6y.scala:22:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum = numbers(i) + sum\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprf3bmw6y.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mindex\u001b[0m = odd.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of Boolean, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprf3bmw6y.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mwhile\u001b[0m (odd.toLong < numbers.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of Boolean, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprf3bmw6y.scala:29:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                numbers(index) = numbers(odd.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of Boolean, but could be made available as an extension method.\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660029381
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.isEmpty){\n            array\n        }else{\n            val firstSum = array.reduce(_ + _)\n            val secondSum = array.reduce(_ + _)\n            if(firstSum%2 == 0 && secondSum%2 == 1){\n                array.reverse\n            }else{\n                array.sortWith(_<_)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpi_6sb31u.scala:35)\n\tat Problem.main(tmpi_6sb31u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029379
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum : Long = 0\n        var list : List[Long] = List()\n        var i : Int = 1\n        while (i < array.size) {\n            sum += array(i)\n            i += 1\n        }\n        list = array.sortWith((x: Long, y: (Long, Long)) => {\n            val diff = x - y\n            if (diff % 2 == 0) {\n                diff + 1\n            } else {\n                diff - 1\n            }\n        }).toList\n        if (sum % 2 == 1) {\n            list.reverse\n        }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpp3ducz5u.scala:27:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = x - y\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((y : (Long, Long)))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029374
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        def sortArrayHelper(array : List[Long], left : Int, right : Int, sorted : List[Long]) : List[Long] = {\n            val mid = (left + right) / 2\n            val currentSum = sum(array[left], array[mid])\n            val newLeft = if (currentSum%2 == 0) mid else left\n            val newRight = if (currentSum%2 == 1) right else mid\n            val newArray = if (newLeft < newRight) sortArrayHelper(array, newLeft, newRight, sorted) else sortArrayHelper(array, newLeft, newRight, sorted).reverse\n\n            sorted :+ sum(newArray(0), newArray(newArray.size - 1))\n        }\n        sortArrayHelper(array, 0, array.size - 1, List.empty)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzxowoo67.scala:21:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurrentSum\u001b[0m = sum(array[\u001b[35mleft\u001b[0m], array[\u001b[35mmid\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzxowoo67.scala:21:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurrentSum\u001b[0m = sum(array[\u001b[35mleft\u001b[0m], array[\u001b[35mmid\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type left\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzxowoo67.scala:21:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurrentSum\u001b[0m = sum(array[\u001b[35mleft\u001b[0m], array[\u001b[35mmid\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: type mid\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzxowoo67.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            sorted :+ sum(newArray(\u001b[31m0\u001b[0m), newArray(newArray.size - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029375
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val coscala = new collection.mutable.ListBuffer[Long]()\n        for(i <- 0 until array.length)\n        {\n            val sum = array(i)\n            val first = i\n            val last = if (i != 0)\n                array(i-1)\n            else array(i)\n            if(sum%2==1)\n            {\n                coscala += last\n                coscala += first\n            }\n            else\n            {\n                coscala += first\n                coscala += last\n            }\n        }\n        coscala.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgssndils.scala:42)\n\tat Problem.main(tmpgssndils.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029381
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val size = array.size\n        var minPos = size - 1\n        var maxPos = 0\n\n        array.sort((a, b) => math.signum(math.min(a, b) - math.max(a, b)))\n\n        if (math.signum(sum(array.toList).asInstanceOf[Long]) % 2 == 0) {\n            array.sort((a, b) => math.signum(math.max(a, b) - math.min(a, b)))\n        } else {\n            array.sort((a, b) => math.signum(math.max(a, b) - math.min(a, b)))\n            array.sort((a, b) => math.signum(math.max(a, b) - math.min(a, b)))\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpujc8pb7c.scala:23:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        array.sort((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => math.signum(math.min(a, b) - math.max(a, b)))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value sort is not a member of List[Long] - did you mean array.sortBy?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujc8pb7c.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mif\u001b[0m (math.signum(sum(array.toList).asInstanceOf[\u001b[35mLong\u001b[0m]) % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpujc8pb7c.scala:26:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            array.sort((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => math.signum(math.max(a, b) - math.min(a, b)))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpujc8pb7c.scala:28:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            array.sort((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => math.signum(math.max(a, b) - math.min(a, b)))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpujc8pb7",
      "stdout": "",
      "timestamp": 1660029380
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val pairs = array.zipWithIndex\n        val reversedPairs = pairs.sortBy(_._1).reverse\n        reversedPairs.flatMap(_._2).map(pairs => {\n            val first = (pairs._1 + pairs._2)\n            val second = (first + 1) % 2\n            if(first > second){\n                pairs._1\n            } else {\n                pairs._2\n            }\n        }).distinct\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdlsuie7i.scala:21:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        reversedPairs.flatMap(_._2).map(\u001b[36mpairs\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Int\n\u001b[31m   |\u001b[0m                              Required: IterableOnce[Any]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdlsuie7i.scala:22:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfirst\u001b[0m = (pairs._1 + pairs._2)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value _1 is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdlsuie7i.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                pairs._1\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue _1 is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import concurrent.duration.durationToPair\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdlsuie7i.scala:27:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                pairs._2\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue _2 is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import concurrent.duration.durationToPair\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029381
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array == null || array.isEmpty) {\n            return array\n        } else {\n            var lastIndex = array.length - 1\n            var sum = 0\n            var i = 0\n            var j = 0\n            var index = -1\n            var tempArray = array\n            while (i < array.length) {\n                sum = sum + (tempArray(i)) + tempArray(lastIndex)\n                if (sum % 2 == 1) {\n                    index = i\n                    lastIndex = i - 1\n                } else {\n                    index = lastIndex\n                    lastIndex = i\n                }\n                tempArray = tempArray(index)\n                i = index + 1\n                j = lastIndex\n                sum = 0\n            }\n            return tempArray\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpohq5vg00.scala:29:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                sum = sum + (tempArray(i)) + tempArray(lastIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpohq5vg00.scala:37:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                tempArray = tempArray(index)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029379
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n      require(array.nonEmpty, \"The given array is empty!\")\n      var sum = 0L\n      array.foreach{\n        x =>\n          sum = sum + x\n      }\n      if (sum % 2 == 1)\n        array.sortBy(l => -l)\n      else\n        array.sortBy(l => -l).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IllegalArgumentException: requirement failed: The given array is empty!\n\tat scala.Predef$.require(Predef.scala:337)\n\tat Problem$.sortArray(tmpkh__bwrg.scala:19)\n\tat Problem$.main(tmpkh__bwrg.scala:31)\n\tat Problem.main(tmpkh__bwrg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029382
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) List(0L)\n        else {\n            val l1 = array.head\n            val l2 = array.last\n            val sum = l1 + l2\n            if (sum.toIntIsEven > sum.toIntIsOdd) array.sortBy(x => -x)\n            else array.sortBy(x => x)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzhlik_fd.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (sum.toIntIsEven > sum.toIntIsOdd) array.sortBy(\u001b[36mx\u001b[0m => -x)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value toIntIsEven is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029379
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var tempArray = array.map(x=>{\n            if(x%2==1){\n                return -1\n            }else{\n                return x\n            }\n        }).toList\n        tempArray = tempArray.sortWith((x,y)=>{\n            if(x%2==1){\n                return true\n            }else{\n                return false\n            }\n        }).toList\n        val res = tempArray.toList\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5abts7dp.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33mreturn\u001b[0m -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5abts7dp.scala:23:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mreturn\u001b[0m x\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (x : Long)\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5abts7dp.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m(x%\u001b[31m2\u001b[0m==\u001b[31m1\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m               ^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5abts7dp.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (\u001b[31mtrue\u001b[0m : Boolean)\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n",
      "stdout": "",
      "timestamp": 1660029382
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val list = array.sortBy(_ * -1)\n        if (list.head % 2 == 1)\n            list.reverse\n        else\n            list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.sortArray(tmpnvt745hq.scala:20)\n\tat Problem$.main(tmpnvt745hq.scala:26)\n\tat Problem.main(tmpnvt745hq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029381
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val size = array.length\n        var i = 0\n        var j = 0\n        var sum = 0\n\n        while(i < size) {\n            sum = sum + array[i]\n            i += 1\n        }\n\n        var big = 0\n        var little = 0\n\n        if(sum % 2 == 0) {\n            big = sum - 1\n            little = sum\n        } else {\n            big = sum + 1\n            little = sum - 1\n        }\n\n        val leftArray = new mutable.ArrayBuilder[Long]\n        val rightArray = new mutable.ArrayBuilder[Long]\n\n        i = j = 0\n        while(i < size) {\n            val smaller = if (big > little) {\n                val temp = big\n                big = little\n                little = temp\n            }\n            val biggerOrEqual = if (big > biggerOrEqual) {\n                big\n            } else {\n                biggerOrEqual\n            }\n            val smallerOrEqual = if (little > smallerOrEqual) {\n                little\n            } else {\n                smallerOrEqual\n            }\n            val left = biggerOrEqual\n            val right = smallerOrEqual\n\n            leftArray.+= left\n            rightArray.+= right\n            i += 1\n        }\n\n        leftArray.result().toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwhyvo74b.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            sum = sum + array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwhyvo74b.scala:40:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleftArray\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuilder[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwhyvo74b.scala:41:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrightArray\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuilder[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwhyvo74b.scala:43:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        i = j = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwhyvo74b.scala:50:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbiggerOrEqual\u001b[0m = \u001b[33mif\u001b[0m (big > biggerOrEqual) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Recursive \u001b[33mvalue\u001b[0m \u001b[35mbiggerOrEqual\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwhyvo74b.scala:53:16 -----",
      "stdout": "",
      "timestamp": 1660029381
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) List(array.head.toLong)\n        else array.sortWith(_.isOdd < _.isOdd) match {\n            case true => List(array.head.toLong)\n            case _ => sortArray(array.drop(1).reverse).reverse.take(array.length).reverse.toList + array.last\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp36roz_gv.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m array.sortWith(_.isOdd < _.isOdd) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value isOdd is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36roz_gv.scala:21:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31mtrue\u001b[0m => List(array.head.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31mtrue\u001b[0m : Boolean)\n\u001b[31m   |\u001b[0m                 Required: List[Long]\n\u001b[31m   |\u001b[0m                 pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp36roz_gv.scala:22:97 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mcase\u001b[0m _ => sortArray(array.drop(\u001b[31m1\u001b[0m).reverse).reverse.take(array.length).reverse.toList + array.last\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029382
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newArray = mutable.ArrayBuffer.empty[Long]\n        for ( i <- 0 until array.length-1 ) {\n            newArray += array(i)\n        }\n        newArray.sortWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9oymywhm.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029377
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val list = array.sortBy(_)\n        // if sum of first and last element is odd then sort in descending order\n        if ((list(0) % 2) == 1) {\n            list.sortWith(_ < _)\n        }\n        else {\n            list.sortWith(_ > _)\n        }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpwp6ogp8j.scala:19:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = array.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mNo implicit Ordering defined for Any..\n\u001b[31m   |\u001b[0mI found:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    scala.math.Ordering.comparatorToOrdering[\u001b[35mAny\u001b[0m](\n\u001b[31m   |\u001b[0m      /* missing */summon[java.util.Comparator[Any]]\n\u001b[31m   |\u001b[0m    )\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mBut no implicit values were found that match type java.util.Comparator[Any].\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwp6ogp8j.scala:21:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m ((list(\u001b[31m0\u001b[0m) % \u001b[31m2\u001b[0m) == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    (\u001b[31m0\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                  Required: Long => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029383
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        def maxSum(startIndex : Long, endIndex : Long) : Long = {\n            def maxSum1(startIndex : Long, endIndex : Long, sum : Long, maxSum : Long) : Long = {\n                if (startIndex > endIndex) sum\n                else if (sum % 2 == 0) maxSum1(startIndex + 1, endIndex, sum + array[startIndex], sum)\n                else maxSum1(startIndex + 1, endIndex, sum - array[startIndex], sum)\n            }\n            maxSum1(startIndex, endIndex, sum, 0l)\n        }\n        def maxSum1(startIndex : Long, endIndex : Long, sum : Long, maxSum : Long) : List[Long] = {\n            if (startIndex > endIndex) List(sum)\n            else {\n                val temp = sum - array[startIndex]\n                if (temp % 2 == 0) maxSum1(startIndex + 1, endIndex, temp, maxSum)\n                else maxSum1(startIndex + 1, endIndex, temp, maxSum - array[startIndex])\n            }\n        }\n        var maxSum = 0l\n        for(i <- 0 until array.size) {\n            if (array(i) > 0) maxSum = maxSum + array(i)\n        }\n        if (maxSum % 2 == 1) maxSum1(array.size, array.size, maxSum, 0l)\n        else maxSum1(array.size, array.size, maxSum - array[array.size - 1], 0l)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps0kd31yx.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxSum\u001b[0m = \u001b[31m0l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxSum is already defined as \u001b[33mmethod\u001b[0m \u001b[35mmaxSum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps0kd31yx.scala:22:85 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) maxSum1(startIndex + \u001b[31m1\u001b[0m, endIndex, sum + array[startIndex], sum)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type startIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps0kd31yx.scala:23:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33melse\u001b[0m maxSum1(startIndex + \u001b[31m1\u001b[0m, endIndex, sum - array[startIndex], sum)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type startIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps0kd31yx.scala:25:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            maxSum1(startIndex, endIndex, sum, \u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps0kd31yx.scala:30:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mtemp\u001b[0m = sum - array[\u001b[35mstartIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m",
      "stdout": "",
      "timestamp": 1660029383
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val size = array.size\n        val start = 0\n        val end = size - 1\n        val sortedList = mutable.Buffer[Long]()\n        var maxSum = Long.MinValue\n        var minSum = Long.MaxValue\n        var minSumIndex = -1\n        var maxSumIndex = -1\n        for (i <- 0 until size) {\n            var sum = array(i).toLong + array(i + 1).toLong\n            if (sum > maxSum) {\n                maxSum = sum\n                maxSumIndex = i\n            } else if (sum < minSum) {\n                minSum = sum\n                minSumIndex = i\n            }\n        }\n        if (maxSumIndex == -1) {\n            return array\n        }\n        val curMaxSum = array[maxSumIndex]\n        for (i <- 0 until size) {\n            var sum = array(i).toLong + array(i + 1).toLong\n            if (sum == curMaxSum) {\n                sortedList += array(i)\n            } else if (sum > curMaxSum) {\n                sortedList += array(i)\n            } else if (sum < curMaxSum) {\n                sortedList += array(i + 1)\n            }\n        }\n        val result = sortedList.sortBy(x => x).reverse.toList\n        if (maxSumIndex != 0) {\n            val sum = (array[maxSumIndex].toLong + array[maxSumIndex - 1].toLong).toLong\n            if (sum % 2 == 1) {\n                result.insert(result.size - 1, maxSum.toLong)\n            } else {\n                result.remove(result.size - 1)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppu9exy_l.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msortedList\u001b[0m = mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppu9exy_l.scala:40:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcurMaxSum\u001b[0m = array[\u001b[35mmaxSumIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type maxSumIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppu9exy_l.scala:53:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = (array[\u001b[35mmaxSumIndex\u001b[0m].toLong + array[\u001b[35mmaxSumIndex\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m].toLong).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type maxSumIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029377
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Your code goes here\n        if (array.isEmpty) {\n            (List[Long]())\n        } else {\n            var sum = 0\n            var temp : List[Long] = array.filter(v => sum != v).map(x => temp.append(x))\n            val newArray = temp.toList\n            if (array.sum % 2 != 0) {\n                newArray.sortWith(_ < _)\n            } else {\n                newArray.sortWith(_ > _)\n            }\n            newArray\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3i53b0cp.scala:24:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mtemp\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = array.filter(\u001b[36mv\u001b[0m => sum != v).map(\u001b[36mx\u001b[0m => temp.append(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029382
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val m = array.head\n        val n = array.last\n        val sum = array.sum\n        val evenOrOdd = (sum % 2 == 0) match {\n            case true => true\n            case false => false\n        }\n        val list = array.sortBy( x => x )\n        if(evenOrOdd && n > m) list.sortBy( x => -x )\n        else list.sortBy( x => x )\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.sortArray(tmp7sn0ffzx.scala:19)\n\tat Problem$.main(tmp7sn0ffzx.scala:31)\n\tat Problem.main(tmp7sn0ffzx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029384
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val length = array.length\n        // sort ascending\n        val start = 0\n        val end = length - 1\n        var i = start\n        var j = 0\n        var k = end\n\n        while(i < k) {\n            while(j < end) {\n                if (array(i) < array(j)) {\n                    val tmp = array(i)\n                    array(i) = array(j)\n                    array(j) = tmp\n                    j += 1\n                } else {\n                    val tmp = array(j)\n                    array(j) = array(i)\n                    array(i) = tmp\n                    i += 1\n                }\n            }\n            i -= 1\n            j += 1\n        }\n        // sort descending\n        start = end\n        end = length - 1\n        i = start\n        j = end\n\n        while(i < k) {\n            while(j > 0) {\n                if (array(i) > array(j)) {\n                    val tmp = array(i)\n                    array(i) = array(j)\n                    array(j) = tmp\n                    j -= 1\n                } else {\n                    val tmp = array(j)\n                    array(j) = array(i)\n                    array(i) = tmp\n                    i -= 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvoxbfvf5.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    array(i) = array(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvoxbfvf5.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    array(j) = tmp\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvoxbfvf5.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    array(j) = array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvoxbfvf5.scala:37:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    array(i) = tmp\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpvoxbfvf5.scala:45:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        start = end\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val start\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpvoxbfvf5.scala:46:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        end = length - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val end\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvoxbfvf5.scala:54:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m                    array(i) = array(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.up",
      "stdout": "",
      "timestamp": 1660029387
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val size = array.size\n        var index = 0\n        while (index < size) {\n            val left = 0\n            var right: Int = size - 1\n            while (left < right) {\n                val mid = left + math.ceil(math.abs(right - left) / 2)\n                if (mid == index) break\n                if (mid < index) left = mid\n                else right = mid\n            }\n            if (left < right)\n                array.swap(index, left)\n            else\n                array.swap(index, right)\n            index += 1\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfa5o2cgk.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (mid == index) break\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfa5o2cgk.scala:27:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mif\u001b[0m (mid < index) left = mid\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    (mid : Double)\n\u001b[31m   |\u001b[0m                                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfa5o2cgk.scala:28:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33melse\u001b[0m right = mid\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (mid : Double)\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfa5o2cgk.scala:31:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                array.swap(index, left)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value swap is not a member of List[Long] - did you mean array.map?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfa5o2cgk.scala:33:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                array.swap(index, right)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value swap is not a member of List[Long] - did you mean array.map?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029388
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0;\n        var odd = 0;\n        var even = 0;\n        for (i<- array){\n            sum = sum + i\n            if (sum %2 == 1){\n                even = even + 1\n            } else {\n                odd = odd + 1\n            }\n        }\n\n        val newList = array.toList\n        if (odd > 0){\n            newList.sortBy(x => x)\n        }\n        if (even == 0){\n            newList.sortBy(x => -x)\n        }\n        return newList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgi4upvt0.scala:23:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            sum = sum + i\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029386
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val len = array.size\n        val sum = (array(0) + array(len-1)).asInstanceOf[Long]\n        if(sum % 2 == 0) array.sortBy(-_) else array.sortBy(-_)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.sortArray(tmp01hyq0go.scala:20)\n\tat Problem$.main(tmp01hyq0go.scala:24)\n\tat Problem.main(tmp01hyq0go.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029389
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.foldLeft(List[Long]()) { (list, num) =>\n            list :+ num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5fhz4rnr.scala:26)\n\tat Problem.main(tmp5fhz4rnr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029390
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0L\n        val l = array.size\n        for(i <- 0 until l)\n        {\n            sum += array(i)\n        }\n        if(sum.mod(2).toInt == 1)\n        {\n            array.sortWith(a => a.compareTo(b) < 0)\n        }\n        else\n        {\n            array.sortWith(a => a.compareTo(b) > 0)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmsah2xoi.scala:25:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mif\u001b[0m(sum.mod(\u001b[31m2\u001b[0m).toInt == \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpmsah2xoi.scala:27:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            array.sortWith(\u001b[36ma\u001b[0m => a.compareTo(b) < \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpmsah2xoi.scala:31:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            array.sortWith(\u001b[36ma\u001b[0m => a.compareTo(b) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Wrong number of parameters, expected: 2\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029390
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var result = array\n        var resultSize = array.length\n        var sum = 0\n        var index = 0\n        var sumIndex = 0\n        while (index<resultSize) {\n            sum += result(index)\n            sumIndex += 1\n            if (sumIndex>=(resultSize-1)) sumIndex=0\n            index += 1\n        }\n        if (sum%2 ==1) {\n            result.sortBy(x=>x)\n        }\n        else result.sortBy(x=>-x)\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpencad9wb.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            sum += result(index)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpencad9wb.scala:33:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33melse\u001b[0m result.sortBy(x=>-x)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpencad9wb.scala:33:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33melse\u001b[0m result.sortBy(x=>-x)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mDeprecatedDoubleOrdering\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029389
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val numList = mutable.ListBuffer.empty[Long]\n        for (x<-array){\n            val y = x\n            val z = x + y\n            if (z % 2 != 0) {numList += z}\n        }\n        numList.sortBy(x => x)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkni2vha1.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029386
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newArray = array.clone\n        newArray.sortWith(_.sum % 2 === 0l)(Ordering.Int.reverse)\n        newArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpaan173sa.scala:19:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = array.clone\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (array : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029389
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sorted = array.sorted\n        if(sorted.last % 2 == 0) {\n            sorted.reverse\n        }\n        sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.sortArray(tmp0vkpvujs.scala:20)\n\tat Problem$.main(tmp0vkpvujs.scala:26)\n\tat Problem.main(tmp0vkpvujs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val length = array.length\n        var sum = 0\n        var count = 0\n        var result = List[Long]()\n        for (i <- 0 until length) {\n            sum += i\n            count += 1\n            if (sum % 2 == 0) {\n                result += array(i)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw3ff3dkg.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029392
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val list = new ListBuffer[Long]()\n        val sum = 0\n        for (i <- 0 to array.size -1) {\n            sum += array(i)\n            list.add(sum)\n        }\n        return list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5u0v1dt1.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5u0v1dt1.scala:23:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            list.add(sum)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue add is not a member of scala.collection.mutable.ListBuffer[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.buffer AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.buffer AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.mutableSeq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.mutableSeq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029393
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val pairs = array.zipWithIndex.sortBy(_._1).map(_._2)\n        (pairs zip array).toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphuuh9ymk.scala:20:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        (pairs zip array).toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0mLong\u001b[1m\u001b[31m)\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029392
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // your code here\n        val array = array.sort\n        if(array.isEmpty) throw new Exception(\"Empty array\")\n        var tempsum = 0\n        while(tempsum != array.length){\n            if(tempsum%2 == 1) array.swap(tempsum, 1)\n            else array.swap(tempsum, 0)\n            tempsum++\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpo7a86bpb.scala:26:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            tempsum++\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpo7a86bpb.scala:20:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marray\u001b[0m = array.sort\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35marray\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029389
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val res = new scala.collection.mutable.ArrayList\n        array.foreach(x => res.addLast(x))\n        val n = res.size\n        // even: sort by value\n        val sorted = res.sortBy(x => (x % 2 == 0))\n        if (sorted.size % 2 == 0) {\n            // odd\n            // res: List[Long], sorted: List[Long]\n            sorted.reverse\n        } else {\n            // even\n            // res: List[Long], sorted: List[Long]\n            sorted\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyneatm28.scala:19:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m scala.collection.mutable.ArrayList\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              type ArrayList is not a member of scala.collection.mutable\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029392
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) array\n        var left = 0\n        var right = array.length - 1\n        var curSum = 0\n\n        // calculate sum\n        while (left <= right) {\n            curSum += if(left < right) array[left] else array[right]\n            left += 1\n            right -= 1\n        }\n\n        // sort array\n        if(curSum % 2 != 0) {\n            array.sortWith(compare(array))\n        }\n        else {\n            array.sortWith(compareDesc(array))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0ei0podz.scala:26:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            curSum += \u001b[33mif\u001b[0m(left < right) array[left] \u001b[33melse\u001b[0m array[right]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^\u001b[0m\n\u001b[31m   |\u001b[0m                      expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ei0podz.scala:26:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            curSum += \u001b[33mif\u001b[0m(left < right) array[left] \u001b[33melse\u001b[0m array[right]\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ei0podz.scala:33:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            array.sortWith(compare(array))\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: compare\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ei0podz.scala:36:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            array.sortWith(compareDesc(array))\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: compareDesc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmp0ei0podz.scala:19:27 ----------------\u001b[0m\u001b[0m\n\u001b[33m19 |\u001b[0m        \u001b[33mif\u001b[0m (array.isEmpty) array\n\u001b[33m\u001b[33m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029392
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith((a,b) => math.abs(a-b) < math.abs(a) + math.abs(b))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm01k7p62.scala:24)\n\tat Problem.main(tmpm01k7p62.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029394
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var res = Array[Long]()\n        var len = array.size\n        var sum = 0\n\n        while (len > 0) {\n            sum = sum + array(len - 1)\n            len = len - 1\n        }\n        if (sum % 2 == 0) {\n            res = array.sortWith(x => (x.toLong, x.toLong))\n        } else {\n            res = array.sortWith(x => (x.toLong, x.toLong)).reverse\n        }\n\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmtydvnaz.scala:24:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            sum = sum + array(len - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpmtydvnaz.scala:28:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            res = array.sortWith(\u001b[36mx\u001b[0m => (x.toLong, x.toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpmtydvnaz.scala:30:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            res = array.sortWith(\u001b[36mx\u001b[0m => (x.toLong, x.toLong)).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmtydvnaz.scala:33:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mreturn\u001b[0m res\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (res : Array[Long])\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029394
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith((a, b) => a < b).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0pk0ai8z.scala:25)\n\tat Problem.main(tmp0pk0ai8z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029395
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.size < 1) return array\n        val m = array.size\n        var minSum = array.head\n        var tempSum = array.head\n        val resultList = mutable.ListBuffer[Long]()\n        var j = 0\n        for (i <- 1 to m) {\n            tempSum = tempSum + array(i).toLong\n            if (tempSum < minSum) {\n                minSum = tempSum\n            }\n            resultList += array(i)\n        }\n        if (minSum.% 2 == 1) {\n            resultList += array.last\n        } else {\n            resultList += array.last\n            resultList += array.head\n        }\n        resultList.sort\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr1trfd1u.scala:32:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (minSum.% \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr1trfd1u.scala:23:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpr1trfd1u.scala:32:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (minSum.% \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m%\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch expected type Boolean\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029391
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val len = array.length\n        val sumLst = array.scanLeft(0l)(_ + _)\n        // println(s\"$sumLst is $sumLst.sum\")\n        if(sumLst.sum % 2L == 0){\n            array.sorted\n        }\n        else{\n            array.sorted(reverseOrder = true)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp56k_3se3.scala:26:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            array.sorted(reverseOrder = \u001b[31mtrue\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35msorted\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mStrictOptimizedSeqOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): List[Long] does not have a parameter reverseOrder\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029391
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.size\n        val even = array.filter(_ % 2 == 0)\n        val odd = array.filter(_ % 2 == 1)\n        val sum = even.sum + odd.sum\n        (if (sum % 2 == 0) odd else even).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1heduqm9.scala:27)\n\tat Problem.main(tmp1heduqm9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029398
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var total = 0\n        var sorted = array.filter(x => x > 0l).map(x => total = total + x)\n        val odd = total % 2\n        if(odd == 1) {\n            sorted.reverse()\n        }\n        sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_q9q_pa9.scala:20:64 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msorted\u001b[0m = array.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0l\u001b[0m).map(\u001b[36mx\u001b[0m => total = total + x)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_q9q_pa9.scala:23:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            sorted.reverse()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Unit\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_q9q_pa9.scala:25:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        sorted\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (sorted : List[Unit])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029396
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var list : List[Long] = array\n        val s = list.head\n        var i = 0\n        while (i < list.length) {\n            val x = list(i)\n            val y = list(i + 1)\n            val sum = x + y\n            if (sum.isEven) {\n                list.update(i + 1, y)\n            }\n            else {\n                list.update(i + 1, x)\n            }\n            i = i + 2\n        }\n        list.head\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprowm4mp5.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (sum.isEven) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isEven is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprowm4mp5.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                list.update(i + \u001b[31m1\u001b[0m, y)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprowm4mp5.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                list.update(i + \u001b[31m1\u001b[0m, x)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprowm4mp5.scala:34:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        list.head\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Long\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029399
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.size <= 0) array :+ 0\n        else {\n            val sortedArray = array.sorted\n            if (sortedArray._1 + sortedArray._2 % 2 == 1)\n                sortedArray\n            else\n                sortedArray.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ad2_abc.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (sortedArray._1 + sortedArray._2 % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value _1 is not a member of List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029397
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumArray : Array[Long] = array.toArray.foldLeft(new Array[Long](array.length)) {\n            case (a: Array[Long], x) => a + x\n            case a: Array[Long] =>\n                val sum = 0\n                a.foreach { x =>\n                    sum += x\n                }\n                sum\n        }\n        var counter = 0\n        var i = 0\n        var j = 1\n        var k = 0\n        val sumArraySize = sumArray.length\n        while (i < sumArraySize && j < sumArraySize) {\n            if (sumArray(i) > sumArray(j)) {\n                swap(array, i, j)\n                counter += 1\n                i += 1\n                j += 1\n            } else if (sumArray(i) < sumArray(j)) {\n                swap(array, i, j)\n                counter += 1\n                i += 1\n            } else {\n                i += 1\n                j += 1\n            }\n        }\n        if (counter % 2 != 0) {\n            swap(array, i, j)\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1bmw75ja.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m (a: Array[Long], x) => a + x\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1bmw75ja.scala:24:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    sum += x\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1bmw75ja.scala:26:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                sum\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    (sum : Int)\n\u001b[31m   |\u001b[0m                Required: Array[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1bmw75ja.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                swap(array, i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: swap\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1bmw75ja.scala:40:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                swap(array, i, j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: swap\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1bmw75ja.scala:49:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1660029401
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var coscala: List[Long] = List()\n        for (i <- 0 until array.length) {\n            sum += i\n            coscala ::= array(i)\n        }\n        array.sortWith(x => (x.compareTo(sum) % 2 == 0) ? 1 : -1)\n        coscala\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpzk2y2aoc.scala:25:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        array.sortWith(\u001b[36mx\u001b[0m => (x.compareTo(sum) % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) ? \u001b[31m1\u001b[0m : -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029396
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith(compare(array))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt_hej_f_.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        array.sortWith(compare(array))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: compare\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029396
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val arrayCopy = array.clone\n        var sum = 0\n        var i = 1\n        var temp = 0\n        var last = 0\n        while(i < arrayCopy.size) {\n            sum = sum + arrayCopy(i)\n            i = i + 1\n        }\n        val isEven = (sum % 2) == 0\n        arrayCopy.sortWith(compare(array, last))\n        if(isEven) {\n            arrayCopy.reverse\n        } else {\n            arrayCopy\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmphqkqf2x0.scala:19:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrayCopy\u001b[0m = array.clone\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (array : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029398
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        require(array.nonEmpty)\n        val mid = array.size / 2\n        array.drop(mid).sortWith(_ > _).take(mid)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IllegalArgumentException: requirement failed\n\tat scala.Predef$.require(Predef.scala:324)\n\tat Problem$.sortArray(tmpbocpz8p2.scala:19)\n\tat Problem$.main(tmpbocpz8p2.scala:24)\n\tat Problem.main(tmpbocpz8p2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029402
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.length\n        val buffer = new ListBuffer[Long]()\n        var j = 0\n        var i = 0\n        var sum = 0\n        while (i < n) {\n            buffer += array(j)\n            j += 1\n        }\n        val result = new ListBuffer[Long]()\n        val mid = buffer.size / 2\n        buffer -= buffer.subList(0, mid)\n        val left = buffer.subList(mid, buffer.size)\n        var sumLeft = 0\n        val midRight = buffer.size / 2\n        buffer += buffer.subList(0, midRight)\n        val right = buffer.subList(midRight, buffer.size)\n        var sumRight = 0\n        val midLeft = buffer.size / 2\n        buffer += buffer.subList(0, midLeft)\n        val left = buffer.subList(midLeft, buffer.size)\n        var sumLeft = 0\n        val midRight = buffer.size / 2\n        buffer += buffer.subList(0, midRight)\n        val right = buffer.subList(midRight, buffer.size)\n        var sumRight = 0\n        while (i < n) {\n            val left = array(j)\n            j += 1\n            val right = array(j)\n            j += 1\n            sumLeft = sumLeft + left\n            sumRight = sumRight + right\n            if (sumLeft % 2 == 0) {\n                result += (left.toLong)\n            }\n            else {\n                result += (right.toLong)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpkdfg18.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleft\u001b[0m = buffer.subList(midLeft, buffer.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpkdfg18.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msumLeft\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0msumLeft is already defined as \u001b[33mvariable\u001b[0m \u001b[35msumLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpkdfg18.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmidRight\u001b[0m = buffer.size / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmidRight is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmidRight\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpkdfg18.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = buffer.subList(midRight, buffer.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mright is already defined as \u001b[33mvalue\u001b[0m \u001b[35mright\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpkdfg18.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msumRight\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0msumRight is already defined as \u001b[33mvariable\u001b[0m \u001b[35msumRight\u001b[0m\n\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660029404
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        def odd(array: List[Long]) : List[Long] = {\n            var sum = 0l\n            for(i <- 0 until array.length){\n                sum = sum + i.toLong\n                if(sum %2 ==0){\n                    return array\n                }\n            }\n        }\n        def even(array: List[Long]) : List[Long] = {\n            var sum = 0l\n            for(i <- 0 until array.length){\n                sum = sum + i.toLong\n                if(sum%2==0){\n                    return array\n                }\n            }\n        }\n        if(array.head % 2 ==0){\n            return odd(array)\n        }else{\n            return even(array)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpignwq_sb.scala:21:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until array.length){\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m22 |\u001b[0m                sum = sum + i.toLong\n\u001b[31m23 |\u001b[0m                \u001b[33mif\u001b[0m(sum %\u001b[31m2\u001b[0m ==\u001b[31m0\u001b[0m){\n\u001b[31m24 |\u001b[0m                    \u001b[33mreturn\u001b[0m array\n\u001b[31m25 |\u001b[0m                }\n\u001b[31m26 |\u001b[0m            }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpignwq_sb.scala:30:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until array.length){\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m31 |\u001b[0m                sum = sum + i.toLong\n\u001b[31m32 |\u001b[0m                \u001b[33mif\u001b[0m(sum%\u001b[31m2\u001b[0m==\u001b[31m0\u001b[0m){\n\u001b[31m33 |\u001b[0m                    \u001b[33mreturn\u001b[0m array\n\u001b[31m34 |\u001b[0m                }\n\u001b[31m35 |\u001b[0m            }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029402
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) {\n            array\n        } else {\n            // get the first index value and last index value\n            val (firstIndex, lastIndex) = array\n            // if the sum of the first index value, the last index value are odd\n            // then sort the array in ascending order\n            val sum = firstIndex + lastIndex\n            if (sum.signum & 1) {\n                array.sortBy(_ < _)\n            } else {\n                array.sortBy(_ > _)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprrg3uxwz.scala:26:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = firstIndex + lastIndex\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmprrg3uxwz.scala:28:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                array.sortBy(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- Error: /tmp/tmprrg3uxwz.scala:28:35 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                array.sortBy(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mShort\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmprrg3uxwz.scala:30:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                array.sortBy(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- Error: /tmp/tmprrg3uxwz.scala:30:35 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                array.sortBy(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and",
      "stdout": "",
      "timestamp": 1660029403
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) throw new Exception(\"Invalid input\")\n        var sum : Long = 0\n        var lastValue : Long = array.last\n        var firstValue : Long = array.head\n        var newArray = Array[Long](array.size)\n        newArray(0) = firstValue\n        newArray(1) = lastValue\n        for (i<-1 to array.size - 1){\n            sum = sum + array(i)\n            if (sum % 2 == 0){\n                sum-=lastValue\n            }\n            else{\n                sum+=firstValue\n            }\n            newArray(i+1) = sum\n        }\n        return newArray.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.Exception: Invalid input\n\tat Problem$.sortArray(tmphhlm9pmo.scala:19)\n\tat Problem$.main(tmphhlm9pmo.scala:39)\n\tat Problem.main(tmphhlm9pmo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029405
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty)\n            return array\n        val len = array.size\n        val odd = len % 2 == 0\n        var left = odd, right = len / 2\n        while (left != right) {\n            // find left index and right index\n            var left_index = left\n            var right_index = right\n            // left index and right index is odd\n            if (odd) {\n                // if left index is odd, use left index as right index\n                while (left_index != 0) {\n                    val temp = array[left_index]\n                    array[left_index] = array[right_index]\n                    array[right_index] = temp\n                    left_index -= 1\n                    right_index += 1\n                }\n                left += 1\n                // if left index is odd, use right index as right index\n                while (right_index < len - 1) {\n                    val temp = array[right_index]\n                    array[right_index] = array[left_index]\n                    array[left_index] = temp\n                    right_index += 1\n                    left_index -= 1\n                }\n            } else {\n                // if left index is odd, use right index as right index\n                while (right_index < len - 1) {\n                    val temp = array[right_index]\n                    array[right_index] = array[left_index]\n                    array[left_index] = temp\n                    right_index += 1\n                    left_index -= 1\n                }\n                right -= 1\n                // if left index is odd, use left index as right index\n                while (left_index != 0) {\n                    val temp = array[left_index]\n                    array[left_index] = array[right_index]\n                    array[right_index] = temp\n                    left_index -= 1\n                    right_index += 1\n                }\n                left -= 1\n            }\n        }\n        array.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:23:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleft\u001b[0m = odd, right = len / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      end of statement expected but ',' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:33:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    array[\u001b[35mleft_index\u001b[0m] = array[right_index]\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:34:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    array[\u001b[35mright_index\u001b[0m] = temp\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:42:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    array[\u001b[35mright_index\u001b[0m] = array[left_index]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:43:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    array[\u001b[35mleft_index\u001b[0m] = temp\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:51:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                    array[\u001b[35mright_index\u001b[0m] = array[left_index]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmphk0u3yz_.scala:52:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m                    ",
      "stdout": "",
      "timestamp": 1660029405
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val array = array.toList\n        val arrayLength = array.size\n        val firstIndex = 0\n        val lastIndex = arrayLength - 1\n        val firstValue = array.getOrElse(firstIndex, 0)\n        val lastValue = array.getOrElse(lastIndex, 0)\n        val sumOfFirstIndexAndLastIndex = firstValue + lastValue\n        val sumOfFirstIndexAndLastIndexOdd = sumOfFirstIndexAndLastIndex % 2\n        val sumOfFirstIndexAndLastIndexEven = sumOfFirstIndexAndLastIndex - sumOfFirstIndexAndLastIndexOdd\n        val newArray = if (sumOfFirstIndexAndLastIndexOdd == 0) array.toList else array.toList.sortDescending\n        newArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8fr7a9j3.scala:19:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marray\u001b[0m = array.toList\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35marray\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029398
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val length = array.length\n        var min = 0\n        var max = length - 1\n        var sum = 0\n        var i = -1\n        var j = -1\n\n        // sort in ascending order\n        while (min < max) {\n            i += 1\n            j += 1\n            sum = 0\n            while (i >= 0 && j < length) {\n                sum += array(i)\n                i -= 1\n                j += 1\n            }\n            while (i >= 0) {\n                sum -= array[i]\n                i -= 1\n            }\n            while (j >= 0) {\n                sum += array[j]\n                j -= 1\n            }\n            if (sum > 0) {\n                array.insert(i, array.pop(j))\n            } else {\n                array.remove(i)\n            }\n        }\n        return array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpktsd51xu.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                sum += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpktsd51xu.scala:37:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                sum -= array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpktsd51xu.scala:37:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                sum -= array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpktsd51xu.scala:41:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                sum += array[\u001b[35mj\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpktsd51xu.scala:41:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                sum += array[\u001b[35mj\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpktsd51xu.scala:45:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                array.insert(i, array.pop(j))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value insert is not a member of List[Long] - did you mean array.init?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpktsd51xu.scala:45:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                array.insert(i, array.pop(j))\n\u001b[31m\u001b[31m   |\u001b[0m                                ",
      "stdout": "",
      "timestamp": 1660029405
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val list = array.sorted\n        if(list.length > 0){\n            val sum = (list(0).asInstanceOf[Long] + list(list.size - 1).asInstanceOf[Long]).toLong\n            if(sum % 2 == 1){\n                list.sortBy(_.asInstanceOf[Long])\n            }\n            else{\n                list.sortBy(_.asInstanceOf[Long])\n            }\n        }\n        else{\n            list.sortBy(_.asInstanceOf[Long])\n        }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphfgtqxr2.scala:38)\n\tat Problem.main(tmphfgtqxr2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029405
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // sort array in ascending order if the sum( first index value, last index value) is odd,\n        // or sort it in descending order if the sum( first index value, last index value) is even.\n        val length = array.length\n        val sum = array.head + array.last\n        if(sum.%2 == 1L) array.sortBy(identity)\n        else array.sortBy(-identity)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5dxddsic.scala:23:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m(sum.%\u001b[31m2\u001b[0m == \u001b[31m1L\u001b[0m) array.sortBy(identity)\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5dxddsic.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33melse\u001b[0m array.sortBy(-identity)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue unary_- is not a member of Any => Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- Error: /tmp/tmp5dxddsic.scala:24:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33melse\u001b[0m array.sortBy(-identity)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029405
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sorted = array.sorted\n        if(sorted.sum % 2 == 0) {\n            sorted.reverse\n        }\n        else {\n            sorted\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpy4baj5ft.scala:31)\n\tat Problem.main(tmpy4baj5ft.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029407
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Your code here\n        var sum = 0\n        var result = new mutable.ListBuffer[Long]()\n        for(i<- array.indices) {\n            sum += array(i)\n        }\n        if(sum % 2 == 0) {\n            result ++= array.sortWith((x,y)=>x-y)\n        } else {\n            result ++= array.sortWith((x,y)=>x-y).reverse\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8w1afkt2.scala:21:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8w1afkt2.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            sum += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029404
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val result = array.foldLeft[List[Long]](Nil) { (list, item) =>\n            val sum = list.getOrElse(0l.toLong) + item\n            val cur = if (sum % 2l.toLong == 1l.toLong) -item else item\n            list :+ cur\n        }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6czxt3d.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = list.getOrElse(\u001b[31m0l\u001b[0m.toLong) + item\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value getOrElse is not a member of List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029405
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.size\n        val c = Array.ofDim[Int](2)\n        val sumArray = array.tail.foldLeft(0l, 0l) {\n            case ((a, l), i) => l + i\n        }\n        if ((sumArray.toInt % 2).isOdd) {\n            array.sortBy( _ + _ )\n        }\n        else {\n            array.sortBy( _ - _ )\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10nb4rht.scala:22:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mcase\u001b[0m ((a, l), i) => l + i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp10nb4rht.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m ((sumArray.toInt % \u001b[31m2\u001b[0m).isOdd) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of (Long, Long), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp10nb4rht.scala:25:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            array.sortBy( _ + _ )\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- Error: /tmp/tmp10nb4rht.scala:25:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            array.sortBy( _ + _ )\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp10nb4rht.scala:28:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            array.sortBy( _ - _ )\n\u001b[31m\u001b[31m   |\u001b[0m                    ",
      "stdout": "",
      "timestamp": 1660029408
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val nums    = array.map (x => new TreeMap (x, x)).sortWith((x,y)=> x._2 < y._2)\n        var max = 0\n        for (e <- nums)\n            max = Math.max(e.key, max)\n        var result = 0\n        for (e <- nums) {\n            if ((result == 0) || (max != 0 && (max % 2 == 0))) {\n                result += (e.key)\n                max = Math.max(max, e.key)\n            } else {\n                result -= (e.key)\n                max = Math.max(max, e.key)\n            }\n        }\n        result.map (x => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpra_v14bp.scala:19:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m    = array.map (\u001b[36mx\u001b[0m => \u001b[33mnew\u001b[0m \u001b[35mTreeMap\u001b[0m (x, x)).sortWith((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m)=> x._2 < y._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mtoo many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mTreeMap\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mTreeMap\u001b[0m: ()(\u001b[33mimplicit \u001b[0mord: Ordering[K]): scala.collection.mutable.TreeMap[K, V]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpra_v14bp.scala:19:77 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m    = array.map (\u001b[36mx\u001b[0m => \u001b[33mnew\u001b[0m \u001b[35mTreeMap\u001b[0m (x, x)).sortWith((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m)=> x._2 < y._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value _2 is not a member of scala.collection.mutable.TreeMap[Any, Any]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpra_v14bp.scala:22:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            max = Math.max(e.key, max)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue key is not a member of scala.collection.mutable.TreeMap[Any, Any] - did you mean e.keys?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpra_v14bp.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result += (e.key)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpra_v14bp.scala:26:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result += (e.key)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue key is not a member of scala.collection.mutable.TreeMap[Any, Any] - did you mean e.keys?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpra_v14bp.scala:27:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                max = Math.max(max, e.key)\n\u001b[31m\u001b[31m   |",
      "stdout": "",
      "timestamp": 1660029409
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val arrayTemp = array.toList.sortWith(\n            (o1: Long, o2: Long) => o1 < o2 || (o1 == o2 && o1 < o2)\n        )\n        val firstIndex = arrayTemp(0)\n        val lastIndex  = arrayTemp(array.length - 1)\n        val newArray  = Array.ofDim[Long](array.length)\n        var i = 0\n        var j = 1\n        while (i < array.length && j < arrayTemp.length) {\n            val sum1 = (array(i) + arrayTemp(i)).toLong\n            val sum2 = (arrayTemp(j) + arrayTemp(j + 1)).toLong\n            val sum  = sum1 + sum2\n            if (sum % 2 != 0) {\n                newArray(j) = arrayTemp(j)\n                j += 1\n            } else {\n                newArray(i) = array(i)\n                i += 1\n            }\n        }\n        val newList: mutable.Buffer[Long] = mutable.Buffer()\n        newList ++= arrayTemp.slice(i.toInt, j.toInt)\n        newList ++= arrayTemp.slice(i.toInt, arrayTemp.length)\n        newList ++= arrayTemp.slice(0, i.toInt)\n        newList ++= arrayTemp.slice(arrayTemp.length - 1, arrayTemp.length)\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxo6mv3rp.scala:39:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = mutable.Buffer()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxo6mv3rp.scala:39:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = mutable.Buffer()\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029406
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.length <= 1) {\n            array\n        } else {\n            // find first index that sum even\n            val evenSumIndex = array.foldLeft(0)(_ + _)\n            val evenSum = array(evenSumIndex)\n            val oddSumIndex = array.foldRight(array.length)(_ + _)\n            val oddSum = array(oddSumIndex)\n            if(evenSum.isOdd && oddSum.isEven) {\n                sortArray(array.take(evenSumIndex)).sortWith(compareOddEven)\n            } else if(evenSum.isOdd && oddSum.isOdd) {\n                sortArray(array.take(evenSumIndex)).sortWith(compareOddEvenDescending)\n            } else if(evenSum.isEven && oddSum.isEven) {\n                sortArray(array.drop(evenSumIndex)).sortWith(compareOddEvenDescending)\n            } else if(evenSum.isEven && oddSum.isOdd) {\n                sortArray(array.drop(evenSumIndex)).sortWith(compareOddEven)\n            } else {\n                array\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqwgnhzpv.scala:23:49 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mevenSumIndex\u001b[0m = array.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    Long\n\u001b[31m   |\u001b[0m                                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqwgnhzpv.scala:25:60 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36moddSumIndex\u001b[0m = array.foldRight(array.length)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqwgnhzpv.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m(evenSum.isOdd && oddSum.isEven) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value isOdd is not a member of Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqwgnhzpv.scala:28:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                sortArray(array.take(evenSumIndex)).sortWith(compareOddEven)\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: compareOddEven\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqwgnhzpv.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(evenSum.isOdd && oddSum.isOdd) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[",
      "stdout": "",
      "timestamp": 1660029410
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var coscalaArray = array.clone()\n        val coscalaArraySize = coscalaArray.size\n        coscalaArraySize -= 1\n        // if the sum of list first index value is odd, the coscala will be sorted ascending, otherwise descending\n        if(coscalaArraySize % 2 != 0) {\n            coscalaArray.reverse()\n        }\n        coscalaArray.sortWith(x => x.sum)\n        coscalaArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp41erqmmw.scala:19:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcoscalaArray\u001b[0m = array.clone()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (array : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029406
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.size\n        val sumArray = array.map(x => x + x.toLong).sum\n        if (sumArray.toDouble % 2 == 1) {\n            array.sortBy(x => x)\n        } else {\n            array.sortBy(x => -x)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpled9f26c.scala:30)\n\tat Problem.main(tmpled9f26c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029411
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var newArray = array\n        newArray.sortWith(compareDesc)\n        newArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1v2zo0l1.scala:20:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        newArray.sortWith(compareDesc)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: compareDesc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029406
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val array = array.sortWith(compare)\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5f7q7j3z.scala:19:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marray\u001b[0m = array.sortWith(compare)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35marray\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029406
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newList = array.sortWith( _.compare(_.sum) < 0 )\n        if (newList.length % 2 == 0) newList.sortWith( _.compare(_.sum) <= 0) else newList.sortWith( _.compare(_.sum) >= 0 )\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpcpj5qkre.scala:19:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = array.sortWith( _.compare(_.sum) < \u001b[31m0\u001b[0m )\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpcpj5qkre.scala:20:55 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (newList.length % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) newList.sortWith( _.compare(_.sum) <= \u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m newList.sortWith( _.compare(_.sum) >= \u001b[31m0\u001b[0m )\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpcpj5qkre.scala:20:101 --------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (newList.length % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) newList.sortWith( _.compare(_.sum) <= \u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m newList.sortWith( _.compare(_.sum) >= \u001b[31m0\u001b[0m )\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                     ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029407
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val listSize = array.size\n        val listSum = array\n            .foldLeft(0l) { (result, current) => result += current}\n            .asInstanceOf[Long]\n        val listSumOdd = listSum.toString.toInt\n        val listSumEven = listSum.asInstanceOf[Long] % 2\n        if(listSumOdd > 0) list.sortBy(_._1).reverse else list.sortBy(_._1).sortBy(_._1).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6aqz1iu8.scala:21:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            .foldLeft(\u001b[31m0l\u001b[0m) { (result, current) => result += current}\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of Long - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6aqz1iu8.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mif\u001b[0m(listSumOdd > \u001b[31m0\u001b[0m) list.sortBy(_._1).reverse \u001b[33melse\u001b[0m list.sortBy(_._1).sortBy(_._1).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: list\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6aqz1iu8.scala:25:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mif\u001b[0m(listSumOdd > \u001b[31m0\u001b[0m) list.sortBy(_._1).reverse \u001b[33melse\u001b[0m list.sortBy(_._1).sortBy(_._1).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                         Not found: list\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029409
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newList = ListBuffer[Long]()\n        val arraySum = array.reduceLeft(_+_)\n        newList += array(0)\n        var j = 1\n        var i = array.size-1\n        while (j<=i){\n            val mid = math.floor((i+j)/2)\n            newList += array(i+mid)\n            newList += array(j+mid)\n            i = mid\n            j = mid+1\n        }\n        val evenSum = array.reduceLeft(_+_)\n        newList += arraySum\n        if (evenSum%2 == 1) {\n            newList.sortInPlace()\n        } else {\n            newList.sortWith(_ < _)\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpimzkswnw.scala:26:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            newList += array(i+mid)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Double\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpimzkswnw.scala:27:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            newList += array(j+mid)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Double\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpimzkswnw.scala:28:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            i = mid\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    (mid : Double)\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpimzkswnw.scala:29:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            j = mid+\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Double\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpimzkswnw.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            newList.sortInPlace()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sortInPlace is not a member of scala.collection.mutable.ListBuffer[Long]\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029414
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.isEmpty) array\n        else {\n            val sum = (array(0).asInstanceOf[Long]+array.last).asInstanceOf[Long]\n            val evenOrOdd = if(sum.mod(2) == 0) \"even\" else \"odd\"\n            if(evenOrOdd == \"odd\") sortArray(array.drop(1))(array.take(array.length - 1).sortBy(_))\n            else sortArray(array.drop(1))(array.take(array.length - 1).sortBy(_.reverse))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3ddyx51c.scala:22:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mevenOrOdd\u001b[0m = \u001b[33mif\u001b[0m(sum.mod(\u001b[31m2\u001b[0m) == \u001b[31m0\u001b[0m) \u001b[31m\"even\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"odd\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3ddyx51c.scala:23:98 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m(evenOrOdd == \u001b[31m\"odd\"\u001b[0m) sortArray(array.drop(\u001b[31m1\u001b[0m))(array.take(array.length - \u001b[31m1\u001b[0m).sortBy(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mNo implicit Ordering defined for Any..\n\u001b[31m   |\u001b[0mI found:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    scala.math.Ordering.ordered[\u001b[35mAny\u001b[0m](\n\u001b[31m   |\u001b[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\u001b[31m   |\u001b[0m    )\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3ddyx51c.scala:24:80 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33melse\u001b[0m sortArray(array.drop(\u001b[31m1\u001b[0m))(array.take(array.length - \u001b[31m1\u001b[0m).sortBy(_.reverse))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value reverse is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3ddyx51c.scala:24:88 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33melse\u001b[0m sortArray(array.drop(\u001b[31m1\u001b[0m))(array.take(array.length - \u001b[31m1\u001b[0m).sortBy(_.reverse))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                        ^",
      "stdout": "",
      "timestamp": 1660029416
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.size\n        val arr = mutable.ArrayBuffer.empty[Long](n).asInstanceOf[Array[Long]]\n        for (i <- 0 until n) {\n            arr(i) = (math.max(array(i), array(n - 1 - i)))\n        }\n        arr.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1h5oanll.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m](n).asInstanceOf[\u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029411
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val result = array.foldLeft((List[Long](), List[Long]()))((x, y) => x._1 ::: y._1 ::: (x._2 ++ y._2))\n        if (result._2.sum % 2 == 1) {\n            result._2.sort\n        } else {\n            result._2.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmljr3jsd.scala:19:105 -----------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = array.foldLeft((List[\u001b[35mLong\u001b[0m](), List[\u001b[35mLong\u001b[0m]()))((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x._1 ::: y._1 ::: (x._2 ++ y._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmljr3jsd.scala:19:87 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = array.foldLeft((List[\u001b[35mLong\u001b[0m](), List[\u001b[35mLong\u001b[0m]()))((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x._1 ::: y._1 ::: (x._2 ++ y._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmljr3jsd.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result._2.sort\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029416
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.isEmpty) throw new Exception(\"empty list can not be sorted\")\n        var sum = 0\n        var sumOdd : Long = 0\n        var sumEven: Long = 0\n        for(i <- 0 until array.size) {\n            sum = sum + array(i)\n            if(sum.equals(0l)) {\n                sumEven = sumEven\n                sumOdd = sumOdd\n            }\n            else if(sum.mod(2l.toLong).equals(0l)) {\n                sumEven = sumEven + array(i)\n            }\n            else {\n                sumOdd = sumOdd + array(i)\n            }\n        }\n        val sortedArray = List(sumEven.toLong, sumOdd.toLong)\n        sortedArray.sortBy(identity)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxg_pexf4.scala:24:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            sum = sum + array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxg_pexf4.scala:29:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(sum.mod(\u001b[31m2l\u001b[0m.toLong).equals(\u001b[31m0l\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.int2bigInt\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029416
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum = array.sum\n        if(sum % 2 == 0) array.sortBy(_.toLong)\n        else if(sum % 2 == 1) array.sortBy(-_.toLong)\n        else array.sortBy(-_.toLong).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpves9hyyz.scala:27)\n\tat Problem.main(tmpves9hyyz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029418
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val list = new mutable.ListBuffer[Long]\n        for (i <- 0 until array.size) {\n            val num = array(i)\n            if (num < 0) return\n            val first = i\n            val last = array.size - 1\n            val sum = first + last\n            val odd = (sum.toDouble % 1) == 0\n            if (odd) {\n                list += num\n                list += array.drop(i + 1)\n            }\n            else {\n                list += array.drop(i + 1)\n                list += num\n            }\n        }\n        list.sortBy(_.toLong).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6nf0h1cl.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6nf0h1cl.scala:22:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Unit\n\u001b[31m   |\u001b[0m                         Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029416
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val array = array.asInstanceOf[List[Long]]\n        val array2 = array.toBuffer.sorted\n        var sum = 0\n        array2.foreach{ n => sum = sum + n }\n        if (sum % 2 == 0) {\n            array2\n        } else {\n            array2.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmprcqt2i38.scala:19:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marray\u001b[0m = array.asInstanceOf[\u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35marray\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029412
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var i = array.size\n        val sum = Math.abs(array.head) + Math.abs(array.last)\n        var max = 1\n        var temp = 0l\n        var temp2: Long = 0l\n        while (i > 0) {\n            val tmp = array.head\n            if (tmp > temp)\n                temp = tmp\n            val temp2 = array.last\n            if (temp2 > temp) {\n                temp = temp2\n                max = Math.max(max, temp)\n            }\n            i -= 1\n        }\n        if (max % 2 != 0) {\n            array.sortBy(x => x.toLong)\n            array.reverse\n        } else {\n            array.sortBy(x => x.toLong).reverse\n        }\n        return array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp801ac754.scala:31:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                max = Math.max(max, temp)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (temp : Long)\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029417
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        def subSortArray(array : List[Long]) : List[Long] = {\n            val length = array.length\n            var sum = 0L\n            val arr2 = new mutable.MutableList[Long]()\n            for (i <- 0 until length) sum += array(i)\n            if (sum % 2 == 0) arr2.addAll(0, array.take(length-1).sorted)\n            else arr2.addAll(array.take(length-1).reverse.sorted)\n            arr2.toList\n        }\n        if (array.length == 1) array(0)\n        else subSortArray(array)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fh90otl.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr2\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_fh90otl.scala:28:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m (array.length == \u001b[31m1\u001b[0m) array(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Long\n\u001b[31m   |\u001b[0m                               Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029417
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var max = 0\n        array.foreach(x => max = math.max(max, x))\n        array.foreach(x => sum += x)\n        if(sum.isOdd && sum < max) array.sort\n        else if(!sum.isOdd && sum > max) array.sortDescending\n        else array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp81w016ya.scala:21:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        array.foreach(\u001b[36mx\u001b[0m => max = math.max(max, x))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81w016ya.scala:22:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        array.foreach(\u001b[36mx\u001b[0m => sum += x)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81w016ya.scala:23:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m(sum.isOdd && sum < max) array.sort\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value isOdd is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81w016ya.scala:23:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m(sum.isOdd && sum < max) array.sort\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81w016ya.scala:24:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(!sum.isOdd && sum > max) array.sortDescending\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value isOdd is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81w016ya.scala:24:47 --------------",
      "stdout": "",
      "timestamp": 1660029418
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val a = array.map(x => x.toLong)\n        val b = a.zipWithIndex.sortBy(x => (x._1, x._2))\n        val c = b.map(x => x._1._2 + x._1._1)\n        val d = c.filter(x => x % 2 != 0)\n        val e = d.map(x => x % 2 == 0)\n        e.map(_.getOrElse(false) match {\n            case true => a.sortWith(_ < _)\n            case false => a.sortWith(_ > _)\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8tw5t_ac.scala:21:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mc\u001b[0m = b.map(\u001b[36mx\u001b[0m => x._1._2 + x._1._1)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8tw5t_ac.scala:22:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = c.filter(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8tw5t_ac.scala:23:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36me\u001b[0m = d.map(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31",
      "stdout": "",
      "timestamp": 1660029419
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val result = new mutable.ArrayList[Long]()\n        var firstIndex = 0\n        var lastIndex = 0\n        var sum = 0\n        while (firstIndex < array.length) {\n            if (sum % 2 == 1) {\n                lastIndex = firstIndex + 1\n            } else {\n                lastIndex = array.length - 1\n            }\n            sum = array[firstIndex] + array[lastIndex]\n            result.add(sum)\n            firstIndex += 1\n            lastIndex -= 1\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpysfyf1cw.scala:19:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpysfyf1cw.scala:29:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            sum = array[\u001b[35mfirstIndex\u001b[0m] + array[\u001b[35mlastIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type firstIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029414
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumArray = array.foldLeft(0l)( (a,b) => a + b )\n        sumArray % 2 match {\n            case 0 => array.sorted\n            case 1 => array.sorted reverse\n            case _ => array.sorted reverse reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmprdhsq4ud.scala:22:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m1\u001b[0m => array.sorted reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          expression expected but \u001b[31mend of statement\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprdhsq4ud.scala:23:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mcase\u001b[0m _ => array.sorted reverse reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: reverse\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029414
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n      array.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx4wx0cim.scala:25)\n\tat Problem.main(tmpx4wx0cim.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val list = new mutable.ListBuffer[Long]()\n        array.foreach { i =>\n            list.+=(i)\n        }\n        list.sortBy(a => a)(Ordering.Int.reverse)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvol_n7d.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029415
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) \n            array\n        else\n            if (array.length == 1) \n                array\n            else\n                if (sumFirstLastElement(array.length) == 1)\n                    sortDescendingArray(array)\n                else\n                    sortAscendingArray(array)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa7_4gtnf.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mif\u001b[0m (sumFirstLastElement(array.length) == \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: sumFirstLastElement\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa7_4gtnf.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    sortDescendingArray(array)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: sortDescendingArray\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa7_4gtnf.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    sortAscendingArray(array)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: sortAscendingArray\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029415
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sortedArray = array.sortBy(a => (a - array(0)))\n        if (sortedArray.sum % 2 == 0)\n            sortedArray.reverse\n        else\n            sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmonh3bmz.scala:29)\n\tat Problem.main(tmpmonh3bmz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var result = scala.collection.mutable.ArrayBuffer.empty[Long]\n        var currentSum = 0l\n        for(i <- 0 until array.size) {\n            currentSum += array(i)\n            if((i > 0) && (currentSum % 2 == 1)) {\n                result ::= array(i)\n            } else {\n                result ::= array(i)\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpob40xqnb.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result ::= array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of scala.collection.mutable.ArrayBuffer[Long] - did you mean scala.collection.mutable.ArrayBuffer[Long].++=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpob40xqnb.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result ::= array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ::= is not a member of scala.collection.mutable.ArrayBuffer[Long] - did you mean scala.collection.mutable.ArrayBuffer[Long].++=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029419
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith((x, y) => math.abs(x - y) < math.abs(x + y))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4_6rio61.scala:24)\n\tat Problem.main(tmp4_6rio61.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029422
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Write your code in here.\n        val result = array.sort((x, y) => if(x + y == 0) 0 else (x+y));\n        if(array.length % 2 == 0) result.sort((x, y) => if(x + y == 0) -1 else (x+y))\n        else result.sort((x, y) => if(x + y == 0) 1 else (x+y))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsykoagyy.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = array.sort((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => \u001b[33mif\u001b[0m(x + y == \u001b[31m0\u001b[0m) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m (x+y));\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value sort is not a member of List[Long] - did you mean array.sortBy?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.nonEmpty) {\n            val sum = array.sum\n            val index = (sum + 1) / 2\n            val left = array.drop(index)\n            val right = array(index)\n            val middle = array\n            val result = left ++ middle ++ right\n            result.sort\n        }\n        else {\n            array\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk92409ol.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleft\u001b[0m = array.drop(index)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk92409ol.scala:23:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = array(index)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (index : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk92409ol.scala:25:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = left ++ middle ++ right\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (right : Long)\n\u001b[31m   |\u001b[0m                                           Required: IterableOnce[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk92409ol.scala:26:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result.sort\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029422
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmporld33pq.scala:25)\n\tat Problem.main(tmporld33pq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660028982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.length\n        var sum = 0\n        var min = 0\n        var max = n - 1\n        array.foreach{\n            x =>\n                sum += x\n            if(sum % 2 == 0)\n                min += x\n            else\n                max -= x\n        }\n        if(min < max)\n            array.sortWith(_ < _)\n        else\n            array.sortWith(_ > _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2s5yvhj0.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                sum += x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2s5yvhj0.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                min += x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2s5yvhj0.scala:29:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                max -= x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -= is not a member of Int - did you mean Int.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var index = 0\n        val sortedArray = array.sortBy(x => x)\n        while (index < sortedArray.size) {\n            val lastItem = sortedArray(index)\n            var leftSum = 0\n            while (index < sortedArray.size && sortedArray(index) < lastItem) {\n                leftSum += sortedArray(index) + 1\n                index += 1\n            }\n            var rightSum = 0\n            while (index < sortedArray.size && sortedArray(index) > lastItem) {\n                rightSum += sortedArray(index) - 1\n                index += 1\n            }\n            if (leftSum % 2 != rightSum % 2) {\n                sortedArray.swap(index, sortedArray.size - 1)\n            }\n        }\n        sortedArray.reverse()\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ur_b4jr.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                leftSum += sortedArray(index) + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ur_b4jr.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                rightSum += sortedArray(index) - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ur_b4jr.scala:34:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                sortedArray.swap(index, sortedArray.size - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue swap is not a member of List[Long] - did you mean sortedArray.map?\n\u001b[31m\u001b[31m-- Error: /tmp/tmp1ur_b4jr.scala:37:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        sortedArray.reverse()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029424
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var retVal: List[Long] = List()\n        var sum : Long = 0\n        var maxArray = array\n        var index = 0\n        var temp : List[Long] = List()\n        for(i <- 0 until maxArray.length){\n            if(sum % 2 == 0){\n                sum = (sum + maxArray(i)).toLong\n                temp = temp + maxArray(i)\n                if(index >= temp.size){\n                    retVal = retVal + temp\n                    index = index + 1\n                    temp.remove(0)\n                }\n            }\n            else{\n                sum = (sum - maxArray(i)).toLong\n                temp = temp + maxArray(i)\n                if(index >= temp.size){\n                    retVal = retVal + temp\n                    index = index + 1\n                    temp.remove(0)\n                }\n            }\n        }\n        return retVal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1pt2y6rp.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                temp = temp + maxArray(i)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1pt2y6rp.scala:29:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    retVal = retVal + temp\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1pt2y6rp.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    temp.remove(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not F",
      "stdout": "",
      "timestamp": 1660029427
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumArray = array.sum\n        var evenSum = sumArray % 2\n        var evenIndex = 0\n        var oddSum = 0\n        array.foreach( x =>\n            if ( evenSum % 2 == 0 ) {\n                evenSum /= 2\n                evenIndex += 1\n                if ( sumArray - evenSum + x == 0 ) {\n                    evenIndex -= 1\n                }\n            } else {\n                oddSum += 1\n                if ( sumArray - oddSum + x == 0 ) {\n                    oddSum -= 1\n                }\n            }\n        )\n        oddSum += 1\n        evenIndex -= 1\n        oddSum += 1\n        evenIndex -= 1\n        oddSum = evenSum + evenIndex\n        evenIndex = evenIndex - evenSum\n        evenSum = evenSum + evenIndex\n        oddSum = oddSum + oddIndex\n        oddSum = oddSum + evenIndex\n        if ( evenSum % 2 == 1 ) {\n            return sortArray(array.map(x => x :: 0))\n        }\n        if ( oddSum % 2 == 0 ) {\n            return sortArray(array.map(x => 0 :: x))\n        }\n        return array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1vd_skif.scala:41:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        oddSum = evenSum + evenIndex\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    Long\n\u001b[31m   |\u001b[0m                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1vd_skif.scala:42:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        evenIndex = evenIndex - evenSum\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    Long\n\u001b[31m   |\u001b[0m                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vd_skif.scala:44:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        oddSum = oddSum + oddIndex\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: oddIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1vd_skif.scala:47:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mreturn\u001b[0m sortArray(array.map(\u001b[36mx\u001b[0m => x :: \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value :: is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1vd_skif.scala:50:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            \u001b[33mreturn\u001b[0m sortArray(array.map(\u001b[36mx\u001b[0m => \u001b[31m0\u001b[0m :: x))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :: is not a member of Long\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029427
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var max = 0\n        var min = 0\n        var length = 0\n        for(i <- 0 until array.length)\n        {\n            if(array(i) > array.length)\n            {\n                sum = sum + array(i)\n                max = max(sum, max)\n                min = min(sum, min)\n                length = length + 1\n                array(i) = array.length - array(i)\n                array.remove(array(i))\n            }\n        }\n        if(length%2 == 1)\n        {\n            val firstIndex = length - 1\n            val secondIndex = length - 2\n            val newList = array.sortBy(x => x % 2 == 1).map(x => x + firstIndex).map(x => x + secondIndex)\n            return newList\n        }\n        else\n        {\n            val firstIndex = length - 1\n            val secondIndex = length - 2\n            val newList = array.sortBy(x => x % 2 == 0).map(x => x + firstIndex).map(x => x + secondIndex)\n            return newList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppv3fz4k8.scala:27:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                sum = sum + array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppv3fz4k8.scala:28:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                max = max(sum, max)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppv3fz4k8.scala:29:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                min = min(sum, min)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppv3fz4k8.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                array(i) = array.length - array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean array.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppv3fz4k8.scala:32:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                array.remove(array(i))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.Implici",
      "stdout": "",
      "timestamp": 1660029428
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.groupBy(_.toInt/2).mapValues(v => v.sum).map(_._1).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpipsyasw0.scala:19:65 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        array.groupBy(_.toInt/\u001b[31m2\u001b[0m).mapValues(\u001b[36mv\u001b[0m => v.sum).map(_._1).sorted\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sorted is not a member of scala.collection.View[Int] - did you mean scala.collection.View[Int].force?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029426
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) {\n            return array\n        } else {\n            var sum = 0\n            var lastIndex = array.length - 1\n            var isEven = false\n            var isOdd = true\n            var sumIndex = 0\n            while (sumIndex < lastIndex) {\n                var sum = 0\n                sumIndex += 1\n                sum = sum + array.get(sumIndex)\n                if (isEven) {\n                    if (sum % 2 != 0) {\n                        sum = sum - 1\n                        isEven = false\n                        isOdd = true\n                    }\n                } else if (sum % 2 == 0) {\n                    sum = sum + 1\n                    isEven = true\n                    isOdd = false\n                }\n                array.insert(sumIndex + 1, sum)\n            }\n            if (isEven) {\n                array.sort((a, b) => { b - a })\n            } else {\n                array.sort((a, b) => { a - b })\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbkpwr_hi.scala:30:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                sum = sum + array.get(sumIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[Long] - did you mean array.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbkpwr_hi.scala:42:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                array.insert(sumIndex + \u001b[31m1\u001b[0m, sum)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value insert is not a member of List[Long] - did you mean array.init?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbkpwr_hi.scala:45:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                array.sort((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => { b - a })\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbkpwr_hi.scala:47:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                array.sort((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => { a - b })\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029427
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var index : Int = array.length - 1\n        var odd : Boolean = array.length % 2 == 1\n        while(index >= 0){\n            val first = array.get(index)\n            val last = array.get(index - 1)\n            var newSum : Long = 0\n            if(odd){\n                newSum = first + last\n            } else {\n                newSum = last + first\n            }\n            if(newSum == 0){\n                array.remove(index)\n            } else {\n                if(newSum < 0){\n                    array.remove(index - 1)\n                    array.remove(index)\n                } else if(newSum > 0){\n                    array.remove(index)\n                    array.remove(index + 1)\n                }\n            }\n            index--\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpcynh_ou4.scala:41:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            index--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcynh_ou4.scala:22:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfirst\u001b[0m = array.get(index)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[Long] - did you mean array.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcynh_ou4.scala:23:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlast\u001b[0m = array.get(index - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcynh_ou4.scala:31:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                array.remove(index)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcynh_o",
      "stdout": "",
      "timestamp": 1660029429
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        require(array.length > 0, \"array length can't be zero\")\n        var result : List[Long] = List()\n        var i = -1\n        var j = array.length - 1\n\n        while (i < j) {\n            while (i < j && array(i) > array(i + 1)) {\n                result += array(i)\n                i += 1\n            }\n            while (i < j && array(i) < array(i + 1)) {\n                result -= array(i)\n                j -= 1\n            }\n            if (i < j) {\n                result += array(i)\n                i += 1\n                j -= 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdxzgfzl7.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdxzgfzl7.scala:30:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result -= array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value -= is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdxzgfzl7.scala:34:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                result += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029429
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum : Long = array.sum\n        if(sum % 2 == 0) {\n            val odd = array.sortWith(_ < _).reverse\n            odd.toList\n        } else {\n            val even = array.sortWith(_ < _)\n            even.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6_il5tbp.scala:32)\n\tat Problem.main(tmp6_il5tbp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var array = array\n        if (array.length == 0) {\n            return array\n        }\n        var i = 0\n        var sum = 0\n        var sumEven = 0\n        while (i < array.length) {\n            sum = sum + array(i).toLong\n            sumEven = sumEven + array(i).toLong % 2\n            i = i + 1\n        }\n        if (sumEven > sum) {\n            var newArray = array.sortWith((a, b) => b.toLong < a.toLong)\n            if (sumEven > sum) {\n                var newArray = array.sortWith((a, b) => b.toLong > a.toLong)\n            }\n            return newArray\n        } else {\n            return array.sortWith((a, b) => b.toLong < a.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxgl6gokh.scala:19:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36marray\u001b[0m = array\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvariable\u001b[0m \u001b[35marray\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029424
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var tempArray = array;\n        val sumFirst = array.head + array.last\n        val sumLast = array.head + array.last\n        val oddOrEven = sumFirst % 2 != 0\n        if(oddOrEven){\n            val sumFirst = array.head + array.last\n            val sumLast = array.head + array.last\n            val evenOrOdd = sumLast % 2 == 0\n            if(evenOrOdd){\n                tempArray = tempArray.sortBy(x => x.toLong)\n            }\n            tempArray = tempArray.sortBy(x => -x.toLong)\n        }\n        return tempArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.sortArray(tmpd2do12to.scala:20)\n\tat Problem$.main(tmpd2do12to.scala:35)\n\tat Problem.main(tmpd2do12to.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) \n            (List[Long]())\n        else {\n            var sum = 0\n            var newArray = array.clone\n            val size = newArray.size\n            for (i <- 0 until size) {\n                sum += newArray(i)\n            }\n            if (sum % 2 == 0)\n                newArray.sortBy(x => x)\n            else newArray.sortBy(x => -x)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpral49u95.scala:23:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnewArray\u001b[0m = array.clone\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (array : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029425
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.size <= 1) array\n        else {\n            val newArray = mutable.ArrayBuffer[Long]()\n            for(i <- 0 until array.size-1) {\n                if(array(i) == array(i+1)) newArray += array(i)\n                else if(array(i) < array(i+1)) newArray += array(i)\n                else if(array(i) > array(i+1)) newArray += array(i+1)\n            }\n            newArray.sortWith(Ordering[Long].reverse)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps8a6p4c4.scala:21:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029427
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.length\n        if(n <= 1) array\n        else {\n            // first sort and find the sum of the first element and the last element\n            var sum = 0l\n            for(i <- 0 until n) {\n                sum += array(i)\n            }\n            val sum = sum.toInt\n\n            // if sum is odd, reverse it\n            if(sum & 1 == 1) {\n                val r = sum.toLong >> 1\n                var a = array\n                for(i <- 0 until n) {\n                    array(i) := (a(i) - r).toLong\n                }\n                array\n            } else {\n                // if sum is even, sort it in ascending order\n                var a = array\n                for(i <- 0 until n) {\n                    array(i) := (a(i) + sum - a(i)).toLong\n                }\n                array\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp27711nnj.scala:27:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = sum.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0msum is already defined as \u001b[33mvariable\u001b[0m \u001b[35msum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp27711nnj.scala:30:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m(sum & \u001b[31m1\u001b[0m == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m&\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((\u001b[31mtrue\u001b[0m : Boolean))\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp27711nnj.scala:34:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    array(i) := (a(i) - r).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value := is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp27711nnj.scala:41:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    array(i) := (a(i) + sum - a(i)).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value := is not a member of Long - did you mean Long.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029432
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumOfFirstAndLastValue = array.sum\n\n        if(sumOfFirstAndLastValue % 2 == 0) array.sort else array.sortDescending\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo8vrzten.scala:21:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m(sumOfFirstAndLastValue % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) array.sort \u001b[33melse\u001b[0m array.sortDescending\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value sort is not a member of List[Long] - did you mean array.sortBy?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo8vrzten.scala:21:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m(sumOfFirstAndLastValue % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) array.sort \u001b[33melse\u001b[0m array.sortDescending\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value sortDescending is not a member of List[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val size = array.size\n        val resultArray = if (size <= 1) array else array.zip(array.dropRight(1)).toList ::: array\n        resultArray.sortBy(x => math.signum(x))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp0ruv9yaa.scala:21:37 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        resultArray.sortBy(\u001b[36mx\u001b[0m => math.signum(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35msignum\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((x : Matchable))\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0ruv9yaa.scala:21:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        resultArray.sortBy(\u001b[36mx\u001b[0m => math.signum(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mDeprecatedFloatOrdering\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029429
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var list = array //don't change this\n\n        if (sum < 2) return list\n        \n        val listSize = list.size\n        val mid = (listSize / 2).toInt\n\n        val oddSum = list[mid].toLong\n        var evenSum = (list[mid]).toLong\n\n        if (oddSum % 2 == 0) \n            list = list.sortBy(x => x.toLong)\n        else list = list.sortBy(x => x.toLong).reverse\n        list = list.take(mid + 1)\n        if (list[mid].toLong < list[mid + 1].toLong)\n            list = list.sortBy(x => x.toLong)\n        else list = list.sortBy(x => x.toLong).reverse\n        list = list.take(mid)\n        \n        return list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkzhcsvue.scala:27:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moddSum\u001b[0m = list[\u001b[35mmid\u001b[0m].toLong\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type mid\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkzhcsvue.scala:28:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mevenSum\u001b[0m = (list[\u001b[35mmid\u001b[0m]).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type mid\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkzhcsvue.scala:34:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mif\u001b[0m (list[\u001b[35mmid\u001b[0m].toLong < list[\u001b[35mmid\u001b[0m \u001b[35m+\u001b[0m \u001b[31m1\u001b[0m].toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: type mid\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029429
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var temp = 0\n        var j = 0\n        var k = 0\n        var sum = 0\n        var tempList = new ListBuffer[Long]()\n        for (i<-1 to array.length) {\n            sum = array[i] + temp\n            if (sum % 2 != 0) {\n                tempList = tempList :+ sum\n                temp = sum\n                j++\n            }\n        }\n        if (array.length > 0) {\n            while (j < array.length) {\n                sum = temp + array[j]\n                tempList = tempList :+ sum\n                temp = sum\n                k++\n            }\n        }\n        while (temp < array.length) {\n            sum = temp + array[k]\n            tempList = tempList :+ sum\n            temp = sum\n            k++\n        }\n        val list = tempList.toList\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpycfubgtk.scala:29:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpycfubgtk.scala:37:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                k++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpycfubgtk.scala:44:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            k++\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpycfubgtk.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            sum = array[\u001b[35mi\u001b[0m] + temp\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpycfubgtk.scala:34:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                sum = temp + array[\u001b[35mj\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpycfubgtk.scala:41:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            sum = temp + array[\u001b[35mk\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type k\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available",
      "stdout": "",
      "timestamp": 1660029429
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // write your code in here\n        val sum  = array.last\n        val even = array.filter(_%2==0)\n        val odd = array.filter(_%2!=0)\n        var evenSorted = even.sortWith(_.compare(sum))\n        var oddSorted = odd.sortWith(_.compare(sum))\n        evenSorted.reverse.::oddSorted.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp_gi1xd0i.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        evenSorted.reverse.::oddSorted.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31m'.'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp_gi1xd0i.scala:23:39 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mevenSorted\u001b[0m = even.sortWith(_.compare(sum))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp_gi1xd0i.scala:24:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36moddSorted\u001b[0m = odd.sortWith(_.compare(sum))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029429
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) return array\n        val l = new mutable.ListBuffer[Long]()\n        val index = new mutable.ListBuffer[Int]()\n        for (i <- 0 until array.size) {\n            if (array(i) < 0) l.append(array(i))\n            else {\n                l.append(array(i))\n                index.append(i)\n            }\n        }\n        var sum = 0\n        var i = 0\n        var j = 0\n        var index = index.iterator\n        var l = l.iterator\n        while (index.hasNext && l.hasNext) {\n            sum = sum + l.next() + index.next()\n            if (sum % 2 == 0) index = index.drop(1)\n            else {\n                l.next()\n                index -= 1\n            }\n        }\n        val re = if (sum % 2 == 0) l.toList else l.toReverse.list\n        re.sortWith(_ > _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx98x6lvn.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mindex\u001b[0m = index.iterator\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mindex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mindex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx98x6lvn.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = l.iterator\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx98x6lvn.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx98x6lvn.scala:21:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpx98x6lvn.scala:36:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) index = index.drop(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Reassignment to val index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array == null || array.size < 2) return array\n        var firstIndex : Long = 0\n        var lastIndex : Long = array.size - 1\n        var index : Int = 0\n        var sum : Long = 0\n        var evenSum = 0\n        var oddSum = 0\n        while(firstIndex < lastIndex) {\n            sum = array[firstIndex] + array[lastIndex]\n            evenSum = evenSum + sum / 2\n            oddSum = oddSum + sum\n            if(sum % 2 == 1) {\n                if(evenSum < oddSum) {\n                    swap(array, firstIndex, lastIndex)\n                } else {\n                    swap(array, firstIndex, lastIndex - 1)\n                }\n            } else {\n                if(evenSum > oddSum) {\n                    swap(array, firstIndex, lastIndex)\n                } else {\n                    swap(array, firstIndex, lastIndex - 1)\n                }\n            }\n            firstIndex = firstIndex + 1\n            lastIndex = lastIndex - 1\n            index += 1\n        }\n        if(array.isEmpty) return array\n        sortArray(array.slice(1, array.length))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3x2bhksh.scala:27:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            sum = array[\u001b[35mfirstIndex\u001b[0m] + array[\u001b[35mlastIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type firstIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3x2bhksh.scala:28:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            evenSum = evenSum + sum / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3x2bhksh.scala:29:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            oddSum = oddSum + sum\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Long\n\u001b[31m   |\u001b[0m                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3x2bhksh.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    swap(array, firstIndex, lastIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: swap\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3x2bhksh.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    swap(array, firstIndex, lastIndex - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: swap\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3x2bhksh.scala:38:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    swap(array",
      "stdout": "",
      "timestamp": 1660029434
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumArray = array.foldLeft(0.toLong)( (sum, currentLong) => sum + currentLong )\n        val sortSum = sumArray.toDouble % 2d.toInt\n        val finalArray = if (sortSum == 0) array else array.sortBy(-_).reverse\n        val result = if (sortSum == 0) finalArray else finalArray.sortBy(-_)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7tsbcv8x.scala:28)\n\tat Problem.main(tmp7tsbcv8x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029437
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val size = array.length\n        var cur = 0\n        var next = 1\n        var max = Integer.MIN_VALUE\n        var i = -1\n        for (i <- 0 until size) {\n            if (max < array[i]) {\n                max = array[i]\n                cur = next\n            }\n            next += 1\n        }\n        val result = array.slice(1, size)\n        result.sortWith(_ < _)\n        if (result.sum % 2 == 0) {\n            result.sortWith(_ > _)\n        } else {\n            result.sortWith(_ < _)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp93k9paqd.scala:25:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (max < array[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp93k9paqd.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                max = array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029433
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var result = array\n        val length = array.length\n        val odd = length % 2\n        if (odd) {\n            for (i <- 0 until length-1) result += i\n        }\n        val even = length / 2\n        for (i <- 0 until even-1) result += i + (length-1-i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi88a1bt3.scala:22:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (odd) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (odd : Int)\n\u001b[31m   |\u001b[0m            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88a1bt3.scala:23:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until length-\u001b[31m1\u001b[0m) result += i\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88a1bt3.scala:26:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until even-\u001b[31m1\u001b[0m) result += i + (length-\u001b[31m1\u001b[0m-i)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029437
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer[Long]()\n        var flag = 0\n        for(i <- 0 until array.size) {\n            val sum = Math.abs((array(i) - array(i-1)))\n            val sum1 = Math.abs((array(i) - array(i+1)))\n            if(sum % 2 == 0) {\n                if(sum1 > 0) flag = 1\n                flag = 0\n                newList += array(i)\n            } else {\n                if(sum1 < 0) flag = -1\n                flag = 1\n                newList += array(i)\n            }\n        }\n        if(flag == 1) newList.sortBy(x => x)\n        else newList.sortBy(x => -x).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxz_b91ru.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029433
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum = array.sum\n        val odd = sum.mod(2l).toLong != 0l\n        val even = sum.mod(2l) == 0l\n        if (odd) array.sortBy(-_)\n        else array.sortBy(-_.max)(-_.min)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7lfw4nxw.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36modd\u001b[0m = sum.mod(\u001b[31m2l\u001b[0m).toLong != \u001b[31m0l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7lfw4nxw.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36meven\u001b[0m = sum.mod(\u001b[31m2l\u001b[0m) == \u001b[31m0l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7lfw4nxw.scala:23:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33melse\u001b[0m array.sortBy(-_.max)(-_.min)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue unary_- is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp7lfw4nxw.scala:23:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33melse\u001b[0m array.sortBy(-_.max)(-_.min)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0L\n        var i = 0\n        var j = 0\n        var newArray = array\n        var temp = 0L\n        while (i < newArray.length) {\n            sum = sum + newArray(i)\n            i = i + 1\n        }\n\n        if (sum % 2L != 0L) {\n            temp = newArray(newArray.length - 1L)\n            newArray = newArray.tail\n            val start = newArray(0)\n            val end = newArray.length - 1\n            while (j < (newArray.length - end)) {\n                newArray(j) = newArray(j + 1L)\n                j = (j + 1L)\n            }\n            newArray(j) = temp\n            newArray.sorted.reverse\n        } else {\n            newArray.sorted\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsnq5qeff.scala:30:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            temp = newArray(newArray.length - \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsnq5qeff.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                newArray(j) = newArray(j + \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsnq5qeff.scala:35:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                newArray(j) = newArray(j + \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    Long\n\u001b[31m   |\u001b[0m                                       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsnq5qeff.scala:36:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                j = (j + \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Long\n\u001b[31m   |\u001b[0m                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsnq5qeff.scala:38:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            newArray(j) = temp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val newArray = array.foldRight(List[Long]())( (l,r) => if (l.sum % 2 == 0) (l :+ r) else (l :+ r.reverse))\n        newArray.toList.sortBy(l => l)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpok5p2a2e.scala:19:69 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = array.foldRight(List[\u001b[35mLong\u001b[0m]())( (\u001b[36ml\u001b[0m,\u001b[36mr\u001b[0m) => \u001b[33mif\u001b[0m (l.sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) (l :+ r) \u001b[33melse\u001b[0m (l :+ r.reverse))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value sum is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpok5p2a2e.scala:19:86 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = array.foldRight(List[\u001b[35mLong\u001b[0m]())( (\u001b[36ml\u001b[0m,\u001b[36mr\u001b[0m) => \u001b[33mif\u001b[0m (l.sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) (l :+ r) \u001b[33melse\u001b[0m (l :+ r.reverse))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :+ is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpok5p2a2e.scala:19:100 -----------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArray\u001b[0m = array.foldRight(List[\u001b[35mLong\u001b[0m]())( (\u001b[36ml\u001b[0m,\u001b[36mr\u001b[0m) => \u001b[33mif\u001b[0m (l.sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) (l :+ r) \u001b[33melse\u001b[0m (l :+ r.reverse))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :+ is not a member of Long\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        def sortHelper(a: List[Long], b: Long, sum : Long) : Boolean = {\n            if(sum%2 == 1) a else b\n        }\n        val sum = 0\n        val array = array.sorted\n        val resultList = mutable.ListBuffer[Long]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var sum = 0\n        while(i < array.size) {\n            sum = sum + array(i).toLong\n            i = i + 1\n        }\n        while(j < array.size) {\n            sum = sum + array(i).toLong\n            i = i + 1\n            sum = sum - array(i).toLong\n            j = j + 1\n        }\n        if(sum%2 == 1) array.reverse.foreach((x) => resultList.append(x))\n        else array.foreach((x) => resultList.append(x))\n        resultList.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50m9nem0.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msum\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0msum is already defined as \u001b[33mvalue\u001b[0m \u001b[35msum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp50m9nem0.scala:20:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m(sum%\u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) a \u001b[33melse\u001b[0m b\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (a : List[Long])\n\u001b[31m   |\u001b[0m                           Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp50m9nem0.scala:20:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m(sum%\u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) a \u001b[33melse\u001b[0m b\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (b : Long)\n\u001b[31m   |\u001b[0m                                  Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp50m9nem0.scala:23:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marray\u001b[0m = array.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35marray\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp50m9nem0.scala:24:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compili",
      "stdout": "",
      "timestamp": 1660029438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.isEmpty){\n          array\n        }\n        var sum = 0\n        var odd = 0\n        var even = 0\n        var result = List[Long]()\n        var temp = 0\n        var temp2 = 0\n        array.foreach(x => {\n          sum = sum + x\n        })\n        odd = sum%2 != 0\n        even = sum%2 == 0\n        array.sort((x: Long, y: Long) => {\n          if((odd == true && x<y) || (even == true && x>y)) -1\n          else if(x<y) 1\n          else x>y\n        })\n        array.foreach(x => {\n          temp = temp + x\n        })\n        if(odd == true){\n          result = array :+ temp\n        }\n        if(even == true){\n          result = result :+ temp2\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_nhe6jbj.scala:29:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m          sum = sum + x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_nhe6jbj.scala:31:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        odd = sum%\u001b[31m2\u001b[0m != \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    Boolean\n\u001b[31m   |\u001b[0m              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_nhe6jbj.scala:32:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        even = sum%\u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    Boolean\n\u001b[31m   |\u001b[0m               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_nhe6jbj.scala:33:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        array.sort((\u001b[36mx\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36my\u001b[0m: \u001b[35mLong\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_nhe6jbj.scala:34:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m          \u001b[33mif\u001b[0m((odd == \u001b[31mtrue\u001b[0m && x<y) || (even == \u001b[31mtrue\u001b[0m && x>y)) -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Int and Boolean cannot be compared ",
      "stdout": "",
      "timestamp": 1660029441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var result: List[Long] = Nil\n        var i = 0\n        var j = 0\n        var k = 0\n        while(i < array.length) {\n            val firstValue = array[i]\n            val secondValue = array[i+1]\n            val thirdValue = array[i+2]\n            if(thirdValue == 0l) {\n                i += 1\n                continue\n            }\n            if(thirdValue > 0l) {\n                result :+= firstValue\n                i += 1\n                continue\n            }\n            if(secondValue == 0l) {\n                i += 2\n                continue\n            }\n            if(secondValue > 0l) {\n                result :+= secondValue\n                i += 2\n                continue\n            }\n            if(firstValue == 0l) {\n                result += thirdValue\n                i += 3\n                continue\n            }\n            if(firstValue > 0l) {\n                result += firstValue\n                i += 1\n                continue\n            }\n            if(thirdValue == 0l) {\n                i += 3\n                continue\n            }\n            if(thirdValue > 0l) {\n                result += thirdValue\n                i += 3\n                continue\n            }\n            result += secondValue\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1ho46qz.scala:24:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfirstValue\u001b[0m = array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1ho46qz.scala:25:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msecondValue\u001b[0m = array[\u001b[35mi+\u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type +\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1ho46qz.scala:26:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mthirdValue\u001b[0m = array[\u001b[35mi+\u001b[31m2\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type +\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1ho46qz.scala:29:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1ho46qz.scala:34:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1ho46qz.scala:38:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                No",
      "stdout": "",
      "timestamp": 1660029440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumList = array.map(i => new Array[Long](array.size).fill(0)){\n            _ ++ Array[Long](i, 0)\n        }.foldLeft(0)((i, j) => i + j) // sum of first index and last index\n        val isOdd = sumList % 2 == 1\n        if (isOdd) array.sorted else array.sorted(reverse = true)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqgrjemo2.scala:19:65 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msumList\u001b[0m = array.map(\u001b[36mi\u001b[0m => \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](array.size).fill(\u001b[31m0\u001b[0m)){\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value fill is not a member of Array[Long]\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpqgrjemo2.scala:20:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            _ ++ Array[\u001b[35mLong\u001b[0m](i, \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => _$1 ++ Array[\u001b[35mLong\u001b[0m](i, 0).\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqgrjemo2.scala:23:58 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (isOdd) array.sorted \u001b[33melse\u001b[0m array.sorted(reverse = \u001b[31mtrue\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35msorted\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mStrictOptimizedSeqOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): List[Long] does not have a parameter reverse\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // write your code in here\n        array.zipWithIndex.sort{ (x,y) =>\n            if((y._1+x._2)%2==0)\n                x._1 < y._1\n            else\n                x._1 > y._1\n        }.map{ (x,y) =>\n            if((y._1+x._2)%2==0)\n                x._2\n            else\n                y._2\n        }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl4jfrkdj.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        array.zipWithIndex.sort{ (\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[(Long @uncheckedVariance, Int)] - did you mean List[(Long @uncheckedVariance, Int)].sortBy?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var min = 0\n        var max = 0\n\n        for ((index, value) <- array.zipWithIndex) {\n            sum += value\n            if(max < value) max = value\n            if(min > value) min = value\n        }\n\n        if(sum % 2 == 1) max = max + 1\n        else max = max - 1\n\n        if(min < 0) min = max + 1\n        else min = min - 1\n\n        array = array.sortWith( (a, b) => b > a )\n        array = array.drop(min)\n        array = array.take(max)\n        array.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpi4sln1op.scala:35:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        array = array.sortWith( (\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => b > a )\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val array\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpi4sln1op.scala:36:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        array = array.drop(min)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val array\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpi4sln1op.scala:37:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        array = array.take(max)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val array\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var coscala : List[Long] = Nil\n\n        // Iterate through the given array.\n        for (i <- 0 until array.size-1) {\n            // Calculate the sum.\n            sum += array(i)\n\n            // If the sum is odd.\n            if (sum % 2 != 0) {\n                // Sort it in descending order.\n                coscala :+= array(i).toLong\n            } else {\n                // Sort it in ascending order.\n                coscala :+= array(i).toLong.reverse\n            }\n        }\n        return coscala\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpurip7a8v.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            sum += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpurip7a8v.scala:33:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                coscala :+= array(i).toLong.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value :+= is not a member of List[Long] - did you mean List[Long].:+?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpurip7a8v.scala:33:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                coscala :+= array(i).toLong.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value reverse is not a member of Long\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029442
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sums = array.foldLeft((List.empty[Long], 0)){ (accum, elem) =>\n            val l = accum._1 + elem\n            val r = accum._2 + elem\n            if (l.toLong > r.toLong) accum.updated(1, l)\n            else accum.updated(1, r)\n        }._1.sorted\n        if (sums.lastOption.exists(_ % 2 == 1)) sums.reverse\n        else sums.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprlwr9puk.scala:20:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = accum._1 + elem\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprlwr9puk.scala:22:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (l.toLong > r.toLong) accum.updated(\u001b[31m1\u001b[0m, l)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value updated is not a member of (List[Long], Int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprlwr9puk.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m accum.updated(\u001b[31m1\u001b[0m, r)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value updated is not a member of (List[Long], Int)\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029442
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.size < 2) \n            return\n\n        var result : List[Long] = Nil\n\n        var sum = 0L\n        var sumOfFirstIndex = 0L\n        var sumOfLastIndex = 0L\n        var arraySize = array.size\n\n        for(i <- 0 until arraySize) {\n            sum += array(i)\n            sumOfFirstIndex += array(i).toLong\n            sumOfLastIndex += array(arraySize - i-1).toLong\n        }\n\n        if(sumOfLastIndex % 2 != 0 && sumOfFirstIndex % 2 == 0) \n            result = array sortBy {x => -x}\n        else {\n            if(sumOfLastIndex % 2 == 0 && sumOfFirstIndex % 2 == 1) \n                result = array sortBy {x => -x }\n            else {\n                if(sumOfFirstIndex % 2 == 1 && sumOfLastIndex % 2 == 0) \n                    result = array sortBy {x => x}\n                else {\n                    if(sumOfLastIndex % 2 == 0 && sumOfFirstIndex % 2 == 1)\n                        result = array sortBy {x => -x }\n                    else {\n                        result = array sortBy {x => -x }\n                    }\n                }\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1dkjknx4.scala:20:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        array.foreach( n => sum+=n)\n        val sortedArray = array.sortWith( (a, b) => a < b || (a == b && sum%2 == 1))\n        sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz8jf6nvz.scala:20:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        array.foreach( \u001b[36mn\u001b[0m => sum+=n)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val a = new mutable.ArrayBuffer[Long](array.toList)\n        val n = a.length\n        val temp = a(0)\n        for (i <- 0 until n) {\n            if (temp + a(i) < temp + a(n-1)) temp = a(n-1) else temp = a(i)\n            a.insert(i, temp)\n        }\n        a\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjn01drvl.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m](array.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpjn01drvl.scala:23:50 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (temp + a(i) < temp + a(n-\u001b[31m1\u001b[0m)) temp = a(n-\u001b[31m1\u001b[0m) \u001b[33melse\u001b[0m temp = a(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Reassignment to val temp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpjn01drvl.scala:23:69 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (temp + a(i) < temp + a(n-\u001b[31m1\u001b[0m)) temp = a(n-\u001b[31m1\u001b[0m) \u001b[33melse\u001b[0m temp = a(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Reassignment to val temp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val resultList = mutable.ArrayBuffer.empty[Long]\n        if (array.nonEmpty) {\n            resultList += array.head\n            val tail = array.tail\n            if (tail.nonEmpty) {\n                val firstTail = tail.head\n                if (firstTail%2 == 0) {\n                    resultList += firstTail\n                    val lastTail = tail.last\n                    if (lastTail%2 == 0) {\n                        resultList += lastTail\n                    }\n                }\n            }\n        }\n        resultList.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1mdu84o.scala:19:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029438
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        require( array.nonEmpty )\n        var result = scala.collection.mutable.ListBuffer.empty[Long]\n        var sum : Long = 0\n        for ( x <- array ) {\n            sum += x\n        }\n        sum += 1\n\n        if ( sum % 2 == 0 ) {\n            result.addAll( array.sortBy( x => ( -x ) ) )\n        } else {\n            result.addAll( array.sortBy( x => ( -x ) ).reverse  )\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IllegalArgumentException: requirement failed\n\tat scala.Predef$.require(Predef.scala:324)\n\tat Problem$.sortArray(tmpv9e1bttr.scala:19)\n\tat Problem$.main(tmpv9e1bttr.scala:35)\n\tat Problem.main(tmpv9e1bttr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029444
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        for (i <- 0 until array.size) {\n            sum += array(i)\n        }\n        val isSumEven = sum % 2 == 0\n        val sortedArray = if (isSumEven) {\n            array.sortBy{x => (x._2 - x._1).abs}\n        } else {\n            array.sortBy{x => (x._2 - x._1).abs}.reverse\n        }\n        return sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp64zhpbqq.scala:21:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            sum += array(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp64zhpbqq.scala:25:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            array.sortBy{\u001b[36mx\u001b[0m => (x._2 - x._1).abs}\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value _2 is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp64zhpbqq.scala:25:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            array.sortBy{\u001b[36mx\u001b[0m => (x._2 - x._1).abs}\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp64zhpbqq.scala:27:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            array.sortBy{\u001b[36mx\u001b[0m => (x._2 - x._1).abs}.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value _2 is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp64zhpbqq.scala:27:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            array.sortBy{\u001b[36mx\u001b[0m => (x._2 - x._1).abs}.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029443
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.isEmpty) throw new Exception(\"The array is empty!\")\n        val arr: mutable.Buffer[Long] = new mutable.Buffer[Long](array.head)\n        val result: mutable.Buffer[Long] = new mutable.Buffer[Long]()\n        array.foreach{elem => \n            arr += elem\n            if((arr.head + arr.last) % 2 == 0) result += arr.head + arr.last\n        }\n        if(arr.head + arr.last < arr.head + arr.last) result ++= arr.tail\n        arr.removeAll(result).toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg1v0xpug.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m](array.head)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg1v0xpug.scala:20:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m](array.head)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg1v0xpug.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg1v0xpug.scala:21:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // write your code\n        var sum = 0\n        for(i <- 0 until array.size){\n            sum = sum + array(i)\n        }\n        sum.toInt match {\n            case 0 => return array\n            case i =>\n                var left = array\n                var right = array\n                while(sum > 0){\n                    var leftMax = left.max\n                    var rightMax = right.max\n                    if(sum % 2 == 0){\n                        sum = sum - leftMax + rightMax\n                    }else{\n                        sum = sum - leftMax - rightMax\n                    }\n                    left = left.filter(_ != leftMax)\n                    right = right.filter(_ != rightMax)\n                }\n                (left + right).sort\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9jl7r37t.scala:22:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum = sum + array(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9jl7r37t.scala:33:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                        sum = sum - leftMax + rightMax\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Long\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9jl7r37t.scala:35:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                        sum = sum - leftMax - rightMax\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Long\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9jl7r37t.scala:40:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                (left + right).sort\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029448
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // write your code here\n        val map=new mutable.HashMap[Long,Long]()\n        for(i <- 0 until array.length){\n            map.put(array(i),i)\n        }\n        val list=array.sorted\n        val list2=list.tail.takeWhile(elem=>!map.contains(elem))\n        val list3=list.drop(list.last)\n        if(list2.length%2==0){\n            list.sortBy(_-_.head+list2.head)\n        }\n        else{\n            list.sortBy(_-_.head+list2.last)\n        }\n        list3\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6mr_j3v.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m=\u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6mr_j3v.scala:25:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist2\u001b[0m=list.tail.takeWhile(elem=>!map.contains(elem))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: elem\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6mr_j3v.scala:26:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist3\u001b[0m=list.drop(list.last)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpl6mr_j3v.scala:28:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            list.sortBy(_-_.head+list2.head)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl6mr_j3v.scala:28:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            list.sortBy(_-_.head+list2.head)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeq",
      "stdout": "",
      "timestamp": 1660029446
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sorted = array.sortBy(i => i)\n        if (sorted.sum % 2 == 1) {\n            sorted.reverse\n        }\n        else sorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnny56lg6.scala:28)\n\tat Problem.main(tmpnny56lg6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029448
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith(_<_) match {\n            case Nil => Nil\n            case x::xs => x :: sortArray(xs)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkdqlm63j.scala:28)\n\tat Problem.main(tmpkdqlm63j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val arrList = array.toList.sortWith((x, y) => (x < y) ? -1 : (x > y) ? +1 : 0)\n        (arrList.tail, arrList.head) match {\n            case (Some(_), Some(_)) => arrList\n            case _ => (if (arrList.head % 2 == 0) arrList.reverse else arrList)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq8wsfd6m.scala:19:80 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrList\u001b[0m = array.toList.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => (x < y) ? -\u001b[31m1\u001b[0m : (\u001b[35mx\u001b[0m \u001b[35m>\u001b[0m \u001b[35my\u001b[0m) \u001b[35m?\u001b[0m \u001b[35m+\u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq8wsfd6m.scala:19:77 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrList\u001b[0m = array.toList.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => (x < y) ? -\u001b[31m1\u001b[0m : (\u001b[35mx\u001b[0m \u001b[35m>\u001b[0m \u001b[35my\u001b[0m) \u001b[35m?\u001b[0m \u001b[35m+\u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type ?\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq8wsfd6m.scala:19:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrList\u001b[0m = array.toList.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => (x < y) ? -\u001b[31m1\u001b[0m : (\u001b[35mx\u001b[0m \u001b[35m>\u001b[0m \u001b[35my\u001b[0m) \u001b[35m?\u001b[0m \u001b[35m+\u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val l = array.size\n        if (l <= 1) array\n        else {\n            var maxSum = -array(0)\n            var maxIndex = -1\n            for (index <- 1 to l) {\n                val sum = array(index)\n                if (sum > maxSum) {\n                    maxIndex = index\n                    maxSum = sum\n                }\n            }\n            if (maxSum.isEven) {\n                // sort descending\n                val l1 = array.drop(maxIndex)\n                val l2 = array.take(maxIndex+1)\n                l2.reverse ::: l1\n            } else {\n                // sort ascending\n                val l1 = array.drop(maxIndex+1)\n                val l2 = array.take(maxIndex)\n                l1 ::: l2\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqcg8m8ua.scala:31:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (maxSum.isEven) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isEven is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n      val sum = 0\n      array.foreach(e => sum += e)\n      if (sum % 2 == 0) {\n        array.sortBy(-_.head)\n      }\n      else {\n        array.sortBy(_.head)\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp72io91vz.scala:20:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m      array.foreach(\u001b[36me\u001b[0m => sum += e)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp72io91vz.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        array.sortBy(-_.head)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value head is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp72io91vz.scala:22:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        array.sortBy(-_.head)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mBigInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp72io91vz.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        array.sortBy(_.head)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value head is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp72io91vz.scala:25:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        array.sortBy(_.head)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mBigInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029452
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Write your code here\n        array.sortWith(x => if (x.sum % 2 == 0) x.reverse else x)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpe7kb8g4w.scala:20:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        array.sortWith(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x.sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) x.reverse \u001b[33melse\u001b[0m x)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029446
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // write your code in Scala\n        var sum : Long = 0\n        var result = array.mkString(\",\").split(\",\").toList.sortWith((x, y) => sum - y.toLong <= x.toLong - sum)\n        if (sum % 2 == 0) {\n            val newList = new ArrayBuffer[Long]()\n            for((i, n) <- array.zipWithIndex) {\n                if(i != n) {\n                    newList += n\n                }\n            }\n            result = newList.sortWith((x, y) => x.toLong > y.toLong)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5b2tvphl.scala:29:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = newList.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x.toLong > y.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    scala.collection.mutable.ArrayBuffer[Long]\n\u001b[31m   |\u001b[0m                    Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5b2tvphl.scala:31:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : List[String])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029452
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val numArray = array.size\n        if (numArray <= 1)\n            return array\n        val odd = array.take(numArray / 2)\n        val even = array.drop(numArray / 2)\n        if (odd.sum % 2 == 0)\n            odd.sortWith(_ < _)\n        else\n            even.sortWith(_ > _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx6_2n1p4.scala:32)\n\tat Problem.main(tmpx6_2n1p4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029452
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n      array.sortWith((x, y) => x < y ? -1 : x > y ? 1 : 0)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4he0rkhm.scala:19:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      array.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x < y ? -\u001b[31m1\u001b[0m : \u001b[35mx\u001b[0m \u001b[35m>\u001b[0m \u001b[35my\u001b[0m \u001b[35m?\u001b[0m \u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ')' expected, but ':' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4he0rkhm.scala:19:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      array.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x < y ? -\u001b[31m1\u001b[0m : \u001b[35mx\u001b[0m \u001b[35m>\u001b[0m \u001b[35my\u001b[0m \u001b[35m?\u001b[0m \u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type >\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4he0rkhm.scala:19:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      array.sortWith((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x < y ? -\u001b[31m1\u001b[0m : \u001b[35mx\u001b[0m \u001b[35m>\u001b[0m \u001b[35my\u001b[0m \u001b[35m?\u001b[0m \u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value ? is not a member of Long\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029451
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var newArray = array\n        val sumOfArray = newArray.sum\n        var evenSum = 0\n        var oddSum = 0\n        val evenArray = array.filter(x => x % 2 == 0).sorted\n        val oddArray = array.filter(x => x % 2 == 1).sorted\n        if (sumOfArray % 2 != 0) {\n            newArray = oddArray.sortWith(_ > _)\n            evenSum = evenArray.reduce((x,y) => x+y)\n            oddSum = oddArray.reduce((x,y) => x+y)\n            if (sumOfArray % 2 == 0) {\n                oddArray = evenArray.sortWith(_ < _)\n            }\n        }\n        else{\n            newArray = evenArray.sortWith(_ < _)\n            evenSum = evenArray.reduce((x,y) => x+y)\n            oddSum = oddArray.reduce((x,y) => x+y)\n            if (sumOfArray % 2 == 1) {\n                evenArray = oddArray.sortWith(_ > _)\n            }\n        }\n        newArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpss1f6eon.scala:27:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            evenSum = evenArray.reduce((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x+y)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpss1f6eon.scala:28:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            oddSum = oddArray.reduce((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x+y)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Long\n\u001b[31m   |\u001b[0m                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpss1f6eon.scala:30:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                oddArray = evenArray.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val oddArray\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpss1f6eon.scala:35:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            evenSum = evenArray.reduce((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x+y)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpss1f6eon.scala:36:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            oddSum = oddArray.reduce((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x+y)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Long\n\u001b[31m   |\u001b[0m                 ",
      "stdout": "",
      "timestamp": 1660029452
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Write your code here\n        array.sortWith(x => x._1 - x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpc21emhfp.scala:20:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        array.sortWith(\u001b[36mx\u001b[0m => x._1 - x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val ls = array.sorted\n        (ls(0) + ls(ls.size-1)).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppu4b2t4k.scala:20:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        (ls(\u001b[31m0\u001b[0m) + ls(ls.size-\u001b[31m1\u001b[0m)).toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Long\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029452
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val n = array.size\n        if (n % 2 == 0){\n            if (sumArrayEven(array) == 0){\n                array.sorted\n            }else {\n                array.sorted reverse \n            }\n        }else {\n            if (sumArrayOdd(array) == 0){\n                array.sorted\n            }else {\n                array.sorted reverse \n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp80784oe1.scala:24:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                array.sorted reverse \n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp80784oe1.scala:30:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                array.sorted reverse \n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp80784oe1.scala:21:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (sumArrayEven(array) == \u001b[31m0\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: sumArrayEven\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp80784oe1.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (sumArrayOdd(array) == \u001b[31m0\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: sumArrayOdd\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val pairs = array.zipWithIndex.sortWith((x, y) => x._2 < y._2) // O(nlogn) -> O(n) when sorted in ascending order\n        if (pairs.exists(_.last._1 % 2 == 1)) { // O(n) -> O(logn) when sorted in descending order\n            pairs.reverse.map(_._1)\n        } else {\n            pairs\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt259t_rf.scala:20:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (pairs.exists(_.last._1 % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m)) { \u001b[34m// O(n) -> O(logn) when sorted in descending order\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value _1 is not a member of Tuple.Last[(Long, Int)]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt259t_rf.scala:23:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            pairs\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mpairs\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mList[\u001b[1m\u001b[31m(\u001b[0mLong\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m)\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029453
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if(array.isEmpty) array\n        else {\n            val sumOfFirstElement = array.head\n            val sumOfLastElement = array.last\n            val isEven = sumOfFirstElement % 2 == 0 && sumOfLastElement % 2 == 0\n            val isOdd = sumOfFirstElement % 2 != 0 && sumOfLastElement % 2 != 0\n            if (isEven) array.sortBy(_ > sumOfLastElement)\n            else array.sortBy(_ < sumOfFirstElement)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9f8392vg.scala:32)\n\tat Problem.main(tmp9f8392vg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029454
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        val length = array.size\n        val result = new scala.collection.mutable.ArrayList[Long]()\n        // if array is empty or contains only one element, return array directly\n        if(array.size == 0 || array.size == 1){\n            return array\n        }\n        // traverse the array\n        for(i <- 0 until length){\n            sum += array[i]\n            if(sum == 1){\n                result += i\n            }\n            else if(sum == 0){\n                if(i != 0){\n                    result.remove(i)\n                }\n            }\n        }\n        return sortArray(result.sorted)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkvzjjwmv.scala:21:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m scala.collection.mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              type ArrayList is not a member of scala.collection.mutable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkvzjjwmv.scala:28:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            sum += array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkvzjjwmv.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            sum += array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029452
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum : Long = array.sum\n        val evenSum : Long = sum % 2\n\n        var evenCount : Long = 0\n        var oddCount : Long = 0\n\n        var i = 0\n\n        var currentArray = 0\n        while(i < array.size) {\n            val sumCurrent : Long = array[i]\n            val lastIndex = i + 1\n\n            val oddSumCurrent : Long = array.get(lastIndex).asInstanceOf[Long]\n\n            val evenSumCurrent : Long = array.get(i).asInstanceOf[Long]\n\n            val temp : Long = if (evenSumCurrent < evenSum) evenSumCurrent else evenSum\n\n            if (temp % 2 == 0 && oddSumCurrent >= oddSum) currentArray += 1\n            if (temp % 2 == 0 && oddSumCurrent < oddSum) currentArray -= 1\n\n            i += 2\n        }\n        if (evenCount != 0) {\n            currentArray = -currentArray\n        }\n        if (currentArray != 0) {\n            array.reverse\n        } else {\n            array\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3q1ct0ti.scala:29:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msumCurrent\u001b[0m : \u001b[35mLong\u001b[0m = array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3q1ct0ti.scala:32:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36moddSumCurrent\u001b[0m : \u001b[35mLong\u001b[0m = array.get(lastIndex).asInstanceOf[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[Long] - did you mean array.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3q1ct0ti.scala:34:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mevenSumCurrent\u001b[0m : \u001b[35mLong\u001b[0m = array.get(i).asInstanceOf[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3q1ct0ti.scala:38:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (temp % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m && oddSumCurrent >= oddSum) currentArray += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: oddSum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3q1ct0ti.scala:39:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b",
      "stdout": "",
      "timestamp": 1660029454
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) return array\n        val sum = array.reduceLeftOption(_ + _)\n        val odd = sum.getOrElse(0) % 2 != 0\n        val newArray = array.sortWith(_ > _)\n        if (odd)\n            newArray.reverse\n        newArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphxfo3qky.scala:21:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36modd\u001b[0m = sum.getOrElse(\u001b[31m0\u001b[0m) % \u001b[31m2\u001b[0m != \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue % is not a member of AnyVal, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029453
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        array.sortWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmporld33pq.scala:25)\n\tat Problem.main(tmporld33pq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660028982
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sumArray = array.foldLeft(0l.toLong)((sum, elem) => {\n            if(sum % 2 != 0) sum + elem else sum - elem\n        })\n        if(sumArray % 2 == 1) array.sortWith(_ > _) else array.sortWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8doy_hax.scala:28)\n\tat Problem.main(tmp8doy_hax.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029455
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var result = array\n        for(i <- 0 until array.size){\n            sum += i\n        }\n        if(sum.modulo(2)==1){\n            result <- (array.sortBy(_.toLong).reverse)\n        }\n        else{\n            result <- (array.sortBy(_.toLong))\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp2dpg14x_.scala:25:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            result <- (array.sortBy(_.toLong).reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                   end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp2dpg14x_.scala:28:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            result <- (array.sortBy(_.toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                   end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2dpg14x_.scala:24:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m(sum.modulo(\u001b[31m2\u001b[0m)==\u001b[31m1\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value modulo is not a member of Int\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029455
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        // Write your code here\n        if(array.head == 0l){\n            return array\n        }\n        val first = array\n        val last  = array.tail\n        val reuslt = first.head +last.head\n        val finalResult = if(reusld.toInt%2==1){\n            last.head + first\n        }else{\n            first.head + last.head\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2b83_yur.scala:26:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfinalResult\u001b[0m = \u001b[33mif\u001b[0m(reusld.toInt%\u001b[31m2\u001b[0m==\u001b[31m1\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: reusld\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp2b83_yur.scala:27:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            last.head + first\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments ((first : List[Long]))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2b83_yur.scala:32:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660029455
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val a = new mutable.ArrayBuffer(array)\n        val a2 = new Array[Long](a.length)\n        var sum = 0\n        var i = 0\n        var flag = 0\n        var n = 0\n        var j = 0\n        for (i <- a.iterator; j <- a.iterator) {\n            sum = sum + (a(j))\n            n += 1\n            if (sum % 2 == 0) {\n                flag = 0\n            } else {\n                flag = 1\n            }\n            flag = (a(j) > a(j + n)) | (a(j) < a(j + n))\n            if (flag == 1) {\n                a2(j) = a(j)\n            }\n        }\n        val b = new ListBuffer[Long]()\n        for (i<-0 until n){\n            b.add(a2(i))\n        }\n        return b.toList\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9_gr5bll.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer(array)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9_gr5bll.scala:41:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            b.add(a2(i))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value add is not a member of scala.collection.mutable.ListBuffer[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029456
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0l\n        var i = array.size\n        while (i-- > 0) {\n            sum += array[i]\n        }\n        var result: List[Long] = List()\n        if (sum % 2l.toLong != 0l.toLong) {\n            result = array.sortWith(_ < _)\n        } else {\n            result = array.sortWith(_ > _)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_jim1ktt.scala:21:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mwhile\u001b[0m (i-- > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_jim1ktt.scala:21:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mwhile\u001b[0m (i-- > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value -- is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jim1ktt.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mwhile\u001b[0m (i-- > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: >\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_jim1ktt.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum += array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jim1ktt.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            sum += array[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029457
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum =\n        array.foldLeft(0L){\n            (a: Long, b: Long) => a + b\n        }\n        if (sum % 2 ==0) {\n            array.sorted\n        } else {\n            array.sorted(Ordering[Long].desc)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps9tyj_bx.scala:26:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            array.sorted(Ordering[\u001b[35mLong\u001b[0m].desc)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value desc is not a member of Ordering[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029457
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0L\n        for(i <- array){\n            sum += i\n        }\n        val oddEven = sum.toInt % 2\n        val reverseOrder = sum.toInt / 2\n        val maxArray = array.max\n        if(oddEven == 1){\n            val sortedArray = array.sortWith((a: Long, b: Long)=>a>b)\n            return sortedArray.reverse\n        }else{\n            val sortedArray = array.sortWith((a: Long, b: Long)=>a>b).reverse\n            return sortedArray\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\tat Problem$.sortArray(tmpmv829hep.scala:25)\n\tat Problem$.main(tmpmv829hep.scala:35)\n\tat Problem.main(tmpmv829hep.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029458
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val coscala = array.groupBy(x => x).mapValues(x => x.toList)\n        val sortedArray = coscala.mapValues(xs => {\n            val sorted = xs.sorted\n            val first = sorted.head\n            val last = sorted.last\n            if (first.sum % 2 == 0 &&\n                last.sum % 2 == 0 &&\n                first.length > last.length) {\n                last.zip(last.drop(last.length - 1))\n            } else {\n                sorted.reverse.zip(sorted.reverse.drop(sorted.length - 1))\n            }\n        }).map(_._2).map(x => x.sorted)\n\n        //return sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc39dqxuf.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (first.sum % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m &&\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value sum is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc39dqxuf.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                last.zip(last.drop(last.length - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value zip is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc39dqxuf.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                last.zip(last.drop(last.length - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value drop is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc39dqxuf.scala:27:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                last.zip(last.drop(last.length - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value length is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc39dqxuf.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660029459
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = array.sum\n        val sorted = array.sorted\n        if(sum % 2 == 0) {\n            sorted.reverse\n        } else {\n            sorted\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmx4q2qyu.scala:31)\n\tat Problem.main(tmpmx4q2qyu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029459
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val a = array.sortBy(-_)\n        var sum = 0\n        var i = 0\n        var j = 0\n        var index = a.length - 1\n        while (sum % 2 != 0) {\n            sum += a(i)\n            i += 1\n        }\n        var left = sum\n        var right = sum\n        var last = a(index)\n        while (j < index) {\n            while (left <= right && a(j) < last) {\n                left += a(j)\n                j += 1 // skip the already sorted element\n            }\n            while (left <= right && a(j) >= last) {\n                right -= a(j)\n                j += 1 // skip the already sorted element\n            }\n            val temp = left\n            left = right\n            right = temp\n        }\n        return a.take(index) + a.drop(index)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx3_q83q_.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            sum += a(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx3_q83q_.scala:33:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                left += a(j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx3_q83q_.scala:37:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                right -= a(j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx3_q83q_.scala:44:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mreturn\u001b[0m a.take(index) + a.drop(index)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660029459
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var result : List[Long] = array\n        var sum : Long = 0\n        for (i <- 0 until result.length){\n            sum += result(i)\n        }\n        if (sum % 2l.toLong > 0l.toLong){\n            result = result.sortBy(x => -x).reverse\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpy0ttc0rf.scala:33)\n\tat Problem.main(tmpy0ttc0rf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660029459
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        var sum = 0\n        var max = array(0)\n        var index = array.size\n        while(index>0){\n            sum = sum + array.get(index-1)\n            if(sum%2==1){\n                max = array.get(index-1)\n                index = index-1\n            }else{\n                index = index-1\n            }\n        }\n        //reverse sort if odd sum\n        if(sum%2==1){\n            array.sortBy(x=> -x)\n        }\n        array\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1_o4wbyx.scala:23:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            sum = sum + array.get(index-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[Long] - did you mean array.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1_o4wbyx.scala:25:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                max = array.get(index-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660029459
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        val sum : List[Long] = array.toList\n        val length = sum.size\n        val odd = 1l.toLong / 2l.toLong\n        val even = 0l.toLong / 2l.toLong\n        if(sum.head % 2l.toLong > odd) sum.reverse\n        else sum.sort\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdznxdovz.scala:24:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33melse\u001b[0m sum.sort\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value sort is not a member of List[Long] - did you mean sum.sortBy?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029459
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list of non-negative integers, return a coscala of the given list after sorting,\n    // you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n    // or sort it in descending order if the sum( first index value, last index value) is even.\n    // Note:\n    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array : List[Long]) : List[Long] = {\n        if (array.isEmpty) array\n        else {\n            val sumOfFirstIndexValue = array.reduce(_ + _)\n            if (sumOfFirstIndexValue % 2 == 0) {\n                array.sorted\n            }\n            else {\n                array.sortedDescending\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvbokk708.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                array.sortedDescending\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value sortedDescending is not a member of List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660029459
    }
  ]
}