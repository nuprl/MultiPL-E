name: HumanEval_89_encrypt
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function encrypt that takes a string as an argument and\n    //\
  \ returns a string encrypted with the alphabet being rotated. \n    // The alphabet\
  \ should be rotated in a manner such that the letters \n    // shift down by two\
  \ multiplied to two places.\n    // For example:\n    // >>> encrypt((\"hi\"))\n\
  \    // (\"lm\")\n    // >>> encrypt((\"asdfghjkl\"))\n    // (\"ewhjklnop\")\n\
  \    // >>> encrypt((\"gf\"))\n    // (\"kj\")\n    // >>> encrypt((\"et\"))\n \
  \   // (\"ix\")\n    def encrypt(s : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
  lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
  gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n   \
  \ assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
  hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
  a\")).equals((\"e\")));\n    }\n\n}\n"
completions: ["        val alphabet = List(\"abcdefghijklmnopqrstuvwxyz\", \"ghijklmnopqrstuvwxyz\"\
    , \"nopqrstuvwxyzabcdef\")\n        var newStr = \"\"\n        for(i <- 0 until\
    \ s.length){\n            val a = alphabet(((i * 2) % alphabet.length))\n    \
    \        val b = alphabet(((i * 2 + 1) % alphabet.length))\n            val c\
    \ = alphabet(((i * 2 + 2) % alphabet.length))\n            val d = alphabet(((i\
    \ * 2 + 3) % alphabet.length))\n            newStr += a + b + c + d\n        }\n\
    \        newStr", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toList\n\
    \        val cipher = \"abcdefghijklmnopqrstuvwxyz\".toList ++ alphabet.drop(2).toList\n\
    \        val chars = s.toList\n        val rotatedChars = chars.zip(alphabet)\
    \ map { case (ch, a) => ch * 2 % a.size }\n        val result = chars.zip(cipher)\
    \ map { case (ch, c) => c }\n        rotatedChars mkString \"\"", "      var result\
    \ = \"\"\n      var count = 0\n      for (x <- s) {\n        count += 2\n    \
    \    result += ((count % 26) + 26) % 26 + x\n      }\n      result", "       \
    \ var alphabet = Seq(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"\
    j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"\
    w\",\"x\",\"y\",\"z\")\n        alphabet = alphabet.map(x => (x -> x)(alphabet.index(x)\
    \ + 2))\n        var newS = \"\"\n        for (i <- s.indices) {\n           \
    \ if (alphabet(alphabet(i))(0) != alphabet(i)) {\n                val a = alphabet(alphabet(i))(0)\n\
    \                val b = alphabet(alphabet(i))(1)\n                alphabet(i)\
    \ = a -> b\n            }\n            newS += alphabet(i)(1)\n        }\n   \
    \     newS", "        val alphabet = new scala.collection.mutable.ArraySeq(\n\
    \            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n            'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n            'u', 'v', 'w', 'x',\
    \ 'y', 'z'\n        )\n        s.toCharArray.zipWithIndex.sortBy(_._1).map { case\
    \ (c, i) =>\n            val l = math.min(alphabet.length - 1, alphabet.indexOf(c))\n\
    \            alphabet(l + 2)\n        }.mkString", "        val l = s.length\n\
    \        val map = scala.collection.mutable.Map[Char, Char]()\n        map.put('w',\
    \ 'm')\n        map.put('h', 'm')\n        map.put('f', 'm')\n        map.put('j',\
    \ 'm')\n        map.put('k', 'm')\n        map.put('l', 'm')\n        map.put('o',\
    \ 'm')\n        map.put('p', 'm')\n        map.put('b', 'm')\n        map.put('c',\
    \ 'm')\n        map.put('n', 'm')\n        map.put('q', 'm')\n        map.put('d',\
    \ 'm')\n        map.put('n', 'm')\n        map.put('m', 'm')\n        map.put('r',\
    \ 'm')\n        map.put('t', 'm')\n        map.put('s', 'm')\n        map.put('e',\
    \ 'm')\n        map.put('v', 'm')\n        map.put('g', 'm')\n        map.put('d',\
    \ 'm')\n        map.put('i', 'm')\n        map.put('o', 'm')\n        map.put('h',\
    \ 'm')\n        map.put('e', 'm')\n        map.put('n', 'm')\n        map.put('p',\
    \ 'm')\n        map.put('q', 'm')\n        map.put('c', 'm')\n        map.put('b',\
    \ 'm')\n        map.put('f', 'm')\n        map.put('z', 'm')\n        map.put('y',\
    \ 'm')\n        map.put('k', 'm')\n        map.put('x', 'm')\n        map.put('t',\
    \ 'm')\n        map.put('s', 'm')\n        map.put('v', 'm')\n        map.put('j',\
    \ 'm')\n        map.put('r', 'm')\n        map.put('h', 'm')\n        map.put('d',\
    \ 'm')\n        map.put('q', 'm')\n        map.put('m', 'm')\n        map.put('v',\
    \ 'm')\n        map.put('l', 'm')\n        map.put('x', 'm')\n        map.put('b',\
    \ 'm')\n        map.put('n', 'm')\n        map.put('f', 'm')\n        map.put('c',\
    \ 'm')\n        map.put('q', 'm')\n        map.put('o', 'm')\n        map.put('e',\
    \ 'm')\n        map.put('d', 'm')\n        map.put('v', 'm')\n        map.put('n',\
    \ 'm')\n        map.put('p', '", "        val l = s.length()\n        var c =\
    \ s.head\n        var alphabet = scala.collection.mutable.ListBuffer[String]()\n\
    \        alphabet += \"a\"\n        alphabet += \"b\"\n        alphabet += \"\
    c\"\n        alphabet += \"d\"\n        alphabet += \"e\"\n        alphabet +=\
    \ \"f\"\n        alphabet += \"g\"\n        alphabet += \"h\"\n        alphabet\
    \ += \"i\"\n        alphabet += \"j\"\n        alphabet += \"k\"\n        alphabet\
    \ += \"l\"\n        alphabet += \"m\"\n        alphabet += \"n\"\n        alphabet\
    \ += \"o\"\n        alphabet += \"p\"\n        alphabet += \"q\"\n        alphabet\
    \ += \"r\"\n        alphabet += \"s\"\n        alphabet += \"t\"\n        alphabet\
    \ += \"u\"\n        alphabet += \"v\"\n        alphabet += \"w\"\n        alphabet\
    \ += \"x\"\n        alphabet += \"y\"\n        alphabet += \"z\"\n\n        var\
    \ i = 0\n        while (i < l) {\n            c += alphabet(i % 6)\n         \
    \   i += 1\n        }\n        return c", "        val alphabet = mutable.ArrayBuffer.empty[String]\n\
    \        var temp = \"\"\n        for (c1 <- s)\n            temp += c1.toChar\n\
    \        for (c1 <- temp)\n            alphabet += c1.toChar\n\n        for (c1\
    \ <- alphabet)\n            alphabet = alphabet.toList ++ alphabet.toList.reverse\n\
    \n        var encr = s.toList\n        for (c1 <- alphabet)\n            encr\
    \ = encr.map(c1.toInt).map{\n                case e if e > 95 => e - 96\n    \
    \            case e if e < 65 => e - 64\n                case e => e\n       \
    \     }\n\n        encr.mkString.reverse", "        val c = s.map(x => x.toChar).toArray\n\
    \        c.map(c => (c + c) % 26).map(c => c.toChar).mkString", "        // Use\
    \ a mutable string to hold the result string.\n        var result = \"\"\n   \
    \     // Declare a mutable array to hold the letters in the string\n        var\
    \ letters = s.toCharArray\n        // Declare a mutable array to hold the letters\
    \ in the alphabet.\n        var alphabet = Array.fill[Char](26)( 'a' )\n     \
    \   // For each letter in the string, append it to the mutable array.\n      \
    \  letters.foreach { letter =>\n            alphabet += letter\n        }\n  \
    \      // Use a mutable counter to hold how many letters there are in the alphabet.\n\
    \        var count = 0\n        // Traverse the mutable array, adding letters\
    \ to the mutable result string\n        // as long as the alphabet has more letters\
    \ than count.\n        // If count has reached 26, we need to append the remaining\
    \ letters to the \n        // result string and move count down by one.\n    \
    \    while (count < 26) {\n            if (alphabet.size < count) {\n        \
    \        result += alphabet(0)\n                count -= 1\n            } else\
    \ {\n                result += alphabet(count)\n                count += 1\n \
    \           }\n        }\n        result", "        def encrypt (s: String) :\
    \ String = {\n            // Create the alphabet and store it in a list\n    \
    \        val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n\n            // Create\
    \ a list to hold the final encrypted string\n            val result = new mutable.ListBuffer[String]()\n\
    \n            // Start at the second letter in the alphabet\n            var c\
    \ = 2\n\n            // For every letter of the string\n            for (c <-\
    \ 2 until s.length) {\n                // If the letter is in the alphabet\n \
    \               if (alphabet.contains(s(c))) {\n                    // Find the\
    \ position of the letter in the alphabet\n                    val position = alphabet.indexOf(s(c))\n\
    \n                    // Add an extra letter to the end and rotate the letter\
    \ by two places\n                    result += alphabet.insert(position, alphabet(position\
    \ + 1))\n\n                }\n            }\n\n            // Return the result\
    \ string\n            result.mkString(\"\")\n        }\n\n        // Return an\
    \ empty string if the string isn't longer than 2 letters\n        if (s.length\
    \ < 2) {\n            return \"\"\n        }\n\n        // Otherwise\n       \
    \ encrypt(s)", "        val alphabet = List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        val alphabetReversed = List(\"\
    z\",\"y\",\"x\",\"w\",\"v\",\"u\",\"t\",\"s\",\"r\",\"q\",\"p\",\"o\",\"n\",\"\
    m\",\"l\",\"k\",\"j\",\"i\",\"h\",\"g\",\"f\",\"e\",\"d\",\"c\")\n        val\
    \ encryptedString = s.map(x=> alphabet(alphabet.indexOf(x) + 2).toChar).mkString\n\
    \        encryptedString.map(x=> alphabetReversed(alphabet.indexOf(x) - 2).toChar).mkString",
  "        val alphabet: Array[Char] = Array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z')\n        val newStringBuilder = new StringBuilder()\n        for (i\
    \ <- 0 until s.length){\n            val currentChar = s.charAt(i)\n         \
    \   val newChar = alphabet((alphabet.indexOf(currentChar) + 2) % alphabet.length)\n\
    \            newStringBuilder.append(newChar)\n        }\n        newStringBuilder.toString()",
  "      val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n      val result = new mutable.ListBuffer[String]()\n\
    \      for (xs <- s) {\n        val x = alphabet.indexOf(xs)\n        val shift\
    \ = x - (x + 1)\n        result.append((alphabet.take(shift) ++ alphabet.reverse\
    \ ++ alphabet.take(shift + 1)).mkString)\n      }\n      result.toString.reverse",
  "        var res = \"\"\n        var c = s.length -1\n        var a = ('A' to 'Z')\
    \ ++ (0 to 'Z' toList diff 'A')\n        for (i <- 0 until a.length) {\n     \
    \       res += a(i) + a(c+i)\n            c--\n        }\n        return res",
  "        if (s.length == 0)\n            return s\n        val newLetters = Array.fill(26)(0)\n\
    \        for (c <- s.toCharArray) {\n            newLetters(c - 'a' + 1) = c.toInt\n\
    \        }\n        var ret = \"\"\n        for (i <- newLetters.indices) {\n\
    \            val n = newLetters(i)\n            ret += (if (n % 2 != 0) \"a\"\
    \ else \"b\") + i.toChar\n        }\n        return ret", "        var newString\
    \ = \"\"\n        for(i<-0 to s.length-1){\n            var x = s.charAt(i)\n\
    \            var y = s.charAt(i+1)\n            newString = (x+y+(x+y)*2)\n  \
    \      }\n        newString", "        val alphabet = Array(\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\")\n        var i = 0\n        var j = 0\n        var encryptedString =\
    \ \"\"\n        while(i < s.length()) {\n            encryptedString += alphabet.apply(j+1)\
    \ + alphabet.apply(i)\n            i += 2\n            j += 1\n        }\n   \
    \     return encryptedString", "      var index = s.length - 1\n      var result\
    \ = \"\"\n      while (index >= 0) {\n        result += alphabet(index(index))\
    \ \n        index -= 2\n      }\n      return result", "       val result = new\
    \ StringBuilder(s.length)\n       for (letter <- s) {\n           result += (alphabet.indexOf((letter\
    \ + 65).toChar) + 2).toChar\n       }\n       result.toString()", "        //\
    \ Initialize an empty string that holds the encrypted string.\n        var encryptedString\
    \ = \"\"\n\n        // Initialize a variable (letter) that holds the first letter\
    \ of the alphabet in each string.\n        var letter = s.charAt(0)\n\n      \
    \  // Initialize a variable (count) that holds a counter that counts how many\
    \ times a letter is shifted down.\n        var count = 0\n\n        // For every\
    \ character in our string (excluding the first letter)\n        for (i <- 1 until\
    \ s.length)\n        {\n            // If letter is less than or equal to the\
    \ number of characters in the alphabet.\n            if (letter < s.length)\n\
    \            {\n                // Shift down count times.\n                count\
    \ += 2\n            }\n            // If letter is greater than the length, do\
    \ nothing.\n            else\n            {\n                // Increment the\
    \ counter by one.\n                count += 1\n            }\n\n            //\
    \ Add the letter to the string after the counter is decremented.\n           \
    \ encryptedString += s(count - letter)\n\n            // Reset the count to 0.\n\
    \            count = 0\n\n            // Increment the letter by one.\n      \
    \      letter += 1\n        }\n\n        // Return the encrypted string\n    \
    \    encryptedString", "      var result = \"\"\n      var s = \"\"\n      var\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      for(i\
    \ <- 1 to s.length){\n          result += alphabet.charAt(i -1) \n      }\n  \
    \    for(i <- s.length-1 downto 0){\n          s += alphabet(s.charAt(i) + alphabet(i+1))\n\
    \      }\n      for(i <- 1 to s.length){\n          result += alphabet.charAt(i\
    \ -1)\n      }\n      result", "        var result : String = \"\"\n        var\
    \ countLetters = 0\n        // Count the number of letters in the string\n   \
    \     for (i <- 0 until s.length) countLetters = countLetters + i\n        //\
    \ Create an array with the letters in correct order\n        var alphabet = new\
    \ Array[Char]((countLetters+1).toInt)\n        for (i <- 0 until countLetters)\
    \ alphabet(i) = s.charAt(i)\n        var temp : Int = 0\n        // Iterate through\
    \ the array and place the letters in the right position\n        for (i = 0 to\
    \ alphabet.length-1) {\n            // Shift the letters down by two \n      \
    \      for (j = 0 to alphabet.length-1) {\n                temp = (i+j) % alphabet.length\n\
    \                if (temp == i) {\n                    temp = temp-1\n       \
    \         }\n                if (temp == j) {\n                    temp = temp+1\n\
    \                }\n                if (temp == i) {\n                    result\
    \ = result + alphabet(temp)\n                }\n                if (temp == j)\
    \ {\n                    result = result + alphabet(j)\n                }\n  \
    \          }\n        }\n        result", "        val alphabet : Set[Char] =\
    \ Set('e','t','a','i','o','n','r','d','g','h','k','j','l','f','c','v','b')\n \
    \       var newString = \"\"\n        for (letters <- s)\n        {\n        \
    \  newString = newString + alphabet.apply(alphabet.size - alphabet.indexOf((letters\
    \ + '2').toChar.charAt(0))) * 2 \n        }\n        newString", "      val alphabet\
    \ = s.toUpperCase.filter(_ != 'A').map(_.toUpperCase).filter(_ != 'Z').map(_.toUpperCase)\n\
    \      alphabet match {\n        case Nil => s\n        case _ => s\"${alphabet.reverse.map(_\
    \ * 2).mkString}\"\n      }", "        val strChars = s.toCharArray\n        val\
    \ alpha = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        val alphaLen = alpha.length\n\
    \        val newAlpha = new Array[Char](alphaLen * 2)\n        var i = 0\n   \
    \     for (c <- strChars) {\n            newAlpha(i * 2) = alpha(i % alphaLen)\n\
    \            newAlpha(i * 2 + 1) = alpha(i % alphaLen)\n            i = i + 1\n\
    \        }\n        strChars.toList.map { c => newAlpha(alpha(c) % alphaLen) }.mkString",
  "      // Create a mutable array of 26 empty strings\n      val alphabet = Array.fill(26)(\"\
    \")\n      // Fill the array with empty strings with your alphabet\n      alphabet\
    \ :+= (\"a\" -> \"b\", \"b\" -> \"c\", \"c\" -> \"d\", \"d\" -> \"e\", \"e\" ->\
    \ \"f\", \"f\" -> \"g\", \"g\" -> \"h\", \"h\" -> \"i\", \"i\" -> \"j\", \"j\"\
    \ -> \"k\", \"k\" -> \"l\", \"l\" -> \"m\", \"m\" -> \"n\", \"n\" -> \"o\", \"\
    o\" -> \"p\", \"p\" -> \"q\", \"q\" -> \"r\", \"r\" -> \"s\", \"s\" -> \"t\",\
    \ \"t\" -> \"u\", \"u\" -> \"v\", \"v\" -> \"w\", \"w\" -> \"x\", \"x\" -> \"\
    y\", \"y\" -> \"z\", \"z\" -> \"\")\n      val r = new scala.util.Random\n   \
    \   // Encrypt your string\n      val result = new StringBuilder(s.length)\n \
    \     for (i <- 0 until s.length) {\n        val index = alphabet.indexOf(s(i).toChar)\n\
    \        if (index != -1) {\n          val offset = scala.math.abs(r.nextInt)\
    \ % 26\n          val newIndex = (index + offset) % 26\n          alphabet(index)\
    \ = alphabet(newIndex)\n        }\n        result.setCharAt(i, alphabet(i))\n\
    \      }\n      result.toString", "        val alphabet = List(\"a\",\"b\",\"\
    c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"\
    p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        val\
    \ alphaMap = mutable.Map.empty[String, Int]\n        for(letter <- alphabet){\n\
    \            alphaMap += (letter -> (alphabet.index(letter) + 1))\n        }\n\
    \        for(i <- 0 to s.length - 1){\n            val s1 = alphabet.indexOf(s.charAt(i))\n\
    \            val s2 = alphabet.indexOf(s.charAt(i+1))\n            val t = (alphaMap(s1)\
    \ + (s2) * 2) + alphaMap(s2)\n            alphaMap(s1) = t\n            alphaMap(s2)\
    \ = t\n        }\n        alphaMap.values.map(alphabet(_)).mkString", "      \
    \  val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val output = new StringBuilder\n\
    \n        // Rotate letters down by 2\n        for (i <- alphabet.indices) {\n\
    \            val l = alphabet(i)\n            val r = alphabet(i + 1)\n      \
    \      output.append (alphabet(i + 2) * l.charAt(0) - alphabet(i + 1) * r.charAt(0)\
    \ - alphabet(i) * l.charAt(1) - alphabet(i + 1) * r.charAt(1))\n        }\n\n\
    \        // Rotate letters down by 2\n        for (i <- output.indices) {\n  \
    \          val l = output(i)\n            val r = output(i + 1)\n            output.append\
    \ (alphabet(i + 2) * l.charAt(0) - alphabet(i + 1) * r.charAt(0) - alphabet(i)\
    \ * l.charAt(1) - alphabet(i + 1) * r.charAt(1))\n        }\n\n        output.toString",
  "        var newString = \"\"\n        var i = 0\n        while (i < s.length())\
    \ {\n            val l = s(i)\n            val j = (i + 1) / 2\n            newString\
    \ += s(j)\n            i += 2\n        }\n        newString", "        val chars\
    \ = s.toCharArray\n        val size = chars.length\n\n        // Set initial rotation\
    \ state\n        var alpha = 2\n        // Set rotation index by 2 for each letter\n\
    \        var index = 0\n\n        // Start iterating through each letter in the\
    \ string\n        var encryptedChar = chars(index)\n        var j = 0\n      \
    \  while (j < size) {\n            val nextChar = chars(index + j)\n         \
    \   // Rotate letter if required\n            val rotatedChar = if (nextChar !=\
    \ encryptedChar) {\n                val newIndex = (index + j) * 2\n         \
    \       if (alpha > 26) alpha = alpha * -1\n                val rotatedChar =\
    \ chars(newIndex)\n                alpha = alpha + 2\n                newIndex\n\
    \            } else nextChar\n            // Update rotated letter\n         \
    \   encryptedChar = rotatedChar\n            j = j + 1\n        }\n        encryptedChar.toString",
  "        val alphabet = Array('z' -> 'y' -> 'a' -> 'b' -> 'c' -> 'd' -> 'e' -> 'f'\
    \ -> 'g' -> 'h' -> 'i' -> 'j' -> 'k' -> 'l' -> 'm' -> 'n' -> 'o' -> 'p' -> 'q'\
    \ -> 'r' -> 's' -> 't' -> 'u' -> 'v' -> 'w' -> 'x' -> 'y' -> 'z')\n        s =\
    \ s.toLowerCase // change to lowercase to simplify our code\n        val result\
    \ = new collection.mutable.StringBuilder\n        val temp = new collection.mutable.ListBuffer[Int]()\n\
    \        for (i <- 1 to s.length) { \n            val c = s(i)\n            val\
    \ a = alphabet(c)\n            val b = a(0) \n            val c = a(1) \n    \
    \        result append (b) \n            temp += b\n            result append\
    \ (c) \n            temp += c\n        }\n        result append alphabet(temp.last)\n\
    \        result.mkString", "      var newS = \"\"\n      var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n      for( i <- 0 until s.length ) {\n        newS += alphabet.charAt(alphabet.indexOf(\
    \ s.charAt(i) ) - 2)\n      }\n      return newS", "        val letters = s.toCharArray\n\
    \        val rotatedLetters = Array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\",\
    \ \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\")\n    \
    \    val encryptedLetters = mutable.ArrayBuffer.empty[String]\n        for (i\
    \ <- 0 to letters.length - 1)\n            encryptedLetters += (rotatedLetters(letters(i)\
    \ + 2).toChar)\n        encryptedLetters.mkString.toUpperCase", "      val alphabet\
    \ = List(\" \" , \"z\" , \"x\" , \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\"\
    \ , \"g\" , \"h\" , \"i\" , \"j\" , \"k\" , \"l\" , \"m\" , \"n\" , \"o\" , \"\
    p\" , \"q\" , \"r\" , \"s\" , \"t\" , \"u\" , \"v\" , \"w\" , \"x\" , \"y\" ,\
    \ \"z\" ).reverse\n      var ret = \"\"\n      for(i <- s.length - 1){\n     \
    \   val first = alphabet(alphabet.indexOf(s.charAt(i)))\n        val last = (alphabet(alphabet.indexOf(s.charAt(i)+1))).zipWithIndex\n\
    \        val firstInd = last._2.next\n        val lastInd = firstInd + 1\n   \
    \     ret += s.charAt(i) + alphabet(firstInd) + alphabet(lastInd)\n      }\n \
    \     return ret", "        val alphabet = Array(\n            'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n            'k', 'l', 'm', 'n', 'o', 'p',\
    \ 'q', 'r', 's', 't',\n            'u', 'v', 'w', 'x', 'y', 'z'\n        )\n \
    \       val alphabetWithTwoShift = Array(\n            'c', 'd', 'f', 'h', 'g',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n            'u', 'v',\
    \ 'w', 'x', 'y', 'z'\n        )\n        val alphabetWithTwoShift2 = Array(\n\
    \            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n            'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n            'u', 'v', 'w', 'x',\
    \ 'y', 'z'\n        )\n        val alphabetWithOneShift = Array(\n           \
    \ 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v',\n            'w', 'x', 'y', 'z'\n       \
    \ )\n        val alphabetWithOneShift2 = Array(\n            'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i',\n            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's',\n            't', 'u', 'v', 'w', 'x', 'y', 'z'\n        )\n\n    \
    \    // Create an empty string\n        var result = \"\"\n\n        // Iterate\
    \ through each character in string, add to result string, \n        // and rotate\
    \ the letters into the correct place\n        for (char <- s) {\n            result\
    \ += alphabet(alphabet.indexOf(char)) + alphabet(alphabet.indexOf(char) + 2)\n\
    \            result += alphabet(alphabet.indexOf(char) + 1) + alphabet(alphabet.indexOf(char)\
    \ + 3)\n            result += alphabet(alphabet.indexOf(char) + 1) + alphabet(alphabet.indexOf(char)\
    \ + 4)\n            result += alphabet(alphabet.indexOf(char) + 2) + alphabet(alphabet.indexOf(char)\
    \ + 5)\n        }\n\n        // Remove the first and last character\n        result\
    \ = result.subString(1, result.length - 1)\n\n        // Append alphabetWithTwoShift\
    \ to the result\n        result += alphabetWithTwoShift(alphabet.indexOf(result.charAt(0)))\n\
    \        result += alphabetWithTwoShift(alphabet.indexOf(result.charAt(result.length\
    \ - 1)))\n\n        // Append alphabetWithOneShift to the result\n        result\
    \ += alphabetWithOneShift(alphabet.indexOf(result.charAt(result.length - 2)))\n\
    \        result += alphabetWithOneShift(alphabet.indexOf(result.charAt(result.length\
    \ - 3)))\n\n        // Append alphabetWithTwoShift2 to the result\n        result\
    \ += alphabetWithTwoShift2(alphabet.indexOf(result.charAt(result.length - 4)))\n\
    \        result += alphabetWithTwoShift2(alphabet.indexOf(result.charAt(result.length\
    \ - 5)))\n\n        // Append alphabetWithOneShift2 to the result\n        result\
    \ += alphabet", "        var i = 0\n        val letters = Array(\n           \
    \ \"abcdefghijklmnopqrstuvwxyz\", \n            \"nopqrstuvwxyzabcdefghij\", \n\
    \            \"pqrstuvwxyzabcdefghijklm\", \n            \"uvwxyzabcdefghijklmnop\"\
    , \n            \"vwxyzabcdefghijklmnopq\", \n            \"wxyzabcdefghijklmnopqr\"\
    , \n            \"xyzabcdefghijklmnopqrs\")\n\n        val numLetters = letters.size\n\
    \        val numPermutations = numLetters-1\n        var result = ''\n       \
    \ while (i < s.length) { \n            // Shift the letters down by two\n    \
    \        val rotated = letters(i)\n            val shiftedLetter = rotated.charAt(0)\n\
    \            val shiftedLetterCode = letters.indexOf(shiftedLetter)\n        \
    \    shiftedLetterCode match {\n                case -1 => result += shiftedLetter\n\
    \                case i => result += shiftedLetter.charAt(i)\n            }\n\
    \            i = i + 1\n        }\n        return result", "        val alphabet\
    \ = (('A' to 'Z') ++ ('A' to 'Z') ++ ('A' to 'Z')).toList\n        val newAlphabet\
    \ = mutable.ListBuffer[Char]()\n        var i = 0\n        while (i < s.length())\
    \ {\n            newAlphabet += alphabet.take(2).toList\n            newAlphabet\
    \ += alphabet.drop(2).toList\n            i += 1\n        }\n        newAlphabet.mkString(\"\
    \").dropRight(1)", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toList\n\
    \        val newAlphabet = alphabet.reverse.tail.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.zip(newAlphabet).map(x => x._1 + \"-\" + x._2).mkString\n\
    \        newString", "        // initialize alphabet\n        val alphabet = List(\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\")\n        // initialize rotation (counter) variable\n\
    \        val rotation = 7\n        // initialize string to be encrypted\n    \
    \    val encrypted = s\n        // loop through each character of the string to\
    \ encrypt and encrypt it\n        // each time through the loop, the character\
    \ is shifted down two spaces\n        // from the current position\n        for\
    \ (i <- 0 until encrypted.length()) {\n            // rotate character at position\
    \ i\n            val currentChar = encrypted(i)\n            // move current character\
    \ to next position (i+2) (+2 since we shift\n            // down two positions)\n\
    \            encrypted(i) =  alphabet((alphabet.indexOf(currentChar)-rotation)*2+rotation)\n\
    \        }\n        // return the encrypted string\n        encrypted", "    \
    \    val alphabet = List(\n            \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\n        )\n \
    \       val rev = alphabet.reverse\n        val first = alphabet(1)\n        val\
    \ last = alphabet(alphabet.length-1)\n        val pairs = scala.collection.mutable.Map[String,\
    \ String]()\n        val news = scala.collection.mutable.List[String]()\n    \
    \    s.chars.foreach(c => {\n            pairs(rev(c)) = rev(c.toLowerCase)\n\
    \        })\n        val rotate = pairs.take(alphabet.length).filter(_._1 == first).toList.sortBy(_._1.toInt)\n\
    \        val rotatedPairs = rotate.flatMap(pairs.updated(_, _._2))\n        rotatedPairs.foreach\
    \ {\n            case (k,v) => news += (s\"$v$k\")\n        }\n        news.mkString(\"\
    \")", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val map = new mutable.HashMap[String, String]()\n        for(c <- alphabet)\
    \ map(c.toString) = c.toString\n        s.map(c => map.get(c))", "        // TODO:\
    \ Implement this function\n        // This function should only change the characters\
    \ of the given string\n        // by rotating them to the right by one and adding\
    \ two to their place\n        ", "        var x = s.length\n        while (x >\
    \ 0) {\n            val r = x % 2\n            if (r == 0) x /= 2\n          \
    \  else x /= 2\n            x = x - 1\n        }\n        if (x < 1)\n       \
    \     \"\"\n        else\n            s.reverse.foldRight(s.reverse) { \n    \
    \            case (\"\", x) => (x % 2).toChar + \"\"\n                case (\"\
    \", y) => (y % 2).toChar + \"\"\n                case (xs, \"\") => (xs % 2).toChar\
    \ + \"\"\n                case (\"\", z) => (z % 2).toChar + \"\"\n          \
    \      case (xs, y) => xs.toChar + y.toChar\n            }", "        val alphabet\
    \ = mutable.ArrayBuffer( /* H */ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z')\n        val letters = mutable.ListBuffer( /* H */ 'H', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z')\n        val l =\
    \ s.toList\n        val newL = l.map(x => {\n            if(alphabet.contains(x))\n\
    \                letters.last\n            else if(letters.nonEmpty)\n       \
    \         letters.last\n            else\n                alphabet.last\n    \
    \    }).distinct\n        newL.toArray", "        val alphabet = List('a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z').map(c => c * 2).map(c => c / 2)\n  \
    \      val result = s.toLowerCase\n            .foldLeft(\"\") { (res, c) =>\n\
    \                val p = alphabet.indexWhere(c => c % 2 == 0)\n              \
    \  alphabet.indexWhere(c => c % 2 != 0) match {\n                    case -1 =>\
    \ res + c\n                    case index =>\n                        val r =\
    \ alphabet.indexWhere(c => c % 2 != 0)\n                        alphabet(index\
    \ - p + r) match {\n                            case alphabet(c) => res + c\n\
    \                            case _ => res + c\n                        }\n  \
    \              }\n            }\n        result", "        s.map(x => ((x.toChar).asInstanceOf[Int])+(1))\n\
    \        .map(x => (x.toChar).asInstanceOf[Int]-2)\n        .reverse.map(x =>\
    \ (x.toChar).asInstanceOf[Int]-2)\n        .map(x => (x.toChar).asInstanceOf[Int])\n\
    \        .reverse\n        .reduceLeft((x1,x2) => x1+x2).reverse.map(x => (x.toChar).asInstanceOf[Int]-2)",
  "        val c = s.toCharArray\n        var i = 1\n        var s = \"\"\n      \
    \  while(i < c.length) {\n            val x = c(i).toInt\n            val y =\
    \ 2 * x + 2\n            c(i) = Character.valueOf((y - x).toChar)\n          \
    \  s += c(i)\n            i += 1\n        }\n        return s", "        val alphabet\
    \ : scala.collection.mutable.ListBuffer[String] = ListBuffer(\"a\",\"b\",\"c\"\
    ,\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"\
    ,\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        val alphabetCount\
    \ : scala.collection.mutable.Map[String,Int] = Map(\"a\" -> 1, \"b\" -> 1, \"\
    c\" -> 1, \"d\" -> 1, \"e\" -> 1, \"f\" -> 1, \"g\" -> 1, \"h\" -> 1, \"i\" ->\
    \ 1, \"j\" -> 1, \"k\" -> 1, \"l\" -> 1, \"m\" -> 1, \"n\" -> 1, \"o\" -> 1, \"\
    p\" -> 1, \"q\" -> 1, \"r\" -> 1, \"s\" -> 1, \"t\" -> 1, \"u\" -> 1, \"v\" ->\
    \ 1, \"w\" -> 1, \"x\" -> 1, \"y\" -> 1, \"z\" -> 1)\n        val alphabetIndex\
    \ : scala.collection.mutable.Map[String,Int] = Map(\"a\" -> 0, \"b\" -> 1, \"\
    c\" -> 2, \"d\" -> 3, \"e\" -> 4, \"f\" -> 5, \"g\" -> 6, \"h\" -> 7, \"i\" ->\
    \ 8, \"j\" -> 9, \"k\" -> 10, \"l\" -> 11, \"m\" -> 12, \"n\" -> 13, \"o\" ->\
    \ 14, \"p\" -> 15, \"q\" -> 16, \"r\" -> 17, \"s\" -> 18, \"t\" -> 19, \"u\" ->\
    \ 20, \"v\" -> 21, \"w\" -> 22, \"x\" -> 23, \"y\" -> 24, \"z\" -> 25)\n     \
    \   val alphabetShiftIndex : scala.collection.mutable.Map[String,Int] = Map(\"\
    a\" -> 1, \"b\" -> 2, \"c\" -> 3, \"d\" -> 4, \"e\" -> 5, \"f\" -> 6, \"g\" ->\
    \ 7, \"h\" -> 8, \"i\" -> 9, \"j\" -> 10, \"k\" -> 11, \"l\" -> 12, \"m\" -> 13,\
    \ \"n\" -> 14, \"o\" -> 15, \"p\" -> 16, \"q\" -> 17, \"r\" -> 18, \"s\" -> 19,\
    \ \"t\" -> 20, \"u\" -> 21, \"v\" -> 22, \"w\" -> 23, \"x\" -> 24, \"y\" -> 25,\
    \ \"z\" -> 26)\n        val alphabetShiftIndexInverted : scala.collection.mutable.Map[String,Int]\
    \ = Map(\"a\" -> 0, \"b\" -> 1, \"c\" -> 2, \"d\" -> 3, \"e\" ", "        var\
    \ newS = \"\"\n        for (x <- s)\n            newS +=  rotateChar((x - 'a')\
    \ + ((x - 'a') << 2) + ((x - 'a') << 4) + ((x - 'a') << 6) + ((x - 'a') << 8)\
    \ + ((x - 'a') << 10))\n        newS", "        val alphabet = ('A' to 'Z') ++\
    \ ('a' to 'z') ++ ('0' to '9')\n        val newS = s.toUpperCase().map(c => alphabet(alphabet.indexOf(c)\
    \ + 2))\n        newS.reverse", "        val a = s.toCharArray\n        val n\
    \ = a.length\n        val m = n%4\n        if (m == 0) a.slice(1, n-1) ++ (2 until\
    \ n-1).map{_+1} ++ a.slice(0, n-1).map{_-1}.toArray\n        else a.slice(1, n-1).map{_+1}\
    \ ++ (0 until m).map{_-1}.toArray ++ (0 until m).map{_+1} ++ (2 until n-1).map{_-1}.toArray",
  "        var alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        alphabet\
    \ = Array.copy(alphabet, 0, alphabet.slice(1, alphabet.length) + alphabet)\n \
    \       alphabet = Array.copy(alphabet, 0, alphabet.slice(-1, alphabet.length))\n\
    \        var result = \"\"\n        for(c <- s) {\n            result += alphabet(alphabet.indexOf(c.toString.toUpperCase))\n\
    \        }\n        return result", "        // Complete the code below to implement\
    \ the function encrypt\n        // HINT: You should use recursion to solve this\
    \ problem", "        val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val\
    \ letters = Array(alphabet.map(_.toChar))\n        val newAlphabet = alphabet.map(_.toChar).reverse\n\
    \        val newLetters = letters.map(_.toChar).reverse\n        val news = newAlphabet.zip(newLetters).map\
    \ {\n            case (str, str2) =>\n                if (str.charAt(0) == str2.charAt(0))\n\
    \                str + str2.substring(1)\n                else str2.substring(0,\
    \ 1) + str\n        }\n        val newEncrypted: Array[String] = Array(s.toCharArray).zip(news).map\
    \ {\n            case (str, str2) =>\n                if (str.charAt(0) == str2.charAt(0))\n\
    \                str + str2.substring(1)\n                else str2.substring(0,\
    \ 1) + str\n        }\n        newEncrypted.mkString.reverse", "        val alphabet\
    \ = \n            List(\n                'z','y','x','w','v','u','t','s','r','q','p','o','n',\n\
    \                'm','l','k','i','j','h','g','f','e','d','c','b','a'\n       \
    \     ).toList\n        val rotations = \n            List(\n                -3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,\n\
    \                24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,\n\
    \                47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,\n\
    \                70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,\n\
    \                92,93,94,95,96,97,98,99\n            )\n        val enc = s.foldLeft(\"\
    \")((acc, ch) => {\n            val idx = alphabet.indexOf(ch) + rotation(rotation(alphabet.indexOf(ch)))\n\
    \            acc + alphabet(idx)\n        })\n        enc", "        val alphabet\
    \ = Array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"\
    l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"\
    y\",\"z\")\n        val cipher = new scala.collection.mutable.HashMap[String,\
    \ String]()\n        for(i <- 0 until s.length){\n            val c = s.charAt(i)\n\
    \            cipher.put(alphabet(c), alphabet(c + 1))\n        }\n        cipher.toList.map(_._2).mkString",
  '        s.zip(Iterator.from(2)).flatMap(t => encrypt(t._1, t._2))', "        val\
    \ str : StringBuilder = new StringBuilder\n        val alphabet = Array(\"a\"\
    ,\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\"\
    ,\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n  \
    \      var i = 0\n        var j = 0\n        for(i <- 0 until s.length){\n   \
    \         for(j <- 0 until alphabet.length){\n                if(alphabet(j) ==\
    \ s.charAt(i)){\n                    str.append(alphabet(j+2))\n             \
    \       break\n                }\n            }\n        }\n        return str.toString()",
  "        val l = s.length\n        val alphabet = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet = alphabet + s.charAt(i)\n\
    \        }\n        val alphabet2 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet2 = alphabet2 + alphabet.charAt(i)\n\
    \        }\n        val l = alphabet2.length\n        val alphabet3 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet3 = alphabet3 + alphabet2.charAt(i)\n\
    \        }\n        val l = alphabet3.length\n        val alphabet4 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet4 = alphabet4 + alphabet3.charAt(i)\n\
    \        }\n        val l = alphabet4.length\n        val alphabet5 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet5 = alphabet5 + alphabet4.charAt(i)\n\
    \        }\n        val l = alphabet5.length\n        val alphabet6 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet6 = alphabet6 + alphabet5.charAt(i)\n\
    \        }\n        val l = alphabet6.length\n        val alphabet7 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet7 = alphabet7 + alphabet6.charAt(i)\n\
    \        }\n        val l = alphabet7.length\n        val alphabet8 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet8 = alphabet8 + alphabet7.charAt(i)\n\
    \        }\n        val l = alphabet8.length\n        val alphabet9 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet9 = alphabet9 + alphabet8.charAt(i)\n\
    \        }\n        val l = alphabet9.length\n        val alphabet10 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet10 = alphabet10 + alphabet9.charAt(i)\n\
    \        }\n        val l = alphabet10.length\n        val alphabet11 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet11 = alphabet11 + alphabet10.charAt(i)\n\
    \        }\n        val l = alphabet11.length\n        val alphabet12 = scala.collection.mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until l) {\n            alphabet12 = alphabet12 + alphabet11.charAt(i)\n\
    \        }\n        val l = alphabet12.length\n        val ", '        // Your
    code here', "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var\
    \ result = \"\"\n        for (x <- s) {\n            result += alphabet.substring(alphabet.indexOf(x)\
    \ + 2, alphabet.indexOf(x) + 3).toUpperCase\n        }\n        return result",
  "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        val\
    \ rotatedAlphabet = rotated_alphabet(alphabet)\n        val result = s.toCharArray.zip(rotatedAlphabet).map(c\
    \ => c.mkString(\"\"))\n        new String(result)", "      var index = 0\n  \
    \    var alpha = \"abcdefghijklmnopqrstuvwxyz\".toArray\n      val newString =\
    \ new StringBuilder\n      while (index != s.length) {\n          val c = s.charAt(index)\n\
    \          val index = alpha.indexOf(c)\n          val newIndex = index + 2\n\
    \          if (newIndex < alpha.length) newString.append(alpha(newIndex))\n  \
    \    }\n      return newString.toString", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var result = \"\"\n        for (i <- 0 until s.length - 1) {\n     \
    \       val c = alphabet.indexOf(s(i + 1))\n            val a = alphabet.indexOf(s(i\
    \ + 2))\n            val b = alphabet.indexOf(s(i + 3))\n            if (c < 0\
    \ || c >= alphabet.length || a < 0 || a >= alphabet.length || b < 0 || b >= alphabet.length)\n\
    \                throw new IllegalArgumentException(\"String contains invalid\
    \ character\")\n            val shift = Math.min(c, Math.min(a, b))\n        \
    \    result += alphabet(shift)\n        }\n        return result", "        val\
    \ newStringBuilder = new StringBuilder\n        var i = 1\n        while(i <=\
    \ s.length){\n          newStringBuilder.append(s.charAt(i).rotate(2 * i).drop(1).take(2))\n\
    \          i += 1\n        }\n        newStringBuilder.toString()\n      }\n}\n\
    </code>\n<|/ a dscore=0 tags=scala,string,algorithm,java |>\n<| a |>\nIn Scala\
    \ 2.13, the solution does not use mutable collections, as was suggested by Dave's\
    \ answer.\n<code>\ndef encrypt(str: String): String =\n  if (str.isEmpty) \"\"\
    \n  else {\n    val l = str.size\n    val newStr = str.head +\n      if (str.size\
    \ == 2) str.tail\n      else str.tail +\n        if (str.size == 3) str.tail.rotate(2)\n\
    \        else str.tail.drop(1) +\n          if (str.size == 4) str.tail.rotate(3)\n\
    \          else str.tail.drop(1) + str.tail.drop(2)\n    newStr +\n      if (str.size\
    \ == l) str.tail\n      else str.tail +\n        if (str.size == l + 1) str.tail.rotate(2)\n\
    \        else str.tail.drop(1) +\n          if (str.size == l + 2) str.tail.rotate(3)\n\
    \          else str.tail.drop(1) + str.tail.drop(2)\n  }\n</code>\n<|/ a dscore=0\
    \ tags=scala,string,algorithm,java |>\n<| a tags=scala,string,algorithm,java |>\n\
    In Scala 2.13, you can use rotateLeft method\n<code>\ndef encrypt(str: String):\
    \ String = str match {\n  case \"\" => \"\"\n  case s if (s.length <= 1) => s\n\
    \  case s if (s.length <= 2) => s.charAt(0) + s.charAt(1)\n  case s if (s.length\
    \ <= 3) => s.charAt(0) + s.charAt(1) + s.charAt(2).rotateLeft(1)\n  case s if\
    \ (s.length <= 4) => s.charAt(0) + s.charAt(1) + s.charAt(2).rotateLeft(1) + s.charAt(3).rotateLeft(1)\n\
    \  case s if (s.length <= 5) => s.charAt(0) + s.charAt(1) + s.charAt(2).rotateLeft(1)\
    \ + s.charAt(3).rotateLeft(1) + s.charAt(4).rotateLeft(1)\n  case s if (s.length\
    \ <= 6) => s.charAt(0) + s.charAt(1) + s.charAt(2).rotateLeft(1) + s.charAt(3).rotateLeft(1)\
    \ + s.charAt(4).rotateLeft(1) + s.charAt(5).rotateLeft(1)\n  case s if (s.length\
    \ <= 7) => s.charAt(0) + s.charAt(1) + s.charAt(2).rotateLeft(1) + s.charAt(3).rotateLeft(1)\
    \ + s.charAt(4).rotate", "        def rotations(s : String) : List[String] = s.split(\"\
    (?<!^)(?!$)\").filter(_ != \"\").toList\n        def shift(s : String, shift :\
    \ Int) : List[String] = s.splitAt(s.length - shift).map(_.swap).reverse\n    \
    \    def rotater(s : List[String], shift : Int) : List[String] = {\n         \
    \   val l = s.toList\n            var rotatedList : List[String] = l.take(l.padTo(s.length\
    \ + shift, \" \"))\n            while (rotatedList.length > 0) {\n           \
    \     rotatedList ::= shift(rotatedList, shift)\n                shift += 2\n\
    \            }\n            rotatedList\n        }\n        rotations(s).map(x\
    \ => rotater(rotations(x), s.length)).mkString(\"\")", "        def rotator(x:\
    \ String, y: String) : String = {\n            if (x.length==0) y\n          \
    \  else {\n                val i = x.indexOf(y);\n                val z = x.substring(0,\
    \ i);\n                val y = x.substring(i+1, x.length);\n                rotator(z,\
    \ y);\n            }\n        }\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');\n\
    \        val rotated = alphabet.map(x => rotator(s, x)).sorted;\n        val rotate\
    \ = rotated.map(x => x.toUpperCase);\n        rotate.mkString(\"\")", "      \
    \  val alphabet = (\"abcdefghijklmnopqrstuvwxyz\").map(x => x.toUpperCase).reverse\n\
    \        s.foldLeft((\"\", \"\")) { case ((firstChar, secondChar), (i, j)) =>\n\
    \            val (newChar, newFirstChar) = alphabet map {\n                case\
    \ a if i == j => alphabet((i + 2) % (alphabet.length - 1)) + a\n             \
    \   case a => a\n            }\n            (newChar, newFirstChar)\n        }._1",
  "        val alphabet: Vector[Char] = ('A' to 'Z') ++ ('a' to 'z') ++ (0 to 9)\n\
    \        s.toList map {alphabet(_) }.toVector map {alphabet.apply(_) }", "   \
    \     var letters = s.toCharArray\n        var newletters = mutable.ArrayBuffer(letters)\n\
    \        while(newletters.length < letters.length){\n            newletters =\
    \ newletters :+ newletters(newletters.length * 2-1)\n        }\n        newletters.toString.toCharArray",
  "        // Convert the string to an array of characters \n        val aChars =\
    \ s.toCharArray\n        // Reverse the array\n        aChars.reverse()\n    \
    \    // Create a new array of the correct size\n        val newChars = new Array[Char](aChars.length\
    \ + 2)\n        // Copy the characters from the old array into the new array\n\
    \        newChars.copyToArray(aChars)\n        // Add the letters e and o to the\
    \ end of the array\n        newChars(newChars.length - 1) = 'e'\n        newChars(newChars.length)\
    \ = 'o'\n        // Convert the new array back to a string and return\n      \
    \  s.toCharArray().toList.map(_.toChar).mkString.reverse", "        val alphabet\
    \ = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n        var result = \"\"\n        for (letter\
    \ <- alphabet) {\n            if (letter != s.charAt(0)) {\n                result\
    \ += letter\n            }\n        }\n        return result", "        var t\
    \ = s.toCharArray\n        var l = 1\n        for (i <- 0 until t.length) {\n\
    \            var x = t(i)\n            var y = t((i+l) % t.length)\n         \
    \   var z = x + y\n            t += z\n        }\n        t.mkString", "     \
    \   val alphabet = (\"abcdefghijklmnopqrstuvwxyz\").zipWithIndex\n        val\
    \ newAlphabet = mutable.Map[String,Int]()\n        (for (letter <- alphabet; val\
    \ i = letter._2) yield {\n            newAlphabet(i.toString) = i + 2\n      \
    \      val newLetter = alphabet(i.toString) + alphabet(i.toString + 1).toString\
    \ // add two letters together\n            newAlphabet(newLetter) = i + 1\n  \
    \          newAlphabet(i.toString + 1).toString\n        }) foreach (x => s +=\
    \ alphabet(x._2))\n        s.drop(1)", "        val s = s\n        var i = s.length\n\
    \        var e = \"\"\n        while (i > 1) {\n            i -= 1\n         \
    \   e += s.charAt(i) + s.charAt(i + 1)\n        }\n        e += s.charAt(i)\n\
    \        return e", "        s.toCharArray.zipWithIndex.map { \n            case\
    \ (c, i) => \n                if (c.isLower) c.toUpper + c.toLower + c.toLower\n\
    \                else c.toLower + c.toUpper\n        }.map { c => \n         \
    \   (c + 'a') % 26 + c.toUpper\n        }.mkString", "        def rot13(s:String)\
    \ : String = {\n            val l = s.length\n            if(l == 0) s\n     \
    \       else if(l == 1) s\n            else rot13(s.substring(1)) + s.substring(0,\
    \ 1) \n        }\n        val n = s.length\n        val alphabet = mutable.ArrayBuffer(\n\
    \            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        )\n\
    \        val result = mutable.ArrayBuffer.empty[String]\n        for(i<-0 until\
    \ n){\n            result :+= alphabet(rot13(s.charAt(i)))\n        }\n      \
    \  result.mkString(\"\")", "        val alphabet = (\"abcdefghijklmnopqrstuvwxyz\"\
    ).toList\n        val newAlphabet = mutable.ListBuffer[String]()\n        newAlphabet\
    \ += alphabet\n        newAlphabet.insert(0, \"a\")\n        newAlphabet += \"\
    b\"\n        newAlphabet += \"c\"\n        newAlphabet += \"d\"\n        newAlphabet\
    \ += \"e\"\n        newAlphabet += \"f\"\n        newAlphabet += \"g\"\n     \
    \   newAlphabet += \"h\"\n        newAlphabet += \"i\"\n        newAlphabet +=\
    \ \"j\"\n        newAlphabet += \"k\"\n        newAlphabet += \"l\"\n        newAlphabet\
    \ += \"m\"\n        newAlphabet += \"n\"\n        newAlphabet += \"o\"\n     \
    \   newAlphabet += \"p\"\n        newAlphabet += \"q\"\n        newAlphabet +=\
    \ \"r\"\n        newAlphabet += \"s\"\n        newAlphabet += \"t\"\n        newAlphabet\
    \ += \"u\"\n        newAlphabet += \"v\"\n        newAlphabet += \"w\"\n     \
    \   newAlphabet += \"x\"\n        newAlphabet += \"y\"\n        newAlphabet +=\
    \ \"z\"\n        newAlphabet += \"a\"\n        newAlphabet += \"b\"\n        newAlphabet\
    \ += \"c\"\n        newAlphabet += \"d\"\n        newAlphabet += \"e\"\n     \
    \   newAlphabet += \"f\"\n        newAlphabet += \"g\"\n        newAlphabet +=\
    \ \"h\"\n        newAlphabet += \"i\"\n        newAlphabet += \"j\"\n        newAlphabet\
    \ += \"k\"\n        newAlphabet += \"l\"\n        newAlphabet += \"m\"\n     \
    \   newAlphabet += \"n\"\n        newAlphabet += \"o\"\n        newAlphabet +=\
    \ \"p\"\n        newAlphabet += \"q\"\n        newAlphabet += \"r\"\n        newAlphabet\
    \ += \"s\"\n        newAlphabet += \"t\"\n        newAlphabet += \"u\"\n     \
    \   newAlphabet += \"v\"\n        newAlphabet += \"w\"\n        newAlphabet +=\
    \ \"x\"\n        newAlphabet += \"y\"\n        newAlphabet += \"z\"\n        newAlphabet\
    \ += \"A\"\n        newAlphabet += \"B\"\n        newAlphabet += \"C\"\n     \
    \   newAlphabet += \"D\"\n        newAlphabet += \"E\"\n        newAlphabet +=\
    \ \"F\"\n        newAlphabet += \"G\"\n        newAlphabet += \"H\"\n        newAlphabet\
    \ += \"I\"\n        newAlphabet += \"J\"\n        newAlphabet += \"K\"\n     \
    \   newAlphabet += \"L\"\n        newAlphabet += \"M\"\n        newAlphabet +=\
    \ \"N\"\n        newAlphabet += \"O\"\n        newAlphabet += \"P\"\n        newAlphabet\
    \ += \"Q\"\n        newAlphabet += \"R\"\n        newAlphabet ", "        def\
    \ alphabetShift(c: Char, alphabet: mutable.Buffer[Char]) : Char = {\n        \
    \    val newChar = alphabet(alphabet.indexOf(c) + 1)\n            alphabet(c)\
    \ = newChar\n            newChar\n        }\n        val alphabet = Array('a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n        val sArr = s.toCharArray\n\
    \        val eArr = Array()\n        var i = 0\n        while (i < sArr.length)\
    \ {\n            val newChar = alphabetShift(sArr(i), alphabet)\n            eArr(i)\
    \ = newChar\n            i += 1\n        }\n        new String(eArr)", "     \
    \ val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n      val alphabetShifted\
    \ = alphabet.zipWithIndex.map { case (c, i) => alphabet(i + 2) }.flatten.toList\n\
    \      val encryptedChar = s.flatMap { c => alphabetShifted.map(c).toList }\n\
    \      encryptedChar.mkString", "        val alphabet = Array(\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\")\n        val s = Array[String]()\n        val len = s.length\n   \
    \     for( x <- 0 until len) {\n            val cur = s.apply(x)\n           \
    \ val newcur = cur.tail :+ cur.head :+ \"a\"\n            s ++= newcur\n     \
    \   }\n        s ", "        var res = \"\"\n        // The base alphabet consists\
    \ of the characters 'a' through 'j'\n        val alphabet = 'a'...'j'\n      \
    \  // Iterate over the characters in the string and add them to the result.\n\
    \        for (c <- s) {\n            res = res + alphabet + alphabet.last\n  \
    \      }\n        return res", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .toCharArray\n        val rotatedAlphabet = Array(alphabet(0), alphabet(26), alphabet(52),\
    \ alphabet(90), alphabet(136), alphabet(202), alphabet(27), alphabet(36), alphabet(51),\
    \ alphabet(58), alphabet(86), alphabet(114), alphabet(130), alphabet(159), alphabet(174),\
    \ alphabet(201), alphabet(268), alphabet(334), alphabet(392), alphabet(45), alphabet(53),\
    \ alphabet(60), alphabet(68), alphabet(76), alphabet(84), alphabet(92), alphabet(100),\
    \ alphabet(108), alphabet(126), alphabet(144), alphabet(162), alphabet(18), alphabet(20),\
    \ alphabet(28), alphabet(36), alphabet(44), alphabet(52), alphabet(60), alphabet(67),\
    \ alphabet(75), alphabet(83), alphabet(91), alphabet(99), alphabet(108), alphabet(117),\
    \ alphabet(125), alphabet(133), alphabet(143), alphabet(152), alphabet(163), alphabet(172),\
    \ alphabet(181), alphabet(190), alphabet(198), alphabet(207), alphabet(216), alphabet(225),\
    \ alphabet(233), alphabet(243), alphabet(252), alphabet(261), alphabet(270), alphabet(278),\
    \ alphabet(286), alphabet(294), alphabet(303), alphabet(313), alphabet(322), alphabet(331),\
    \ alphabet(339), alphabet(347), alphabet(356), alphabet(364), alphabet(373), alphabet(382),\
    \ alphabet(391), alphabet(400), alphabet(408), alphabet(416), alphabet(425), alphabet(433),\
    \ alphabet(442), alphabet(451), alphabet(460), alphabet(468), alphabet(476), alphabet(483),\
    \ alphabet(492), alphabet(500), alphabet(508), alphabet(517), alphabet(525), alphabet(533),\
    \ alphabet(542), alphabet(551), alphabet(560), alphabet(567), alphabet(576), alphabet(584),\
    \ alphabet(593), alphabet(602), alphabet(612), alphabet(620), alphabet(629), alphabet(637),\
    \ alphabet(646), alphabet(654), alphabet(663), alphabet(672), alphabet(681), alphabet(690),\
    \ alphabet(698), alphabet(707), alphabet(716), alphabet(725), alphabet(734), alphabet(743),\
    \ alphabet(752), alphabet(761), alphabet", "        val alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alpha2 = alpha.zipWithIndex.map { x => (x._2, x._1) }\n        val\
    \ alpha3 = alpha2.map{ x => x._1 }.zipWithIndex.map { x => x._2 }\n\n        def\
    \ shift_2(x:Int) = x - 2\n        def shift_3(x:Int) = x - 3\n        def shift_4(x:Int)\
    \ = x - 4\n\n        def rotate_left(x:Int) = alpha2(x)(shift_2(x))\n        def\
    \ rotate_right(x:Int) = alpha2(x)(shift_3(x))\n        def rotate_left_2(x:Int)\
    \ = alpha3(x)(shift_4(x))\n        def rotate_right_2(x:Int) = alpha3(x)(shift_4(x))\n\
    \n        val alpha4 = alpha2.map{ x => x._1 }.zipWithIndex.map { x => x._2 }\n\
    \        def rotate_left_3(x:Int) = alpha4(x)(shift_4(x))\n        def rotate_right_3(x:Int)\
    \ = alpha4(x)(shift_4(x))\n\n        val alpha5 = alpha2.map{ x => x._1 }.zipWithIndex.map\
    \ { x => x._2 }\n        def rotate_left_4(x:Int) = alpha5(x)(shift_4(x))\n  \
    \      def rotate_right_4(x:Int) = alpha5(x)(shift_4(x))\n\n        val alpha6\
    \ = alpha2.map{ x => x._1 }.zipWithIndex.map { x => x._2 }\n        def rotate_left_5(x:Int)\
    \ = alpha6(x)(shift_4(x))\n        def rotate_right_5(x:Int) = alpha6(x)(shift_4(x))\n\
    \n        val alpha7 = alpha2.map{ x => x._1 }.zipWithIndex.map { x => x._2 }\n\
    \        def rotate_left_6(x:Int) = alpha7(x)(shift_4(x))\n        def rotate_right_6(x:Int)\
    \ = alpha7(x)(shift_4(x))\n\n        val alpha8 = alpha2.map{ x => x._1 }.zipWithIndex.map\
    \ { x => x._2 }\n        def rotate_left_7(x:Int) = alpha8(x)(shift_4(x))\n  \
    \      def rotate_right_7(x:Int) = alpha8(x)(shift_4(x))\n\n        val alpha9\
    \ = alpha2.map{ x => x._1 }.zipWithIndex.map { x => x._2 }\n        def rotate_left_8(x:Int)\
    \ = alpha9(x)(shift_4(x))\n        def rotate_right_8(x:Int) = alpha9(x)(shift_4(x))\n\
    \n        ", "        val result = new StringBuilder(s.length)\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n\n        val len = s.length\n\
    \        var i = 0\n        while (i < len) {\n            val index = s.charAt(i).toInt\n\
    \            val rotation = alphabet.size - index\n            val shift = rotation.toInt\n\
    \            val shift2 = shift.toInt\n            val shift3 = shift2.toInt\n\
    \            if (i == 0) {\n                result.append(alphabet((index + (shift\
    \ * 2))));\n                i = 2\n            } else if (i == 1) {\n        \
    \        result.append(alphabet((index + shift)));\n                i = 2\n  \
    \          } else if (i == 2) {\n                result.append(alphabet((index\
    \ - (shift))));\n                i = 1\n            } else {\n               \
    \ result.append(alphabet((index - (shift * 2))));\n                i = 2\n   \
    \         }\n        }\n        result.toString()", "        def rotateLeft(i:\
    \ Int, j: Int) : String = {\n            val rotated = s.substring(i)\n      \
    \      rotated.substring(0, j) + rotated.substring(j, s.length) + rotated.substring(0,\
    \ j) + rotated.substring(j)\n        }\n        s.reverse.zip(s.reverse.zipWithIndex).map{\
    \ case (x, y) => rotateLeft(y._2, y._1 * 2) + x }.mkString", "        val alphabet\
    \ = Seq(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n        var i = 0\n        var letter =\
    \ alphabet(0)\n        var outString = \"\"\n        while (i<s.length)\n    \
    \    {\n            val c = s.charAt(i)\n            letter = alphabet(alphabet.indexOf(c)\
    \ + 2)\n            outString = outString + letter\n            i = i + 1\n  \
    \      }\n        return outString", "       val alphabet = List(\"a\",\"b\",\"\
    c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"\
    p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n       val alphabet2\
    \ = List(\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\",\"a\",\"b\")\n       val alphabet3 = List(\"c\",\"d\",\"e\",\"f\",\"g\",\"\
    h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"\
    u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"a\",\"b\",\"c\")\n       val alphabet4 = List(\"\
    d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"\
    q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"a\",\"b\",\"c\",\"\
    d\")\n       val alphabet5 = List(\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"\
    l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"\
    y\",\"z\",\"a\",\"b\",\"c\",\"d\",\"e\")\n       val alphabet6 = List(\"f\",\"\
    g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"\
    t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\")\n\
    \       val alphabet7 = List(\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"\
    o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"a\",\"\
    b\",\"c\",\"d\",\"e\",\"f\",\"g\")\n       val alphabet8 = List(\"h\",\"i\",\"\
    j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"\
    w\",\"x\",\"y\",\"z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\")\n     \
    \  val alphabet9 = List(\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\"\
    ,\"r\",\"s\",\"t", "        val str1 = s.mkString.toUpperCase\n        val str2\
    \ = str1.substring(0,str1.length/2)\n        val str3 = str2.toUpperCase+str2.substring(str2.length/2,str2.length)\n\
    \        val str4 = str1.substring(-str1.length/2)+str3\n        str4", "    \
    \    val a = s.toCharArray\n        val b = a.map(c => (c.toLong * 2) + 2).toArray\n\
    \        val c = new String(b)\n        a.foreach(c => c.toLong * 2 + 2)\n   \
    \     c + a.mkString(\"\")", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val r = alphabet map {x => (s(0) - 'a') * 2 + 'a'}\n        r.foldLeft(s)\
    \ {\n        case (acc, c) => acc + c\n        }", "        val alphabet = Array(\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\")\n        var encryptedString = s\n        var newEncryptedString\
    \ = encryptedString\n        for (x<-0 to newEncryptedString.length-1){\n    \
    \        if (newEncryptedString.charAt(x) equals alphabet.charAt(x+2)){\n    \
    \            newEncryptedString = newEncryptedString.substring(0,x) + \"d\" +\
    \ newEncryptedString.substring(x+1)\n                println(newEncryptedString)\n\
    \                encryptedString = newEncryptedString\n            }\n       \
    \ }\n        return encryptedString", "      var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');\n\
    \      val n = s.length\n      var new_str = s\n      for(i <- 0 until n){\n \
    \       val c = s.charAt(i)\n        val index = alphabet.indexOf(c)\n       \
    \ val next_index = index + 2\n        if(next_index < alphabet.length){\n    \
    \      new_str = new_str + alphabet.apply(next_index)\n        }\n        else\
    \ {\n          new_str = new_str + alphabet(alphabet.length - 1);\n        }\n\
    \      }\n      new_str", "        val letters: mutable.Buffer[String] = new mutable.Buffer[String]()\n\
    \        for (c <- s.toCharArray) {\n            letters += c\n            letters\
    \ += c.swap\n            letters += c.swap\n        }\n        letters.mkString",
  "        val alphabet = (\"abcdefghijklmnopqrstuvwxyz\")\n        var newLetters\
    \ = \"\"\n        var newString = \"\"\n        for(i <- 0 to s.length - 1) {\n\
    \            newLetters += alphabet.substring(alphabet.indexOf(i) + 2, alphabet.indexOf(i)\
    \ + 4) + \"\\n\"\n            newString += alphabet.substring(alphabet.indexOf(i)\
    \ + 4, alphabet.indexOf(i + 1) + 4) + \"\\n\"\n        }\n        newLetters +=\
    \ alphabet.substring(alphabet.indexOf(0), alphabet.indexOf(1)) + \"\\n\"\n   \
    \     newString += alphabet.substring(alphabet.indexOf(0), alphabet.indexOf(1))\
    \ + \"\\n\"\n        return newLetters + \"\\n\" + newString", "        val alphabet\
    \ = new Array[Char](\"abcdefghijklmnopqrstuvwxyz\".toCharArray)\n        var s\
    \ = s\n        s.toCharArray.sorted.foreach { c =>\n            val index = alphabet(alphabet.indexOf(c))\
    \ + 2\n            alphabet(alphabet.indexOf(c)) = alphabet(index)\n        }\n\
    \        s.toCharArray.mkString", "        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetCount = alphabet.to.length\n        val alphabetString =\
    \ \"\"\n        var i = 0\n        for (c <- s.toCharArray){\n            alphabetString\
    \ += alphabet(i % alphabetCount)\n            i = i + 1\n        }\n        return\
    \ alphabetString", "        val alphabet = Array(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n \
    \       var index = 0\n        while (index <= s.length)\n        {\n        \
    \    index = index + 1\n            var a = alphabet.indexOf(s(index))\n     \
    \       var b = alphabet.indexOf(\"a\")\n            var c = alphabet.indexOf(\"\
    b\")\n            var d = alphabet.indexOf(\"c\")\n            var e = alphabet.indexOf(\"\
    d\")\n            var f = alphabet.indexOf(\"e\")\n            var g = alphabet.indexOf(\"\
    f\")\n            var h = alphabet.indexOf(\"g\")\n            var i = alphabet.indexOf(\"\
    h\")\n            var j = alphabet.indexOf(\"i\")\n            var k = alphabet.indexOf(\"\
    j\")\n            var l = alphabet.indexOf(\"k\")\n            var m = alphabet.indexOf(\"\
    l\")\n            var n = alphabet.indexOf(\"m\")\n            var o = alphabet.indexOf(\"\
    n\")\n            var p = alphabet.indexOf(\"o\")\n            var q = alphabet.indexOf(\"\
    p\")\n            var r = alphabet.indexOf(\"q\")\n            var s = alphabet.indexOf(\"\
    r\")\n            var t = alphabet.indexOf(\"s\")\n            var u = alphabet.indexOf(\"\
    t\")\n            var v = alphabet.indexOf(\"u\")\n            var w = alphabet.indexOf(\"\
    v\")\n            var x = alphabet.indexOf(\"w\")\n            var y = alphabet.indexOf(\"\
    x\")\n            var z = alphabet.indexOf(\"y\")\n            var alphabet =\
    \ alphabet.drop(alphabet.size - 1).drop(1)\n            var result = \"\"\n  \
    \          if (a > b)\n            {\n                result = result + alphabet(a)\n\
    \            }\n            else\n            {\n                result = result\
    \ + alphabet(b)\n            }\n            if (b > c)\n            {\n      \
    \          result = result + alphabet(b)\n            }\n            else\n  \
    \          {\n                result = result + alphabet(c)\n            }\n \
    \           if (c > d)\n            {\n                result = result + alphabet(c)\n\
    \            }\n            else\n            {\n                result = result\
    \ + alphabet(d)\n            }\n            if (d > e)\n            {\n      \
    \          result = result + alphabet(d)\n            }\n            else\n  \
    \          {\n                result = result + alphabet(e)\n            }\n \
    \           if (e > f)\n            {\n                result = result + alphabet(e)\n\
    \            }\n            else\n            {\n                result = result\
    \ + alphabet(f)\n            }\n            if (f > g)\n            {\n      \
    \          result = result + alphabet(f)\n            }\n            else\n  \
    \          {\n                result = result + alphabet(g)\n            }\n \
    \           if (g > h)\n            {\n                result = result + alphabet(g)\n\
    \            }\n            else\n            {\n                result = result\
    \ + alphabet(h)\n            }\n", "         val alphabet = List(\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    )\n         val letters = s.toCharArray\n         val rotatedAlphabet = alphabet.map(alphabet(_).swap)\n\
    \         val rotatedLetters = letters.map(letters(_).swap)\n         val rotatedString\
    \ = rotatedLetters.mkString(\"\")\n         rotatedString", "        val alphabet\
    \ = (\"abcdefghijklmnopqrstuvwxyz\"\n            + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n            + \"0123456789\"\n            + \"!@#$%^&*()\"\n            + \"\
    -\"\n            + \"`~[]{};:,./<>?\"\n            + \"abcdefghijklmnopqrstuvwxyz\"\
    \n            + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            + \"0123456789\"\n\
    \            + \"!@#$%^&*()\"\n            + \"-\"\n            + \"`~[]{};:,./<>?\"\
    \n            + \"abcdefghijklmnopqrstuvwxyz\"\n            + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n            + \"0123456789\").mkString\n        val res = \"\"\n        var\
    \ i = 0\n        while (i < s.length)\n            res += alphabet((s.charAt(i)\
    \ - 65) + alphabet.indexOf((s.charAt(i + 1) - 65)) + 2)\n            i += 1\n\
    \        res", "        var newString : String = s.mkString\n        val alphabet\
    \ = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n        val alphabetWithZ = List(\"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\", \"z\")\n        val zCharPosition = alphabet.indexOf(\"\
    z\")\n        val newStringLength = newString.length\n        var index = 0\n\
    \        var rotatedCharacter = \"\"\n        var positionOfZ = 0\n        while\
    \ (positionOfZ < zCharPosition) {\n            rotatedCharacter = alphabetWithZ(positionOfZ)\
    \ + alphabetWithZ(zCharPosition)\n            positionOfZ = positionOfZ + 1\n\
    \        }\n        alphabetWithZ.zip(alphabetWithZ.tail).foreach{ case(a,b) =>\
    \ newString = new StringBuilder(newString).insert(index, a).insert(newString.length,\
    \ b).toString()}\n        if (newString.length > newStringLength) {\n        \
    \    newString = new StringBuilder(newString.substring(0, newString.length-1)).toString()\n\
    \        }\n        newString", "        def rot(x : String) : String = {\n  \
    \          // This could be done more efficiently by using an array\n        \
    \    val alphabet = Array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n            val alphabet2\
    \ = Array(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"m\"\
    , \"l\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\")\n            val alphabet3 = Array(\"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"m\", \"l\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    )\n            val alphabet4 = Array(\"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\", \"m\", \"l\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n            val alphabet5\
    \ = Array(\"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"m\", \"l\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\")\n            val alphabet6 = Array(\"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"m\", \"l\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\")\n            val alphabet7 = Array(\"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"m\", \"l\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n           \
    \ val alphabet8 = Array(\"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"m\", \"l\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n            val alphabet9 = Array(\"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"m\", \"\
    l\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\")\n            val alphabet10 = Array(\"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"m\", \"l\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n \
    \           val alphabet11 = Array(\"b\", \"c\", \"d\", \"e\", \"f", "       \
    \ val result = new StringBuilder\n        for(i <- 0 until s.length) result +=\
    \ s.charAt(i) + rotator(s.charAt(i))\n        result.toString", "        val alphabet\
    \ = Array(\"z\",\"y\",\"x\",\"w\",\"v\",\"u\",\"t\",\"s\",\"r\",\"q\",\"p\",\"\
    o\",\"n\",\"m\",\"l\")\n        var resultString = \"\"\n        for(i <- s.indices)\
    \ {\n            resultString += alphabet(alphabet.indices.filter(j => j != i).map((_\
    \ + 2).head))\n        }\n        return resultString", "        val alpha = \"\
    abcdefghijklmnopqrstuvwxyz\".toCharArray.grouped(2).toList\n        val l = alpha.length\n\
    \        var p = 0\n        var c = 0\n        var ret = \"\"\n        var i =\
    \ 0\n        for (c <- s.toCharArray) {\n            var a = alpha \n        \
    \    while (i < l)\n            {\n                a = (a(p - i) + a(p - i)) %\
    \ 26\n                i += 1\n            }\n            ret += (c -> a)\n   \
    \         p = (p + 1) % l\n        }\n        ret", "        // Initialize a mutable\
    \ list to hold the alphabet rotation values\n        var alphabet = List(\"A\"\
    , \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"\
    , \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\"\
    , \"X\", \"Y\", \"Z\")\n        val result = new collection.mutable.ListBuffer[String]()\n\
    \        var i = 0\n        // Loop over all the characters in the string\n  \
    \      s.foreach(char => { \n            // Get the character position from the\
    \ alphabet\n            var position = alphabet.indexOf(char)\n            //\
    \ Add 2 multiples of the alphabet position to the alphabet \n            // to\
    \ shift down by two \n            alphabet = alphabet.take(position + 2).toList\
    \ :: alphabet.drop(position + 2).toList\n            // Add this character to\
    \ the result\n            result.append(char) // Add character to the end of the\
    \ result\n            // Add this character to the end of the alphabet\n     \
    \       alphabet = alphabet.take(2).toList :: alphabet.drop(2).toList\n      \
    \  })\n        result.toString()", "        val alphabet = mutable.LinkedList(\"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\")\n        var currentLetter\
    \ = alphabet.get(0)\n        var currentString = \"\"\n        for((letter,index)\
    \ <- s.toCharArray.zipWithIndex) {\n            if(index != 0) {\n           \
    \     currentLetter = alphabet.get((alphabet.indexOf(currentLetter) + 1) % (alphabet.size))\n\
    \            }\n            currentString = currentString + currentLetter + letter\n\
    \        }\n        currentString", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val chars = s.toList\n        val result = new ArrayBuffer[Char]()\n\
    \        var j = 0\n        while (j < chars.length) {\n            val char =\
    \ chars(j)\n            val char1 = alphabet.lastIndexOf(char)\n            val\
    \ char2 = alphabet.indexOf(chars.last, char1 - 1)\n            val char3 = alphabet(alphabet.indexOf(char)\
    \ - char2)\n            val char4 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ + 1)\n            val char5 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.lastIndexOf(char1)\
    \ + 1)\n            val char6 = alphabet(alphabet.lastIndexOf(char)) - char2\n\
    \            val char7 = alphabet(alphabet.lastIndexOf(char)) - char2\n      \
    \      val char8 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ - 1)\n            val char9 = alphabet(alphabet.lastIndexOf(char)) - char2\n\
    \            val char10 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ + 1)\n            val char11 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ + 1)\n            val char12 = alphabet(alphabet.lastIndexOf(char)) - char2\n\
    \            val char13 = alphabet(alphabet.lastIndexOf(char)) - char2\n     \
    \       val char14 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ - 1)\n            val char15 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ + 1)\n            val char16 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ + 1)\n            val char17 = alphabet(alphabet.lastIndexOf(char)) - char2\n\
    \            val char18 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ - 1)\n            val char19 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ - 1)\n            val char20 = alphabet(alphabet.lastIndexOf(char)) - char2\n\
    \            val char21 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ - 1)\n            val char22 = alphabet(alphabet.lastIndexOf(char)) + alphabet(alphabet.indexOf(char1)\
    \ - 1)\n            val char23 = alphabet(alphabet.lastIndexOf(char)) - char",
  "        val alphabet = (\"abcdefghijklmnopqrstuvwxyz\").map(_.toChar)\n       \
    \ val maxAlphabet = alphabet.map(_.toString.length).max\n\n        s.zipWithIndex.map\
    \ {\n            case(str, index) => if(index+2 < maxAlphabet) alphabet(index)+alphabet(index+2)\n\
    \            else alphabet(index)\n        }.mkString(\"\")", "        var str\
    \ = \"\"\n        val alphabet = scala.collection.mutable.Array(\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\")\n        for (i <- s.toList) {\n            str = str +  alphabet(alphabet.indexOf(i)\
    \ + 2).toChar\n        }\n        str", "        // Declare a variable called\
    \ alphabet to be a collection of 26 \n        // mutable.Chars\n        var alphabet\
    \ = mutable.ArrayBuffer(97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255)\n\
    \        // Fill the collection of 26 characters with letters from the English\
    \ alphabet\n        for (x <- 0 to 26) alphabet += Character(x + 97)\n       \
    \ // Declare a variable called rotations to be an immutable collection\n     \
    \   // of 26 immutable.Chars\n        var rotations = scala.collection.immutable.ArrayBuffer(97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,15",
  "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotator = new Rotator(alphabet)\n        rotator.rotate(s)", "  \
    \      // Start with a copy of the original string\n        var enc = s.toCharArray\n\
    \        // Make a mutable copy of the char array\n        var rotA = new mutable.ArrayBuffer[Int]()\n\
    \        for(c <- enc){\n            rotA.append(c - 0)\n            rotA.append(c\
    \ - 1)\n            rotA.append(c - 2)\n            rotA.append(c - 3)\n     \
    \       rotA.append(c - 4)\n            rotA.append(c - 5)\n            rotA.append(c\
    \ - 6)\n            rotA.append(c - 7)\n            rotA.append(c - 8)\n     \
    \       rotA.append(c - 9)\n            rotA.append(c - 10)\n            rotA.append(c\
    \ - 11)\n            rotA.append(c - 12)\n            rotA.append(c - 13)\n  \
    \          rotA.append(c - 14)\n            rotA.append(c - 15)\n        }\n \
    \       // Rotate the array\n        var rotA2 = rotA.reverse\n        var rotB\
    \ = new mutable.ArrayBuffer[Int]()\n        for(c <- rotA2){\n            rotB.append(c)\n\
    \        }\n        // Return the encrypted string\n        return s.foldLeft(\"\
    \")(\n            (a: Int, b: Int) => a + b + rotB(rotB.size - 1 - rotB.indexOf(a)))",
  "      val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toSet\n      val cipher = s.toCharArray.filter(c\
    \ => alphabet(c)).map {\n        case c if alphabet(c) => (alphabet(c) + alphabet(alphabet.indexOf(c))).map(c\
    \ => (c ^ alphabet(alphabet.indexOf(c))).toChar)\n        case c => c\n      }\n\
    \      new String(cipher.reverse)", "        val n = s.length\n        val a =\
    \ alphabet.asInstanceOf[List[String]]\n        var en = mutable.MutableList[String]()\n\
    \        var j = 0\n        while (j < n) {\n            en = en :+ a(j + 2 *\
    \ a.length)\n            j += 1\n        }\n        en.reverse\n        en.reverse\n\
    \        en", "        val m = s.toCharArray\n        for (i <- 0 until m.length-1){\n\
    \            m(i) =((m(i)+2)/2) \n            m(i+1) = ((m(i+1)-2*m(i))/3)\n \
    \       }\n        new String(m)", "        val newS = s.toCharArray.map( x =>\
    \ ((x & 1) * 2 + (x & 2))).toString.toUpperCase\n        s.takeWhile(c => c !=\
    \ 'Z').mkString.map(s => newS.charAt(newS.indexOf(s.toUpperCase)) + \n       \
    \ ' ').mkString.mkString(\"\")", "        val chars = s.toCharArray\n        val\
    \ len = chars.length\n        val newChars = Array.ofDim[Char](len)\n        var\
    \ i = 0\n        var j = 0\n        for(i <- 0 until len) {\n            val rotLetter\
    \ = chars(i).toChar\n            val letterShifted = rotLetter.asInstanceOf[Int]\
    \ + 2\n            val letterShiftedInt = letterShifted.toInt\n            newChars(i)\
    \ = letterShiftedInt.toChar\n        }\n        new String(newChars)", "     \
    \   var res = s.toCharArray\n        for(i <- 0 until s.length)\n            res(i)\
    \ = encrypt(res(i))\n        new String(res)", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map1 = alphabet.toMap\n        val map2 = alphabet.toMap.reverse\n\
    \        val map3 = alphabet.toMap.toList.reverse\n        val map4 = alphabet.toMap.mapValues(\
    \ _ => 2 ).reverse.toList.reverse\n        val map5 = alphabet.toMap.mapValues(\
    \ _ => 1 ).reverse.toList.reverse\n        val map6 = alphabet.toMap.mapValues(\
    \ _ => 0 ).reverse.toList.reverse\n        val map7 = alphabet.toMap.mapValues(\
    \ _ => 3 ).reverse.toList.reverse\n        val map8 = alphabet.toMap.mapValues(\
    \ _ => 4 ).reverse.toList.reverse\n        val map9 = alphabet.toMap.mapValues(\
    \ _ => 5 ).reverse.toList.reverse\n        val map10 = alphabet.toMap.mapValues(\
    \ _ => 6 ).reverse.toList.reverse\n        val map11 = alphabet.toMap.mapValues(\
    \ _ => 7 ).reverse.toList.reverse\n        val map12 = alphabet.toMap.mapValues(\
    \ _ => 8 ).reverse.toList.reverse\n        val map13 = alphabet.toMap.mapValues(\
    \ _ => 9 ).reverse.toList.reverse\n        val map14 = alphabet.toMap.mapValues(\
    \ _ => 10 ).reverse.toList.reverse\n        val map15 = alphabet.toMap.mapValues(\
    \ _ => 11 ).reverse.toList.reverse\n        val map16 = alphabet.toMap.mapValues(\
    \ _ => 12 ).reverse.toList.reverse\n        val map17 = alphabet.toMap.mapValues(\
    \ _ => 13 ).reverse.toList.reverse\n        val map18 = alphabet.toMap.mapValues(\
    \ _ => 14 ).reverse.toList.reverse\n        val map19 = alphabet.toMap.mapValues(\
    \ _ => 15 ).reverse.toList.reverse\n        val map20 = alphabet.toMap.mapValues(\
    \ _ => 16 ).reverse.toList.reverse\n        val map21 = alphabet.toMap.mapValues(\
    \ _ => 17 ).reverse.toList.reverse\n        val map22 = alphabet.toMap.mapValues(\
    \ _ => 18 ).reverse.toList.reverse\n        val map23 = alphabet.toMap.mapValues(\
    \ _ => 19 ).reverse.toList.reverse\n        val map24 = alphabet.toMap.mapValues(\
    \ _ => 20 ).reverse.toList.reverse\n        val map25 = alphabet.toMap.mapValues(\
    \ _ => 21 ).reverse.toList.reverse\n        val map26 = alphabet.toMap.mapValues(\
    \ _ => 22 ).reverse.toList.reverse\n        val map27 = alphabet.toMap.mapValues(\
    \ _ => 23 ).reverse", "        val alphabet = (0 until 26).map(_.toString).toArray\n\
    \        val rot = alphabet.map(alphabet(_).replace(alphabet(_).length)).map(alphabet(_).replace(0,\
    \ 1)).zipWithIndex.map(x => x._2 + x._1).map(alphabet(_)).toArray\n        val\
    \ s = rot(0) + s + rot(1) + s + rot(2) + s + rot(3) + s + rot(4) + s + rot(5)\
    \ + s + rot(6) + s + rot(7) + s + rot(8) + s + rot(9) + s + rot(10)\n        s",
  "        def rotate(alphabet : Array[Char]) : Array[Char] = {\n            var res:\
    \ Array[Char] = new Array[Char](alphabet.length)\n            var i = 0\n    \
    \        while (i < alphabet.length) {\n                val b = alphabet(i)\n\
    \                var j = alphabet.length - 1\n                var k = alphabet.length\
    \ - 2\n                while (j >= 0) {\n                    val c = alphabet(j)\n\
    \                    val d = alphabet(k)\n                    if (b == c) {\n\
    \                        res(i) = d\n                        res(k) = b\n    \
    \                    res(k) = b\n                        j -= 1\n            \
    \        } else if (b != c) {\n                        res(i) = c\n          \
    \              j -= 1\n                    } else {\n                        res(i)\
    \ = b\n                        k += 1\n                    }\n               \
    \ }\n                i += 1\n            }\n            res\n        }\n     \
    \   val alphabet = Array('f' , 'l' , 'r' , 'z' , 'a' , 'e' , 'h' , 'j' , 'k' ,\
    \ 'm' , 'n' , 'p' , 'q' , 't' , 'w' , 'v' , 'y' , 'u' , 'x' , 'z')\n        val\
    \ enc = s.map(x => rotate(alphabet).toList.flatten).flatten.toList\n        enc.map(x\
    \ => alphabet(x) + x).mkString(\"\")", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val stringLength = s.length\n        val result = new Array[Char](stringLength\
    \ * 2)\n        var i = 0\n        for (i <- 0 until stringLength) {\n       \
    \     val x = alphabet.indexOf(s(i))\n            val y = alphabet.indexOf(s(i+1))\n\
    \            val z = (x - 2) + (y - 1)\n            result(i*2) = alphabet(z-x)\n\
    \            result(i*2+1) = alphabet(z+x)\n        }\n        new String(result)",
  "        val alphabet = scala.collection.mutable.ArrayBuffer.fill((s.length + 1)\
    \ * 2 - 1)(65).toList\n        alphabet.foreach(alphabet(_) =:= 65)\n        for\
    \ (a <- alphabet.iterator; a.hasNext; ) {\n            val b = a.next\n      \
    \      alphabet(b) = alphabet(a) + 2\n            alphabet(b) = alphabet(b) +\
    \ 2\n        }\n        alphabet(s.length + 1) = 65\n        val sb = new StringBuilder()\n\
    \        for (i <- 0 until s.length; sb append alphabet(i)) {}\n        sb.toString",
  "        val alpha = Array('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \        var n = 0\n        var j = 0\n        var enc = \"\"\n        var l =\
    \ s.length\n        while (n<l) {\n            var temp = alpha (alpha(alpha.indexOf(s)\
    \ + j + 2)) - alpha (alpha(alpha.indexOf(s) + j))\n            if (temp > 0) {\n\
    \                enc = enc + (s(n))\n            }\n            else {\n     \
    \           enc = enc + (s(n))\n            }\n            n = n + 1\n       \
    \     j = j + 2\n        }\n        return enc", "      val alphabet = List(\"\
    z\", \"y\", \"x\", \"w\", \"v\", \"u\", \"t\", \"s\", \"r\", \"q\", \"p\", \"\
    o\", \"n\", \"m\", \"l\", \"k\", \"j\", \"i\")\n      var res = \"\"\n      for\
    \ (i <- 0 until s.length - 1) {\n        res += alphabet(alphabet.indexOf(s.charAt(i))\
    \ + 1) + alphabet(alphabet.indexOf(s.charAt(i)) + 2)\n      }\n      res", " \
    \       val letters = ('A' to 'Z').map(_.toChar)\n        val rotatedLetters =\
    \ letters.map(l => ( (l+2)%26) + l)\n        val rotatedLetters2 = letters.map(l\
    \ => ( (l+2)%26))\n        val result = s.zip(rotatedLetters).map(p => p._1 +\
    \ p._2)\n        result.zip(rotatedLetters2).map(p => p._1 + p._2)", "       \
    \ val alphabet = Vector(\n            'h' -> 'g',\n            'e' -> 'f',\n \
    \           'l' -> 'j',\n            'm' -> 'k',\n            'n' -> 'o',\n  \
    \          'p' -> 'i',\n            'q' -> 'w',\n            'r' -> 'y',\n   \
    \         't' -> 'z',\n            'u' -> 'v',\n            'v' -> 'w',\n    \
    \        'w' -> 'x',\n            'x' -> 'y',\n            'y' -> 'z',\n     \
    \       'z' -> 'a'\n        )\n        // use foldLeft to rotate the string\n\
    \        val newString = s.foldLeft(\"\")((acc, nextChar) => acc + alphabet(nextChar))\n\
    \        // remove first letter\n        newString.subString(1, newString.length-1)",
  "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        val\
    \ letterMap : mutable.Map[Char, Char] = mutable.HashMap()\n        for(letter\
    \ <- alphabet) letterMap ++= letter -> letter + 1\n        \n        val newLetterMap\
    \ : mutable.Map[Char, Char] = mutable.HashMap()\n        for(letter <- alphabet)\
    \ newLetterMap ++= letterMap.filterKeys(_ == letter).values.head -> letter + 1\n\
    \        \n        val newString = \"\"\n        for(c <- s.toCharArray) {\n \
    \           newString += newLetterMap.getOrElse(c, c)\n        }\n        \n \
    \       return newString", "      var rotatedAlphabet = scala.collection.mutable.ListBuffer[String]()\n\
    \      rotatedAlphabet += (\"a\")\n      rotatedAlphabet += (\"b\")\n      rotatedAlphabet\
    \ += (\"c\")\n      rotatedAlphabet += (\"d\")\n      rotatedAlphabet += (\"e\"\
    )\n      rotatedAlphabet += (\"f\")\n      rotatedAlphabet += (\"g\")\n      rotatedAlphabet\
    \ += (\"h\")\n      rotatedAlphabet += (\"i\")\n      rotatedAlphabet += (\"j\"\
    )\n      rotatedAlphabet += (\"k\")\n      rotatedAlphabet += (\"l\")\n      rotatedAlphabet\
    \ += (\"m\")\n      rotatedAlphabet += (\"n\")\n      rotatedAlphabet += (\"o\"\
    )\n      rotatedAlphabet += (\"p\")\n      rotatedAlphabet += (\"q\")\n      rotatedAlphabet\
    \ += (\"r\")\n      rotatedAlphabet += (\"s\")\n      rotatedAlphabet += (\"t\"\
    )\n      rotatedAlphabet += (\"u\")\n      rotatedAlphabet += (\"v\")\n      rotatedAlphabet\
    \ += (\"w\")\n      rotatedAlphabet += (\"x\")\n      rotatedAlphabet += (\"y\"\
    )\n      rotatedAlphabet += (\"z\")\n      s.toCharArray.map { char =>\n     \
    \   rotatedAlphabet += (char.toString + char.toString + \"a\")\n        rotatedAlphabet\
    \ += (char.toString + char.toString + \"b\")\n        rotatedAlphabet += (char.toString\
    \ + char.toString + \"c\")\n        rotatedAlphabet += (char.toString + char.toString\
    \ + \"d\")\n        rotatedAlphabet += (char.toString + char.toString + \"e\"\
    )\n        rotatedAlphabet += (char.toString + char.toString + \"f\")\n      \
    \  rotatedAlphabet += (char.toString + char.toString + \"g\")\n        rotatedAlphabet\
    \ += (char.toString + char.toString + \"h\")\n        rotatedAlphabet += (char.toString\
    \ + char.toString + \"i\")\n        rotatedAlphabet += (char.toString + char.toString\
    \ + \"j\")\n        rotatedAlphabet += (char.toString + char.toString + \"k\"\
    )\n        rotatedAlphabet += (char.toString + char.toString + \"l\")\n      \
    \  rotatedAlphabet += (char.toString + char.toString + \"m\")\n        rotatedAlphabet\
    \ += (char.toString + char.toString ", "        var chars = s.toCharArray\n  \
    \      var result = (chars.toSeq zip chars.tail).toList\n        result.sortBy\
    \ {\n            (a, b) => a.toInt - b.toInt\n        }.foreach {\n          \
    \  char =>\n                val oldChar = chars.find(_ == char)\n            \
    \    val newChar = chars.remove(oldChar)\n                chars.insert(oldChar,\
    \ newChar)\n        }\n        var res = \"\"\n        for (i <- 0 to chars.length)\n\
    \            res += chars(i)\n        res", "        def rotate(s: String): String\
    \ = {\n            val newString = new StringBuilder(s.length)\n            for(\
    \ i <- 0 until s.length ) {\n                val j = i + (s.length - i)/2\n  \
    \              newString.append(s(j))\n                newString.append(s(j+1))\n\
    \            }\n            newString.toString()\n        }\n        def rot(s:\
    \ String): String = {\n            val newString = new StringBuilder(s.length)\n\
    \            for( i <- 0 until s.length ) {\n                val j = i + (s.length\
    \ - i)/2\n                newString.append(s(j))\n                newString.append(s(j+1))\n\
    \            }\n            newString.toString()\n        }\n        val alphabet\
    \ = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n        val newString = s.map(letter =>\
    \ alphabet(alphabet.indexOf(letter) + 1))\n        val newString2 = newString.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 2))\n        val newString3 = newString2.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 3))\n        val newString4 = newString3.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 4))\n        newString4 ++ newString",
  "       val alpha = 'a' to 'z'\n       val alpha2 = 'a' to 'z'\n       val alpha3\
    \ = 'a' to 'z'\n       val alpha4 = 'a' to 'z'\n       val alpha5 = 'a' to 'z'\n\
    \       val alpha6 = 'a' to 'z'\n       val alpha7 = 'a' to 'z'\n       val alpha8\
    \ = 'a' to 'z'\n       val alpha9 = 'a' to 'z'\n       val alpha10 = 'a' to 'z'\n\
    \       val alpha11 = 'a' to 'z'\n       val alpha12 = 'a' to 'z'\n       val\
    \ alpha13 = 'a' to 'z'\n       val alpha14 = 'a' to 'z'\n       val alpha15 =\
    \ 'a' to 'z'\n       val alpha16 = 'a' to 'z'\n       val alpha17 = 'a' to 'z'\n\
    \       val alpha18 = 'a' to 'z'\n       val alpha19 = 'a' to 'z'\n       val\
    \ alpha20 = 'a' to 'z'\n       val alpha21 = 'a' to 'z'\n       val alpha22 =\
    \ 'a' to 'z'\n       val alpha23 = 'a' to 'z'\n       val alpha24 = 'a' to 'z'\n\
    \       val alpha25 = 'a' to 'z'\n       val alpha26 = 'a' to 'z'\n       val\
    \ alpha27 = 'a' to 'z'\n       val alpha28 = 'a' to 'z'\n       val alpha29 =\
    \ 'a' to 'z'\n       val alpha30 = 'a' to 'z'\n       val alpha31 = 'a' to 'z'\n\
    \       val alpha32 = 'a' to 'z'\n       val alpha33 = 'a' to 'z'\n       val\
    \ alpha34 = 'a' to 'z'\n       val alpha35 = 'a' to 'z'\n       val alpha36 =\
    \ 'a' to 'z'\n       val alpha37 = 'a' to 'z'\n       val alpha38 = 'a' to 'z'\n\
    \       val alpha39 = 'a' to 'z'\n       val alpha40 = 'a' to 'z'\n       val\
    \ alpha41 = 'a' to 'z'\n       val alpha42 = 'a' to 'z'\n       val alpha43 =\
    \ 'a' to 'z'\n       val alpha44 = 'a' to 'z'\n       val alpha45 = 'a' to 'z'\n\
    \       val alpha46 = 'a' to 'z'\n       val alpha47 = 'a' to ", "        // Initialize\
    \ an empty string for storing the encrypted string.\n        var encryptedString\
    \ = \"\"\n        // Create an empty string for storing each character of the\
    \ original string.\n        var originalString = \"\"\n        // Iterate over\
    \ the characters of the original string.\n        for (i <- 0 until s.length)\
    \ {\n            // Append a space to originalString.\n            originalString\
    \ = originalString + \" \" + s(i)\n            // Append the character at index\
    \ i to the encryptedString.\n            encryptedString = encryptedString + alphabet.charAt(i)\n\
    \        }\n        // Return the encrypted string.\n        encryptedString",
  "        var n = s.length\n        var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetCount = alphabet.size\n        var results = new Array[String](alphabetCount*2)\n\
    \        val temp = s.toList\n        temp.reverse.foreach(c => results(alphabetCount(c))\
    \ = alphabet(c))\n        results.reverse", "         var a = s.toUpperCase\n\
    \         var index = a.indexOf(\"A\")\n         if (index >= 0) {\n         \
    \   a.substring(index) = a.substring(index) + a.substring(index).substring(0,1)\
    \ \n            a.substring(0,index) = a.substring(0,index) + a.substring(0,index).substring(1)\n\
    \         }\n         return a", "        if (s.length == 0) return \"\"\n   \
    \     val letters = mutable.HashSet[String]()\n        for (c <- s.toCharArray)\
    \ letters += c.toString\n        var letter = 0\n        val rotatedLetters =\
    \ mutable.HashSet[String]()\n        while (letter < letters.size) {\n       \
    \     val letter2 = letter - 2\n            if (letter > 0) letter2 -= 1\n   \
    \         if (letter2 < 0) letter2 += 2\n            val c = letters.get(letter2)\n\
    \            if (c != null) rotatedLetters += c\n            letter += 1\n   \
    \     }\n        val finalLetters = mutable.HashSet[String]()\n        for (c\
    \ <- rotatedLetters) finalLetters += c.toString\n        for (c <- finalLetters)\
    \ finalLetters += c\n        return finalLetters.mkString", "        val alphabet\
    \ = (\"abcdefghijklmnopqrstuvwxyz\").map(c => (c + 2).asInstanceOf[Char])\n  \
    \      val rotatedAlphabet = alphabet.map(c => (c + 2).asInstanceOf[Char]).toList\n\
    \        val l = rotatedAlphabet.size\n        val r = l / 2\n        val l =\
    \ rotatedAlphabet.slice(0, r)\n        val r = rotatedAlphabet.slice(l, l)\n \
    \       val result = l + s\n        result + r", "        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.zip(alphabet.reverse).map(x => x._1).mkString(\"\
    \")\n        var i = s.length\n        var j = s.length\n        var encryptedString\
    \ = \"\"\n        while (j > 0) {\n            var t = rotatedAlphabet.charAt(j)\n\
    \            while (i >= 0) {\n                encryptedString += alphabet(i).charAt(j)\n\
    \                i -= 1\n                j -= 1\n            }\n            encryptedString\
    \ += t.charAt(j)\n            j -= 1\n        }\n        encryptedString", " \
    \       val alphabet = mutable.ArrayBuffer(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255)\n\
    \        var result = \"\"\n        var current = \"\"\n        var alphabetCount\
    \ = 1\n        for(i<-0 to s.length-1){\n            current += s(i)\n       \
    \     if(current(i)==current(i+1)){\n                alphabetCount += 1", "  \
    \      val alphabet = (\"abcdefghijklmnopqrstuvwxyz\").map(_.toChar)\n       \
    \ val n = alphabet.size\n        val rotation = Array.fill(n)(Array(0,1))\n  \
    \      var result = 0\n        var j = 0\n        s.toCharArray.foreach { \n \
    \       char => {\n            result = result * n + alphabet.indexOf(char)\n\
    \            for (k <- 0 to n) {\n                rotation k += 2\n          \
    \      rotation k %= n\n            }\n            j += rotation\n        }",
  "        val result = Array.ofDim[String](26)\n        var index = 0\n        var\
    \ c = 0\n        while(index < s.length){\n            c = index(s, index)\n \
    \           result(c + 2) = s(index).toChar\n            result(c + 1) = s(index\
    \ + 1).toChar\n            result(c + 0) = s(index + 2).toChar\n            index\
    \ = index + 3\n        }\n        return s.mkString.map(_.toChar).map(result(_))",
  "        val alphabet = List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"\
    i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"\
    v\",\"w\",\"x\",\"y\",\"z\")\n        val alphabetLength = alphabet.size\n   \
    \     var firstCharacter = s(0)\n        var lastCharacter = s(s.length-1)\n \
    \       var position = alphabet.indexOf(firstCharacter)\n        var result =\
    \ \"\"\n        var i = 0\n        while (i<s.length-1) {\n            result\
    \ += alphabet.apply(position-2)\n            position = position + 2\n       \
    \     i += 1\n        }\n        return result + alphabet.apply(position)", " \
    \       val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\
    \        var result = ''\n        for (i <- 0 until s.length){\n            result\
    \ += alphabet((alphabet.indexOf(s) + 2) % (alphabet.size))\n        }\n      \
    \  result", "        var a = \"abcdefghijklmnopqrstuvwxyz\"\n        var b = a.length\n\
    \        var ns = \"\"\n        var j = 0\n        var k = 0\n        for(i <-\
    \ 0 until s.length)\n        {\n            ns = ns + a.charAt(j) * 2\n      \
    \      j++\n            if(j > b)\n            {\n                j = 0\n    \
    \            k++\n            }\n        }\n        return ns", "        val alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val nums = \"0123456789\"\n      \
    \  val output = s.map(c => alpha.indexOf(c) + alpha.indexOf(c))\n        output.map(n\
    \ => nums.charAt(n))", "        val alphabet = Vector(\"a\",\"b\",\"c\",\"d\"\
    ,\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\"\
    ,\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        // create empty\
    \ String\n        var resultString = empty[String]\n        \n        // Iterate\
    \ over every letter in String\n        for (letter <- s) {\n            // Get\
    \ index of letter in alphabet\n            val index = alphabet.indexOf[letter]\n\
    \            // Check if letter is in alphabet\n            if (index != -1) {\n\
    \                // Get two letters after current letter\n                val\
    \ before = alphabet(index - 1)\n                val after = alphabet(index)\n\
    \                // Rotate letter if index is odd and before letter is 'a'\n \
    \               if (index % 2 != 0 && before == \"a\") {\n                   \
    \ val tempLetter = after\n                    alphabet(index) = before\n     \
    \               alphabet(index - 1) = tempLetter\n                }\n        \
    \    }\n            resultString = resultString + alphabet(index) + letter\n \
    \       }\n        resultString", "        var str = \"\"\n        var l = 0\n\
    \        while(l < s.length)\n        {\n            str += s.substring(l, l +\
    \ 1) + \"b\"\n            l += 2\n        }\n        val alphabet = str.split('').toList\n\
    \        val rotated_alphabet = alphabet.drop(alphabet.length / 2).reverse ++\
    \ alphabet.take(alphabet.length / 2).reverse\n        rotated_alphabet.map(_ +\
    \ str.charAt(0))", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toUpperCase\n\
    \        val numAlphabet = \"1234567890\".toUpperCase\n        val cipher = \"\
    \"\n        val len = s.length\n        for (i<-0 until len) {\n            cipher\
    \ += alphabet(alphabet.indexOf(s.charAt(i))+numAlphabet.indexOf(s.charAt(i)))\n\
    \        }\n        cipher", "        val alphabet = scala.collection.mutable.List('a'\
    \ to 'z')\n        val rotatedAlphabet = scala.collection.mutable.List('z' to\
    \ 'a')\n        alphabet.zip(rotatedAlphabet).foreach {\n            case (x,y)\
    \ => s = s.replace(x, y)\n        }\n        s", "        var l = s.toCharArray\n\
    \        var l2 = l.clone()\n        var l3 = l2.clone()\n        var l4 = l3.clone()\n\
    \        var l5 = l4.clone()\n        var l6 = l5.clone()\n        l2.reverse()\n\
    \        l5.reverse()\n        l6.reverse()\n        for( i <- 0 until l.length\
    \ ) {\n            l3(i) = l2(i+2)\n        }\n        l2.clear()\n        l2.add(l3)\n\
    \        l2.add(l4)\n        l2.add(l5)\n        l2.add(l6)\n        l2.toCharArray()",
  "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val rotator = alphabet.map(c\
    \ => (c, c + 2)).iterator\n        val res = s.foldLeft(\"\", \"\")((acc, c) =>\
    \ acc + rotator.next()._1)\n        val rotator2 = alphabet.map(c => (c, c + 2)).iterator\n\
    \        val res2 = res.foldLeft(\"\", \"\")((acc, c) => acc + rotator2.next()._1)\n\
    \        res2", "        val alphabet = (65 until 90) map { c =>\n           \
    \ (c.toDouble + 4).toChar\n        }\n        val rotated = (alphabet zip alphabet.toList.tail)\
    \ map {\n            case (acc, n) => acc * 2 + (n - 65)\n        }\n\n      \
    \  val n = s.length\n        val l = ((n div (2 * 2)) + (1 until 2)).product\n\
    \        val r = (n div l) - (1 until 2)\n        val m = ((2 * n) - r).product\n\
    \        val p = (l + (m / 2))\n\n        val p0 = alphabet.indexWhere(c => c\
    \ == p) match {\n            case Some(index) => index\n            case None\
    \ => 0\n        }\n        val p1 = alphabet.indexWhere(c => c == p + 1) match\
    \ {\n            case Some(index) => index\n            case None => 0\n     \
    \   }\n        val p2 = alphabet.indexWhere(c => c == p + 2) match {\n       \
    \     case Some(index) => index\n            case None => 0\n        }\n     \
    \   val p3 = alphabet.indexWhere(c => c == p + 3) match {\n            case Some(index)\
    \ => index\n            case None => 0\n        }\n        val p4 = alphabet.indexWhere(c\
    \ => c == p + 4) match {\n            case Some(index) => index\n            case\
    \ None => 0\n        }\n        val p5 = alphabet.indexWhere(c => c == p + 5)\
    \ match {\n            case Some(index) => index\n            case None => 0\n\
    \        }\n        val p6 = alphabet.indexWhere(c => c == p + 6) match {\n  \
    \          case Some(index) => index\n            case None => 0\n        }\n\
    \        val p7 = alphabet.indexWhere(c => c == p + 7) match {\n            case\
    \ Some(index) => index\n            case None => 0\n        }\n        val p8\
    \ = alphabet.indexWhere(c => c == p + 8) match {\n            case Some(index)\
    \ => index\n            case None => 0\n        }\n        val p9 = alphabet.indexWhere(c\
    \ => c == p + 9) match {\n            case Some(index) => index\n            case\
    \ None => 0\n        }\n\n        val t = ((p0 - p1) + (p0 - p2) + (p0 - p3))\
    \ + ((p0 - p4) + (p0 - p5) + (p0 - p6)) + ((p0 - p7) + (p0 - p8) + (p0 - p9))\n\
    \        val u = ((p1 - p2) + (p1 - p3) + (p1 - p4)) + ((p1 - p5) + (p1 - p6",
  "        var resultString = s\n        for( i <- 0 until resultString.length) resultString\
    \ = resultString.substring(0,i) + rotate(resultString.substring(0,i)) + resultString.substring(i+1)",
  "        // Get a mutable copy of s\n        val sCopy = s.toList\n        // Get\
    \ a mutable copy of alpha\n        val alphaCopy = mutable.ListBuffer.empty[Char]\n\
    \        alphaCopy ++= s.toArray.flatMap(c => \n                            scala.math.pow(2,\
    \ alphaCopy.length).map(l => if (c > l) c - l else c - l)\n                  \
    \      )\n        // Rotate the mutable copy (by rotating alphaCopy) by rotating\
    \ the \n        // input string (by multiplying letters down by 2) in succession.\n\
    \        for (x <- 0 until s.length) alphaCopy.tail :+ alphaCopy.head :+ alphaCopy.head\n\
    \        sCopy.zipWithIndex.map(c => if (c._1 == 0) c._2 else c._1 - 2)\n    \
    \        .map(c => if (alphaCopy.contains(c.asInstanceOf[Char])) c.asInstanceOf[Char]\
    \ else c.asInstanceOf[String](0))\n            .map(c => if (c.isUpper) c.toUpperCase()\
    \ else c.toLowerCase())\n            .mkString(\"\")", '        // TODO: implement
    encrypt', "        val c = (\"abcdefghijklmnopqrstuvwxyz\".toList zip \"abcdefghijklmnopqrstuvwxyz\"\
    .toList zip \"abcdefghijklmnopqrstuvwxyz\".toList zip \"abcdefghijklmnopqrstuvwxyz\"\
    .toList zip \"abcdefghijklmnopqrstuvwxyz\".toList zip \"abcdefghijklmnopqrstuvwxyz\"\
    .toList zip \"abcdefghijklmnopqrstuvwxyz\".toList zip \"abcdefghijklmnopqrstuvwxyz\"\
    .toList zip \"abcdefghijklmnopqrstuvwxyz\".toList zip \"abcdefghijklmnopqrstuvwxyz\"\
    .toList zip \"abcdefghijklmnopqrstuvwxyz\".toList zip \"abcdefghijklmnopqrstuvwxyz\"\
    .toList zip \"abcdefghijklmnopqrstuvwxyz\".toList).find(_.apply(s.charAt(0))).map{case\
    \ (c, (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s))=>{\n            val x = (s.length+2)/2;\n\
    \            val y = (s.length+3)/2;\n            val z = (s.length+4)/2;\n  \
    \          val aa = (s.length+5)/2;\n            val ab = (s.length+6)/2;\n  \
    \          val ac = (s.length+7)/2;\n            val ad = (s.length+8)/2;\n  \
    \          val ae = (s.length+9)/2;\n            val af = (s.length+10)/2;\n \
    \           val ag = (s.length+11)/2;\n            val ah = (s.length+12)/2;\n\
    \            val ai = (s.length+13)/2;\n            val aj = (s.length+14)/2;\n\
    \            val ak = (s.length+15)/2;\n            val al = (s.length+16)/2;\n\
    \            val am = (s.length+17)/2;\n            val an = (s.length+18)/2;\n\
    \            val ao = (s.length+19)/2;\n            val ap = (s.length+20)/2;\n\
    \            val aq = (s.length+21)/2;\n            val ar = (s.length+22)/2;\n\
    \            val as = (s.length+23)/2;\n            val at = (s.length+24)/2;\n\
    \            val au = (s.length+25)/2;\n            val av = (s.length+26)/2;\n\
    \            val aw = (s.length+27)/2;\n            val ax = (s.length+28", " \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        val\
    \ alphabetRotated = \"ghijklmnopqrstuvwxyzabcdef\".toCharArray\n        val result\
    \ = new mutable.ListBuffer[String]()\n        \n        val chars = s.toCharArray\n\
    \        for ( i <- 0 until chars.length )\n            result.append( alphabetRotated(\
    \ alphabet.indexOf( chars( i ) ) + 2 ) )\n        result.toString", "        val\
    \ letters = mutable.HashSet[Char]()\n        letters += 'a'\n        letters +=\
    \ 'b'\n        letters += 'c'\n        letters += 'd'\n        letters += 'e'\n\
    \        letters += 'f'\n        letters += 'g'\n        letters += 'h'\n    \
    \    letters += 'i'\n        letters += 'j'\n        letters += 'k'\n        letters\
    \ += 'l'\n        letters += 'm'\n        letters += 'n'\n        letters += 'o'\n\
    \        letters += 'p'\n        letters += 'q'\n        letters += 'r'\n    \
    \    letters += 's'\n        letters += 't'\n        letters += 'u'\n        letters\
    \ += 'v'\n        letters += 'w'\n        letters += 'x'\n        letters += 'y'\n\
    \        letters += 'z'\n        val result = new StringBuilder\n        for (c\
    \ <- s)\n            if (letters.contains(c))\n                result.append(letters(letters.indexOf(c)\
    \ + 1))\n            else\n                result.append(c)\n        result.toString()",
  "        val alphabet = (\"a\"..\"z\").map(_.toString).toSet\n        val newAlphabet\
    \ = (\"a\"..\"z\").map(_.toString).map(x => alphabet.swap(x)) // shuffle the alphabet\n\
    \        val s = alphabet.zip(newAlphabet).map { \n            case (k, v) =>\
    \ k.zip(v).map(_ + k).zip(v).toSet.toList // combine letters with their original\
    \ value\n        }.flatMap(x => x.map(_.toString)) // flatten the new alphabet\n\
    \        s.map(x => newAlphabet(alphabet(s.indexOf(x)))) // return new alphabet ",
  "      val alphabet = \"abcdefghijklmnopqrstuvwxyz\".toList\n      val rotatedAlphabet\
    \ = alphabet.map{a => a.toUpperCase().concat(alphabet.map{b => b.concat(a.toUpperCase()).reverse}).reverse}.flatten\n\
    \      s.toList.map(letter => rotatedAlphabet.map{letter => letter.toString.concat(letter.toUpperCase)}.getOrElse(letter))",
  "        def rotate(str : String) : String = {\n            val alphabet = (\"abcdefghijklmnopqrstuvwxyz\"\
    ).toList\n            val len = str.length\n            val mid = (len - 1) /\
    \ 2\n            var i = 0\n            while (i < len) {\n                val\
    \ tmp = alphabet(i + (mid * 2) - 1)\n                if (tmp == str.charAt(i))\
    \ {\n                    val newStr = (str - str.substring(i, mid) + str.substring(mid,\
    \ i)).substring(1)\n                    newStr\n                } else {\n   \
    \                 (str - str.substring(i, mid) + str.substring(mid, i)).substring(1)\n\
    \                }\n                i += 1\n            }\n        }\n       \
    \ val newStr = rotate(s)\n        if (newStr.length == 1) {\n            newStr\n\
    \        } else {\n            val newLen = newStr.length\n            val newMid\
    \ = (newLen - 1) / 2\n            var i = 0\n            while (i < newLen) {\n\
    \                val tmp = alphabet(i + (newMid * 2) - 1)\n                if\
    \ (tmp == newStr.charAt(i)) {\n                    val newStr = (newStr - newStr.substring(i,\
    \ newMid) + newStr.substring(newMid, i)).substring(1)\n                    newStr\n\
    \                } else {\n                    (newStr - newStr.substring(i, newMid)\
    \ + newStr.substring(newMid, i)).substring(1)\n                }\n           \
    \     i += 1\n            }\n        }", "        val alphabet : Set[Char] = ('a'\
    \ to 'z') ++ (\n                'A' to 'Z') ++ (\n                '0' to '9')\n\
    \        val alphaIndexMap = alphabet.zipWithIndex.toMap\n        var i = 0\n\
    \        var ret = \"\"\n        while (i < s.length) {\n            var a = s(i)\n\
    \            val x = a.toInt\n            val y = x - 1\n            val z = x\
    \ + 1\n            if (y == 0 || z == alphabet.length) {\n                ret\
    \ = ret +\n                        alphabet(alphaIndexMap(alphabet(y)) + 1)\n\
    \            } else {\n                ret = ret +\n                        alphabet(alphaIndexMap(alphabet(y)))\
    \ +\n                        alphabet(alphaIndexMap(alphabet(z)))\n          \
    \  }\n            i += 1\n        }\n        return ret", "        val alphabet\
    \ = Array('z', 'y', 'x', 'w', 'u', 't', 's', 'r', 'q', 'p')\n        var encryptedStr\
    \ = \"\"\n        var count = 0\n\n        for (c <- s) {\n            count +=1\n\
    \            val index = alphabet.indexOf(c) + 2\n            if (index >= alphabet.length)\
    \ index = index - alphabet.length\n            encryptedStr += alphabet(index)\n\
    \        }\n        return encryptedStr", "        var ans = new StringBuilder\n\
    \        for (x <- s) {\n            val l = x\n            var j = 0\n      \
    \      while (j < 2) {\n                val temp = l\n                l = (l rotLeft\
    \ 1)\n                j += 1\n            }\n            ans += l\n        }\n\
    \        return ans.toString", "      // Find the characters in the input string\
    \ that are a member of the alphabet.\n      // The list returned should include\
    \ only the characters that will be shifted.\n      // For example, if there are\
    \ 5 characters in the input string, then this list should include\n      // the\
    \ letters i, j, k, l, m in the correct order (as described above).\n      val\
    \ alphabet = mutable.List('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\
    \      \n      \n      // Find the indexes of the characters that are in the input\
    \ string that are member of the alphabet.\n      val ind = s match {\n       \
    \ case \"\" => Nil\n        case s => s.zipWithIndex.filter( z => alphabet.toSet.contains(z._1)).map(\
    \ z => z._2 ).toList\n      }\n      \n      // If the string contains any characters\
    \ that are not members of the alphabet, then return the string as it is.\n   \
    \   if (ind.isEmpty) s\n      // Otherwise, create an empty list to hold the new\
    \ string.\n      else (0 until ind.length).map( i => alphabet(ind(i)) ).mkString(\"\
    \")", "        val result = s.toList.zip(alphabet.toList).map(\n            i\
    \ => i._1 + i._2\n        ).mkString(\"\")\n        alphabet = alphabet.updated(0,\
    \ alphabet.last)\n        alphabet = alphabet.updated(1, alphabet.last)\n    \
    \    alphabet = alphabet.updated(2, alphabet.last)\n        alphabet = alphabet.updated(3,\
    \ alphabet.last)\n        alphabet = alphabet.updated(4, alphabet.last)\n    \
    \    alphabet = alphabet.updated(5, alphabet.last)\n        alphabet = alphabet.updated(6,\
    \ alphabet.last)\n        alphabet = alphabet.updated(7, alphabet.last)\n    \
    \    alphabet = alphabet.updated(8, alphabet.last)\n        alphabet = alphabet.updated(9,\
    \ alphabet.last)\n        alphabet = alphabet.updated(10, alphabet.last)\n   \
    \     alphabet = alphabet.updated(11, alphabet.last)\n        alphabet = alphabet.updated(12,\
    \ alphabet.last)\n        alphabet = alphabet.updated(13, alphabet.last)\n   \
    \     alphabet = alphabet.updated(14, alphabet.last)\n        alphabet = alphabet.updated(15,\
    \ alphabet.last)\n        alphabet = alphabet.updated(16, alphabet.last)\n   \
    \     alphabet = alphabet.updated(17, alphabet.last)\n        alphabet = alphabet.updated(18,\
    \ alphabet.last)\n        alphabet = alphabet.updated(19, alphabet.last)\n   \
    \     alphabet = alphabet.updated(20, alphabet.last)\n        alphabet = alphabet.updated(21,\
    \ alphabet.last)\n        alphabet = alphabet.updated(22, alphabet.last)\n   \
    \     alphabet = alphabet.updated(23, alphabet.last)\n        alphabet = alphabet.updated(24,\
    \ alphabet.last)\n        alphabet = alphabet.updated(25, alphabet.last)\n   \
    \     alphabet = alphabet.updated(26, alphabet.last)\n        alphabet = alphabet.updated(27,\
    \ alphabet.last)\n        alphabet = alphabet.updated(28, alphabet.last)\n   \
    \     alphabet = alphabet.updated(29, alphabet.last)\n        alphabet = alphabet.updated(30,\
    \ alphabet.last)\n        alphabet = alphabet.updated(31, alphabet.last)\n   \
    \     alphabet = alphabet.updated(32, alphabet.last)\n        alphabet = alphabet.updated(33,\
    \ alphabet.last)\n        alphabet = alphabet.updated(34, alphabet.last)\n   \
    \     alphabet = alphabet.updated(35, alphabet.last)\n        alphabet = alphabet.updated(36,\
    \ alphabet.last)\n        alphabet = ", "        val alphabet = Array('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \        val encryptedString = mutable.StringBuilder(s)\n        for ((c, i) in\
    \ s.zipWithIndex) {\n            val rotatedAlphabet = rot90(alphabet(alphabet.indexOf(c)),\
    \ 2)\n            encryptedString.append(rotatedAlphabet(i))\n        }\n    \
    \    encryptedString.toString", "       val alphabet = List(\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\")\n       var index = alphabet.indexOf(s)\n       var newString = \"\"\n\
    \       while(index != -1) {\n           newString = newString + alphabet(alphabet.size\
    \ - 1 - index) + alphabet(index)\n           index = alphabet.indexOf(s, index\
    \ + 1)\n       }\n       newString", "        val alphabet = new Array[Char](26)\n\
    \        for(i <- 0 to 25) {\n            alphabet(i) = ('A' + i)\n        }\n\
    \        val newStr = new StringBuilder()\n        for(i <- 0 to s.length - 1)\
    \ {\n            newStr.append(alphabet(s.charAt(i).toChar - 1))\n           \
    \ newStr.append(alphabet(s.charAt(i+1).toChar + 2))\n        }\n        return\
    \ newStr.toString", "        def rotation(s: String): String = {\n           \
    \ val (n, _) = s.split('') match {\n                case Nil => throw new IllegalArgumentException(\"\
    invalid string\")\n                case x :: xs => (x.toInt * 2).map(x => (x -\
    \ 97).mod(26) + 97).toString + xs\n            }\n            rotatedString :\
    \ String = n\n        }\n        if (s.length == 0) throw new IllegalArgumentException(\"\
    invalid string\")\n        rotation(s)", "        // Write your answer here\n\
    \        val alphabet = List(\n            'a' -> 'b',\n            'b' -> 'c',\n\
    \            'c' -> 'a',\n            'd' -> 'e',\n            'e' -> 'd',\n \
    \           'f' -> 'g',\n            'g' -> 'f',\n            'h' -> 'j',\n  \
    \          'j' -> 'h',\n            'k' -> 'l',\n            'l' -> 'k',\n   \
    \         'm' -> 'n',\n            'n' -> 'm',\n            'o' -> 'p',\n    \
    \        'p' -> 'o',\n            'q' -> 'r',\n            'r' -> 'q',\n     \
    \       's' -> 't',\n            't' -> 's',\n            'u' -> 'v',\n      \
    \      'v' -> 'u',\n            'w' -> 'x',\n            'x' -> 'w',\n       \
    \     'y' -> 'z',\n            'z' -> 'y'\n        ).map{case (k,v) => k -> v}.map(x=>x._2)\n\
    \        var x = 0\n        var y = 1\n        var z = 2\n        var result =\
    \ \"\"\n        for(c <- s) {\n            result += (alphabet(c).toChar - 'a'\
    \ * 2).toChar\n            result += (alphabet(c).toChar - 'b' * 2).toChar\n \
    \           result += (alphabet(c).toChar - 'c' * 2).toChar\n            result\
    \ += (alphabet(c).toChar - 'd' * 2).toChar\n            result += (alphabet(c).toChar\
    \ - 'e' * 2).toChar\n            result += (alphabet(c).toChar - 'f' * 2).toChar\n\
    \            result += (alphabet(c).toChar - 'g' * 2).toChar\n            result\
    \ += (alphabet(c).toChar - 'h' * 2).toChar\n            result += (alphabet(c).toChar\
    \ - 'j' * 2).toChar\n            result += (alphabet(c).toChar - 'k' * 2).toChar\n\
    \            result += (alphabet(c).toChar - 'l' * 2).toChar\n            result\
    \ += (alphabet(c).toChar - 'm' * 2).toChar\n            result += (alphabet(c).toChar\
    \ - 'n' * 2).toChar\n            result += (alphabet(c).toChar - 'o' * 2).toChar\n\
    \            result += (alphabet(c).toChar - 'p' * 2).toChar\n            result\
    \ += (alphabet(c).toChar - 'q' * 2).toChar\n            result += (alphabet(c).toChar\
    \ - 'r' * 2).toChar\n            result += (alphabet(c).toChar - 't' * 2).toChar\n\
    \            result += (alphabet(c).to", "        // A map from each character\
    \ to its position in the alphabet.\n        val alphabet = Map('A' -> 0, 'B' ->\
    \ 1, 'C' -> 2, 'D' -> 3, 'E' -> 4, 'F' -> 5, 'G' -> 6, 'H' -> 7, 'I' -> 8, 'J'\
    \ -> 9, 'K' -> 10, 'L' -> 11, 'M' -> 12, 'N' -> 13, 'O' -> 14, 'P' -> 15, 'Q'\
    \ -> 16, 'R' -> 17, 'S' -> 18, 'T' -> 19, 'U' -> 20, 'V' -> 21, 'W' -> 22, 'X'\
    \ -> 23, 'Y' -> 24, 'Z' -> 25)\n        // A map from each character to the corresponding\
    \ letter which comes before it.\n        val positions = Map('A' -> 'B', 'C' ->\
    \ 'D' /* ... */, 'K' -> 'L', 'M' -> 'N' /* ... */)\n        // A map from each\
    \ letter in the alphabet to its corresponding \n        // letter in the rotated\
    \ alphabet.\n        val rotated_alphabet = Map(alphabet ++ Map(Map(A -> Z) zip\
    \ alphabet zip alphabet -- alphabet -- Map(Z -> A)).map(_ -> _).toMap)\n     \
    \   // Create a list out of the string, then map each letter in the string \n\
    \        // to the corresponding letter in the rotated alphabet.\n        s.split('\
    \ ').map(c => rotated_alphabet(c).toSeq.head).toList", "        val rotated_alphabet\
    \ = alphabet.map(s => s.drop(2)).zipWithIndex.map{ case (s, i) => s.take(i + 2)\
    \ }.flatten\n        val rotated_s = s ++ rotated_alphabet.reverse\n        rotated_s.tail",
  "        // TODO: Write your code here\n        var newString = \"\"\n        for(i\
    \ <- 0 until s.length){\n            newString += s.charAt(i) + s.charAt(s.length\
    \ - i - 1)\n        }\n        newString", "        def rotate(ch : Char) : Char\
    \ = ch == 'z' ? 'y' : ch == 'a' ? 'x' : ch\n        s.toList\n            .map\
    \ (ch => if (ch == 'a') 'z' else if (ch == 'z') 'a' \n                    else\
    \ rotate(ch))\n            .toList\n            .toSeq\n            .map (ch =>\
    \ ch * 2)\n            .mkString", "        // Implement your solution to Problem\
    \ 3 here\n        val alphabet = Array('z','y','x','w','v','u','t','s','r','q','p','o','n','m','l','k')\n\
    \        val res = for (c <- alphabet) yield {\n            if (c.equals(s.charAt(0))\
    \ || (s.charAt(0).equals(c) && s.charAt(1).equals(c))) {\n                c.toChar\n\
    \            } else if (c.equals(s.charAt(s.length() - 1)) || (s.charAt(s.length()\
    \ - 1).equals(c) && s.charAt(s.length() - 2).equals(c))) {\n                c.toChar\n\
    \            } else {\n                c.toChar + c.toChar\n            }\n  \
    \      }\n        new String(res)", '        val alphabet = Array("q","w","e","r","t","y","u","i","o","p","a","s","d","f","g","h","j","k","l","z","x","c","v","b","n","m","
    ","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","0","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x","c","v","b","n","m","-","z","x',
  "        var res = \"\"\n        var tmp = \"\"\n        for (i <- 0 until s.length)\
    \ \n        {\n            if (i < s.length / 2) \n            {\n           \
    \     res += tmp\n                tmp = s[i]\n            } else {\n         \
    \       tmp = s[i]\n                res += tmp\n                tmp = \"\"\n \
    \           }\n        }\n        res += tmp\n        return res", "       //\
    \ Find the alphabet size\n       val alphabetSize = s.length\n\n       // Create\
    \ a mutable array to store the final result\n       val charArray = mutable.ArrayBuffer.empty[Char]\n\
    \n       // Loop through the string and add the letters to the array\n       for\
    \ (i <- 0 until s.length)\n           charArray.append(s(i).charAt(alphabetSize\
    \ - 1))\n\n       // Create the new alphabet and rotate the array\n       val\
    \ alphabet = Array.ofDim[Char](alphabetSize)\n       for (i <- 0 until alphabetSize)\n\
    \           alphabet(i) = charArray(i).charAt(0) - 'a'\n\n       // Loop through\
    \ each character in the string, increment the index\n       // by the number of\
    \ letters in the rotated alphabet\n       for (i <- 0 until s.length)\n      \
    \     charArray(i) = s(i).charAt(0)\n           for ((index, letter) <- charArray\
    \ zip alphabet)\n               charArray(i) += letter\n\n       charArray.toArray",
  "        // Use a mutable buffer to hold the result string\n        var result =\
    \ new StringBuilder()\n        // Use a mutable buffer to hold the current character\
    \ of the alphabet\n        var buffer = new StringBuilder()\n        // Iterate\
    \ over each character in the input string\n        for (c <- s) {\n          \
    \  // Get a single character out of the alphabet\n            buffer.append(alphabet.charAt(alphabet.indexOf(c)\
    \ + 1))\n            // Get the location of the character in the alphabet\n  \
    \          // That is subtract 1 from it's ASCII value because we want \n    \
    \        // it to shift down by two and then add the value at the \n         \
    \   // location of the character to the buffer\n            // The -1 because\
    \ we want to add an extra 2 so we don't \n            // miss the letters that\
    \ should be shifted down a bit\n            buffer.append(alphabet.indexOf(c -\
    \ alphabet.charAt(alphabet.indexOf(c) + 1)) - 1 + alphabet.charAt(alphabet.indexOf(c)\
    \ + 1))\n            // Append the result to the mutable buffer\n            result.append(buffer.reverse)\n\
    \        }\n        // Return the result string\n        return result.toString()",
  "        // TODO: Write code here\n        return s.toCharArray()", "        val\
    \ alphabet = new mutable.ListBuffer[String]()\n        var index = 0\n       \
    \ var x = 0\n        while(x<s.length){\n            alphabet += s.substring(x,x+1).mkString\n\
    \            x += 2\n            index += 1\n        }\n        val newAlphabet\
    \ = alphabet.map(elem => elem.substring(1, elem.length))\n        val newIndex\
    \ = new mutable.ListBuffer[String]()\n        for(i<-1 to newAlphabet.length-1){\n\
    \            newIndex += newAlphabet(i)\n        }\n        newIndex.toList",
  "        var alphabet = scala.collection.mutable.MutableList.empty[Char]\n     \
    \   alphabet += ('a' to 'z')\n        alphabet += ('A' to 'Z')\n        alphabet\
    \ += ('0' to '9')\n        for (i <- 0 until s.length)\n            alphabet =\
    \ alphabet.tail ++ alphabet.head + alphabet.tail\n\n        val cipher = scala.collection.mutable.MutableList.empty[String]\n\
    \        var index = 0\n        for (i <- 0 until s.length)\n            cipher\
    \ = cipher ++ alphabet(alphabet(s.charAt(i).toInt + index) % alphabet.length)\n\
    \            index += 2\n        cipher.reverse", "        val alphabet = List(\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\")\n        val rep = alphabet.reverse\n        val newAlph\
    \ = alphabet.foldLeft(rep.tail) {\n            (acc: List[Char], x: Char) => acc.last::(x::acc)\n\
    \        }\n        rep.reverse::newAlph", '        // Implement this method',
  "        var newString = \"\"\n        var newAlphabet = scala.collection.mutable.List(\"\
    t\",\"h\",\"o\",\"z\",\"g\",\"x\",\"y\",\"p\",\"f\",\"m\",\"l\",\"j\",\"i\",\"\
    n\",\"k\")\n        newAlphabet.tail = alphabet.tail.reverse.dropWhile(elem =>\
    \ elem != \"t\")\n        newAlphabet.head += alphabet.head\n        newAlphabet\
    \ = alphabet.tail.reverse.dropWhile(elem => elem != \"t\")\n        newAlphabet\
    \ ++= alphabet.head\n        newAlphabet = newAlphabet.reverse\n        \n   \
    \     var i = 0\n        while(i<s.length){\n            var j = 0\n         \
    \   while(j<newAlphabet.length){\n                if(s(i) == newAlphabet(j)){\n\
    \                    newString += s(i)\n                    j++\n            \
    \    }else{\n                    newString += newAlphabet(j)\n               \
    \     j++\n                }\n            }\n            i+=1\n        }\n   \
    \     return newString", "        val map = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- s.length)\n            map(i) = s.charAt(i)\n        val map2\
    \ = map.map(e => e + 2).map(e => e % 26).map(e => e + 1).map(e => e % 26)\n  \
    \      val map3 = map2.map(e => e + 2).map(e => e % 26).map(e => e + 1).map(e\
    \ => e % 26)\n        val map4 = map3.map(e => e + 2).map(e => e % 26).map(e =>\
    \ e + 1).map(e => e % 26)\n        val map5 = map4.map(e => e + 2).map(e => e\
    \ % 26).map(e => e + 1).map(e => e % 26)\n        val map6 = map5.map(e => e +\
    \ 2).map(e => e % 26).map(e => e + 1).map(e => e % 26)\n        val map7 = map6.map(e\
    \ => e + 2).map(e => e % 26).map(e => e + 1).map(e => e % 26)\n        val map8\
    \ = map7.map(e => e + 2).map(e => e % 26).map(e => e + 1).map(e => e % 26)\n \
    \       val map9 = map8.map(e => e + 2).map(e => e % 26).map(e => e + 1).map(e\
    \ => e % 26)\n        val map10 = map9.map(e => e + 2).map(e => e % 26).map(e\
    \ => e + 1).map(e => e % 26)\n        val map11 = map10.map(e => e + 2).map(e\
    \ => e % 26).map(e => e + 1).map(e => e % 26)\n        val map12 = map11.map(e\
    \ => e + 2).map(e => e % 26).map(e => e + 1).map(e => e % 26)\n        val map13\
    \ = map12.map(e => e + 2).map(e => e % 26).map(e => e + 1).map(e => e % 26)\n\
    \        val map14 = map13.map(e => e + 2).map(e => e % 26).map(e => e + 1).map(e\
    \ => e % 26)\n        val map15 = map14.map(e => e + 2).map(e => e % 26).map(e\
    \ => e + 1).map(e => e % 26)\n        val map16 = map15.map(e => e + 2).map(e\
    \ => e % 26", "        // We need to rotate each letter of the alphabet by two\
    \ in two places\n        // This is done by subtracting two from the alphabet\
    \ size and multiplying\n        // by two\n        val alphabet = s.toCharArray.map(x\
    \ => (x-'a')*2+(x-'a')).toArray\n        val newString = new StringBuilder\n \
    \       val currentIndex = 0;\n        val newIndex = 0;\n        while(newIndex\
    \ < s.length) {\n            val c = alphabet(currentIndex);\n            newString.append(c);\n\
    \            newIndex += c.length\n            currentIndex += c.length\n    \
    \    }\n        newString.toString", "        var alphabet = new mutable.Array[Char](26)\n\
    \        var i = 0\n        alphabet :+= 97\n        alphabet :+= 65\n       \
    \ alphabet :+= 65\n        alphabet :+= 97\n        alphabet :+= 65\n        alphabet\
    \ :+= 65\n        alphabet :+= 97\n\n        var n = s.length\n        var s =\
    \ s\n        while (i < n) {\n            val a = s.charAt(i).toInt\n        \
    \    var r = a\n            var j = 0\n            var k = 0\n            while\
    \ (j < 26) {\n                var b = alphabet(j)\n                var c = s.charAt(j).toInt\n\
    \                var d = a - b\n                var e = c + d\n              \
    \  alphabet(j) = e\n                r = (e + a) % 26\n                j = j +\
    \ 1\n            }\n            s = r\n            i = i + 1\n        }\n    \
    \    alphabet.reverse\n        s.toCharArray", '        // TODO: Write code to
    implement this function', "        // Create a mutable string of the same length\
    \ but initially empty.\n        val encrypt : MutableList[Char] = MutableList[Char]()\n\
    \        var i = 0\n        // Populate the string with the characters rotated\
    \ down by two.\n        for (j <- 0 until s.length()) {\n            encrypt +=\
    \ s.charAt(i).toChar\n            i +=1\n        }\n        // Append the \"encrypted\"\
    \ string to the result string.\n        s + encrypt(encrypt(s).toString)", " \
    \       def rotate(letter : Char, alphabet : Array[Char], index :Int) : String\
    \ = {\n            val c = alphabet get(index) //get the next letter\n       \
    \     val n = alphabet size\n            index = (index+n) % n //make index wrap\
    \ around\n            alphabet updated(index, c) //move the letter down\n    \
    \        alphabet apply(index)//return letter at index\n        }\n        var\
    \ index = 0\n        val alphabet = Array('z','y','x','w','v','u','t','s','r','q','p','o','n','m','l','k','j','i','h','g','f')\n\
    \        s.replaceAll(\"([a-zA-Z])\",{x => rotate(x, alphabet, index++)})", " \
    \     var alphabet = scala.collection.mutable.ListBuffer[String]()\n      var\
    \ alphabetCount = scala.collection.mutable.ListBuffer[Int]()\n      // Initialize\
    \ the alphabet with each letter occuring twice \n      // The number of times\
    \ it occurs determines the rotation.\n      s split \"\" foreach {\n        a\
    \ => alphabet += a\n        alphabetCount += a.toChar.length * 2\n      }\n  \
    \    // The final string is formed with the original letters and the rotated letters\n\
    \      alphabet += alphabet.slice(alphabetCount.length)\n      alphabetCount +=\
    \ alphabetCount.length\n      var newString = s split \"\" map {\n        a =>\
    \ alphabet += a\n      }\n      // The letters of the alphabet are rotated in\
    \ the alphabet by twos.\n      alphabetCount += 1\n      alphabet = alphabet.slice(alphabetCount)\n\
    \      alphabetCount += alphabetCount.length\n      alphabetCount -= 1\n     \
    \ alphabet += alphabet.slice(alphabetCount)\n      // Convert each letter to a\
    \ string and return the string joined to one string.\n      newString = newString.map\
    \ {\n        a => a.toChar\n      }.toString.toString + newString.dropRight(1)\n\
    \      newString", "        val alphabet = Array('A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z')\n        val rotated : Array[Char] = Array('A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z').map(_ + 2).map(_ + 2)\n        val result\
    \ = s.map(c => {\n            (c to rotated) match {\n                case (a,\
    \ b) => a to b\n                case _ => c\n            }\n        }).mkString\n\
    \        result", "        var ret = \"\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        for(i <- 0 until s.length){\n            ret += alphabet.charAt(s.charAt(i)\
    \ - 1)\n            ret += alphabet.charAt(alphabet.indexOf(s.charAt(i)) + 2)\n\
    \        }\n        ret", "        var a = s.toCharArray\n        var x = 1\n\
    \        var y = a(0)\n        var z = a(0)\n        var b = \"\"\n\n        while\
    \ (a.length > 1) {\n            z -= a(0)\n            y += (z-y) * x\n      \
    \      b += y.toString\n            z += a(0)\n            x += (z-y) * x\n  \
    \      }\n        return b", "        var result = \"\"\n        var alphabet\
    \ = (\"abcdefghijklmnopqrstuvwxyz\")\n\n        val len = s.length\n        for\
    \ (i<-0 until len){\n            var char1 = alphabet(s.charAt(i).toInt) + 2\n\
    \            var char2 = alphabet(s.charAt(i).toInt) + 4\n            var char3\
    \ = alphabet(s.charAt(i).toInt) + 6\n            var char4 = alphabet(s.charAt(i).toInt)\
    \ + 8\n\n            var char5 = alphabet(char1.toInt) + 2\n            var char6\
    \ = alphabet(char2.toInt) + 4\n            var char7 = alphabet(char3.toInt) +\
    \ 6\n            var char8 = alphabet(char4.toInt) + 8\n\n            var char9\
    \ = alphabet(char5.toInt) + 2\n            var char10 = alphabet(char6.toInt)\
    \ + 4\n            var char11 = alphabet(char7.toInt) + 6\n            var char12\
    \ = alphabet(char8.toInt) + 8\n\n            var char13 = alphabet(char9.toInt)\
    \ + 2\n            var char14 = alphabet(char10.toInt) + 4\n            var char15\
    \ = alphabet(char11.toInt) + 6\n            var char16 = alphabet(char12.toInt)\
    \ + 8\n\n            var char17 = alphabet(char13.toInt) + 2\n            var\
    \ char18 = alphabet(char14.toInt) + 4\n            var char19 = alphabet(char15.toInt)\
    \ + 6\n            var char20 = alphabet(char16.toInt) + 8\n\n            var\
    \ char21 = alphabet(char17.toInt) + 2\n            var char22 = alphabet(char18.toInt)\
    \ + 4\n            var char23 = alphabet(char19.toInt) + 6\n            var char24\
    \ = alphabet(char20.toInt) + 8\n\n            result += alphabet((char1.toInt)\
    \ + 4)\n            result += alphabet((char2.toInt) + 4)\n            result\
    \ += alphabet((char3.toInt) + 4)\n            result += alphabet((char4.toInt)\
    \ + 4)\n\n            result += alphabet((char5.toInt) + 4)\n            result\
    \ += alphabet((char6.toInt) + 4)\n            result += alphabet((char7.toInt)\
    \ + 4)\n            result += alphabet((char8.toInt) + 4)\n\n            result\
    \ += alphabet((char9.toInt) + 4)\n            result += alphabet((char10.toInt)\
    \ + 4)\n            result += alphabet((char11.toInt) + 4)\n            result\
    \ += alphabet((char12.toInt) + 4)\n\n            result += alphabet((char13.toInt)\
    \ + 4)\n            result += alphabet((char14.toInt) + 4)\n            result\
    \ += alphabet((char15.toInt) + 4)\n            result += alphabet((char16.toInt)\
    \ + 4)\n\n            result += alphabet((char17.toInt) + 4)\n            result\
    \ += alphabet((char18.to", "       def rot13(c:String) : String = {\n        \
    \ val rot13 = c.toCharArray\n         val result = new Array[Char](c.length)\n\
    \         val length = rot13.length\n         var i = 0\n         while (i < rot13.length)\
    \ {\n           val c = rot13(i)\n           if (c >= 'a' && c <= 'm')\n     \
    \         c = (c - 'a' + 13) % 26 + 'a' // rot13 alphabet\n           if (c >=\
    \ 'A' && c <= 'M')\n              c = (c - 'A' + 13) % 26 + 'A' // rot13 alphabet\n\
    \           result(i) = c\n           i += 1\n         }\n         new String(result)\n\
    \       }\n       val enc = s.toCharArray\n       val length = enc.length\n  \
    \     var i = 0\n       var result = new StringBuilder(enc.length)\n       while\
    \ (i < enc.length) {\n         val c = enc(i)\n         if (c >= 'a' && c <= 'm')\n\
    \           c = rot13(c.toString)\n         if (c >= 'A' && c <= 'M')\n      \
    \     c = rot13(c.toString)\n         result(i) = c\n         i += 1\n       }\n\
    \       result.toString"]
stop_tokens:
- "\n    }\n"
