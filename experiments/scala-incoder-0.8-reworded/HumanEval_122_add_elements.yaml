name: HumanEval_122_add_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers arr and an integer k, return\n    //\
  \ the sum of the elements with at most two digits from the first k elements of arr.\n\
  \    // Example:\n    // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong,\
  \ 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))\n\
  \    // (24l)\n    // Constraints:\n    // 1. 1 <= len(arr) <= 100\n    // 2. 1\
  \ <= k <= len(arr)\n    def addElements(arr : List[Long], k : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(addElements((List[Long](1l.toLong,\
  \ -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong,\
  \ 99l.toLong)), (3l)) == (-4l));\n    assert(addElements((List[Long](111l.toLong,\
  \ 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));\n\
  \    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));\n \
  \   assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));\n  \
  \  assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));\n    }\n\n}\n"
completions: ["        var sum = 0L\n        var counter = 1L\n        for(i<-1 to\
    \ k)\n        {\n            if(arr(i).compareTo(BigDecimal(10)*counter)<0)\n\
    \                sum+=arr(i)\n            counter+=1\n        }\n        return\
    \ sum", "        // base case\n        if(arr.isEmpty)\n            return 0\n\
    \n        // first k digits\n        var firstK = arr\n        for(i <- 0 until\
    \ k)\n            firstK = firstK._1 + firstK._2\n\n        // get max two digit\
    \ number from firstK elements\n        var maxTwoDigitSum = firstK.maxBy(_ % 10)._2\
    \ / 10\n        if(maxTwoDigitSum < 0)\n            maxTwoDigitSum = maxTwoDigitSum\
    \ + 9\n        \n        // add rest\n        var rest = arr.drop(k)\n       \
    \ val sum = rest sum maxTwoDigitSum\n        \n        // return max two digit\
    \ sum + sum\n        return maxTwoDigitSum + sum", "        // This solution works\
    \ in O(n^2) time \n        // as we take 2 numbers out in each iteration \n  \
    \      val arr = arr ++ arr filterNot (x => x % 10 == 0) filterNot (x => x % 10\
    \ == 1)\n        val result = arr filter { x => x%10 == 0 }.reduce((x,y) => x+y)\n\
    \        if (arr.length < k) return result \n        else addElements(arr filter\
    \ (x => x % 10 == 1), k)", "        var sum = 0\n        val arr = arr.toList\n\
    \        val tail = arr.drop(k).toList\n        val first = arr.take(k).toList\n\
    \        for (i <- tail) {\n            sum = sum + i\n        }\n        for\
    \ (i <- first) {\n            sum = sum + i\n        }\n        sum", "      \
    \  val result = scala.collection.mutable.ListBuffer.empty[Long]\n        for (elem\
    \ <- arr)\n            result ::= (elem % 10) + elem / 10\n        result.slice(0,\
    \ k).sum", "        if (arr.isEmpty)\n            return 0\n        if (k == 0)\n\
    \            return arr(0)\n        if (k == 1)\n            return arr(0)\n \
    \       var sum = 0L\n        for (i<-k to arr.length-1){\n            sum +=\
    \ arr(i)\n        }\n        sum += arr(arr.length)\n        return sum", "  \
    \      val n = arr.size\n        val result = new Array[Long](n)\n        var\
    \ i : Long = 1\n        var sum : Long = 0l\n        while (i<n) {\n         \
    \   sum = arr(i) + sum\n            if (sum.toString.length < 2) { i += 1; sum\
    \ = 0l }\n        }\n        if (k < n) { sum -= arr(k) }\n        result(0) =\
    \ sum\n        result.foreach(println)\n        result", "        val arr = arr.dropRight(k)\n\
    \        val sum = 0\n        for(i <- 0 until arr.length) {\n            sum\
    \ += arr(i)\n        }\n        sum", "        val counts = arr.map(_ % 10).take(k).toArray\n\
    \        val sum = arr.foldLeft((0L, 0L))((acc, cur) => {\n            val currentSum\
    \ = acc.get._1 + cur % 10\n            val currentCount = acc.get._2 + 1\n   \
    \         val updatedCount = currentCount match {\n                case 0 => currentCount\n\
    \                case 1 => currentCount + 1\n                case _ => currentCount\
    \ - 1\n            }\n            (updatedSum, updatedCount)\n        }).get._1\
    \ + arr.take(k).map(_ % 10).sum\n        val carryOver = sum % 10\n        sum\
    \ + (10 - carryOver)", "        var max = 0\n        for(i <- 0 until arr.length)\
    \ {\n            if(arr.length > (i+k)) {\n                max += arr(i).floor.toLong\n\
    \            }\n        }\n        max", "        val m = arr.head\n        val\
    \ n = arr.last\n        val a = arr.take(k)\n        val b = arr.drop(k).dropRight(1)\n\
    \        val c = a + b\n        val z = k - 1\n        val s = c + z\n       \
    \ val m = m + k\n        val z = z * 10\n        val s = s + z\n        val z\
    \ = k * 10\n        val s = s + z\n        val z = k * 100\n        val s = s\
    \ + z\n        val s = s + m\n        s", "        val len = arr.size\n      \
    \  if (len < 1) return 0\n        if (len == 1) return arr(0)\n        val start\
    \ = arr.take(k)\n        val end   = arr.drop(k - 1)\n        val map   = mutable.HashMap[Long,\
    \ Long]()\n        var sum = 0\n        for ( i <- start.drop(k) ; j <- end )\
    \ {\n            if (!map.contains(i)) {\n                sum += i\n         \
    \       map += i -> i\n            }\n        }\n        sum", "        arr.take(k).foldLeft(0l)\
    \ {\n            (acc, val) => acc + (val % (10 * 10) + 1)\n        }", "    \
    \    if (arr.isEmpty || arr.size <= k) {\n            return 0\n        }\n\n\
    \        var s = 0.0\n        var i = k\n        while (i >= 0) {\n          \
    \  s += arr(i)\n            i -= 1\n        }\n        val tmp = s - math.min(arr(k),\
    \ arr(k-1))\n        var t = 0\n        for (i = k; i < arr.length; ++i) {\n \
    \           t += arr(i) - tmp\n        }\n        return t", "        var sum\
    \ = 0\n        val arr = arr.sorted\n        for (i <- 0 until arr.length && arr.length\
    \ - i >= k) sum += arr(i)\n        sum", "        var max = 0L\n        var num\
    \ = 0\n        var i = 0\n        while (i < k) {\n            num = max % 10\
    \ + arr(i).toInt % 10\n            max = Math.max(1, max / 10)\n            i\
    \ = i + 1\n        }\n        return max", "        val l1 = arr.take(k.toInt)\n\
    \        val l2 = arr.drop(k.toInt)\n        l1.foldLeft(0l) { (s, e) =>\n   \
    \         val l = if (s % 10 < e) s + 1 else s\n            l * 10 + e\n     \
    \   }", "        var result : Long = 0\n        var lastElements : List[Long]\
    \ = Nil\n        for( x <- arr ) {\n            if( lastElements.size <= k ) {\n\
    \                lastElements = lastElements :+ x\n            } else {\n    \
    \            if( math.pow(x, 2).sum % 10 == 0 ) {\n                    result\
    \ += x\n                }\n            }\n        }\n        return result", " \
    \       if (arr.isEmpty)\n            return 0\n\n        val arr = arr.take(k).toArray\n\
    \        val maxLength = Math.max(arr.take(k).length, k)\n\n        val sums =\
    \ arr.map {x => x + x.toString.substring(0,maxLength)}\n            .foldLeft(ListBuffer.empty[Long])\
    \ { (acc: mutable.ListBuffer[Long], elem: Long) =>\n                acc += elem\n\
    \                acc += elem.substring(0,maxLength)\n                acc += elem.substring(0,maxLength-1)\n\
    \                acc += elem.substring(0,maxLength-2)\n            }\n       \
    \     .map(x => x.toString.toLong).toList\n\n        val sumsLong = sums.map(x\
    \ => x.toLong).toList\n        var total = 0L\n        for ( l <- sumsLong) {\n\
    \            total += l\n        }\n        return total", "        val l1 = arr.take(k).toList\n\
    \        val l2 = arr.drop(k).toList\n        val l3 = l2.zip(l1).map{ case (x,y)\
    \ => x.toLong + y.toLong }.toList\n        l3.sum", "        val map1 = arr.take(k).toMap\n\
    \        var sum = 0\n        for(i <- 0 until k){\n            sum += map1(i)\n\
    \            val tmp = sum%10\n            sum += tmp\n        }\n        return\
    \ sum", "        if(k > arr.size)\n            throw new IllegalArgumentException(\"\
    k must be <= length of arr\")\n        var count = 0\n        var sum = 0L\n \
    \       for(elem <- arr[0..k]) {\n            var temp = 0L\n            for(i\
    \ <- 0 until elem) {\n                temp += arr(i).toLong\n            }\n \
    \           sum += temp\n            count += 1\n        }\n        sum += arr(k).toLong\n\
    \        if(count > 1)\n            sum += arr(k+1).toLong\n        sum.toLong",
  "        val ls = arr.take(k).toList\n        val result = 0\n        ls.foreach{x\
    \ => result += x}\n        return result", "        val sumM: mutable.Long = mutable.Long(0)\n\
    \        var total = 0\n        for(i <- 0 to arr.size - k + 1){\n           \
    \ total += arr(i)\n        }\n        total", "        val firstK = arr.take(k).toList\n\
    \        val firstKSet = firstK.toSet\n        val arr = arr.drop(k).toList\n\
    \        val finalSum = arr.reduceLeft((x, y) => (firstKSet.contains(x) || firstKSet.contains(y))\n\
    \            ? (x + y) :\n            (x + y) * (firstKSet.contains(x) ? 2 : 1))\n\
    \        arr.head + finalSum", "        if(arr.length < 2)\n            return\
    \ 0l\n\n        val newArr: List[Long] = arr.take(k).reverse.drop(k).reverse\n\
    \n        if(arr.length > k)\n            newArr += arr.drop(k).reverse\n\n  \
    \      val sum : Long = arr.sum\n\n        val result = newArr.foldLeft(sum)((sum,\
    \ element) => sum + element)\n\n        result", "        var sum = 0\n      \
    \  var index = 0\n        while(index < k) {\n            if(index < (k-1)) {\n\
    \                sum += arr(index)\n                index += 1\n            }\
    \ else {\n                sum = sum + arr(index) + arr(index+1)\n            \
    \    index += 1\n                index += 2\n            }\n        }\n      \
    \  return sum", "        val arr = arr.reverse.take(k)\n        val arr = arr.sortBy(_.toString.toInt)\n\
    \        val sum = (arr.head + arr.last) % (10 - arr.last)\n        sum * 10 +\
    \ arr.last", "        var ans = 0\n        var i = 0\n        while (i < arr.size)\
    \ {\n            ans += arr(i)\n            val remainder = math.abs(arr(i) -\
    \ arr(i + 1))\n            i += 2\n            if ((remainder < 10) || (k == 0))\
    \ return ans\n        }\n        return ans", "        val l = arr.length\n  \
    \      val sums = mutable.ListBuffer.empty[Long]\n        var sum : Long = 0\n\
    \        for (i<- 0 until k) {\n            val n = arr.drop(i).last\n       \
    \     sum += n\n            sums += n\n        }\n        if (sums.size == k)\n\
    \            sums.sum\n        else\n            sums.sum - sums.last", "    \
    \    if (k == 0) 0\n        else {\n            var sum : Long = 0\n         \
    \   for (i <- 0 until k) {\n                sum += arr(i)\n            }\n   \
    \         return sum\n        }", "        require(k <= arr.length, \"k exceeds\
    \ length of arr\")\n        var sum = 0\n        arr.sortWith(_ < _)\n       \
    \ for(i <- arr.indices) {\n            sum = sum + arr(arr.length-(i+1))\n   \
    \     }\n        return sum + arr(k)", "        val nums = arr.toIndexedSeq.sortBy(_.toInt).takeRight(k).toList\n\
    \        val sum = arr(k).toInt + arr(k - 1).toInt\n        nums zip nums.tail.filter(_\
    \ > sum) map { case (a,b) => a + b }.reduceLeft(_ + _)", "        // Write your\
    \ code here\n        var i : Long = 0\n        var sum : Long = 0\n        for(x\
    \ <- arr){\n            if(i == k){\n                sum += x\n            }else\
    \ if(i == k-1){\n                sum += x\n                sum -= (x/10l)*10\n\
    \            }else{\n                sum += x\n            }\n            i+=1\n\
    \        }\n        sum", "        // Use scala.collection.mutable.ListBuffer\
    \ to calculate the sum.\n        // Use mutable list to calculate the index and\
    \ keep track of the last k elements.\n        var lastElement = arr.head\n   \
    \     var index = 0\n        var sum = 0\n        val buffer = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        for(i <- 0 until k) {\n            buffer.append(lastElement.drop(index).sum.toLong)\n\
    \            sum += lastElement.drop(index).sum\n            lastElement = lastElement.drop(index).last\n\
    \            index += 1\n        }\n        return sum", "        val first =\
    \ arr.take(k).toList\n        val rest = arr.drop(k).toList\n        val first\
    \ = first.sum\n        val rest = rest.reduce(_ addElem(_))\n        val first2\
    \ = first.toString.take(2).sum\n        val rest2 = rest.toString.drop(2).reduce(_\
    \ addElem(_))\n        val rest3 = rest2.toString.take(2).reduce(_ addElem(_))\n\
    \        val sum = first2 + rest3\n        return sum", "        val len = arr.size\n\
    \        var sum = 0\n        var sum2 = 0\n        var i = 0\n        while(i\
    \ < k){\n            if(arr(i).toString().length < 2){\n                i += 1\n\
    \                continue\n            }\n            sum += arr(i)\n        \
    \    sum2 += arr(i).toLong * arr(i).toLong\n            i += 1\n        }\n  \
    \      val twoSum = sum2 - sum * sum\n        return sum + twoSum", "        val\
    \ arr = arr.toList // not very performant\n        val result = {\n          \
    \  val res = arr.head\n            val newRes = res.take(k).toList\n         \
    \   val oldRes = res.drop(k).toList\n            newRes +: oldRes.sum\n      \
    \  }\n        require(k <= arr.length)\n        result", "        if (arr.isEmpty)\
    \ {\n            return 0\n        }\n        var ans = 0.0\n        var i = k\n\
    \        for (elem <- arr until arr.last){\n            while (i >= 2 && (elem.toString.substring(0,i).reverse.charAt(0)-'0')%10\
    \ != 0){\n                ans += elem.toDouble\n                i -= 1\n     \
    \       }\n            i -= 1\n        }\n        return ans.toLong", "      \
    \  require(arr.nonEmpty, \"List can not be empty\")\n        require(k <= arr.length,\
    \ \"K cannot be more than the length of the array\")\n        val arr = arr.tail\n\
    \        var sum = 0l\n        val m = arr.head\n        var i = 0\n        var\
    \ j = 1\n        while (i < arr.length) {\n            if (j < arr.length && arr(i)\
    \ == arr(j)) {\n                j+=1\n            }\n            else {\n    \
    \            sum+=m\n                if (j==k)\n                    break\n  \
    \              j+=1\n            }\n            i+=1\n        }\n        sum",
  "      val s = scala.collection.mutable.Map[Int, Int]()\n      for (i <- 0 to arr.size\
    \ - k) {\n        val num = arr(i).toString.toLong\n        val l = s.find(num).map(a\
    \ => a + 1)\n        if (l.isEmpty) {\n          s(num) = 1\n        } else {\n\
    \          val value = l(s).get\n          s(num) = (1 + value).toLong\n     \
    \   }\n      }\n      s.values.sum", "        var sum = 0\n        var last =\
    \ 0\n        for (i<-0 until arr.length) {\n            if (last + 1 >= arr.length)\
    \ last = i\n            else {\n                val first = last + 1\n       \
    \         if (first <= i) sum = sum + arr(first) - arr(last)\n               \
    \ else sum = sum + arr(last) - arr(first)\n                last = i\n        \
    \    }\n        }\n        return sum", "        def twoDigit(index : Long) :\
    \ Boolean = index % 10 == index % 100\n        def addTwoDigit(num : Long, index\
    \ : Long) : Long = {\n            val temp = index.toInt\n            if (twoDigit(index))\n\
    \                num.toLong + temp.toLong\n            else\n                num.toLong\
    \ * 10 + temp.toLong\n        }\n        val res = arr.filter(_ <= k).toList.sorted\n\
    \        val res = res.takeWhile(_ < k).toList\n        val res = res.map(addTwoDigit(_,\
    \ 0))\n        val res = res.reduceLeft((a, b) => a + b)\n        res", "    \
    \    val n = arr.length\n        val arr = arr.sortWith(_ > _)\n        val res\
    \ = 0\n        for (i<- 0 until k) {\n            res = res + arr(i)\n       \
    \ }\n        return res", "        var sum = 0L\n        for ( x <- arr.slice(1,\
    \ k) ) sum += x\n        return sum", "        if (arr.isEmpty) return 0\n   \
    \     val m = math.min(k, arr.length)\n        val sum = arr diff arr.drop(m)\n\
    \        val sum1 = arr.take(m)\n        val sum2 = arr.drop(m)\n        val result\
    \ = sum.zip(sum1).map(_ + _).zip(sum2).map(_ + _)\n        return result.foldLeft(0L)(_\
    \ + _)", "        val m = arr.length\n        val max = arr.drop(k).foldRight(0)((a,\
    \ b) => if (b > a) b else a)\n        (max.toLong + arr.take(k).filter(_ % 10\
    \ == 0).sum).toLong", "        val sum = 0\n        val twoToK = math.max(0, k\
    \ - arr.length)\n        arr.sliding(twoToK).\n                map { i => sum\
    \ + i }.\n                sum", "        val m = arr.map(_.toString.length).max\n\
    \        val m = arr.take(k).map(_.toString.length).max\n        return arr.map(_.toString.substring(0,\
    \ m)).sum", "        val result = 0\n        val counter = new mutable.HashSet[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            val value = arr(i)\n   \
    \         val remainder = value % 10\n            if (counter.size() > 0 && counter.contains(remainder))\
    \ {\n                result += value\n            } else {\n                if\
    \ (remainder >= k) {\n                    result += value\n                  \
    \  counter.add(remainder)\n                }\n            }\n        }\n     \
    \   result", "        // Your code here\n        val m = arr.length\n        val\
    \ n = k\n        val arr = arr.toList\n        val max = arr.take(n)\n       \
    \ var sum = 0L\n        var i = 0\n        var j = 1\n        while (i < n &&\
    \ j < m) {\n            if (arr(i) >= arr(j)) {\n                sum = sum + arr(i)\n\
    \                i += 1\n            }\n            else {\n                sum\
    \ = sum + arr(j)\n                j += 1\n            }\n        }\n        sum",
  "        val newArr  = arr.drop(k)\n        val oneDArr : List[Long] = newArr.filter(_\
    \ % 10L == 0)\n        val twoDArr : List[Long] = newArr.filter(_ % 10L != 0)\n\
    \        val oneD : List[Long] = oneDArr.reverse.sliding(2).map(_.sum)\n     \
    \   val twoD : List[Long] = twoDArr.reverse.sliding(2).map(_.sum)\n        oneD.getOrElse(0)\
    \ + twoD.getOrElse(0)", "        val mins = arr.take(k).foldLeft((0l, 0l)) {\n\
    \            case ((min, sum), (element, index)) =>\n                if (index\
    \ >= k) (min._1 + element, min._2 + 1)\n                else if (element < min._1)\
    \ (min._1, element)\n                else (min._2, min._1 + element)\n       \
    \ }\n\n        val maxs = arr.takeRight(k).foldLeft((0l, 0l)) {\n            case\
    \ ((max, sum), (element, index)) =>\n                if (index >= k) ((max._1\
    \ - element, max._2), max._1 + element)\n                else if (element > max._1)\
    \ ((max._1, element), max)\n                else ((max._2, max._1 - element),\
    \ max._2)\n        }\n\n        val totalSum = mins._2 + maxs._2 + arr(k).toLong\n\
    \        mins._1 + maxs._1 + totalSum", "        // Fill this in.\n        arr.sortWith(_\
    \ < (arr(1) %  1000000) == -1) \n        var sum : Long = 0\n        for (i <-\
    \ 0 until k) {\n            sum = sum + arr(arr.length - i - 1)\n        }\n \
    \       return sum", "        var sum = 0L\n        for (element <- arr.getRange(0,\
    \ k)) {\n            sum += element.toLong\n        }\n        sum += arr(k)\n\
    \        sum", "        val hashSet = mutable.Set[Long]()\n        var sum = 0L\n\
    \        for(i<- k to arr.size){\n            val element = arr(i)\n         \
    \   val first = element.toString.substring(0, 1)\n            val second = element.toString.substring(1,\
    \ 2)\n            if(hashSet.contains(first + second)) sum+=element\n        \
    \    hashSet += (first + second)\n        }\n        sum", "        val arr1 =\
    \ arr.take(k.toInt).toArray\n        val arr2 = arr.drop(k.toInt).toArray\n  \
    \      var sum = 0\n        for(i <- 0 until arr1.length){\n            val digit1\
    \ = arr1(i).toInt\n            val digit2 = arr2(i).toInt\n            sum +=\
    \ digit1 * digit2\n        }\n        return sum", "        val len = arr.size\n\
    \        val arr = arr.sortWith(_ < _)\n        val sum = 0\n        var i = 0\n\
    \        for(j <- k to len - k){\n            sum += arr(i).toLong\n         \
    \   i += 1\n        }\n        sum", "        val minPairs = arr.zip(arr.drop(k)).filter(_._2\
    \ < _._2).length\n        val sum = (arr min k).sum\n        minPairs * sum",
  "        val r = new mutable.ArrayBuffer(0)\n        var i = 0\n        for (x <-\
    \ arr) {\n            if (i + 1 < k) {\n                r.append(x + arr(i + 1))\n\
    \                i += 1\n            } else {\n                if (r.nonEmpty)\
    \ {\n                    r += x\n                }\n            }\n        }\n\
    \        if (r.nonEmpty) {\n            r += arr(i)\n        }\n        r.toList.sum",
  "        var sum = 0\n        var maxIndex = 0\n        for (i<- arr.indices) {\n\
    \            if(i < k) sum += arr(i)\n            if(arr(i) > arr(maxIndex)) maxIndex\
    \ = i\n        }\n        return sum + arr(maxIndex)", "        val arr = arr.sortWith(_\
    \ < _) // sort descending\n        val res = new mutable.LinkedList[Long]()\n\
    \        var sum = 0\n        for(i <- 0 to arr.length - k){\n            val\
    \ cur = arr(i)\n            if(i % 2 == 0){\n                sum += cur\n    \
    \            val cur2 = arr(i - 1)\n                val cur3 = arr(i - 2)\n  \
    \              val cur4 = arr(i - 3)\n                if(cur2 == 0 || cur3 ==\
    \ 0 || cur4 == 0){\n                    val l = if (i == 0){ res(0) } else { res(res.size\
    \ - 1) }\n                    l += cur\n                    res.add(cur)\n   \
    \             }\n                else{\n                    val l = if (i == 0){\
    \ res(0) } else { res(res.size - 1) }\n                    l += cur\n        \
    \            l += cur2\n                    res.add(cur)\n                   \
    \ l += cur3\n                    l += cur4\n                }\n            }\n\
    \            else{\n                sum += cur\n                res.add(cur)\n\
    \            }\n        }\n        val sum = res.mkString(\"\").trim().toLong\n\
    \        return sum", "        val digits = arr diff arr.take(k).toList\n    \
    \    val result = (digits\n            .groupBy(x => x.toString.toInt)\n     \
    \       .mapValues(x => x.size)\n            .foldLeft(0l) { (acc, element) =>\
    \ acc + (element._2 * Math.pow(10, element._1))})\n        result + arr.take(k).sum",
  "        var sum = 0\n        var i = 0\n        for(i = k; i <= arr.length && i\
    \ < arr.length; i += k) {\n            sum += arr(i)\n        }\n        return\
    \ sum", "        val n = arr.size\n        val sum = 0\n        val lastDigits\
    \ = 0 // last two digits of the sum\n        val twoDigitSums = mutable.MutableListBuffer[Long]()\n\
    \        for (i <- 0 until n) {\n            if (i < (k-1)) {\n              \
    \  sum += arr(i)\n                val cur = math.pow(10, math.ceil(math.log10(arr.head.toDouble/arr(i)).toDouble))\n\
    \                val digits = math.floor(cur.toDouble / 10)\n                lastDigits\
    \ += digits\n                twoDigitSums += digits\n            }\n         \
    \   else if (i == k) {\n                sum += arr.last\n                lastDigits\
    \ += math.ceil(math.log10(arr.last.toDouble).toDouble)\n            }\n      \
    \  }\n        val sumTwoDigits = twoDigitSums.sum\n        val twoDigitSum = lastDigits\
    \ + sumTwoDigits\n        val res = (sum + twoDigitSum).toLong\n        res",
  "        if (arr.length < 1 || arr.length < k) return 0L\n        var sum = 0L\n\
    \        var i = 0L\n        for (elem <- arr) {\n            sum += elem\n  \
    \          i += 1\n            if (i < k && elem.toString.length < 3) sum -= 10L\n\
    \        }\n        sum", "        def kthMax(n : Long) : Long = {\n         \
    \   val max = arr.take(k)\n            val maxIndex = arr.indexOf(max)\n     \
    \       if (maxIndex < k) kthMax(maxIndex + 1)\n            else max(0)\n    \
    \    }\n        return arr.map(n => kthMax(n)).sum", "        val sum = arr.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        if (arr.length > k) {\n            arr.take(k).foldLeft(sum)\
    \ { (sum, e) => sum + e.toString.substring(1, 2) }\n        } else {\n       \
    \     sum\n        }", "        val result = arr.sum\n        if (result.length\
    \ > k) {\n            val numOfDigits = result.take(k).length\n            val\
    \ remainder = result.drop(numOfDigits)\n            val sum = remainder.sum\n\
    \            val remainderWithTwoDigits = remainder.map(_.map(x => if (x < 10)\
    \ 0l\n            else if (x >= 10) 10l\n            else x).toLong)\n       \
    \     val sumWithTwoDigits = remainderWithTwoDigits.sum\n            val sumWithTwoDigitsString\
    \ = sumWithTwoDigits.toString\n            val twoDigits = numOfDigits * \"0\"\
    \ + sumWithTwoDigitsString\n            result + twoDigits\n        }\n      \
    \  else result", "        if(arr.isEmpty)\n            return 0\n        var sum\
    \ = 0\n        var left = 0\n        val arr = arr.toList\n        for(i <- arr.drop(k))\n\
    \        {\n            if(i.toString.length < 2)\n                continue\n\
    \            left += 1\n            sum += i.toLong\n        }\n        return\
    \ sum + addElements(arr.take(k), left - 1)", "        val maxNum = arr.filter(_\
    \ < 100).last\n        if (k > arr.length)\n            0\n        else {\n  \
    \          var res = maxNum\n            var idx = k\n            while (idx <\
    \ arr.length) {\n                var next = arr(idx+1) - 100\n               \
    \ if (next > res)\n                    res = next\n                idx += 1\n\
    \            }\n            res\n        }", "        def getSum (arr : List[Long],\
    \ sum : Long, index : Long, arrSize : Int) : Long = {\n            if (index ==\
    \ arrSize) {\n                sum\n            } else {\n                getSum\
    \ (arr, (sum + arr(index)), index + 1, arrSize)\n            }\n        }\n  \
    \      val arrSize = arr.length\n        val sum = 0L\n        getSum (arr, sum,\
    \ 0, k)", "        val arr = arr filter (_ > 0) sortWith ((_,b) => b) toList\n\
    \        var sum = 0L\n        var currentSum = 0L\n        var previousSum =\
    \ 0L\n        for( _ <- arr.drop(k) )\n        {\n            if (arr.length >\
    \ (k + 1))\n            {\n                currentSum += arr(arr.length - 1)\n\
    \                sum += 1\n                currentSum -= arr(k)\n            \
    \    sum += 1\n            }\n            else\n            {\n              \
    \  currentSum += arr(0)\n                sum += 1\n            }\n           \
    \ previousSum = currentSum\n        }\n        return sum * (previousSum / 10)",
  "        // Initialize sum \n        var sum = 0\n        // Count number of digits\
    \ in first k elements of arr\n        var cnt = 0\n        for (i<- 0 until k\
    \ ) {\n            cnt = (arr(i).asDigit().toString.length) \n        }\n    \
    \    // Add elements with 2 digits from the first k elements of arr\n        for\
    \ (i<- 0 until k ) {\n            sum = sum + arr(i).asDigit().toString.substring(0,cnt)\n\
    \        }\n        // Return sum\n        sum.toString", "        val sum = 0l\n\
    \        val digits = arr.take(k).toList\n        for(i <- 0 until digits.size)\
    \ {\n            sum += digits(i)\n        }\n        sum", "        require(k\
    \ <= arr.length, \"k should be in range [1, len(arr)] but k = \" + k);\n     \
    \   val l = new mutable.ListBuffer[Long]();\n        for (i <- 1 to arr.length){\n\
    \            val num = arr(i);\n            if (num < 10){\n                l.append(num);\n\
    \            } else {\n                l.append(num % 10);\n                l.append(num\
    \ / 10);\n            }\n        }\n        val max = l.max\n        if (l.length\
    \ < k){\n            return max;\n        }\n        val i = l.length - k\n  \
    \      for (j <- k to i by -1){\n            val sum = l.sum\n            val\
    \ remainder = sum % (10 * j);\n            val leftSum = l.sum\n            val\
    \ rightSum = l.sum\n            if (remainder < 10 - leftSum / 10 * j || remainder\
    \ < 10 - rightSum / 10 * j){\n                return (left + right);\n       \
    \     }\n            val a = leftSum / 10 * j\n            val b = rightSum /\
    \ 10 * j\n            if (remainder < b - a){\n                return (left +\
    \ right);\n            }\n        }\n        return max;", "      val n = arr.size\n\
    \      var total = 0\n      for (i <- 1 to k by 2)\n          if (arr.length >=\
    \ i && arr(i).toString.length > 1)\n              total += arr(i)\n      total",
  "        val counts = mutable.ListBuffer.empty[Int]\n        for (elem <- arr.take(k))\
    \ counts += elem.digits\n        counts sum", "        val n = arr.length\n  \
    \      val arr2 = arr.take(k).toList\n        if (k == n) {\n            (arr(0)\
    \ + arr2(0)) + (arr(1) +arr2(1)) + (arr(2) + arr2(2)) + (arr(3) +arr2(3)) + (arr(4)\
    \ +arr2(4)) + (arr(5) +arr2(5)) + (arr(6) +arr2(6)) + (arr(7) +arr2(7)) + (arr(8)\
    \ +arr2(8)) + (arr(9) +arr2(9))\n        } else {\n            var result : Long\
    \ = 0\n            var j = 0\n            for (i <- 0 until k) {\n           \
    \     if (j == n-1) {\n                    result += arr(j)\n                }\n\
    \                else {\n                    result += arr2(j) + arr2(i+1)\n \
    \               }\n                j += 1\n            }\n            result\n\
    \        }", "        val arr = arr.take(k)\n        val res = arr.map(x => math.pow(10,\
    \ math.max(0, math.abs(x - 1)))).sum\n        arr ++ Array(res)", "        val\
    \ res = arr.map(x => if (x % 10 == 0) x else x + 10).takeRight(k).sum\n      \
    \  arr(k)", "        // Write your code here\n        val size = arr.size\n  \
    \      val resList = mutable.ArrayBuffer(k)\n        var sum = 0\n        while(resList.size\
    \ != size) {\n            sum += arr(resList(0))\n            resList -= 1\n \
    \       }\n        return sum", "        val ans = 0.toLong\n        val result\
    \ = new mutable.PriorityQueue[Int]()\n        result.addAll(arr.getOrElse(Array.empty[Long],\
    \ Array.empty[Long]).reverse.take(k))\n        while(result.nonEmpty) {\n    \
    \        val value = result.poll()\n            ans += value\n            result.filter\
    \ { x => x <= value }.foldLeft(0l) { (sum, v) => sum + v }\n        }\n      \
    \  ans", "        val ans = arr(k-1).toLong + arr(k).toLong\n        for (i <-\
    \ k+1 until arr.size) {\n            val summ = arr(i-1).toLong + arr(i).toLong\n\
    \            if (summ > ans) ans = summ\n        }\n        ans", "        def\
    \ partition(arr : List[Long], k : Long) : List[List[Long]] = {\n            val\
    \ leftArray = arr.filter(_ < k)\n            val rightArray = arr.filter(_ >=\
    \ k)\n            leftArray.partition(l => rightArray.contains(l))\n        }\n\
    \n        val leftArray = arr.filter(_ < k)\n        val rightArray = arr.filter(_\
    \ >= k)\n        leftArray.foldLeft(0l) { (sum, element) => sum + (element % 10\
    \ + element / 10 * (10 - element % 10)) }", "        val arrCopy = arr.slice(0,k)\n\
    \        val n = arrCopy.last\n        val max = arrCopy.max\n\n        val arr1\
    \ = arrCopy.slice(1, k - 1).map(_ * 10 + _)\n        val arr2 = arrCopy.slice(k\
    \ - 1, 1)\n\n        if (n > max)\n            addElements(arr1, k - 1) + addElements(arr2,\
    \ k - 1) + max - 1\n        else max", "        val arr = arr.sortWith(_ < (_\
    \ + 1l) == (_ + 1l))\n        val first = arr.take(k)\n        val rest = arr.drop(k)\n\
    \        rest.sum", "        var sum : Long = arr(0).toLong\n        var digits\
    \ : mutable.HashSet[Long] = mutable.HashSet[Long](1l)\n        for (i <- 1 to\
    \ k) {\n            val nextNum = arr(i)\n            var currentDigit : Option[Long]\
    \ = digits.get(nextNum.toLong)\n            currentDigit = currentDigit.flatMap(x\
    \ => x % 10)\n            sum = sum + nextNum * currentDigit.get\n           \
    \ digits = digits + (nextNum * currentDigit.flatMap(x => x % 10))\n        }\n\
    \        sum", "        var result : Long = 0\n        var sum : Long = 0\n  \
    \      var maxSum : Long = 0\n        var currentIndex : Long = 0\n        var\
    \ currentSum : Long = 0\n        var currentMaxSum : Long = 0\n        var minSum\
    \ : Long = 0\n        var maxIndex : Long = 0\n\n        while (currentIndex <\
    \ arr.length) {\n            val element = arr(currentIndex)\n            currentSum\
    \ += element\n            if (currentIndex >= k) {\n                currentMaxSum\
    \ = currentSum\n                currentIndex = k\n                currentMaxSum\
    \ = element\n                currentSum = 0\n                currentMaxSum = element\n\
    \            } else {\n                if (currentMaxSum < element) {\n      \
    \              currentMaxSum = element\n                    currentSum = element\n\
    \                }\n                currentIndex += 1\n            }\n       \
    \ }\n        sum = 0\n        arr.forall {\n            sum += it\n        }\n\
    \        minSum = math.min(sum, k.toLong)\n        maxSum = math.max(sum, k.toLong)\n\
    \        result = currentMaxSum + maxSum + minSum\n        return result", " \
    \       val n = arr.length\n        val sorted = arr.sortWith( (x,y) => x < y)\n\
    \        val twodigitsum = sorted.reduceLeft( (x,y) => x + y)\n        val ktwodigitsum\
    \ = k - twodigitsum\n        val result = ktwodigitsum * ktwodigitsum / n\n  \
    \      result", "        var sum = 0\n        var currentElement: Long = 0\n \
    \       for(element <- arr.take(k)) {\n            if(currentElement > 2999999999L)\
    \ {\n                sum += 1\n                currentElement = 0\n          \
    \  }\n            sum += element\n            currentElement += 1\n        }\n\
    \        sum", "        val m = arr.take(k).length\n        val n = (arr.length\
    \ - k).abs.toInt\n        val result = arr.sliding(n + 1).flatten.map(_ * m).sum.toLong\n\
    \        result", "      var maxTwos = 0\n      var sum = 0\n      for (i <- 0\
    \ until k) {\n        if (maxTwos == 0 && arr(i) <= 9l.toLong) {\n          sum\
    \ += arr(i)\n        }\n        if (maxTwos != 0 && arr(i) <= 9l.toLong) {\n \
    \         sum += arr(i) - 9l.toLong\n        }\n        if (maxTwos == 1 && arr(i)\
    \ > 9l.toLong) {\n          maxTwos = 0\n          sum += arr(i)\n        }\n\
    \        if (arr(i) > 9l.toLong) {\n          maxTwos = 1\n          sum += arr(i)\
    \ - 9l.toLong\n        }\n      }\n      return sum", "        val arr = arr.toArray\n\
    \        var sum = 0\n        var max = 0\n        for(i <- 0 until k) {\n   \
    \         if(arr(i) > max) max = arr(i)\n        }\n        for(i <- 0 until k)\
    \ {\n            sum = (sum + arr(i)) % 10\n        }\n        return sum + max",
  "        var sum = 0L\n        var index = 0\n        while(index<k){\n        \
    \    sum += arr(index)\n            index += 1\n        }\n        return sum",
  "        val max = arr.take(k).last\n        val min = arr.drop(k).head\n      \
    \  (max - min).max / 10", "        val digits = scala.math.ceil(math.log10(arr.last)).toInt\n\
    \        val results = (0 until k).map{i => addElements(arr.takeRight(i+1), k)}\n\
    \        return results.flatten.toLong + addElements(arr.takeRight(k), k-digits)",
  "        val result = new mutable.ListBuffer[Long]\n        var curSum = 0\n   \
    \     var curr = 0\n        var j = 0\n        var index = 0\n        for(i <-\
    \ 0 until k){\n            curr = 0\n            for(j => i < arr.length; j++){\n\
    \                curr += arr(index)\n                index++\n               \
    \ i += 1\n            }\n            currSum += curr\n            i += 1\n   \
    \     }\n        result.append(currSum)\n        result.toList.get(0)", "    \
    \    val len = arr.size\n        if (k >= len) 0\n        else {\n           \
    \ val arr = arr.toList\n            var sum = 0\n            var j = 0\n     \
    \       while (j < k) {\n                val curr = arr(j)\n                val\
    \ next = (j + 1 < arr.size) ? arr(j + 1).toLong : 0\n                val curChar\
    \ = curr.toString.charAt(0)\n                val nextChar = next.toString.charAt(0)\n\
    \                val tmp = (curChar - nextChar)\n                if (tmp < 0)\
    \ tmp else if (tmp == 0) sum += next\n                j += 1\n            }\n\
    \            sum\n        }", "        val arr = arr.toStream\n        var sum\
    \ = 0L\n        var lastDigit = 0L\n        var lastDigitsSinceLast = 0L\n   \
    \     var isOdd = 0L\n        arr.take(k).foreach(x => {\n            if (x %\
    \ 2L != 0L) {\n                sum += x\n                lastDigit = 0L\n    \
    \            lastDigitsSinceLast = 0L\n                isOdd = 1L\n          \
    \  } else {\n                if ((lastDigit + 1L) % 2L == 0L && !isOdd) {\n  \
    \                  lastDigitsSinceLast += 1L\n                }\n            \
    \    if ((lastDigit + 1L) % 2L != 0L && !isOdd) {\n                    sum +=\
    \ x\n                    lastDigit = 0L\n                    lastDigitsSinceLast\
    \ = 0L\n                    isOdd = 1L\n                } else if ((lastDigit\
    \ + 1L) % 2L == 0L && isOdd) {\n                    lastDigitsSinceLast += 1L\n\
    \                }\n            }\n        })\n        return sum", "        val\
    \ arr = arr.toList\n        val result = mutable.Buffer.empty[Long]\n        var\
    \ sum = 0\n        var i = 0\n        while (i < arr.length && sum + arr(i) <\
    \ k) {\n            sum = sum + arr(i)\n            i += 1\n        }\n      \
    \  i = arr.size - 1\n        while i >= 0 && sum + arr(i) > k) {\n           \
    \ sum = sum - arr(i)\n            i -= 1\n        }\n        if (i < 0) {\n  \
    \          i = 0\n        }\n        while (i < arr.length && sum + arr(i) > k)\
    \ {\n            sum = sum - arr(i)\n            i += 1\n        }\n        result\
    \ = sum", "        if (arr.isEmpty) return 0\n        if (arr.size == k) {\n \
    \           var sum = 0l\n            for (i<- 0 until (arr(k) div 100)) {\n \
    \               sum = sum + arr(i).asInstanceOf[Long]\n            }\n       \
    \     return sum\n        }\n\n        var maxSum = 0L\n        val maxSumIdx\
    \ = 0\n        for (i <- 0 until (arr(k) div 100)) {\n            val tempSum\
    \ = arr(i).asInstanceOf[Long]\n            if (tempSum > maxSum) {\n         \
    \       maxSum = tempSum\n                maxSumIdx = i\n            }\n     \
    \   }\n        val tempSum = arr(maxSumIdx).asInstanceOf[Long]\n        val maxSumIdx\
    \ = k\n        tempSum + maxSum", "        val indexMap = mutable.Map[Long, Int]()\n\
    \        val res = mutable.ArrayBuffer(0)\n        for (i <- arr){\n         \
    \   if(indexMap.contains(i)){\n                indexMap(i) += 1\n            }\
    \ else {\n                indexMap(i) = arr.indexOf(i) + 1\n            }\n  \
    \      }\n        val lastMax = arr.size - k\n        for (i <- 0 until lastMax)\
    \ {\n            var max = 0\n            var j = k\n            while (j < arr.size)\
    \ {\n                if (j + indexMap(i) < arr.size) {\n                    max\
    \ += arr(j)\n                    j += 1\n                } else {\n          \
    \          break\n                }\n            }\n            val tmpRes = (res.last\
    \ + max).toLong\n            res += tmpRes\n        }\n        res.last", "  \
    \      val maxLength = arr.take(k).foldRight(0l)(_ + _.length).toLong\n      \
    \  val maxLength2 = maxLength * maxLength\n        val sum = 0l\n        var index\
    \ = 0\n        val size = arr.length\n        for (i <- 0 until size) {\n    \
    \        val elem = arr(i)\n            if (elem.toString.length < maxLength)\n\
    \                sum = sum + elem\n            else if (elem.toString.length <\
    \ maxLength2) {\n                sum = sum + elem\n                index = i\n\
    \            }\n        }\n        return sum", "        val res = arr.foldRight(0l)\
    \ { (acc, val) => acc + val.toString.substring(k).length }\n        val sum =\
    \ arr.foldRight(0l) { (acc, val) => acc + val.toString.substring(k).length }\n\
    \        return sum", "        var sum = 0L\n        var result = 0L\n\n     \
    \   for(i <- arr.take(k)) {\n            val str = i.toString\n            var\
    \ j = 0\n            for(x <- 0 until str.length) {\n                if(j > k)\
    \ {\n                    break\n                }\n                if(str.charAt(x)\
    \ == '0') {\n                    j++\n                } else {\n             \
    \       sum += str.length + x\n                    j = 0\n                }\n\
    \            }\n            result += i\n        }\n        result", "       \
    \ val counts = arr.grouped(k).map(_.length)\n        val maxCount = counts.max()\n\
    \        counts(0) + (counts(maxCount) - 1)", "        // write your code in Scala\
    \ without using Scala collections\n        var sum = 0\n        var num = 0\n\
    \        \n        for (i<- arr.reversed) {\n            if (i % 100 == 0)\n \
    \               sum = sum + i\n            \n            if (num == k)\n     \
    \           break\n            \n            num = num + 1\n        }\n      \
    \  \n        return sum", "        val arr = arr.toList\n        var sum = 0L\n\
    \        var count = 0\n        var sumWithTwoDigits = 0\n        for (x <- arr)\
    \ {\n            sum += x\n            count += 1\n        }\n        while (count\
    \ > 0) {\n            sumWithTwoDigits += sum % 10\n            sum = (sum / 10).toLong\n\
    \            sum -= sumWithTwoDigits % 10\n            sumWithTwoDigits = (sumWithTwoDigits\
    \ / 10).toLong\n            count -= 1\n        }\n        sumWithTwoDigits +=\
    \ sum % 10\n        return sumWithTwoDigits", "        val arr = arr.toList\n\
    \        var result = 0.0\n        for (i <- k to arr.length) {\n            result\
    \ += arr(i)\n        }\n        result", "        val r = new TreeSet[Long]()\n\
    \        for (i <- 0 until k) {\n            r += arr(i)\n        }\n        val\
    \ l = arr.size / 2\n        var sum = 0L\n        var lastSum = -1L\n        for\
    \ (i <- 0 until l) {\n            if (r.contains(arr(i))) {\n                sum\
    \ += arr(i)\n            } else {\n                lastSum = sum\n           \
    \     sum = arr(i)\n            }\n        }\n        lastSum", "        var index\
    \ : Long = 0\n        val totalSum = arr.take(k).foldLeft(0l) { (sum, element)\
    \ => sum + element }\n        while (index<k) {\n            val addElem = arr.take(index).foldLeft(0l)\
    \ { (sum, element) => sum + element }\n            if (addElem == 2 || addElem\
    \ == 3)\n                totalSum = totalSum + addElem\n            else {\n \
    \               val nextSum = arr.take(index+1)\n                if (nextSum.exists(_\
    \ == 2))\n                    totalSum = totalSum + nextSum.head\n           \
    \     else\n                    index++\n            }\n        }\n        return\
    \ totalSum", "        val arr = arr.sortBy(_ * 10)\n        var sum = 0L\n   \
    \     var left = 0L\n        var i = 0\n        var current = 0L\n        while\
    \ (i < k) {\n            val val = arr(i).toInt\n            current += val\n\
    \            i += 1\n            if (current > 10) {\n                sum += current\
    \ / 10\n                current = current % 10\n            } else {\n       \
    \         sum += current\n            }\n        }\n        if (left > 0) {\n\
    \            sum += left\n        }\n        sum", "        val m = arr.size\n\
    \        val r = new Array[Long](k)\n        var s = 0\n        var index = 0\n\
    \        var flag = false\n        var start = 0\n        var last = 0\n     \
    \   for (i <- 0 to k-1) {\n            if (index == k) {\n                val\
    \ temp = 0\n                var sum = 0\n                for (j <- 0 to k-1) {\n\
    \                    temp += arr(j)\n                    if (temp % 10 == 0) {\n\
    \                        sum += arr(j)\n                        temp = 0\n   \
    \                 }\n                }\n                if (sum >= last)\n   \
    \                 s += sum - last\n                last = 0\n                index\
    \ = 0\n                flag = false\n                start = 0\n            }\n\
    \            val curr = arr(index).toInt\n            var sum = curr\n       \
    \     if (start < curr && sum > last) {\n                sum += sum - last\n \
    \               last = sum\n                index++\n            } else {\n  \
    \              if (sum >= last)\n                    s += sum - last\n       \
    \         last = 0\n                index = 0\n            }\n            flag\
    \ = !flag\n            start++\n        }\n        if (index > 0) {\n        \
    \    val temp = 0\n            var sum = 0\n            for (j <- 0 to index-1)\
    \ {\n                temp += arr(j)\n                if (temp % 10 == 0) {\n \
    \                   sum += arr(j)\n                    temp = 0\n            \
    \    }\n            }\n            if (sum >= last)\n                s += sum\
    \ - last\n            s += last - last - arr.last\n        }\n        s + arr.last",
  "        var sum = 0\n        val maxLen = arr.length\n        for (i<- 1L until\
    \ (maxLen)) sum += arr(k)\n        return sum", "        val sum : Long = arr(0)\
    \ + (arr(1) + (arr(2) + (arr(3) + arr(4))))\n        arr.grouped(4).filter(n =>\
    \ k.toLong <= n.toLong).take(3).foldLeft(sum) {\n            ( acc, n ) =>\n \
    \           if( acc.toLong <= n.toLong) acc + n.toLong\n            else acc +\
    \ n.toLong + 10\n        }", "        val resultSet = mutable.HashSet[Long]()\n\
    \        val minSet = mutable.HashSet[Long]()\n        val maxSet = mutable.HashSet[Long]()\n\
    \n        for (element <- arr) {\n            val tempSet = minSet.union(maxSet)\n\
    \            if (tempSet.size <= 2) {\n                resultSet += element\n\
    \                minSet += element\n                maxSet += element\n      \
    \      } else {\n                if (tempSet.size == 3) {\n                  \
    \  if (element >= minSet.last) {\n                        minSet += element\n\
    \                    }\n                    if (element <= maxSet.last) {\n  \
    \                      maxSet += element\n                    }\n            \
    \    }\n            }\n        }\n        val maxSet2 = minSet.union(maxSet)\n\
    \        minSet.subsetOf(maxSet2)", "        var sum = 0l\n        for (i<- 0\
    \ until k) {\n            sum = sum + arr(i)\n        }\n        return sum",
  "        var sum = 0L\n        for(i<-0 to k-arr(0).toInt){\n            sum +=\
    \ arr(i).toLong\n        }\n        for(i<-0 to k){\n            if(arr(i).toInt\
    \ % 10 != 0 && sum-arr(i).toLong != 0){\n                sum -= arr(i).toLong\n\
    \            }\n        }\n        return sum", "        val result = mutable.LongAccumulator.zero\n\
    \        var i = 0\n        while (i < arr.size) {\n            if (k > 0 && arr(i).toInt\
    \ + arr(i+k).toInt > 9) {\n                result.add(arr(i).toInt + arr(i+k).toInt.toLong)\n\
    \                i += k\n                k--\n            } else {\n         \
    \       result.add(arr(i).toInt)\n                i += 1\n            }\n    \
    \    }\n        result.toLong", "        val num = new mutable.Queue[Long](arr.slice(0,\
    \ k).map(_.toLong))\n        var total = 0\n        while(num.nonEmpty) {\n  \
    \          total += num.dequeue()\n        }\n        total", "        if (arr.isEmpty)\
    \ 0\n        else {\n            val first = arr.take(k).toList\n            val\
    \ second = arr.drop(k).toList\n            var sum = 0\n            second.foreach\
    \ { x =>\n                if (x < 10) sum += x\n            }\n            sum\
    \ ++ first.sum\n        }", "        // write your code here\n        if(arr.size\
    \ < k)\n            return 0\n        var sum = 0\n        var arrLength = arr.size\n\
    \        for(i<-0 to arrLength-1) {\n            val elementNumber = arr(i)\n\
    \            if(elementNumber.toString.length < 2)\n                sum += elementNumber\n\
    \        }\n        return sum", "        val len = arr.size\n        val m =\
    \ 1l\n        var sum = 0\n        var startIdx = 0\n        val twosCount = arr.count(l\
    \ => l.toString.length < 2)\n        var idx = 0\n        while (idx < twosCount)\
    \ {\n            val l = arr(idx)\n            val sum = sum + l\n           \
    \ val currentLen = l.toString.length\n            if (sum > k) {\n           \
    \     start = arr.take(startIdx + 1).toString.length\n                sum = k\
    \ - sum\n            } else {\n                sum += m\n                m +=\
    \ 1\n            }\n            idx = idx + 1\n            if (currentLen - start\
    \ > 2) {\n                startIdx = idx\n            }\n        }\n        sum",
  "        arr.length match {\n            case 0 => 0\n            case 1 => arr(0)\n\
    \            case 2 => arr(0) + arr(1)\n            case 3 => arr(0) + arr(1)\
    \ + arr(2)\n            case 4 => arr(0) + arr(1) + arr(2) + arr(3)\n        \
    \    case 5 => arr(0) + arr(1) + arr(2) + arr(3) + arr(4)\n            case 6\
    \ => arr(0) + arr(1) + arr(2) + arr(3) + arr(4) + arr(5)\n            case 7 =>\
    \ arr(0) + arr(1) + arr(2) + arr(3) + arr(4) + arr(5) + arr(6)\n            case\
    \ 8 => arr(0) + arr(1) + arr(2) + arr(3) + arr(4) + arr(5) + arr(6) + arr(7)\n\
    \            case 9 => arr(0) + arr(1) + arr(2) + arr(3) + arr(4) + arr(5) + arr(6)\
    \ + arr(7) + arr(8)\n        }", "        var i = 0\n        var sum = 0\n   \
    \     while (i < k) {\n            sum += arr(i)\n            i += 2\n       \
    \ }\n        sum", "        val size = arr.size\n        val result = (0l.toLong\
    \ /: arr.take(k)(_+_)) { (sum, element) => sum * 10 + (element.asInstanceOf[Long])\
    \ } + k * 10\n        if (result <= size) {\n            result\n        } else\
    \ {\n            addElements(arr, k + 1)\n        }", "        val digits = arr.drop(k).toList\n\
    \        val sum : Long = 0\n        val sumOfDoubles = arr.take(k).foldLeft(0.0l)(_+_)\n\
    \        for ( i <- 0 until k ) {\n            sum += arr(i)\n            if(\
    \ digits(i).length == 2 ) {\n                sum += sumOfDoubles\n           \
    \ }\n        }\n        return sum", "        if (arr.isEmpty) return 0\n    \
    \    if (arr.length >= k) arr(k)\n        else arr(k)\n        val r = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length - k) {\n            val a = arr(i)\n   \
    \         val b = arr(i + k)\n            val c = arr(i + k + 1)\n           \
    \ val d = arr(i + k + 2)\n            r.add(a+b+c+d)\n        }\n        r.sum",
  "        if (arr.size <= k) return 0\n        val maxCount = arr.take(k)\n     \
    \   val maxElements = arr.filter(x => maxCount.contains(x).length == 1)\n    \
    \    val maxValues = maxCount.foldRight(0L) { case (sum, element) =>\n       \
    \     sum + element\n        }\n        val maxElement = maxElements.sum\n   \
    \     return maxValue + maxElement", "        var acc : Long = 0L\n        var\
    \ i : Int = 0\n        while (i < k) {\n            val a = arr(i).toLong\n  \
    \          val b = arr(i+1).toLong\n            val c = arr(i+2).toLong\n    \
    \        if (a == b) acc += a\n            if (a == c) acc += a\n            i\
    \ += 3\n        }\n        acc", "        val arr1 = arr.take(k)\n        val\
    \ arr2 = arr.drop(k).toList.map(_ / 10)\n        var sum = 0L\n        for (x\
    \ <- arr1) {\n            sum ++= x\n        }\n        for (x <- arr2) {\n  \
    \          sum ++= x\n        }\n        sum", "        var arrLen = arr.length\n\
    \        var result = 0.0\n        // loop through first k elements of arr\n \
    \       for (j <- 1 to k) {\n            result += arr.apply(j)\n        }\n \
    \       // loop through remaining elements of arr\n        for (j <- k+1 to arrLen)\
    \ {\n            result += arr.apply(j)\n        }\n        return result", " \
    \       val result = new mutable.ListBuffer[Long]()\n        var index = 0\n \
    \       var temp = 0\n        while (index < k) {\n            temp = arr.map(x\
    \ => x % 10).sum\n            if (temp > 2) {\n                result += 1\n \
    \           }\n            index += 1\n        }\n        result.sum", "     \
    \   var total = 0L\n        var i = 0L\n        var max = 0L\n        while(i\
    \ < k && arr.nonEmpty) {\n            max += arr(i)\n            i += 1\n    \
    \    }\n        if(i < k) {\n            while(i < k) {\n                max +=\
    \ arr(i++) max += arr(i)\n                i += 1\n            }\n        }\n \
    \       if(arr.isEmpty) max += 0\n        total += max\n        return total",
  "        var maxSum : Long = 0\n        var maxCount = 0\n        var maxElem =\
    \ 0\n        var maxSumOfFirstK = 0\n        for (i<- 0 until k){\n          \
    \  maxSumOfFirstK += arr(i)\n            maxCount = i\n            maxElem = arr(i)\n\
    \        }\n        for (i<- 0 until k){\n            var firstKSumOfI = 0\n \
    \           var firstKSum = 0\n            for (i<-0 until i){\n             \
    \   firstKSumOfI += arr(i)\n            }\n            firstKSum = firstKSumOfI\n\
    \            if (firstKSumOfI > maxSum){\n                maxSum = firstKSum\n\
    \                maxCount = i\n                maxElem = arr(i)\n            }\n\
    \        }\n        return maxSum", "        // code here\n        val first =\
    \ arr take k\n        val sum = first reduce ((x, y) => x + y)\n        return\
    \ sum.toLong", "        val countMap = new mutable.HashMap[Long, Int]()\n    \
    \    val sum = 0\n        for(i <- 0 to k-1){\n            val a = arr(i)\n  \
    \          if(countMap.contains(a)){\n                val count = countMap.get(a)\n\
    \                val oldCount = count - 1\n                countMap.put(a, oldCount)\n\
    \                sum += a\n            }else{\n                countMap.put(a,\
    \ 1)\n            }\n        }\n        sum", "        val arr = arr.toList\n\
    \        var ans = 0.0\n        var last = 0\n        for(i <- 0 until arr.length)\n\
    \        {\n            val current = arr(i)\n            if(i < k)\n        \
    \    {\n                if(current > last + 1) {\n                    ans += current\
    \ - last\n                    last = current\n                }\n            }\
    \ else \n            {\n                if(current < last + 1) {\n           \
    \         ans += last - current\n                    last = current\n        \
    \        }\n            }\n        }\n        if(k <= arr.length)\n          \
    \  ans += last - arr(k)\n        ans", "        val arr = arr\n        val arr\
    \ = arr.toList\n        val len = arr.size\n        val twoDigits = arr.filter(_\
    \ < 9l).size\n        if (twoDigits < k)\n            throw new ArithmeticException(\"\
    Incorrect sum, sum of digits for k is less than size of k\")\n        val twoDigitsSum\
    \ = arr.take(twoDigits).sum\n        return twoDigitsSum + twoDigits.toLong *\
    \ k", "        arr.sortWith(_ < _) // sort\n        val res = arr.drop(k).takeWhile(_\
    \ < _ + 999)\n        val lc = arr.length - k\n        val maxCnt = arr.count(_\
    \ < _ + 999)\n        if(lc > maxCnt) res + (999l - res)(0)\n        else res(0)",
  "        var sum = 0\n        var k1 = k\n        var k2 = k\n        for(i <- 0\
    \ until arr.length) \n        {\n            val j = (i + 1).toInt\n         \
    \   if(i == 0 && j < k1)\n            {\n                k1 = j\n            }\n\
    \            else if(j == arr.length-1 && i < k2)\n            {\n           \
    \     k2 = i\n            }\n            val m = math.max(k1,k2)\n           \
    \ if(i%m == 0)\n            {\n                sum = sum + arr(i)\n          \
    \  }\n        }\n        return sum", "        // O(n)\n        var sum = 0l\n\
    \        // O(n)\n        val maxElemsToConsider = arr.take(k)\n        // O(n+k)\n\
    \        for (elem <- maxElemsToConsider) {\n            // O(1)\n           \
    \ val firstDigit = elem.toString.substring(0, 1)\n            // O(1)\n      \
    \      val secondDigit = elem.toString.substring(1, 2)\n            // O(1)\n\
    \            val sum = sum + (if (firstDigit < secondDigit) 1 else 0)\n      \
    \  }\n        // O(n)\n        sum", "        val maxLength = arr.take(k).length\n\
    \        val twoDigitMaxLength = (maxLength - 2) max 0 // for safety: at most\
    \ k digits are used\n        val twoDigitMax = maxLength * 10l.toLong // to ensure\
    \ overflow in intermediate operations\n        val sum = 0l\n        for (elem\
    \ <- arr; idx <- 0 until k)\n            sum += (elem - arr(idx) mod twoDigitMax)\n\
    \        sum", "        val numOfElements = arr.size\n        val map = new mutable.HashMap[Long,Long]\n\
    \        for(i <- 0 until numOfElements) {\n            if(!map.containsKey(arr(i)\
    \ - k)) {\n                map.put(arr(i) - k, 0)\n            }\n           \
    \ map.put(arr(i) - k, map.get(arr(i) - k) + 1)\n        }\n        val maxValues\
    \ = map.groupBy(_._2).maxBy(_._1)\n        val result = maxValues.map(_._1).sum\n\
    \        result", "        val arr = arr.sortWith(_ > _).take(k)\n        val\
    \ map = new mutable.HashMap[Long, Long]()\n        for (e <- arr) {\n        \
    \    val digits = digitsOf(e)\n            if(digits.length == 2) map.putIfAbsent(digits,\
    \ 0l) += e\n            else map.putIfAbsent(digits, e) += e\n        }\n    \
    \    val sum = map.values.reduce(_ + _)\n        sum.toLong", "        val result\
    \ = 0.0;\n        var index = 0;\n        var sum = 0;\n        while (index <\
    \ k) {\n            sum += arr(index);\n            index += 1;\n        }\n \
    \       result = sum", "      val max = arr.last\n      val max2 = arr.init\n\
    \      val sum = 0\n      val max2Len = max2.length\n      val arrLen = arr.length\n\
    \      arr.foreach {\n        case i : Long =>\n          if (i < 10L) {\n   \
    \         sum = sum + i\n          } else if (i < (max2 + 10L)) {\n          \
    \  val nextDigit = i / 10L\n            val nextDig2 = ((i % 10L) * 100L) % 10L\n\
    \            val nextDigit3 = i - (nextDig * 10L) - (nextDig2 * 100L)\n      \
    \      sum = sum + nextDigit\n            if (nextDig2 > max2Len - 1) sum = sum\
    \ + max2\n            if (nextDigit3 > max2Len - 1) sum = sum + max2\n       \
    \   } else {\n            val nextDigit4 = i / 100L\n            val nextDigit5\
    \ = ((i % 100L) * 1000L) % 100L\n            val nextDigit6 = i - (nextDigit4\
    \ * 100L) - (nextDigit5 * 1000L)\n            sum = sum + nextDigit4\n       \
    \     if (nextDigit5 > max2Len - 1) sum = sum + max2\n            if (nextDigit6\
    \ > max2Len - 1) sum = sum + max2\n          }\n      }\n      sum", "       \
    \ // Initialize result as sum of first k elements\n        var result = arr.head\n\
    \n        // For all elements except the first k add their digits\n        for\
    \ ( n <- arr.tail ) {\n            result += n\n        }\n\n        // For the\
    \ k first elements add their two digits\n        for ( i <- 1 to k-1 ) {\n   \
    \         result += arr(i)\n        }\n\n        return result", "        var\
    \ max = 2\n        var result = 0L\n        for (i <- 0 until arr.size) {\n  \
    \          val curr = arr(i)\n            if (max <= 2 || curr % 10 == 0)\n  \
    \              result += curr\n            max += 2\n            if (max > k)\n\
    \                break\n        }\n        result", '        // your code is here',
  "        if (k > arr.length) 0\n        else {\n            val maxIndex = arr.lastIndex\
    \ - k + 1 // max index from last k elements of arr\n            val sums = arr.take(k)\
    \ // first k elements of arr\n            val sum: Long = 0\n            for (i\
    \ <- 0 until k) sum += sums(i)\n            sum\n        }", "        val twoDigitsMax\
    \ = arr.take(k).filter(_ % 10 != 0).reduceLeft(_ max _)\n        val firstTwoMax\
    \ = arr.filter(_ % 10 == 0).take(twoDigitsMax).map(_ / 10).reduceLeft(_ max _)\n\
    \        firstTwoMax.sum", "        if (arr.isEmpty) 0\n        else if(arr.head\
    \ > k)\n            addElements(arr.drop(1), k)\n        else\n            arr.foldLeft(0l)\
    \ { (a, e) => a + e.drop(1).sum.take(2) }", "        val arr = arr.drop(k).toList\n\
    \        val res = arr.takeWhile(_ < 10).reduceLeftOption(_ + _)\n        res.getOrElse(0)",
  "        require(arr.nonEmpty)\n        require(k <= arr.length)\n        val twoDigits\
    \ = arr.reverse.take(k).sum\n        val otherDigits = arr.reverse.drop(k).sum\n\
    \        (twoDigits + otherDigits)", "        var i = 0\n        var total = 0\n\
    \        while(i < arr.length) {\n            var nextSum = arr(i) + arr(i+1)\n\
    \            var sum = (nextSum.toString.length < k) ? nextSum : nextSum.substring(0,k)\n\
    \            total += sum.toLong\n            i += 2\n        }\n        total",
  "        var sum = 0L\n        val sortedArr = arr.sortWith((x, y) => x < y)\n \
    \       var i = 0\n        while (i < k) {\n            sum += sortedArr(i)\n\
    \            i += 1\n        }\n        sum", "      var num : Long = 0\n    \
    \  arr.foreach( i => num = num + i.toString.substring(0,k)+i.toString.substring(k)\
    \ )\n      num", "        val maxSum = arr.take(k).reduceLeft(_ + _)\n       \
    \ val sum = (1l to k).filter(i => arr.take(i).sum <= maxSum)\n            .reduceLeft(_\
    \ + _)\n        sum", "        val map = mutable.HashMap[Long,Long]()\n      \
    \  for (i<-0 until k) {\n            map += (i.toLong -> arr(i))\n        }\n\
    \        map.filterValues( v => v.length > 1).map( v => v.last).sum", "      \
    \  val map = mutable.HashMap.empty[Long,Long]\n        for (i <- arr.take(k))\
    \ {\n            val value = map.getOrElse(i,0l) + i\n            map += i ->\
    \ value.toLong\n        }\n        val sum = map.values.sum\n        sum", " \
    \       // Brute-force approach\n        var ret = 0L\n        for(j <- 1 to k)\
    \ {\n            ret += arr.take(j).sum\n        }\n        return ret", "   \
    \     val arr = arr.sortWith(_ > _)\n        val result = (0 until arr.length).filter(_\
    \ => arr.dropRight(1).contains(arr(_)))\n        val sum = result.reduce(_ + _)\n\
    \        return sum + arr(k).toLong", "        val n = arr.size\n        var maxCount\
    \ = 1\n        var sum = 0\n        for (i <- 1 to n) {\n            var count\
    \ = 0;\n            var curr = arr(i)\n            var maxNum = 1\n          \
    \  var flag = true;\n            while (curr != 0) {\n                if (curr\
    \ % 10 == 0) {\n                    count++\n                }\n             \
    \   if (count > maxCount) {\n                    maxCount = count;\n         \
    \           maxNum = curr;\n                    flag = false;\n              \
    \  }\n                curr = curr.toInt\n            }\n            if (count\
    \ == maxCount) {\n                if (flag) {\n                    sum += maxNum\n\
    \                }\n            }\n        }\n        return sum;", "        val\
    \ n = arr.size\n        val res = 0L\n        val arr = arr.toArray\n        for(i\
    \ <- 0 until k) {\n            val j = (i + 1) % n\n            res += arr(i)\n\
    \            res += arr(j)\n        }\n        res", "        val ret = 0L\n \
    \       val n = arr.size\n        for (x<-n;x<k){\n            val cur = arr.get(x)\n\
    \            if(cur>10){\n                val tmp = (cur.toInt*10).toLong + ret.toLong\n\
    \                ret = tmp\n            }\n        }\n        ret", "        var\
    \ sum = 0\n        for (i <- 0 until arr.size) {\n            var sum = sum +\
    \ arr(i)\n            if (sum.toString.length <= k.toString.length) {\n      \
    \          return sum\n            }\n        }\n        return sum", "      \
    \  val newList = arr.take(k) ++ (arr.drop(k))\n        val maxLen = Math.max(newList.map(_\
    \ % 10).sum, 0).toLong\n        newList.zip(newList.tail).map { case (x, y) =>\
    \ if (x._1 % 10 == y._1 % 10 && x._2 % 10 != y._2 % 10) return x + y._2 else x\
    \ + y._1 + 1 }.sum / maxLen", "        val sum = 0\n        for (i<-0 until k)\
    \ {\n            sum += arr(i)\n        }\n        sum", "        val arr = arr.toList\n\
    \        var max2 : List[Long] = null\n        var maxSum : Long = 0\n       \
    \ for (i <- arr.indices.reverse.toList if arr.length > i) {\n            // get\
    \ two max\n            val x = arr(i)\n            if (max2 == null || x > max2(1))\n\
    \                max2 = List(x, arr(i))\n            else {\n                if\
    \ (x > maxSum + max2(1))\n                    maxSum = maxSum + max2(1)\n    \
    \            max2 = List(arr(i), x)\n            }\n        }\n        if (max2\
    \ != null)\n            maxSum = maxSum + max2(1)\n        maxSum", "        var\
    \ result : Long = 0\n        for(i <- 0 until k) {\n            val tmp = (arr(i)\
    \ - 1000l)\n            result += math.abs(tmp.toInt)\n        }\n        return\
    \ result", "      var sum = 0\n      for(i <- 0 until k)\n      sum += arr(i)\n\
    \n      var i = k\n      while(i >= 0)\n      {\n        var sum = sum + (arr(i)\
    \ / 1000L)\n        i -= 1\n      }\n      return sum", "        val n = new collection.mutable.Queue[Long]\n\
    \        for(i <- 0 until arr.length) {\n            val s = arr(i)\n        \
    \    val ns = n\n            for(j <- 0 until k) {\n                val m = s.toInt\n\
    \                if(m < 100) {\n                    n.enqueue(s.toInt * 10)\n\
    \                } else {\n                    val t = (s % 100).toInt\n     \
    \               n.enqueue(t)\n                    n.enqueue(s % 100)\n       \
    \         }\n            }\n            if(n.length == 1) n.enqueue(s)\n     \
    \   }\n        val result = n.dequeue\n        result * (100 + result)", "   \
    \     val arrSize = arr.size\n        var minDigits = 2\n        var result =\
    \ 0\n        var i = 0\n        while(i < k) {\n            val sumDigits = arr.take(minDigits).sum\n\
    \            if (sumDigits < minDigits) {\n                minDigits = sumDigits\n\
    \            }\n            else {\n                result += arr.take(minDigits).sum\n\
    \                minDigits = 2\n                i = 0\n            }\n       \
    \ }\n        result += arr.take(minDigits).sum\n        result", "      def f(i:\
    \ Int, arr : List[Long]) : List[Long] = {\n        if (i < arr.length && i <=\
    \ k) {\n          val result = arr(i).toString.dropRight(1).dropRight(1).dropRight(1).dropRight(1)\n\
    \          val list = result.toInt\n          val newList: List[Long] = new mutable.ArrayList[Long]\n\
    \          newList(list) += arr(i)\n          f(i + 1, newList)\n        } else\
    \ {\n          arr\n        }\n      }\n      f(0,arr)", "        var sum = 0L\n\
    \        for (i <- 0 until k) {\n            sum += arr.take(i).filter(i => i\
    \ >= 10).sum\n        }\n        return sum", "        val result = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        arr.take(math.min(k+1, arr.length)).foreach { i =>\n            arr.lastOption\
    \ match {\n                case None => result.append((i.toInt - arr.head).toLong)\n\
    \                case Some(last) =>\n                    if (i <= last - 2)\n\
    \                        result.append((i.toInt - last).toLong)\n            \
    \        else\n                        result.append((i-last).toLong)\n      \
    \      }\n        }\n        result.sum", "        val maxDigits = 2\n       \
    \ val result = new mutable.MutableList[Long]()\n        val start = 1\n      \
    \  val currentSum = arr(start)\n        for(i <- 0 until k){\n            val\
    \ newSum = currentSum + arr(i)\n            if((newSum % 10).isPositive){\n  \
    \              result.add(newSum)\n            }\n            currentSum = newSum\n\
    \        }\n        val retSum = result.sum\n        if(k > result.size){\n  \
    \          val r = k - result.size\n            retSum - r * (retSum / 100)\n\
    \        }\n        return retSum", "        val res = arr.head + arr.last\n \
    \       val maxPos = arr.take(k).lastIndexWhere(x => x > res).toInt // index of\
    \ the largest number that fits in the first k elements\n        val minPos = arr.take(k).lastIndexWhere(x\
    \ => x <= res).toInt // index of the smallest number that fits in the first k\
    \ elements\n        val rangePos = Math.min(k, maxPos - minPos + 1) // number\
    \ of elements with at most two digits in the first k elements of arr\n       \
    \ val maxTwoDigitsSum = res.toLong * 10 + arr[maxPos - rangePos]\n        val\
    \ maxTwoDigitsSum2 = res.toLong * 10 + arr[maxPos - rangePos - 1]\n        val\
    \ maxTwoDigitsSum3 = res.toLong * 10 + arr[maxPos - rangePos - 2]\n        val\
    \ maxTwoDigitsSum4 = res.toLong * 10 + arr[maxPos - rangePos - 3]\n        val\
    \ maxTwoDigitsSum5 = res.toLong * 10 + arr[maxPos - rangePos - 4]\n        val\
    \ maxTwoDigitsSum6 = res.toLong * 10 + arr[maxPos - rangePos - 5]\n        val\
    \ maxTwoDigitsSum7 = res.toLong * 10 + arr[maxPos - rangePos - 6]\n        val\
    \ maxTwoDigitsSum8 = res.toLong * 10 + arr[maxPos - rangePos - 7]\n        val\
    \ maxTwoDigitsSum9 = res.toLong * 10 + arr[maxPos - rangePos - 8]\n        val\
    \ maxTwoDigitsSum10 = res.toLong * 10 + arr[maxPos - rangePos - 9]\n        val\
    \ maxTwoDigitsSum11 = res.toLong * 10 + arr[maxPos - rangePos - 10]\n        val\
    \ maxTwoDigitsSum12 = res.toLong * 10 + arr[maxPos - rangePos - 11]\n        val\
    \ maxTwoDigitsSum13 = res.toLong * 10 + arr[maxPos - rangePos - 12]\n        val\
    \ maxTwoDigitsSum14 = res.toLong * 10 + arr[maxPos - rangePos - 13]\n        val\
    \ maxTwoDigitsSum15 = res.toLong * 10 + arr[maxPos - rangePos - 14]\n        val\
    \ maxTwoDigitsSum16 = res.toLong * 10 + arr[maxPos - rangePos - 15]\n        val\
    \ maxTwoDigitsSum17 = res.toLong * 10 + arr[maxPos - rangePos - 16]\n        val\
    \ maxTwoDigitsSum18 = res.toLong * 10 + arr[maxPos - range", "        if (arr.isEmpty)\n\
    \            return 0\n        var sum = 0L\n        var i = k\n        for(elem\
    \ <- arr) {\n            if (i < 2)\n                sum += elem\n           \
    \ else if (i != arr.size && elem >= 10 * arr(i - 1))\n                sum += elem\n\
    \            i = i + 1\n        }\n        return sum", "        val m = arr.size\n\
    \        val maxk = m + k - 1\n        val twodigits = mutable.Map[Long, Long]()\n\
    \        var sum = 0l\n        // first k-1 elements\n        for(i <- 0 until\
    \ k) {\n            twodigits(arr(i)) += arr(i)\n        }\n        // second\
    \ k-1 elements\n        for(i <- m until maxk) {\n            twodigits(arr(i))\
    \ += arr(i)\n        }\n        for(i <- 0 until m) {\n            sum = sum +\
    \ (twodigits(arr(i)) / 1000 + twodigits(arr(i)) % 1000) * Math.pow(10, arr.size\
    \ - 1 - i)\n        }\n        sum.toLong", "        if (arr.isEmpty) {\n    \
    \        return 0l\n        }\n        var sum = 0L\n        var kIndex = 0\n\
    \        val maxK = arr.size - 1\n        for(i <- 0 until k) {\n            sum\
    \ += arr(if (i < (k - 1)) k else i)\n        }\n        for(i <- 0 until k) {\n\
    \            sum += arr(if (i < (kIndex + 1)) maxK else i)\n            kIndex\
    \ += 1\n        }\n        sum", "        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        var sum = 0\n        for (x <- arr.take(k)) {\n            sum += x\n\
    \        }\n        val rest = arr.drop(k)\n        val restSum = addElements(rest,\
    \ 1)\n        val restSumToDigits = math.pow(restSum,9) / math.pow(10, arr.length.toDouble\
    \ - k)\n        result += sum * restSumToDigits\n        result.foldLeft(0l){case\
    \ (acc, x) => acc+x.toInt}", '        arr.take(k).map(_ + arr(0)).sum', "    \
    \  \n        def sum(n: Long, arr: List[Long]): Long = {\n          if (n < 2l)\
    \ arr.headOption.getOrElse(0l) + sum(n + 2l, arr.tail)\n          else sum(n +\
    \ 2l, arr.tail)\n        }\n        \n        val n = arr.size\n        val arr\
    \ = arr.toList\n        sum(n,arr)\n      }\n    \n      \n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>\nimport scala.math._\n\nobject Solution {\n  def sumFirstKElements(arr:\
    \ Array[Int], k: Int): Int = {\n    val sumFirstKElements = arr zip arr take k\
    \ reduce (_ + _)\n    arr.size - (sumFirstKElements zip arr.drop(k)) reduce (_\
    \ + _)\n  }\n}\n\n</code>\n<|/ a dscore=0 tags=scala |>\n<| c |>\nCan you give\
    \ an explanation for your code?\n<|/ c |>\n<| c |>\nThis is an example of what\
    \ i meant: https://stackoverflow.com/a/40733188/824743\n<|/ c |>\n<| a tags=scala\
    \ |>\n<code>\nscala> def sumFirstKElements(arr: Array[Int], k: Int): Int = {\n\
    \     |     val sumFirstKElements = arr.zip(arr).take(k).map(_ + _)\n     |  \
    \   arr.size - (sumFirstKElements.zip(arr.drop(k)).map(_ + _)) reduce (_ + _)\n\
    \     | }\nsumFirstKElements: (arr: Array[Int], k: Int)Int\n\nscala> sumFirstKElements(Array(1,2,3,4,5,6,7,8,9,10),\
    \ 4)\nres0: Int = 10\n</code>\n<|/ a dscore=0 |>\n<| a tags=scala dscore=0 |>\n\
    <code>\ndef sumFirstKElements(arr: Array[Int], k: Int): Int = {\n  var sumFirstKElements\
    \ = 0\n  for(i <- 0 until k) {\n    sumFirstKElements += arr(i)\n  }\n  arr.size\
    \ - sumFirstKElements\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this code snippet\
    \ may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please ", "      var sum = 0\n      var i\
    \ = 1 // we start with the first element\n      while (i < k) {\n        sum +=\
    \ arr(i)\n        i += 1\n      }\n      sum", "        val nums = arr.take(k).toList\
    \ \n        nums.reduce(_ + _)", "        val result = arr.foldLeft((0l, 0l))((acc,\
    \ elem) => {\n            val acc1 = (acc(0), acc(1))\n            val acc2 =\
    \ (acc1(0), acc1(1) + elem)\n            val acc3 = (acc2(0), acc2(1) + acc1(0))\n\
    \            (acc3(0), acc3(1))\n        })\n        val acc = (result(0), result(1))\n\
    \        if(k > acc._1) result else acc", "        val result = new ListBuffer[Long]()\n\
    \        for (i <- 0 until k ) result += arr(i)\n        val maxCount = result.count(i\
    \ => i.length <= 2)\n        result.filter(_ <= maxCount).sum", "        var sum\
    \ = 0\n        var count = 0\n        for (el <- arr.take(k)) {\n            if\
    \ (math.floor(el*100) <= k) {\n                sum += el\n                count\
    \ += 1\n            }\n        }\n        return sum * (math.pow(10, count) /\
    \ math.pow(10, k));", "      val sorted = arr.sorted\n      val result = 0\n \
    \     for( i <- 0 to k-1) result += sorted.apply(i)\n      result", "        val\
    \ arr = arr.take(k).toList\n        var res = 0l\n        var i = 0\n        while\
    \ (i < arr.length) {\n            val sum = arr(i) + arr(i + 1)\n            res\
    \ = sum if sum > res else res\n            i += 2\n        }\n        res", " \
    \       val arr = arr.toList\n        var sum = 0\n        var i = k\n       \
    \ while(i >= 0 && i < arr.length) {\n            sum += arr(i).toLong\n      \
    \      i -= 1\n        }\n        if (i < 0) {\n            return sum\n     \
    \   }\n        if (sum < 10) {\n            return sum\n        }\n        for(i\
    \ = k; i < arr.length; i++){\n            val x = arr(i).toLong\n            sum\
    \ += (x / 10).toLong\n        }\n        return sum", "        val size = arr.size\n\
    \        val min = arr.head\n        val max = arr.last\n        var currentSum\
    \ = min.toLong\n        for (i <- k to size by 2) {\n            currentSum =\
    \ currentSum + arr(i).toLong\n        }\n        if (currentSum < max) {\n   \
    \         currentSum = currentSum + max\n        }\n        if (currentSum > max)\
    \ {\n            currentSum = currentSum - max\n        }\n        currentSum",
  "        var ans = 0\n        var count = 0\n        for (i <- 0 until arr.length)\
    \ {\n            if (count > k) {\n                ans += arr(i)\n           \
    \     count = 0\n            } else {\n                count += 1\n          \
    \  }\n        }\n        return ans", "        val sum = 0\n        val maxCount\
    \ = arr.take(k).filter(_ > 9).length\n        var i = 0\n        var maxIndex\
    \ = 0\n        var j = 0\n        while (i < k) {\n            while (j < maxCount\
    \ && arr(i + j) < 9) {\n                j++\n            }\n            sum +=\
    \ arr(i + j)\n            i += j + 1\n            maxIndex = j - maxCount\n  \
    \          j = 0\n        }\n        sum", "        val ans = 0l\n        var\
    \ l = arr.size\n        while(l >= k){\n            val min = arr.take(l).min\n\
    \            val max = arr.take(l).max\n            ans += max\n            l\
    \ -= 1\n        }\n        ans", "        def toTwoDigits(n : Long) =\n      \
    \      if(n>9) n else (n%10 + 10*n%10)\n        val result = 0.until(arr.length).foldLeft(0l)\
    \ { (res: Long, i: Long) => res + toTwoDigits(arr(i)) + toTwoDigits(arr(i+1))\
    \ }\n        if(result.length<=k) result else (result.take(k)).sum", "       \
    \ val arr = arr.toList\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val sum = new mutable.ListBuffer[Long]()\n        for (i <- 0 until k)\
    \ {\n            sum += arr.take(i)\n        }\n        arr.length -= k\n    \
    \    for (i <- 0 until arr.length) {\n            if (sum(i) > 2) {\n        \
    \        result += sum(i)\n            } else {\n                result += arr(i)\n\
    \            }\n        }\n        arr.length -= result.length\n        result.toList"]
stop_tokens:
- "\n    }\n"
