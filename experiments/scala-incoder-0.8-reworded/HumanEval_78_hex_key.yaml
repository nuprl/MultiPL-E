name: HumanEval_78_hex_key
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You have been tasked to write a function that receives \n    // a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n    // digits that are\
  \ primes (prime number, or a prime, is a natural number \n    // greater than 1\
  \ that is not a product of two smaller natural numbers).\n    // Hexadecimal digits\
  \ are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    // Prime numbers are\
  \ 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine a number of the following\
  \ digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal 13).\n    // Note: you\
  \ may assume the input is always correct or empty string, \n    // and symbols A,B,C,D,E,F\
  \ are always uppercase.\n    // Examples:\n    // >>> hexKey((\"AB\"))\n    // (1l)\n\
  \    // >>> hexKey((\"1077E\"))\n    // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n\
  \    // (4l)\n    // >>> hexKey((\"123456789ABCDEF0\"))\n    // (6l)\n    // >>>\
  \ hexKey((\"2020\"))\n    // (2l)\n    def hexKey(num : String) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"))\
  \ == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
  )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
  )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
  \    }\n\n}\n"
completions: ["        val result = mutable.LinkedHashMap[(Int, Int), Long]()\n  \
    \      for(i <- 0 until num.length) yield {\n            val hexDigit = num.toChar(i).toInt\n\
    \            val decimalDigit = (hexDigit - 48)\n            val binary = decimalDigit\
    \ * (10l << 4)\n            val digit = decimalDigit % 2\n            result +=\
    \ (\n                (binary.asInstanceOf[(Int, Int)]) -> (\n                \
    \    if (digit == 0) 1\n                    else if (digit == 1) 3\n         \
    \           else digit\n                )\n            )\n        }\n        val\
    \ maxSize = 3 \n        val maxKey = result.map(_._1).filter(_._2 > maxSize).max\n\
    \        val maxValue = result.map(_._2).max\n        result.get(maxKey).map(_._2)",
  "        // I solved the problem with recursion and pattern matching\n        //\
    \ and I didn't use loops.\n        val result: Long = num.toLong\n        val\
    \ arr: Array[Char] = num.toCharArray\n        if (arr.length > 0) {\n        \
    \    val first = arr.head\n            val rest = arr.tail\n            // If\
    \ there is a remaining array, then there are more digits\n            if (rest.length\
    \ > 0) {\n                val result1 = hexKey(rest)\n                // If the\
    \ first digit is a prime number, then the result is a prime number\n         \
    \       if (first == 1 ||\n                    (first == 2 && arr.length == 2\
    \ && (rest == 2 || rest == 3) ||\n                    (first == 3 && arr.length\
    \ == 2 && (rest == 3 || rest == 5) ||\n                    (first == 4 && arr.length\
    \ == 2 && (rest == 4 || rest == 7) ||\n                    (first == 5 && arr.length\
    \ == 2 && (rest == 5 || rest == 11) ) ||\n                    (first == 6 && arr.length\
    \ == 2 && (rest == 6 || rest == 13) ) ||\n                    (first == 7 && arr.length\
    \ == 2 && (rest == 7 || rest == 17) ) ||\n                    (first == 8 && arr.length\
    \ == 2 && (rest == 8 || rest == 19) ) ||\n                    (first == 9 && arr.length\
    \ == 2 && (rest == 9 || rest == 29))))\n                    result += result1\n\
    \                // If there is only 1 digit left, then result is a prime number\n\
    \                else if (arr.length == 1) {\n                    result += 1\n\
    \                }\n            }\n        }\n        result", "        def pow(x:Long,\
    \ y:Int) : Long = {\n            val result = 1L\n            for(i <- 0 until\
    \ y-1) result *= x\n            result\n        }\n        val chars = num.split(\"\
    \").toList\n        val n = chars.count { case c: Char => c.isDigit }\n      \
    \  val m = chars.count { case c: Char => c.isUpper }\n        val m = if(m < n)\
    \ n else m\n        val n = if(n < m) n else m\n        val d = chars.count {\
    \ case c: Char => c.isUpper }\n        val b = chars.count { case c: Char => c.isLower\
    \ }\n        val d = if(d < b) d else b\n        val result = pow(n*n, d)\n  \
    \      result * pow(2, d)", "        val n = num.trim().toUpperCase\n        val\
    \ digits = n.chars().filter(c => c <= 'F').count()\n        var count = 0\n  \
    \      var prime = 1\n\n        while (digits(prime) < digits(n)) {\n        \
    \    prime = (prime * 3)\n        }\n        // if the first number was prime\
    \ (prime = 1) we add 0\n        if (prime == 1) {\n            count += 0\n  \
    \      }\n        for (i <- 2 to prime-1) {\n            val isPrime = true\n\
    \            for (j -> k <- prime-i+1 until i) {\n                if (i % j ==\
    \ 0) {\n                    isPrime = false\n                    break\n     \
    \           }\n            }\n            if (isPrime) {\n                count\
    \ += i\n            }\n        }\n        count + 1", "        val a = num.toCharArray\n\
    \        val n = a.length\n        val hex = num.toList\n        val result =\
    \ 0\n        var i : Int = 0\n        while (i < n) {\n            val y = hex(i).toInt\n\
    \            val x = y() - 48\n            if (x >= 0 && x <= 9) {\n         \
    \       result = result + (x * 10)\n            }\n            i += 1\n      \
    \  }\n        result", "        val hex = num.toLowerCase.replaceAll(\"\\\"\"\
    , \"\").toUpperCase\n        if (hex.length == 6){\n            val digits = hex.split(\"\
    \").map(_.toInt)\n            var prime = 1\n            val l = digits.length\n\
    \            val counter = mutable.Buffer[Int]()\n            var j = 0\n    \
    \        while (j < l){\n                val p = digits(j) * digits(j + 1)\n \
    \               counter.append(p)\n                if (p != 1 && p != prime){\n\
    \                    prime = p\n                }\n                j += 1\n  \
    \          }\n            val counters = counter.distinct\n            counters.toList.map(_.toLong).sum\n\
    \        }\n        else{\n            0\n        }", "        var result : Long\
    \ = 0\n        var isPrime : Boolean = false\n        var hexDigit : Int = 0\n\
    \        var isHexDigit : Boolean = false\n        var isPrimeDigit : Boolean\
    \ = false\n        for(i <- 0 until num.length){\n            hexDigit = num(i).toInt\n\
    \            hexDigit = hexDigit match {\n                case x if x >= 'A' &&\
    \ x <= 'F' => {\n                    isHexDigit = true\n                    hexDigit\
    \ - 'A' + 1\n                }\n                case x if x >= '0' && x <= '9'\
    \ => {\n                    isHexDigit = true\n                    hexDigit -\
    \ '0' + 1\n                }\n                case _ => throw new Exception(\"\
    Invalid hexadecimal number string: \" + num)\n            }\n            if(isHexDigit)\
    \ {\n                isPrimeDigit = true\n                isPrime = isPrime ||\
    \ (hexDigit == 2)\n                isPrime = isPrime || (hexDigit == 3)\n    \
    \            isPrime = isPrime || (hexDigit == 5)\n                isPrime = isPrime\
    \ || (hexDigit == 7)\n                isPrime = isPrime || (hexDigit == 11)\n\
    \                isPrime = isPrime || (hexDigit == 13)\n                isPrime\
    \ = isPrime || (hexDigit == 17)\n                isPrime = isPrime || (hexDigit\
    \ == 19)\n                isPrime = isPrime || (hexDigit == 23)\n            \
    \    isPrime = isPrime || (hexDigit == 29)\n                isPrime = isPrime\
    \ || (hexDigit == 31)\n                isPrime = isPrime || (hexDigit == 37)\n\
    \                isPrime = isPrime || (hexDigit == 43)\n                isPrime\
    \ = isPrime || (hexDigit == 59)\n                isPrime = isPrime || (hexDigit\
    \ == 67)\n                isPrime = isPrime || (hexDigit == 73)\n            \
    \    isPrime = isPrime || (hexDigit == 79)\n                isPrime = isPrime\
    \ || (hexDigit == 83)\n                isPrime = isPrime || (hexDigit == 89)\n\
    \                isPrime = isPrime || (hexDigit == 97)\n            }\n      \
    \      if(!isPrimeDigit) result += hexDigit\n        }\n        result", "   \
    \     val nums = num.toList.flatMap(_.toDigit)\n        val key = (2 to nums.length).foldLeft(1l)(\n\
    \            (x: Long, i) => \n                if (num(i) == 0) \n           \
    \         1l \n                else if (nums(i) >= 0 && nums(i) < 10) {\n    \
    \                x + (10 ** i)\n                } else if (nums(i) == 10) {\n\
    \                    x + (5 ** i)\n                } else if (nums(i) == 13) {\n\
    \                    x + (7 ** i)\n                } else if (nums(i) == 11) {\n\
    \                    x + (11 ** i)\n                } else if (nums(i) == 17)\
    \ {\n                    x + (13 ** i)\n                } else if (nums(i) ==\
    \ 19) {\n                    x + (17 ** i)\n                } else 1l\n      \
    \  )\n        key", "        // 1. Split num in digits and chars and transform\
    \ the chars in int\n        val (digits, chars) = num.toInt split \"\"\n     \
    \   \n        // 2. Make an immutable set of primes\n        val primes = scala.collection.mutable.Set[Int]()\
    \ ++= List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97)\n\
    \        val primesIterator = primes.iterator\n        val primes = primesIterator.mkString\n\
    \        \n        // 3. Make an immutable list of all digits\n        val digits\
    \ = scala.collection.mutable.ListBuffer[Int]()\n        for(i <- 0 to digits.length\
    \ - 1)\n            digits += digits(i)\n\n        // 4. Count the number of prime\
    \ digits in digits that are not divisible by primes.\n        val (count, primes)\
    \ = (digits.length - primes.splitAt(digits.length).length, primes)\n        \n\
    \        // 5. Return the count of digits not divisible by primes\n        digits.count(x\
    \ => !primesIterator.contains(x) && !primes.contains(x / primesIterator.length).toInt)",
  "        val hexs = hexDigits(num)\n        val count = new mutable.HashMap[String,\
    \ Long]\n        hexs.foreach { hexNum =>\n            val key = hexNum.toString\n\
    \            if (count.contains(key)) {\n                count(key) = count(key)\
    \ + 1\n            } else {\n                count.put(key, 1)\n            }\n\
    \        }\n        count.values.toArray.max", "      val key = scala.collection.mutable.ListBuffer[Long]()\n\
    \      for (hex <- num.toCharArray) {\n        val value = scala.math.pow(hex,\
    \ num.length)\n        // If the value is less than two, then that is not a prime,\
    \ otherwise\n        // it is.\n        if (value <= 2) key += value\n      }\n\
    \      key.sum", "        //Complete the function here\n        val n = num.toInt\n\
    \        val a = 1\n        val b = n\n        val nPrime = 0\n        var nDivisor\
    \ = 0\n        var nDivisorTemp = 0\n        var nFactor = 0\n        while(a\
    \ <= b){\n            nDivisorTemp = nDivisor\n            nDivisor = n%a\n  \
    \          nFactor = a\n            while (nDivisor != 0){\n                nDivisorTemp\
    \ = nDivisorTemp*nFactor\n                nDivisor = nDivisor/a\n            \
    \    nFactor = a\n            }\n            if (nDivisorTemp == 0){\n       \
    \         nPrime = nPrime+1\n            }\n            a = nFactor+1\n      \
    \  }\n        nPrime", "        val hexaNumberList = num.split(\"(?<=\\\\d)(?=[A-F])\"\
    ).map(_.toInt)\n        var count = 1\n        var primes = mutable.Set[Long]()\n\
    \        hexaNumberList.foreach{x => primes += x }\n        var primeCheck = primes.toList\n\
    \        primes.clear()\n        var hexaCheck = hexaNumberList\n        var remainder\
    \ = 0\n        while (primeCheck.length > 0){\n            primeCheck = primeCheck.filter(_%primeCheck.head\
    \ == 0)\n            hexaCheck = hexaCheck.filter(_%hexaCheck.head == 0)\n   \
    \         count += 1\n        }\n        remainder = hexaCheck.sum % hexaCheck.length\n\
    \        if (remainder == 0) {\n            count\n        } else {\n        \
    \    count\n        }", "        val hexNum = num.toUpperCase // \"1077E\", \"\
    ABED1A33\", \"123456789ABCDEF0\"\n        var count : Long = 0\n        hexNum.map(c\
    \ => if (c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F')\
    \ count += 1\n        else count += 0)\n        return count", "       val digits\
    \ = (num match {\n            case \"\" => Seq()\n            case x => x.toString.toList\n\
    \        })\n       val primes = (digits collect {\n            case x if x.isPrime\
    \ => x\n        })\n       primes.distinct.size", "      val counts = mutable.Map.empty[String,\
    \ Long]\n      val digits = num.toCharArray.takeRight(6)\n      val digitMap =\
    \ digitToInt(digits)\n      digits foreach { digit =>\n        val prime = digitToPrime(digit)\n\
    \        counts.get(prime.toString) match {\n          case Some(count) => count\
    \ += digitMap.get(digit)\n          case None =>\n            counts += digit\
    \ -> digitMap.get(digit)\n        }\n      }\n      counts.values.sum", "    \
    \    // TODO: Implement this method.\n        // You should use String and Char\
    \ primitives to do so.\n        ", "        def factorize(v : Int) : List[Int]\
    \ = if (v < 2) {\n            List[Int](v)\n        } else {\n            v ::\
    \ factorize(v / 2)\n        }\n        val n = num.toLong\n        val hexa =\
    \ n.toString.toUpperCase \n        val primes = factorize(hexa.length.toInt)\n\
    \        primes.foldLeft((1l,0l)) { case ((l,cnt),(p,m)) =>\n            if (p%2\
    \ != 0 && primes.contains(p)) {\n                val c = primes.indexOf(p)\n \
    \               if (c < primes.length - 1) {\n                    (l + cnt,c)\n\
    \                } else {\n                    (l + cnt,primes.indexOf(p)+2)\n\
    \                }\n            } else {\n                (l,cnt)\n          \
    \  }\n        }", "        val keys = num.split(\"\").toList\n        var count\
    \ : Long = 0\n        for (key <- keys) {\n            val keyStr = key.toInt\n\
    \            for (d <- keyStr) {\n                if (checkPrime(d, keyStr)) {\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \        count", "       val hexDigitsCount = num.length.toLong\n       val countMap\
    \ = Map[String, Long]()\n       var count = 0L\n       for (i <- 0 until hexDigitsCount)\
    \ {\n           if (num(i).isDigit()) {\n             count += (10L * hexDigitsCount\
    \ - i).toLong\n             val key = num(i).toString\n             val countValue\
    \ = countMap(key)\n             if (countValue > 0) {\n                countValue\
    \ -= 1\n             }\n             countMap(key) = countValue\n            \
    \ }\n           }\n       for (key <- countMap) {\n          count += 1L\n   \
    \    }\n       count", "        def hexDigit(hex : String) : String = {\n    \
    \        val res = hex.charAt(0).toUpperCase + hex.substring(1).replaceAll(\"\\\
    \\W\", \"\").toLowerCase\n            if(res.length != hex.length) throw new IllegalArgumentException(\"\
    Cannot process invalid hexadecimal number: \" + hex)\n            else res\n \
    \       }\n        def checkPrime(n : Long) : Boolean = {\n            var isPrime\
    \ = false\n            for((i <- 1 to n / 2) if(!isPrime && (n % i == 0))) {\n\
    \                isPrime = true\n            }\n            isPrime\n        }\n\
    \        def isPrime(n : Long) : Boolean = {\n            var isPrime = false\n\
    \            for((i <- 1 to n / 2) if(!isPrime && (n % i == 0))) {\n         \
    \       isPrime = true\n            }\n            isPrime\n        }\n      \
    \  val numStr = hexDigit(num)\n        val numArray = numStr.chars.toList.toArray\n\
    \        val isPrime = numArray.length == numStr.length && checkPrime(Integer.parseInt(numArray.toString))\n\
    \        if(numStr.length == 1 || isPrime) 1l else 2l", "        val nums = num.split(\"\
    \").toList\n        val res = new mutable.HashMap[Int, Int]()\n        for (i<-\
    \ 0 until nums.length) {\n            if (res.contains(nums(i)) {\n          \
    \      res.update(nums(i), res.get(nums(i)) + 1)\n            } else {\n     \
    \           res.update(nums(i), 1)\n            }\n        }\n        val res2\
    \ = res.filter(_._2 > 1).map { case (k, v) => (k, v / 2) }\n        res2.map {\
    \ case (k, v) => (k, v * 2) }.reduce(_ + _)", '        // write your code here',
  "        var numOfDigits = 0\n        var key = 1 // 1 = 2\n        for (x <- num)\
    \ {\n            if (x != ('A' | 'B' | 'C' | 'D' | 'E' | 'F')) {\n           \
    \     numOfDigits += x.toInt % 2\n            }\n            key = key * 3\n \
    \       }\n        if (numOfDigits > 0)\n            return key.asInstanceOf[Long]\n\
    \        else\n            return 0", "        var n = 0\n        var m = 1\n\
    \        var k = 0\n        val primes = Set(2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val digits\
    \ = num.toString.toCharArray.map(_.toInt)\n        val n = digits.length\n   \
    \     digits.foreach { i =>\n            val l = digits(i) * m\n            k\
    \ += primes.contains(l)\n            m += 1\n        }\n        (1L / k).toLong",
  "        val numLength = num.length\n        if (numLength == 0)\n            return\
    \ 0\n        val firstDigit = num take(1) + num.drop(1).take(1).toUpperCase +\
    \ num.drop(1).drop(2).toUpperCase + num.drop(1).drop(3).toUpperCase + num.drop(1).drop(4).toUpperCase\
    \ + num.drop(1).drop(5).toUpperCase + num.drop(1).drop(6).toUpperCase + num.drop(1).drop(7).toUpperCase\
    \ + num.drop(1).drop(8).toUpperCase + num.drop(1).drop(9).toUpperCase\n      \
    \  val primes = primes\n        val key = primes.find(num take (2).toUpperCase\
    \ == firstDigit + num.drop(2).toUpperCase + num.drop(2).toUpperCase + num.drop(3).toUpperCase\
    \ + num.drop(4).toUpperCase + num.drop(5).toUpperCase + num.drop(6).toUpperCase\
    \ + num.drop(7).toUpperCase + num.drop(8).toUpperCase + num.drop(9).toUpperCase)\n\
    \        if (key == None)\n            return 0\n        key.get.toLong", "  \
    \      var numList : List[Long] = num.toCharArray.toList.map(_.toLong)\n     \
    \   var tempNum : int = 2\n        var primeList : List[Long] = List(2, 3, 5)\n\
    \        var hexaList : List[Int] = List(2, 3, 5)\n        var count : Int = 0\n\
    \        var currentNum : int = 2\n        \n        while(numList.length > 0)\
    \ {\n            currentNum = numList.head\n            numList.remove(0)\n  \
    \          hexaList.lastOption.getOrElse(1)\n            if(!hexaList.contains(currentNum))\
    \ {\n                if(currentNum !% 2 == 0 && currentNum !% 3 == 0 && currentNum\
    \ !% 5 == 0) {\n                    hexaList += currentNum\n                 \
    \   count += hexaList.lastOption.getOrElse(1)\n                    hexaList.remove(hexaList.lastOption)\n\
    \                    \n                    if(hexaList == primeList) {\n     \
    \                   primeList += currentNum\n                        count +=\
    \ hexaList.lastOption.getOrElse(1)\n                        hexaList.remove(hexaList.lastOption)\n\
    \                    }\n                }\n            }\n        }\n        count",
  "        // A prime number (or prime) is a natural number greater than 1 that \n\
    \        // is not a product of two smaller natural numbers. \n        // A natural\
    \ number is a natural number greater than 1, whose \n        // highest value\
    \ is less than 10 and who's least significant digit \n        // is 1.\n     \
    \   val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19)\n\n        //\
    \ A prime number is prime, if it has no divisors other than itself.\n        //\
    \ For example (2) and (3) are prime, 3 is only a divisor of 2, so \n        //\
    \ prime(3) returns true. \n        def isPrime(number : Int) : Boolean = {\n \
    \           val prime = primes.find(_ == number)\n            prime != None\n\
    \        }\n\n        // Return count of prime numbers from 0 to 16\n        def\
    \ countPrimes(startIndex : Int) : Int = {\n            val count = startIndex\n\
    \            val primes = mutable.ArrayBuffer(2, 3, 5, 7, 11, 13, 17, 19)\n  \
    \          var index : Int = startIndex\n            while (primes.nonEmpty &&\
    \ count < 16) {\n                val prime = primes.find(_ == index)\n       \
    \         if (prime != None) {\n                    primes.remove(prime)\n   \
    \                 count += 1\n                }\n                index += 1\n\
    \            }\n            count\n        }\n\n        // Return count of divisors\n\
    \        def countDivisors(startIndex : Int) : Int = {\n            val count\
    \ = startIndex\n            val divisors = mutable.ArrayBuffer(2, 3, 5, 7, 11,\
    \ 13, 17, 19)\n            var index : Int = startIndex\n            var count\
    \ : Int = 0\n            while (divisors.nonEmpty && count < 16) {\n         \
    \       val divisor = divisors.find(_ % index == 0)\n                if (divisor\
    \ != None) {\n                    divisors.remove(divisor)\n                 \
    \   count += 1\n                }\n                index += 1\n            }\n\
    \            count\n        }\n\n        // Return the product of the hexadecimal\
    \ digits\n        def hexProduct(x:Int):Int = {\n            x match {\n     \
    \           case x if x % 10 == 0  => x\n                case x if x % 10 == 1\
    \ => hexProduct(x / 10) * 10 + x%10\n                case x if x % 10 == 2 =>\
    \ hexProduct(x / 10) * 10 + x%10\n                case x if x % 10 == 3 => hexProduct(x\
    \ / 10) * 10 + x%10\n                case x if x % 10 == 4 => hexProduct(x / 10)\
    \ * 10 + x%10\n                case x if x % 10 == 5 => hexProduct(x / 10) * 10\
    \ + x%10\n                case x if x % 10 == 6 => hexProduct(x / 10) * 10 + x%10\n",
  '        // Complete the function below', "        val digits = num.toCharArray.filter(x\
    \ => x >= '0' && x <= '9').toList\n        val bases = List('2', '3', '5', '7',\
    \ 'B', 'D')\n        val primes = bases.map(x => digits.length).filter(x => digits(x)\
    \ <= 3)\n        val toAdd = primes.length + 2\n        val total = (primes zip\
    \ digits).filter { case (p,c) => p*c <= toAdd }.count\n        total.toLong",
  "        // Use a List to store the numbers of 2 to the power of each hexadecimal\
    \ digit\n        val numbers = mutable.ListBuffer.empty[Long]\n        for (i\
    \ <- 0 until num.length) {\n            numbers += 2L.toLong * Integer.parseInt(num(i).toChar,\
    \ 16)\n        }\n\n        // Iterate through the numbers list and determine\
    \ if they are prime\n        var count = 0L\n        var isPrime = true\n    \
    \    for (i = 3L until num.length) { \n            if (numbers(i) == 0) {\n  \
    \              count += 1L\n                isPrime = true\n            }\n  \
    \          else {\n                count += 1L\n                isPrime = false\n\
    \                if (isPrime) {\n                    for ((j <- 3L to i); j <-\
    \ 3L to i) {\n                        if (numbers(j) > 0) {\n                \
    \            isPrime = false\n                            break\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n        count ", "        val arr = num.map(_.toUpperCase).toArray\n \
    \       val arr = arr.filterNot(arr(_) == \"0\")\n        val arr = arr.filterNot(arr(_)\
    \ == \"A\")\n        val arr = arr.filterNot(arr(_) == \"B\")\n        val arr\
    \ = arr.filterNot(arr(_) == \"C\")\n        val arr = arr.filterNot(arr(_) ==\
    \ \"D\")\n        val arr = arr.filterNot(arr(_) == \"E\")\n        val arr =\
    \ arr.filterNot(arr(_) == \"F\")\n        val arr = arr.map(_.toInt)\n       \
    \ val nums = arr.toList\n        val n = nums.foldLeft(2l) { (a, v) => v == a\
    \ ? a : v * a }\n        val hexNum = n.toString.reverse\n        hexNum.foldLeft(2l)\
    \ { (a, b) => b == a ? b : a * b }", "        val len = num.length()\n       \
    \ val hex = num.toList.reverse.dropWhile(_ != '0')\n        val count = hex.count(\
    \ _ isPrime)\n        ((len * 2) + count).toLong", "        var result : Long\
    \ = 0\n        num.toCharArray.foreach {\n            c => {\n               \
    \ if (c.toUpper == \"A\" || c.toUpper == \"B\"){\n                    result +=\
    \ 2\n                }\n                else if (c.toUpper == \"C\" || c.toUpper\
    \ == \"D\"){\n                    result += 3\n                }\n           \
    \     else if (c.toUpper == \"E\" || c.toUpper == \"F\"){\n                  \
    \  result += 5\n                }\n                else {\n                  \
    \  result += c.toInt % 10\n                }\n            }\n        }\n     \
    \   result", "        val hexDigits: Array[String] = num.toLowerCase ++ \"ABCDEF\"\
    .toLowerCase ++ \"0\".toLowerCase \n        val hexChar: Char = 'A'\n        val\
    \ hexKeys: mutable.Set[Long] = mutable.Set()\n        val n = 0\n        val prime:\
    \ Long = 1\n        while (n < hexDigits.length) {\n            val currentDigit\
    \ = hexDigits(n)\n            val remainder = hexDigits(n) rem hexChar.toLong\n\
    \            val isPrime: Boolean = (prime <= hexDigits.length \n            \
    \    && hexDigits(n).equalsIgnoreCase(hexDigits(n+1)))\n            if (!isPrime)\
    \ {\n                hexKeys += (currentDigit * prime)\n                prime++\n\
    \            }\n            n++\n        }\n        if (hexKeys.size > 1) {\n\
    \            hexKeys.size\n        } else {\n            return 0\n        }",
  "        // (1) The first six digits are the binary representation of the number.\n\
    \        // (2) The last two digits are the last two bits.\n        // The first\
    \ six digits are represented as binary number, and each \n        // of the last\
    \ two digits is represented as the sum of two powers of \n        // two.\n  \
    \      // The binary number 10 is represented as 10 (=decimal 10).\n        //\
    \ The binary representation for 10 is 10 (=decimal 10).\n        // So, for 10,\
    \ the last two bits is 10 (=decimal 10).\n        // Then, the sum of two powers\
    \ of two equals to 10 (=decimal 10).\n        // Thus, the last two digits is\
    \ 10.\n        // If any number is prime, the last two digits will be a power\
    \ of two,\n        // and all numbers with last two digits equal to a power of\
    \ two will \n        // be primes.\n        // For each number in the range, if\
    \ the last two digits is a power of \n        // two, the number is prime. Otherwise,\
    \ it is not.\n        val binaryRep = num.substring(0, 6).map(_.toInt).map(Integer.pow(_)).toList\n\
    \        val lastTwoBits = num.substring(6, num.length)\n        val sumTwoPowOfTwo\
    \ = Integer.parseInt(lastTwoBits.substring(0, lastTwoBits.length - 2))\n     \
    \   val lastTwoDigitsPowOfTwo = Integer.parseInt(lastTwoBits.substring(lastTwoBits.length\
    \ - 2, lastTwoBits.length))\n        if (binaryRep.forall(_.isPowerOfTwo)) {\n\
    \            if (lastTwoDigitsPowOfTwo.isPowerOfTwo) {\n                return\
    \ binaryRep.count(_ == lastTwoDigitsPowOfTwo)\n            } else {\n        \
    \        return 0\n            }\n        } else {\n            return 0\n   \
    \     }", "        val hexChars = \"0123456789ABCDEF\"\n        val hexCount =\
    \ num.length()\n        var numArray = Array.fill(hexCount)(0)\n        for (i\
    \ <- 0 until hexCount) {\n            val hexChar = hexChars(i)\n            val\
    \ hexCharVal = hexChar.charAt(i)\n            if (hexCharVal == 'A'){\n      \
    \          numArray(i) = 1\n            }\n            else if (hexCharVal ==\
    \ 'B'){\n                numArray(i) = 2\n            }\n            else if (hexCharVal\
    \ == 'C'){\n                numArray(i) = 3\n            }\n            else if\
    \ (hexCharVal == 'D'){\n                numArray(i) = 5\n            }\n     \
    \       else if (hexCharVal == 'E'){\n                numArray(i) = 7\n      \
    \      }\n            else if (hexCharVal == 'F'){\n                numArray(i)\
    \ = 11\n            }\n            else if (hexCharVal == '0'){\n            \
    \    numArray(i) = 13\n            }\n        }\n        var primes = 0\n    \
    \    var maxPrime = 0\n        var maxCount = 0\n        for (i <- 0 until hexCount)\
    \ {\n            val hexChar = hexChars(i)\n            val hexCharVal = hexChar.charAt(i)\n\
    \            if (hexCharVal == 'A'){\n                numArray(i) = 1\n      \
    \      }\n            else if (hexCharVal == 'B'){\n                numArray(i)\
    \ = 2\n            }\n            else if (hexCharVal == 'C'){\n             \
    \   numArray(i) = 3\n            }\n            else if (hexCharVal == 'D'){\n\
    \                numArray(i) = 5\n            }\n            else if (hexCharVal\
    \ == 'E'){\n                numArray(i) = 7\n            }\n            else if\
    \ (hexCharVal == 'F'){\n                numArray(i) = 11\n            }\n    \
    \        else if (hexCharVal == '0'){\n                numArray(i) = 13\n    \
    \        }\n        }\n        var maxCountHex = maxCount * 16\n        val maxPrimeHex\
    \ = maxPrime * 16\n        for (i <- 0 until hexCount) {\n            val hexChar\
    \ = hexChars(i)\n            val hexCharVal = hexChar.charAt(i)\n            if\
    \ (numArray(i) == 2){\n                maxPrimeHex = i\n                maxCountHex\
    \ = 1\n            }\n            else if (numArray(i) == 3){\n              \
    \  maxPrimeHex = i\n                maxCountHex = 2\n            }\n         \
    \   else if (numArray(i) == 5){\n                maxPrimeHex = i\n           \
    \     maxCountHex = 4\n            }\n            else if (numArray(i) == 7){\n\
    \                maxPrimeHex = i\n                ", "        if (num.length ==\
    \ 0)\n            return 0\n        val hex = num.toUpperCase().toCharArray\n\
    \        val digits = hex.map(c => Integer.parseInt(c.toString, 16))\n       \
    \ val primes = mutable.HashSet[Long]()\n        digits: foreach { i =>\n     \
    \       if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0)\n                primes +=\
    \ i\n        }\n        primes.toList.length", "        val count = hexaNumToInt(num)\n\
    \        val hexaNum = hexaNumToStr(num)\n        val numMap = hexaNum.map(hexToChar)\n\
    \        numMap.count(_ == 'A')", '        // Your code here', "        val nums\
    \ = num.toUpperCase match {\n            case \"\" => \"\"\n            case str\
    \ => str.split(\"(?<=\\\\G(.{4}))\")\n        }\n        val ans = nums.length\n\
    \        val primes = List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97)\n\
    \        primes.foreach { x =>\n            if (nums.contains(x)) {\n        \
    \        ans += 1\n            }\n        }\n        ans * (2l - 1)", "      \
    \  val res = num.toCharArray.filter(f => f >= '0' && f <= '9').toList.foldLeft(0){\
    \ (acc,x) =>\n            acc += x.toInt\n        }\n        val len = num.length\n\
    \        val firstChar = num(0)\n        val lastChar = num(len-1)\n        if(firstChar\
    \ >= '0' && firstChar <= '9' && lastChar >= '0' && lastChar <= '9') res\n    \
    \    else 0", "        val input = num\n        var count = 0\n        for (i<-0\
    \ to input.length-1) {\n            if (input(i) != \"A\" && input(i) != \"B\"\
    \ && input(i) != \"C\" && input(i) != \"D\" && input(i) != \"E\" && input(i) !=\
    \ \"F\") {\n                if (input(i).isDigit) {\n                    if (input.substring(i\
    \ + 1, i+2).drop(1).forall(i => i.toInt == 2).toBoolean) {\n                 \
    \       count = count + 1\n                    }\n                }\n        \
    \    }\n        }\n        count.toLong", "        val hexDigits = \"0123456789ABCDEF\"\
    \n        var count = 2L\n        var pos = 0\n        // The prime numbers are\
    \ those numbers whose first \n        // hexadecimal digit is a prime number.\n\
    \        var primes = mutable.Set[Long]()\n        // Count the number of hexadecimal\
    \ digits in the \n        // input string.\n        while(pos < num.length) {\n\
    \            // Count and skip to the next hexadecimal digit.\n            count\
    \ += hexDigits.count(hexDigits(pos))\n            pos = pos + 1\n        }\n \
    \       // Find all prime numbers up to count (inclusively) \n        // and add\
    \ them to the primes set.\n        while(count <= hexDigits.length()) {\n    \
    \        val hexDigit = hexDigits(count).toInt\n            if (hexDigit <= hexDigits.length())\
    \ {\n                val factor = hexDigits(hexDigit).toInt / hexDigits.length()\n\
    \                primes.add(hexDigits(count + factor).toLong)\n            }\n\
    \            count += 1\n        }\n        // Find the first prime number which\
    \ has only \n        // \"count\" digits.\n        val firstPrime = primes.find(_\
    \ <= count)\n        // Count primes up until the first prime number.\n      \
    \  var nextPrime = 1L\n        while(nextPrime <= firstPrime) {\n            val\
    \ prime = primes.find(_ <= nextPrime)\n            if (prime == null) {\n    \
    \            nextPrime += 1L\n            } else {\n                count = 1L\n\
    \                break\n            }\n        }\n        // The last prime number\
    \ is a prime number which \n        // has only \"count\" digits.\n        val\
    \ lastPrime = primes.find(_ > count)\n        // The number to be returned.\n\
    \        return count + (lastPrime - firstPrime) + 1L", "        // your code\
    \ here\n        val hexStr =  num.toCharArray.map(x => x.toInt).toList\n     \
    \   val n = hexStr.length\n        val hex = hexStr.filter(x => x%2 == 0).toList\n\
    \        val hex1 = hex.filter(x => x != 0)\n        val hex2 = hex1.filter(x\
    \ => x != 1)\n        val hex3 = hex2.filter(x => x != 2)\n        val hex4 =\
    \ hex3.filter(x => x != 3)\n        val hex5 = hex4.filter(x => x != 4)\n    \
    \    val hex6 = hex5.filter(x => x != 5)\n        val hex7 = hex6.filter(x =>\
    \ x != 6)\n        val hex8 = hex7.filter(x => x != 7)\n        val hex9 = hex8.filter(x\
    \ => x != 8)\n        val hex10 = hex9.filter(x => x != 9)\n        val hex11\
    \ = hex10.filter(x => x != 10)\n        val hex13 = hex11.filter(x => x != 11)\n\
    \        val hex17 = hex13.filter(x => x != 13)\n        val hexB = hex17.filter(x\
    \ => x != 17)\n        val hexD = hexB.filter(x => x != 11)\n        val hexF\
    \ = hexD.filter(x => x != 13)\n        val hexDigits = hexB\n        val hexDigits2\
    \ = hexD\n        val hexDigits3 = hexF\n        val hexDigits4 = hex3\n     \
    \   val hexDigits5 = hex4\n        val hexDigits6 = hex5\n        val hexDigits7\
    \ = hex6\n        val hexDigits8 = hex7\n        val hexDigits9 = hex8\n     \
    \   val hexDigits10 = hex9\n        val hexDigits11 = hex10\n        val hexDigits13\
    \ = hex11\n        val hexDigits17 = hex13\n        val hexDigitsB = hex17\n \
    \       val hexDigitsD = hexB\n        val hexDigitsF = hexD\n        // hexDigits\
    \ = hexB, hexD, hexF\n        // hexDigits = hexB, hexD, hexF, hex3, hex4, hex5,\
    \ hex6, hex7, hex8, hex9, hex10, hex11, hex13, hex17\n        // hexDigits = hexB,\
    \ hexD, hexF, hex3, hex4, hex5, hex6, hex7, hex8, hex9, hex10, hex11, hex13, hex17,\
    \ hexB, hexD\n        // hexDigits = hexB, hexD, hexF, hex3, hex4, hex5, hex6,\
    \ hex7, hex8, hex9, hex10, hex11, ", "        val primeDigit = num.chars().map(_\
    \ % 16).filter(_ >= 2).count() + 1\n        num.chars().map(_ % 16).filter(_ >=\
    \ 2).count() + 1", "        var count=0\n        var key=0\n        for(i <- num.toCharArray)\
    \ {\n            if((i=='A')||(i=='B')||(i=='C')||(i=='D')||(i=='E')||(i=='F'))\
    \ {\n                count+=1\n                if(count>3) key+=count\n      \
    \          count=0\n            }\n            else {\n                count-=1\n\
    \            }\n        }\n        key", "        var hex = num.toCharArray.toList\n\
    \        hex.foreach(c => c match {\n            case 'A' => hex.update(0, \"\
    B\")\n            case 'B' => hex.update(0, \"D\")\n            case 'C' => hex.update(0,\
    \ \"F\")\n            case 'D' => hex.update(0, \"E\")\n            case 'E' =>\
    \ hex.update(0, \"A\")\n            case 'F' => hex.update(0, \"9\")\n       \
    \     case '0' => hex.update(0, '0')\n            case _ =>\n        })\n    \
    \    hex.filter(c => c.toLong > 0).count() - hex.filter(c => c.toLong < 0).count() ",
  "       var count = 1\n       for (ch <- num.toCharArray) {\n           val num\
    \ = Integer.parseInt(ch, 16)\n           count += primeFactors(num)\n       }\n\
    \       count", "        def powersOfX() : List[Int] = {\n            val powersOfX\
    \ = List[Int](1,1)\n            for(x <- powersOfX) yield {\n                val\
    \ newX = x*x\n                if(num.charAt(newX) != '0') powersOfX += newX\n\
    \            }\n        }\n        val digits = num.toCharArray.filter(_.isDigit).toList\n\
    \        val powers = powersOfX().reverse\n        val primes = List(2, 3, 5,\
    \ 7, 11, 13, 17)\n        val result = 0\n        for(x <- powers) result += (primes.indexOf(digits(x))\
    \ * primes.indexOf(digits(x - 1)))\n        result", "        val n = num.length\n\
    \        val primes = scala.collection.mutable.Set[Long]()\n        var power\
    \ = 0\n        for {\n            x <- 0 until n\n            pow = (n+x-1)*16\n\
    \            if pow > n\n        } pow = (n+x-1)*16\n        pow *= 0\n      \
    \  for (i<- 0 until n-1) {\n            primes.add((pow/16).toInt)\n         \
    \   pow = pow % 16\n        }\n        primes.toList.foldLeft(0l){_ + _}", " \
    \       val num = num.toUpperCase // use toUpperCase to ensure 'A' < 'b'\n   \
    \     val key = num.zipWithIndex.filter(_._1 == 2).map(_._2)\n        key.filter(_\
    \ > 0).foldLeft(1l) { (x, z) =>\n            if (z > 0) {\n                val\
    \ z2 = z\n                ((z2 * z2) + (z2 + 1) * x) % z2\n            } else\
    \ x\n        }", "        val l = num.length\n        val k = l*l/2\n        var\
    \ count = 0\n        for(i<-0 to k-2){\n            val hex = num.charAt(i)\n\
    \            val deci = hex.asInstanceOf[Int]\n            val rem = deci % 16\n\
    \            val hexa = rem + 16\n            val deci2 = hexa.asInstanceOf[Int]\n\
    \            val rem2 = deci2 % 16\n            val hexa2 = rem2 + 16\n      \
    \      if(hexa != 0 && hexa2 != 0){\n                if(hex.asInstanceOf[Int]\
    \ == hexa){\n                    count+=1\n                }\n               \
    \ if(hex.asInstanceOf[Int] == hexa2){\n                    count+=1\n        \
    \        }\n            }\n        }\n        count", "        var len = 0\n \
    \       val numbers = num.map(x=>x.toInt)\n        for (i <- 0 until num.length)\
    \ {\n            len += i * numbers.apply(i)\n        }\n        val digits =\
    \ len.toString.toInt\n        val n = digits / 16\n        val res = digits -\
    \ (n * 16)\n        return res ", "        val n = num.toCharArray.toList\n  \
    \      var nums = 0\n        var i = 0\n        while(i < n.length) {\n      \
    \      if(n(i) == 'A') {\n                nums += 1\n            }\n         \
    \   if(n(i) == 'B') {\n                nums += 1\n            }\n            if(n(i)\
    \ == 'C') {\n                nums += 1\n            }\n            if(n(i) ==\
    \ 'D') {\n                nums += 1\n            }\n            if(n(i) == 'E')\
    \ {\n                nums += 1\n            }\n            if(n(i) == 'F') {\n\
    \                nums += 1\n            }\n            i += 1\n        }\n   \
    \     nums", "        val primeList = getPrimes(num.length)\n        var count\
    \ = 0\n        for (i <- 0 until primeList.length) {\n            var hexNum =\
    \ num.toInt + primeList(i)\n            var hexKey = 0\n            while (hexNum\
    \ > 0) {\n                hexKey += hexNum % 16L\n                hexNum /= 16L\n\
    \            }\n            if (hexKey % 2L == 1L)\n                count += primeList(i)\
    \ + 1\n        }\n        count // return number of hexadecimal digits that are\
    \ primes", "        // Your code here\n        val arr = num.split(\"\").toList\n\
    \        var count = 0\n        for(i <- arr.indices) {\n            val current\
    \ = arr(i)\n            val len = arr.length\n            for(j <- 0 until len)\
    \ {\n                val j = arr(j)\n                val n = current * j\n   \
    \             if(n % 10 != 0) {\n                    continue\n              \
    \  }\n                if(((n * 6 + 1) > 7) && ((n * 6 + 1) < 11)) {\n        \
    \            count = count + 1\n                }\n            }\n        }\n\
    \        count.toLong", "        val primes = mutable.Set[Long]()\n        val\
    \ count   = mutable.Map[Long, Long]()\n        for (i <- num.toCharArray) {\n\
    \            val h = scala.math.BigInt(i.toInt, 16).asInstanceOf[scala.Int]\n\
    \            if (primes.contains(h)) count(h+1)\n            else primes.add(h)\n\
    \        }\n        count.toSeq.sortBy(_._2).reverse.headOption.map(_._1)", " \
    \       val primes = mutable.HashSet[Long]()\n        for (nthDigit <- num.toCharArray.takeWhile(_\
    \ != '0')) {\n            val hex = Integer.parseInt(nthDigit.toString)\n    \
    \        primes += (hex to hex)\n        }\n        if (primes.contains(\"2\"\
    ) || primes.contains(\"3\") || primes.contains(\"5\") || primes.contains(\"7\"\
    )) {\n            primes.toSet.size + 1\n        }\n        else {\n         \
    \   primes.toSet.size + 0\n        }", "        val str = num.toString.toUpperCase\n\
    \        val hex = str.map(x => x.toInt)\n        var count = 0\n        var prime\
    \ = 0\n        for (i <- hex) {\n            prime += i\n            if (prime\
    \ > 1) prime = 0\n            count += 1\n        }\n        count", "       \
    \ val len = num.length\n        val list = num.toList.map(c => c.toLong)\n   \
    \     val firstNum = list.head\n        if (list.length == 1) {\n            firstNum\n\
    \        } else {\n            var nextNum = list.tail.head\n            var count\
    \ = 0\n            val primes = new mutable.ListBuffer[Long]()\n            //\
    \ Find the primes less than 2 * firstNum\n            while (nextNum % 2 == 0)\
    \ {\n                primes += 2\n                nextNum = (nextNum / 2).toLong\n\
    \            }\n\n            // Find the primes less than 3 * firstNum\n    \
    \        while (nextNum % 3 == 0) {\n                primes += 3\n           \
    \     nextNum = (nextNum / 3).toLong\n            }\n\n            // Find the\
    \ primes less than 5 * firstNum\n            while (nextNum % 5 == 0) {\n    \
    \            primes += 5\n                nextNum = (nextNum / 5).toLong\n   \
    \         }\n\n            // Find the primes less than 7 * firstNum\n       \
    \     while (nextNum % 7 == 0) {\n                primes += 7\n              \
    \  nextNum = (nextNum / 7).toLong\n            }\n\n            // Find the primes\
    \ less than 9 * firstNum\n            while (nextNum % 9 == 0) {\n           \
    \     primes += 9\n                nextNum = (nextNum / 9).toLong\n          \
    \  }\n\n            // Find the primes less than 11 * firstNum\n            while\
    \ (nextNum % 11 == 0) {\n                primes += 11\n                nextNum\
    \ = (nextNum / 11).toLong\n            }\n\n            // Find the primes less\
    \ than 13 * firstNum\n            while (nextNum % 13 == 0) {\n              \
    \  primes += 13\n                nextNum = (nextNum / 13).toLong\n           \
    \ }\n\n            // Find the primes less than 17 * firstNum\n            while\
    \ (nextNum % 17 == 0) {\n                primes += 17\n                nextNum\
    \ = (nextNum / 17).toLong\n            }\n\n            // Find the primes less\
    \ than 19 * firstNum\n            while (nextNum % 19 == 0) {\n              \
    \  primes += 19\n                nextNum = (nextNum / 19).toLong\n           \
    \ }\n\n            // Find the primes less than 20 * firstNum\n            while\
    \ (nextNum % 20 == 0) {\n                primes += 20\n                nextNum\
    \ = (nextNum / 20).toLong\n            }\n\n            for (i <- primes) {\n\
    \                if (list.exists(c => c % i == 0)) {\n                    count\
    \ += 1\n                }\n            }\n\n            firstNum * count\n   \
    \     }", "        val hexArray = num.toCharArray.map { ch =>\n            val\
    \ b = (ch - 'A') + (ch - '0')\n            if( b > 9 ) \n                throw\
    \ new IllegalArgumentException(s\"The character $ch is not in the range 'A' to\
    \ 'F'.\")\n            if( b < 10 ) \n                b + 4\n            else\
    \ \n                b\n        }\n        var count = 0\n        hexArray.foreach\
    \ { e =>\n            val isPrime = 2 until hexArray.length filter (e == _)\n\
    \            count += isPrime.size filter (e % _ == 0)\n        }\n        count",
  "        def hex(n: Int) : Int = n match {\n            case  0 => 0\n         \
    \   case  1 => 0\n            case  2 => 0\n            case  3 => 0\n       \
    \     case  4 => 1\n            case  5 => 2\n            case  6 => 2\n     \
    \       case  7 => 3\n            case  8 => 3\n            case  9 => 3\n   \
    \         case 10 => 4\n            case 11 => 5\n            case 12 => 5\n \
    \           case 13 => 6\n            case 14 => 6\n            case 15 => 7\n\
    \            case 16 => 7\n            case 17 => 7\n            case 18 => 8\n\
    \            case 19 => 8\n            case 20 => 8\n            case 21 => 9\n\
    \            case 22 => 9\n            case 23 => 9\n            case 24 => 10\n\
    \            case 25 => 10\n            case 26 => 10\n            case 27 =>\
    \ 11\n            case 28 => 11\n            case 29 => 11\n            case 30\
    \ => 12\n            case 31 => 12\n            case 32 => 12\n            case\
    \ 33 => 13\n            case 34 => 13\n            case 35 => 13\n           \
    \ case 36 => 14\n            case 37 => 14\n            case 38 => 14\n      \
    \      case 39 => 15\n            case 40 => 15\n            case 41 => 15\n \
    \           case 42 => 15\n            case 43 => 16\n            case 44 => 16\n\
    \            case 45 => 16\n            case 46 => 16\n            case 47 =>\
    \ 17\n            case 48 => 17\n            case 49 => 17\n            case 50\
    \ => 17\n            case 51 => 18\n            case 52 => 18\n            case\
    \ 53 => 18\n            case 54 => 18\n            case 55 => 18\n           \
    \ case 56 => 19\n            case 57 => 19\n            case 58 => 19\n      \
    \      case 59 => 19\n            case 60 => 20\n            case 61 => 20\n \
    \           case 62 => 20\n            case 63 => 20\n            case 64 => 21\n\
    \            case 65 => 21\n            case 66 => 21\n            case 67 =>\
    \ 21\n            case 68 => 21\n            case 69 => 21\n            case 70\
    \ => 21\n            case 71 => 21\n            case 72 => 22\n            case\
    \ 73 => 22\n            case 74 => 22\n            case 75 => 22\n           \
    \ case 76 => 22\n            case 77 => 23\n            case 78 => 23\n      \
    \      case 79 => 23\n            case 80 => 23\n            case 81 => 23\n \
    \           case 82 => 23\n            case 83 => 24\n            case 84 => 24\n\
    \            case 85 => 24\n            case 86 => 24\n            case 87 =>\
    \ 25\n            case 88 => 25\n            case ", "        require(num.matches(\"\
    .*[A-Z0-9]{2}$\"), \"Input String must contain only hexadecimal characters\")\n\
    \        require(num.length == num.length, \"Input String must be hexadecimal\
    \ only\")\n        var primeNum = 1l\n        var primeNumSet = Set[Long]()\n\
    \        var hexNum = num.charAt(0).toInt\n        hexNum match {\n          \
    \  case hexNum if hexNum <= 9 => (hexNum + hexNum).asInstanceOf[Int].toLong\n\
    \            case hexNum if hexNum <= 15 => (hexNum + hexNum - 10).asInstanceOf[Int].toLong\n\
    \            case _ =>\n        }\n\n        for (d <- 0 until hexNum + 1) {\n\
    \            val divisor = (hexNum + d - hexNum).asInstanceOf[Int]\n         \
    \   if (divisor <= 1 || (hexNum - divisor).asInstanceOf[Int] <= 1) {\n       \
    \         if (primeNumSet.add(primeNum)) {\n                    primeNum += 1l\n\
    \                }\n            } else {\n                primeNum += 1l\n   \
    \             primeNumSet = primeNumSet - Set(divisor)\n            }\n      \
    \  }\n\n        primeNumSet", "        var res = 1\n        val map = new mutable.HashMap[Int,\
    \ Int]\n        val digits = num.substring(1).split('').toList\n        for (i\
    \ <- 0 until digits.length) {\n            map.put(digits(i).toInt, 0)\n     \
    \   }\n        for (i <- 2 until digits.length - 1) {\n            var p = 1\n\
    \            for (j <- 0 until digits.length - i - 1) {\n                p *=\
    \ digits(j)\n            }\n            if (map.get(i) == 0) {\n             \
    \   res += 1\n                map.put(i, 1)\n            } else if (map.get(i)\
    \ > p) {\n                res += map.get(i) - p\n                map.put(i, p)\n\
    \            } else {\n                res += map.get(i)\n                map.put(i,\
    \ 0)\n            }\n        }\n        res", "        val n = num.toInt\n   \
    \     val sum: Long = 0\n        // Convert n to an array of digits, i.e. hex[n]\
    \ to hex[\"A\", \"B\", \"C\", ... \"F\"]\n        val hex = n.toString.toCharArray.map(x\
    \ => x.toChar).mkString\n        // Use sliding window to calculate sum of digits\
    \ \n        hex.sliding(2, 2).map { \n            case Array(a,b) => a + b \n\
    \            case _ => 0 \n        }.foreach(sum +=_)\n        math.pow(10, sum.toInt)",
  "        // TODO: add your code here\n        // write your code here\n        var\
    \ count = 0\n        for (i <- 0 to num.length-1) {\n            if (num(i) ==\
    \ num(i).toLowerCase()) {\n                count += 2\n            } else {\n\
    \                count += 1\n            }\n        }\n        count * hexToInt(num)\
    \ // return hexToInt(num) if num is hexadecimal string", "        var count =\
    \ 0L\n        var primes = scala.collection.mutable.Set[Long]()\n        var primesArray\
    \ = scala.collection.mutable.Array[Long]()\n        // You will need to check\
    \ all hexadecimal digits one by one:\n        for ( i <- 0 until num.length )\
    \ {\n            // We use the next hexadecimal digit as the symbol\n        \
    \    var symbol = num(i).toInt\n            val upperCase = symbol.toString.toUpper\n\
    \            if ( upperCase == \"A\" || upperCase == \"B\" || upperCase == \"\
    C\" || upperCase == \"D\" || upperCase == \"E\" || upperCase == \"F\" ) symbol.toInt\n\
    \            else {\n                // Check if it's one of the digits that belongs\
    \ to primes\n                var checkHexDigit = true\n                for ( j\
    \ <- 0 until primesArray.length ) {\n                    if ( symbol == primesArray(j)\
    \ ) {\n                        checkHexDigit = false\n                       \
    \ break\n                    }\n                }\n                if ( checkHexDigit\
    \ ) primes += symbol\n            }\n        }\n        // Now you have a set\
    \ of primes\n        for ( prime <- primes ) {\n            count += prime\n \
    \       }\n        count", '        // Your code here', "        val a = num.toUpperCase\
    \ + \"ABCDEF\"\n        // We are going to create a mutable list of digits from\
    \ the given string.\n        val digits = mutable.Buffer.empty[Char]\n       \
    \ // The final result will be a sum of the primes that we find.\n        var sum\
    \ = 0\n        // We iterate over the string and add the digits from the buffer\
    \ to the mutable list.\n        for ((i, x) <- num.lengths.map(x => a index (x\
    \ minBound)).zip(num)) {\n            digits ++= x.toCharArray\n        }\n  \
    \      // Iterate over the digits list and count the primes that are contained\
    \ in the list.\n        digits foreach { c =>\n            if (a.contains (c))\
    \ sum += a.indexOf(c).toLong\n        }\n        sum", "        val hexa = num.split(\"\
    \\\\\")\n        var count = 0\n        for(i <- 0 to hexa.size - 1){\n      \
    \      if(hexa(i).matches(\"\"\"\\d.\"\"\")){\n                count = count +\
    \ 1\n            }\n        }\n        hexa.size", '        // your solution',
  "        val nList = num.toUpperCase match {\n            case \"A\"..\"F\" => \n\
    \                val n1 = hex2Int(num.substring(0, 1)) \n                val n2\
    \ = hex2Int(num.substring(1, 2))\n                n1 :: n2\n            case \"\
    0\"..\"9\" => \n                val n1 = hex2Int(num.substring(0, 1)) \n     \
    \           val n2 = hex2Int(num.substring(1, 2))\n                n1 :: n2\n\
    \            case _ => 0\n        }\n        nList.count(x => x == 2)", "    \
    \    val num = num.toLowerCase\n        var digits = num.count(\"a\").map(_.toInt)\n\
    \        val p = Array(2, 3, 5, 7, 11, 13, 17, 19)\n        val i = p.toStream\n\
    \        val primes = Seq(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\
    \ 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\
    \ 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\
    \ 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\
    \ 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\
    \ 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\
    \ 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\
    \ 947, 953, 967, 971, 977, 983, 991, 997)\n        primes foreach(x => digits.filterNot(_==x).foreach(y\
    \ => digits.remove(y)))\n        p.zipWithIndex.filter(_._2 % p.sum == 0).flatMap(x\
    \ => (digits.filter(_==x._).map(x._), x._2))", "        val hex = num.split(\"\
    \\\\W\")\n        // We create our set of primes (set of natural numbers less\
    \ than or equal \n        // to the number that we want to count).\n        val\
    \ numbers = hex.map(n => n.toLong)\n        // We are going to count the number\
    \ of primes we have.\n        var count = 0\n        // While there are still\
    \ primes left, we are going to divide them and \n        // count the number we\
    \ find there.\n        while (numbers.length > 0) {\n            // Since we know\
    \ that we are dividing by primes lesser than or \n            // equal to the\
    \ current number, we do not divide them by primes\n            // greater than\
    \ the current number.\n            val num = numbers.dropWhile(n => n < num).head\n\
    \            // We found a prime, we are going to count it.\n            count\
    \ += 1\n            // And we are going to remove it from the set of numbers to\
    \ divide with.\n            numbers = numbers.tail\n        }\n        // We are\
    \ returning our count.\n        count", "        var numCount : Long = 0\n   \
    \     num.toCharArray.foreach(c => {\n            val val = (c.toLong + 96).toHexString\n\
    \            if (val.toInt==1 && val.toHexString==\"20\") {\n                numCount\
    \ += 1\n            }\n        })\n        return numCount", "        val numArray\
    \ = num.split(\"\").toList\n        val numChar = numArray(0)\n        var i =\
    \ 0\n        var digits = \"\"\n        var prime = 0\n        for (hexDigit <-\
    \ numArray) {\n            digits = digits + hexDigit + \" \"\n            if\
    \ (hexDigit == \"A\") {\n                prime = 1\n            }\n          \
    \  else if (hexDigit == \"B\") {\n                prime = 2\n            }\n \
    \           else if (hexDigit == \"C\") {\n                prime = 3\n       \
    \     }\n            else if (hexDigit == \"D\") {\n                prime = 5\n\
    \            }\n            else if (hexDigit == \"E\") {\n                prime\
    \ = 7\n            }\n            else if (hexDigit == \"F\") {\n            \
    \    prime = 11\n            }\n            else {\n                prime = 2\n\
    \            }\n        }\n        var numDigits = digits.length\n        var\
    \ primes = 0\n        val primeFactors = primeFactorsOfNumberOfDigits(numDigits)\n\
    \        var hexNumChars = numChar.toString.length\n        var hexNumPrimes =\
    \ numDigits.length\n        val hexNumPrimeFactors = primeFactorsOfNumberOfDigits(hexNumPrimes)\n\
    \        for (hexPrime <- hexNumPrimeFactors) {\n            if (hexPrime == numDigits)\
    \ {\n                primes = primes + 1\n            }\n        }\n        val\
    \ hexNumPrimeFactorsArray = primeFactorsOfNumberOfDigits(primes)\n        val\
    \ hexNumPrimes = hexNumPrimeFactorsArray(0)\n        val hexNumPrimesArray = primeFactorsOfNumberOfDigits(hexNumPrimes)\n\
    \        val hexNumPrimesSum = hexNumPrimes.toInt\n        val hexNumPrimesSumArray\
    \ = primeFactorsOfNumberOfDigits(hexNumPrimesSum)\n        for (hexPrime <- hexNumPrimesArray)\
    \ {\n            if (hexPrime == primes) {\n                primes = primes +\
    \ 1\n            }\n        }\n        var hexNumPrimesSumPrimes = 0\n       \
    \ val hexNumPrimesSumPrimesArray = primeFactorsOfNumberOfDigits(hexNumPrimesSumPrimes)\n\
    \        for (hexPrime <- hexNumPrimesSumArray) {\n            if (hexPrime ==\
    \ primes) {\n                primes = primes + 1\n            }\n        }\n \
    \       primes = primes - 1\n        hexNumPrimes = hexNumPrimes - 1\n       \
    \ for (hexPrime <- hexNumPrimeFactorsArray) {\n            if (hexPrime == primes)\
    \ {\n                primes = primes + 1\n            }\n        }\n        hexNum",
  "        val numStr : String = num.toUpperCase\n        val numStrArray = numStr.toCharArray\n\
    \        val n = numStr.length\n        var count = 0\n        for(i <- 0 until\
    \ n) {\n            val c = numStrArray(i)\n            if(c == 'A') {\n     \
    \           count += 1\n            }\n            else if(c == 'B') {\n     \
    \           count += 3\n            }\n            else if(c == 'C') {\n     \
    \           count += 5\n            }\n            else if(c == 'D') {\n     \
    \           count += 7\n            }\n            else if(c == 'E') {\n     \
    \           count += 11\n            }\n            else if(c == 'F') {\n    \
    \            count += 13\n            }\n            else {\n                count\
    \ += c\n            }\n        }\n        count", "        // Your code here\n\
    \        val nums = num.toCharArray.filterNot(s => ('A'<= s ) && (s <= 'F'))\n\
    \        val numsOfDigits : Array[Int] = nums.map(x => x + '0' - 'A'.toInt)\n\
    \        numsOfDigits.length", "        if (num.length == 0) {\n            return\
    \ 0\n        }\n        var n = 0\n        for (v <- num.toCharArray) {\n    \
    \        n += v.toLong match {\n                case a if a%2==0 => (0L)\n   \
    \             case b if (b%2==0) => (1L)\n                case c if (c%2==0) =>\
    \ (2L)\n                case d if (d%2==0) => (3L)\n                case e if\
    \ (e%2==0) => (4L)\n                case f if (f%2==0) => (5L)\n             \
    \   case g if (g%2==0) => (6L)\n                case h if (h%2==0) => (7L)\n \
    \               case i if (i%2==0) => (8L)\n                case j if (j%2==0)\
    \ => (9L)\n                case k if (k%2==0) => (10L)\n                case l\
    \ if (l%2==0) => (11L)\n                case m if (m%2==0) => (12L)\n        \
    \        case n if (n%2==0) => (13L)\n                case o if (o%2==0) => (14L)\n\
    \                case p if (p%2==0) => (15L)\n                case q if (q%2==0)\
    \ => (16L)\n                case r if (r%2==0) => (17L)\n                case\
    \ s if (s%2==0) => (18L)\n                case t if (t%2==0) => (19L)\n      \
    \          case u if (u%2==0) => (20L)\n                case v if (v%2==0) =>\
    \ (21L)\n                case w if (w%2==0) => (22L)\n                case x if\
    \ (x%2==0) => (23L)\n                case y if (y%2==0) => (24L)\n           \
    \     case z if (z%2==0) => (25L)\n                case A if (A%2==0) => (26L)\n\
    \                case B if (B%2==0) => (27L)\n                case C if (C%2==0)\
    \ => (28L)\n                case D if (D%2==0) => (29L)\n                case\
    \ E if (E%2==0) => (30L)\n                case F if (F%2==0) => (31L)\n      \
    \          case x => 0\n            }\n        }\n        n", "        def isPrime(num\
    \ : Long, i : Int) : Boolean = {\n            if (i <= 0) false\n            val\
    \ upper = num.toString.toUpperCase\n            val upperDigit = upper.toCharArray()(i)\n\
    \            val upper2 = upper.toCharArray()(i-1)\n            if (upperDigit\
    \ == upper2) true\n            else (upperDigit == ('0' | upper2))\n        }\n\
    \n        def primeDigits(num : Long, i : Int) : Long = {\n            if (num\
    \ == 0) 0\n            else {\n                val upper = num.toString.toUpperCase\n\
    \                val upperDigit = upper.toCharArray()(i)\n                if (isPrime(num,\
    \ i)) primeDigits(num.toString.toLong, i) + 1\n                else primeDigits(num.toString.toLong,\
    \ i) * 10 + upperDigit\n            }\n        }\n        val total = 0\n    \
    \    val numStr = toDigits(num)\n        numStr.foreach { digit =>\n         \
    \   total += primeDigits(numStr.length, digit)\n        }\n        total.toLong",
  "        def hexToDec(str: String) : Long = {\n            val arr = str.split('')\n\
    \            var sum = 0\n            arr.map { x =>\n                val y =\
    \ x.toInt\n                if (y == 17) 17\n                else if (y == 10)\
    \ 10\n                else sum + y\n            }\n        }\n        def getHexDigits(str:\
    \ String): List[String] = {\n            val arr = str.split('')\n           \
    \ val res = new ArrayBuffer[String]()\n            arr.foreach { x =>\n      \
    \          val y = x.toInt\n                if (y != 17 && y != 10) res += x.toString\n\
    \            }\n            res.toList\n        }\n        val digits = getHexDigits(num)\n\
    \        val hexToDec_arr = digits.map(hexToDec).toList\n        val res = hexToDec_arr.count(_\
    \ == 2)\n        (1l -> res)", "        // TODO: Write your code here\n      \
    \  val hexNum = num.toCharArray\n        val hexKey = new mutable.HashMap[Int,\
    \ Int]()\n        var count = 0\n        for(i <- 0 until hexNum.length) {\n \
    \           val hexVal = hexNum(i)\n            hexKey.getOrElseUpdate(hexVal.toInt,\
    \ 0)\n            count += 1\n        }\n        count", "        val input =\
    \ num.toLowerCase // make sure input will be lowercase\n        val isHex = input.matches(\"\
    \"\"^[0-9A-F]*$\"\"\")\n        val numChars = input.length\n        // find first\
    \ and last hex character index\n        val firstHex = input.indexOf('A')\n  \
    \      val lastHex = input.length - 1\n        // the prime numbers are between\
    \ first and last hex chars\n        val primes = findPrimes(firstHex, lastHex).asInstanceOf[List[Long]]\n\
    \        // a dictionary to count frequency of each prime char\n        val freq\
    \ = input.sliding(2).map(ch => ch to 1).groupBy(_._1).map(x => x._1 to x._2.size)\n\
    \        // prime chars which has less than two frequencies will be excluded\n\
    \        val countFreq = freq.filter(_._2 < 2)\n        val hexFreq = countFreq.filter(_._2\
    \ > 0)\n        // add the prime numbers whose frequencies are more than 2\n \
    \       val addPrimes = primes.filterNot(x => hexFreq.contains(x))\n        val\
    \ hexKey = hexFreq.map(x => hexFreq.size - hexFreq.count(_ == x)).sum\n      \
    \  // if the input has only one hexadecimal digit, return it as 1\n        if\
    \ (numChars == 1) {\n            hexKey += hexKey((\"1\")) // if the input is\
    \ only one hexadecimal digit, add it\n        }\n        // add prime chars whose\
    \ frequencies are more than 2\n        addPrimes", "        var numDigit = num.length\n\
    \        var hexNum: Long = 0L\n        var hexDig: Char = 'A'\n\n        for\
    \ (i <- 0 until numDigit) {\n            if (num(i) == 'A') { hexDig = 'A'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'B') { hexDig = 'B'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'C') { hexDig = 'C'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'D') { hexDig = 'D'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'E') { hexDig = 'E'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'F') { hexDig = 'F'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == hexDig) {\n               \
    \ hexNum = hexNum * 16L\n                hexDig = 'A'\n            }\n       \
    \     else {\n                hexNum = hexNum * 16L\n            }\n        }\n\
    \        return hexNum", "        var sum = 0\n        for(i <- num.toCharArray)\
    \ sum = sum + (i.toLong % 2 == 0 ? i : i ^ 1)\n        sum", "        // Write\
    \ your code here\n        val list = new mutable.ListBuffer[Long]()\n        for\
    \ (i <- 0 to num.length-1){\n            if (num(i).toInt == 0 || num(i).toInt\
    \ == 1){\n                list += num(i).toLong\n            } else {\n      \
    \          val a = num(i).toInt\n                val b = num(i+1).toInt\n    \
    \            val p = a*10 + b\n                \n                for (x <- 2 until\
    \ p){\n                    if (p%x == 0) list += x*10\n                }\n   \
    \         }\n        }\n        list.size", "        val numAsList = num.toList\n\
    \        val primes = mutable.Set[Long]()\n        def countPrimes(num : Int)\
    \ : Long = {\n            if (num == 0)\n                0\n            else if\
    \ (num % 2 == 0)\n                countPrimes(num/2) + 1\n            else if\
    \ (num % 2 == 1)\n                countPrimes(num/2) + 1\n            else\n \
    \               primes.add(num)\n                countPrimes(num/2)\n        }\n\
    \        val primesLen = primes.size\n        numAsList.foreach(countPrimes(_))\n\
    \        primes.size - primesLen + 1", "        val hex = num.replaceAll(\"[^A-F0-9]\"\
    ,\"\")\n        if(hex.size == 0) 1\n        else {\n            val hexDigits\
    \ = hex.split(\"\").map(x => x.toInt)\n            // hexDigits now contains a\
    \ list of all digits in hexadecimal num\n            val primes = hexDigits.filter(x\
    \ => x >= 0 && x <= 16).map(x => (x / 16) rem 2).toSet\n            // primes\
    \ now contains all prime numbers in hexDigits\n            val maxPrime = hexDigits.filter(x\
    \ => x >= 0 && x <= 16).map(x => (x / 16) rem 2).reduce((x, y) => x < y ? x :\
    \ y)\n            // maxPrime now contains the largest prime number in hexDigits\n\
    \            val hexToDigits = hexDigits - primes - maxPrime\n            // hexToDigits\
    \ now contains the prime numbers in hexadecimal digits in order\n            val\
    \ key = 0\n            for(hexToDigit <- hexToDigits)\n                key +=\
    \ hexToDigit * primes.find(hexToDigit == _).map(x => hexToDigit * x).reduce((x,\
    \ y) => x < y ? x : y)\n            key\n        }", "        var count = 0L\n\
    \        for (xx <- num.toCharArray) {\n            val x = math.pow(16, num.length\
    \ - xx)\n            if (x % num.toInt == 0) count++\n        }\n        count",
  "        if (num.length != 16) {\n            throw new Exception(\"Bad input, must\
    \ have the length of 16\")\n        }\n\n        val digits = new mutable.HashSet[Long]()\n\
    \        val primes = new mutable.HashSet[Long]()\n\n        val hex = num.toCharArray.map(_.toLong).map(x\
    \ => x % 16).toList\n        val hexString = hex.toList\n        // Convert each\
    \ char to its decimal representation from 0-9\n        val hexDec = hexString.map(x\
    \ => x + 48).reverse\n        val hexDecString = hexDec.toList\n        // Convert\
    \ each hexadecimal number to a String\n        val hexString = hexDecString.reverse\n\
    \        // Add the digits\n        hexString.foreach(x => digits.add(x))\n  \
    \      // Add the primes\n        for (x1 <- 0 to hexString.length - 2) {\n  \
    \          val x3 = hexString(2 * x1 + 1)\n            if ((hexString(2 * x1 +\
    \ 2) == x3) && (x1 != hexString.length - 2)) {\n                primes.add(x1)\n\
    \            }\n        }\n        // Add the prime numbers less than the hexadecimal\
    \ number.\n        // For example if the hexadecimal number is \"AB\", then prime\
    \ numbers are \n        // 3, 5, 7, 11, 13\n        val primeStrings = primes.toList\n\
    \        var prime = 0\n        val isPrime = hexString.foreach(x => if (prime\
    \ == 0) primeStrings.foreach(y => prime += if (x % y == 0) 1 else 0))\n\n    \
    \    return digits.size + prime", "        val digits = hexToInt(num)\n      \
    \  val length = digits.length\n        // count the number of prime numbers\n\
    \        val primes = \n            for (i <- 0 until length if isPrime(digits(i)))\n\
    \            yield digits(i)\n        primes.sum", "        var count = 0\n  \
    \      var digit = num.charAt(0)\n        for (i <- 0 until num.length-1) {\n\
    \            digit = num.charAt(i)\n            if (digit >= '0' && digit <= '9')\
    \ {\n                val digitValue = digit.toLong\n                if (digitValue\
    \ < 10) {\n                    if (digitValue % 2 == 0 && digitValue % 3 == 0\
    \ && digitValue % 5 == 0) {\n                        count = count + 1\n     \
    \               }\n                }\n            }\n        }\n        count\
    \ + 1", "        val hex = num.toLong\n        var sum = 0\n        // Count the\
    \ number of digits less than 16\n        var sumOfDigits = hex.filter(_ < 16)\n\
    \        while(sumOfDigits.nonEmpty) {\n            val digit = sumOfDigits.head\n\
    \            // If the number is not a product of only 2 and 3, add it to the\
    \ sum\n            if(!isPrime(digit) || !isPrime(digit * digit))\n          \
    \      sum += digit\n            sumOfDigits = sumOfDigits.tail\n        }\n \
    \       sum.toLong", "        val numList = num.grouped(4).toList\n        var\
    \ result = 0\n        for (i <- 0 until numList.length) {\n            result\
    \ += isPrime(numList(i))\n        }\n        result", "        var count = 3\n\
    \        var hexDigit = 0\n        var isPrime = true\n        var isUpper = false\n\
    \        var isDig = false\n        var isAlpha = false\n        for (char <-\
    \ num.toCharArray) {\n            hexDigit += Character.toInt(char)\n        }\n\
    \        isUpper = hexDigit > 0xFF\n        isDig = (hexDigit >= 0) && (hexDigit\
    \ <= 9)\n        isAlpha = (hexDigit >= 0) && (hexDigit <= 0xF)\n        var isDigit\
    \ = (hexDigit >= 0) && (hexDigit <= 9)\n        if (isDigit && !isAlpha) {\n \
    \           count = hexDigit + 1\n        }\n        if (isUpper && !isDig) {\n\
    \            count = hexDigit + 1\n        }\n        if (isAlpha && !isDig) {\n\
    \            count = hexDigit + 1\n        }\n        if (!isDig && !isUpper &&\
    \ !isAlpha) {\n            count = hexDigit + 1\n        }\n        val digitList\
    \ = scala.collection.mutable.ListBuffer[Int]()\n        if (hexDigit >= 0xA) {\n\
    \            digitList += 0xA\n        }\n        if (hexDigit >= 0xB) {\n   \
    \         digitList += 0xB\n        }\n        if (hexDigit >= 0xC) {\n      \
    \      digitList += 0xC\n        }\n        if (hexDigit >= 0xD) {\n         \
    \   digitList += 0xD\n        }\n        if (hexDigit >= 0xE) {\n            digitList\
    \ += 0xE\n        }\n        if (hexDigit >= 0xF) {\n            digitList +=\
    \ 0xF\n        }\n        digitList.foreach { hexDigit =>\n            if (isPrime)\
    \ {\n                isPrime = hexDigit % 2 != 0\n                if (isPrime)\
    \ {\n                    val digit = hexDigit / 2\n                    if (digit\
    \ == 0 || digit == 1) {\n                        isPrime = true\n            \
    \        } else {\n                        isPrime = false\n                 \
    \   }\n                }\n            }\n        }\n        return count", " \
    \       val key = new scala.collection.mutable.MutableList[Long]()\n        var\
    \ index = 0\n        num match {\n            case hexKey if hexKey.isEmpty =>\
    \ 0\n            case hexKey => hexKey.length match {\n                case hexKey.length\
    \ if hexKey.forall(_.isDigit) => hexKey.count(digitToLong)\n                case\
    \ hexKey.length if hexKey.forall(_.isLetter) => hexKey.count(letterToLong)\n \
    \               case hexKey.length if hexKey.forall(_.isUpper) => hexKey.count(upperToLong)\n\
    \                case _ => throw new IllegalArgumentException(s\"${hexKey} is\
    \ not hexadecimal number\")\n            }\n        }\n        return key.reverse",
  "        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        0", " \
    \       val hexArray = num.toCharArray.flatMap { x =>\n            if(x.toInt\
    \ > 9 || x.toInt < 0)\n                throw new IllegalArgumentException(\n \
    \                   \"The argument is not hexadecimal number\")\n            else\
    \ if(x.toInt == 0)\n                throw new IllegalArgumentException(\n    \
    \                \"The argument is not hexadecimal number\")\n            else\
    \ if(x.toInt == 1)\n                throw new IllegalArgumentException(\n    \
    \                \"The argument is not hexadecimal number\")\n            else\
    \ x\n        }\n        val primes = List(2,3,5,7,11,13,17,19,23,29,31,37,41,\n\
    \                          43,47,53,59,61,67,71,73,79,83,89,97)\n        val primesCount\
    \ = primes.toList.length\n        val hexCount = hexArray.toList.length\n    \
    \    val hexPrimesCount = hexArray.toList.count(x => primes.contains(x))\n   \
    \     val hexPrimes = hexArray.toList.filter { x =>\n            primes.contains(x)\n\
    \        }\n        val hexPrimesCount = hexArray.toList.count(x => primes.contains(x))\n\
    \        val hexPrimes = hexArray.toList.filter { x =>\n            primes.contains(x)\n\
    \        }\n        val result = primes.foldLeft(0)(_+hexPrimesCount)\n      \
    \  result", "        val hexKey = num.toInt\n        val primes = primes(hexKey)\n\
    \        val lenOfHexKey = hexKey.length\n        // Find the first prime number.\n\
    \        var isPrime = true\n        for (prime <- primes) {\n            if (lenOfHexKey\
    \ == prime.length)\n                isPrime = false\n            if (hexKey.length\
    \ == prime.length) {\n                if (hexKey.charAt(lenOfHexKey) == 'A') {\n\
    \                    if (hexKey.charAt(lenOfHexKey+2) == 'A')\n              \
    \          hexKey.charAt(lenOfHexKey+2) = 'B'\n                    else\n    \
    \                    hexKey.charAt(lenOfHexKey+2) = 'A'\n                }\n \
    \               if (hexKey.charAt(lenOfHexKey) == 'C')\n                    hexKey.charAt(lenOfHexKey)\
    \ = 'D'\n            }\n        }\n        if (primes.isEmpty)\n            0\n\
    \        else\n            primes.find(_ == lenOfHexKey).get.asInstanceOf[Long]",
  "        val num = num.toUpperCase // make sure input string is uppercase\n    \
    \    def hexDigit(hex : Int) : Int = hex % 16 // get the hexadecimal digit\n \
    \       val primes = mutable.ArrayBuffer( // store prime numbers in an ArrayBuffer\
    \ \n            2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l,\
    \ 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l,\
    \ 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l,\
    \ 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l,\
    \ 263l, 269l, 271l, 277l, 281l, 283l, 293l, 297l, 301l, 307l, 311l, 313l, 317l,\
    \ 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l,\
    \ 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l,\
    \ 487l, 491l, 499l, 503l, 509l, 521l, 523l, 529l, 531l, 537l, 543l, 549l, 551l,\
    \ 557l, 563l, 569l, 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l,\
    \ 631l, 637l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l,\
    \ 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 767l, 773l, 787l, 797l,\
    \ 803l, 809l, 811l, 817l, 821l, 823l, 827l, 829l, 831l, 833l, 839l, 843l, 849l,\
    \ 851l, 857l, 863l, 871l, 877l, 883l, 889l, 893l, 901l, 907l, 911l, 919l, 931l,\
    \ 937l, 941l, 947l, 953l, 967l, 971l, 977l, 983", "        val s = num.trim\n\
    \        if(s.length == 0) return 1\n        val numsHash = s.toInt.map(i => i\
    \ + ((i % 2) + 1)).toMap\n        val maxPrime = 2L\n        def primesHash(p\
    \ : Long) : Long = {\n            val res = if (numsHash.get(p) > 0) {\n     \
    \           val res = primesHash(p / 2)\n                numsHash.remove(p)\n\
    \                res\n            } else {\n                0\n            }\n\
    \            res + p\n        }\n        primesHash(maxPrime)", "        def isPrime(n:\
    \ BigInt) : Boolean = {\n            // Check whether n is prime\n           \
    \ if (n < 2) false\n            else {\n                var isPrime = true\n \
    \               for (d <- 2 to ceil(sqrt(n).toInt) by 2) {\n                 \
    \   if (n % d == 0) {\n                        isPrime = false\n             \
    \           break\n                    }\n                }\n                if\
    \ (isPrime) true\n                else false\n            }\n        }\n     \
    \   val numList = num.split(\"\").toList\n        // The prime digits of numList\
    \ is 2, 3, 5, 7, 11, 13, 17...\n        // So, numList.filter(_ % 2 == 0) is for\
    \ 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n        // numList.filter(_ %\
    \ 2 == 1) is for 1, 3, 7, 11, B (=decimal 13), D (=decimal 17).\n        // numList.filter(_\
    \ % 2 == 0) | numList.filter(_ % 2 == 1) is for 2, 5, 7, 11, B (=decimal 11),\
    \ D (=decimal 13).\n        val primes = numList.filter(isPrime)\n        // primes\
    \ is List(2, 3, 5, 7, 11, 13, 17)\n        // primes.toSet is Set(2, 3, 5, 7,\
    \ 11)\n        // primes.toSet - primes.toSet is Set(2)\n        // primes.toSet.mkString.toInt\
    \ == primes.toSet.map(_.toString.toInt).sum\n        // primes.toSet.map(_ * 2\
    \ + 1).sum == primes.toSet.map(_ * 2 + 1).sum\n        val primesSet = primes.toSet\n\
    \        primesSet.size * primesSet.toSet.size - primesSet.count(_ > 2)", "  \
    \      // Count how many times the key repeats\n        val count = num.length.grouped(2).filter{\
    \ _1.length == _2.length }.size\n        val primes : Long = num.length rem 2\
    \ match{\n            case 0 => 1\n            case n => 2 to (n - 1) map (n =>\
    \ (num.length / n).toLong).sum\n        }\n        (count * primes).toLong", " \
    \       // Your code here.\n        // Return Long.MaxValue if num is empty.\n\
    \        val nums = num.split(\"(?<=\\\\G.{3})\").toList.map(_.toInt)\n      \
    \  var count = 0\n        nums.foreach{n =>\n            var flag = false\n  \
    \          for(i <- 2 until n by 2){\n                if(n % i == 0) {\n     \
    \               flag = true\n                    break\n                }\n  \
    \          }\n            if(!flag)\n                count = count + 1\n     \
    \   }\n        \n        count match {\n            case 6  => 2L\n          \
    \  case 5  => 3L\n            case 4  => 5L\n            case 3  => 7L\n     \
    \       case 2  => 11L\n            case 1  => 13L\n            case 0  => 0L\n\
    \            case _ => count\n        }", "        val hexToBin = num foldLeft(Map[Char,\
    \ String]()) { case (map, ch) => (map + (ch -> (ch.toInt % 2))) }\n        val\
    \ binToHex = hexToBin.values.map(x => (x.toHexString)).mkString(\"0\")\n     \
    \   binToHex.length", "        // Create a set that stores all prime numbers and\
    \ a variable that counts the number of digits in num \n        var primes = Set.empty[Long]\n\
    \        var count = 0\n        for(c <- num) {\n            if(primes.contains(c.toLong))\
    \ {\n                count += 1\n            } else {\n                primes\
    \ += c.toLong\n            }\n        }\n        primes.size", "        val numList\
    \ = num.split(\"\").filter(_.isDigit).map(_.toLong).toList\n        val lastDigit\
    \ = numList.last\n        if(lastDigit < 10 || lastDigit > 15) {\n           \
    \ return 0\n        }\n        val lastDigitValue = lastDigit - 1\n        val\
    \ numList2 = numList.dropRight(1)\n        val numList3 = numList2.filter( x =>\
    \ (numList2.length - x) > 1)\n        val numList4 = numList3.filter( x => x.toString.toLong\
    \ % lastDigitValue == 0)\n        numList4.size", "        val bits = num.toCharArray.map(_.toInt)\n\
    \        val num2bits = num :: bits\n        val primes: mutable.Set[Long] = {\n\
    \            var isPrime = false\n            var numToCheck = num2bits\n    \
    \        var i = 3\n            while(i <= bits.length) {\n                val\
    \ test = numToCheck % i\n                if (test == 0) isPrime = true\n     \
    \           else \n                    if(isPrime == true) primes += test\n  \
    \                  numToCheck = (numToCheck / i).toLong\n                i +=\
    \ 1\n            }\n            primes\n        }\n        val ret = (primes.length\
    \ / 8).toLong\n        ret", "        var n = 0\n        var digitCount = 0\n\
    \        var primeCount = 0\n        val len = num.length\n        for (i <- 0\
    \ until len) {\n            val key = num(i)\n            digitCount += 1\n  \
    \          if ((key.toChar() == 'A' || key.toChar() == 'B' || key.toChar() ==\
    \ 'C' || key.toChar() == 'D' || key.toChar() == 'E' || key.toChar() == 'F') &&\
    \ key.toUpperCase != 'A' && key.toUpperCase != 'B' && key.toUpperCase != 'C' &&\
    \ key.toUpperCase != 'D' && key.toUpperCase != 'E' && key.toUpperCase != 'F')\
    \ {\n                val keyUpper = key.toUpperCase // uppercase letter\n    \
    \            val keyLower = key.toLowerCase // lowercase letter\n            \
    \    var isPrime = true\n                if (keyUpper >= 'A' && keyUpper <= 'F')\
    \ {\n                    if (keyUpper >= '0' && keyUpper <= '9') {\n         \
    \               primeCount += 0 // not prime if less than a digit\n          \
    \              primeCount += 1 // prime if more than a digit (including 0)\n \
    \                   } else {\n                        primeCount += 0 // not prime\
    \ if less than a digit\n                        primeCount += 0 // prime if more\
    \ than a digit (including 0)\n                    }\n                } else {\n\
    \                    if (keyUpper >= '0' && keyUpper <= '9') {\n             \
    \           primeCount += 0 // not prime if less than a digit\n              \
    \          primeCount += 0 // prime if more than a digit (including 0)\n     \
    \               } else {\n                        primeCount += 0 // not prime\
    \ if less than a digit\n                        primeCount += 0 // prime if more\
    \ than a digit (including 0)\n                    }\n                }\n     \
    \       }\n            if (keyLower == 'A' || keyLower == 'B' || keyLower == 'C'\
    \ || keyLower == 'D' || keyLower == 'E' || keyLower == 'F') {\n              \
    \  primeCount += 0 // not prime if less than a digit\n                primeCount\
    \ += 0 // prime if more than a digit (including 0)\n            }\n        }\n\
    \        n = digitCount\n        n = n + primeCount\n        n", "        val\
    \ numOfDigits = num.length\n        var n = 0\n        val primesSet = mutable.Set[Long]()\n\
    \        val hexDigits = \"ABCDEF\".toSet\n        hexDigits.foreach {\n     \
    \       c =>\n                val hexValue = num.toLong\n                n = hexValue\
    \ * java.lang.Long.parseInt(\"11\".toChar) + n\n                // If there is\
    \ a prime, add it to the set.\n                // If not, move to the next digit.\n\
    \                while(n / hexValue > 1) {\n                    primesSet += hexValue\n\
    \                    hexValue += 1\n                }\n        }\n        primesSet.count(_\
    \ > num)", "        var sum = 0\n        var i = num.length\n        var k = num.length\n\
    \        while (i >= 1){\n            var remainder = num.charAt(i-1) - 'A'\n\
    \            if (remainder >= 2) {\n                sum = sum + remainder\n  \
    \          }\n            i = i - 1\n            k = k - 1\n        }\n      \
    \  var remainder = num.charAt(0) - 'A'\n        if (remainder >= 2) {\n      \
    \      sum = sum + remainder\n        }\n        return sum", "        val hexList\
    \ = num.split(\"\\\\B\") //split by non hexa chars\n        val hexNums = hexList.map\
    \ { x => parseHex(x).toLong }.toList\n        hexNums.map(x => isPrime(x) ? x\
    \ : 1l).sum", "        if (num.length == 0 || num.head != 'A' && num.head != 'B'\
    \ && num.head != 'C'\n            && num.head != 'D' && num.head != 'E' && num.head\
    \ != 'F') {\n            return 0\n        }\n        var count = 0\n        var\
    \ lastDigit = 0\n        var index = 0\n        for (i <- num.indices) {\n   \
    \         if (num(i) > '9') {\n                if (lastDigit == 4) {\n       \
    \             lastDigit = 0\n                } else {\n                    lastDigit\
    \ += 1\n                }\n            }\n            if (num(i) <= '9') {\n \
    \               lastDigit += 1\n            }\n            if (lastDigit % 2 ==\
    \ 1) {\n                lastDigit += 2\n            }\n            if (lastDigit\
    \ > 9) {\n                lastDigit = 0\n            }\n            count += 1\n\
    \            if (lastDigit % 2 == 1) {\n                lastDigit += 2\n     \
    \       }\n            if (lastDigit > 9) {\n                lastDigit = 0\n \
    \           }\n            count += 1\n            if (lastDigit % 2 == 1) {\n\
    \                lastDigit += 2\n            }\n            if (lastDigit > 9)\
    \ {\n                lastDigit = 0\n            }\n            count += 1\n  \
    \          if (lastDigit % 2 == 1) {\n                lastDigit += 2\n       \
    \     }\n            if (lastDigit > 9) {\n                lastDigit = 0\n   \
    \         }\n            count += 1\n            if (lastDigit % 2 == 1) {\n \
    \               lastDigit += 2\n            }\n            if (lastDigit > 9)\
    \ {\n                lastDigit = 0\n            }\n            count += 1\n  \
    \      }\n        count", "        val hex = num.toCharArray.map(_.toInt)\n  \
    \      val res = mutable.ArrayBuffer.empty[Long]\n        val n = hex.length\n\
    \        val primes = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n   \
    \     val factors = mutable.ArrayBuffer.empty[Long]\n        \n        // Get\
    \ all prime numbers in one pass.\n        primes += 2\n        while (primes.nonEmpty\
    \ && primes.head <= n) {\n            while (hex(i).toLong !in primes) {\n   \
    \             factors += hex(i).toLong\n                i += 1\n            }\n\
    \            primes -= hex(i).toLong\n            i += 1\n        }\n        //\
    \ Get all factors in one pass.\n        while (factors.nonEmpty && factors.head\
    \ <= n) {\n            factors += hex(i).toLong\n            i += 1\n        }\n\
    \        // Get the hexadecimal digits that is primes.\n        var hexPrimes\
    \ = primes.filter(p => hex(p) > 0)\n        while (hexPrimes.nonEmpty && hexPrimes.head\
    \ <= n) {\n            hexPrimes -= hexPrimes.head\n            i += 1\n     \
    \   }\n        // The hexadecimal digits that is primes are now removed from hexPrimes.\n\
    \        \n        // Now hexPrimes is the set of prime numbers that are not factors\
    \ of the \n        // input. \n        // All the hex digits that are prime can\
    \ be divided by all the factors \n        // of input. So that all hex digits\
    \ that are prime in the input are \n        // divided equally by every hex digit\
    \ that is prime in the input.\n        // The hexadecimal digits that is not prime\
    \ can be divided by every hex \n        // digit that is prime in the input. So\
    \ all hex digits that are not \n        // prime in the input will be divided\
    \ equally by every hex digit that is \n        // prime in the input.\n      \
    \  val factorsSet = factors.toSet\n        // Now calculate the prime factors\
    \ of each hex digit.\n        hexPrimes.foreach { prime => \n            factorsSet.filter(_\
    \ % prime == 0).foreach(factors => factors += prime)\n        }\n        // Calculate\
    \ the total of prime factors for each hex digit.\n        // Add the primes and\
    \ factors into the result. \n        hexPrimes.zipWithIndex.filter(_._1 % 2 ==\
    \ 1).foreach { \n            case (prime, i) => res ++= prime :: factors.take(i)\n\
    \        }\n        res.sum", "        val hl = num.toLong\n        var count\
    \ = 0\n        for (h <- 0 until hl) count += (hl-h)%16 == 0L\n        count",
  "        val numList = num.split(\"\\\\s\")\n        val numList = numList.filter(_.isDigit)\n\
    \        var total = 0l\n        var digit = 0\n        for (i <- numList) {\n\
    \            total += i.toLong\n            if (i % 2 == 0) {\n              \
    \  digit += 1\n                if (digit >= 3) {\n                    return total\n\
    \                }\n            }\n            digit = 0\n        }\n        return\
    \ total", "        val count = new mutable.ListBuffer[Int]()\n        num match\
    \ {\n            case hexNum if hexNum.length==0 => 0\n            case hexNum\
    \ if hexNum.length==1 => 1\n            case hexNum if hexNum.length==2 => 2\n\
    \            case hexNum if hexNum.length==3 => 2\n            case hexNum if\
    \ hexNum.length==4 => 3\n            case hexNum if hexNum.length==5 => 3\n  \
    \          case hexNum if hexNum.length==6 => 4\n            case hexNum if hexNum.length==7\
    \ => 5\n            case hexNum if hexNum.length==8 => 5\n            case hexNum\
    \ if hexNum.length==9 => 6\n            case hexNum if hexNum.length==10 => 6\n\
    \            case hexNum if hexNum.length==11 => 7\n            case hexNum if\
    \ hexNum.length==12 => 7\n            case hexNum if hexNum.length==13 => 7\n\
    \            case hexNum if hexNum.length==14 => 8\n            case hexNum if\
    \ hexNum.length==15 => 8\n            case hexNum if hexNum.length==16 => 8\n\
    \            case hexNum if hexNum.length==17 => 9\n            case hexNum if\
    \ hexNum.length==18 => 9\n            case hexNum if hexNum.length==19 => 10\n\
    \            case hexNum if hexNum.length==20 => 10\n            case hexNum if\
    \ hexNum.length==21 => 11\n            case hexNum if hexNum.length==22 => 11\n\
    \            case hexNum if hexNum.length==23 => 11\n            case hexNum if\
    \ hexNum.length==24 => 12\n            case hexNum if hexNum.length==25 => 12\n\
    \            case hexNum if hexNum.length==26 => 12\n            case hexNum if\
    \ hexNum.length==27 => 13\n            case hexNum if hexNum.length==28 => 13\n\
    \            case hexNum if hexNum.length==29 => 13\n            case hexNum if\
    \ hexNum.length==30 => 14\n            case hexNum if hexNum.length==31 => 14\n\
    \            case hexNum if hexNum.length==32 => 14\n            case hexNum if\
    \ hexNum.length==33 => 15\n            case hexNum if hexNum.length==34 => 15\n\
    \            case hexNum if hexNum.length==35 => 15\n            case hexNum if\
    \ hexNum.length==36 => 16\n            case hexNum if hexNum.length==37 => 16\n\
    \            case hexNum if hexNum.length==38 => 16\n            case hexNum if\
    \ hexNum.length==39 => 16\n            case hexNum if hexNum.length==40 => 16",
  "        val length = num.length\n        if (length == 0)\n            return 0\n\
    \        val primes = num.filter(x => Character.isLetter(x) && x != \"A\" && x\
    \ != \"B\" && x != \"C\" && x != \"D\" && x != \"E\" && x != \"F\").map(x => BigInt(x.toUpperCase)).toSet\n\
    \        val sum = 0\n        for (i <- 2 until length) {\n            val num\
    \ = num.substring(i, i + 1)\n            val prime = primes.find(p => p.toString.toInt\
    \ == num.toString.toInt)\n            if (prime != null)\n                sum\
    \ += prime\n        }\n        sum", "        var result = 0L\n        for (i\
    \ <- num.substring(1, num.length).split(\"(?<=\\\\G..)\".r)) {\n            result\
    \ += hexDigits(i)\n        }\n        result", "        def hexDigit(digit: Int)\
    \ : Boolean = {\n            // digit > 9 => return false\n            if (digit\
    \ > 9) {\n                return false\n            }\n            // digit >\
    \ 5 => return false\n            if (digit > 5) {\n                return false\n\
    \            }\n            // digit > 3 => return false\n            if (digit\
    \ > 3) {\n                return false\n            }\n            // digit >\
    \ 1 => return false\n            if (digit > 1) {\n                return false\n\
    \            }\n            // digit > 0 => return true\n            return true\n\
    \        }\n        val arr = num.toCharArray.map(_.toInt)\n        val hexDigitArr\
    \ = arr.filterNot(hexDigit)\n        val hexDigitArr = hexDigitArr.toSeq\n   \
    \     val hexDigitArr = hexDigitArr.distinct\n        val hexDigitArr = hexDigitArr.takeWhile(hexDigit(_))\n\
    \        hexDigitArr.size", "        val lnum = num.toLong\n        val nums =\
    \ Array.ofDim[Char](num.length + 1)\n        \n        nums(0) = \"0\"\n     \
    \   \n        val p = lnum / 3\n        val q = lnum % 3\n        \n        nums(1)\
    \ = lnum match {\n            case 0 => \"0\"\n            case 1 => \"1\"\n \
    \           case 2 => \"2\"\n            case 3 => \"3\"\n            case 4 =>\
    \ \"4\"\n            case 5 => \"5\"\n            case 6 => \"6\"\n          \
    \  case 7 => \"7\"\n            case 8 => \"8\"\n            case 9 => \"9\"\n\
    \            case 10 => \"A\"\n            case 11 => \"B\"\n            case\
    \ 12 => \"C\"\n            case 13 => \"D\"\n            case 14 => \"E\"\n  \
    \          case 15 => \"F\"\n            case x => x.toChar\n        }\n     \
    \   \n        val i = Array.ofDim[Char](nums.length)\n        \n        var j\
    \ = 0\n        \n        // We go through the digits, each time checking if they\
    \ are prime or not\n        // until we reach a prime (we don't need to go through\
    \ the whole number).\n        // If it is a prime, we add it to the array nums\n\
    \        // If it is not a prime, we skip it\n        // We stop when the number\
    \ becomes larger than lnum (we stopped checking before\n        // reaching a\
    \ prime).\n        while(j < nums.length-1) {\n            \n            if((p\
    \ * q) % nums(j) == 0)\n                nums(j+1) = \"0\"\n            else\n\
    \                nums(j+1) = nums(j+1) match {\n                    case 0 =>\
    \ \"0\"\n                    case 1 => \"1\"\n                    case 2 => \"\
    2\"\n                    case 3 => \"3\"\n                    case 4 => \"4\"\n\
    \                    case 5 => \"5\"\n                    case 6 => \"6\"\n  \
    \                  case 7 => \"7\"\n                    case 8 => \"8\"\n    \
    \                case 9 => \"9\"\n                    case 10 => \"A\"\n     \
    \               case 11 => \"B\"\n                    case 12 => \"C\"\n     \
    \               case 13 => \"D\"\n                    case 14 => \"E\"\n     \
    \               case 15 => \"F\"\n                    case x => x.toChar\n   \
    \             }\n                \n            if((p * q) > lnum)\n          \
    \      break\n            \n            j+=1\n        }\n        \n        val\
    \ n = \"0\"\n        var nk = -1\n        var kk = 0\n        \n        // We\
    \ start counting from 2 because 0 is the first hexadecimal digit\n        // which\
    \ is not prime\n        for(kk <- 2 until nums.length-1) {\n            \n   \
    \         if(nums(kk) > lnum)\n                break\n            \n         \
    \   val k : Int = 0\n            \n            // We start at 0 because 0 is not\
    \ a prime and we do not need to check it \n            // with any of the ", " \
    \       val primes = scala.collection.mutable.ArrayBuffer(2,3,5,7)\n        val\
    \ nonPrimes = scala.collection.mutable.ArrayBuffer(11,13,17,19,23,29,31,37,41,43,47)\n\
    \        val letters = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)\n   \
    \     val decimals = scala.collection.mutable.ArrayBuffer(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47)\n\
    \        var count = 2\n        for (c <- num.toCharArray) {\n            if (letters.contains(c))\
    \ {\n                if (decimals.contains(c)) {\n                    if (primes.contains(count))\
    \ {\n                        count += 1\n                    } else {\n      \
    \                  nonPrimes += count\n                        count = 0\n   \
    \                 }\n                } else {\n                    nonPrimes +=\
    \ count\n                    count = 0\n                }\n            } else\
    \ {\n                if (decimals.contains(c)) {\n                    count +=\
    \ 1\n                } else {\n                    nonPrimes += count\n      \
    \              count = 0\n                }\n            }\n        }\n      \
    \  nonPrimes.toLong", "        def hexToInt(s : String) : Int = {\n          \
    \  val digits = Iterator.from(s).takeWhile(_.isDigit)\n            val digitPairs\
    \ = digits.length / 2\n            val result = digits\n                .grouped(digitPairs)\n\
    \                .foldLeft(0)((res, pair) => res + pair.toChar.asDigit(0) * pair)\n\
    \            res % 1000\n        }\n        val digits = Iterator.from(num).takeWhile(_.isDigit)\n\
    \        val digitPairs = digits.length / 2\n        val result = digits\n   \
    \         .grouped(digitPairs)\n            .foldLeft(0)((res, pair) => res +\
    \ pair.toChar.asDigit(0) * pair)\n        res % 1000", "        val primes = new\
    \ mutable.HashSet[Long]()\n        var count = 0\n        for(a <- num .toCharArray){\n\
    \            val number = a.toLong\n            if(number == 1){\n           \
    \     primes += number\n                count += 2\n            }else{\n     \
    \           if(number % 2 == 0 || number % 3 == 0){\n                    primes\
    \ += number\n                    count += 2\n                }\n             \
    \   else if(primes.contains(number)){\n                    primes += number\n\
    \                    count += 2\n                }\n                else{\n  \
    \                  count += 1\n                }\n            }\n        }\n \
    \       count", '        // TODO: ', "        def hexDigit(x: Int): Int = if (x\
    \ >= 0 && x <= 9) x else x - 10 + 26\n        def hexChar(x: Int): Int = if (x\
    \ >= 0 && x <= 9) x else x - 10 + 26\n        val hexCharSet = scala.collection.mutable.Set(hexChar('A'),\
    \ hexChar('B'), hexChar('C'), hexChar('D'), hexChar('E'), hexChar('F'))\n    \
    \    val hexDigitSet = scala.collection.mutable.Set(hexDigit('A'), hexDigit('B'),\
    \ hexDigit('C'), hexDigit('D'), hexDigit('E'), hexDigit('F'))\n        val hexChar2Set\
    \ = scala.collection.mutable.Set(hexChar('A'), hexChar('B'), hexChar('C'), hexChar('D'),\
    \ hexChar('E'), hexChar('F'), hexChar('A'), hexChar('B'), hexChar('C'), hexChar('D'),\
    \ hexChar('E'), hexChar('F'), hexChar('A'), hexChar('B'), hexChar('C'), hexChar('D'),\
    \ hexChar('E'), hexChar('F'))\n        val hexDigit2Set = scala.collection.mutable.Set(hexDigit('A'),\
    \ hexDigit('B'), hexDigit('C'), hexDigit('D'), hexDigit('E'), hexDigit('F'))\n\
    \        val chars = num.toCharArray\n        var numDigits = 0\n        var numChars\
    \ = 0\n        var numHexDigits = 0\n        var numHexChars = 0\n        var\
    \ numHexDigit2s = 0\n        var numHexChar2s = 0\n        for (i <- chars) {\n\
    \            val x = hexDigit(i)\n            numDigits += x\n            numChars\
    \ += if (hexDigitSet contains x) 1 else 0\n            numHexDigits += x\n   \
    \         numHexChars += if (hexCharSet contains x) 1 else 0\n            numHexDigit2s\
    \ += if (hexDigit2Set contains x) 1 else 0\n            numHexChar2s += if (hexChar2Set\
    \ contains x) 1 else 0\n        }\n        (numDigits, numChars, numHexDigits,\
    \ numHexChars, numHexDigit2s, numHexChar2s)", "        val hexString = num.trim\n\
    \        if (hexString.length == 0) 0\n        else {\n            val (num, hexString1)\
    \ = hexString.split(\"(?!^)\").unzip\n            val num2 = num.toInt\n     \
    \       val (hexString2, hexString3) = hexString1.split(\"(?!^)\").unzip\n   \
    \         val hexString4 = hexString2.trim\n            val hexString5 = hexString3.trim\n\
    \            // num1 can be divided by 3 or 5 or 7 or 11 or 13 or 17 or 19 or\
    \ 23\n            // num2 can be divided by 3 or 5 or 7 or 11 or 13 or 17 or 19\
    \ or 23\n            // so num1 * num2 < hexString4, hexString5 can be divided\
    \ by 3 or 5 or 7 or 11 or 13 or 17 or 19 or 23\n            val hexString6 = hexString4.trim\n\
    \            if (num2 * num2 < hexString6 || hexString5 == \"\" || hexString5\
    \ == \"A\" || hexString5 == \"B\" || hexString5 == \"C\" || hexString5 == \"D\"\
    \ || hexString5 == \"E\" || hexString5 == \"F\") num2 * num2\n            else\
    \ {\n                val hexString7 = hexString5.trim\n                val hexString8\
    \ = hexString7.trim\n                val hexString9 = hexString8.trim\n      \
    \          if (hexString9.length == 0) num2 * num2\n                else {\n \
    \                   val hexString10 = hexString9.trim\n                    val\
    \ hexString11 = hexString10.trim\n                    val hexString12 = hexString11.trim\n\
    \                    val hexString13 = hexString12.trim\n                    if\
    \ (hexString13.length == 0) num2 * num2\n                    else {\n        \
    \                val hexString14 = hexString13.trim\n                        val\
    \ hexString15 = hexString14.trim\n                        val hexString16 = hexString15.trim\n\
    \                        val hexString17 = hexString16.trim\n                \
    \        val hexString18 = hexString17.trim\n                        if (hexString18.length\
    \ == 0) num2 * num2\n                        else {\n                        \
    \    val hexString19 = hexString18.trim\n                            val hexString20\
    \ = hexString19.trim\n                            val hexString21 = hexString20.trim\n\
    \                            val hexString22 = hexString21.trim\n            \
    \                val hexString23 = hexString22.trim\n                        \
    \    val hexString24 = hexString23.trim\n                            val hexString25\
    \ = hexString24.trim\n                            val hexString26 = hexString25.trim\n\
    \                            val hexString27 = hexString26.trim\n            \
    \                val hexString28 = hexString27.trim\n                        \
    \    val hexString29", "        val key = mutable.HashSet[Int]()\n        var\
    \ counter = 2\n        val hexChars = \"0123456789ABCDEF\"\n        val stringChars\
    \ = num.toCharArray\n        stringChars foreach { c =>\n            val i = hexChars.indexOf(c)\n\
    \            if(i != -1)\n                key.add(i)\n        }\n        while(key.nonEmpty\
    \ && counter <= hexChars.length) {\n            val next = hexChars(key.toSet.next)\n\
    \            if(!stringChars.contains(next)) {\n                counter += 1\n\
    \            }\n        }\n        key.toSet.count() match {\n            case\
    \ 0 => 0\n            case _ => (counter - 2)\n        }", "        var prime\
    \ : Long = 0\n        var counter : Long = 1\n        for (i <- 0 to (hexNum.length\
    \ - 1)) {\n            val hex = hexNum(i).toChar\n            if (hex >= '0'\
    \ && hex <= '9') {\n                prime *= counter\n                prime +=\
    \ hex.toLong\n                counter += 1\n            }\n            else {\n\
    \                counter += 1\n            }\n        }\n        prime", "   \
    \     def isPrime(num: Long, divisor: Long) : Boolean = {\n            val sqrt\
    \ = (num * num + divisor * divisor) / 2L\n            divisor <= 1L || sqrt <=\
    \ 1L || sqrt % divisor != 0L\n        }\n        val hexDigits = num.toCharArray.map(_\
    \ => hexValue(_)).toList\n        var primeCount = 0\n        var prime = 0L\n\
    \        for (hexDigit <- hexDigits) {\n            prime = hexValue(hexDigit)\n\
    \            if (isPrime(prime, 2L)) {\n                primeCount += 1\n    \
    \        }\n        }\n        prime", "        val primes = mutable.Buffer[Long]()\n\
    \        // You have been tasked to write a function that receives \n        //\
    \ a hexadecimal number as a string and counts the number of hexadecimal \n   \
    \     // digits that are primes (prime number, or a prime, is a natural number\
    \ \n        // greater than 1 that is not a product of two smaller natural numbers).\n\
    \        // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E,\
    \ F.\n        // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n        // So you\
    \ have to determine a number of the following digits: 2, 3, 5, 7, \n        //\
    \ B (=decimal 11), D (=decimal 13).\n        // Note: you may assume the input\
    \ is always correct or empty string, \n        // and symbols A,B,C,D,E,F are\
    \ always uppercase.\n        // Examples:\n        // >>> hexKey((\"AB\"))\n \
    \       // (1l)\n        // >>> hexKey((\"1077E\"))\n        // (2l)\n       \
    \ // >>> hexKey((\"ABED1A33\"))\n        // (4l)\n        // >>> hexKey((\"123456789ABCDEF0\"\
    ))\n        // (6l)\n        // >>> hexKey((\"2020\"))\n        // (2l)\n\n  \
    \      def isPrime(i: Long, primes: List[Long]): Boolean = {\n            primes.contains(i)\n\
    \        }\n        def isPrime(i: Long): Boolean = {\n            if (primes.contains(i))\n\
    \            {\n                true\n            }\n            else\n      \
    \      {\n                var test2 = i/2\n                while (test2 > 1)\n\
    \                {\n                    if (isPrime(test2, primes)) \n       \
    \             {\n                        return true\n                    }\n\
    \                    else\n                    {\n                        test2\
    \ -= 1\n                    }\n                }\n            }\n            return\
    \ false\n        }\n        def isPrime(i: Long, primes: mutable.Buffer[Long])\
    \ : Boolean = {\n            primes.contains(i)\n        }\n\n        // You have\
    \ been tasked to write a function that receives \n        // a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n        // digits that are\
    \ primes (prime number, or a prime, is a natural number \n        // greater than\
    \ 1 that is not a product of two smaller natural numbers).\n        // Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n        // Prime\
    \ numbers are 2, 3, 5, 7, 11, 13, 17,...\n        // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n        // B (=decimal 11),\
    \ D (=decimal 13).\n        // Note: you may assume the input is always correct\
    \ or empty string, \n        // and symbols A,B,C,D,E,F are always uppercase.\n\
    \        // Examples:\n        // >>> hexKey((\"AB\"))\n        // (1", "    \
    \    // Convert string to array of characters:\n        var numArr = num.toCharArray.filterNot(Character.isDigit).toArray\n\
    \        \n        // Find primes less than or equal to numArr\n        var numPrimes\
    \ = 0\n        var i = 2\n        var primes = mutable.ArrayBuffer(2, 3, 5, 7,\
    \ 11, 13, 17, 19)\n        var primeCount = primes.length\n        while (i *\
    \ i < numArr.length && primeCount > 0) {\n            if (numArr(i * i) == numArr(i))\
    \ {\n                primeCount -= 1\n            } else {\n                primes\
    \ += primeCount\n                primeCount -= 1\n            }\n            i\
    \ += 2\n        }\n\n        // Find digits in primes\n        var digits = primes.filter(_\
    \ % numArr(0) == 0).length\n        for (prime <- primes) {\n            digits\
    \ += numArr.filterNot(_ == numArr(0)).filter(_ % prime == 0).length\n        }\n\
    \        \n        // Return count\n        digits.length", "        val hex =\
    \ num.toCharArray.map(_ - 48).toList\n        val bitSet = hex.foldLeft(0) { (s,\
    \ b) => s << 1 + b }\n        val primeBits = primeBitSet\n        val resultBits\
    \ = hex.foldLeft(0) { (s, b) => s << 1 + primeBits(b) }\n        resultBits %\
    \ hex.size + 1", "        var count = 0\n        var digits = num.toCharArray()\n\
    \        for( i <- 0 until digits.length ) {\n            if( i % 2 == 0 ) {\n\
    \                if( digits(i) == 'A' || digits(i) == 'B' ) {\n              \
    \      count += 1\n                }\n                else if( digits(i) == 'D'\
    \ || digits(i) == 'E' ) {\n                    count += 1\n                }\n\
    \                else {\n                    count += 0\n                }\n \
    \           }\n        }\n        count", "        import scala.util.parsing.combinator._\n\
    \        val digits = num.grouped(2).map(_.toChar)\n        val charMap = Map(\n\
    \            \"A\"->1, \"B\"->2, \"C\"->3, \"D\"->4, \"E\"->5, \"F\"->6\n    \
    \    )\n        val len = digits.length\n        val sumOfDigits = digits map\
    \ {x => if (charMap.get(x) != null) 1 \n        else charMap.get(x) match { case\
    \ 0 => 2 }\n        }.reduceLeft(_ + _)\n        val hexCount = num.length % 2\n\
    \        val totalDigits = hexCount * 2 + len\n        val totalNum = digits.length\
    \ + sumOfDigits + (hexCount * hexCount)\n        if (totalNum >= totalDigits)\
    \ 0\n        else num.length.toLong / totalNum", "        def isPrime(n : Int)\
    \ : Boolean = {\n            var isPrime = false\n            while (n > 1) {\n\
    \                if (n % 2 == 0) {\n                    isPrime = true\n     \
    \               n = n + 1\n                } else {\n                    if (n\
    \ == 3) {\n                        isPrime = true\n                        break\n\
    \                    } else if (n % 2 == 1) {\n                        isPrime\
    \ = false\n                        break\n                    }\n            \
    \        n = n / 2\n                }\n            }\n            isPrime\n  \
    \      }\n        val numAsIntArray = num.split(\"\").toList.toArray.map(_.toInt)\n\
    \        val result = 0L\n        for (i <- 0 until numAsIntArray.length-1) {\n\
    \            val n1 = numAsIntArray(i)\n            val n2 = numAsIntArray(i+1)\n\
    \            val isPrime = isPrime(n1)\n            if (isPrime) {\n         \
    \       val n3 = numAsIntArray(i+2)\n                val n4 = numAsIntArray(i+3)\n\
    \                if (n4 != 0) {\n                    val n5 = numAsIntArray(i+4)\n\
    \                    val n6 = numAsIntArray(i+5)\n                    if (n6 !=\
    \ 0) {\n                        val n7 = numAsIntArray(i+6)\n                \
    \        val n8 = numAsIntArray(i+7)\n                        if (n8 != 0) {\n\
    \                            val n9 = numAsIntArray(i+8)\n                   \
    \         val n10 = numAsIntArray(i+9)\n                            val n11 =\
    \ numAsIntArray(i+10)\n                            val n12 = numAsIntArray(i+11)\n\
    \                            val n13 = numAsIntArray(i+12)\n                 \
    \           val n14 = numAsIntArray(i+13)\n                            val n15\
    \ = numAsIntArray(i+14)\n                            val n16 = numAsIntArray(i+15)\n\
    \                            val n17 = numAsIntArray(i+16)\n                 \
    \           val n18 = numAsIntArray(i+17)\n                            val n19\
    \ = numAsIntArray(i+18)\n                            val n20 = numAsIntArray(i+19)\n\
    \                            val n21 = numAsIntArray(i+20)\n                 \
    \           val n22 = numAsIntArray(i+21)\n                            val n23\
    \ = numAsIntArray(i+22)\n                            val n24 = numAsIntArray(i+23)\n\
    \                            val n25 = numAsIntArray(i+24)\n                 \
    \           val n26 = numAsIntArray(i+25)\n                            val n27\
    \ = numAsIntArray(i+26)\n                            val n28 = numAsIntArray(i+27)",
  "        // Your code here\n        var count = 0\n        // Convert string to\
    \ array, then to string\n        num.toString.toArray().toList.filterNot(x =>\
    \ x.toString.toChar.isDigit).filterNot(x => x.toString.toChar.isLetter).foreach\
    \ { x =>\n            // If the char is number, add it to count\n            if\
    \ (x.toString.toChar.isDigit) {\n                count += 1\n            }\n \
    \       }\n        count + (if (num.isEmpty || num.toString.toChar == 'F') 2 else\
    \ 0)", "        val digits = num.split(\"\").toList\n        val numKeySet = digits.length\
    \ + 1 toSet\n        for (d <- digits) {\n            if (!numKeySet.contains(d.toInt))\
    \ {\n                numKeySet.add(d.toInt)\n            }\n        }\n      \
    \  val numKeySetSize = numKeySet.toSet.size\n        val hexKeySet = numKeySet.toSet\
    \ map (_ % 10).toSet\n        val hexKeySetSize = hexKeySet.toSet.size\n     \
    \   numKeySet.toSet map { _ => (numKeySetSize - hexKeySetSize) }.toList", "  \
    \      val digits = num.toList\n        val charArray = digits.toArray\n     \
    \   val numString = new String(charArray).replaceAll(\"0\", \"\").replaceAll(\"\
    A\", \"\")\n        val hexDigitsArray = numString.toList.toArray.grouped(4).toList\n\
    \        val primes = hexDigitsArray.filter(_ > 1).filter(_ % 2 == 0).map(_ *\
    \ 2)\n        val numHexDigitsToSum = hexDigitsArray.size - primes.size\n    \
    \    val sum = hexDigitsArray.reduceLeft(_ + _)\n        numHexDigitsToSum * hexDigitsArray.size\
    \ * (hexDigitsArray.size - 1) * sum / sum", "        require(num.length == hexDigits.length,\
    \ \n            s\"Error: input length must be exactly ${hexDigits.length}\")\n\
    \n        var hex : Long = 0\n        for(i <- 0 until num.length) {\n       \
    \     val n = num(i)\n            hex = hex + hexDigits.indexOf(n)\n        }\n\
    \        hex", "        val hexKeys : mutable.Set[String] = mutable.Set(\"0\"\
    , \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\"\
    , \"C\", \"D\", \"E\", \"F\")\n        val hexKeysLength = hexKeys.size\n    \
    \    val hexNum = hexKeys.toSet.diff(hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet ", "        val hexString = num.filter(x =>\
    \ x.isHexDigit).mkString.toLong\n        val bits = hexString.toCharArray\n  \
    \      val bitCount = bits.length\n        val keyDigits = bitCount(2)\n     \
    \   val hexDigits = bitCount(3)\n        val newBits = new Array[String](bitCount)\n\
    \        val result = new Array[Boolean](keyDigits)\n        val primes = Array(2,\
    \ 3, 5, 7, 11, 13, 17)\n        var i = 1\n        while (i < bitCount) {\n  \
    \          if (bits(i) == 'A' || bits(i) == 'B') { \n                val hexAtoi\
    \ = (hexString.toLong - hexString.toLong * hexDigits(2)) / 2\n               \
    \ val hexAtoj = (hexString.toLong - hexString.toLong * hexDigits(3)) / 3\n   \
    \             val hexAtok = hexString.toLong - hexString.toLong * hexDigits(4)\
    \ / 4\n                val hexAtol = hexString.toLong - hexString.toLong * hexDigits(5)\
    \ / 5\n                val hexAtom = hexString.toLong - hexString.toLong * hexDigits(6)\
    \ / 6\n                val hexAton = hexString.toLong - hexString.toLong * hexDigits(7)\
    \ / 7\n                val hexAtoo = hexString.toLong - hexString.toLong * hexDigits(8)\
    \ / 8\n                val hexAtop = hexString.toLong - hexString.toLong * hexDigits(9)\
    \ / 9\n                val hexAtoq = hexString.toLong - hexString.toLong * hexDigits(10)\
    \ / 10\n                val hexAtor = hexString.toLong - hexString.toLong * hexDigits(11)\
    \ / 11\n                val hexAtos = hexString.toLong - hexString.toLong * hexDigits(12)\
    \ / 12\n                val hexAtot = hexString.toLong - hexString.toLong * hexDigits(13)\
    \ / 13\n                val hexAtou = hexString.toLong - hexString.toLong * hexDigits(14)\
    \ / 14\n                val hexAtov = hexString.toLong - hexString.toLong * hexDigits(15)\
    \ / 15\n                val hexAtow = hexString.toLong - hexString.toLong * hexDigits(16)\
    \ / 16\n                val hexAtox = hexString.toLong - hexString.toLong * hexDigits(17)\
    \ / 17\n                val hexAtoy = hexString.toLong - hexString.toLong * hexDigits(18)\
    \ / 18\n                val hexAto", "        var total = 0L\n        val numLength\
    \ = num.length\n        for(i <- 0 until numLength) {\n            val d = num(i).toInt\n\
    \            for(j <- 0 until d) {\n                total += (if(isPrime(j)) j.toLong\
    \ else 0L)\n            }\n        }\n        total", "        val numArray =\
    \ num.toCharArray()\n        val charArray = numArray.map(_.toUpperCase)\n   \
    \     val hexArray = charArray.map(x=> (x.toLong, x.toLong % 16L))\n        var\
    \ count = 0L\n        var i = hexArray.size - 1\n        var j = 0\n        while\
    \ (i>=0){\n            count += hexArray(i)._1\n            i -= 1\n         \
    \   j+=1\n        }\n        count += hexArray(j)._1\n        count", "      \
    \  val ns: StringBuffer = new StringBuffer(num)\n        val str: List[Char] =\
    \ ns.getChars().toList\n        val len = str.length\n        val primes = List[Long](2,3,5,7,11,13,17,19)\n\
    \        val map: mutable.Map[Long, Long] = mutable.Map[Long, Long]()\n      \
    \  val maps: mutable.Map[Long, Long] = mutable.Map[Long, Long]()\n        def\
    \ checkPrime(prime : Long) : Boolean = {\n            prime in primes\n      \
    \  }\n        def checkPrime2(prime : Long) : Boolean = {\n            prime in\
    \ primes.reverse\n        }\n        def checkPrime3(prime : Long) : Boolean =\
    \ {\n            for (x <- primes.takeWhile(checkPrime)){\n                if\
    \ (prime == x) {\n                    true\n                } else if (prime !=\
    \ x && prime < x){\n                    false\n                } else if (prime\
    \ > x){\n                    prime > x\n                }\n            }\n   \
    \     }\n        for(i <- 0 until len){\n            val val = str.apply(i)\n\
    \            val dec = str.apply(i).toInt\n            val numDigits = str.length\n\
    \            val digit = dec % 10\n            val power = dec / 10\n        \
    \    if (checkPrime(power)) {\n                map(power) += 1\n             \
    \   if (map.contains(power)) {\n                    maps(power) += 1\n       \
    \         }\n                if(!map.contains(power) && !maps.contains(power))\
    \ {\n                    map(power) += 1\n                    if (map.contains(power))\
    \ {\n                        maps(power) += 1\n                    }\n       \
    \         }\n            }\n        }\n        val nn = str\n        for(x <-\
    \ primes){\n            val num = x\n            val primesNum = nn.filterNot(x\
    \ => x == num)\n            val primesNum2 = primesNum.filterNot(x => x == num)\n\
    \            val primesNum3 = primesNum2.filterNot(x => x == num)\n          \
    \  if (checkPrime2(primesNum2) == checkPrime3(primesNum3)){\n                return\
    \ x\n            }\n        }\n        return 0l", "        val digits = num.map(x\
    \ => x.toChar)\n        val hexa = digits.map(x => x.toInt)\n        val primes\
    \ = primes().toList\n        val result = hexa.zip(primes).map{case (h,p) => if\
    \ (p == 1) (h,1) else (h,0) }.countBy{case (h,c) => c}\n        result.maxBy(_._1)._1",
  "        val arr = num.split(\"(?!^)(?=\\\\d)\").map(_.toLong).toArray\n       \
    \ var count = 0\n        for (x<-arr) {\n            // only consider even numbers\n\
    \            if (x%2 == 0)\n                count += 1\n        }\n        \n\
    \        // first check if num is a prime\n        var count = 0\n        for\
    \ (i<-0 until arr.length) {\n            // only consider even numbers\n     \
    \       if (arr(i) % 2 == 0)\n                count += 1\n        }\n        \n\
    \        // now check if num is prime\n        if (count == 0) {\n           \
    \ // count the number of odd numbers in arr\n            var count = 0\n     \
    \       for (x<-0 until arr.length) {\n                // only consider odd numbers\n\
    \                if (arr(x) % 2 == 1)\n                    count += 1\n      \
    \      }\n            // if the count is odd, num is a prime\n            if (count\
    \ % 2 == 1)\n                count += 2\n        }\n        // return the count\
    \ as a long\n        count.toLong", "        // 1. We must convert the hexadecimal\
    \ string to decimal string, \n        // by appending 0x to it (\"AB\" => \"0xAB\"\
    ), then convert it to \n        // a byte array.\n        // 2. Let's use groupBy\
    \ and filter method of collections, \n        // where groupBy will group all\
    \ elements with the same value, \n        // and filter will keep only those elements\
    \ that satisfy the given \n        // predicate function.\n        // 3. Since\
    \ we want to keep only the primes, we must apply some \n        // kind of filter\
    \ to remove all the non-primes elements, and \n        // finally return the length\
    \ of the resulting collection.\n        // 4. We use toList to convert it into\
    \ a mutable list. The toList \n        // method will convert the mutable list\
    \ to immutable list, and return \n        // it.\n        num.toByteArray().grouped(4).filter(i\
    \ => {\n            // 5. We use the isPrime method of scala.math library to \n\
    \            // determine if a number is prime or not.\n            isPrime(i._1)\n\
    \        }).map(i => {\n            // 6. In the map method, we need to convert\
    \ the byte array to \n            // a decimal string, and return a tuple with\
    \ the string and \n            // the number as a long.\n            val str =\
    \ i._1.toString(16)\n            str.substring(str.length-1)\n        }).toList.length",
  "        val list = num.chars.toList\n        var count : Int = 0\n        var i\
    \ : Int = 0\n        var j : Int = 0\n        var prime = 0\n        while(i <\
    \ list.length) {\n            prime = (prime == 0) || (prime == 1) || (list(i).toUpperCase\
    \ == \"A\") || (list(i).toUpperCase == \"B\") || (list(i).toUpperCase == \"C\"\
    ) || (list(i).toUpperCase == \"D\") || (list(i).toUpperCase == \"E\") || (list(i).toUpperCase\
    \ == \"F\")\n            if(list(i).toUpperCase == \"0\") count++\n          \
    \  if(prime == true && list.take(i).toUpperCase == \"2\") count++\n          \
    \  i = i + 1\n        }\n        count = count + 1\n        return count", " \
    \       import java.lang._\n        val chars = num.toCharArray\n        // Count\
    \ each prime digits count\n        var count = 0\n        var prev = 0\n     \
    \   for(i <- 0 until chars.length - 1){\n            if(chars(i).toInt == prev){\n\
    \                count += 1\n            } else {\n                count = 0\n\
    \                prev = chars(i).toInt\n            }\n        }\n        val\
    \ count = chars.length * 2 - 1 - count\n        val key = num.toLong * count /\
    \ chars.length\n        key", "        var n = 0\n        for (i <- 0 until num.length\
    \ - 1)\n            n += num.charAt(i).toInt.toLong\n        if (num.length ==\
    \ 0) 0\n        else {\n            var prime = primes\n            for (i <-\
    \ 0 until prime.length - 1)\n                if (n / prime(i).productDiv <= 1)\
    \ n /= prime(i)\n            n\n        }", "        // TODO: Your code here\n\
    \        return 0", "        val num = num.toUpperCase\n\n        val primes =\
    \ List(2, 3, 5, 7, 11, 13, 17, 19)\n        val primesCount = primes.size\n\n\
    \        var hexDigits = 0 \n        var hexVal = 0\n        var hexPrime = 0\n\
    \        val hexArray = num.toCharArray.map { c =>\n            hexVal = hexVal\
    \ + (c * scala.util.pow(2, hexDigits))\n            hexDigits = hexDigits + 1\n\
    \        }\n\n        val countPrime = hexArray.count(_ == 2)\n        val countPrime2\
    \ = hexArray.count(_ == 3)\n        val countPrime3 = hexArray.count(_ == 5)\n\
    \        val countPrime4 = hexArray.count(_ == 7) \n        val countPrime5 =\
    \ hexArray.count(_ == 11) \n        val countPrime6 = hexArray.count(_ == 13)\n\
    \        val countPrime7 = hexArray.count(_ == 17)\n        val countPrime8 =\
    \ hexArray.count(_ == 19)\n\n        if(countPrime == primesCount) {\n       \
    \     hexVal = hexVal - primesCount\n        }\n        if(countPrime2 == primesCount)\
    \ {\n            hexVal = hexVal - primesCount\n        }\n        if(countPrime3\
    \ == primesCount) {\n            hexVal = hexVal - primesCount\n        }\n  \
    \      if(countPrime4 == primesCount) {\n            hexVal = hexVal - primesCount\n\
    \        }\n        if(countPrime5 == primesCount) {\n            hexVal = hexVal\
    \ - primesCount\n        }\n        if(countPrime6 == primesCount) {\n       \
    \     hexVal = hexVal - primesCount\n        }\n        if(countPrime7 == primesCount)\
    \ {\n            hexVal = hexVal - primesCount\n        }\n        if(countPrime8\
    \ == primesCount) {\n            hexVal = hexVal - primesCount\n        }\n\n\
    \        hexVal", "        var numList = num.toList\n        val prime = List(2,3,5,7,11,13,17,19)\n\
    \        var count = 0\n        for (i <- 0 until numList.size) {\n          \
    \  var num2 = numList(i)\n            for(j <- 0 until prime.size) {\n       \
    \         if(num2 % prime(j) == 0) {\n                    num2 /= prime(j)\n \
    \                   count += 1\n                    break\n                }\n\
    \            }\n        }\n        count + numList.size", "        // Return value\
    \ should be Long, an arbitrary precision (64-bit) integer.\n        val map =\
    \ mutable.Map.empty[Long, Int]\n        for (i <- 0 until num.length)\n      \
    \      map += num.charAt(i) -> 1\n        \n        // Prime number is a natural\
    \ number greater than 1 that is not a product \n        // of two smaller natural\
    \ numbers, therefore any prime number can have the \n        // same number of\
    \ digits as the hexadecimal number. \n        val primes = map.filter { case (_,\
    \ v) => v > 1 }.keys\n        val primeNum = primes.head\n        val hexCount\
    \ = map.getOrElse(primeNum, 0)\n        \n        // The hexadecimal number must\
    \ be an exact power of two\n        val hexBase = hexCount / hexCount.getOrElse(BigInt(2),\
    \ 1)\n        val hexBase2 = hexBase / hexBase.getOrElse(BigInt(2), 1)\n     \
    \   val hexBase3 = hexBase2 / hexBase2.getOrElse(BigInt(2), 1)\n        val hexBase4\
    \ = hexBase3 / hexBase3.getOrElse(BigInt(2), 1)\n        \n        if (hexCount\
    \ % hexCount.getOrElse(BigInt(2), 1) == 0)\n            (hexCount + hexBase4)\
    \ / hexBase4.getOrElse(BigInt(2), 1)\n        else\n            0", "        val\
    \ keyMap : mutable.Map[Int, Long] = mutable.Map(\n                0 -> 2,\n  \
    \              1 -> 2,\n                2 -> 3,\n                3 -> 3,\n   \
    \             4 -> 5,\n                5 -> 7,\n                6 -> 11,\n   \
    \             7 -> 13,\n                8 -> 17,\n                9 -> 19\n  \
    \      )\n        val newKey = num.toLong\n        val result = 0\n        for\
    \ (x <- num.toLong - 1) {\n            if (x < 9) {\n                if (keyMap(x)\
    \ == 2) {\n                    result += newKey % 10\n                    newKey\
    \ /= 10\n                }\n            }\n            else if (x == 9) {\n  \
    \              if (keyMap(x) == 2) {\n                    result += newKey % 10\n\
    \                    newKey /= 10\n                }\n            }\n        \
    \    else {\n                if (keyMap(x) == 2) {\n                    result\
    \ += newKey % 10\n                    newKey /= 10\n                }\n      \
    \      }\n        }\n        result", "        val key = mutable.BitSet()\n  \
    \      num.foreach(x => {\n            if (x.toChar.toUpperCase() == 'A') key.xor(x('a')\
    \ - 'A' + 10)\n            if (x.toChar.toUpperCase() == 'B') key.xor(x('b') -\
    \ 'A' + 10)\n            if (x.toChar.toUpperCase() == 'C') key.xor(x('c') - 'A'\
    \ + 10)\n            if (x.toChar.toUpperCase() == 'D') key.xor(x('d') - 'A' +\
    \ 10)\n            if (x.toChar.toUpperCase() == 'E') key.xor(x('e') - 'A' + 10)\n\
    \            if (x.toChar.toUpperCase() == 'F') key.xor(x('f') - 'A' + 10)\n \
    \       })\n        val result: Long = key.count()\n        return result", " \
    \       var n = 0L\n        // TODO: Write code here", "        num.toLong.filter(_\
    \ >= '0') map { hex =>\n            // If the hexadecimal digit is a valid hexadecimal\
    \ digit, \n            // return its count. Otherwise, return 0.\n           \
    \ if (hex >= '0' && hex <= '9') {\n                val digitCount = hex.toInt\n\
    \                if (digitCount > 0 && digitCount <= 6) {\n                  \
    \  if (digitCount > 2) {\n                        if (digitCount > 5) {\n    \
    \                        if (digitCount > 7) {\n                             \
    \   return digitCount\n                            } else {\n                \
    \                return 0\n                            }\n                   \
    \     } else {\n                            if (digitCount > 3) {\n          \
    \                      return digitCount\n                            } else {\n\
    \                                return 0\n                            }\n   \
    \                     }\n                    } else {\n                      \
    \  if (digitCount > 2) {\n                            if (digitCount > 5) {\n\
    \                                return digitCount\n                         \
    \   } else {\n                                return 0\n                     \
    \       }\n                        } else {\n                            if (digitCount\
    \ > 2) {\n                                return digitCount\n                \
    \            } else {\n                                return 0\n            \
    \                }\n                        }\n                    }\n       \
    \         }\n            } else {\n                return 0\n            }\n \
    \       }.sum", "        // First split the number into its digits.\n        var\
    \ numDigits = num.toString.toList.reverse.map(_.toInt).reverse\n        var primes\
    \ : mutable.Set[Int] = mutable.Set.empty\n        \n        // For each digit,\
    \ check if it is prime and add its position to \n        // the set.\n       \
    \ numDigits.zipWithIndex.foreach { case (digit, idx) => \n            if (isPrime(digit)\
    \ && (primes.contains(idx) || primes.isEmpty)) primes += idx\n        }\n    \
    \    // Count the number of primes found.\n        numDigits.count(_ == 2)", " \
    \       val hex = num.map(_.toChar).mkString.toLong\n        hex.reverse match\
    \ {\n            case 0 => \"0\"\n            case a => \"0123456789ABCDEF\".indexOf(a.toChar)\n\
    \        }", "        val chars = num.toCharArray\n        var count = 0\n   \
    \     var hex = 0\n        for(i <- 0 until chars.length) {\n            val c\
    \ = chars(i)\n            if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\
    \ || (c >= 'A' && c <= 'F')) {\n                count += 1 \n                val\
    \ hd = hex % 10\n                hex += c - '0'\n                if(hd < 9) {\n\
    \                    hex = 0\n                }\n            }\n        }\n  \
    \      count", "        val primes = mutable.Set[Long]()\n        // The function\
    \ should count the prime digits (i.e. the numbers of \n        // hexadecimal\
    \ digits that are primes) and return the result.\n        def countHexPrimes(hexNum\
    \ : String) : Long = {\n            val hex = hexNum.map(x => if (x == 'A' ||\
    \ x == 'B' || x == 'C' || x == 'D' || x == 'E' || x == 'F') x else Character.toUpperCase(x)).mkString\n\
    \            val hexArray = hex.toCharArray\n            val hexString = new String(hexArray)\n\
    \            val charArray = hexString.toCharArray\n            var count = 0\n\
    \            val primeDigits = hexString.map(x => x match {\n                case\
    \ x if x % 2 == 0 => true\n                case x => false\n            }).filter(x\
    \ => x).map(x => x match {\n                case false => x + 2\n            \
    \    case true => x - 2\n            }).toArray\n            var hexDigits = new\
    \ collection.mutable.ArrayBuffer[Char]()\n            hexDigits.append(hexNum)\n\
    \            while (hexDigits.nonEmpty) {\n                hexDigits.clear()\n\
    \                for (i <- hexDigits.indices.reverse) {\n                    hexDigits.append(hexDigits.take(i\
    \ + 1).last)\n                }\n                hexDigits.append(hexDigits.last)\n\
    \                for (i <- hexDigits.indices) {\n                    hexDigits.append(hexDigits.take(i\
    \ + 1).last)\n                }\n                primeDigits.zip(hexDigits).foreach\
    \ { case (prime, hexDigit) =>\n                    if (!primeDigits.contains(hexDigit.toInt))\n\
    \                        primes.add(prime)\n                }\n              \
    \  hexDigits.clear()\n            }\n            primes.size\n        }\n    \
    \    val num = num.replaceAll(\"\\\\D\", \"\")\n        val numArray = num.toCharArray\n\
    \        val numString = new String(numArray)\n        val charArray = numString.toCharArray\n\
    \        var hexNumber = 0\n        var count = 0\n        var hexDigits = collection.mutable.ArrayBuffer[Char]()\n\
    \        for (i <- charArray) {\n            if (hexNumber > 9) {\n          \
    \      hexNumber += hexNumber(hexDigits)\n                hexDigits = collection.mutable.ArrayBuffer[Char]()\n\
    \                count = 0\n            }\n            if (Character.isDigit(hexNumber(hexDigits)))\
    \ {\n                count += 1\n                hexNumber += hexNumber(hexDigits)\n\
    \                hexDigits = collection.mutable.ArrayBuffer[Char]()\n        \
    \    }\n            hexDigits.append(i)\n        }\n        hexNumber + hexNumber(hexDigits)",
  "        val hexDigits = \"abcdef0123456789ABCDEF\"\n        val hexValue = num.map(c\
    \ => hexDigits.indexOf(c)).sum\n        val hexDigitsLength = hexDigits.length\n\
    \        val hexValueString = hexValue.toString\n        val hexValueLength =\
    \ hexValueString.length\n        val primes = mutable.ArrayBuffer.empty[Int]\n\
    \        (0 to hexValueLength - 1).foreach {\n            if (hexValueString.charAt(_)\
    \ == '1') {\n                primes += hexDigitsLength\n            }\n      \
    \  }\n        primes.length", "        val hex = num.map(_.toInt)\n        val\
    \ a = hex(0)\n        val b = hex(2)\n        val c = hex(4)\n        val d =\
    \ hex(6)\n        val e = (hex(0))\n        val f = (hex(2))\n        val g =\
    \ (hex(4))\n        val h = (hex(6))\n        val l = hex(0)\n        val m =\
    \ (hex(0))\n        val n = (hex(2))\n        val o = (hex(4))\n        val p\
    \ = (hex(6))\n        val q = (hex(0))\n        val r = (hex(2))\n        val\
    \ s = (hex(4))\n        val t = (hex(6))\n        val u = (hex(0))\n        val\
    \ v = (hex(2))\n        val x = (hex(4))\n        val y = (hex(6))\n        val\
    \ z = (hex(0))\n        val hex2 = hex(1)\n        val hex3 = hex(2)\n       \
    \ val hex5 = hex(5)\n        val hex7 = hex(7)\n        val hex9 = hex(9)\n  \
    \      val hexB = hex(11)\n        val hexD = hex(13)\n        val hexE = hex(17)\n\
    \        val hexF = hex(19)\n        var hexArray = Array[Int](hex, hex2, hex3,\
    \ hex5, hex7, hex9, hexB, hexD, hexE, hexF)\n        val primes = primesOf(hexArray.length)\n\
    \        var primeCount = 0\n        var primeDigit = 0\n        var primeIndex\
    \ = 0\n        for (prime <- primes) {\n            primeDigit = 0\n         \
    \   primeIndex = 0\n            for (hex <- hexArray) {\n                if (hex\
    \ > prime) {\n                    primeDigit += 1\n                    if (primeDigit\
    \ == prime) {\n                        break\n                    }\n        \
    \        }\n            }\n            if (primeDigit == prime) {\n          \
    \      primeCount += 1\n            }\n        }\n        primeCount", "     \
    \   val map = new mutable.HashMap[String, Long]()\n        for(num <- num.toCharArray.map(x\
    \ => x.toLong)){\n            if (map.contains(num.toString)){\n             \
    \   map(num.toString) +=1\n            }else{\n                map.put(num.toString,1)\n\
    \            }\n        }\n        for(num <- map.keys){\n            val prime\
    \ = num.indexOf('2')\n            if(prime == -1 || prime == 0){\n           \
    \     map.remove(num)\n            }\n        }\n        map.size", '        //
    Your code here.', "        val chars = num.toCharArray\n        val n = chars.length\n\
    \        val a = Array.fill(n)(0)\n        for (i <- 0 to n-1){\n            val\
    \ b = chars(i).toLong\n            a(i) = a(i) ++ b\n        }\n        val b\
    \ = Array.fill(n)(0)\n        for (i <- 0 to n-1){\n            val c = a(i) %\
    \ 2\n            b(i) = b(i) ++ c\n        }\n        b.sum", "        val hexList\
    \ = num.toList\n        val keys = hexList.map(x => x.toInt)\n        val keySet\
    \ = keys.toSet\n        val primeKeys = for {\n            key <- keySet\n   \
    \         if (key.equals(key / 2) || key.equals(key * 3) || key.equals(key * 5)\
    \ || key.equals(key * 7) || key.equals(key * 11))\n        } yield key\n     \
    \   val result = 0\n        primeKeys.foreach { key =>\n            if (hexList.map(x\
    \ => x.toInt).contains(key)) result += key\n        }\n        result", "    \
    \    var i = 0\n        var count = 0\n        val l = (num.length).asInstanceOf[Int]\n\
    \        for (i <- 0 until l) {\n            val x = (hexDigit(num(i).toChar)).asInstanceOf[Int]\n\
    \            if (x == 0) count = count + 1\n            else {\n             \
    \   val p = primes(x)\n                count = count + (p.size > 1)\n        \
    \    }\n        }\n        count * l", "        // convert decimal string to binary\
    \ string\n        val binary = num.map(c => c.toInt % 2).toList.mkString\n   \
    \     // calculate the binary equivalent of the number\n        val hex = Integer.parseInt(binary,\
    \ 2)\n        // count the primes\n        val primes = hex.toSet.filter(_ % 2\
    \ != 0) // even\n        // convert to decimal string\n        val decimal = primes.foldLeft(0)(_\
    \ + 2)\n        return hex.asInstanceOf[Long] * (hex.asInstanceOf[Long] * 16)\
    \ + decimal", "        // Use '2' as base to convert a string to number\n    \
    \    num.toLong(2).asInstanceOf[Long]", "        val len = num.length\n      \
    \  val chars = (num ++ num).chars.toList\n        chars.map(c => (c + 'A').toInt\
    \ % 26).distinct.toList.length", "        val hexList = num.toString.toCharArray.filterNot(_.isDigit)\n\
    \        var numPrime = 0\n        var numPow = 0\n        for(hex <- hexList)\
    \ {\n            numPrime += hexToInt(hex)\n            numPow += hexToInt(hex)\n\
    \        }\n        (hexList.count(x => isPrime(hexToInt(x))) == (numPrime * numPow)\
    \ / hexList.size)", "        val length = num.length\n        val digits = mutable.HashSet[Int]()\n\
    \        val count = mutable.HashSet[Long]()\n        for (i <- 0 until length)\
    \ {\n            val chr = num(i).toUpperCase // in case the char was an uppercase\
    \ letter\n            digits += (if (chr == \"A\") 0 else 1)\n            digits\
    \ += (if (chr == \"B\") 2 else 1)\n            digits += (if (chr == \"C\") 4\
    \ else 1)\n            digits += (if (chr == \"D\") 6 else 1)\n            digits\
    \ += (if (chr == \"E\") 8 else 1)\n            digits += (if (chr == \"F\") 10\
    \ else 1)\n        }\n        for (i <- digits) {\n            for (j <- 0 until\
    \ i) {\n                if (digits(j + i) == 2) {\n                    count.+=\
    \ 2\n                }\n                if (digits(j + i) == 3) {\n          \
    \          count.+= 3\n                }\n                if (digits(j + i) ==\
    \ 5) {\n                    count.+= 5\n                }\n                if\
    \ (digits(j + i) == 7) {\n                    count.+= 7\n                }\n\
    \            }\n        }\n        val num = count.length\n        count.length",
  "        // base case\n        if(num.isEmpty) 0\n        else {\n            //\
    \ count the number of digits, starting at 0\n            var digits = 0\n    \
    \        // loop to count the digits\n            for(i <- num.toCharArray )\n\
    \            {\n                // if the digit is between '0' and '9', it is\
    \ an ASCII digit \n                // and therefore a hex digit\n            \
    \    if((i>=48) && (i<=57)) digits+=1\n                // if the digit is between\
    \ 'A' and 'F', it is a hexadecimal \n                // digit and therefore a\
    \ hex digit\n                else if((i>=65) && (i<=70)) digits+=1\n         \
    \       // if the digit is between 'a' and 'f', it is a hexadecimal \n       \
    \         // digit and therefore a hex digit\n                else if((i>=97)\
    \ && (i<=102)) digits+=1\n                // any other digits are considered a\
    \ hex digit, so...\n                else digits+=1\n            }\n          \
    \  // return number of hex digits \n            return digits\n        }", " \
    \       val hexDigits = num.toCharArray.map(_.toInt)\n        var count = 0L\n\
    \        for(i <- 0 until hexDigits.length) {\n            val num = hexDigits(i)\
    \ * hexDigits(i) + hexDigits(i+1)\n            val isPrime = num % 2 == 0\n  \
    \          val numToAdd = hexDigits(i) + hexDigits(i+1)\n            if(isPrime\
    \ && (numToAdd < hexDigits.length ||\n                            (hexDigits(i)\
    \ == hexDigits(i+1)))) {\n                count += 1L\n            }\n       \
    \ }\n        count + 1", "        def isPrime(n : Int) : Boolean = {\n       \
    \     for{\n                i <- 2 until math.ceil(math.sqrt(n))\n           \
    \ } yield n % i == 0\n        }\n        val isEven = num.length % 2 == 0\n  \
    \      val isHex = num.toCharArray.map(c => ('A' <= c && c <= 'F')).forall(!_)\n\
    \        val isDecimal = num.toCharArray.map(c => ('0' <= c && c <= '9')).forall(!_)\n\
    \        if(isEven && isHex && isDecimal) return 1\n        if(num.length == 0)\
    \ return 0\n        val hexKey = num.toCharArray.map(c => ('A' <= c && c <= 'F')).count(!_)\n\
    \        if(hexKey == 3) return 1\n        if(hexKey == 5) return 2\n        if(hexKey\
    \ == 7) return 3\n        if(hexKey == 11) return 4\n        if(hexKey == 13)\
    \ return 5\n        if(hexKey == 17) return 6\n        if(hexKey == 19) return\
    \ 7\n        return 0", "        if (num.isEmpty) 0\n        else {\n        \
    \    val numMap = num.toCharArray.map(c => (c).toLong)\n            val hexNum\
    \ = numMap.toList.sortBy(a => a).reverse\n            val hexNumList = hexNum.map(a\
    \ => (a & 0xF).toLong)\n            val hexNumMap = hexNumList.toMap\n       \
    \     val hexNumArray = hexNumList.toArray\n            val hexNumArrayList =\
    \ hexNumArray.toList.sortBy(a => a).reverse\n            val hexNumArrayMap :\
    \ Map[Long, Int] = hexNumArrayList.foldLeft[Map[Long, Int]](Map())(\n        \
    \        a => {\n                    val key = a.toLong\n                    val\
    \ value = hexNumMap.getOrElse(key, 0)\n                    a + (key -> value)\n\
    \                }\n            )\n            val hexNumArrayMapList = hexNumArrayMap.map(a\
    \ => a._1 -> a._2)\n            val twosIndex = hexNumArrayMap.filter(_._1 ==\
    \ 2).map(_._2)\n            val zerosIndex = hexNumArrayMap.filter(_._1 == 0).map(_._2)\n\
    \            val prime = hexNumArrayMapList.getOrElse(hexNumArrayMapList(0).toLong,\
    \ 0)\n            val nonPrime = hexNumArrayMapList\n                .filter(a\
    \ => a._1 -> a._2 != prime)\n                .map(a => a._1 -> a._2)\n       \
    \         .toList\n                .toMap\n            val primeList = nonPrime.filter(_._1\
    \ == prime).toList\n            val nonPrimeMap = nonPrime.foldLeft[Map[Long,\
    \ Int]](Map())(\n                a => {\n                    val key = a.toLong\n\
    \                    val value = primeList.count(b => b._1 == key)\n         \
    \           a + (key -> value)\n                }\n            )\n           \
    \ val primeArray = primeList.map(_._1).toArray\n            val primeArrayList\
    \ = primeArray.sortBy(a => a).reverse\n            val primeArrayMap : Map[Long,\
    \ Int] = primeArrayList.foldLeft[Map[Long, Int]](Map())(\n                a =>\
    \ {\n                    val key = a.toLong\n                    val value = hexNumArrayMap.getOrElse(key,\
    \ 0)\n                    a + (key -> value)\n                }\n            )\n\
    \            val primeArrayMapList = primeArrayMap.map(a => a._1 -> a._2)\n  \
    \          val nonPrimeArray = nonPrime.filter(a => a._1 -> a._2 != prime).toList\n\
    \            val nonPrimeArrayMap = nonPrime.", "        val digits = num.toCharArray\n\
    \        val prime = scala.collection.mutable.MutableList(2l)\n        val hex\
    \ = scala.collection.mutable.MutableList(2l)\n        val hexStr = scala.collection.mutable.MutableList(2l)\n\
    \        // The number has 6 digits, and it's an even number (hexKey(\"0xAB\"\
    ) is 0L)\n        if (digits.length == 6) {\n            if (digits(0) == '0')\
    \ {\n                hex.push(digits(1))\n                hex.push(digits(2))\n\
    \                hex.push(digits(3))\n                hex.push(digits(4))\n  \
    \              hex.push(digits(5))\n                hex.push(digits(6))\n    \
    \            hex.push(digits(7))\n            } else {\n                hex.push(digits(0))\n\
    \                hex.push(digits(1))\n                hex.push(digits(2))\n  \
    \              hex.push(digits(3))\n                hex.push(digits(4))\n    \
    \            hex.push(digits(5))\n            }\n            hexStr.clear()\n\
    \            hexStr.push(digits(0)+digits(1)+digits(2)+digits(3)+digits(4)+digits(5))\n\
    \            hexStr.push(digits(6)+digits(7))\n            hexStr.push(digits(8)+digits(9))\n\
    \            hexStr.push(digits(10)+digits(11)+digits(12))\n            hexStr.push(digits(13)+digits(14)+digits(15))\n\
    \            // Find the prime number\n            for (hexNum <- hexStr) {\n\
    \                val hexNumInt = hexNum.toInt\n                var primeIndex\
    \ = 0\n                primeIndex = hex.indexWhere(hexNum => hexNumInt%hexNum\
    \ == 0)\n                if (primeIndex == -1) {\n                    prime.push(hexNumInt)\n\
    \                }\n            }\n            val hexStrInt = hexStr.toInt\n\
    \            var primeIndex = 0\n            primeIndex = hexStr.indexWhere(hexNum\
    \ => hexStrInt%hexNum == 0)\n            if (primeIndex == -1) {\n           \
    \     prime.push(hexStrInt)\n            }\n            prime.count()\n      \
    \  }", "        val strList = num.split(\"\\\\\").toList\n        if(strList.length\
    \ == 0){\n            return 1l\n        }\n        val count2 = strList.foldLeft(0l){\
    \ (count, v) => {\n            if(v.nonEmpty){\n                val isPrime =\
    \ v.head.toInt % 2 == 0\n                if(isPrime){\n                    val\
    \ isOdd = v.head.toInt % 3 == 0\n                    if(isOdd){\n            \
    \            val isEven = v.head.toInt % 4 == 0\n                        if(isEven){\n\
    \                            count + 1\n                        }\n          \
    \              else{\n                            count + 1\n                \
    \        }\n                    }\n                    else{\n               \
    \         count + 1\n                    }\n                }\n              \
    \  else{\n                    count + 1\n                }\n            }\n  \
    \          else{\n                count + 1\n            }\n        }}\n     \
    \   val result = count2 % 8\n        if(result == 0){\n            1l\n      \
    \  }\n        else{\n            result\n        }", "        val count = new\
    \ scala.collection.mutable.HashMap[Int, Int]();\n        var n = 0;\n        val\
    \ maxDigit = Character.getNumericValue(num.charAt(0));\n        // count the digit\
    \ in the string\n        for (i <- 0 until num.length -1) {\n            if (Character.getNumericValue(num.charAt(i))\
    \ == maxDigit - 1) {\n                n = n + 1;\n            } else {\n     \
    \           count = count + (n -> 1)\n                n = 0;\n            }\n\
    \        }\n        // count the digit in the last string\n        if (n != 0)\
    \ {\n            count = count + (n -> 1)\n        }\n        // print the count\n\
    \        println(count.toList)\n        val prime = count.filter{case(key, value)\
    \ => key % 2 == 0 && value > 1}\n        println(prime)\n        prime.toList.map(x\
    \ => x._1).toList", "        val n = num.length\n        var count = 0L\n    \
    \    val m = num.drop(1).mkString\n        val d = num.dropRight(1).mkString\n\
    \        val f = d.toDouble\n        val f2 = math.pow(10, 8) - f2\n        val\
    \ x = f.toLong\n        for (i <- 0 until n) {\n            var t = x * f2\n \
    \           while (t >= m) {\n                t -= m\n                count +=\
    \ 1\n            }\n        }\n        count + n", "        if (num.isEmpty) {\n\
    \            return 0L\n        }\n\n        def isPrime(n: Int): Boolean = {\
    \ // Returns whether n is a prime or not\n            val primes = mutable.ArrayBuffer(2,\
    \ 3, 5, 7)\n            primes.filter(_.isDefinedAt(n)).forall(p => p < n)\n \
    \       }\n\n        def count(n: Int): Long = { // Count how many hexadecimal\
    \ digits there are in a given number\n            def hexDigit(n: Int): Int =\
    \ { // Returns how many hexadecimal digits there are in a given number\n     \
    \           val tmp = n / 16\n                if (tmp % 2 == 0) {\n          \
    \          (tmp - 1) + hexDigit(tmp / 2)\n                } else {\n         \
    \           (tmp - 1) + 1\n                }\n            }\n            hexDigit(n)\
    \ * hexDigit(n / 16)\n        }\n\n        def primeCount(n: Int): Long = { //\
    \ Count how many hexadecimal digits there are in a given number\n            def\
    \ hexDigit(n: Int): Int = { // Returns how many hexadecimal digits there are in\
    \ a given number\n                val tmp = n / 16\n                if (tmp %\
    \ 2 == 0) {\n                    (tmp - 1) + hexDigit(tmp / 2)\n             \
    \   } else {\n                    (tmp - 1) + 1\n                }\n         \
    \   }\n            hexDigit(n) * hexDigit(n / 16)\n        }\n\n        val num\
    \ = num.toCharArray\n        val hexDigits: mutable.ArrayBuffer[Int] = mutable.ArrayBuffer(0)\
    \ // the hex digits\n        var count = 0L\n\n        for (i <- num) {\n    \
    \        val curr = i\n            hexDigits(count) = curr\n            count\
    \ += 1\n        }\n\n        for (hexDigit <- hexDigits) {\n            if (isPrime(hexDigit))\
    \ {\n                count += 1L\n            }\n        }\n\n        count *\
    \ primeCount(num)", "        val digits = num.grouped(4).toList\n        val hexDigits\
    \ = digits.map(d => if (d.toString.toLowerCase() == 'a') (6) else d.toString.toInt).toSet\n\
    \        val numDigits = digits.size\n        val hexDigitDigits = hexDigits.size\
    \ * hexDigits.size\n        val primeDigits = (hexDigitDigits/(numDigits*hexDigitDigits)).toLong\n\
    \        val primeDigitDigits = primeDigits.size * primeDigits.size\n        hexDigitDigits\
    \ + primeDigits + hexDigits + primeDigits + hexDigitDigits", "        val list\
    \ = num.toLong.map(_.toByte)\n        val prime = list.zipWithIndex.filter(_._2\
    \ == 1).map(_._1).drop(1)\n        var count = 0L\n        val primeList = prime.toList\n\
    \        primeList.foreach{ number => if (list.contains(number)) count+=1}\n \
    \       count", "        val s = num.toInt\n        if (s == 0)\n            return\
    \ 0\n        var primes : Long = 0\n        var isPrime : Boolean = true\n   \
    \     val digits = Array.from(num)\n        var d = 0\n        digits(0) = (digits(0).toInt\
    \ + 1) % 16\n        val primes = findPrimes(digits.length)\n        val length\
    \ = digits.length\n        while (primes.isDefined) {\n            val p = primes.get\n\
    \            if (isPrime && d == 0) {\n                d += p\n            }\n\
    \            if (d < p) {\n                d += p\n                isPrime = true\n\
    \            } else if (d > p) {\n                isPrime = false\n          \
    \      d -= p\n            } else {\n                d += p\n            }\n \
    \           val newDigits = Array.from(digits)\n            val digitToAdd = d\n\
    \            newDigits(digitToAdd) = (newDigits(digitToAdd).toInt + 1) % 16\n\
    \            val newString = newDigits.map(_ + 48).mkString\n            val newLength\
    \ = newString.length\n            if (newLength != length && (newString.toInt\
    \ == digits(0).toInt) || (newString.toInt == digits(digitToAdd).toInt)) {\n  \
    \              primes = Some(digitToAdd)\n            }\n        }\n        return\
    \ primes.getOrElse(0)", "        //write your code here\n        val digits =\
    \ num.takeWhile(Character.isDigit)\n        val hexNum = digits.foldLeft(0){\n\
    \            (sum,c) => sum + Integer.parseInt(c) \n        }\n        val primes\
    \ = primeFactors(hexNum)\n        val factors = primes.filter{ n => hexNum % n\
    \ == 0}\n        factors.foldLeft(0){\n            (sum,c) => sum + c\n      \
    \  }", "        val hex = num.replaceAll(\"[^0-9a-zA-Z]\", \" \")\n        val\
    \ hexArray = hex.split(\" \").map(_.toInt)\n        val hexPrimeCount = hexPrimes(hexArray.length)\n\
    \        hexPrimeCount.toLong", "        // Count the number of possible hexadecimal\
    \ digits. \n        val hexLength = hexDigits.length\n        val hexNumbers =\
    \ num.toList\n        // Convert each hexadecimal digit to decimal\n        val\
    \ hexNumbersBig = hexNumbers.map{ x => hexDigits.indexOf(x).toLong }\n       \
    \ // Calculate the decimal value of each hexadecimal digit\n        val hexNumbersDecimal\
    \ = hexNumbersBig.map(x => x / hexLength)\n        // Calculate the sum of the\
    \ decimal value of each hexadecimal digit. \n        // A prime number is a hexadecimal\
    \ number whose decimal value is equal to \n        // 0 or 1, but not to 2 or\
    \ 3\n        val sumOfHexNumbersDecimal = hexNumbersDecimal.sum\n        // Find\
    \ all the prime numbers whose decimal value equals to 0 or 1\n        val primeNumbers\
    \ = List(2,3,5,7,11,13,17,19)\n            .filter( x => sumOfHexNumbersDecimal\
    \ == 0 || sumOfHexNumbersDecimal == 1 )\n            .filter( x => primeNumbers.indexOf(x)\
    \ != 0 ) \n        // Return the number of primes whose decimal value is equals\
    \ to 0 or 1\n        primeNumbers.length", "        val nums = num.trim.toIntArray\n\
    \        val key = nums(0)\n        val hexNum = num.substring(1)\n        var\
    \ numOfZeros = 0\n        val digits = hexNum.toList\n        // loop through\
    \ the digits\n        for(i <- 0 until digits.length) {\n            // if the\
    \ digit is 0, increment the number of 0's in the number \n            // of 0's\
    \ in the hexNum\n            if(digits(i) == 0) {\n                numOfZeros\
    \ += 1\n            }\n            // if the digit is greater than or equal to\
    \ 0 and less than \n            // the number of the hexadecimal digits, add one\
    \ to the number\n            if(digits(i) >= key && digits(i) <= numOfZeros) {\n\
    \                numOfZeros += 1\n            }\n        }\n        // return\
    \ the number of the hexadecimal digits that are prime\n        return numOfZeros",
  "        val nums = num.split(\"\\\\s\").toList\n        val prime = nums.filter(x\
    \ => x.toUpperCase != \"0\").map(x => nums(nums.indexOf(x)))\n        val hexDigit\
    \ = primes.filter(x => x.toUpperCase != \"0\").map(x => prime(primes.indexOf(x)))\n\
    \        nums.zip(hexDigit).filter(x => x._1.toUpperCase != \"0\").map(x => x._2\
    \ + x._1)", "        // Write your code here.\n        val list = num.toList\n\
    \        var primeCounter = 0L\n        for (i <- 0 until list.size){\n      \
    \    val digit = list.apply(i)\n          val hexDigit = digit % 16\n        \
    \  if(hexDigit < 2 || hexDigit > 9){\n            throw new IllegalArgumentException(s\"\
    Digit $digit is not valid.\")\n          }\n          if(primeCounter % 2 == 0\
    \ && hexDigit < 12){\n            primeCounter += 1\n          }\n          else\
    \ if(primeCounter % 2 == 1 && hexDigit < 13){\n            primeCounter += 1\n\
    \          }\n          else if(hexDigit == 12){\n            primeCounter +=\
    \ 2\n          }\n          else if(hexDigit == 13){\n            primeCounter\
    \ += 3\n          }\n        }\n        primeCounter", "        // The first letter\
    \ will be uppercase.\n        val digit = num(0)\n        // The rest can be anything\
    \ except 'A'...'F', '0'...'9', \n        // except 'A'...'F', the second letter.\n\
    \        val digits = num.subString(1,num.length-1).toString.toCharArray.dropWhile(digit\
    \ != ('A' | 'B' | 'C' | 'D' | 'E' | 'F')).map(x=>x.toInt)\n        // We only\
    \ consider prime numbers of length 2 through 9.\n        val digits = digits to\
    \ (9 to digits.length).filter(x=>digits(x) == 2)\n        // Then we just check\
    \ the primes we calculated before.\n        val sum = digits.foldLeft((0l,0)){\n\
    \            case ((sum,count),digit) => sum._1+digit._1 -> sum._1+digit._1 ->\
    \ count\n            case ((sum,count),_)       => sum -> count\n        }._1\n\
    \        return sum", "        import scala.math._\n        def hexaToInt(h:String)\
    \ : Int = {\n            val digits = h.split(\"\")\n            var sum = 0\n\
    \            for(i <- 0 until digits.length)\n                sum = sum * 16 +\
    \ digits(i).toInt\n            sum\n        }\n        val n = hexaToInt(num)\n\
    \        val m = n.toString.toLong\n        val isPrime = {\n            import\
    \ scala.math._\n            def isPrime(x : BigInt) : Boolean = {\n          \
    \      val q = BigInt(2)\n                val i = BigInt(2)\n                val\
    \ r = BigInt(2)\n                val x = BigInt(x)\n                val y = BigInt(2)\n\
    \                val n = BigInt(2)\n                var counter = BigInt(0)\n\
    \                while(i <= n) {\n                    val a = BigInt(x.pow(i))\n\
    \                    val b = BigInt(y.pow(i))\n                    val c = a.mod(b)\n\
    \                    val q = q.mult(c)\n                    val r = r.mul(x.pow(i))\n\
    \                    val s = r.mod(q)\n                    val x = q\n       \
    \             val y = r\n                    if(s.equals(BigInt(0)))\n       \
    \                 counter = counter + 1\n                    i = i + 1\n     \
    \           }\n                counter == 0\n            }\n            isPrime(m)\
    \ && isPrime(m)\n        }\n        (1l until m).count(isPrime).toLong", "   \
    \     val map = mutable.HashMap[String, Long]()\n        var count = 0\n     \
    \   val hex = num.toCharArray\n        hex.foreach { c =>\n            if(isPrime(c))\
    \ {\n                count += 1\n                map += c -> map.getOrElse(c,\
    \ 0) + 1\n            }\n        }\n        count", "        var count = 0\n \
    \       var prime = 0\n        var primes = scala.collection.mutable.Set.empty[Int]\n\
    \        for (i <- num.toCharArray) {\n            val charInt = i.toInt\n   \
    \         if (charInt < 0 || charInt.toString != \"A\") {\n                count\
    \ += 1\n                prime += (charInt - 'A')\n                primes += charInt\n\
    \            }\n        }\n        if (primes.size == 0) {\n            return\
    \ count\n        }\n        var count = 0\n        var isPrime = true\n      \
    \  var prime2 = primes.head\n        var prime3 = primes.tail.head\n        while\
    \ (prime2 != 1) {\n            if (prime2 % prime3 == 0) {\n                prime3\
    \ += 1\n            } else {\n                isPrime = false\n            }\n\
    \            prime2 /= 10\n        }\n        while (!isPrime) {\n           \
    \ prime3 = prime3 + 1\n            prime2 = prime2 * 3 + 1\n            if (prime2\
    \ > prime3) {\n                isPrime = false\n            }\n        }\n   \
    \     if (prime2 == 1) {\n            prime2 = primes.head\n        }\n      \
    \  count += prime2\n        if (prime3 == 2 || prime3 == 3 || prime3 == 5 || prime3\
    \ == 7 || prime3 == 11 || prime3 == 13) {\n            count += 1\n        }\n\
    \        return count", "        // Your code here\n        val numOfDigits =\
    \ hexToInt(num)\n        var count = 0\n        var primeNumber = 1\n        for\
    \ (i <- 0 to numOfDigits - 1) {\n            var prime = false\n            var\
    \ testNumber = hexToInt(num).toInt\n            while (testNumber > 0) {\n   \
    \             prime = true\n                testNumber %/= primeNumber\n     \
    \       }\n            if (prime) {\n                count += 1\n            }\n\
    \            primeNumber *= primeNumber\n        }\n        (count / 2)", "  \
    \     val digits = num.toCharArray\n       if (digits.isEmpty) {\n           0l\n\
    \       } else {\n           val n = digits.length\n           val m = digits.length\
    \ / 2\n           val p = 2\n           val counter = new scala.collection.mutable.HashMap[Char,\
    \ Long]()\n           for (i <- 2 to n) {\n               val flag = i % 2 !=\
    \ 0\n               if (flag) {\n                   if (counter.get(digits(i))\
    \ > 0) {\n                       counter.put(digits(i), (counter.get(digits(i)).asInstanceOf[Long]\
    \ + 1L))\n                   } else {\n                       counter.put(digits(i),\
    \ (1L))\n                   }\n               }\n           }\n           val\
    \ result = counter.values.toList.foldLeft(0l) { (sum, v) =>\n               val\
    \ m = v * p + 2\n               if (m <= n) {\n                   sum + m\n  \
    \             } else {\n                   sum\n               }\n           }\n\
    \           result\n       }"]
stop_tokens:
- "\n    }\n"
