language: scala
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val zero = numbers.min\n        val\
    \ one = numbers.max\n        val factor = (one - zero) / (numbers.size - 1)\n\
    \        numbers.map(n => factor * n).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcdkc6itb.scala:15)\n\tat Problem.main(tmpcdkc6itb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // We want to transform the numbers\
    \ to lie between 0 and 1.\n        // The \"range\" method of a Range object will\
    \ do this.\n        val min = numbers(0)\n        val max = numbers(0)\n     \
    \   for (i <- numbers.size-1) {\n            if(numbers(i) > max) {\n        \
    \        max = numbers(i)\n            } else if(numbers(i) < min) {\n       \
    \         min = numbers(i)\n            }\n        }\n        numbers.map(x =>\
    \ (x - min) / (max - min))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp5xia2ze.scala:13:18 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (i <- numbers.size-\e[31m1\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  value foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val unit = Math.min(numbers(0).toFloat,numbers(numbers.size\
    \ - 1).toFloat)\n        numbers.map(x => x/unit)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpesmrsuea.scala:13)\n\tat Problem.main(tmpesmrsuea.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNum = math.min(numbers.map(math.abs))\n\
    \        val maxNum = math.max(numbers.map(math.abs))\n        val range = (maxNum-minNum)\n\
    \        val nums = numbers.map(x => x - minNum) / (range / 2)\n        (nums.toList\
    \ ::: List(1.0f.toFloat))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6_msxe47.scala:9:26 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mminNum\e[0m = math.min(numbers.map(math.abs))\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments (List[Float])\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp6_msxe47.scala:10:26 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmaxNum\e[0m = math.max(numbers.map(math.abs))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (List[Float])\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6_msxe47.scala:12:48\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mnums\e[0m = numbers.map(\e[36mx\e[0m => x - minNum) / (range / \e[31m2\e[0m)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue / is not a member of List[Nothing], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.last\n        for (number <- numbers) {\n            if (number\
    \ < min) {\n                min = number\n            }\n            if (number\
    \ > max) {\n                max = number\n            }\n        }\n        numbers.map(x\
    \ => (x - min) / (max - min))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNumber = math.min(numbers)\n\
    \        val maxNumber = math.max(numbers)\n        val range = maxNumber - minNumber\n\
    \        val scaledNumbers = numbers.map(number => ((range * (number - minNumber))\
    \ / (range + minNumber)).round).toList\n        minNumber until maxNumber ++ scaledNumbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqp3m6vse.scala:9:29 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mminNumber\e[0m = math.min(numbers)\n\
    \e[31m\e[31m  |\e[0m                        ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqp3m6vse.scala:10:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxNumber\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m          \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        assert(numbers.size > 1)\n       \
    \ val sum = numbers.foldLeft(0.0f) { (sum, num) =>\n            if (sum < num)\
    \ sum + num\n            else sum\n        }\n        numbers.map(num / sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppt9u4p9w.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        numbers.map(num / sum)\n\e[31m\e[31m   |\e[0m\
    \                    ^^^\e[0m\n\e[31m   |\e[0m                    Not found: num\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val range = max - min + 1\n        val step = (range\
    \ - 1.0f) / (numbers.size - 1)\n        (0 until numbers.size).map( i => numbers(i)\
    \ + step * i ).map( i => min + (i * step))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpinxumyqu.scala:13:68\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (\e[31m0\e[0m until numbers.size).map(\
    \ \e[36mi\e[0m => numbers(i) + step * i ).map( \e[36mi\e[0m => min + (i * step))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Float]\n\e[31m   |\e[0m     \
    \   Required: List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        // If the range is too small, rescale all numbers\
    \ to zero\n        if(max - min < 1.0e-6)\n            numbers.map(x => 0.0f).toList\n\
    \        // If the range is too large, rescale all numbers to one\n        else\
    \ {\n            val diff = max - min\n            val rescaled = (numbers - min)\
    \ / diff * 2.0f + 1.0f\n            rescaled.toList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpapqe4nbo.scala:17:36 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mrescaled\e[0m = (numbers\
    \ - min) / diff * \e[31m2.0f\e[0m + \e[31m1.0f\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of List[Float], but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Initialize min and max with first\
    \ number\n        var min = numbers(0)\n        var max = numbers(0)\n       \
    \ // Set initial min and max to first numbers\n        numbers.foreach { number\
    \ =>\n            if (number < min) min = number\n            if (number > max)\
    \ max = number\n        }\n        // Apply a linear transformation of difference\
    \ between min and max to all the numbers\n        var minDiff = max - min\n  \
    \      var newMin = 0.0f\n        var newMax = 1.0f\n        for (number <- numbers)\
    \ {\n            // Scale new number to range of [0, 1]\n            val scaledNumber\
    \ = (number - min) / minDiff\n            // Check if scaledNumber is between\
    \ 0.0 and 1.0\n            if (scaledNumber > 1.0) scaledNumber = 1.0\n      \
    \      if (scaledNumber < 0.0) scaledNumber = 0.0\n            // Get the new\
    \ min and max values\n            newMin = min(newMin, scaledNumber)\n       \
    \     newMax = max(newMax, scaledNumber)\n        }\n        numbers.map(number\
    \ => if(number < newMin) 0.0f else if (number > newMax) 1.0f else number).filterNot(_\
    \ == 0.0f).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpd0k_itsc.scala:25:49 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (scaledNumber > \e[31m1.0\e\
    [0m) scaledNumber = \e[31m1.0\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                Reassignment to val scaledNumber\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpd0k_itsc.scala:26:49 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m (scaledNumber < \e[31m0.0\e\
    [0m) scaledNumber = \e[31m0.0\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                Reassignment to val scaledNumber\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmpd0k_itsc.scala:28:21 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            newMin = min(newMin, scaledNumber)\n\e[31m\e\
    [31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m                  \
    \   \e[33mvariable\e[0m \e[35mmin\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpd0k_itsc.scala:29:21 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            newMax = max(newMax, scaledNumber)\n\e[31m\e\
    [31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m                  \
    \   \e[33mvariable\e[0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val length = numbers.head\n      \
    \  val min = numbers.min\n        val max = numbers.max\n        if (max < min)\n\
    \            numbers.reverse\n        else if (min < -max)\n            numbers.reverse\n\
    \        else if (min > max) {\n            val tmp = min\n            min = max\n\
    \            max = tmp\n        }\n        numbers.map(_.toFloat * length / max\
    \ )\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpjmmv_oxg.scala:18:16 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            min = max\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val min\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpjmmv_oxg.scala:19:16 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            max = tmp\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val max\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val nums = numbers.toList\n      \
    \  if (nums.size < 2)\n            numbers\n        else\n            List(nums.min\
    \ / nums.sum, nums.max / nums.sum) :: rescaleToUnit(nums.drop(1))\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphqg2a0hf.scala:13:16\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            List(nums.min / nums.sum,\
    \ nums.max / nums.sum) :: rescaleToUnit(nums.drop(\e[31m1\e[0m))\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mFloat\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m            Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty) {\n         \
    \   return numbers.reverse\n        }\n        val sortedNumbers = numbers.sortBy(_.toFloat)\n\
    \        var minimum = sortedNumbers.head\n        var maximum = sortedNumbers.last\n\
    \        var result: List[Float] = numbers.reverse\n        for (i <- numbers.size-1\
    \ downTo 1) { \n            if (result(i) < minimum) minimum += minimum\n    \
    \        if (result(i) > maximum) maximum += maximum\n            result(i) =\
    \ result(i) - minimum.asInstanceOf[Float] / (maximum.asInstanceOf[Float] - minimum.asInstanceOf[Float])\n\
    \        }\n        result.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpymvcw62r.scala:16:33 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i <- numbers.size-\e[31m1\e[0m\
    \ downTo \e[31m1\e[0m) { \n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value downTo is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var max = numbers.head\n        var\
    \ min = numbers.last\n\n        numbers.foreach(n => {\n            if (n > max)\
    \ max = n\n            if (n < min) min = n\n        })\n\n        var length\
    \ = numbers.size\n\n        var sum : Float = 0.0f\n\n        var scaled: Float\
    \ = 1.0f\n\n        while (length > 1) {\n            scaled = ((numbers.head\
    \ - min) / (max - min)) * 2.0f\n\n            numbers.tail = scaled.toFloat ::\
    \ numbers.tail\n\n            sum += scaled.toFloat\n\n            length -= 1\n\
    \        }\n\n        numbers.head = 0.5f * (min + max)\n\n        sum += numbers.head\n\
    \n        numbers.head :: sum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpajrhxb85.scala:26:25 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            numbers.tail = scaled.toFloat :: numbers.tail\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val tail\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpajrhxb85.scala:33:21 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        numbers.head = \e[31m0.5f\e[0m * (min + max)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m        Reassignment to val head\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpajrhxb85.scala:37:21 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        numbers.head :: sum\n\e[31m\e[31m   |\e[0m       \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                     value :: is not\
    \ a member of Float\n3 errors found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.map(f => (f / numberMin(f).toFloat).toFloat)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6qczyhps.scala:9:30 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.map(\e[36mf\e[0m => (f / numberMin(f).toFloat).toFloat)\n\
    \e[31m\e[31m  |\e[0m                              ^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                              Not found: numberMin\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min  = numbers.reduceLeft(min)\
    \ _\n        val max = numbers.reduceRight(max) _\n        numbers.map { x =>\
    \ (x - min) / (max - min) }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E099] Syntax Error: /tmp/tmpwt6juxn_.scala:9:43 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m  = numbers.reduceLeft(min)\
    \ _\n\e[31m\e[31m  |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m  |\e[0mOnly function types can be followed by _ but the current expression\
    \ has type <error Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type>\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwt6juxn_.scala:10:38 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = numbers.reduceRight(max)\
    \ _\n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m\
    \   |\e[0m                                      Recursive \e[33mvalue\e[0m \e\
    [35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val smallest = numbers.min\n     \
    \   val largest = numbers.max\n        if (smallest == 0.0f) numbers else numbers.map(x\
    \ => (x - smallest) / (largest - smallest))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var result: List[Float] = numbers\
    \ // Copy list\n        var min: Float = math.min(numbers.head)\n        var max:\
    \ Float = math.max(numbers.last)\n\n        for(i <- 1 to numbers.size - 1) {\
    \ // Rescale each element\n            var minIndex: Int = numbers.indexWhere(_\
    \ == min)\n            var maxIndex: Int = numbers.indexWhere(_ == max)\n    \
    \        var scaled: Float = (numbers(i) - min) / (max - min) * (max - min) +\
    \ min\n            result(i) = scaled\n            min = scaled\n            max\
    \ = scaled\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_b4g3cdt.scala:10:30 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m: \e[35mFloat\e\
    [0m = math.min(numbers.head)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers.head : => Float))\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp_b4g3cdt.scala:11:30 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m: \e[35mFloat\e\
    [0m = math.max(numbers.last)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers.last : => Float))\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_b4g3cdt.scala:17:12 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            result(i) = scaled\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Float]\
    \ - did you mean List[Float].updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val xs = numbers.foldLeft(0.0f, 0.0f){\n\
    \            case (acc, curr) => (acc + curr) / numbers.size\n        }\n    \
    \    xs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8zah13il.scala:10:37 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mcase\e[0m (acc, curr) => (acc + curr)\
    \ / numbers.size\n\e[31m\e[31m   |\e[0m                                 ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of (Float, Float), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val smallest  = numbers.min\n    \
    \    val largest   = numbers.max\n        val rescaled  = (numbers - smallest)\
    \ / (largest - smallest)\n        rescaled.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoz_t_gk6.scala:11:33 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mrescaled\e[0m  = (numbers\
    \ - smallest) / (largest - smallest)\n\e[31m\e[31m   |\e[0m                  \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of List[Float],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.sortBy(-_)\n     \
    \   val mn = n(0)\n        val mx = n(n.get.length - 1)\n        (0 until n.get.length).map(\
    \ x => n(x) / mx).map( (x, xs) => x * mx + mn).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvyei6yw_.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmx\e[0m = n(n.get.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^\e[0m\n\e[31m\
    \   |\e[0m          value get is not a member of List[Float] - did you mean n.seq?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvyei6yw_.scala:12:19 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        (\e[31m0\e[0m until n.get.length).map( \e[36mx\e\
    [0m => n(x) / mx).map( (\e[36mx\e[0m, \e[36mxs\e[0m) => x * mx + mn).toList\n\e\
    [31m\e[31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not\
    \ a member of List[Float], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvyei6yw_.scala:12:65\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        (\e[31m0\e[0m\
    \ until n.get.length).map( \e[36mx\e[0m => n(x) / mx).map( (\e[36mx\e[0m, \e[36mxs\e\
    [0m) => x * mx + mn).toList\n\e[31m\e[31m   |\e[0m                           \
    \                              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                               Wrong number of parameters, expected: 1\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        assert(numbers.isEmpty || numbers.size\
    \ == 2)\n        val rescaledNumbers : List[Float] = numbers.map(n => if (n<0.0f)\
    \ 0.0 else n.toFloat/numbers.size)\n        assert(rescaledNumbers.min==0.0f &&\
    \ rescaledNumbers.max==1.0f)\n        return rescaledNumbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvuwx957f.scala:10:73\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mrescaledNumbers\e\
    [0m : \e[35mList\e[0m[\e[35mFloat\e[0m] = numbers.map(\e[36mn\e[0m => \e[33mif\e\
    [0m (n<\e[31m0.0f\e[0m) \e[31m0.0\e[0m \e[33melse\e[0m n.toFloat/numbers.size)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^^^\e[0m\n\e[31m   |\e[0m                                  \
    \             Found:    (\e[31m0.0d\e[0m : Double)\n\e[31m   |\e[0m          \
    \                                     Required: Float\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.foldLeft(numbers.head.toFloat){\
    \ (lastNumber, nextNumber) => lastNumber + (nextNumber - lastNumber) / (numbers.size\
    \ - 1) }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptb665d_n.scala:9:46\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        numbers.foldLeft(numbers.head.toFloat){\
    \ (\e[36mlastNumber\e[0m, \e[36mnextNumber\e[0m) => lastNumber + (nextNumber -\
    \ lastNumber) / (numbers.size - \e[31m1\e[0m) }\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m        Found:    Float\n\e[31m  |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mFloat\e[1m\e[32m]\e[0m\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        var rescaledNumbers = List[Float]()\n        for\
    \ (i<- numbers) {\n            rescaledNumbers += (((i.toFloat * max.toFloat)\
    \ / (max.toFloat-min.toFloat)) + (min.toFloat)).toFloat\n        }\n        rescaledNumbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph7wqz80n.scala:13:28 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            rescaledNumbers += (((i.toFloat * max.toFloat)\
    \ / (max.toFloat-min.toFloat)) + (min.toFloat)).toFloat\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value += is not a member\
    \ of List[Float] - did you mean List[Float].!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009660
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val maxInt = numbers.max\n       \
    \ val minInt = numbers.min\n        numbers.map( _ / maxInt - minInt)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp61kwsb48.scala:14)\n\tat Problem.main(tmp61kwsb48.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty)\n           \
    \ numbers\n        else {\n            var max = 1\n            var min = 0\n\
    \            var newNumbers = numbers\n            // Iterating over elements\
    \ and finding the smallest and largest numbers\n            numbers.foreach {\
    \ n =>\n                if (n > max) {\n                    max = n\n        \
    \        }\n                if (n < min) {\n                    min = n\n    \
    \            }\n            }\n            val diff = max - min\n            //\
    \ Iterating over elements and dividing them by diff and adding them to the new\
    \ list\n            numbers.foreach { n =>\n                if (n != 0 && n !=\
    \ 1) {\n                    newNumbers = newNumbers ::: (n / diff + min).toFloat\n\
    \                }\n            }\n            newNumbers\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfx8y6_h1.scala:18:26\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                    max = n\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (n : Float)\n\e[31m   |\e[0m                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfx8y6_h1.scala:21:26\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    min = n\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (n : Float)\n\e[31m   |\e[0m                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfx8y6_h1.scala:28:44\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    newNumbers\
    \ = newNumbers ::: (n / diff + min).toFloat\n\e[31m\e[31m   |\e[0m           \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                      value ::: is not a member of Float\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty) List(1.0f)\n\
    \        else numbers.map(x => ((x - min(numbers)) / (max(numbers) - min(numbers))).toFloat)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpccx6e012.scala:10:36 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33melse\e[0m numbers.map(x => ((x - min(numbers))\
    \ / (max(numbers) - min(numbers))).toFloat)\n\e[31m\e[31m   |\e[0m           \
    \                         ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.length < 2) numbers\n\
    \        else numbers(0) to numbers(1) map { n =>\n            (0.5f * (n - numbers(0)))\
    \ + (numbers(1) / n).toFloat\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpylk7lubv.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33melse\e[0m numbers(\e[31m0\e[0m) to numbers(\e\
    [31m1\e[0m) map { n =>\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue to is not a member of Float, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.BigDecimal.double2bigDecimal\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009662
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // The smallest number is set to 0\n\
    \        // The largest number is set to 1\n        // The new number list is\
    \ made by applying the linear transform to the old list with the range of 0 to\
    \ 1\n        val newList: List[Float] = List(0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat,\
    \ 0.75f.toFloat, 1.0f.toFloat)\n        // The old list is made to contain the\
    \ new list\n        // The new list is made to contain the original list\n   \
    \     // If the new list is smaller than the original list then the new list contains\
    \ zeros, and vice versa\n        val oldList = numbers.toList\n        if (newList.length\
    \ < oldList.length) {\n            val newListWithZeros = List(0.0.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat)\n            val newListWithOnes\
    \ = newList.zip(newListWithZeros).map(x => if (x._2 > x._1) x._2 else x._1)\n\
    \            newListWithOnes.reverse\n        } else {\n            newList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_yufzbtw.scala:26)\n\tat Problem.main(tmp_yufzbtw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var minNum = numbers(0)\n        var\
    \ maxNum = numbers(0)\n        numbers.foreach {\n            num => {\n     \
    \           if (num < minNum) {\n                    minNum = num\n          \
    \      }\n                if (num > maxNum) {\n                    maxNum = num\n\
    \                }\n            }\n        }\n        if (minNum == maxNum) {\n\
    \            return numbers\n        }\n        if (minNum > maxNum) {\n     \
    \       numbers.reverse.foreach {\n                num => {\n                \
    \    if (num > maxNum) {\n                        maxNum = num\n             \
    \       }\n                    if (num < minNum) {\n                        minNum\
    \ = num\n                    }\n                }\n            }\n           \
    \ numbers.reverse.foreach {\n                num => {\n                    if\
    \ (num == minNum) {\n                        minNum = maxNum\n               \
    \     }\n                    if (num == maxNum) {\n                        maxNum\
    \ = minNum\n                    }\n                }\n            }\n        }\
    \ else {\n            numbers.foreach {\n                num => {\n          \
    \          if (num == minNum) {\n                        minNum = maxNum\n   \
    \                 }\n                    if (num == maxNum) {\n              \
    \          maxNum = minNum\n                    }\n                }\n       \
    \     }\n        }\n        val rescaledList = List(minNum, maxNum)\n        rescaledList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkx5zq86a.scala:61)\n\tat Problem.main(tmpkx5zq86a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var newNumbers = numbers.map(x =>\
    \ (x - numbers.min) / (numbers.max - numbers.min))\n        newNumbers.filter(_\
    \ > 0.0).foreach(x => newNumbers.updated(0, x))\n        newNumbers.filter(_ <\
    \ 0.0).foreach(x => newNumbers.updated(newNumbers.size-1, x))\n        newNumbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.head\n        var\
    \ min = 0.0f, max = 1.0f\n        numbers.foreach {\n            x =>\n      \
    \          min = if (x < min) min else x\n                max = if (x > max) max\
    \ else x\n        }\n        val m = min + ((max - min)/n)\n        numbers.map(_\
    \ / m).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgdvjndvd.scala:10:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = \e[31m0.0f\e\
    [0m, max = \e[31m1.0f\e[0m\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\
    \e[31m   |\e[0m                      end of statement expected but ',' found\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpgdvjndvd.scala:14:28 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                max = \e[33mif\e[0m (x > max) max \e\
    [33melse\e[0m x\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>\e[0m\
    \ in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments ((Int, Int) => Int)\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpgdvjndvd.scala:14:44 --------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \                max = \e[33mif\e[0m (x > max) max \e[33melse\e[0m x\n\e[31m\e\
    [31m   |\e[0m                                            ^\e[0m\n\e[31m   |\e\
    [0m                                            Found:    (x : Float)\n\e[31m \
    \  |\e[0m                                            Required: (Int, Int) => Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgdvjndvd.scala:16:24 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = min + ((max - min)/n)\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ expected type ?{ - : ? }\n4 errors found\n"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sortedList = numbers.sortBy(math.abs)\n\
    \        var x = 0.0f\n        var y = 0.0f\n        var temp = 0.0f\n       \
    \ \n        for(i <- 0 until sortedList.size) {\n            x = x + sortedList(i)\
    \ \n            y = y + temp\n            temp = sortedList(i)\n        }\n  \
    \      \n        x = x / ((sortedList.size + 1) / 2)\n        for(i <- 0 until\
    \ sortedList.size) {\n            sortedList(i) = x * (sortedList(i) + y) / (sortedList.size\
    \ + 1) / 2 \n        }\n        \n        sortedList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcmvx1sxo.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sortedList(i) = x * (sortedList(i) + y) /\
    \ (sortedList.size + \e[31m1\e[0m) / \e[31m2\e[0m \n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Float]\
    \ - did you mean sortedList.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minimum = numbers.min\n      \
    \  val maximum = numbers.max\n        val numberOfElements = numbers.length\n\
    \        val newList = mutable.ArrayBuffer.empty[Float]\n\n        for (i <- 0\
    \ until numberOfElements) {\n            newList += (((numbers.apply(i)-minimum)\
    \ / (maximum-minimum)) * (1.0f.toFloat))\n        }\n\n        return newList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps2v_lelj.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mFloat\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sum = numbers.reduce(0f)\n   \
    \     val rescaledNumbers = numbers.map{x => x / sum}\n        rescaledNumbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7gy8g32w.scala:9:33\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36msum\e\
    [0m = numbers.reduce(\e[31m0f\e[0m)\n\e[31m\e[31m  |\e[0m                    \
    \             ^^\e[0m\n\e[31m  |\e[0m                                 Found: \
    \   (\e[31m0.0f\e[0m : Float)\n\e[31m  |\e[0m                                \
    \ Required: (Float, Float) => Float\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val m = numbers.min\n        val s\
    \ = numbers.max\n        val t = s.toFloat/m.toFloat\n        numbers.map(x =>\
    \ x*t).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbe7v3wm8.scala:15)\n\tat Problem.main(tmpbe7v3wm8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val middle = numbers.size / 2\n        val newMax\
    \ = (min + max) / 2\n        val newMin = (max - min) / 2\n        numbers.map(n\
    \ => (n - newMin) / (newMax - newMin).toFloat)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd34kss3_.scala:17)\n\tat Problem.main(tmpd34kss3_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty) return Nil\n\
    \        val min = math.min(numbers).toFloat\n        val max = math.max(numbers).toFloat\n\
    \        if (min == max) List(min)\n        else {\n            val xs = numbers.map(math.pow)\n\
    \            val rescale = xs.reduce(_ + _)/xs.last\n            xs.map(x => x\
    \ * rescale).reduce(_+_)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmplfp8r_c_.scala:10:23 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers).toFloat\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmplfp8r_c_.scala:11:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers).toFloat\n\e[31m\e[31m   |\e[0m        \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplfp8r_c_.scala:14:33 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mxs\e[0m = numbers.map(math.pow)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                 Found:    (Double, Double) => Double\n\
    \e[31m   |\e[0m                                 Required: Float => Double\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplfp8r_c_.scala:16:43\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            xs.map(\e[36mx\e\
    [0m => x * rescale).reduce(_+_)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Double\n\e[31m   |\e[0m            Required:\
    \ List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 erro"
  stdout: ''
  timestamp: 1660009665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val length = numbers.length\n    \
    \    if (length <= 1) {\n            List(numbers(0).toFloat)\n        } else\
    \ {\n            val rescaled = numbers.map(x => (x - numbers.min) / (numbers.max\
    \ - numbers.min))\n            val mapped = rescaled.zipWithIndex.map(x => (x(0)\
    \ + 1.0f).toFloat * x(1))\n            val min = numbers.min.toFloat\n       \
    \     val max = numbers.max.toFloat\n            val result = mapped.map(x =>\
    \ if (x == 0.0f) 0f else (x - min) / (max - min))\n            result\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbfymty2x.scala:22)\n\tat Problem.main(tmpbfymty2x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val smallest = math.min(numbers.reduceLeft(math.abs))\n\
    \        val largest = math.max(numbers.reduceRight(math.abs))\n        val diff\
    \ = (largest - smallest) / (numbers.length - 1.0)\n        val list = numbers.map(x\
    \ => (x - smallest) / diff)\n        list.map { x => if (x == 0.0) 0.0 else if\
    \ (x == 1.0) 1.0 else x }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqvf_70ul.scala:9:56 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers.reduceLeft(math.abs))\n\
    \e[31m\e[31m  |\e[0m                                                   ^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  |\e\
    [0m (x: Double): Double\n\e[31m  |\e[0m (x: Float): Float\n\e[31m  |\e[0m (x:\
    \ Long): Long\n\e[31m  |\e[0m (x: Int): Int\n\e[31m  |\e[0mmatch expected type\
    \ (B, Float) => B\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqvf_70ul.scala:9:28\
    \ ------------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e\
    [0m \e[36msmallest\e[0m = math.min(numbers.reduceLeft(math.abs))\n\e[31m\e[31m\
    \  |\e[0m                       ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\e[31m  |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments (Float)\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpqvf_70ul.scala:10:56 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mlargest\e[0m = math.max(numbers.reduceRight(math.abs))\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e\
    [0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0mmatch expected\
    \ type (Float, B) => B\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqvf_70ul.scala:10:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers.reduceRight(math.abs))\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in "
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var newNumbers = numbers\n       \
    \ var smallestNumber = numbers(0)\n        var largestNumber = numbers(0)\n\n\
    \        newNumbers.foreach{ number =>\n            if( smallest > number ) smallest\
    \ = number\n            if( largest < number ) largest = number\n        }\n \
    \       val delta = (largestNumber - smallestNumber).abs() / newNumbers.size\n\
    \        newNumbers.foreach{ number => \n            if( smallestNumber > number\
    \ ) smallestNumber = number\n            if( largestNumber < number ) largestNumber\
    \ = number\n        }\n        newNumbers = (newNumbers map { _ - smallest } map\
    \ { _ + smallest }).toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2ybq0ip5.scala:14:16 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m( smallest > number ) smallest\
    \ = number\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Not found: smallest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2ybq0ip5.scala:14:36 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m            \e[33mif\e[0m( smallest > number ) smallest =\
    \ number\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Not found: smallest\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2ybq0ip5.scala:15:16\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m(\
    \ largest < number ) largest = number\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: largest\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2ybq0ip5.scala:15:35 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m( largest < number ) largest\
    \ = number\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: largest\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp2ybq0ip5.scala:17:53 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdelta\e[0m = (largestNumber\
    \ - smallestNumber).abs() / newNumbers.size\n\e[31m\e[31m   |\e[0m           \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mclass\e[0m \e[35mRichFloat\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2"
  stdout: ''
  timestamp: 1660009665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.size >= 2)\n     \
    \   val min = numbers.min\n        val max = numbers.max\n        // The first\
    \ element in the list will be 0\n        numbers.map( _/min * max)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3qmm6gs.scala:16)\n\tat Problem.main(tmpq3qmm6gs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = math.min(numbers).toFloat\n\
    \        val max = math.max(numbers).toFloat\n        val scaledNumbers = numbers.map(\
    \ _ / max - min ).map( math.floor ).toList\n        scaledNumbers\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4n_bocdu.scala:9:23 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers).toFloat\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4n_bocdu.scala:10:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers).toFloat\n\e[31m\e[31m   |\e[0m        \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4n_bocdu.scala:12:8 ---------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        scaledNumbers\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (scaledNumbers : List[Double])\n\e[31m \
    \  |\e[0m        Required: List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val length = numbers.size\n      \
    \  if(length < 2) numbers.head\n        else {\n            val totalMin = numbers.min\n\
    \            val totalMax = numbers.max\n            val newMin = totalMin / 2.0\n\
    \            val newMax = totalMax / 2.0\n            numbers.map(n => (n - newMin)\
    \ / (newMax - newMin) * 1.0f).toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw5ndgw5t.scala:10:31\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mif\e[0m(length\
    \ < \e[31m2\e[0m) numbers.head\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    Float\n\e[31m   |\e[0m  \
    \                     Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mFloat\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw5ndgw5t.scala:16:70\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            numbers.map(\e[36mn\e\
    [0m => (n - newMin) / (newMax - newMin) * \e[31m1.0f\e[0m).toList\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[\e[1m\e[31mDouble\e[0m]\n\e[31m\
    \   |\e[0m            Required: List[\e[1m\e[32mFloat\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val m = numbers.reduceLeft((x, y)\
    \ => math.min(math.max(x, 0.0f), 1.0f))\n        numbers.map(x => x / m)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa7693gwh.scala:13)\n\tat Problem.main(tmpa7693gwh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009666
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var lowest = numbers.min\n       \
    \ var highest = numbers.max\n        var rescaledNumbers = List.empty[Float]\n\
    \n        // we know that if the lowest is greater than the highest then it implies\
    \ that the\n        // smallest number will be zero\n        if(lowest > highest)\
    \ {\n            rescaledNumbers = List.fill(numbers.size)(0)\n            numbers.foreach{\
    \ n =>\n                val ratio = n / highest\n                val scaled =\
    \ ratio * lowest\n                rescaledNumbers = rescaledNumbers :+ scaled\n\
    \            }\n        } else {\n            rescaledNumbers = numbers\n    \
    \    }\n\n        rescaledNumbers\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8bw70fju.scala:29)\n\tat Problem.main(tmp8bw70fju.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.sortWith( (n1, n2) => n2 <\
    \ n1)\n        val size = numbers.size\n        if (size < 2) {\n            numbers\n\
    \        } else {\n            var min = numbers(0)\n            var max = numbers(0)\n\
    \            for (i in 1 until size) {\n                min = if (numbers(i) <\
    \ min) numbers(i) else min\n                max = if (numbers(i) > max) numbers(i)\
    \ else max\n            }\n            if (min < 0.0f) min = 0.0f\n          \
    \  if (max > 1.0f) max = 1.0f\n            val scaledNumber = (max - min).toFloat\n\
    \            val scaled = List(0.0f, 0.0f, 0.0f, 0.0f, 0.0f)\n            var\
    \ i = 1\n            while (i <= size) {\n                scaled = scaled.updated(i,\
    \ numbers(i) / scaledNumber)\n                i += 1\n            }\n        \
    \    scaled.sortWith( (n1, n2) => n2 < n1)\n            scaled\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qhpf8yg.scala:16:36 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mfor\e[0m (i in \e[31m1\e[0m until size)\
    \ {\n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m \
    \  |\e[0m                                    '<-' expected, but '{' found\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp3qhpf8yg.scala:20:32 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (min < \e[31m0.0f\e[0m) min\
    \ = \e[31m0.0f\e[0m\n\e[31m\e[31m   |\e[0m                                ^\e\
    [0m\n\e[31m   |\e[0m                                expression expected but \e\
    [31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3qhpf8yg.scala:21:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e\
    [0m (max > \e[31m1.0f\e[0m) max = \e[31m1.0f\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \      expression expected but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp3qhpf8yg.scala:29:38 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            scaled.sortWith( (\e[36mn1\e[0m, \e[36mn2\e\
    [0m) => n2 < n1)\n\e[31m\e[31m   |\e[0m                                      ^^\e\
    [0m\n\e[31m   |\e[0m                                      ')' expected, but '=>'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qhpf8yg.scala:30:0 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            scaled\n\e[31m\e[31m   |\e[0m^^^^^^\e[0m\n\
    \e[31m   |\e[0m'<-' expected, but 'end of statement' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp3qhpf8yg.scala:31:8 ----------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        }\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0m        '<-' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3qhpf8yg.scala:19:13 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m            }\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0mvalue "
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sortedNumbers = numbers.sortBy(_)\n\
    \        val first = sortedNumbers.head\n        val last = sortedNumbers.last\n\
    \n        sortedNumbers.map(i => (i - first) / (last - first))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4eziegjb.scala:9:45 ------------------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36msortedNumbers\e[0m = numbers.sortBy(_)\n\
    \e[31m\e[31m  |\e[0m                                             ^\e[0m\n\e[31m\
    \  |\e[0mNo implicit Ordering defined for Any..\n\e[31m  |\e[0mI found:\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e\
    [31m  |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m  |\e[0m    )\n\e[31m  |\e[0m\n\e[31m  |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1660009671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers(0).abs, max = numbers(0).abs\n\
    \        for (nd <- numbers) {\n            min = math.min(min, nd.abs)\n    \
    \        max = math.max(max, nd.abs)\n        }\n        numbers.map(_.div(max).multiply(1.0f\
    \ - min))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpdnz_31b2.scala:9:32 ------------------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = numbers(\e[31m0\e\
    [0m).abs, max = numbers(\e[31m0\e[0m).abs\n\e[31m\e[31m  |\e[0m              \
    \                  ^\e[0m\n\e[31m  |\e[0m                                end of\
    \ statement expected but ',' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpdnz_31b2.scala:12:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m12 |\e[0m            max = math.max(max,\
    \ nd.abs)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in\
    \ \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double,\
    \ y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e\
    [0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m  \
    \ |\e[0mmatch arguments ((Int, Int) => Int, (scala.runtime.RichFloat#abs : =>\
    \ Float))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdnz_31b2.scala:14:22\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        numbers.map(_.div(max).multiply(\e\
    [31m1.0f\e[0m - min))\n\e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e\
    [31m   |\e[0m                    value div is not a member of Float\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min: Float = numbers.min\n   \
    \     val max: Float = numbers.max\n        val rescaled: List[Float] = numbers.map{x\
    \ => ((x - min)/(max - min)).toFloat}\n        rescaled\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.foldLeft(List[Float]()){\n\
    \            (acc, elem) =>\n                if (acc.length == 0) (acc.append(elem),\
    \ elem)\n                else if (acc.last >= elem)\n                    (acc.dropRight(1).reverse,\
    \ acc)(0) + elem / acc.last\n                else\n                    (acc.takeRight(acc.length\
    \ / 2 + 1), acc.reverse)(elem) + elem.toDouble / acc.last\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbmmr7bcx.scala:11:42 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m                \e[33mif\e[0m (acc.length == \e[31m0\e\
    [0m) (acc.append(elem), elem)\n\e[31m\e[31m   |\e[0m                         \
    \             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a member of\
    \ List[Float] - did you mean acc.appended?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpbmmr7bcx.scala:13:55 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m                    (acc.dropRight(\e[31m1\e[0m).reverse, acc)(\e[31m0\e[0m)\
    \ + elem / acc.last\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Float], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbmmr7bcx.scala:15:69 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    (acc.takeRight(acc.length / \e[31m2\e\
    [0m + \e[31m1\e[0m), acc.reverse)(elem) + elem.toDouble / acc.last\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                                Found:\
    \    (elem : Float)\n\e[31m   |\e[0m                                         \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.size >= 2, s\"Input\
    \ list must have at least two elements.\");\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        numbers.map(x => (x - min) / (max\
    \ - min))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpjp10ket6.scala:10:23 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpjp10ket6.scala:11:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val xmax = numbers.max\n        val\
    \ xmin = numbers.min\n        val ymin = xmin\n        val ymax = xmax\n     \
    \   val ydiff = (ymax - ymin).toFloat\n        val xdiff = (xmax - xmin).toFloat\n\
    \        val rescale = (xdiff / ydiff).toFloat\n        numbers.map(x => x - xmin\
    \ * rescale)\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd8tlm_xt.scala:19)\n\tat Problem.main(tmpd8tlm_xt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009677
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val list = numbers.toList\n      \
    \  val length = list.size\n        val largest = list.max\n        val smallest\
    \ = list.min\n        // calculate new minimum from largest and smallest elements\n\
    \        val newMin = largest - smallest\n        // calculate new largest from\
    \ largest and smallest elements\n        val newMax = largest + smallest\n\n \
    \       var newList: List[Float] = List()\n        if (newMin > 0) {\n       \
    \     newList = list :+ newMin\n        }\n        if (newMax > 0) {\n       \
    \     newList = newList :+ newMax\n        }\n        // If there are exactly\
    \ two elements, then just add either 0 or 1\n        val twoNumbers = newList\
    \ == List(newMin, newMax)\n        if (twoNumbers) {\n            newList = newList\
    \ :+ 0f\n        } else {\n            // If there are at least 3 elements, then\
    \ calculate newList and add 1 if the smallest element is 0 or 1 and the largest\
    \ element is 1\n            val oneNumbers = newList == List(0f, 1f)\n       \
    \     if (oneNumbers) {\n                newList = newList :+ 1\n            }\n\
    \        }\n        newList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp8tjgxpd.scala:39)\n\tat Problem.main(tmpp8tjgxpd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.foldLeft((numbers.minOption.getOrElse(0.0f),\
    \ numbers.maxOption.getOrElse(1.0f))){ (min, max) => (min / max) }._1.toList.map(_.toFloat)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpahq7avn7.scala:9:117 ------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.foldLeft((numbers.minOption.getOrElse(\e\
    [31m0.0f\e[0m), numbers.maxOption.getOrElse(\e[31m1.0f\e[0m))){ (\e[36mmin\e[0m,\
    \ \e[36mmax\e[0m) => (min / max) }._1.toList.map(_.toFloat)\n\e[31m\e[31m  |\e\
    [0m                                                                          \
    \                                       ^^^^^\e[0m\n\e[31m  |\e[0mvalue / is not\
    \ a member of (Float, Float), but could be made available as an extension method.\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m  |\e[0m\n\e[31m  |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m  |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m  |\e[0m\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n      val xmin = numbers.min\n      val xmax\
    \ = numbers.max\n      def rescale(x: Float, xmin: Float, xmax: Float): Float\
    \ = {\n        x * (xmax - xmin) + xmin\n      }\n      numbers.map(rescale) filter\
    \ (_ > 0.0f) toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp93pykqit.scala:14:51 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m      numbers.map(rescale) filter (_ > \e[31m0.0f\e[0m)\
    \ toList\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp93pykqit.scala:14:18 --------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m      numbers.map(rescale) filter (_ > \e[31m0.0f\e[0m) toList\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ Found:    \e[1m\e[31m(\e[0mFloat\e[1m\e[31m,\e[0m \e[1m\e[31mFloat\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mFloat\e[0m\e[1m\e[31m)\e[0m\e[1m\e[31m \e\
    [0m=> Float\n\e[31m   |\e[0m                  Required: Float => Float\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if(numbers.isEmpty)\n            numbers\n\
    \        else {\n            val minNumber = numbers.min\n            val maxNumber\
    \ = numbers.max\n            val diff = maxNumber - minNumber\n            val\
    \ zeroPoint = maxNumber - diff * 0.5\n            val newNumbers = numbers map\
    \ (n => (n - minNumber) / (maxNumber - minNumber))\n            newNumbers map\
    \ { n => if (n < 0.0) zeroPoint else n}\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7i8acqoc.scala:17:47\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            newNumbers map {\
    \ \e[36mn\e[0m => \e[33mif\e[0m (n < \e[31m0.0\e[0m) zeroPoint \e[33melse\e[0m\
    \ n}\n\e[31m\e[31m   |\e[0m                                               ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Found:    (zeroPoint\
    \ : Double)\n\e[31m   |\e[0m                                          Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var minVal = numbers.min\n       \
    \ var maxVal = numbers.max\n        var min = math.min(minVal, maxVal)\n     \
    \   var max = math.max(minVal, maxVal)\n        numbers.map(x=>((x-min)/(max-min)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.sortWith(_ < _)\n        val\
    \ start = 0\n        val end = 1\n        var min = numbers(0)\n        var max\
    \ = numbers(0)\n        var lastNum = 0\n        for (i <- 0 until numbers.size)\
    \ {\n            val currentNum = numbers(i)\n            if (currentNum < min)\
    \ {\n                min = currentNum\n            } else if (currentNum > max)\
    \ {\n                max = currentNum\n            }\n            lastNum = numbers(i)\n\
    \        }\n        val range = (min - max) * 0.1\n        val scale = range.toFloat\
    \ / lastNum\n        val newRange = range * scale\n        val newMax = max *\
    \ scale\n        val newMin = min * scale\n        val newNumbers = numbers.map(x\
    \ => x * scale).toList\n        return (newNumbers).sortWith(_ < _)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp27llsem_.scala:22:29\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            lastNum = numbers(i)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    Found:    Float\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.map { n => n / numbers.reduceLeft(_\
    \ + _) }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6qwxe5iv.scala:12)\n\tat Problem.main(tmp6qwxe5iv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val max = numbers.max\n        val\
    \ min = numbers.min\n        val length = numbers.length\n        var i = 0\n\
    \        val scale = new mutable.ListBuffer[Float]()\n        for(n <- numbers){\n\
    \            i += (n - min) / (max - min)\n            scale.append(i)\n     \
    \   }\n        scale.map(_.toFloat)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_eiy_u2y.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mscale\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mFloat\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_eiy_u2y.scala:15:14\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            i += (n - min)\
    \ / (max - min)\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = math.min(numbers.head)\n\
    \        var max = math.max(numbers.last)\n        var sum = numbers.reduceLeft(_+_)\n\
    \        if (sum == 0.0f)\n            numbers = numbers: List[Float]()\n    \
    \    else\n            numbers = numbers.map( x => x/sum).toList\n        (min,\
    \ max) :: numbers\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpddmik1nc.scala:13:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            numbers = numbers: \e[35mList\e[0m[\e[35mFloat\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                 end of statement expected but\
    \ '(' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpddmik1nc.scala:9:23 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = math.min(numbers.head)\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers.head\
    \ : => Float))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpddmik1nc.scala:10:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e\
    [0m \e[36mmax\e[0m = math.max(numbers.last)\n\e[31m\e[31m   |\e[0m           \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with\
    \ types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float,\
    \ y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m\
    \ (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers.last : => Float))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val mins = numbers.min\n        val\
    \ maxs = numbers.max\n        numbers.map {\n            case x if (x > maxs)\
    \ x else (x - mins).toFloat/maxs.toFloat\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4uqehang.scala:12:35 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m (x > maxs)\
    \ x \e[33melse\e[0m (x - mins).toFloat/maxs.toFloat\n\e[31m\e[31m   |\e[0m   \
    \                                ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                 expression expected but \e[31melse\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4uqehang.scala:12:33 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m (x > maxs)\
    \ x \e[33melse\e[0m (x - mins).toFloat/maxs.toFloat\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value\
    \ x is not a member of Boolean\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4uqehang.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        }\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m    \
    \    Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.min.toFloat + numbers.map(x\
    \ => x / (numbers.maxOrMin))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp276506if.scala:9:60 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.min.toFloat + numbers.map(\e[36mx\e[0m\
    \ => x / (numbers.maxOrMin))\n\e[31m\e[31m  |\e[0m                           \
    \                         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mvalue maxOrMin\
    \ is not a member of List[Float] - did you mean numbers.maxOption?\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp276506if.scala:9:28 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.min.toFloat + numbers.map(\e[36mx\e[0m\
    \ => x / (numbers.maxOrMin))\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m+\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m  |\e[0m  (x:\
    \ Double): Double\n\e[31m  |\e[0m  (x: Float): Float\n\e[31m  |\e[0m  (x: Long):\
    \ Float\n\e[31m  |\e[0m  (x: Int): Float\n\e[31m  |\e[0m  (x: Char): Float\n\e\
    [31m  |\e[0m  (x: Short): Float\n\e[31m  |\e[0m  (x: Byte): Float\n\e[31m  |\e\
    [0m  (x: String): String\n\e[31m  |\e[0m match arguments (List[Nothing])\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009677
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val scale = (max - min) / (numbers.size - 1)\n  \
    \      numbers.map(n => n + (min - max) / numbers.size * (n - max))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpow0ubvyz.scala:15)\n\tat Problem.main(tmpow0ubvyz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min: Float = numbers.min\n   \
    \     val max: Float = numbers.max\n        val rescaled: List[Float] = numbers.map(x\
    \ => x.toFloat * max - min)\n        (rescaled.sum, rescaled)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwpxv05k2.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        (rescaled.sum, rescaled)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mFloat\e[0m\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0mList[Float]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Float]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.size // number of\
    \ elements input\n        val min = numbers.min  // smallest number\n        val\
    \ max = numbers.max  // largest number\n        val range = max - min  // difference\
    \ between smallest and largest number\n        val scaledRange = range / n  //\
    \ scale of largest to smallest number\n        val scaledNumbers = (0 until n)\
    \ map {\n            i => numbers[i] + min * scaledRange\n        }\n        scaledNumbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9f6072wg.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[36mi\e[0m => numbers[\e[35mi\e[0m] + min\
    \ * scaledRange\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: type i\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9f6072wg.scala:17:8 ---------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        scaledNumbers\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (scaledNumbers : IndexedSeq[Nothing])\n\e\
    [31m   |\e[0m        Required: List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val rescale = (min - max) / (1.0f - min)\n      \
    \  numbers.map {\n            n => (n - min) * rescale + max\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkq8ly2ur.scala:17)\n\tat Problem.main(tmpkq8ly2ur.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Convert all numbers to their square\
    \ root\n        val squareRoot = numbers.map( x=>math.sqrt(x).toFloat) \n    \
    \    // Convert the result from square root to range 0 to 1\n        val rescaled\
    \ = squareRoot.map( x=>x/math.sqrt(numbers.toList.length))\n        // Convert\
    \ the result from range 0 to 1 to range 0 to 1\n        rescaled.map( x=>x*numbers.length).zipWithIndex.foldLeft((List[Float](0f),List[Float](0f)))\
    \ { \n            (a,i)=>(a._1+i._1,a._2+i._2) \n        }._1.reverse ++ rescaled\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdt6k91df.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            (\e[36ma\e[0m,\e[36mi\e[0m)=>(a._1+i._1,a._2+i._2)\
    \ \n\e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Float], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdt6k91df.scala:15:34\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            (\e[36ma\e[0m,\e\
    [36mi\e[0m)=>(a._1+i._1,a._2+i._2) \n\e[31m\e[31m   |\e[0m                   \
    \           ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Float],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdt6k91df.scala:16:24 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        }._1.reverse ++ rescaled \n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Found:    (rescaled : List[Double])\n\e[31m   |\e[0m                    \
    \    Required: IterableOnce[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009680
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty) List(0.0f)\n\
    \        else if (numbers.head == numbers.last) List(1.0f)\n        else numbers.map(n\
    \ => n - math.min(numbers)).map(n => n / math.max(numbers))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpff9s6jyp.scala:11:39 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33melse\e[0m numbers.map(n => n - math.min(numbers)).map(n\
    \ => n / math.max(numbers))\n\e[31m\e[31m   |\e[0m                           \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with\
    \ types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float,\
    \ y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m\
    \ (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpff9s6jyp.scala:11:64 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33melse\e[0m numbers.map(n => n - math.min(numbers)).map(n\
    \ => n / math.max(numbers))\n\e[31m\e[31m   |\e[0m                           \
    \                                   ^^^\e[0m\n\e[31m   |\e[0mvalue / is not a\
    \ member of Nothing, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpff9s6jyp.scala:11:71 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33melse\e[0m numbers.map(n => n - math.min(numbers)).map(n\
    \ => n / math.max(numbers))\n\e[31m\e[31m   |\e[0m                           \
    \                                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e["
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.foldLeft((numbers.min - numbers.max)/(numbers.max\
    \ - numbers.min)) { (x, y) =>\n            x + y * (y - x).toFloat\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1jtvmvs7.scala:9:82\
    \ ---------------------\e[0m\e[0m\n\e[31m 9 |\e[0m        numbers.foldLeft((numbers.min\
    \ - numbers.max)/(numbers.max - numbers.min)) { (\e[36mx\e[0m, \e[36my\e[0m) =>\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Float\n\e\
    [31m   |\e[0m        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mFloat\e[1m\e\
    [32m]\e[0m\n\e[31m10 |\e[0m            x + y * (y - x).toFloat\n\e[31m11 |\e[0m\
    \        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.length\n        val\
    \ m = numbers.min\n        val M = numbers.max\n\n        val min = M - m \n \
    \       val max = M - n / 2\n        val range = (max - min) / n\n\n        (0\
    \ to n).map(i => {\n            (min + range * (i + n - 1)) - n / 2\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp068sjpos.scala:17:20\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        (\e[31m0\e[0m to n).map(\e\
    [36mi\e[0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:\
    \    IndexedSeq[Float]\n\e[31m   |\e[0m        Required: List[Float]\n\e[31m18\
    \ |\e[0m            (min + range * (i + n - \e[31m1\e[0m)) - n / \e[31m2\e[0m\n\
    \e[31m19 |\e[0m        })\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009682
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sum : Float = numbers.reduce(_\
    \ + _)\n        numbers.map(n => n / sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphp5w6ite.scala:13)\n\tat Problem.main(tmphp5w6ite.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009684
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n      val minNumber = numbers.min\n      val\
    \ maxNumber = numbers.max\n      numbers.map {\n        n => (n - minNumber) /\
    \ (maxNumber - minNumber)\n      }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // The largest element should be 1\
    \ and the smallest element should be 0\n        var min = 0f\n        var max\
    \ = 0f\n        numbers.foreach{ elem =>\n            if(elem > max) {\n     \
    \           max = elem\n            }\n            if(elem < min) {\n        \
    \        min = elem\n            }\n        }\n\n        val rescaledNumbers =\
    \ numbers.map(elem => max + (elem - min))\n        return rescaledNumbers\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv8r5g514.scala:25)\n\tat Problem.main(tmpv8r5g514.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.map(x => (x - numbers.min)\
    \ / (numbers.max - numbers.min))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val newMin = math.min(numbers.head,\
    \ numbers.last)\n        val newMax = math.max(numbers.head, numbers.last)\n \
    \       var sum = 0.0f\n        var i = 0\n        while (i < numbers.length &&\
    \ numbers(i) < newMin)\n            sum += numbers(i)\n        while (i < numbers.length\
    \ && numbers(i) > newMax)\n            sum += numbers(i)\n        while (i < numbers.length\
    \ && numbers(i) == newMin)\n            sum += numbers(i)\n        while (i <\
    \ numbers.length && numbers(i) == newMax)\n            sum += numbers(i)\n   \
    \     while (i < numbers.length)\n            numbers(i) /= sum\n        numbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz1nd8a_l.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            numbers(i) /= sum\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a\
    \ member of Float - did you mean Float.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.size>1, \"List must\
    \ contain at least two elements\")\n        val sortedNumbers = numbers.sortBy(math.abs)\n\
    \        val unitSize = sortedNumbers.last.toFloat\n        val scaledNumbers\
    \ = sortedNumbers.map{x=>(x/unitSize).toFloat}\n        scaledNumbers\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcgo1l1a0.scala:16)\n\tat Problem.main(tmpcgo1l1a0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def linear(number : Float) : Float\
    \ = {\n            number / numbers.max\n        }\n        val result = numbers.map(linear).toList\n\
    \        result.min match {\n            case 0.0f => 0.0f\n            case _\
    \  => result.max\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk3dp0y8a.scala:20)\n\tat Problem.main(tmpk3dp0y8a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = math.min(numbers.map(_.toFloat))\n\
    \        val max = math.max(numbers.map(_.toFloat))\n        numbers.map(x =>\
    \ (x - min)/(max - min))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpwg8atw31.scala:9:23 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers.map(_.toFloat))\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments (List[Float])\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpwg8atw31.scala:10:23 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = math.max(numbers.map(_.toFloat))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (List[Float])\n2 errors found\n"
  stdout: ''
  timestamp: 1660009684
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val total = numbers.reduceLeft( (x,\
    \ y) => x + y)\n        val rescale = (1.0f / total).toFloat\n        numbers.map(\
    \ x => x * rescale)\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2r71k2s.scala:14)\n\tat Problem.main(tmpl2r71k2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var smallest : Float = 0.0\n     \
    \   var largest : Float = 1.0\n        numbers foreach {\n            value =>\
    \ {\n                val valueInRange = (value - smallest) / (largest - smallest)\n\
    \                if (valueInRange < 0.0f) smallest -= value\n                if\
    \ (valueInRange > 1.0f) largest += value\n            }\n        }\n        List(smallest.toFloat,\
    \ largest.toFloat)\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpghtuvrc7.scala:21)\n\tat Problem.main(tmpghtuvrc7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Compute the linear transform of\
    \ the list\n        // >>> transform(numbers)\n        val values = numbers.map(_/numbers.size).toList.sortBy(_*numbers.size).reverse\n\
    \n        // If the smallest number is 0, remove it from the list as the smallest\
    \ number is 0\n        // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n        // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat))\n        if (values(0) == 0) values.remove(0)\n\
    \n        // If the largest number is 1, remove it from the list as the largest\
    \ number is 1\n        // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n        // (List[Float](1.0f.toFloat,\
    \ 1.0f.toFloat, 1.0f.toFloat, 1.0f.toFloat))\n        if (values(values.size-1)\
    \ == 1) values.remove(values.size - 1)\n\n        // Return the scaled list\n\
    \        // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat)))\n        // (List[Float](0.0f.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat))\n        values\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbmpr44jw.scala:16:35 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (values(\e[31m0\e[0m) == \e[31m0\e\
    [0m) values.remove(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member of List[Float]\
    \ - did you mean values.reduce?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbmpr44jw.scala:21:47\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (values(values.size-\e\
    [31m1\e[0m) == \e[31m1\e[0m) values.remove(values.size - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                        ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue remove is not a member of List[Float], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val ranges = numbers.map(x => x -\
    \ Math.min(x, Math.max(x, 0)))\n        val scale = ranges.min\n        val ranges2\
    \ = ranges.map(x => (x - scale).abs)\n        ranges2.take(1).map(x => x / scale).reduceLeft((x,\
    \ y) => x + y)\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7gu0iwvy.scala:12:54\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        ranges2.take(\e[31m1\e\
    [0m).map(\e[36mx\e[0m => x / scale).reduceLeft((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x + y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Float\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mFloat\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val nMin = min(numbers)\n        val\
    \ nMax = max(numbers)\n        numbers.map(x => (x - nMin) / (nMax - nMin))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqx3f3wrf.scala:9:19 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mnMin\e[0m = min(numbers)\n\
    \e[31m\e[31m  |\e[0m                   ^^^\e[0m\n\e[31m  |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\e[31m  |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpqx3f3wrf.scala:10:19 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mnMax\e[0m = max(numbers)\n\
    \e[31m\e[31m   |\e[0m                   ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val result = numbers(0)\n        var\
    \ min = 0f;\n        var max = numbers\n        var i = 1;\n        while (i <\
    \ numbers.size) {\n            if (numbers(i) < min) {\n                min =\
    \ numbers(i);\n            }\n            if (numbers(i) > max) {\n          \
    \      max = numbers(i);\n            }\n            i += 1\n        }\n     \
    \   val range = max - min;\n        if (range <= 0) {\n            return List(result);\n\
    \        }\n        val newRange = range / numbers.size;\n        val range =\
    \ max - min;\n        val scale = newRange / range;\n        var newNumbers: List[Float]\
    \ = numbers.map(x => x * scale).toList\n        newNumbers.sortWith((x,y) => x\
    \ - y)\n        newNumbers\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5oxl0ddl.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mrange\e[0m = max - min;\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrange\
    \ is already defined as \e[33mvalue\e[0m \e[35mrange\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5oxl0ddl.scala:17:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e\
    [0m (numbers(i) > max) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m>\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long):\
    \ Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\
    \e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m\
    \   |\e[0mmatch arguments ((max : List[Float]))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5oxl0ddl.scala:18:29 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m                max = numbers(i);\n\e[31m\e[31m   |\e[0m             \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:    Float\n\
    \e[31m   |\e[0m                      Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mFloat\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp5oxl0ddl.scala:22:24 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mrange\e[0m = max - min;\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of List[Float],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numer"
  stdout: ''
  timestamp: 1660009690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val firstNumber = numbers(0)\n   \
    \     var scaleFactor = firstNumber\n        numbers.foreach { number => scaleFactor\
    \ = scaleFactor * number }\n        val scaled = numbers.map(_/scaleFactor).map(math.pow(_,2)).map(math.pow(_,-1))\n\
    \        numbers.zip(scaled).map { case (x, y) => x + (y-x)/scaleFactor }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9awljwzm.scala:13:49\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        numbers.zip(scaled).map\
    \ { \e[33mcase\e[0m (x, y) => x + (y-x)/scaleFactor }\n\e[31m\e[31m   |\e[0m \
    \                                                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                 Found:    Double\n\
    \e[31m   |\e[0m                                                 Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.length > 0)\n    \
    \    numbers.map(n => (if (n < 0.0) 0.0f else 1.0f)/n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyuqd9e52.scala:13)\n\tat Problem.main(tmpyuqd9e52.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var scale = 0.0f\n        var minVal\
    \ = math.min(numbers)\n        var maxVal = math.max(numbers)\n        if (minVal\
    \ == 0.0f && maxVal == 0.0f) {\n            numbers.length match {\n         \
    \       case 0    => scales\n                case _    => throw new Exception(\"\
    No number in list\")\n            }\n        } else {\n            numbers.foreach(x\
    \ => {\n                scale = 1.0f - math.pow(x - minVal, 2)\n            })\n\
    \        }\n        numbers.map(_ * scale).sortBy(_)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpntw3gvhy.scala:10:26 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mminVal\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpntw3gvhy.scala:11:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e\
    [0m \e[36mmaxVal\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m             \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpntw3gvhy.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m    => scales\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: scales\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpntw3gvhy.scala:19:24 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                scale = \e[31m1.0f\e[0m - math.pow(x\
    \ - minVal, \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    Double\n\e[31m   |\e[0m\
    \                        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpntw3gvhy.scala:22:40 ------------------------------"
  stdout: ''
  timestamp: 1660009690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sortedNumbers = numbers.sortWith(_\
    \ <=> _) // sorted numbers (smallest first, largest last)\n        val zeroed\
    \ = sortedNumbers.takeWhile(x => x < 0f)\n        val scaled  = sortedNumbers.drop(zeroed.length)\n\
    \        scaled.map(_ / zeroed.min).reverse // reverse to get largest to smallest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo655cy_k.scala:9:47 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36msortedNumbers\e[0m = numbers.sortWith(_\
    \ <=> _) \e[34m// sorted numbers (smallest first, largest last)\e[0m\n\e[31m\e\
    [31m  |\e[0m                                             ^^^^^\e[0m\n\e[31m  |\e\
    [0m                 value <=> is not a member of Float - did you mean _$1.<=?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sum : Float = 0.0f\n        numbers.foreach\
    \ { x =>\n            sum += x\n        }\n        if (sum != 0.0f) {\n      \
    \      val invSum = 1.0f / sum\n            numbers.foreach { x =>\n         \
    \       x *= invSum\n            }\n        }\n        numbers\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfszrme74.scala:11:16 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            sum += x\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Float\
    \ - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfszrme74.scala:16:18\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                x *= invSum\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m              \
    \  value *= is not a member of Float - did you mean x.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // 1. Calculate the sum of all numbers\
    \ \n        val sum = numbers.reduce((x, y) => x + y)\n        // 2. Normalize\
    \ all numbers by dividing each number by its sum\n        val normalized = numbers.map(x\
    \ => x / sum)\n        // 3. Return the normalized list \n        return normalized\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplyordabt.scala:17)\n\tat Problem.main(tmplyordabt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNumber = math.min(numbers)\n\
    \        val maxNumber = math.max(numbers)\n        var rescaledList = scala.collection.mutable.ListBuffer.empty[Float]\n\
    \        var i = 1\n        rescaledList += numbers(0)\n        while (i < numbers.size)\
    \ {\n            rescaledList += (numbers(i) - minNumber) / (maxNumber - minNumber)\n\
    \            i += 1\n        }\n        rescaledList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmph_urivla.scala:9:29 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mminNumber\e[0m = math.min(numbers)\n\
    \e[31m\e[31m  |\e[0m                        ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmph_urivla.scala:10:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxNumber\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m          \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_urivla.scala:18:8 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        rescaledList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Found:    (rescaledList : scala.collection.mutable.ListBuffer[Float])\n\
    \e[31m   |\e[0m   Required: List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var smallest = numbers.min\n     \
    \   var largest = numbers.max\n        var rescaledNumbers = scala.collection.mutable.ArrayBuffer.empty[Float]\n\
    \        for (n <- numbers) {\n            rescaledNumbers = rescaledNumbers :+\
    \ n / largest - n / smallest\n        }\n        rescaledNumbers\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxya_z880.scala:15:8\
    \ ---------------------\e[0m\e[0m\n\e[31m15 |\e[0m        rescaledNumbers\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mFound:    (rescaledNumbers\
    \ : scala.collection.mutable.ArrayBuffer[Float])\n\e[31m   |\e[0mRequired: List[Float]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty) numbers\n   \
    \     else {\n            val result = numbers.map{ x => (x - numbers.min) / (numbers.max\
    \ - numbers.min) }\n            val minMax = numbers.min, numbers.max\n      \
    \      if (minMax != 0) {\n                result.map{ x => (x * minMax._2) }.maxBy(numbers.max)\
    \ - result.minBy(numbers.min)\n            } else {\n                result.maxBy(numbers.max)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7brl14ko.scala:12:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mminMax\e[0m = numbers.min,\
    \ numbers.max\n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\
    \e[31m   |\e[0m                                 end of statement expected but\
    \ ',' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7brl14ko.scala:14:45\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m                result.map{\
    \ \e[36mx\e[0m => (x * minMax._2) }.maxBy(numbers.max) - result.minBy(numbers.min)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                      value _2 is not a member of\
    \ Float\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7brl14ko.scala:14:85\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                result.map{ \e\
    [36mx\e[0m => (x * minMax._2) }.maxBy(numbers.max) - result.minBy(numbers.min)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                       Found:    (ord : Float)\n\e[31m   |\e[0m             \
    \                                  Required: Ordering[Float]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7brl14ko.scala:16:29 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                result.maxBy(numbers.max)\n\e[31m\e[31m\
    \   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m               \
    \              Found:    (ord : Float)\n\e[31m   |\e[0m                      \
    \       Required: Ordering[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sumOfSquares = numbers.reduce((a,\
    \ b) => a + b * b)\n        val min = numbers.min\n        val max = numbers.max\n\
    \        val scale = 1.0f / Math.sqrt(sumOfSquares)\n        numbers.map(x =>\
    \ min * scale + x * scale)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa1pml5v0.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        numbers.map(\e[36mx\e\
    [0m => min * scale + x * scale)\n\e[31m\e[31m   |\e[0m                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Found:\
    \    Double\n\e[31m   |\e[0m                         Required: Float\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = sys.maxFloat\n        var\
    \ max = 0.0f\n\n        // This loop is O(n)\n        for (number : Float <- numbers)\
    \ {\n            min = Math.min(min, number)\n            max = Math.max(max,\
    \ number)\n        }\n\n        // This loop is O(n)\n        for (number : Float\
    \ <- numbers) {\n            number = ((number - min) / (max - min)) - 0.5f\n\
    \        }\n\n        numbers\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgbpyz6wg.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = sys.maxFloat\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \            value maxFloat is not a member of sys\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmpgbpyz6wg.scala:20:19 -----------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m            number = ((number - min) / (max - min)) - \e[31m0.5f\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val number\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009695
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val range = numbers.map(_.toInt).max\n\
    \        numbers.map(_.toInt / range)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu1gd9nby.scala:15)\n\tat Problem.main(tmpu1gd9nby.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val m = numbers.min\n        val n\
    \ = numbers.max\n        numbers.map((number: Float) => number*(m-n)/(m+n))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzcx5rjau.scala:14)\n\tat Problem.main(tmpzcx5rjau.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009699
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val numMin = numbers.min\n       \
    \ val numMax = numbers.max\n        val numRange = numMax - numMin\n        if\
    \ (numRange == 0.0f) numbers else numbers map { x => (x - numMin) / numRange }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009699
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.last\n        for (i<- numbers) \n            if (min > i) \n\
    \                min = i\n            if (max < i) \n                max = i\n\
    \        numbers.map(x => (x - min) / (max - min))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009699
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // create empty list\n        val\
    \ result = numbers.map { n =>\n            // check min and max\n            if\
    \ (n >= 1.0) 1.0f - n\n            else n\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpccz4n16q.scala:18)\n\tat Problem.main(tmpccz4n16q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min: Float = math.min(numbers.minOrNull,\
    \ numbers.min.minOrNull)\n        val max: Float = math.max(numbers.maxOrNull,\
    \ numbers.max.maxOrNull)\n        val newNumbers: List[Float] = List(min, (numbers\
    \ - min) / (max - min), max)\n        return newNumbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc480bq5.scala:9:42 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m: \e[35mFloat\e[0m\
    \ = math.min(numbers.minOrNull, numbers.min.minOrNull)\n\e[31m\e[31m  |\e[0m \
    \                                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m     \
    \                       value minOrNull is not a member of List[Float]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmprc480bq5.scala:9:65 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m: \e[35mFloat\e[0m\
    \ = math.min(numbers.minOrNull, numbers.min.minOrNull)\n\e[31m\e[31m  |\e[0m \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                                  value minOrNull is not a member\
    \ of Float\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc480bq5.scala:10:42\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m: \e[35mFloat\e[0m = math.max(numbers.maxOrNull, numbers.max.maxOrNull)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value maxOrNull is not a member of List[Float]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc480bq5.scala:10:65 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m: \e[35mFloat\e\
    [0m = math.max(numbers.maxOrNull, numbers.max.maxOrNull)\n\e[31m\e[31m   |\e[0m\
    \                                                     ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value maxOrNull is not a member\
    \ of Float\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc480bq5.scala:11:57\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mnewNumbers\e[0m: \e[35mList\e[0m[\e[35mFloat\e[0m] = List(min, (numbers -\
    \ min) / (max - min), max)\n\e[31m\e[31m   |\e[0m                            \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of\
    \ List[Float], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fi"
  stdout: ''
  timestamp: 1660009700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        numbers.map(x => (x - min) / (max - min))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = math.min(numbers).toFloat\n\
    \        val max = math.max(numbers).toFloat\n        numbers.map(num => (num\
    \ - min) / (max - min))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpe47yb2zo.scala:9:23 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers).toFloat\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpe47yb2zo.scala:10:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers).toFloat\n\e[31m\e[31m   |\e[0m        \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val unitRange = numbers.min/numbers.max\n\
    \        val zeroPoint = numbers.min\n        val onePoint = numbers.max\n   \
    \     val result = numbers.map((x: Float) => { ((x - zeroPoint) / unitRange).toFloat\
    \ + onePoint })\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv_1vface.scala:16)\n\tat Problem.main(tmpv_1vface.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def scale(x: Float, factor: Float)\
    \ : Float = {\n            val oldX = x\n            x -= 1.0f\n            x\
    \ /= factor\n            x += 1.0f\n            x - oldX\n        }\n        numbers.foldLeft(List[Float]()){\
    \ (res, num) => res :+ scale(num, num.toFloat) }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsw8ri_bk.scala:11:14 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            x -= \e[31m1.0f\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Float - did you mean x.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsw8ri_bk.scala:12:14\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m            x /= factor\n\
    \e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value /=\
    \ is not a member of Float - did you mean x.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpsw8ri_bk.scala:13:14 ------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m            x += \e[31m1.0f\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Float - did you mean\
    \ x.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.map { n =>\n            val\
    \ diff = (n - min(numbers).toFloat) / (max(numbers) - min(numbers))\n        \
    \    (diff * 1.0f + 1.0f - n)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmppkg1zl12.scala:10:28 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mdiff\e[0m = (n - min(numbers).toFloat)\
    \ / (max(numbers) - min(numbers))\n\e[31m\e[31m   |\e[0m                     \
    \       ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNum = numbers.min\n       \
    \ val maxNum = numbers.max\n        var nums = numbers.toList\n        nums.map(num\
    \ => num * (maxNum - minNum) + minNum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphhl95r5x.scala:15)\n\tat Problem.main(tmphhl95r5x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.nonEmpty)\n      \
    \  require(numbers.forall(_ > 0.0f))\n        require(numbers.forall(_ < 1.0f))\n\
    \n        val smallestNonZero = numbers.minBy(_ != 0.0f)\n        val maxNonZero\
    \ = numbers.maxBy(_ != 0.0f)\n        var newNums = numbers.map(_ / smallestNonZero).map(_\
    \ * maxNonZero)\n        newNums = newNums.drop(1).filter(_ != 0.0f)\n       \
    \ newNums.sortWith(_ > _) // Sort the list so that the smallest value is 0, largest\
    \ is 1\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: requirement failed\n\tat scala.Predef$.require(Predef.scala:324)\n\
    \tat Problem$.rescaleToUnit(tmp6mqryrtv.scala:11)\n\tat Problem$.main(tmp6mqryrtv.scala:20)\n\
    \tat Problem.main(tmp6mqryrtv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009703
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.map( n => (n%1.0f).toFloat\
    \ / 1.0f )\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyqo61_9u.scala:12)\n\tat Problem.main(tmpyqo61_9u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val range = max - min\n        val scaledNumbers\
    \ = numbers.map(n => { val scaled = n.toFloat / range }); \n        scaledNumbers.map(_\
    \ * range + min)\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpah83qrtw.scala:13:28 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        scaledNumbers.map(_ * range + min)\n\e[31m\e\
    [31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0mvalue * is not\
    \ a member of Unit, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.minBy(_.toFloat).toFloat /:\
    \ numbers.map(_.toFloat) (_ / _) (_ * 1.0f).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpgvbwy3oh.scala:9:68 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.minBy(_.toFloat).toFloat /: numbers.map(_.toFloat)\
    \ (_ / _) (_ * \e[31m1.0f\e[0m).toList\n\e[31m\e[31m  |\e[0m                 \
    \                                                   ^\e[0m\n\e[31m  |\e[0m   \
    \  Missing parameter type\n\e[31m  |\e[0m\n\e[31m  |\e[0m     I could not infer\
    \ the type of the parameter _$3 of expanded function:\n\e[31m  |\e[0m     (_$3,\
    \ _$4) => _$3 / _$4.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpgvbwy3oh.scala:9:72\
    \ ------------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        numbers.minBy(_.toFloat).toFloat\
    \ /: numbers.map(_.toFloat) (_ / _) (_ * \e[31m1.0f\e[0m).toList\n\e[31m\e[31m\
    \  |\e[0m                                                                    \
    \    ^\e[0m\n\e[31m  |\e[0m     Missing parameter type\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m     I could not infer the type of the parameter _$4 of expanded function:\n\
    \e[31m  |\e[0m     (_$3, _$4) => _$3 / _$4.\n2 errors found\n"
  stdout: ''
  timestamp: 1660009699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val ns = numbers.toList\n        val\
    \ smallestIndex = ns.head.toInt\n        var scaledNumbers = ns map { n =>\n \
    \           if(n >= smallestIndex) 0.0f - n else 1.0f - n\n        }\n       \
    \ scala.util.Sorting.quickSort(scaledNumbers)\n        scaledNumbers\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmps2v6whcb.scala:14:27 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        scala.util.Sorting.quickSort(scaledNumbers)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mquickSort\e[0m in\
    \ \e[33mobject\e[0m \e[35mSorting\e[0m with types\n\e[31m   |\e[0m [K](a: Array[K])(\e\
    [33mimplicit \e[0mevidence$1: Ordering[K]): Unit\n\e[31m   |\e[0m (a: Array[Float]):\
    \ Unit\n\e[31m   |\e[0m (a: Array[Int]): Unit\n\e[31m   |\e[0m (a: Array[Double]):\
    \ Unit\n\e[31m   |\e[0mmatch arguments ((scaledNumbers : List[Float]))\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sortedNumbers = numbers.sorted\n\
    \        val min = sortedNumbers.head\n        val max = sortedNumbers.last\n\
    \        if (max - min < 1e-5f)\n            numbers : List[Float]\n        else\n\
    \            sortedNumbers.map((n / max - min).toFloat * 2.0f - 1.0f).toList ::\
    \ numbers.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1q2mn81b.scala:15:31 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            sortedNumbers.map((n / max - min).toFloat\
    \ * \e[31m2.0f\e[0m - \e[31m1.0f\e[0m).toList :: numbers.reverse\n\e[31m\e[31m\
    \   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m             \
    \                  Not found: n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var smallest = 0f\n        var largest\
    \ = 1f\n        var range = 0f\n        numbers foreach { n =>\n            var\
    \ nn = n * n\n            if (nn == 0) {\n                return\n           \
    \ }\n            if (nn == n) {\n                smallest = math.min(n, smallest)\n\
    \                largest = math.max(n, largest)\n                range = math.max(range,\
    \ n)\n            } else {\n                smallest = math.min(smallest, n)\n\
    \                largest = math.max(largest, n)\n                range = math.max(range,\
    \ nn)\n            }\n        }\n        if (smallest == 0f && largest == 1f)\
    \ {\n            return\n        }\n        if (smallest == 1f) {\n          \
    \  smallest = 0f\n        } else {\n            smallest = smallest * (range /\
    \ smallest + 1f)\n        }\n        if (largest == 0f) {\n            largest\
    \ = 1f\n        } else {\n            largest = largest * (range / largest + 1f)\n\
    \        }\n        val rangeScaled = range / 2f\n        numbers map { n =>\n\
    \            if (smallest == 0f) {\n                if (n < smallest) {\n    \
    \                0f\n                } else {\n                    ((n - smallest)\
    \ * rangeScaled + smallest)\n                }\n            } else {\n       \
    \         if (n < smallest) {\n                    ((n - smallest) * rangeScaled\
    \ + smallest)\n                } else {\n                    if (n == largest)\
    \ {\n                        (largest + 1f)\n                    } else {\n  \
    \                      ((n - smallest) * rangeScaled + smallest)\n           \
    \         }\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp2kl_x73.scala:15:16\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                \e[33mreturn\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \         Found:    Unit\n\e[31m   |\e[0m                Required: List[Float]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp2kl_x73.scala:28:12\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mreturn\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    Unit\n\e[31m   |\e[0m            Required: List[Float]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val numberRange = numbers.last.toDouble\
    \ - numbers.head.toDouble\n        val range = numberRange.toFloat\n        var\
    \ result: List[Float] = List()\n        val min = (numbers.head + numbers.last)\
    \ / 2.0\n        val max = (min * range).roundToInt\n        for(number <- numbers)\
    \ {\n            if(number > max) result = result ::: (List(0.0f.toFloat))\n \
    \           if(number < min) result = result ::: (List((min.toFloat - min).roundToInt))\n\
    \            else result = result ::: (List(number.toFloat))\n        }\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsd8780s2.scala:13:32 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = (min * range).roundToInt\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  value roundToInt is not a member of Double\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpsd8780s2.scala:16:75 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m(number < min) result = result\
    \ ::: (List((min.toFloat - min).roundToInt))\n\e[31m\e[31m   |\e[0m          \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value roundToInt is not a member\
    \ of Double\n2 errors found\n"
  stdout: ''
  timestamp: 1660009705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val scaled = numbers.map {x => x - min/(max - min)}.sorted\n\
    \        scaled.inits.map(_.toFloat).reverse.take(numbers.size).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsp3fmkle.scala:12:27 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        scaled.inits.map(_.toFloat).reverse.take(numbers.size).toList\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toFloat is not a member of List[Float @uncheckedVariance], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def makeLinear(table : List[Float])\
    \ : List[Float] = { //make t between 0-1\n            val min = math.min(table)\n\
    \            val max = math.max(table)\n            val t = (max - min) / (1.0f\
    \ - min)\n            (table.toFloat * t).toFloat\n        }\n        val min\
    \ = math.min(numbers)\n        val max = math.max(numbers)\n        var i = 0\n\
    \        var j = 0\n        var t = makeLinear(List(1.0f - min, max))\n      \
    \  while(i < numbers.length && j < numbers.length){ //loop over all the numbers\
    \ in the list\n            if(numbers[i] < min){\n                t = makeLinear(List(numbers[i]\
    \ + min, min))\n                i += 1\n            }\n            else if(numbers[i]\
    \ > max){\n                t = makeLinear(List(min, numbers[i] - max))\n     \
    \           j += 1\n            }\n            else{\n                i += 1\n\
    \                j += 1\n            }\n        }\n        while(j < numbers.length){\n\
    \            t = makeLinear(List(numbers[j], min))\n            j += 1\n     \
    \   }\n        t\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqfe366c5.scala:10:27 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = math.min(table)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((table : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqfe366c5.scala:11:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(table)\n\e[31m\e[31m   |\e[0m                  \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((table : List[Float]))\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpqfe366c5.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            (table.toFloat * t).toFloat\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toFloat is not\
    \ a member of List[Float], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpqfe366c5.scala:15:23 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmetho"
  stdout: ''
  timestamp: 1660009706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val unitNumbers = numbers.filter(x\
    \ => x != 0f).toList\n        if (unitNumbers.isEmpty) {\n            return List(0f)\n\
    \        } else {\n            val nums = List(1f, unitNumbers.min)(0f)\n    \
    \        val diff = unitNumbers.max - nums.max\n            nums :: List(unitNumbers.min.toFloat)\
    \ + (diff / unitNumbers.size)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpii6tdqgl.scala:13:49\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e\
    [36mnums\e[0m = List(\e[31m1f\e[0m, unitNumbers.min)(\e[31m0f\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                 ^^\e[0m\n\e[31m\
    \   |\e[0m                                                Found:    (\e[31m0.0f\e\
    [0m : Float)\n\e[31m   |\e[0m                                                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpii6tdqgl.scala:14:39\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e\
    [0m \e[36mdiff\e[0m = unitNumbers.max - nums.max\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mFloat\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Float\n\e[31m   |\e[0m (x: Int): Float\n\e\
    [31m   |\e[0m (x: Char): Float\n\e[31m   |\e[0m (x: Short): Float\n\e[31m   |\e\
    [0m (x: Byte): Float\n\e[31m   |\e[0mmatch arguments (Float => Float)\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpii6tdqgl.scala:15:50 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            nums :: List(unitNumbers.min.toFloat) + (diff\
    \ / unitNumbers.size)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Float], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = 0\n        var max = Double.PositiveInfinity\n\
    \        for (n <- numbers) {\n            min = math.min(min, n)\n          \
    \  max = math.max(max, n)\n        }\n        // Scale the entire list to range\
    \ [0, 1]\n        val scale = (max - min)/2.0\n        numbers.map(n => n/scale).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_puckd8.scala:12:32\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            min = math.min(min,\
    \ n)\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                Found:    (n : Float)\n\e[31m   |\e[0m    \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpf_puckd8.scala:17:34 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        numbers.map(\e[36mn\e[0m => n/scale).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    List[\e[1m\e[31mDouble\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mFloat\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min : Float = 0.00001\n      \
    \  var max : Float = 1.0\n        numbers.foreach{ x => min = math.min(min, x);\
    \ max = math.max(max, x) }\n        var result = numbers.map { x => (x - min)\
    \ / (max - min) }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz_9rqeng.scala:16)\n\tat Problem.main(tmpz_9rqeng.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val listOfNumbers = numbers.toList\n\
    \        val smallestNumber = listOfNumbers.min\n        val largestNumber = listOfNumbers.max\n\
    \        listOfNumbers.map { x =>\n            x -> math.abs(x - smallestNumber)\
    \ / (largestNumber - smallestNumber)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9v0jphd1.scala:13:12\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            x -> math.abs(x -\
    \ smallestNumber) / (largestNumber - smallestNumber)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mFloat\e\
    [0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0mFloat\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m \
    \           Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.head\n        val\
    \ minNum = numbers.min\n        val maxNum = numbers.max\n        val range =\
    \ maxNum - minNum\n        val range = range / n\n        val min = minNum - range\
    \ * n\n        val max = maxNum + range * n\n        (0 until n).map(_ => min\
    \ + n * _).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpukv2fnbm.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mrange\e[0m = range / n\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrange\
    \ is already defined as \e[33mvalue\e[0m \e[35mrange\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpukv2fnbm.scala:16:17\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        (\e[31m0\e[0m until n).map(_\
    \ => min + n * _).toList\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m\
    \   |\e[0m                 Found:    (n : Float)\n\e[31m   |\e[0m            \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpukv2fnbm.scala:16:39\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        (\e[31m0\e[0m\
    \ until n).map(_ => min + n * _).toList\n\e[31m\e[31m   |\e[0m               \
    \                        ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2\
    \ of expanded function:\n\e[31m   |\e[0m   _$2 => min + n * _$2.\n3 errors found\n"
  stdout: ''
  timestamp: 1660009709
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val range = (numbers.min - numbers.max).toFloat\n\
    \        val length = numbers.size + 1\n        val step = range / length\n  \
    \      numbers.map(x => (x - numbers.min) * step).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr5z62fyo.scala:15)\n\tat Problem.main(tmpr5z62fyo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNum = numbers.min\n       \
    \ val maxNum = numbers.max\n        var scaled: List[Float] = Nil\n        numbers.foreach\
    \ {\n            case num if num == minNum => scaled = scaled.++ Nil\n       \
    \     case num if num == maxNum => scaled = scaled.++ List(maxNum)\n         \
    \   case num if num < minNum => scaled = scaled.++ List((num - minNum) / (maxNum\
    \ - minNum)* maxNum)\n            case num if num > maxNum => scaled = scaled.++\
    \ List((maxNum - num) / (maxNum - minNum)* maxNum)\n            case num => scaled\
    \ = scaled.++ List(num)\n        }\n        return scaled\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpeyxift7m.scala:13:63 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mcase\e[0m num \e[33mif\e[0m num ==\
    \ minNum => scaled = scaled.++ Nil\n\e[31m\e[31m   |\e[0m                    \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                expression expected but \e[31mend of statement\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeyxift7m.scala:14:60\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mcase\e\
    [0m num \e[33mif\e[0m num == maxNum => scaled = scaled.++ List(maxNum)\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue List is not a member of IterableOnce[Float] => List[Float]\
    \ - did you mean IterableOnce[Float] => List[Float].wait?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpeyxift7m.scala:15:59 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m            \e[33mcase\e[0m num \e[33mif\e[0m num < minNum\
    \ => scaled = scaled.++ List((num - minNum) / (maxNum - minNum)* maxNum)\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue List is not a member of IterableOnce[Float] => List[Float]\
    \ - did you mean IterableOnce[Float] => List[Float].wait?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpeyxift7m.scala:16:59 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m num \e[33mif\e[0m num > maxNum\
    \ => scaled = scaled.++ List((maxNum - num) / (maxNum - minNum)* maxNum)\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue List is not a member of IterableOnce[Float] => List[Float]\
    \ - did you mean IterableOnce[Float] => List[Float].wait?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpeyxift7m.scala:17:43 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m num => scaled = scaled.++ List(num)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^\e[0m\n"
  stdout: ''
  timestamp: 1660009711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val maxValue = numbers.max\n     \
    \   val minValue = numbers.min\n        val range = maxValue - minValue\n    \
    \    val scaledNumbers = numbers.map((n) => n * range / numbers.size)\n      \
    \  scaledNumbers.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6av89_4f.scala:16)\n\tat Problem.main(tmp6av89_4f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val range = max - min\n        numbers.map(x => x\
    \ - min / range * 2.0f - 1.0f).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk4ag0u_g.scala:15)\n\tat Problem.main(tmpk4ag0u_g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.size\n        if (n\
    \ == 0) numbersList\n        else {\n            // Scale the first number\n \
    \           val first = numbers.head\n            numbers.head /= (first - numbers.last)\n\
    \            numbers.drop(numbers.size - 1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdsbh7xb4.scala:10:20 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mif\e[0m (n == \e[31m0\e[0m) numbersList\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 Not found: numbersList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdsbh7xb4.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m            numbers.head /= (first - numbers.last)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ /= is not a member of Float - did you mean Float.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009710
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // First, find out the min and max\
    \ elements\n        var min = numbers.min\n        var max = numbers.max\n   \
    \     numbers.foreach(num => {\n            if(num < min) min = num\n        \
    \    if(num > max) max = num\n        })\n        // Now, find the scale factor\n\
    \        var scale = 1.0f / (max - min)\n        // Now, scale it\n        numbers.map(num\
    \ => (num - min) * scale)\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minVal = min(numbers)\n      \
    \  val maxVal = max(numbers)\n        val delta = (maxVal - minVal) / numbers.size\n\
    \        (for (i <- numbers.indices) yield {\n            numbers[i] + delta *\
    \ i\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp55nr1tp0.scala:9:21 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mminVal\e[0m = min(numbers)\n\
    \e[31m\e[31m  |\e[0m                     ^^^\e[0m\n\e[31m  |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\e[31m  |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp55nr1tp0.scala:10:21 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmaxVal\e[0m = max(numbers)\n\
    \e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : List[Float]))\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp55nr1tp0.scala:13:20 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m            numbers[\e[35mi\e[0m] + delta * i\n\e[31m\e[31m   |\e[0m      \
    \              ^\e[0m\n\e[31m   |\e[0m                    Not found: type i\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val n = numbers.head\n        val\
    \ min = numbers.head\n        val max = numbers.last\n        (min until max).map\
    \ { x =>\n            val scaled = (x - min) / (max - min)\n            x.toFloat\
    \ * (scaled * 2).toFloat\n        }.headOption.toList ++ numbers.tail\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdnm6kizd.scala:12:13 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        (min until max).map { \e[36mx\e[0m =>\n\e[31m\e\
    [31m   |\e[0m         ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue until is not a member\
    \ of Float, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mThe following import might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.double2bigDecimal\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.length >= 2, s\"Can't\
    \ rescale to a unit vector with less than two elements. numbers.length=${numbers.length}\"\
    )\n        val length = numbers.head\n        numbers.map { x =>\n           \
    \ x / length\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk6x1556.scala:16)\n\tat Problem.main(tmprk6x1556.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = math.min(numbers.toList.map(_.toFloat))\n\
    \        var max = math.max(numbers.toList.map(_.toFloat))\n        if (min ==\
    \ 0.0f) {\n            min = 0.0f\n        }\n        if (max == 0.0f) {\n   \
    \         max = 1.0f\n        }\n        var transformed = new mutable.ArrayList[Float]()\n\
    \        for (number <- numbers) {\n            transformed.add(number * (max\
    \ - min) / (max - min).toFloat)\n        }\n        transformed.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp63xf2stp.scala:9:23 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = math.min(numbers.toList.map(_.toFloat))\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments (List[Float])\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp63xf2stp.scala:10:23 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m = math.max(numbers.toList.map(_.toFloat))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (List[Float])\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp63xf2stp.scala:17:30\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e\
    [36mtransformed\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mFloat\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var smallest = fmin(numbers(0), numbers(1))\n\
    \        var largest = fmax(numbers(0), numbers(1))\n        numbers.zipWithIndex.foreach\
    \ { case (num, i) =>\n            if(num > largest) {\n                largest\
    \ = num\n            }\n            else if(num < smallest) {\n              \
    \  smallest = num\n            }\n        }\n        numbers = numbers map { n\
    \ => (n / largest) * (largest - smallest) + smallest }\n        numbers\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx0iy983.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36msmallest\e[0m = fmin(numbers(\e\
    [31m0\e[0m), numbers(\e[31m1\e[0m))\n\e[31m\e[31m  |\e[0m                    \
    \   ^^^^\e[0m\n\e[31m  |\e[0m                       Not found: fmin\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx0iy983.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mlargest\e[0m = fmax(numbers(\e\
    [31m0\e[0m), numbers(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^\e[0m\n\e[31m   |\e[0m                      Not found: fmax\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmplx0iy983.scala:19:16 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        numbers = numbers map { \e[36mn\e[0m => (n /\
    \ largest) * (largest - smallest) + smallest }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val numbers\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val length = numbers.size\n      \
    \  if (length < 2) numbers else (0 until length).map(i => numbers(i).toFloat)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_4mwyrp4.scala:10:57\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mif\e[0m (length\
    \ < \e[31m2\e[0m) numbers \e[33melse\e[0m (\e[31m0\e[0m until length).map(\e[36mi\e\
    [0m => numbers(i).toFloat)\n\e[31m\e[31m   |\e[0m                            \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    IndexedSeq[Float]\n\e[31m   |\e\
    [0m                                     Required: List[Float]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        assert(numbers.length > 1) \n    \
    \    // Find smallest number in the list\n        var smallest = numbers.min\n\
    \        // Set smallest number to be 0\n        numbers.map(_ => 0.0f)\n    \
    \    // Set largest number to be 1\n        numbers.map(_ => 1.0f)\n        //\
    \ Rescale each number by (smallest - number) / smallest \n        numbers.map(num\
    \ => (num - smallest) / smallest)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp65t4k2gf.scala:20)\n\tat Problem.main(tmp65t4k2gf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var scaledNumbers = numbers.map(_/numbers.length)\n\
    \        val smallestIndex = scaledNumbers.indexOf(scala.math.min(scaledNumbers))\n\
    \        scaledNumbers(smallestIndex) = 0.0f\n        val largestIndex = scaledNumbers.indexOf(scala.math.max(scaledNumbers))\n\
    \        scaledNumbers(largestIndex) = 1.0f\n        scaledNumbers\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpki128_42.scala:10:61 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36msmallestIndex\e[0m = scaledNumbers.indexOf(scala.math.min(scaledNumbers))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((scaledNumbers : List[Float]))\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpki128_42.scala:11:8 -------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        scaledNumbers(smallestIndex) = \e[31m0.0f\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is\
    \ not a member of List[Float] - did you mean List[Float].updated?\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpki128_42.scala:12:60 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mlargestIndex\e[0m = scaledNumbers.indexOf(scala.math.max(scaledNumbers))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((scaledNumbers : List[Float]))\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpki128_42.scala:13:8 -------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        scaledNumbers(largestIndex) = \e[31m1.0f\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is\
    \ not a member of List[Float] - did you mean List[Float].updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009715
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        // Convert to unit\n        val rescale = (max -\
    \ min) * 0.5f / Float.PositiveInfinity\n        val result = numbers.map(x =>\
    \ (x - min) * rescale + min)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo_wfayvw.scala:17)\n\tat Problem.main(tmpo_wfayvw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009716
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val scaled = numbers.map( (x) => Math.min( max, Math.max(\
    \ min, x ) ) ).toList\n        scaled\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpac4o24k6.scala:15)\n\tat Problem.main(tmpac4o24k6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val diff = (max - min).toFloat\n        val rangeInt\
    \ = ((max - min) / diff).toInt\n        val rangeFloat = (max - min) / diff\n\
    \        val scaled = numbers.map((x: Float) => x + (min * diff))\n        val\
    \ zeroed = scaled.map(x => if(x == 0.0f) 0.0f else x)\n        val roundedUp =\
    \ zeroed.map(x => math.floor(x * rangeFloat) + rangeFloat)\n        val roundedDown\
    \ = zeroed.map(x => math.ceil(x * rangeFloat) - rangeFloat)\n        val rounded\
    \ = (roundedUp ++ roundedDown).toList\n        rounded\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp65ea5ov.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        rounded\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (rounded : List[Double])\n\
    \e[31m   |\e[0m        Required: List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var newList = List[Float]()\n    \
    \    var newMin = 0.0f\n        var newMax = 1.0f\n        for (i <- 0 until numbers.size)\n\
    \        {\n            newList ::= numbers(i)\n            if (numbers(i) < newMin)\
    \ newMin = numbers(i)\n            if (numbers(i) > newMax) newMax = numbers(i)\n\
    \        }\n        var scale = (newMax - newMin) / (2.0f * (1.0f - newMax))\n\
    \        newList = newList.map(x => (x - newMin) * scale)\n        newList = newList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjcr3r7z.scala:20:16\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        newList = newList.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Found:    Unit\n\e[31m   |\e[0m        Required: List[Float]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009717
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.sortBy(-_).map(f => (0f -\
    \ f) / (numbers.size - 1))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt_kwrz_h.scala:12)\n\tat Problem.main(tmpt_kwrz_h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009718
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val range = max - min\n        val scaledNumbers\
    \ = numbers.map(x => if (x == min || x == max) 0.0f else (x * (range / (max -\
    \ min))) + min)\n        scaledNumbers\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3u8xjks.scala:16)\n\tat Problem.main(tmpf3u8xjks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val totalSize = numbers.size\n   \
    \     var min = numbers.reduceLeft((x:Float, y:Float) => if (x < y) x else y)\n\
    \        var max = numbers.reduceLeft((x:Float, y:Float) => if (x > y) x else\
    \ y)\n        for (i <- 0 until totalSize) {\n            numbers(i) /= max -\
    \ min\n            numbers(i) *= max - min\n            min = numbers.reduceLeft((x:Float,\
    \ y:Float) => if (x < y) x else y)\n            max = numbers.reduceLeft((x:Float,\
    \ y:Float) => if (x > y) x else y)\n        }\n        numbers\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpimge44cw.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            numbers(i) /= max - min\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not\
    \ a member of Float - did you mean Float.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpimge44cw.scala:14:23 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m            numbers(i) *= max - min\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Float\
    \ - did you mean Float.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.sortWith(_ < _)\n        val\
    \ scaled = numbers.map((f => if(f < 0) 0 else 1))\n        scaled.take(numbers.length).foldLeft(List[Float](0f))(\n\
    \            (a, b) => List(a,b).zipped.map(_/2).foldLeft(a)(_+_)\n        )\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshetchkl.scala:12:32 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            (\e[36ma\e[0m, \e[36mb\e[0m) => List(a,b).zipped.map(_/\e\
    [31m2\e[0m).foldLeft(a)(_+_)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue zipped is not a member of List[Matchable] - did you\
    \ mean List[Matchable].zipAll?\n1 error found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        var rescaledNumber : Float = 0.0f\n\n        if (numbers.isEmpty)\n\
    \            numbers\n        else {\n            numbers.foldRight(List[Float]())(_::_).map(x\
    \ => math.abs(x)).toList.sortBy(math.abs).foreach(x => {\n                if (x\
    \ == max) rescaledNumber = 1.0f\n                else if (x == min)\n        \
    \            rescaledNumber = 0f\n                else\n                    rescaledNumber\
    \ = (x - min)/(max - min).toFloat\n            })\n        }\n        numbers.map(x\
    \ => if(rescaledNumber == 0.0f) 0.0f else x*rescaledNumber).toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmput3_wue7.scala:27)\n\tat Problem.main(tmput3_wue7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.length > 1, s\"rescaleToUnit\
    \ requires at least two elements in given list: ${numbers}\")\n\n        val length\
    \ = numbers.head\n        var smallest = numbers.head\n        var largest = numbers.head\n\
    \n        var i = 1 // index of smallest number in given list\n        while (i\
    \ < numbers.length) {\n            if (numbers[i] > largest) {\n             \
    \   largest = numbers[i]\n            }\n            if (numbers[i] < smallest)\
    \ {\n                smallest = numbers[i]\n            }\n            i += 1\
    \ // increment index of smallest number in given list\n        }\n\n        val\
    \ scaled = numbers.map(x => x / length).map(x => if (x > largest) largest else\
    \ if (x < smallest) smallest else x)\n\n        if (scaled.head != 0.0f) {\n \
    \           scaled.head *= 1.0f - smallest // rescale smallest number to zero\n\
    \        }\n\n        scaled\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9xga437.scala:17:24 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (numbers[\e[35mi\e[0m] > largest)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m    \
    \                    Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpb9xga437.scala:18:34 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m                largest = numbers[\e[35mi\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m       \
    \                           Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpb9xga437.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (numbers[\e[35mi\e[0m] < smallest)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m    \
    \                    Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpb9xga437.scala:21:35 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                smallest = numbers[\e[35mi\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m      \
    \                             Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpb9xga437.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            scaled.head *= \e[31m1.0f\e[0m - smallest\
    \ \e[34m// rescale smallest number to zero\e[0m\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member\
    \ of Float - did you mean Float.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660009720
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.last\n        val n = numbers.tail.size\n        for (i <- 1 to\
    \ n) {\n            min = if (min < numbers.head) min else numbers.head\n    \
    \        max = if (max > numbers.last) max else numbers.last\n        }\n    \
    \    numbers.map(_ / max - min)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzui4t548.scala:19)\n\tat Problem.main(tmpzui4t548.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009722
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minValue = math.min(numbers.min,\
    \ numbers.max)\n        val maxValue = math.max(numbers.min, numbers.max)\n  \
    \      val diff = (maxValue - minValue).toFloat\n        val rescale = (1.0f -\
    \ diff) / (numbers.size - 1)\n        (numbers map { x => (x - minValue) * rescale\
    \ + diff } map { x => if (x > 0) x else 0 })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpddpho89e.scala:16)\n\tat Problem.main(tmpddpho89e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var minNumber = math.max(numbers.min)\
    \ // = 2.0\n        var maxNumber = math.min(numbers.max) // = 5.0\n        numbers.map(\
    \ x => { x = ((x - minNumber) / (maxNumber - minNumber)); x; })\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf0v1lew4.scala:9:29 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mminNumber\e[0m = math.max(numbers.min)\
    \ \e[34m// = 2.0\e[0m\n\e[31m\e[31m  |\e[0m                        ^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  |\e\
    [0m (x: Double, y: Double): Double\n\e[31m  |\e[0m (x: Float, y: Float): Float\n\
    \e[31m  |\e[0m (x: Long, y: Long): Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\
    \e[31m  |\e[0mmatch arguments (Float)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf0v1lew4.scala:10:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e\
    [0m \e[36mmaxNumber\e[0m = math.min(numbers.max) \e[34m// = 5.0\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Float)\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpf0v1lew4.scala:11:30\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        numbers.map(\
    \ \e[36mx\e[0m => { x = ((x - minNumber) / (maxNumber - minNumber)); x; })\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Reassignment to val x\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val unitMin = numbers.min\n      \
    \  val unitMax = numbers.max\n        numbers.map(x => (x - unitMin) / (unitMax\
    \ - unitMin))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009722
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.nonEmpty)\n      \
    \  var smallest = 0.0f\n        var largest = 1.0f\n        var rescaled = numbers.map{n\
    \ => (n - smallest) / (largest - smallest)}\n        rescaled\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps67zxe8z.scala:16)\n\tat Problem.main(tmps67zxe8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n      numbers.min match {\n        case 0.0\
    \ => numbers\n        case min if min < 1.0f => numbers.map(_ * max - min).map(math.exp(_))\n\
    \        case min => numbers.map(_ * max - min).map(math.exp(_))\n      }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzqfct5ah.scala:11:48 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mcase\e[0m min \e[33mif\e[0m min < \e[31m1.0f\e\
    [0m => numbers.map(_ * max - min).map(math.exp(_))\n\e[31m\e[31m   |\e[0m    \
    \                                          ^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Float\n\e[31m   |\e[0m (x: Int):\
    \ Float\n\e[31m   |\e[0m (x: Char): Float\n\e[31m   |\e[0m (x: Short): Float\n\
    \e[31m   |\e[0m (x: Byte): Float\n\e[31m   |\e[0mmatch arguments ((Int, Int) =>\
    \ Int)\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzqfct5ah.scala:11:73\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mcase\e[0m min \e\
    [33mif\e[0m min < \e[31m1.0f\e[0m => numbers.map(_ * max - min).map(math.exp(_))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \                      Found:    Double\n\e[31m   |\e[0m                     \
    \                                   Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpzqfct5ah.scala:12:34 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mcase\e[0m min => numbers.map(_ * max -\
    \ min).map(math.exp(_))\n\e[31m\e[31m   |\e[0m                               \
    \ ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Float\n\e[31m   |\e[0m (x: Int): Float\n\e[31m   |\e[0m (x: Char): Float\n\
    \e[31m   |\e[0m (x: Short): Float\n\e[31m   |\e[0m (x: Byte): Float\n\e[31m  \
    \ |\e[0mmatch arguments ((Int, Int) => Int)\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzqfct5ah.scala:12:59 --------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mcase\e[0m min => numbers.map(_ "
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val zeroToOne = numbers.map( (f =>\
    \ f - Math.min(numbers)) / ( Math.max(numbers) - Math.min(numbers) ) )\n     \
    \   zeroToOne.init\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfe1ahp0m.scala:9:38 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mzeroToOne\e[0m = numbers.map(\
    \ (\e[36mf\e[0m => f - Math.min(numbers)) / ( Math.max(numbers) - Math.min(numbers)\
    \ ) )\n\e[31m\e[31m  |\e[0m                                      ^\e[0m\n\e[31m\
    \  |\e[0m                            Missing parameter type\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m                            I could not infer the type of the parameter\
    \ f.\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpfe1ahp0m.scala:9:75 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mzeroToOne\e[0m = numbers.map(\
    \ (\e[36mf\e[0m => f - Math.min(numbers)) / ( Math.max(numbers) - Math.min(numbers)\
    \ ) )\n\e[31m\e[31m  |\e[0m                                                  \
    \                    ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mobject\e[0m \e[35mMath\e[0m with\
    \ types\n\e[31m  |\e[0m (x$0: Double, x$1: Double): Double\n\e[31m  |\e[0m (x$0:\
    \ Float, x$1: Float): Float\n\e[31m  |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m\
    \  |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers :\
    \ List[Float]))\n2 errors found\n"
  stdout: ''
  timestamp: 1660009720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def minMax(values : List[Float], result\
    \ : Option[List[Float]] = None : Option[List[Float]]): Option[List[Float]] = {\n\
    \            if (values.size == 1) {\n                result.getOrElse(List.of(0))\n\
    \            } else {\n                val minimum = values.min\n            \
    \    val maximum = values.max\n                val unit = (maximum - minimum)\
    \ / values.size\n                val rescaledValues = values.map(x => x.toFloat\
    \ * unit + minimum)\n                result match {\n                    case\
    \ Some(rescaledValues) =>\n                        minMax(rescaledValues, Some(rescaledValues))\n\
    \                    case _ =>\n                        minMax(values.reverse,\
    \ Some(List(values.reverse)))\n                }\n            }\n        }\n\n\
    \        val result = minMax(numbers)\n        result.getOrElse(List.empty)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy3ftjcfx.scala:11:38 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m                result.getOrElse(List.of(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m      value of is not a member of object scala.collection.immutable.List\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy3ftjcfx.scala:21:64 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                        minMax(values.reverse, Some(List(values.reverse)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \            Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mFloat\e[1m\e[31m]\e\
    [0m\n\e[31m   |\e[0m                                                   Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009721
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val max = numbers.max\n        val\
    \ min = numbers.min\n        val range = max - min\n        val scaled = numbers.map{\
    \ x => x / range }\n        val result = numbers.map{ x => (x - min) * range +\
    \ min }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzk8yh2cu.scala:17)\n\tat Problem.main(tmpzk8yh2cu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val newMin = math.min(numbers)\n \
    \       val newMax = math.max(numbers)\n        val length = numbers.size\n  \
    \      val newSize = length + 1 // include the new minimum value at the end\n\
    \        val rescaled = new Array[Float](newSize) // initial array of new size\n\
    \        val newOffset = length - 1 // initial offset for new numbers\n      \
    \  // Start populating the rescaled array\n        var i = 0\n        while (i\
    \ < newSize) {\n            rescaled(i) = newMin + (newOffset * numbers(i))\n\
    \            i += 1\n        }\n        rescaled\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7cumfw_q.scala:9:26 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mnewMin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7cumfw_q.scala:10:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mnewMax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m             \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7cumfw_q.scala:21:8 ---------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        rescaled\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (rescaled : Array[Float])\n\e[31m   |\e\
    [0m        Required: List[Float]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // find minimum element\n        val\
    \ min = numbers.min\n        // find maximum element\n        val max = numbers.max\n\
    \        val range = max - min\n        // calculate new values\n        numbers.map\
    \ { n =>\n            n / range * 0.5f + min\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpev34tt51.scala:20)\n\tat Problem.main(tmpev34tt51.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.foldLeft((List[Float](0.toFloat),\
    \ 0.0f.toFloat))(_ + _._2)._1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu54pbwy6.scala:9:67 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.foldLeft((List[\e[35mFloat\e[0m](\e[31m0\e\
    [0m.toFloat), \e[31m0.0f\e[0m.toFloat))(_ + _._2)._1\n\e[31m\e[31m  |\e[0m   \
    \                                                              ^^^\e[0m\n\e[31m\
    \  |\e[0mvalue + is not a member of (List[Float], Float), but could be made available\
    \ as an extension method.\n\e[31m  |\e[0m\n\e[31m  |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m  |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m  |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m  |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu54pbwy6.scala:9:71\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        numbers.foldLeft((List[\e\
    [35mFloat\e[0m](\e[31m0\e[0m.toFloat), \e[31m0.0f\e[0m.toFloat))(_ + _._2)._1\n\
    \e[31m\e[31m  |\e[0m                                                         \
    \            ^^^^\e[0m\n\e[31m  |\e[0m                                       \
    \  value _2 is not a member of Float\n2 errors found\n"
  stdout: ''
  timestamp: 1660009726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def rescale(x : List[Float], l : List[Float],\
    \ u : List[Float]) : List[Float] = {\n            if (x.isEmpty) l\n         \
    \   else (l.head * (u(x.head) - x.head) + rescale(x.tail, l, u)) :: rescale(x.tail,\
    \ l, u)\n        }\n\n        rescale(numbers, List(0f), List(1f, 1f))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ah89s20.scala:11:32\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33melse\e[0m (l.head\
    \ * (u(x.head) - x.head) + rescale(x.tail, l, u)) :: rescale(x.tail, l, u)\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    Float\n\e[31m   |\e[0m              \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009726
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // If no numbers are given, the list\
    \ is returned.\n        if (numbers.isEmpty) {\n            return numbers\n \
    \       }\n        // Calculate the maximum and minimum elements in the list\n\
    \        val max = numbers.max\n        val min = numbers.min\n        // If all\
    \ numbers are equal, the list is already scaled between 0 and 1\n        if (min\
    \ == max) {\n            return numbers\n        }\n        // Calculate the new\
    \ scale\n        val scale = max - min\n        // Create a new list, by dividing\
    \ the elements by the new scale\n        numbers.map(n => n / scale)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx8adhe5r.scala:26)\n\tat Problem.main(tmpx8adhe5r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val sum = numbers.reduceLeft(_ + _)\n\
    \        val scaled = (numbers map { _ / sum } toList).toList\n        // The\
    \ smallest number will be 0, so if the smallest element is 0 and the sum is 1,\n\
    \        // then rescale all numbers to 1\n        if (scaled.head == 0.0f &&\
    \ sum == 1.0f) {\n            scaled.map(_ = 1.0f)\n        }\n        scaled\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8qly96wl.scala:10:52 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mscaled\e[0m = (numbers map\
    \ { _ / sum } toList).toList\n\e[31m\e[31m   |\e[0m                          \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009724
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Initialize max/min values\n   \
    \     var maxVal = 0.0f\n        var minVal = numbers.head\n\n        // Get difference\
    \ between max and min\n        numbers.foreach { n =>\n            if (maxVal\
    \ < n) maxVal = n\n            if (minVal > n) minVal = n\n        }\n\n     \
    \   // Calculate new values between min and max\n        var rescaledNumbers =\
    \ List(0.0f, 0.0f, 0.0f, 0.0f, 0.0f)\n        numbers.foreach { n =>\n       \
    \     rescaledNumbers = rescaledNumbers :+ (((n - minVal) / (maxVal - minVal))\
    \ * numbers.size)\n        }\n\n        // Return result\n        rescaledNumbers\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp59d2ensy.scala:29)\n\tat Problem.main(tmp59d2ensy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        if (numbers.isEmpty) return Nil\n\
    \        val minValue = math.min(numbers)\n        val maxValue = math.max(numbers)\n\
    \        val newMinValue : Float = 0F\n        val newMaxValue : Float = 1F\n\
    \        val scaledNumbers = numbers.map(x => { \n            val newX : Float\
    \ = (x - minValue)/(maxValue - minValue)\n            if (newX < 0F) newX else\
    \ 0F\n        })\n        newMinValue :: scaledNumbers ::: newMaxValue :: Nil\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpb0hd9pmn.scala:10:28 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mminValue\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpb0hd9pmn.scala:11:28\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxValue\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.reduceLeft((xs, x) => xs.map(_\
    \ / x.toFloat))\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqbotil6q.scala:9:41 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.reduceLeft((\e[36mxs\e[0m, \e[36mx\e[0m)\
    \ => xs.map(_ / x.toFloat))\n\e[31m\e[31m  |\e[0m                            \
    \          ^^^^^^\e[0m\n\e[31m  |\e[0m                                      value\
    \ map is not a member of Float\n1 error found\n"
  stdout: ''
  timestamp: 1660009728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val maxNumber : Float = numbers.max\n\
    \        val minNumber : Float = numbers.min\n        val length : Float = numbers.last\n\
    \        val newNumbers : List[Float] = numbers.map( x => (x - minNumber) / (maxNumber\
    \ - minNumber) * (length.toFloat - 1.0f).toFloat + 1.0f)\n        //TODO: return\
    \ newNumbers instead of numbers\n        return newNumbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmw0xqxlc.scala:17)\n\tat Problem.main(tmpmw0xqxlc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Create a mutable list of numbers\
    \ and an auxiliary function to find the smallest number in the list\n        val\
    \ nums = mutable.ListBuffer.empty[Float]\n        def smallest(n: Float) : Float\
    \ = {\n            if (nums.isEmpty) nums += n\n            else if (nums.last()\
    \ < n) nums += n\n            else nums.last\n        }\n\n        // Create a\
    \ mutable list of numbers and an auxiliary function to find the largest number\
    \ in the list\n        val mins = mutable.ListBuffer.empty[Float]\n        def\
    \ largest(n: Float) : Float = {\n            if (mins.isEmpty) mins += n\n   \
    \         else if (mins.last() > n) mins += n\n            else mins.last\n  \
    \      }\n\n        // Calculate the minimum and maximum values from the numbers\
    \ passed in\n        numbers.foreach(num => smallest(num))\n        numbers.foreach(num\
    \ => largest(num))\n\n        // Create an array from the list of numbers\n  \
    \      val arr = nums.toArray\n\n        // Divide each number in the array by\
    \ the maximum and minimum values\n        val scaledArr = arr.map {\n        \
    \    num => num / (largest(num) - smallest(num))\n        }\n\n        // Return\
    \ the list of scaled numbers\n        scaledArr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgmq5c25m.scala:10:19 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ListBuffer.empty[\e\
    [35mFloat\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgmq5c25m.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmins\e[0m = mutable.ListBuffer.empty[\e\
    [35mFloat\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009725
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require(numbers.size >= 2, \"Expected\
    \ a list of at least two elements\")\n        val sortedNumbers = numbers.sortWith(_\
    \ < _)\n        val firstNumber = sortedNumbers.head\n        val secondNumber\
    \ = sortedNumbers.last\n        val diff = firstNumber - secondNumber\n      \
    \  val scale = (1.0f / diff).toFloat\n        sortedNumbers map (_ * scale)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzs2jirgr.scala:18)\n\tat Problem.main(tmpzs2jirgr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val rangeMin = numbers.min\n     \
    \   val rangeMax = numbers.max\n        val range = (rangeMax - rangeMin)\n  \
    \      val rescaledList = (rangeMax - rangeMin).map(x => (x - rangeMin) / range).map(x\
    \ => x * numbers(0)) + numbers.drop(1)\n        rescaledList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8kzghpz_.scala:12:49 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mrescaledList\e[0m = (rangeMax\
    \ - rangeMin).map(\e[36mx\e[0m => (x - rangeMin) / range).map(\e[36mx\e[0m =>\
    \ x * numbers(\e[31m0\e[0m)) + numbers.drop(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           value map is not a member of Float\n1 error found\n"
  stdout: ''
  timestamp: 1660009730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Find smallest and largest numbers\
    \ and store them in 'min' and 'max'\n        var min = Float.MaxValue\n      \
    \  var max = Float.MinValue\n        for (n <- numbers) {\n            if (n <\
    \ min)\n                min = n\n            if (n > max)\n                max\
    \ = n\n        }\n        // Apply linear transform to each number in numbers:\
    \ \n        // >>> numbers * 0.0f + (min - min) / (max - min) * (max - max)\n\
    \        numbers.map { n => n * 0.0f + (min - min) / (max - min) * (max - max)\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx9veq_ca.scala:23)\n\tat Problem.main(tmpx9veq_ca.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minElement = math.min(numbers)\n\
    \        val maxElement = math.max(numbers)\n        var result = numbers.map(x\
    \ => x - minElement) / maxElement * (maxElement.toFloat() - minElement.toFloat())\n\
    \        result = result.map { x => math.min(x, 1.0f) }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp39irgf1g.scala:9:30 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mminElement\e[0m = math.min(numbers)\n\
    \e[31m\e[31m  |\e[0m                         ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp39irgf1g.scala:10:30\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxElement\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m         \
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp39irgf1g.scala:11:54 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = numbers.map(\e\
    [36mx\e[0m => x - minElement) / maxElement * (maxElement.toFloat() - minElement.toFloat())\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue / is not a member of List[Nothing], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minInv = numbers.min\n       \
    \ val maxInv = numbers.max\n        val scale = (maxInv.abs - minInv.abs).toFloat\n\
    \        numbers.map(x => (x - minInv) / scale)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009733
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def scale(x : Float) = {\n       \
    \     val min = numbers.min\n            val max = numbers.max\n            if\
    \ (min == 0.0f && max == 1.0f) 0.0f\n            else (x - min) / (max - min)\n\
    \        }\n        numbers.map(x => scale(x))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNum = numbers.min\n       \
    \ val maxNum = numbers.max\n        (0 until numbers.size).map(_ => maxNum - numbers.lift(_).sum\
    \ / numbers.lift(_).size).getOrElse(List(minNum))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpxe1ly3ol.scala:11:62 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        (\e[31m0\e[0m until numbers.size).map(_ => maxNum\
    \ - numbers.lift(_).sum / numbers.lift(_).size).getOrElse(List(minNum))\n\e[31m\e\
    [31m   |\e[0m                                                              ^\e\
    [0m\n\e[31m   |\e[0m  Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  I could not infer the type of the parameter _$2 of expanded function:\n\e[31m\
    \   |\e[0m  (_$2, _$3) => maxNum - numbers.lift(_$2).sum / numbers.lift(_$3).size.\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpxe1ly3ol.scala:11:84 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        (\e[31m0\e[0m until numbers.size).map(_ => maxNum\
    \ - numbers.lift(_).sum / numbers.lift(_).size).getOrElse(List(minNum))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                    ^\e[0m\n\e[31m   |\e[0m  Missing parameter type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m  I could not infer the type of the parameter _$3 of\
    \ expanded function:\n\e[31m   |\e[0m  (_$2, _$3) => maxNum - numbers.lift(_$2).sum\
    \ / numbers.lift(_$3).size.\n2 errors found\n"
  stdout: ''
  timestamp: 1660009730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n      numbers.map(x => (x-min(numbers))/(max(numbers)-min(numbers)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpt_i4prqw.scala:9:26 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m      numbers.map(\e[36mx\e[0m => (x-min(numbers))/(max(numbers)-min(numbers)))\n\
    \e[31m\e[31m  |\e[0m                          ^^^\e[0m\n\e[31m  |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n1 error found\n"
  stdout: ''
  timestamp: 1660009730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val range = (max - min).toFloat\n        if (range\
    \ == 0) numbers else numbers.map(x => (x - min) / range)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNumber : Float = numbers.min\n\
    \        val maxNumber : Float = numbers.max\n        val newNumbers = numbers.map(x\
    \ => minNumber + (x - minNumber) / (maxNumber - minNumber).toFloat)\n        numbers.clear()\n\
    \        numbers.addAll(newNumbers)\n        numbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmqknu9zl.scala:12:16 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        numbers.clear()\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue clear is not a member of List[Float]\
    \ - did you mean numbers.clone?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmqknu9zl.scala:13:16\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        numbers.addAll(newNumbers)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue addAll\
    \ is not a member of List[Float], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = math.min(numbers)\n    \
    \    val max = math.max(numbers)\n        val range = max - min\n        val scale\
    \ = (range.max to range.min).max / 2.0\n        val transformedMin = min - scale\n\
    \        val transformedMax = max + scale\n        val transformed = numbers.map(x\
    \ => (x - min) / range)\n        (transformedMin +: transformed +: transformedMax).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpayanin8z.scala:9:23 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m  |\e[0m                  ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpayanin8z.scala:10:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val numbersList = numbers.toList\n\
    \        var minVal: Float = numbersList.min\n        var maxVal: Float = numbersList.max\n\
    \        numbersList.map(x => (x - minVal) / (maxVal - minVal)).map(_ * 2.0f).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz3_aeao6.scala:15)\n\tat Problem.main(tmpz3_aeao6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNum = math.min(numbers).toFloat\n\
    \        val maxNum = math.max(numbers).toFloat\n        // Create a list of values\
    \ between 0 to 1\n        val range = (maxNum-minNum).toFloat/numbers.size\n \
    \       numbers.map(_ + minNum).toList.map(x => x*range)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpl60lb53i.scala:9:26 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mminNum\e[0m = math.min(numbers).toFloat\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpl60lb53i.scala:10:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxNum\e[0m = math.max(numbers).toFloat\n\e[31m\e[31m   |\e[0m     \
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl60lb53i.scala:13:49 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        numbers.map(_ + minNum).toList.map(\e[36mx\e\
    [0m => x*range)\n\e[31m\e[31m   |\e[0m                                       \
    \         ^^\e[0m\n\e[31m   |\e[0mvalue * is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m\
    \   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m\
    \   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var rescaledNumbers = new mutable.ArrayBuffer[Float]()\n\
    \        var smallest = math.min(numbers)\n        var largest = math.max(numbers)\n\
    \        // Normalize all values to range between zero and one\n        // >>>\
    \ 0.0f.toFloat / largest.toFloat - 1.0f.toFloat / smallest.toFloat\n        var\
    \ difference = largest - smallest\n        for( x <- numbers ) {\n           \
    \ rescaledNumbers += (x - smallest) / difference\n        }\n        // Normalize\
    \ all values from the original list to range between zero and one\n        for(\
    \ x <- rescaledNumbers ) {\n            rescaledNumbers += (x * largest.toFloat\
    \ / smallest.toFloat) - 1.0f.toFloat\n        }\n        rescaledNumbers.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4is01uym.scala:9:34 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mrescaledNumbers\e[0m = \e\
    [33mnew\e[0m mutable.ArrayBuffer[\e[35mFloat\e[0m]()\n\e[31m\e[31m  |\e[0m   \
    \                               ^^^^^^^\e[0m\n\e[31m  |\e[0m                 \
    \                 Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp4is01uym.scala:10:28 -----------------------------\e[0m\e[0m\n\e[31m10\
    \ |\e[0m        \e[33mvar\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : List[Float]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4is01uym.scala:11:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : List[Float]))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val total = (numbers: :+: (0 until\
    \ numbers.size)).reduce(_ * _)\n        val norm = numbers.map {\n           \
    \ case x if x == 0.0 => 0.0\n            case x if x == 1.0 => 1.0\n         \
    \   case x if x == total => 1.0\n            case x => x * (1/total)\n       \
    \ }\n        norm.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppcsyy1az.scala:9:34 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mtotal\e[0m = (numbers: \e\
    [35m:+:\e[0m (\e[31m0\e[0m until numbers.size)).reduce(_ * _)\n\e[31m\e[31m  |\e\
    [0m                                  ^\e[0m\n\e[31m  |\e[0m                  \
    \                ')' expected, but '(' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmppcsyy1az.scala:9:30 -------------------------\e[0m\e[0m\n\e[31m9\
    \ |\e[0m        \e[33mval\e[0m \e[36mtotal\e[0m = (numbers: \e[35m:+:\e[0m (\e\
    [31m0\e[0m until numbers.size)).reduce(_ * _)\n\e[31m\e[31m  |\e[0m          \
    \                    ^^^\e[0m\n\e[31m  |\e[0m                              Not\
    \ found: type :+:\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppcsyy1az.scala:16:13\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        norm.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    List[\e\
    [1m\e[31mDouble\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mFloat\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        def rescaleToUnitAux(numbers: List[Float],\
    \ currentIndex : Int) : List[Float] = {\n            if (currentIndex < numbers.length\
    \ - 1) {\n                val temp = numbers(currentIndex)\n                numbers(currentIndex)\
    \ = numbers(currentIndex + 1).toFloat\n                numbers(currentIndex +\
    \ 1) = temp\n                rescaleToUnitAux(numbers, currentIndex + 1)\n   \
    \         } else {\n                numbers\n            }\n        }\n      \
    \  rescaleToUnitAux(numbers, 0)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprqr7cmj2.scala:12:16 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                numbers(currentIndex) = numbers(currentIndex\
    \ + \e[31m1\e[0m).toFloat\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue update is not a member of List[Float] - did you mean numbers.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprqr7cmj2.scala:13:16 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                numbers(currentIndex + \e[31m1\e[0m)\
    \ = temp\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[Float] - did you mean numbers.updated?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009736
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        require( numbers.nonEmpty )\n    \
    \    require( numbers.size >= 2 )\n\n        // Scale numbers in range (0..1)\
    \ to (0..1)\n        val min: Float = numbers.min\n        val max: Float = numbers.max\n\
    \        val delta: Float = 1.0f / (max - min)\n        numbers.map { x => (x\
    \ - min) * delta }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minNum = numbers.min\n       \
    \ val maxNum = numbers.max\n        val minNumFloor = math.floor(minNum)\n   \
    \     val maxNumFloor = math.floor(maxNum)\n        val deltaX = maxNum - minNum\n\
    \        val deltaY = maxNumFloor - minNumFloor\n        numbers.map(n => minNumFloor\
    \ + (n - minNumFloor) * deltaX / deltaY)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvrvl9xq.scala:15:25\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        numbers.map(\e[36mn\e\
    [0m => minNumFloor + (n - minNumFloor) * deltaX / deltaY)\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Double\n\e[31m   |\e[0m\
    \                         Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009736
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        val range = max - min\n        val scaledNumbers\
    \ = numbers.map {x => (x - min) / range * 1.0f}\n        if (scaledNumbers.forall(x\
    \ => x < 0.0f)) {\n            scaledNumbers.reverse\n        } else {\n     \
    \       scaledNumbers\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val minMax = numbers.foldLeft((numbers.head,\
    \ numbers.last)) {\n            (min, max) =>\n                if (min > max)\
    \ (min.asInstanceOf[Float], max.asInstanceOf[Float]) else (max.asInstanceOf[Float],\
    \ min.asInstanceOf[Float])\n        }\n\n        if (minMax._1 == minMax._2) {\n\
    \            List(minMax._1)\n        } else {\n            val min = (minMax._1\
    \ + minMax._2) / 2\n            val max = minMax._1\n            numbers.map(x\
    \ => if (x == min) 0.0 else x).reverse\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph8hqe_6b.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m                \e[33mif\e[0m (min > max) (min.asInstanceOf[\e\
    [35mFloat\e[0m], max.asInstanceOf[\e[35mFloat\e[0m]) \e[33melse\e[0m (max.asInstanceOf[\e\
    [35mFloat\e[0m], min.asInstanceOf[\e[35mFloat\e[0m])\n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of (Float,\
    \ Float), but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m \
    \ import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmph8hqe_6b.scala:19:55 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            numbers.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == min) \e[31m0.0\e[0m \e[33melse\e[0m x).reverse\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m \
    \           Required: List[\e[1m\e[32mFloat\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // The smallest number will be 0,\
    \ and the largest 1\n        var smallestNumber = 0f\n        var largestNumber\
    \ = 1f\n        var output = new collection.mutable.ListBuffer[Float]()\n    \
    \    for(i <- 0 until numbers.size) {\n            val number = numbers(i).toFloat\n\
    \            if(number > largestNumber) {\n                largestNumber = number\n\
    \            }\n            if(number < smallestNumber) {\n                smallestNumber\
    \ = number\n            }\n        }\n        for(i <- 0 until numbers.size) {\n\
    \            val number = numbers(i).toFloat\n            val outputNumber = number\
    \ / largestNumber * smallestNumber + smallestNumber\n            output.append((outputNumber.toFloat).toFloat)\n\
    \        }\n        output.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51215dce.scala:30)\n\tat Problem.main(tmp51215dce.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val min = (numbers.min)(math.MaxFloat)\n\
    \        val max = (numbers.max)(math.MinFloat)\n        numbers.map {x => x /\
    \ min - max}\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsodjdfaw.scala:9:37 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = (numbers.min)(math.MaxFloat)\n\
    \e[31m\e[31m  |\e[0m                                ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                                value MaxFloat is not a member of math\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsodjdfaw.scala:10:37 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = (numbers.max)(math.MinFloat)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                value MinFloat is not a member of math\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Convert each number in the list\
    \ to a float\n        numbers.map(_.toFloat)\n\n        // Find smallest and largest\
    \ numbers in the list\n        var smallest: Float = numbers(0)\n        var largest:\
    \ Float = numbers(0)\n        for (i<- 1 to numbers.size-1) {\n            if\
    \ (numbers(i) < smallest) smallest = numbers(i)\n            if (numbers(i) >\
    \ largest) largest = numbers(i)\n        }\n\n        // Set the smallest and\
    \ largest numbers to 0 and the list to 1\n        numbers(0) = 0f\n        numbers(numbers.size-1)\
    \ = 1f\n\n        // Subtract the largest number from the smallest number\n  \
    \      var i = 0\n        while (i <= numbers.size-1) {\n            numbers(i]\
    \ -= largest\n            i += 1\n        }\n\n        return numbers\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw6r15uzo.scala:27:21 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            numbers(i] -= largest\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     ')' expected,\
    \ but ']' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6r15uzo.scala:21:8\
    \ -------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        numbers(\e[31m0\e\
    [0m) = \e[31m0f\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[Float] - did you mean numbers.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6r15uzo.scala:22:8 -------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        numbers(numbers.size-\e[31m1\e[0m) = \e[31m1f\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is\
    \ not a member of List[Float] - did you mean numbers.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val maxValue = numbers.max\n     \
    \   val minValue = numbers.min\n        var scaledNumbers = List.empty[Float]\n\
    \n        // Scale the numbers up or down to 0.0 or 1.0\n        for ( i <- numbers)\
    \ {\n            val current = (i * 1.0).toFloat\n            val difference =\
    \ max - min\n            val scale = math.min(1.0f, (max - current) / difference)\n\
    \            scaledNumbers = scaledNumbers :+ current * scale\n        }\n\n \
    \       // Make sure that if max is 1.0, min is 0.0\n        if (scaledNumbers.isEmpty)\
    \ {\n            val difference = max - min\n            val scale = 1.0f / difference\n\
    \            scaledNumbers = scaledNumbers :+ (minValue * scale).toFloat\n   \
    \     }\n        return scaledNumbers\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpo0s17crt.scala:16:29 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mdifference\e[0m = max\
    \ - min\n\e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m  \
    \ |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m\
    \ in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch expected type ?{ - : ? }\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpo0s17crt.scala:17:40 -----------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m            \e[33mval\e[0m \e[36mscale\e[0m = math.min(\e[31m1.0f\e[0m,\
    \ (max - current) / difference)\n\e[31m\e[31m   |\e[0m                       \
    \                 ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch expected type ?{ - : ?\
    \ }\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpo0s17crt.scala:23:29 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mdifference\e[0m = max\
    \ - min\n\e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m  \
    \ |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m\
    \ in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch expected type ?{ - : ? }\n3 errors found\n"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var minInd = numbers.length\n    \
    \    var maxInd = 0\n        var minValue = numbers.head\n        var maxValue\
    \ = numbers.last\n\n        numbers.foreach(n => {\n            if (n < minValue)\
    \ {\n                minInd = 0\n                minValue = n\n            } else\
    \ if (n > maxValue) {\n                maxInd = numbers.length\n             \
    \   maxValue = n\n            }\n        })\n\n        if (minInd == 0) {\n  \
    \          numbers = numbers.map(_ / minValue)\n        } else if (maxInd == numbers.length\
    \ - 1) {\n            numbers = numbers.map(_ / maxValue)\n        } else {\n\
    \            numbers = numbers.map(_ / maxValue) ::: numbers.map(_ / minValue).reverse\n\
    \        }\n\n        numbers\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpam0igh2m.scala:25:20 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            numbers = numbers.map(_ / minValue)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpam0igh2m.scala:27:20 -----------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            numbers = numbers.map(_ / maxValue)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpam0igh2m.scala:29:20 -----------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            numbers = numbers.map(_ / maxValue) ::: numbers.map(_\
    \ / minValue).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val numbers\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.min(number.abs.asInstanceOf[Number]).toFloat/numbers.max(number.abs.asInstanceOf[Number]).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ov_d735.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.min(number.abs.asInstanceOf[\e[35mNumber\e\
    [0m]).toFloat/numbers.max(number.abs.asInstanceOf[\e[35mNumber\e[0m]).toFloat\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^\e[0m\n\e[31m  |\e[0m          \
    \          Not found: number\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1ov_d735.scala:9:73 -------------------------\e[0m\e[0m\n\e[31m9 |\e\
    [0m        numbers.min(number.abs.asInstanceOf[\e[35mNumber\e[0m]).toFloat/numbers.max(number.abs.asInstanceOf[\e\
    [35mNumber\e[0m]).toFloat\n\e[31m\e[31m  |\e[0m                              \
    \                                           ^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \                                                   Not found: number\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Compute range and scale of numbers,\
    \ both are in [0, 1)\n        val (rangeMin, rangeMax) = (numbers.minInt, numbers.maxInt)\n\
    \        val (scaleMin, scaleMax) = (numbers.minInt, numbers.maxInt)\n       \
    \ val rangeDiff = rangeMax - rangeMin\n        val scaleDiff = scaleMax - scaleMin\n\
    \n        // If range and scale are identical, just return original list\n   \
    \     if (rangeDiff == scaleDiff) numbers else numbers.map((_ - rangeMin) / rangeDiff\
    \ * scaleMin) + scaleMin\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt65xm23u.scala:10:44 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m (rangeMin, rangeMax) = (numbers.minInt,\
    \ numbers.maxInt)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue minInt is not a member of List[Float] - did you mean\
    \ numbers.init?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt65xm23u.scala:10:60\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m (rangeMin,\
    \ rangeMax) = (numbers.minInt, numbers.maxInt)\n\e[31m\e[31m   |\e[0m        \
    \                                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue maxInt is not a member of List[Float] - did you mean numbers.maxBy?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt65xm23u.scala:11:44 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m (scaleMin, scaleMax) = (numbers.minInt,\
    \ numbers.maxInt)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue minInt is not a member of List[Float] - did you mean\
    \ numbers.init?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt65xm23u.scala:11:60\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m (scaleMin,\
    \ scaleMax) = (numbers.minInt, numbers.maxInt)\n\e[31m\e[31m   |\e[0m        \
    \                                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue maxInt is not a member of List[Float] - did you mean numbers.maxBy?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt65xm23u.scala:12:33 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mrangeDiff\e[0m = rangeMax\
    \ - rangeMin\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of Nothing, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |"
  stdout: ''
  timestamp: 1660009741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        val units = new mutable.HashSet[Float]()\n\
    \        numbers.foreach(x => {\n            if (x != 0.0f) units.add(x)\n   \
    \     })\n        var max = 0.0f\n        var min = 1.0f\n        units.foreach\
    \ { x => max = math.max(max, x); min = math.min(min, x) }\n        numbers.map(x\
    \ => (x - min) / (max - min))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ijm_m2e.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36munits\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mFloat\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \        ^^^^^^^\e[0m\n\e[31m  |\e[0m                        Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        // Create a mutable list of numbers,\
    \ add two copies of the number\n        val numbers_scaled = numbers.toList\n\
    \        numbers_scaled.addAll(numbers_scaled)\n        // Find the min/max of\
    \ the list\n        val minNum = numbers_scaled.min\n        val maxNum = numbers_scaled.max\n\
    \        // Multiply all numbers by their difference to max and min\n        numbers_scaled\
    \ :+ minNum :* maxNum :/ minNum :* maxNum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat,\
    \ 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw99onfcn.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        numbers_scaled.addAll(numbers_scaled)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue addAll is\
    \ not a member of List[Float] - did you mean numbers_scaled.zipAll?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpw99onfcn.scala:16:33 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        numbers_scaled :+ minNum :* maxNum :/ minNum\
    \ :* maxNum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m  value :* is not a member of List[Float] - did you mean List[Float].:+?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        numbers.map { x => ((x-numbers.min).toFloat/numbers.max)\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpopvbe5so.scala:12)\n\tat Problem.main(tmpopvbe5so.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var result : List[Float] = List()\n\
    \        var minNum = numbers.getOrElse(0)\n        var maxNum = numbers.getOrElse(numbers.size\
    \ - 1)\n        var smallestNum = 0.0\n        var largestNum = 1.0\n        numbers.foreach(x\
    \ => {\n            if (x < minNum) minNum = x\n            if (x > maxNum) maxNum\
    \ = x\n            smallestNum = Math.min(smallestNum, x)\n            largestNum\
    \ = Math.max(largestNum, x)\n        })\n        var smallestNumFixed = smallestNum.toFloat\n\
    \        var largestNumFixed = largestNum.toFloat\n        var factor = (largestNum\
    \ - smallestNum) / largestNumFixed\n        numbers.foreach(x => {\n         \
    \   x = x * factor\n        })\n        result = numbers\n        result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6ecu9dtt.scala:10:29 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mminNum\e[0m = numbers.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     value getOrElse is not a member of List[Float]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6ecu9dtt.scala:11:29 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mmaxNum\e[0m = numbers.getOrElse(numbers.size\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value getOrElse is not a member of List[Float]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ecu9dtt.scala:24:16 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            x = x * factor\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Double\n\
    \e[31m   |\e[0m                Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    // such that the smallest number will become 0 and the largest\
    \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = Float.MaxValue\n       \
    \ var max = Float.MinValue\n        numbers.foreach(n => { if (n < min) min =\
    \ n; if (n > max) max = n; });\n        val n = (max - min) / numbers.last\n \
    \       var scaled = numbers.map(n => n * n)\n        val factor = (max - min)\
    \ / scaled.last\n        for (i <- scaled.size - 2 downTo 0) {\n            scaled\
    \ = scaled.map(n => n * factor + min)\n        }\n        scaled.mkList(min)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
    \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
    \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
    \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
    \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpesmw1lct.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mfor\e[0m (i <- scaled.size - \e[31m2\e\
    [0m downTo \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value downTo is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpesmw1lct.scala:18:15 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        scaled.mkList(min)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue mkList is not a member of List[Float]\
    \ - did you mean List[Float].toList?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009741
