name: HumanEval_61_correct_bracketing
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // brackets is a string of \"(\" and \")\".\n    // return true if every opening\
  \ bracket has a corresponding closing bracket.\n    // >>> correctBracketing((\"\
  (\"))\n    // (false)\n    // >>> correctBracketing((\"()\"))\n    // (true)\n \
  \   // >>> correctBracketing((\"(()())\"))\n    // (true)\n    // >>> correctBracketing((\"\
  )(()\"))\n    // (false)\n    def correctBracketing(brackets : String) : Boolean\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"\
  ()\")) == (true));\n    assert(correctBracketing((\"(()())\")) == (true));\n   \
  \ assert(correctBracketing((\"()()(()())()\")) == (true));\n    assert(correctBracketing((\"\
  ()()((()()())())(()()(()))\")) == (true));\n    assert(correctBracketing((\"((()())))\"\
  )) == (false));\n    assert(correctBracketing((\")(()\")) == (false));\n    assert(correctBracketing((\"\
  (\")) == (false));\n    assert(correctBracketing((\"((((\")) == (false));\n    assert(correctBracketing((\"\
  )\")) == (false));\n    assert(correctBracketing((\"(()\")) == (false));\n    assert(correctBracketing((\"\
  ()()(()())())(()\")) == (false));\n    assert(correctBracketing((\"()()(()())()))()\"\
  )) == (false));\n    }\n\n}\n"
completions: ["        brackets match {\n            case \"\" => true\n         \
    \   case c => c == '(' && correctBracketing(brackets.dropRight(1)) || c == ')'\
    \ && correctBracketing(brackets.dropLeft(1))\n        }", "        val bracketPairs\
    \ = brackets.split(\"\\\\)\")\n        for (i <- 0 until bracketPairs.length -\
    \ 1) {\n            if (bracketPairs(i).length !=2 || bracketPairs(i).head ==\
    \ \"(\" || bracketPairs(i).head == \")\") {\n                return false\n  \
    \          }\n        }\n        return true", "        // \"(\" and \")\" are\
    \ special and they have no matching \"()\"\n        // \"(\" and \"(\" are special\
    \ and they have no matching \")\"\n        // To be \"correct\" we must match\
    \ the first opening bracket and then the matching closing bracket.\n        var\
    \ openBrackets : List[Char] = brackets.toList match {\n            case head ::\
    \ tail if head.length == 1 => (head).toChar\n            case _ => List()\n  \
    \      }\n        var closeBrackets : List[Char] = brackets.toList match {\n \
    \           case head :: tail if head.length == 1 => (head).toChar\n         \
    \   case _ => List()\n        }\n        var open : Boolean = false\n        var\
    \ found : Boolean = false\n\n        // Match opening brackets\n        while\
    \ (!open && !found) {\n            openBrackets = openBrackets.tail\n        \
    \    for (bracket : Char <- openBrackets) {\n                if (brackets.charAt(brackets.indexOf(bracket)\
    \ + 1) == bracket) {\n                    found = true\n                    openBrackets\
    \ = openBrackets.tail\n                }\n            }\n        }\n        //\
    \ Match closing brackets\n        while (!open && !found) {\n            closeBrackets\
    \ = closeBrackets.tail\n            for (bracket : Char <- closeBrackets) {\n\
    \                if (brackets.charAt(brackets.indexOf(bracket) - 1) == bracket)\
    \ {\n                    found = true\n                    closeBrackets = closeBrackets.tail\n\
    \                }\n            }\n        }\n        if (found)\n           \
    \ return true\n        else\n            return false", "        def helper(s\
    \ : String) : Boolean = s.head() == '(' && s.tail.head() == '(' || s.head() ==\
    \ ')' && s.tail.head() == ')' || s.isEmpty\n\n        if (brackets == \"\") {\n\
    \            false\n        } else if (brackets.contains(\"(\")) {\n         \
    \   val list = brackets.split(\",\")\n            val first = list.head\n    \
    \        val last = list.tail.head\n            if (helper(first) && helper(last))\
    \ {\n                helper(list)\n            } else {\n                false\n\
    \            }\n        } else {\n            false\n        }", "        val\
    \ count = brackets.split(\"\"\"\\W\"\"\").filter(_.nonEmpty).map(_ => 1).reduce(_\
    \ + _)\n        (brackets.split(\"\"\"\\W\"\"\").filter(_.nonEmpty).map(_ => 1).reduce(_\
    \ + _) == count)", "        // a stack of strings to check whether we have \"\
    (\" on the current level or not.\n        // The string will be pushed into brackets\
    \ string each time we encounter a bracket '('.\n        // When we encounter \"\
    )\", we will pop those strings one by one from the stack to check whether it has\
    \ a corresponding \"(\" on the current level.\n        // If it has a corresponding\
    \ \"(\" on the current level, we will push them into the stack to check the next\
    \ \"(\" on the current level.\n        // If not, we will return false to indicate\
    \ it is not a valid bracketing.\n        var stack : Stack[String] = new Stack[String]()\n\
    \        // We will keep a variable that keeps track of the opening bracket index\
    \ in the string.\n        var openingBracketIndex : Int = -1\n\n        // Keep\
    \ traversing brackets.\n        while(brackets.nonEmpty) {\n            // First\
    \ check if brackets is empty or not.\n            if(brackets.isEmpty) {\n   \
    \             return false\n            }\n\n            // Then get the opening\
    \ bracket index and check if it is the last opening bracket or not.\n        \
    \    openingBracketIndex = brackets.indexOf('(', openingBracketIndex + 1)\n  \
    \          if(openingBracketIndex == -1) {\n                // If we find an opening\
    \ bracket not at the end of a string. That's not valid.\n                return\
    \ false\n            }\n\n            // Then, push it into the stack.\n     \
    \       stack.push(brackets.substring(openingBracketIndex))\n            // Finally,\
    \ remove them from brackets.\n            brackets = brackets.substring(openingBracketIndex\
    \ + 1)\n        }\n\n        // Then check if the stack is empty.\n        if(stack.isEmpty)\
    \ {\n            return true\n        }\n\n        // And if stack is not empty,\
    \ check whether every opening bracket has a corresponding closing bracket.\n \
    \       // Return false if not.\n        for(openingBracketIndex \u2190 0 until\
    \ stack.size) {\n            if(!stack.isEmpty) {\n                // If we find\
    \ an opening bracket not at the end of a string. That's not valid.\n         \
    \       return false\n            }\n\n            if(brackets.isEmpty) {\n  \
    \              // If we find an opening bracket not at the end of a string. That's\
    \ not valid.\n                return false\n            }\n\n            if(brackets.charAt(openingBracketIndex)\
    \ != ')') {\n                // If we find an opening bracket not at the end of\
    \ a string. That's not valid.\n                return false\n            }\n\n\
    \            // Pop from the stack.\n            brackets = brackets.substring(1)\n\
    \            if(!stack.isEmpty) {\n                // If we find an opening bracket\
    \ not at the end of a string. That's not valid.\n                return false\n\
    \            }\n        }\n\n        // If we reach this point without reaching\
    \ any ", "        var hasRightBracket: Boolean = true\n        var openingBracket:\
    \ String = \"\"\n        var closingBracket: String = \"\"\n        for (c <-\
    \ brackets) {\n            if (c == '(') {\n                if (openingBracket\
    \ == \"\") {\n                    openingBracket = c\n                } else {\n\
    \                    hasRightBracket = false\n                }\n            }\
    \ else if (c == ')') {\n                if (closingBracket == \"\") {\n      \
    \              closingBracket = c\n                } else {\n                \
    \    hasRightBracket = false\n                }\n            } else {\n      \
    \          openingBracket = \"\"\n                closingBracket = \"\"\n    \
    \        }\n        }\n        return hasRightBracket", "        val bracket =\
    \ brackets.toList\n        val opening = bracket.takeWhile(_ == '(').reverse\n\
    \        val closing = bracket.dropWhile(_ == ')').reverse\n        opening ==\
    \ closing ", "        val stack = mutable.Stack[String]()\n        val braces\
    \ = brackets.split(\"\\\\(\").flatMap(_.toList)\n        val parens = brackets.split(\"\
    \\\\)\").toList\n        braces.foreach { c =>\n            if (parens.contains(c))\
    \ {\n                stack += c\n            }\n        }\n        stack.isEmpty",
  "        var lastIsWasOpening = false\n        var lastIsWasClosing = false\n  \
    \      var openingBrackets = 0\n        for (c <- brackets) {\n            if\
    \ (c == \"(\") {\n                openingBrackets += 1\n                if (lastIsWasOpening\
    \ == false && lastIsWasClosing == true) {\n                    lastIsWasOpening\
    \ = true\n                }\n            } else if (c == \")\") {\n          \
    \      openingBrackets -= 1\n                lastIsWasClosing = true\n       \
    \     }\n        }\n        lastIsWasOpening == openingBrackets == 0", "     \
    \   var inBrackets : Boolean = true\n        var openBracketCount : Int = 0\n\
    \        val closeBracketCount = brackets.length - 2\n        var openBracketIndex\
    \ = 0\n        while (openBracketCount < closeBracketCount) {\n            val\
    \ openBracket = brackets(openBracketIndex)\n            openBracketCount += 1\n\
    \            val closeBracket = brackets(openBracketCount)\n            inBrackets\
    \ = inBrackets && (openBracket == closeBracket)\n            openBracketIndex\
    \ += 1\n        }\n        inBrackets", "        val openingBrackets = brackets.split(\"\
    \\(\")\n        val closingBrackets = brackets.split(\"\\)\")\n        val openingBracketSet\
    \ = new HashSet[String]()\n        val closingBracketSet = new HashSet[String]()\n\
    \        for (openingBracket <- openingBrackets) {\n            openingBracketSet.add(openingBracket)\n\
    \        }\n        for (closingBracket <- closingBrackets) {\n            closingBracketSet.add(closingBracket)\n\
    \        }\n        openingBracketSet.subsetOf(closingBracketSet)", "        val\
    \ stack = mutable.Stack[String]()\n        brackets.toList foreach { b =>\n  \
    \          if (b == \"(\") {\n                stack.push(b)\n            } else\
    \ if (b == \")\") {\n                val last = stack.pop()\n                if\
    \ (last != \"(\") false\n                else true\n            } else if (b ==\
    \ \")(\") {\n                val last = stack.pop()\n                if (last\
    \ != \"(\") false\n                else true\n            } else if (b == \"((\"\
    ) {\n                val last = stack.pop()\n                if (last != \"(\"\
    ) false\n                else true\n            } else if (b == \"(()\") {\n \
    \               val last = stack.pop()\n                if (last != \"(\") false\n\
    \                else true\n            } else if (b == \")()\") {\n         \
    \       val last = stack.pop()\n                if (last != \"(\") false\n   \
    \             else true\n            } else if (b == \")((\") {\n            \
    \    val last = stack.pop()\n                if (last != \"(\") false\n      \
    \          else true\n            } else {\n                false\n          \
    \  }\n        }", "        if (brackets.length == 0) return true\n        val\
    \ openedBrackets = brackets.split(\"\\\\(+\").map(_.trim).filter(_.nonEmpty)\n\
    \        val closedBrackets = brackets.split(\"\\\\(+\").map(_.trim).filter(_.nonEmpty).filter(_.nonEmpty)\n\
    \        val closedBracketSet = closedBrackets.map(_.head) .toSet\n        val\
    \ openedBracketSet = openedBrackets.map(_.head) .toSet\n        closedBracketSet.forall(openedBracketSet.contains)\
    \ ||\n        openedBracketSet.forall(closedBracketSet.contains)", "        var\
    \ openings = brackets.split(\"(\")\n        var closings = brackets.split(\")\"\
    )\n        if (openings.size > closings.size) false\n        var opening = openings(0)\n\
    \        var closing = closings(0)\n        openings = openings.drop(1)\n    \
    \    closings = closings.drop(1)\n        val open = if (openings.isEmpty) 0 else\
    \ openings(openings.size - 1)\n        val close = if (closings.isEmpty) 0 else\
    \ closings(closings.size - 1)\n        closing = if (close < open) close + 1 else\
    \ close\n        opening = if (opening < close) opening + 1 else opening\n   \
    \     openings = if (opening < 0) \"(\" + openings else openings\n        closings\
    \ = if (closing < 0) \")(\" + closings else closings\n        val result = openings\
    \ + closing == brackets\n        if (result) result else false", "        var\
    \ openingBracketStack = mutable.Stack[Char]()\n        var closingBracketStack\
    \ = mutable.Stack[Char]()\n\n        brackets.foreach({\n            case c =>\n\
    \                openingBracketStack += c\n            case c =>\n           \
    \     closingBracketStack += c\n        })\n\n        openingBracketStack.foreach\
    \ { c =>\n            closingBracketStack.forall(x => x == c)\n        }", " \
    \       var bracketCount = 0\n        var bracketsString = brackets\n        for\
    \ (i <- bracketsString.indices) {\n            if (bracketsString.charAt(i) ==\
    \ '(') {\n                bracketCount = bracketCount + 1\n            } else\
    \ if (bracketsString.charAt(i) == ')') {\n                bracketCount = bracketCount\
    \ - 1\n            } else {\n                return false\n            }\n   \
    \         if (bracketCount < 0) {\n                return false\n            }\n\
    \        }\n        return true", "        // keep track of which brackets are\
    \ open\n        val bracketStack = mutable.Stack[String]()\n        // keep track\
    \ of which brackets are closed\n        val bracketClosedStack = mutable.Stack[String]()\n\
    \n        // keep track of how many brackets are open\n        var bracketCount\
    \ = 0\n\n        // go through each character in the brackets\n        // and\
    \ keep track of whether a bracket is open or closed\n        for (char : Char\
    \ in brackets) {\n            // if we see an opening bracket\n            if\
    \ (char == '(') {\n                bracketCount += 1\n                // add it\
    \ to the stack\n                bracketStack += char\n                // if we\
    \ see a closing bracket, increment the count\n                // and remove it\
    \ from the stack\n                if (bracketStack.nonEmpty && bracketCount >\
    \ 1) {\n                    bracketCount -= 1\n                    bracketClosedStack\
    \ += char\n                    bracketStack -= char\n                }\n     \
    \           // if we see a closing bracket, add it to the stack\n            \
    \    // and decrement the count\n                // if we see an opening bracket,\
    \ do nothing\n            } else if char == ')' && bracketCount > 0 {\n      \
    \          // remove the top bracket from the stack\n                bracketClosedStack\
    \ -= char\n                // if we see another bracket, add it to the stack\n\
    \                // if we see a closing bracket, decrement the count\n       \
    \         // otherwise do nothing\n                if (bracketClosedStack.nonEmpty\
    \ || bracketCount < 0) {\n                    bracketStack += char\n         \
    \           bracketCount += 1\n                }\n                // if we see\
    \ a closing bracket, add it to the stack\n                // and decrement the\
    \ count\n            } else if (char == ')' && bracketCount == 0) {\n        \
    \        bracketClosedStack += char\n                bracketStack += char\n  \
    \          }\n        }\n\n        // if the stack is empty we are done\n    \
    \    if (bracketStack.nonEmpty) {\n            false\n        } else {\n     \
    \       true\n        }", "        val bracketStack = new mutable.Stack[String]()\n\
    \        bracketStack.push(brackets)\n        val result: Boolean = true\n   \
    \     while (result && bracketStack.nonEmpty) {\n            val nextBrackets\
    \ = bracketStack.pop()\n            if (brackets.isEmpty) result = false\n   \
    \         else {\n                // nextBrackets is \"(\" or \")\".\n       \
    \         if (nextBrackets != brackets) {\n                    result = false\n\
    \                }\n                else {\n                    val nextOpeningBracket\
    \ = nextBrackets.charAt(0)\n                    if (nextBrackets.charAt(1) !=\
    \ nextOpeningBracket) {\n                        result = false\n            \
    \        }\n                }\n            }\n        }\n        result", '        brackets.forall(s
    => s == "(" || s == ")")', "        var inBrackets = false\n        brackets foreach\
    \ {\n          c =>\n          if (\"(\" == c) {\n            inBrackets = true\n\
    \          } else if (\")\" == c) {\n            inBrackets = false\n        \
    \  } else if inBrackets {\n            return false\n          }\n        }\n\
    \        true\n      }", "        if (brackets == null) throw new Exception(\"\
    Brackets cannot be null\")\n        var bracketIndex = 0\n        var opening\
    \ = 0\n        var closing = 0\n        for (char <- brackets.toCharArray) {\n\
    \            if (char == \"(\") opening += 1\n            if (char == \")\") closing\
    \ += 1\n            if (char == \"(\") bracketIndex += 1\n            if (char\
    \ == \")\") bracketIndex -= 1\n        }\n        // count open bracket count\
    \ for each opening bracket and check that it is equal\n        // to the number\
    \ of closing brackets found.\n        opening = opening - closing\n        if\
    \ (opening != brackets.length) false\n        else true //the bracketing works",
  "        val index = 0\n        def isPair(ch : String) : Boolean = ch != \")\"\
    \ && ch != \"]\" && ch != \")[\"\n        def isClosingBracket(ch : String) :\
    \ Boolean = ch == \"(\" && brackets.charAt(index + 1) == \")\"\n        while\
    \ (index < brackets.length && isPair(brackets.charAt(index))) {\n            index\
    \ += 2\n        }\n        brackets.toList.forall { ch =>\n            isClosingBracket(ch)\n\
    \        }", "        val closed = brackets.substring(0,brackets.length()-1).reverse.dropWhile(_\
    \ == \")\")\n        val open = brackets.substring(0,brackets.length()-1).reverse.dropWhile(_\
    \ == \"(\")\n        open forall (closed contains _)", "        val bracketsStr\
    \ = brackets.toLowerCase\n        val openingBracketsRegex = \"\"\"\\(+\"\"\"\
    .r\n        val closingBracketsRegex = \"\"\"\\)+\"\"\".r\n        val matches\
    \ : Option[String] = openingBracketsRegex.findAllIn(bracketsStr).toList\n    \
    \    val matches2  : Option[String] = closingBracketsRegex.findAllIn(bracketsStr).toList\n\
    \        matches.toList.forall(matches => {\n            matches2.toList.contains(matches)\n\
    \        })", "        if (brackets.isEmpty) true\n        else {\n          \
    \  var openBrackets = 1\n            var closedBrackets = 1\n            var current\
    \ = \"(\"\n            var result = false\n            for (i <- 0 until brackets.length)\
    \ \n                if (brackets(i) == current) {\n                    if (current\
    \ == \")\") closedBrackets += 1\n                    else openBrackets += 1\n\
    \                } else if brackets(i) == \")\" {\n                    if (openBrackets\
    \ == closedBrackets) result = true\n                    openBrackets -= 1\n  \
    \                  closedBrackets += 1\n                }\n                else\
    \ {\n                    current = \"(\" \n                    openBrackets =\
    \ 1\n                    closedBrackets = 1\n                }\n            result\n\
    \        }", "        var openBrackets = 0\n        var closeBrackets = 0\n  \
    \      for (bracket <- brackets)\n            if (bracket == '(') openBrackets\
    \ += 1\n            if (bracket == ')') closeBrackets += 1\n        if ((openBrackets\
    \ != closeBrackets) && (openBrackets != 0))\n            return false\n      \
    \  else\n            return true", "        var openingBrackets = 0\n        var\
    \ closingBrackets = 0\n        var isBracketingComplete = false\n        brackets.foreach\
    \ { c =>\n            if (c == '(') openingBrackets += 1\n            if (c ==\
    \ ')') closingBrackets += 1\n            if (c == ')' && openingBrackets > 0 &&\
    \ closingBrackets > 0) {\n                isBracketingComplete = true\n      \
    \      }\n        }\n        isBracketingComplete", "        var insideBrackets\
    \ = false\n        var numOpening = 0\n        var numClosing = 0\n\n        for\
    \ (c <- brackets) {\n            if (c == '(')\n                numOpening +=\
    \ 1\n            if (c == ')')\n                numClosing += 1\n\n          \
    \  if (c == '(' && insideBrackets && numOpening > 0) {\n                numOpening\
    \ -= 1\n            }\n            if (c == ')' && insideBrackets && numClosing\
    \ > 0) {\n                numClosing -= 1\n            }\n        }\n\n      \
    \  if (numOpening == 0 && numClosing == 0)\n            true\n        else\n \
    \           false", "        var inBracketing = false\n        var count = 1\n\
    \        var lastClosed = 0\n        brackets.toList match {\n            case\
    \ Nil => true\n            case head :: tail =>\n                inBracketing\
    \ = true\n                val result = brackets.substring(lastClosed,head.length).toList\
    \ match {\n                    case Nil => true\n                    case _ =>\n\
    \                        val newCount = count + 1\n                        if\
    \ (newCount != count) {\n                            inBracketing = false\n  \
    \                          count = 1\n                            lastClosed =\
    \ head.length\n                        } else {\n                            inBracketing\
    \ = correctBracketing(tail)\n                        }\n                }\n  \
    \              inBracketing && result\n        }", "        val counts = brackets.split(\"\
    \\\\(\").map(bracket => {\n            val closingIndex = bracket.indexOf(\"\\\
    \\)\")\n            (bracket, closingIndex, bracket.length)\n        }).toMap\n\
    \        for (count <- counts.tail.zip(counts.tail.init)) {\n            val before\
    \ = count._1.substring(1)\n            val after = count._2.substring(1)\n   \
    \         val beforeCount = before.length\n            val afterCount = after.length\n\
    \            val missing = beforeCount - afterCount\n            if (missing !=\
    \ 0) {\n                return false\n            }\n        }\n        true",
  "        val bracks = brackets.split(\",\")\n        var inString = \"\"\n     \
    \   for (brack <- bracks) {\n            val brack2 = brackets(brackets.indexOf(brack)\
    \ + 1)\n            if (brack2 == \"(\") {\n                inString += \"(\"\n\
    \            } else if (brack2 == \")\") {\n                if (inString.length\
    \ >= 1) {\n                    inString = inString.substring(0, inString.length\
    \ - 1)\n                }\n            } else {\n                inString += bracket\n\
    \            }\n        }\n        (bracks.size == bracks.length) && (inString.isEmpty)",
  "        val openingBrackets = brackets.split(\"\\\\(\")\n        val closingBrackets\
    \ = brackets.split(\"\\\\)\")\n        (openingBrackets zip closingBrackets).forall(x\
    \ => x._1 == x._2)", "      val closedBrackets = brackets.split(\" \").filter(_.length==1).map(_.toInt)\n\
    \      val openBrackets = brackets.split(\" \").filter(_.length==2).map(_.toInt)\n\
    \n      openBrackets.forall(_ > closedBrackets.max)", "        var lastIndex =\
    \ brackets.length - 1\n        var openingBracket: Int = 0\n        while (openingBracket\
    \ < lastIndex) {\n            // increment the opening bracket to count it\n \
    \           openingBracket += 1\n            var closingBracket: Int = 0\n   \
    \         var openingBracketCount = 0\n            while (closingBracket < lastIndex)\
    \ {\n                // increment the closing bracket to count it\n          \
    \      closingBracket += 1\n                // if the current bracket is closing\n\
    \                if (brackets(openingBracket) == brackets(closingBracket)) {\n\
    \                    // add it to the open count\n                    openingBracketCount\
    \ += 1\n                }\n                // if the current bracket is not closing\n\
    \                else {\n                    // if the opening bracket count is\
    \ not zero\n                    if (openingBracketCount > 0) {\n             \
    \           // the closing bracket count will be zero when the bracket is open\n\
    \                        // and will be one when the bracket is closed\n     \
    \                   openingBracketCount -= 1\n                    }\n        \
    \        }\n            }\n            // if the last index is zero, no brackets\
    \ are correct\n            if (lastIndex == 0) {\n                return false\n\
    \            }\n            // if the last index is one and there is only one\
    \ opening\n            // bracket, it is incorrect\n            else if (lastIndex\
    \ == 1) {\n                // if the current bracket is not closed, it is not\
    \ correct\n                if (brackets(openingBracket) != brackets(closingBracket))\
    \ {\n                    return false\n                }\n            }\n    \
    \        else {\n                // if the last index is two and there are two\
    \ opening\n                // brackets, it is not correct\n                if\
    \ (lastIndex == 2) {\n                    if (brackets(openingBracket) != brackets(closingBracket))\
    \ {\n                        return false\n                    }\n           \
    \     }\n            }\n            // if all of the brackets are correct\n  \
    \          else {\n                return true\n            }\n            //\
    \ decrement the opening bracket count because we looked at it\n            lastIndex\
    \ -= 1\n        }", '        brackets.dropRight(1).forall(x => brackets(0).equals(x))
    && brackets.dropRight(1).forall(x => brackets(0).equals(x))', "        brackets\
    \ match {\n            case s\"($brackets)\" => true\n            case s\"${brackets}$\"\
    \ => true\n            case _ => false\n        }", "        var openBracket =\
    \ brackets.head\n        var openBracketCount = 1\n        var closingBracket\
    \ = brackets.last\n        var closingBracketCount = 1\n        brackets.tail.foreach(bracket\
    \ => {\n            if (openBracket != bracket) {\n                return false\n\
    \            }\n            openBracketCount += 1\n            closingBracketCount\
    \ += 1\n        })\n        if (openBracketCount != closingBracketCount) {\n \
    \           return false\n        }\n        return true", "        val openings\
    \ = brackets.split(\"\\\\(\")\n        val closings = brackets.split(\"\\\\)\"\
    )\n        var open : Boolean = false\n        var close : Boolean = false\n \
    \       for (opening  <- openings) {\n            for (closing <- closings) {\n\
    \                if (opening == closing) {\n                    open += !open\n\
    \                }\n            }\n        }\n        open == closings.length",
  "        for (elem <- brackets) {\n            if (elem == \"(\" || elem == \")\"\
    ) {\n                if (brackets.indexOf(elem) == (brackets.lastIndexOf(elem)\
    \ - 1)) {\n                    return true\n                }\n            }\n\
    \        }\n        return false", "        val b = brackets.split(\"\\\\[|\\\\\
    ]|\\\\)\").toList\n        val b2 = b.toList\n        b2.reverse.foreach { x =>\
    \ if(x.equals(\"()\")) false; else if(x.equals(\")\")) true } else false", '        brackets.split("("
    zip brackets.split(")").map(a => a._2.charAt(0) == a._1.charAt(0)).exists(_._2)',
  "        val openBrackets = brackets.count(\"(\")\n        val closedBrackets =\
    \ brackets.count(\")\")\n        openBrackets == closedBrackets", "        def\
    \ isOpeningBracket(char: Char, openingBrackets: String) : Boolean = \n       \
    \     openingBrackets.contains(char) ? true : false\n        val openingBrackets\
    \  = brackets.toList\n        val closingBrackets = brackets.replaceAll(\"\\\\\
    (|\\\\)\", \"\")\n        val openedBrackets  = new StringBuilder()\n        val\
    \ closedBrackets = new StringBuilder()\n        for (char <- brackets.toList)\n\
    \        {\n            if (isOpeningBracket(char, openingBrackets)) \n      \
    \          openedBrackets.append(char)\n            else \n                closedBrackets.append(char)\n\
    \        }\n        // Check that the brackets are correctly closed\n        if\
    \ (closedBrackets.toList.size != openingBrackets.size) \n            return false\n\
    \        // Check that the brackets are correctly opened\n        for (char <-\
    \ openingBrackets)\n            if (!isOpeningBracket(char , openingBrackets))\
    \ \n                return false\n        true", "        val counts = brackets.split(\"\
    \\\\)\").map { _.replaceFirst(\"\\\\(\", \"\") }.map(_.length).foldLeft(0L){\n\
    \            case (count, open) => count+open\n            case (count, close)\
    \ => count+close\n        }\n        true", "        val b = \"()\".toList\n \
    \       val b1 = brackets.toList\n        val b2 = b.toList\n        b2.map(b1\
    \ => {\n            if(b1.isDefined){\n                b1.exists(x => b2.contains(x))\n\
    \            }else{\n                false\n            }\n        })", "    \
    \    val openingBracketRegex = \"\"\"\\(\"\"\".r\n        val closingBracketRegex\
    \ = \"\"\"\\)\"\"\".r\n        val openingBrackets: mutable.Set[String] = mutable.Set()\n\
    \        val closingBrackets: mutable.Set[String] = mutable.Set()\n        for\
    \ (c <- brackets)\n            if (openingBracketRegex.findFirstIn(c).isDefined)\n\
    \                openingBrackets += c.substring(1, c.length - 1)\n           \
    \ if (closingBracketRegex.findFirstIn(c).isDefined)\n                closingBrackets\
    \ += c.substring(1, c.length - 1)\n        openingBrackets.size == closingBrackets.size",
  "        val stack = new Stack[String]\n        for (c <- brackets) {\n        \
    \    if (c == \"(\") {\n                stack.push(c)\n            } else if (c\
    \ == \")\") {\n                if (stack.isEmpty) false else stack.pop\n     \
    \       } else {\n                if (stack.isEmpty || stack.last.toString !=\
    \ \"(\" || stack.last.toString != c) false else stack.pop\n                stack.push(c)\n\
    \            }\n        }\n        !stack.isEmpty", "        val openingBrackets\
    \ = brackets.replaceAll(\"\\\\)\",\"\")\n        val closingBrackets = brackets.replaceAll(\"\
    \\\\(\",\"\")\n\n        if(openingBrackets.length == 0 || closingBrackets.length\
    \ == 0) {\n            false\n        }\n        else if(openingBrackets.split(\"\
    \\\\(\").length != closingBrackets.split(\"\\\\(\").length) {\n            false\n\
    \        }\n        else {\n            val openingBracketPairs = openingBrackets.split(\"\
    \\\\(\")\n            val closingBracketPairs = closingBrackets.split(\"\\\\)\"\
    )\n            val openingBracketPairsSortedByLength = openingBracketPairs.map(_.length).sortWith(_\
    \ > _)\n            val closingBracketPairsSortedByLength = closingBracketPairs.map(_.length).sortWith(_\
    \ > _)\n            if(openingBracketPairsSortedByLength.tail.head != closingBracketPairsSortedByLength.head.head)\
    \ {\n                false\n            }\n            else {\n              \
    \  openingBracketPairs.zip(closingBracketPairs).map(pair => pair.head == pair.tail.head)\n\
    \            }\n        }", "        val openingBrackets  = brackets.toSet.filter(x\
    \ => x == \"(\" || x == \")\")\n        val closingBrackets = brackets.toSet.filter(x\
    \ => x == \"(\" || x == \")\").diff( openingBrackets)\n        openingBrackets.size\
    \ == closingBrackets.size && openingBrackets == closingBrackets", "        var\
    \ openingBrackets = \"\"\n        var closingBrackets = \"\"\n        for (bracket\
    \ <- brackets) {\n            val n = bracket.length\n            if (bracket\
    \ == \"(\") {\n                openingBrackets += bracket\n                closingBrackets\
    \ += bracket\n            }\n            else {\n                if (openingBrackets.endsWith(closingBrackets))\
    \ {\n                    openingBrackets = openingBrackets.substring(0, openingBrackets.length\
    \ - closingBrackets.length)\n                }\n                else {\n     \
    \               return false\n                }\n            }\n        }\n  \
    \      openingBrackets == closingBrackets", "        var open : Boolean = brackets.indexOf(\"\
    (\") != -1\n        var closed = false\n        for(i <- brackets.indices) {\n\
    \            if(brackets(i) == \")\") {\n                closed = true\n     \
    \           break\n            } else if(brackets(i) == \"(\") {\n           \
    \     if(!closed) {\n                    open = true\n                    break\n\
    \                } else {\n                    closed = false\n              \
    \  }\n            }\n        }\n        if(open == closed) {\n            false\n\
    \        } else {\n            true\n        }", "        val bracketsArray =\
    \ brackets.toCharArray.dropRight(1)\n        val numOfOpenBrackets = bracketsArray.zipWithIndex.filter(x\
    \ => (x._1 != '(')).length\n        val numOfCloseBrackets = bracketsArray.zipWithIndex.filter(x\
    \ => (x._1 != ')')).length\n        numOfOpenBrackets == numOfCloseBrackets",
  "      var openCount = 0\n      var closeCount = 0\n      brackets.splitIterator.foreach(c\
    \ => {\n        if (c == '(') openCount += 1\n        if (c == ')') closeCount\
    \ += 1\n      })\n      openCount >= closeCount", "        val map = brackets.toList.grouped(2).map(x\
    \ => x.mkString).map(x => x.replaceFirst(\"\\\"\",\"\").replaceFirst(\"\\\\\"\
    ,\"\")).map(x => x.charAt(0) == \"(\" ? 0 : 1).map(x => x.charAt(x) == \"(\" ?\
    \ 1 : -1)\n        map.foldLeft(0)((a, b) => a + b)", "        var openBracketCount\
    \ : Int = 0\n        var closedBracketCount : Int = 0\n        var bracketPairs\
    \ : Array[String] = brackets.split(\"\\\\(\")\n        for ( (oneBracket, twoBrackets)\
    \ <- bracketPairs)\n            if (twoBrackets.length == 1)\n               \
    \ openBracketCount++\n            if (oneBracket == \"(\" && !twoBrackets.contains(\"\
    )\"))\n                closedBracketCount++\n        if (openBracketCount != closedBracketCount)\n\
    \            false\n        else\n            true", "        var closed = false\n\
    \        var opening = brackets.dropWhile(c => c != \")\")\n        var closing\
    \ = brackets.dropWhile(c => c != \"(\")\n        if (opening.length == 0) return\
    \ false\n        while (opening.nonEmpty) {\n            val c = opening.last\n\
    \            if (c == \")\" && closing.nonEmpty) {\n                opening =\
    \ opening.init\n                closing = closing.init\n            } else {\n\
    \                closed = true\n                opening = opening.tail\n     \
    \           closing = closing.tail\n            }\n        }\n        closed =\
    \ false\n        opening = opening.init\n        closing = closing.init\n    \
    \    while (opening.nonEmpty) {\n            val c = opening.last\n          \
    \  if (c == \")\" && closing.nonEmpty) {\n                opening = opening.init\n\
    \                closing = closing.init\n            } else {\n              \
    \  closed = true\n                opening = opening.tail\n                closing\
    \ = closing.tail\n            }\n        }\n        closed", "        val closeBrackets\
    \ = brackets.toList.map { b =>\n            if (b == \"(\")\n                \"\
    (\"\n            else if (b == \")\")\n                \")\"\n            else\n\
    \                throw new Exception(\"unrecognized input: \" + b)\n        }\n\
    \        val openBrackets = brackets.toList.filter(!_.equals(\"(\"))\n       \
    \ val bracketsToFind = openBrackets.toList\n        val foundAtIndices = mutable.ArrayBuffer.empty[Int]\n\
    \        val foundAtIndices = mutable.ArrayBuffer.empty[Int]\n        for (i <-\
    \ 0 until bracketsToFind.size-1) {\n            val openingBracket = bracketsToFind(i)\n\
    \            val closingBracket = closeBrackets(i)\n            val foundIndex\
    \ = (bracketsToFind.size - 1) - i\n            if (bracketsToFind(foundIndex)\
    \ != openingBracket) {\n                val foundAt = openingBracket + foundIndex\n\
    \                foundAtIndices += foundAt\n            }\n            if (bracketsToFind(foundIndex)\
    \ != closingBracket) {\n                val foundAt = closingBracket + foundIndex\n\
    \                foundAtIndices += foundAt\n            }\n        }\n       \
    \ foundAtIndices.size < bracketsToFind.size", "      var opening = true\n    \
    \  var closing = false\n      var i = 0\n      var j = 0\n      // Count number\
    \ of opening brackets in the string\n      while (i < brackets.length)\n     \
    \   if ( brackets(i) ==  \"(\") {\n          if (opening == false)\n         \
    \   opening = true\n          else\n            closing = true\n        }\n  \
    \      else if (brackets(i) == \")\") {\n          if (closing == true)\n    \
    \        closing = false\n          else\n            opening = true\n       \
    \ }\n        i += 1\n      if (opening != closing)\n        return false\n   \
    \   while (j < brackets.length)\n        if ( brackets(j) ==  \"(\") {\n     \
    \     if (opening == false)\n            opening = true\n          else\n    \
    \        closing = true\n        }\n        else if (brackets(j) == \")\") {\n\
    \          if (closing == true)\n            closing = false\n          else\n\
    \            opening = true\n        }\n        j += 1\n      if (opening != closing)\n\
    \        return false\n      return true", "        var braket : String = \"\"\
    \n        brackets.split('(').foreach{ x =>\n            if(braket.isEmpty) braket\
    \ = x\n            else {\n                if(x != braket) false\n           \
    \     else {\n                    braket = \"\"\n                }\n         \
    \   }\n        }\n        if(braket.isEmpty) true\n        else {\n          \
    \  false\n        }", "        brackets.toList.zip(brackets.tail).forall { case\
    \ (bracket, tail) =>\n            bracket match {\n                case '(' =>\
    \ tail == ')'\n                case '[' => tail == ']'\n                case ')'\
    \ => tail == '('\n                case ']' => tail == '['\n                case\
    \ _ => false\n            }\n        }", "        var inParenthesis : Boolean\
    \ = false\n        var hasDone : Boolean = false\n        for (c <- brackets)\
    \ {\n            if (c != \")\" && c != \"(\") {\n                return false\n\
    \            }\n            if (c == \"(\") {\n                inParenthesis =\
    \ true\n            } else if (c == \")\") {\n                if (inParenthesis)\
    \ {\n                    inParenthesis = false\n                } else {\n   \
    \                 return false\n                }\n            }\n        }\n\
    \        return true", "        def correctBracket(cur : String, open : Boolean)\
    \ : Boolean = {\n            if (cur == \"(\" || cur == \"[\") open = true\n \
    \           if (cur == \")\" || cur == \"]\") open = false\n            cur\n\
    \        }\n        val result = brackets.reverse.foldLeft(false) {\n        \
    \    (open : Boolean, cur : String) => {\n                if (cur == \"(\" ||\
    \ cur == \"[\") {\n                    val open2 = correctBracket(cur, open)\n\
    \                    if (open2) open = !open2\n                    open\n    \
    \            } else open\n            }\n        }\n        result", "       \
    \ (brackets zip brackets take brackets.length)\n            .forall(x => x._1\
    \ == x._2 - 1)", "        var opening = 0\n        var closing = 0\n        var\
    \ lastOpeningIndex = -1\n        var lastClosingIndex = -1\n\n        for (i <-\
    \ 0 until brackets.size)\n            if (brackets(i) == '(')\n              \
    \  opening += 1\n            else if (brackets(i) == ')')\n                closing\
    \ += 1\n\n        if (opening * closing == 0)\n            return true\n\n   \
    \     for (i <- 0 until brackets.size)\n            if (brackets(i) == '(')\n\
    \                lastOpeningIndex = i\n            if (brackets(i) == ')')\n \
    \               lastClosingIndex = i\n\n        if (lastOpeningIndex == -1 ||\
    \ lastClosingIndex == -1)\n            return false\n\n        // check that closing\
    \ bracket was actually opened in the middle\n        // of the opening bracket\n\
    \        var j = lastOpeningIndex\n        while (j > 0 && brackets(j - 1) ==\
    \ '(')\n            j = j - 1\n\n        // check that closing bracket was actually\
    \ opened in the middle\n        // of the opening bracket\n        var j = lastClosingIndex\n\
    \        while (j + 1 < brackets.size\n            && brackets(j + 1) == ')')\n\
    \            j = j + 1\n\n        if (brackets(j) != brackets(lastOpeningIndex))\n\
    \            return false\n\n        return true", "        // TODO: implement\
    \ a stack\n        def stack = new Stack[String]()\n        stack push brackets\n\
    \        brackets foreach {\n            c => if (c == \")\" && stack.isEmpty)\
    \ false\n            c => if (c == \"(\" && stack.isEmpty) false\n           \
    \ c => if (c == \"(\" && stack.toString.charAt(stack.size() - 1) != \")\") false\n\
    \            c => if (c == \")\" && stack.toString.charAt(stack.size() - 1) !=\
    \ \"(\") false\n            c => if (c == \"(\" && stack.size < 2) false\n   \
    \         c => stack.pop()\n            c => stack.toString.charAt(stack.size\
    \ - 1) != c\n        }\n        stack.isEmpty", "        // initialize a list\
    \ of pairs of open and close brackets, initially empty\n        var stack = new\
    \ Stack[String]()\n        var openBrackets = brackets.split(\"(\")\n        var\
    \ closeBrackets = brackets.split(\")\")\n        for( i <- 0 until openBrackets.length\
    \ ) {\n            var openBracket = openBrackets(i)\n            var closeBracket\
    \ = closeBrackets(i)\n            if( openBracket != closeBracket ) {\n      \
    \          // the brackets are not the same\n                println(\"Blah blah\"\
    )\n                stack.push(openBracket)\n                stack.push(closeBracket)\n\
    \            }\n            else {\n                // if the brackets are the\
    \ same, pop the top 2 off the stack\n                if( stack.size <= 1 ) {\n\
    \                    // we hit the base case, everything is fine\n           \
    \         return true\n                }\n                else {\n           \
    \         var topBracket = stack.pop()\n                    var secondTopBracket\
    \ = stack.pop()\n                    if( topBracket != secondTopBracket ) {\n\
    \                        println(\"Blah blah\")\n                        // the\
    \ brackets are different, not good\n                        return false\n   \
    \                 }\n                }\n            }\n        }\n        return\
    \ true", "        var allRight = false\n        var allRight2 = false\n      \
    \  var openBrackets = 0\n        var openBrackets2 = 1\n        var lastClosingBracket\
    \ = brackets.length - 1\n        var lastClosingBracket2 = lastClosingBracket\
    \ - 1\n        var lastClosingBracket3 = lastClosingBracket2 - 1\n        var\
    \ lastClosingBracket4 = lastClosingBracket3 - 1\n        for(i <- 0 to brackets.length\
    \ - 1){\n            if(brackets(i) == '('){\n                openBrackets +=\
    \ 1\n            }\n            if(brackets(i) == ')'){\n                openBrackets2\
    \ += 1\n            }\n            if(openBrackets == openBrackets2){\n      \
    \          if(lastClosingBracket < lastClosingBracket2){\n                   \
    \ allRight = false\n                    allRight2 = false\n                }\n\
    \                else if(lastClosingBracket2 == lastClosingBracket3){\n      \
    \              allRight = false\n                    allRight2 = true\n      \
    \          }\n                else if(lastClosingBracket2 == lastClosingBracket4){\n\
    \                    allRight = false\n                    allRight2 = false\n\
    \                }\n                else if(lastClosingBracket3 == lastClosingBracket4){\n\
    \                    allRight2 = true\n                }\n                else{\n\
    \                    allRight2 = false\n                }\n            }\n   \
    \     }\n        return allRight && allRight2", "        var inParen : Boolean\
    \ = false\n        var closeBrackets : Boolean = false\n        var openBrackets\
    \ : Boolean = false\n\n        brackets.foreach( c => inParen = inParen || c ==\
    \ '(' )\n        \n        \n        brackets.toList.reverse.foreach( c => {\n\
    \            closeBrackets = closeBrackets ||  c == '('\n            openBrackets\
    \ = openBrackets ||  c == ')'\n        })\n        \n        \n        inParen\
    \ &&  !closeBrackets && openBrackets", "        var opening = false\n        var\
    \ closing = false\n        var inside = false\n        var count = 0\n       \
    \ var i = 0\n        while ( i < brackets.length ) {\n            if ( brackets(i)\
    \ == '(' ) {\n                if ( opening ) {\n                    closing =\
    \ true\n                } else {\n                    opening = true\n       \
    \         }\n            } else if ( brackets(i) == ')' ) {\n                if\
    \ ( closing ) {\n                    inside = true\n                } else {\n\
    \                    closing = true\n                }\n            } else if\
    \ ( brackets(i) == ')' && !opening && !closing && !inside ) {\n              \
    \  count = count + 1\n                if (count == 2 ) {\n                   \
    \ return true\n                }\n            }\n            i = i + 1\n     \
    \   }\n        return false", "        // we convert the string to an iterator\
    \ over chars\n        val brackets = brackets.toCharIterator\n        var openingBrackets\
    \ = 0\n        while (brackets.hasNext) {\n            val c = brackets.next\n\
    \            if (c == '(') {\n                openingBrackets += 1\n         \
    \   } else if (c == ')') {\n                if (openingBrackets > 0) {\n     \
    \               openingBrackets -= 1\n                } else {\n             \
    \       return false\n                }\n            }\n        }\n        true",
  "        // convert each bracket into a stack of open brackets\n        def openBrackets\
    \ : List[String] = {\n            def stack : List[String] = Nil\n           \
    \ bracket match {\n                case \")\" => stack.reverse\n             \
    \   case \")(\"  => stack.reverse.head\n                case \")(\" => stack.reverse.head\
    \ :: stack.reverse.tail\n                case \")()\" => stack.reverse.head ::\
    \ stack.reverse.tail :: Nil\n                case \")(()\" => stack.reverse.head\
    \ :: stack.reverse.tail :: Nil\n                case \")()()\" => stack.reverse.head\
    \ :: stack.reverse.tail :: Nil :: Nil\n                case \"()\" => stack.reverse.head\
    \ :: Nil\n                case \"(()\" => stack.reverse.head :: Nil\n        \
    \        case \"(())\" => stack.reverse.head :: Nil :: Nil\n                case\
    \ \"(()())\" => stack.reverse.head :: Nil :: Nil :: Nil\n                case\
    \ \")(())\" => stack.reverse.head :: Nil :: Nil :: Nil\n                case \"\
    )(()())\" => stack.reverse.head :: Nil :: Nil :: Nil :: Nil\n                case\
    \ \")()(())\" => stack.reverse.head :: Nil :: Nil :: Nil :: Nil :: Nil\n     \
    \           case \"(()())(())\" => stack.reverse.head :: Nil :: Nil :: Nil ::\
    \ Nil :: Nil :: Nil\n                case \")()()()\" => stack.reverse.head ::\
    \ Nil :: Nil :: Nil :: Nil :: Nil :: Nil\n                case \")()(())()\" =>\
    \ stack.reverse.head :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil\n      \
    \          case \"()()()()\" => stack.reverse.head :: Nil :: Nil :: Nil :: Nil\
    \ :: Nil :: Nil :: Nil :: Nil\n                case \")()(())(())\" => stack.reverse.head\
    \ :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil\n                case\
    \ \")()()()()\" => stack.reverse.head :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil\
    \ :: Nil :: Nil :: Nil\n                case \")()(())(())()\" => stack.reverse.head\
    \ :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil :: Nil :: ", "        var incorrectBracketing\
    \ : Boolean = true\n        var count : Int = 0\n        for (c <- brackets) {\n\
    \            count += 1\n            if (c == \"(\") {\n                count\
    \ += 1\n            } else if (c == \")\") {\n                count -= 1\n   \
    \         }\n            if (count < 0) {\n                incorrectBracketing\
    \ = false\n            }\n        }\n        if (incorrectBracketing) {\n    \
    \        false\n        } else {\n            true\n        }", "        var openingBracket\
    \ = false \n        var closingBracket = false \n        for (bracket <- brackets.split(\"\
    \")) {\n            if (bracket == \"(\") {\n                openingBracket =\
    \ true\n            } else if (bracket == \")\") {\n                closingBracket\
    \ = true\n            } else if ((openingBracket) && (closingBracket)) {\n   \
    \             return false\n            } else if ((openingBracket) && (!closingBracket))\
    \ {\n                openingBracket = false\n            }\n        }\n      \
    \  return true", "        // Add brackets if they don't exist\n        brackets\
    \ ++= (\"(\", \"(\", \")\", \")\")\n        // Add opening brackets as needed,\
    \ and remove closing brackets as needed\n        val bracketed = brackets.replaceAll(\"\
    \\\\(\", \"\").replaceAll(\"\\\\)\", \"\")\n        val openingBrackets = bracketed.split(\"\
    \\\\(\")\n        val closingBrackets = bracketed.split(\"\\\\)\")\n        //\
    \ For each opening bracket, check if it matches all the closing brackets one by\
    \ one\n        val bracketsMatcher = openingBrackets.foldLeft(false) { (acc, elem)\
    \ =>\n            // For each closing bracket, check if they all match.\n    \
    \        val bracketsMatch = closingBrackets.map(elem => elem == elem).forall(elem\
    \ => acc && elem)\n            !acc && bracketsMatch\n        }\n        bracketsMatcher",
  "        // check left brackets\n        for (left <- brackets.substring(0,brackets.length-1);\
    \ left !=\"(\") {\n            if (brackets.substring(0,brackets.length-1).substring(0,left.length)\
    \ != left) {\n                return false\n            }\n        }\n       \
    \ // check right brackets\n        for (right <- brackets.substring(brackets.length-1,brackets.length);\
    \ right !=\"(\") {\n            if (brackets.substring(0,brackets.length-1).substring(brackets.length-1,right.length)\
    \ != right) {\n                return false\n            }\n        }\n      \
    \  true", "        val stack = mutable.Stack[String]()\n        for (i <- 1 to\
    \ brackets.size - 1) {\n            stack += brackets.charAt(i)\n            stack\
    \ += brackets.charAt(i + 1)\n        }\n        stack.toList == List(\"\", \"\
    ()\", \"()()\")", "        val bracketStack = mutable.Stack[String]()\n      \
    \  val result  = bracketStack.exists { x =>\n            if (brackets.indexOf(x.charAt(0))\
    \ !=-1){\n                if (brackets.indexOf(x.charAt(brackets.length-1)) ==\
    \ -1){\n                    bracketStack.push(x.substring(1,x.length()))\n   \
    \                 return true\n                }\n            }\n            false\n\
    \        }\n        result", "        def recurse(brackets : String) : Boolean\
    \ = {\n            if (brackets.length == 1) brackets == \"(\" else brackets ==\
    \ \"()\"\n        }\n\n        val stack = Stack[String]()\n        for (ix <-\
    \ brackets.indices) {\n            val s = brackets(ix)\n            val bracketLength\
    \ = s.length\n            if (bracketLength == 1) stack += s\n            else\
    \ {\n                if (stack.isEmpty) recurse(s) else stack.pop == s\n     \
    \       }\n        }\n\n        !stack.isEmpty", "        // iterate over the\
    \ string, counting how many open brackets we have seen\n        var openBracketCount\
    \ = 0\n        var lastOpenBracket = \"\"\n        for (bracket <- brackets) {\n\
    \            if (lastOpenBracket.isEmpty) lastOpenBracket = bracket\n        \
    \    openBracketCount += 1\n            if (openBracketCount == 1) {\n       \
    \         lastOpenBracket = bracket\n            }\n        }\n        // if all\
    \ brackets were balanced, then return true\n        if (openBracketCount == brackets.length)\n\
    \            return true\n        // otherwise return false\n        return false",
  "        val bracketsMap = brackets.toList.map(c => (c.toInt, c.toInt)).toMap\n\
    \        var foundBracketing = false\n        brackets.toList.foreach {\n    \
    \        case (c1, c2) =>\n                var currentChar = c1\n            \
    \    // keep going until the corresponding closing bracket is found\n        \
    \        while (bracketsMap.contains(currentChar) && bracketsMap(c1) == currentChar)\
    \ {\n                    currentChar = c2 // advance 2 chars in the string\n \
    \               }\n                // if we still haven't found a closing bracket,\
    \ then the string\n                // has unmatched brackets\n               \
    \ foundBracketing = !foundBracketing\n        }\n        return foundBracketing",
  "        val bracketMap = mutable.Map.empty[String, String]\n        for (i <- 0\
    \ until brackets.length()) {\n            val bracket = brackets(i)\n        \
    \    if (bracket == \"(\" || bracket == \"[\") {\n                if (bracketMap.contains(bracket))\
    \ {\n                    return false\n                } else {\n            \
    \        bracketMap += (bracket -> brackets(i + 1))\n                }\n     \
    \       }\n            if (bracket == \")\" || bracket == \"]\") {\n         \
    \       if (!bracketMap.contains(bracket)) {\n                    return false\n\
    \                }\n                bracketMap -= (bracket -> brackets(i + 1))\n\
    \            }\n        }\n        true", "      var openCount : Int = 0\n   \
    \   var closedCount : Int = 0\n      var bracesCount : Int = 0\n      var bracketsCount\
    \ : Int = 0\n      brackets.split(\"\").foreach { bracket =>\n        openCount\
    \ += if (bracket == \"(\") 1 else if (bracket == \")\") -1 else 0\n        closedCount\
    \ += if (bracket == \"(\") -1 else if (bracket == \")\") 1 else 0\n        bracesCount\
    \ += if (bracket == \"(\") 1 else 0\n        bracketsCount += if (bracket == \"\
    (\") 1 else 0\n      }\n      return openCount == closedCount && openCount ==\
    \ bracesCount && closedCount == bracketsCount", "        val openingBrackets :\
    \ List[Char] = brackets.toList map {\n            case c if c == '('  => 1\n \
    \           case c             => 0\n        }\n        val closingBrackets :\
    \ List[Char] = brackets.toList map {\n            case c if c == ')'  => 1\n \
    \           case c             => 0\n        }\n        openingBrackets == closingBrackets",
  "        brackets match {\n            case \"()\" => true\n            case _ =>\
    \ false\n        }", "        val stack = ListBuffer[String]()\n        for (i\
    \ <- 0 to brackets.length - 1) {\n            if (brackets(i) == '(') {\n    \
    \            stack += '('\n            } else if (brackets(i) == ')') {\n    \
    \            if (stack.last.equals('(')) {\n                    stack.pop()\n\
    \                } else {\n                    return false\n                }\n\
    \            }\n        }\n        stack.isEmpty", "        val bracketMap : mutable.Map[Char,\
    \ Char] =\n            brackets.toCharArray().zip(brackets.toCharArray()).map\
    \ {\n            case ('(', _) => '('\n            case (')', _) => ')'\n    \
    \        case _ => throw new RuntimeException(\"Bad brackets string: \" + brackets)\n\
    \            }\n        bracketMap.forall { (leftBracket, rightBracket) => leftBracket\
    \ == rightBracket }", "        val openingBrackets = brackets.split(\"\\\\(\"\
    )\n        val closingBrackets = brackets.split(\"\\\\)\")\n        val equalOpening\
    \ = openingBrackets.forall(openingBracket =>\n            closingBrackets.contains(openingBracket)\n\
    \        )\n        equalOpening", "        if (brackets.length == 0)\n      \
    \      return false\n\n        val openingBracketIndex = brackets.indexOf(\"(\"\
    )\n        val closingBracketIndex = brackets.indexOf(\")\")\n\n        if (openingBracketIndex\
    \ < 0 || closingBracketIndex < 0 || openingBracketIndex > closingBracketIndex)\n\
    \            false\n\n        else\n            brackets(openingBracketIndex +\
    \ 1) == brackets(closingBracketIndex - 1)", "        brackets match {\n      \
    \      case \".*\" => true\n            case (\".*\") => true\n            case\
    \ (\"(.*\") => {\n                if (brackets.dropRight(1).matches(\"\\\\)$\"\
    )) {\n                    true\n                } else {\n                   \
    \ false\n                }\n            }\n            case (\")(.*\") => {\n\
    \                if (brackets.dropRight(2).matches(\"\\\\)$\")) {\n          \
    \          true\n                } else {\n                    false\n       \
    \         }\n            }\n            case _ => false\n        }", "       \
    \ val closed = brackets.dropWhile(c => c != \"(\" && !c.equals(\")\")).drop(1)\n\
    \        closed.size == brackets.length", "        // Use a stack to keep track\
    \ of whether parentheses are balanced.\n        // The stack keeps track of whether\
    \ parentheses are balanced from the current\n        // position towards the top,\
    \ where brackets are.\n        val stack = mutable.Stack[Boolean]()\n        //\
    \ If the stack becomes empty, parentheses are balanced.\n        if (brackets\
    \ == \"\") {\n            true\n        } else {\n            // Get the first\
    \ character of the bracket and push it to the stack.\n            stack.push(brackets.charAt(0))\n\
    \            for (x <- 1 to brackets.length - 1) {\n                // If the\
    \ top of the stack is opening, we enclose the current bracket\n              \
    \  // and push it back to the stack.\n                if (stack.isEmpty) {\n \
    \                   stack += brackets.charAt(x)\n                } else if (brackets.charAt(x)\
    \ == brackets.charAt(stack.getTop)) {\n                    // If the top is closing,\
    \ remove the closing bracket and push it\n                    // back to the stack.\n\
    \                    stack -= brackets.charAt(x)\n                } else if (brackets.charAt(x)\
    \ == brackets.charAt(stack.getTop + 1)) {\n                    // If the same\
    \ bracket appears multiple times, we must have a matching\n                  \
    \  // opening bracket. Either way, we remove the opening bracket and add\n   \
    \                 // the closing bracket to the stack.\n                    stack\
    \ -= brackets.charAt(x)\n                    stack += brackets.charAt(stack.getTop\
    \ + 1)\n                }\n            }\n            // If parentheses are not\
    \ balanced, parentheses are not balanced.\n            !stack.isEmpty\n      \
    \  }", "        val openings = brackets.split(\"\\\\(\")\n        val closings\
    \ = brackets.split(\"\\\\)\")\n        openings.toList == closings.toList", " \
    \       if(brackets.length == 0) {\n            true\n        }\n        else\
    \ {\n            val openingBrackets = brackets.toSet\n            val closingBrackets\
    \ = openingBrackets.diff(Set(\")\"))\n            val openingBracketsLeft = openingBrackets.diff(Set(\"\
    (\"))\n            if(closingBrackets.size == 0) {\n                closingBrackets.size\
    \ == 0 && openingBracketsLeft.size == 0\n            }\n            else {\n \
    \               closingBrackets.size == 0 && openingBracketsLeft.size > 0\n  \
    \          }\n        }", "        // initialize an array to hold the index positions\n\
    \        var indexPositions = Array[Int]()\n        for(i <- 0 until brackets.length)\n\
    \            if(brackets.charAt(i) == ')')\n                indexPositions +=\
    \ i\n\n        // iterate through and make sure each open bracket has an associated\
    \ closing bracket.\n        for(i <- 0 until brackets.length)\n            if(brackets.charAt(i)\
    \ == '(')\n                for(j <- indexPositions(i) until indexPositions(i+1))\n\
    \                    if(brackets.charAt(j) != '(')\n                        return\
    \ false\n\n        return true", "        if (brackets.length == 0)\n        \
    \    return true\n        brackets.charAt(0)\n          match {\n            case\
    \ ')' =>\n            case ')(' =>\n            case ')(' |' |')' =>\n       \
    \     case ')(' |' |')(' =>\n            case ')(' |' |')(' |')' =>\n        \
    \    case ')(' |' |')(' |')(' |')' =>\n            case ')(' |' |')(' |')(' |')('\
    \ |')' =>\n            case ')(' |' |')(' |')(' |')(' |')(' |')' =>\n        \
    \    case ')(' |' |')(' |')(' |')(' |')(' |')(' |')' =>\n            case ')('\
    \ |' |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n            case ')(' |' |')('\
    \ |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n            case ')(' |' |')('\
    \ |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n            case ')(' |'\
    \ |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n            case ')('\
    \ |' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n         \
    \   case ')(' |' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' =>\n\
    \            case ')(' |' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')('\
    \ |')(' |')' =>\n            case ')(' |' |')(' |')(' |')(' |')(' |')(' |')('\
    \ |')(' |')(' |')(' |')(' |')' =>\n            case ')(' |' |')(' |')(' |')('\
    \ |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n            case ')(' |'\
    \ |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')(' |')' =>\n\
    \            case ')(' |", "        val bracketsSet = brackets.toSet\n       \
    \ val openingBracketsCount = bracketsSet.size\n        var openBracketsCount =\
    \ 0\n\n        val closingBracketsCount = bracketsSet diff Set(\"(\",\")\")\n\n\
    \        // if there are no closing brackets, it isn't a matching bracket pair\n\
    \        if (closingBracketsCount == 0)\n            return false\n\n        while\
    \ (openBracketsCount < openingBracketsCount)\n            openBracketsCount +=\
    \ bracketsSet contains brackets(openBracketsCount)\n\n        openBracketsCount\
    \ > 0", "        // count the number of opening brackets\n        var opening\
    \ = 0\n        // for each opening bracket\n        for (c <- brackets)\n    \
    \        if (c == '(') opening++\n        // for each closing bracket\n      \
    \  for (c <- brackets)\n            if (c == '(') opening--\n        opening =\
    \ 0\n        for (c <- brackets)\n            if (c == '(') opening++\n      \
    \  opening == 0", "        for (i <- 0 until brackets.length - 1 by -1) \n   \
    \         if (brackets(i) != brackets(i + 1)) \n                return false\n\
    \        return true", "        var bracketCount = 0\n        var lastBracket\
    \ = brackets.charAt(0)\n        var foundLastBracket = false // tracks if we found\
    \ a closing bracket\n        var lastFound = -1 // tracks the current index of\
    \ the last closing bracket\n        var found = -1 // tracks the current index\
    \ of the last opening bracket\n        var incorrect = false\n\n        // loop\
    \ through the brackets\n        for(i <- 0 until brackets.length)\n        { //\
    \ if we see a bracket\n            if(brackets.charAt(i) == '(')\n           \
    \ {\n                // if we see an opening bracket, increment the counter\n\
    \                bracketCount += 1\n                // if we see a closing bracket,\
    \ decrement the counter\n                if(brackets.charAt(i + 1) == '(')\n \
    \                   bracketCount -= 1\n                // if we see a closing\
    \ bracket, check if it's right\n                if(bracketCount < 0)\n       \
    \         {\n                    incorrect = true\n                    return(true)\n\
    \                }\n            }\n            else if(brackets.charAt(i) == ')')\n\
    \            {\n                // if we see an opening bracket, check if it's\
    \ right\n                if(bracketCount < 0)\n                {\n           \
    \         incorrect = true\n                    return(true)\n               \
    \ }\n                bracketCount -= 1\n            }\n            else\n    \
    \        {\n                // if we see an opening bracket, check if it's right\n\
    \                if(bracketCount > 0)\n                {\n                   \
    \ incorrect = true\n                    return(true)\n                }\n    \
    \            // if we see a closing bracket, check if it's right\n           \
    \     if(brackets.charAt(i + 1) == '(')\n                    bracketCount += 1\n\
    \                lastBracket = brackets.charAt(i)\n                lastFound =\
    \ i\n                foundLastBracket = brackets.charAt(i + 1) == '('\n      \
    \      }\n        }\n\n        // if we made it here, all brackets are correctly\
    \ matched\n        if(foundLastBracket && lastBracket != ')')\n        {\n   \
    \         incorrect = true\n            return(true)\n        }\n        else\n\
    \        {\n            // if this is the last bracket, check if it's correct\n\
    \            if(lastBracket != ')')\n                incorrect = true\n\n    \
    \        // if the last closing bracket was on another line, we didn't have a\
    \ match\n            if(lastFound < 0)\n                return(false)\n\n    \
    \        // if we didn't have it on a new line, check to see if we have a match\n\
    \            if(!foundLastBracket && lastBracket == ')')\n                return(false)\n\
    \n            // if we found a closing bracket, check if it's the right one\n\
    \            if(bracketCount < 0)\n            {\n                incorrect =\
    \ true\n                return(true)\n            }\n\n            // if we did\
    \ have it on a new line, check if it's the right one\n            if(foundLastBracket)\n\
    \                if(bracketCount > 0)\n                    return(false)\n   \
    \             return(true)\n        }\n        return(incorrect)\n    }", "  \
    \      val countPairs = brackets.count{ case c if (c == '(') => (1) case c if\
    \ (c == '[') => (1) case c if (c == '{' ) => (1) }\n        ( countPairs == brackets.size\
    \ - 1 )", "        val result: List[(String, String)] = brackets.split(\"\\\\\
    (\").map(_.trim).toList match {\n            case Nil => Nil\n            case\
    \ x::xs => {\n                val y = xs.reverse.split(\"\\\\)\")\n          \
    \      val z = (x,y) ++ y\n                val t = z.map(_._1 + \")\")\n     \
    \           val t = z.filter(_._1 != x)\n                val y = t.map(_._1 +\
    \ \")\")\n                val y = t.filter(_._1 != x)\n                val y =\
    \ t.filter(_._1 != \"(\")\n                val y = t.filter(_._1 != \")\")\n \
    \               val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1\
    \ != \")(\")\n                val y = t.filter(_._1 != \")(\")\n             \
    \   val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 !=\
    \ \")(\")\n                val y = t.filter(_._1 != \")(\")\n                val\
    \ y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 != \")(\"\
    )\n                val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1\
    \ != \")(\")\n                val y = t.filter(_._1 != \")(\")\n             \
    \   val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 !=\
    \ \")(\")\n                val y = t.filter(_._1 != \")(\")\n                val\
    \ y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 != \")(\"\
    )\n                val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1\
    \ != \")(\")\n                val y = t.filter(_._1 != \")(\")\n             \
    \   val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 !=\
    \ \")(\")\n                val y = t.filter(_._1 != \")(\")\n                val\
    \ y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 != \")(\"\
    )\n                val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1\
    \ != \")(\")\n                val y = t.filter(_._1 != \")(\")\n             \
    \   val y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 !=\
    \ \")(\")\n                val y = t.filter(_._1 != \")(\")\n                val\
    \ y = t.filter(_._1 != \")(\")\n                val y = t.filter(_._1 != \")(\"\
    )\n                val y = t.filter(_", "      if(brackets.length == 0) false\n\
    \      else brackets.charAt(0) != \"(\" || brackets.endsWith(\")\") || correctBracketing(brackets.substring(1,\
    \ brackets.length-1))", "        val openingBracketSet = openingBrackets(brackets)\n\
    \        val closingBracketSet = closingBrackets(brackets)\n        val resultingBracketingSet\
    \ = openingBracketSet.intersect(closingBracketSet).isEmpty\n        resultingBracketingSet",
  "        val stack = mutable.Stack[Int]()\n        val counter = mutable.HashMap[Char,Int]()\n\
    \        for(i <- 0 until brackets.length) {\n            if(brackets.charAt(i)\
    \ == '(') {\n                stack.push(i)\n                counter.put(brackets.charAt(i),\
    \ 0)\n            } else if(brackets.charAt(i) == ')') {\n                if(stack.isEmpty)\
    \ {\n                    return false\n                }\n                val\
    \ top = stack.pop()\n                val count = counter.get(brackets.charAt(i))\n\
    \                if(count == top) {\n                    counter.put(brackets.charAt(i),\
    \ count + 1)\n                } else {\n                    counter.put(brackets.charAt(i),\
    \ count)\n                }\n            } else {\n                counter.put(brackets.charAt(i),\
    \ counter.getOrElse(brackets.charAt(i),0) - 1)\n            }\n        }\n   \
    \     stack.isEmpty", "        val leftBracketCount = brackets.replaceAll(\"\\\
    \\(\", \"\").length\n        val rightBracketCount = brackets.replaceAll(\"\\\\\
    )\", \"\").length\n        (leftBracketCount - rightBracketCount) == 0", "   \
    \     var open : Boolean = true\n        var closed : Boolean = false\n\n    \
    \    for( bracket <- brackets) {\n            if( bracket == \"(\" && !open) {\n\
    \                open = true\n            } else if( bracket == \")\" && open\
    \ ) {\n                closed = true\n            } else if( open && closed) {\n\
    \                return false\n            }\n        }\n        return true",
  "        brackets match {\n            case \"\" => true\n            case \")\"\
    \ => false\n            case _  => brackets.split(\"\\\\(\").map(x => x.split(\"\
    \\\\)\").length) == brackets.split(\"\\\\)\").length\n        }", "        var\
    \ stack = List[(Char, Char)]()\n        var opening = false\n        for (c <-\
    \ brackets) {\n            if(c == '(') {\n                opening = true\n  \
    \          }\n            if(c == ')') {\n                opening = false\n  \
    \          }\n            if(opening) {\n                stack += (c, c)\n   \
    \         }\n        }\n        stack.length == brackets.length", "        //\
    \ Your code here\n        brackets.flatMap(bracket => {\n            val pattern\
    \ = s\"${bracket}+\".r\n            val m = pattern.findFirstIn(brackets)\n  \
    \          m match {\n                case Some(index) => false\n            \
    \    case _ => true\n            }\n        })", "        var opening = true\n\
    \        var bracketCount = 0\n        var depth = 0\n        var currentBracket\
    \ = ()\n        var inParen = false\n\n        for(c <- brackets) {\n        \
    \    if(c == \"(\") {\n                if(currentBracket != ())\n            \
    \        return false\n                currentBracket = c\n                bracketCount\
    \ += 1\n            } else if(c == \")\") {\n                if(currentBracket\
    \ == ())\n                    return false\n                bracketCount -= 1\n\
    \                if(bracketCount < 0)\n                    return false\n    \
    \            currentBracket = ()\n            } else if(c == \"[\") {\n      \
    \          inParen = true\n                depth += 1\n            } else if(c\
    \ == \"]\") {\n                inParen = false\n                depth -= 1\n \
    \           }\n            if(inParen)\n                currentBracket += c\n\
    \        }\n        depth == 0", "        val opening = brackets.split(\"\\\\\
    (\")\n        val closing = brackets.split(\"\\\\)\")\n        opening.toSeq.zipWithIndex.forall\
    \ { case (x, i) => x == closing(i) }", "        var closed = false\n        var\
    \ opened = 0\n        brackets.toList match {\n        case List() => closed =\
    \ true\n        case head :: tail => {\n            if ((head == \"(\" && opened\
    \ == 0) || (head == \")\" && opened == tail.size)) {\n                closed =\
    \ true\n            }\n            opened += 1\n            correctBracketing(tail)\n\
    \        }\n        }\n        !closed", "        if (brackets == null)\n    \
    \        return false\n\n        val allParens = brackets.toSet\n        val emptyParen\
    \ = Set()\n\n        for {\n            open <- allParens - emptyParen\n     \
    \       close <- allParens - emptyParen\n        } yield (open + close) == brackets.size",
  '        brackets.matches("\\(.*\\)")', "        val bracketsList = brackets.toList\n\
    \        var trueCount = 0\n        bracketsList.foreach { b =>\n            if\
    \ (b == \")\")\n                trueCount += 1\n            else if (b == \"(\"\
    )\n                trueCount = trueCount - 1\n            if (trueCount < 0)\n\
    \                return false\n        }\n        return trueCount == 0", "  \
    \      brackets match {\n            case x if x contains \")\"   => true\n  \
    \          case x if x contains \")(\"  => true\n            case x if x contains\
    \ \"()\"   => true\n            case x if x contains \"((\"  => true\n       \
    \     case x if x contains \"()()\" => true\n            case x if x contains\
    \ \"(()\" => true\n            case x if x contains \"(()()\" => true\n      \
    \      case _                  => false\n        }", "        if (brackets.isEmpty)\
    \ true\n        else {\n            val (startIndex, endIndex) = brackets.span(x\
    \ => x == \"(\")\n            if (startIndex == endIndex) brackets.contains(\"\
    (\")\n            else false\n        }", "        if (brackets.length == 0) true\n\
    \        else {\n            var openingBrackets = brackets.toLowerCase.split(\"\
    \\\\(\").filterNot(_.isEmpty).toList\n            var closingBrackets = brackets.toLowerCase.split(\"\
    \\\\)\").filterNot(_.isEmpty).toList\n            val bracketsInParentheses =\
    \ List(\"\", \"()\", \"[]\", \"{}\", \"({})\", \"(()())\", \"((){})\", \"({})(\"\
    , \"{}(\", \"({})(\")\n            openingBrackets.foreach { b =>\n          \
    \      closingBrackets.foreach { c =>\n                    if (b == c) {\n   \
    \                     openingBrackets.remove(new Tuple(b, c))\n              \
    \      } else if (bracketsInParentheses.contains(b) && bracketsInParentheses.contains(c))\
    \ {\n                        openingBrackets.remove(new Tuple(b, c))\n       \
    \             } else {\n                        return false\n               \
    \     }\n                }\n            }\n            openingBrackets.isEmpty\n\
    \        }", "        var opening = false\n        var closing = false\n\n   \
    \     for (i <- 0 until brackets.length) {\n            val currBracket = brackets(i)\n\
    \            if (currBracket == \"(\") {\n                opening = true\n   \
    \         } else if (currBracket == \")\") {\n                closing = true\n\
    \            }\n            if (opening && closing) {\n                return\
    \ true\n            }\n        }\n        return false", "        val chars =\
    \ brackets.toCharArray\n        val openingBrackets = new mutable.LinkedHashMap[Char,Int]()\n\
    \        val closingBrackets = new mutable.LinkedHashMap[Char,Int]()\n\n     \
    \   chars.foreach { c =>\n            if (c == '(') {\n                openingBrackets(c)\
    \ = 1\n            } else if (c == ')') {\n                closingBrackets(c)\
    \ = 1\n            } else if (c != ')') {\n                val openCount = openingBrackets.get(c)\n\
    \                val closeCount = closingBrackets.get(c)\n                if (openCount\
    \ == null || closeCount == null) {\n                    openingBrackets(c) = 1\n\
    \                    closingBrackets(c) = 1\n                } else {\n      \
    \              openingBrackets(c) += 1\n                    if (openCount == 1)\
    \ {\n                        closingBrackets(c) = 1\n                    }\n \
    \               }\n            }\n        }\n\n        openingBrackets.forall\
    \ { case (k,v) => v == closingBrackets.get(k) }", "        var openingBrackets\
    \ = 0\n        brackets foreach { b =>\n            if (b == \"(\") openingBrackets\
    \ += 1\n            if (b == \")\") openingBrackets -= 1\n            if (openingBrackets\
    \ < 0) return false\n        }\n        return true", "        var openBrackets\
    \ = \"\"\n        var openBracketCount = 0\n        var closeBrackets = \"\"\n\
    \        var closeBracketCount = 0\n        // remove brackets from the brackets\
    \ string\n        var strWithoutBrackets = brackets.replaceAll(\"\\\\(|\\\\)\"\
    , \"\")\n        // for every character in the strWithoutBrackets string...\n\
    \        for (c <- strWithoutBrackets.toCharArray()) {\n            if (c == '(')\
    \ {\n                // increment the opening brackets counter\n             \
    \   openBracketCount += 1\n                openBrackets += c\n            }\n\
    \            else if (c == ')') {\n                // decrement the opening brackets\
    \ counter\n                if (openBracketCount > 0) {\n                    openBracketCount\
    \ -= 1\n                    openBrackets += c\n                }\n           \
    \ }\n            else if (openBracketCount == 0) {\n                // reset this\
    \ character to a bracket if there are no more brackets\n                closeBrackets\
    \ += c\n            }\n        }\n        // return true if there are exactly\
    \ the same number of brackets\n        if (openBrackets == closeBrackets) {\n\
    \            return true\n        }\n        return false", "        var insideBrackets\
    \ : Boolean = true\n        var openBrackets = \"\"\n        var closeBrackets\
    \ = \"\"\n        brackets.foreach {\n            case x => x match {\n      \
    \          case \")\" => closeBrackets = x }\n                case \")(\"  =>\
    \ insideBrackets = false }\n                case \")()\" => insideBrackets = false\
    \ }\n            case \")(\" => insideBrackets = false }\n            case \"\
    )(\" => insideBrackets = false }\n            case \")(\" => insideBrackets =\
    \ false }\n            case \")(\" => insideBrackets = false }\n            case\
    \ \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = false }\n           \
    \ case \")(\" => insideBrackets = false }\n            case \")(\" => insideBrackets\
    \ = false }\n            case \")(\" => insideBrackets = ", "        // The brackets\
    \ string may have multiple opening brackets,\n        // so a nested loop is required.\n\
    \        for (bracket <- brackets) {\n            for {\n                // Open\
    \ the bracket.\n                openingBracket <- brackets.indexOf(bracket, 1)\
    \ match {\n                    case -1 => // No closing bracket.\n           \
    \         case _  => // Close the bracket.\n                }\n              \
    \  // Close the bracket.\n                closingBracket <- brackets.lastIndexOf(bracket,\
    \ 1) match {\n                    case -1 => // No opening bracket.\n        \
    \            case _  => // Open the bracket.\n                }\n            }\
    \ yield openingBracket != closingBracket\n        }", "        // () has two open\
    \ brackets.\n        // If there is an even number of these opening\n        //\
    \ brackets (i.e. there is an even number of '(' in\n        // brackets) then\
    \ return false.\n        // If there is an odd number of these opening\n     \
    \   // brackets (i.e. there is an odd number of '(' in\n        // brackets) then\
    \ return true.\n        // >>> correctBracketing((\"()\"))\n        // (false)\n\
    \        // >>> correctBracketing((\"(()\"))\n        // (true)\n        // >>>\
    \ correctBracketing((\"(()()\"))\n        // (true)\n        // >>> correctBracketing((\"\
    ())\"))\n        // (false)\n        // >>> correctBracketing((\")())\"))\n  \
    \      // (false)\n        // >>> correctBracketing((\"()(()\"))\n        // (false)\n\
    \        \n        val n = brackets.length\n        if (n != 0)\n            for\
    \ (i <- 0 until n) {\n                val p = brackets.charAt(i)\n           \
    \     if (p == '(')\n                    for (j <- i until n by 2) {\n       \
    \                 val q = brackets.charAt(j + 2)\n                        if (q\
    \ == '(') {\n                            if (i != j)\n                       \
    \         return false\n                        }\n                    }\n   \
    \         }\n        true", "        if (brackets.length == 0) return true\n \
    \       def check(brackets: String) : Boolean = {\n            val current = brackets.head\n\
    \            if (current == \"(\" && brackets.tail.contains(\")\")) return check(brackets.tail)\n\
    \            if (current == \")\" && brackets.tail.contains(\"(\")) return check(brackets.tail)\n\
    \            if (current == \"(\" && brackets.tail.contains(\")\")) return true\n\
    \            if (current == \")\" && brackets.tail.contains(\"(\")) return true\n\
    \            return false\n        }\n        return check(brackets)", "     \
    \   // count how many \"(\" there are in the brackets\n        var count = 0\n\
    \        var i = brackets.length\n        while (brackets.charAt(i) != '(') {\n\
    \            count += 1\n            i += 1\n        }\n\n        // if the brackets\
    \ aren't balanced, then return false\n        var left = 0\n        var right\
    \ = brackets.length\n        while left < right {\n            // get rid of the\
    \ left-most open bracket and decrement the counter\n            val openingBracket\
    \ = brackets.charAt(left)\n            val closingBracket = brackets.charAt(right-1)\n\
    \            count += 1\n            right -= 1\n            // if the closing\
    \ bracket doesn't match the opening bracket, return false\n            if (openingBracket\
    \ != closingBracket) {\n                return false\n            }\n        \
    \    // else, move on to the next open bracket\n            left += 1\n      \
    \  }\n        // if everything matched up, return true\n        count == brackets.length",
  "        var closed = true\n        var open = 1\n        var closed1 = true\n \
    \       var open1 = 1\n        var closed2 = true\n        var open2 = 1\n   \
    \     var closed3 = true\n        var open3 = 1\n        for (i <- 0 until brackets.length)\n\
    \        {\n            if (brackets.charAt(i) == '(')\n            {\n      \
    \          if (open == 0)\n                {\n                    closed = false\n\
    \                }\n                open += 1\n            }\n            else\
    \ if (brackets.charAt(i) == ')')\n            {\n                closed -= 1\n\
    \                if (closed == 0)\n                {\n                    open1\
    \ += 1\n                    closed1 = false\n                }\n             \
    \   open1 -= 1\n            }\n            else if (brackets.charAt(i) == ')(')\n\
    \            {\n                closed2 -= 1\n                if (closed2 == 0)\n\
    \                {\n                    open2 += 1\n                    closed2\
    \ = false\n                }\n                open2 -= 1\n            }\n    \
    \        else if (brackets.charAt(i) == ')(')\n            {\n               \
    \ closed3 -= 1\n                if (closed3 == 0)\n                {\n       \
    \             open3 += 1\n                    closed3 = false\n              \
    \  }\n                open3 -= 1\n            }\n        }\n        return closed",
  "      val openingBrackets = brackets.split(\"\\\\(|\\\\)\")\n      openingBrackets.forall(x\
    \ => brackets.indexOf(x) > 0)", "        val setOfOpenings = brackets.split(\"\
    ,\").toSet\n        val setOfClosings = brackets.replace(\")\", \"\").replace(\"\
    (\", \"\").split(\",\").toSet\n\n        setOfOpenings.forall(setOfClosings.contains)",
  "        var depth = 0\n        var opens = mutable.Set()\n        var closes =\
    \ mutable.Set()\n        var stack = mutable.Stack[String]()\n\n        for (c\
    \ <- brackets) {\n            if (\"()\".contains(c))\n                opens +=\
    \ c\n            else if (\")\".contains(c))\n                closes += c\n  \
    \          else\n                stack += c\n        }\n\n        opens.foreach\
    \ { c =>\n            if (closes.contains(c)) {\n                depth -= 1\n\
    \                if (depth <= 0)\n                    return true\n          \
    \  } else {\n                depth += 1\n            }\n        }\n        return\
    \ false", "        for (i <- 0 to brackets.length - 1) {\n            if (brackets.charAt(i)\
    \ != brackets.charAt(i + 1)) {\n                return false\n            }\n\
    \        }\n        true", "        if (brackets.isEmpty) true\n        else brackets.indexOf(brackets.head)\
    \ != brackets.lastIndexOf(brackets.last)", "        var openBracket = brackets.head\n\
    \        var closedBracket = brackets.last\n        var openCount = 0\n      \
    \  var closedCount = 0\n        while (openBracket != closedBracket) {\n     \
    \       if (openBracket == \"(\") {\n                openCount += 1\n        \
    \    }\n            if (openBracket == \")\") {\n                closedCount +=\
    \ 1\n            }\n            if (openBracket == \"(\" && closedBracket == \"\
    )\") {\n                closedCount += 1\n            }\n            openBracket\
    \ = brackets(openCount)\n            closedBracket = brackets(closedCount)\n \
    \       }\n        return openCount == closedCount", "        val bracketsArray\
    \ = brackets.split(\"\")\n        var current = \"\"\n        var isCorrect =\
    \ true\n        for (elem <- bracketsArray) {\n            if (elem == \"(\")\
    \ {\n                if (!current.isEmpty)\n                    isCorrect = false\n\
    \                current += \"(\"\n            } else {\n                if (current.isEmpty)\n\
    \                    isCorrect = false\n                current += elem\n    \
    \        }\n        }\n        return isCorrect", "        // The first open bracket\
    \ in the brackets string.\n        val openBracketIndex = brackets.indexOf(\"\
    (\")\n        if (openBracketIndex < 0) return false\n        val closeBracketIndex\
    \ = brackets.lastIndexOf(\")\")\n        if (closeBracketIndex < 0) return false\n\
    \        // All the brackets in this string are open, so they all have to be closed.\n\
    \        for (i <- openBracketIndex until closeBracketIndex)\n            if (brackets.charAt(i)\
    \ != brackets.charAt(closeBracketIndex))\n                return false\n     \
    \   true", "      brackets.length % 2 == 0 => {\n        val openBrackets = brackets.substring(0,\
    \ brackets.length / 2)\n        val closeBrackets = brackets.substring(brackets.length\
    \ / 2, brackets.length)\n        closeBrackets.tail.foldLeft(true){ (acc, x) =>\
    \ acc && openBrackets.contains(\"(\" + x + \")\")}\n      }\n      else => {\n\
    \        val openBrackets = brackets.substring(0, brackets.length / 2)\n     \
    \   val closeBrackets = brackets.substring(brackets.length / 2, brackets.length\
    \ - 1)\n        closeBrackets.tail.foldLeft(true){ (acc, x) => acc && openBrackets.contains(\"\
    (\" + x + \")\")}\n      }", "        brackets.indexWhere(x => x match { case\
    \ '(': case ')' => x }) match {\n            case Some(startId) => brackets.indexWhere(x\
    \ => x match { case ')' => x }) match {\n                case Some(endId) => endId\
    \ == startId\n                case None => false\n            }\n            case\
    \ None => false\n        }", '        brackets.split("").exists(c => c.equals("(")
    || c.equals(")"))', "        val opening = brackets.split('(')\n        val closing\
    \ = brackets.split(')')\n        val opening1 = opening.length\n        val closing1\
    \ = closing.length\n\n        if (opening1 === closing1) true\n        else false",
  "        var openingBrackets : List[Char] = Nil\n        var closingBrackets : List[Char]\
    \ = Nil\n        var isOpen : Boolean = false\n        for (c <- brackets) {\n\
    \            if (c == '(') openingBrackets = openingBrackets :+ c\n          \
    \  else if (c == ')') closingBrackets = closingBrackets :+ c\n            else\
    \ if (c == '[') isOpen = !isOpen\n            else if (c == ']') isOpen = !isOpen\n\
    \        }\n\n        if (openingBrackets.size == 0) return false\n        if\
    \ (openingBrackets.size == closingBrackets.size) return true\n        for (i =\
    \ openingBrackets.length - 1; i >= 0; i--) {\n            val opening = openingBrackets.head\n\
    \            val closing = closingBrackets.head\n            if (isOpen && !(opening\
    \ == closing)) false\n            else if (!isOpen && (opening == closing)) true\n\
    \            else\n                false\n        }", "        def bracketCount(s:\
    \ String): Int = {\n            var bracketCount = 0\n            for(i <- 0 until\
    \ s.length){\n                if(s(i) == '(')\n                    bracketCount++\n\
    \                else\n                    bracketCount -= 1\n            }\n\
    \            bracketCount\n        }\n        val openingBracketSet = Set(brackets.toCharArray)\n\
    \        val closingBracketSet = Set(brackets.toCharArray.reverse)\n        openingBracketSet.forall\
    \ {\n            closingBracketSet.contains(_)\n        }", "        val result\
    \ = (brackets takeWhile { !_.isDigit}).length == brackets.length\n        result\
    \ || (brackets indexOf \"(\" map (_.toInt) filter { i => brackets(i+1).equals(\"\
    (\") }.length == 0)", "        brackets.length == 2 => {\n            val openingBrackets\
    \ = brackets.substring(0,brackets.length-1).split(\",\")\n            val closingBrackets\
    \ = brackets.substring(brackets.length-1).split(\",\")\n            if(openingBrackets.forall(closingBrackets.contains))\
    \ true\n            else false\n        }\n        else false", "        if(brackets.length\
    \ == 0) return true\n        val opens = brackets.split(\"\\\\(\").map(_.toInt).toSet\n\
    \        val closes = brackets.split(\"\\\\)\").map(_.toInt).toSet\n        closes.subsetOf(opens)",
  "        assert(brackets.length == 2)\n\n        var openingBracketCount : Int =\
    \ 0\n        var closingBracketCount : Int = 0\n\n        brackets.foreach {\n\
    \          case '(' -> openingBracketCount += 1\n          case ')' -> closingBracketCount\
    \ += 1\n        }\n        assert(openingBracketCount == closingBracketCount)\n\
    \        assert(openingBracketCount == 0)\n        true", '        brackets.replaceAll("\\(|\\)",
    "").split("\\(").map(_.length).toSeq.sum == brackets.length', '        brackets.sliding(2).forall(a
    => a(0) == a(1))', "        var opening = false\n        var closing = false\n\
    \        for (bracket <- brackets.toList) {\n            opening match {\n   \
    \             case true => closing = bracket == '('\n                case false\
    \ => closing = bracket == ')'\n            }\n            opening match {\n  \
    \              case true => opening = closing = true\n                case false\
    \ => opening = closing = false\n            }\n        }\n        !opening &&\
    \ !closing", "      brackets.split(\"\").map(_ == '(' || _ == ')').\n        foldLeft(false){_\
    \ && _}", "        def isBracket(s : String) : Boolean = (s contains \"(\" &&\
    \ s contains \")\")\n        def checkOpeningBracket(i: Int) : Boolean = brackets.charAt(i)\
    \ == '('\n        def checkClosingBracket(i: Int) : Boolean = brackets.charAt(i)\
    \ == ')'\n        def checkIncorrectBracket(i: Int) : Boolean = !checkOpeningBracket(i)\
    \ && !checkClosingBracket(i)\n        val n = brackets.length\n        (1 until\
    \ n).exists(i => !checkIncorrectBracket(i))", "        val opening = brackets.toList\n\
    \        val closing = brackets.reverse.toList\n        if (opening.length ==\
    \ 0 || closing.length == 0) {\n            return true\n        }\n        var\
    \ stack : Stack[String] = new Stack[String]\n        for(i <- 0 until opening.length)\
    \ {\n            if(!stack.isEmpty && closing(i) == stack.peek()) {\n        \
    \        stack.pop()\n            } else {\n                stack += opening(i)\n\
    \            }\n        }\n        stack.isEmpty", "        val stack = new Stack[String]()\n\
    \        val openingBrackets = {\n            val ret = new mutable.Set[String]()\n\
    \            val inStack = {\n                stack.size() > 0\n            }\n\
    \            while (stack.nonEmpty) {\n                val openingBracket = stack.pop()\n\
    \                ret += openingBracket\n                if (inStack) {\n     \
    \               if (openingBracket != \")\") return false\n                } else\
    \ {\n                    if (openingBracket == \"(\") {\n                    \
    \    stack += \")\"\n                    } else if (openingBracket == \")\") {\n\
    \                        stack += \"(\"\n                    }\n             \
    \   }\n            }\n            ret.toSeq\n        }\n        brackets.split(\"\
    \\\\(\").length == openingBrackets.toSeq.length", "        if(brackets == \"\"\
    )\n            return true\n        val openingBrackets = brackets.split(\"\\\\\
    (\")\n        val closingBrackets = brackets.split(\"\\\\)\")\n        val bracketsMap\
    \ = new mutable.HashMap[String, Int]()\n        val closedBracketsMap = new mutable.HashMap[String,\
    \ Int]()\n        openingBrackets.foreach(bracketsMap add (brackets))\n      \
    \  closingBrackets.foreach(bracketsMap add (brackets))\n        openingBrackets.foreach(bracketsMap\
    \ remove (brackets))\n        closingBrackets.foreach(bracketsMap remove (brackets))\n\
    \        closedBracketsMap addAll bracketsMap\n        val closedBrackets = closedBracketsMap.keySet\n\
    \        closedBrackets.contains(brackets) && (closingBrackets.size == closedBrackets.size)\
    \ && (openingBrackets.size == closedBrackets.size);", "      var stack : Stack[String]\
    \ = new Stack[String]\n      val result = new Stack[Boolean]()\n      var inBrackets\
    \ = false\n      var index = 0\n      for(i <- brackets.indices) {\n        val\
    \ c = brackets(i)\n        if(c != \")\" && c != \")(\") {\n          result.push(c\
    \ != \")\")\n        } else {\n          inBrackets = true\n          stack.push(brackets(i))\n\
    \        }\n      }\n      while(inBrackets) {\n        index += 1\n        val\
    \ c = brackets(index)\n        if(c != \")\" && c != \")(\") {\n          result.push(c\
    \ != \")\")\n        } else {\n          inBrackets = false\n          stack.push(brackets(index))\n\
    \        }\n      }\n      result.pop()", "        if(brackets.length < 2) return\
    \ true\n        val open = brackets.substring(0,1)\n        val close = brackets.substring(brackets.length-1,brackets.length)\n\
    \        if(open eq close) return false\n        val opens = open.split(\"\\\\\
    )\")\n        val closes = close.split(\"\\\\(\")\n        val openCount = opens.length\n\
    \        val closeCount = closes.length\n        // count the number of open parentheses\n\
    \        var openCount:Int = 0\n        for(i <- 0 until opens.length) if(opens(i)\
    \ eq \"(\") openCount += 1\n        // count the number of closing parentheses\n\
    \        var closeCount:Int = 0\n        for(i <- 0 until closes.length) if(closes(i)\
    \ eq \")\") closeCount += 1\n        // if the open count is equal to the close\
    \ count, all are paired correctly\n        if(openCount >= closeCount) return\
    \ true\n        // if the open count is less than or equal to the close count,\
    \ check if any opening brackets are missing.\n        if(openCount < closeCount)\
    \ {\n            val missingOpenCount = (closeCount-openCount)\n            val\
    \ missingCloseCount = (openCount-closeCount)\n            for(i <- 0 until openCount)\
    \ if(closes(i) eq \"(\") {\n                if(missingOpenCount == 0) return true\n\
    \                missingOpenCount -= 1\n            }\n            for(i <- 0\
    \ until closeCount) if(opens(i) eq \")\") {\n                if(missingCloseCount\
    \ == 0) return true\n                missingCloseCount -= 1\n            }\n \
    \       }\n        // if both open/close count are less than or equal to zero,\
    \ the brackets are incorrectly paired.\n        return false", "        // use\
    \ a stack to store pairs of brackets \n        var stack : Stack[Char] = new Stack[Char]()\n\
    \        // for every bracket in the brackets string, add a pair \n        //\
    \ to the stack if it exists, else add a new pair\n        brackets.toSeq.foreach(c\
    \ => {\n            stack match {\n                case Nil => stack push c\n\
    \                case x :: Nil => stack push c\n                case x :: xs =>\
    \ stack push c\n            }\n        })\n        \n        // while the stack\
    \ is not empty\n        while (stack.nonEmpty) {\n            // take the first\
    \ bracket off the stack\n            // if it is closed, then the matching pair\
    \ must be the empty string \"\"\n            val c = stack.head\n            stack\
    \ = stack.tail\n            val pair = (c, \"\")\n            c match {\n    \
    \            case ')' => {\n                    if (stack.isEmpty) {\n       \
    \                 return false\n                    }\n                    val\
    \ top = stack.head\n                    stack = stack.tail\n                 \
    \   pair match {\n                        case (\"(\", _) => stack.push c\n  \
    \                      case (_, \")\") => stack = stack :+ top\n             \
    \       }\n                }\n                case ')' => {\n                \
    \    if (stack.isEmpty) {\n                        return false\n            \
    \        }\n                    val top = stack.head\n                    stack\
    \ = stack.tail\n                    pair match {\n                        case\
    \ (\"(\", _) => stack.push c\n                        case (_, \")\") => stack\
    \ = stack :+ top\n                    }\n                }\n                case\
    \ _ => false\n            }\n        }\n        true", "        var count = 1\n\
    \        val bracketCountMap : mutable.Map[String, Int] = mutable.Map()\n    \
    \    for (i <- 0 until brackets.length - 1) {\n            if (brackets(i) ==\
    \ brackets(i + 1)) {\n                count += 1\n                bracketCountMap\
    \ += (brackets(i) -> count)\n            } else {\n                count = 0\n\
    \            }\n        }\n        bracketCountMap.toSeq.exists(a => a._2 > 0)\
    \ // only take in account keys with more than 0 value.", "        brackets match\
    \ {\n            case \"\" => false\n            case \")(\"  => true\n      \
    \      case \")(\"  => true\n            case \")(\"  => true\n            case\
    \ \")(\"  => true\n            case \")((\"  => false\n            case \")((\"\
    \  => false\n            case \")(\"  => false\n            case \")((\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case \")(\"  => false\n            case \")(\"  => false\n      \
    \      case \")(\"  => false\n            case \")(\"  => false\n            case\
    \ \")(\"  => false\n            case \")(\"  => false\n            case \")(\"\
    \  => false\n            case \")(\"  => false\n            case \")(\"  => false\n\
    \            case ", "        val bracketsArray = brackets.toArray\n        var\
    \ count : Int = 0\n        var open : Boolean = false\n        var close = false\
    \ \n        var inClosed : Boolean = false\n        var currentOpen = -1 // first\
    \ open bracket\n        var currentClose : Int = -1 // first close bracket\n\n\
    \        // loop through array\n        for (a <- 0 until bracketsArray.length)\
    \ {\n            count += 1 \n            open = bracketsArray(a) == \"+\" ||\
    \ bracketsArray(a) == \"-\"\n            currentOpen = bracketsArray(a) == \"\
    +\" ? 0 : bracketsArray(a) == \"-\" ? 1 : -1\n\n            if (currentOpen ==\
    \ -1) {\n                // if there is no opening bracket yet\n             \
    \   if (open) {\n                    // if there is a closing bracket we still\
    \ have a problem\n                    if (count == 1) {\n                    \
    \    if (inClosed) {\n                            // if we are in a closed bracket\n\
    \                            if (bracketsArray(a) != \")\") {\n              \
    \                  // if we are not in the last bracket\n                    \
    \            return false\n                            } else {\n            \
    \                    // if in the last bracket and last open bracket and \n  \
    \                              // last closed bracket, we are still ok\n     \
    \                           return true\n                            }\n     \
    \                   } else {\n                            // if we are in the\
    \ first bracket\n                            if (bracketsArray(a) != \")\") {\n\
    \                                // if we are not in the last bracket\n      \
    \                          return true\n                            } else {\n\
    \                                // if in the last bracket and last open bracket\n\
    \                                // we are still ok\n                        \
    \        return true\n                            }\n                        }\n\
    \                    } else {\n                        // if we are in the last\
    \ bracket\n                        if (bracketsArray(a) != \")\") {\n        \
    \                    // if we are not in the last bracket\n                  \
    \          return true\n                        } else {\n                   \
    \         // if we are in the last bracket and last open bracket\n           \
    \                 // we are still ok\n                            return true\n\
    \                        }\n                    }\n                } else {\n\
    \                    // if we have not opened the bracket\n                  \
    \  if (count == 1) {\n                        // if we are in the first bracket\n\
    \                        if (bracketsArray(a) != \")\") {\n                  \
    \          // if we are not in the last bracket\n                            return\
    \ true\n                        } else {\n                            // if we\
    \ are in the last bracket and last open bracket\n                            //\
    \ we are still ok\n                            return true\n                 \
    \       }\n                    } else {\n                        // if we are\
    \ in the last bracket\n                        if (bracketsArray(a) != \")\")\
    \ {\n                            // if we are not in the last bracket\n      \
    \                      return true\n                        } else {\n       \
    \                     // if we are in the last bracket and last open bracket\n\
    \                            // we are still ok\n                            return\
    \ true\n                        }\n                    }\n                }\n\
    \            } else {\n                // if we have opened the bracket\n    \
    \            if (!open) {\n                    // if we are in the last bracket\n\
    \                    if (count == 1) {\n                        // if we are in\
    \ the first bracket\n                        if (bracketsArray(a) != \")\") {\n\
    \                            // if we ", "        var opening = false\n      \
    \  var closing = false\n        var bracketCount = 0\n        var stack = collection.mutable.Stack[String]()\n\
    \        for (c <- brackets) {\n            if (c == '(') {\n                if\
    \ (opening && !closing) {\n                    stack.push(brackets)\n        \
    \            closing = true\n                    opening = false\n           \
    \     } else {\n                    opening =  true\n                }\n     \
    \       } else if(c == ')') {\n                if (opening && !closing) {\n  \
    \                  val newBrackets = stack.pop()\n                    if (newBrackets\
    \ != null && newBrackets.nonEmpty) {\n                        closing = true\n\
    \                        opening = false\n                    } else {\n     \
    \                   closing = false\n                    }\n                }\
    \ else {\n                    closing =  true\n                }\n           \
    \ }\n            bracketCount++\n        }\n        return bracketCount == 1",
  "        var opening = 0\n        var closing = 0\n        var openingInBracket\
    \ = false\n        var closingInBracket = false\n        var currentBracket =\
    \ 0\n        var isOpen = false\n        for( char <- brackets ) {\n         \
    \   if(char == \"(\") opening += 1\n            else if(char == \")\") closing\
    \ += 1\n            else if(char == \")\")\n                if(opening > 0) {\n\
    \                    opening = opening - 1\n                    openingInBracket\
    \ = true\n                }\n            else if(char == \"(\")\n            \
    \    if(closing > 0) {\n                    closing = closing - 1\n          \
    \          closingInBracket = true\n                }\n            else if(openingInBracket\
    \ && closingInBracket)\n                currentBracket = currentBracket + 1\n\
    \            else if(openingInBracket)\n                openingInBracket = false\n\
    \            else if(closingInBracket)\n                closingInBracket = false\n\
    \        }\n        if(opening == 0 || closing == 0) false\n        else if(openingInBracket\
    \ && closingInBracket) {\n            if(opening > closing) true\n           \
    \ else false\n        } else if(openingInBracket) {\n            if(closing >\
    \ 0) false\n            else true\n        } else if(closingInBracket) {\n   \
    \         if(opening > 0) true\n            else false\n        } else {\n   \
    \         if(opening > 0) true\n            else false\n        }", "        if(brackets.isEmpty)\n\
    \            return true\n        val openingBrackets = brackets.toList.dropRight(1)\n\
    \        val closingBrackets = brackets.toList.dropRight(1)\n        val openingBracketsCount\
    \ = openingBrackets.length\n        val closingBracketsCount = closingBrackets.length\n\
    \        if(openingBracketsCount != closingBracketsCount)\n            return\
    \ false\n        val openingBracketsMap = new mutable.HashMap[Char, Int]()\n \
    \       val closingBracketsMap = new mutable.HashMap[Char, Int]()\n        val\
    \ openingBracketsStack = new Stack[Char]()\n        val closingBracketsStack =\
    \ new Stack[Char]()\n        for(i <- 0 until openingBracketsCount) {\n      \
    \      openingBracketsMap += openingBrackets(i) -> openingBracketsStack.push(i)\n\
    \            closingBracketsMap += closingBrackets(i) -> closingBracketsStack.push(i)\n\
    \        }\n        openingBracketsStack.foreach(openingBracketsMap += _)\n  \
    \      closingBracketsStack.foreach(closingBracketsMap += _)\n        for(i <-\
    \ 0 until openingBracketsCount) {\n            if(openingBracketsMap.getOrElse(openingBrackets(i),\
    \ 0) != closingBracketsMap.getOrElse(closingBrackets(i), 0))\n               \
    \ return false\n        }\n        true", "        val bracketsArray = brackets.toCharArray\n\
    \        val length = brackets.length\n        if (length < 2) {\n           \
    \ return true\n        }\n        var openingBracketsFound = 0\n        var closingBracketsFound\
    \ = 0\n        var isCorrect = true\n        val openingBracketsArray = Array()\n\
    \        val closingBracketsArray = Array()\n        for (index <- 0 until length)\
    \ {\n            if (bracketsArray(index) == '(') {\n                openingBracketsFound\
    \ += 1\n                openingBracketsArray += index\n            } else if (bracketsArray(index)\
    \ == ')') {\n                closingBracketsFound += 1\n                closingBracketsArray\
    \ += index\n            }\n        }\n        for (openingBracket <- openingBracketsArray)\
    \ {\n            if (openingBracket < closingBracketsArray) {\n              \
    \  isCorrect = false\n            }\n        }\n        return isCorrect", " \
    \       val openings = brackets.substring(1,brackets.length-1).split(\"\\\\)\"\
    ).toList\n        val closings = brackets.substring(0,1).split(\"\\\\(\").toList\n\
    \        val allOpenings = openings.toSet.equals(closings.toSet)\n        if(!allOpenings)\
    \ false\n        else openings.forall(opening => {\n          closings.find(closing\
    \ => {\n            opening == closing\n          }) == None\n        })", " \
    \       // create a map from opening bracket to closing bracket\n        var map\
    \ = mutable.Map.empty[Char, Char]\n        var count = 0\n        for (c <- brackets)\
    \ {\n            map.getOrElseUpdate(c.charAt(0), c.charAt(0))\n            map.getOrElseUpdate(c.charAt(1),\
    \ c.charAt(1))\n            count += 1\n        }\n        // if there are fewer\
    \ than 3 closing brackets, return false\n        if (count < 3) return false;\n\
    \        // return true if there are exactly 3 closing brackets\n        if (count\
    \ == 3) return true;\n        // return true if there are 2 or fewer closing brackets\n\
    \        if (count > 3) return true;\n        // return false if there is an extra\
    \ opening bracket\n        return map.getOrElse(map.getOrElse(chars.charAt(0),\
    \ chars.charAt(0)), chars.charAt(0)) != chars.charAt(1)", "        if (brackets.length\
    \ != 2)\n            return false\n        val openingBrackets = brackets.toList\n\
    \        var closedBracketsCount = 0\n        for (i <- 0 until openingBrackets.length)\
    \ {\n            if (openingBrackets(i) == \")\") {\n                closedBracketsCount\
    \ += 1\n                if (closedBracketsCount == openingBrackets.length)\n \
    \                   return true\n            }\n            if (openingBrackets(i)\
    \ == \"(\") {\n                closedBracketsCount = 0\n            }\n      \
    \  }\n        return false", "        val openingBrackets = brackets.replaceAllLiterally(\"\
    \\\\()\", \"\")\n        val closingBrackets = brackets.replaceAllLiterally(\"\
    \\\\)\", \"\")\n        openingBrackets.size == closingBrackets.size", "     \
    \   val openingBrackets = brackets.split(\"(\").map(_.trim).toSet\n        val\
    \ closingBrackets = brackets.split(\")\").map(_.trim).toSet\n        openingBrackets.forall(closingBrackets.contains)\
    \ || closingBrackets.forall(openingBrackets.contains)", "      brackets.foldLeft(true)((acc,\
    \ x) =>\n        if (x == '(') acc else acc && correctBracketing(x+')'))", " \
    \       val b = new mutable.ListBuffer[String]()\n        brackets.split(\"\"\
    ).foreach(x => if (x == \"(\") b.append(\")\") else b.append(\"(\"))\n       \
    \ b.drop(1).forall(x => x == \"(\")", "        // The opening bracket must be\
    \ closed by a matching closing bracket.\n        def isOpeningBracket(c : String)\
    \ : Boolean = c.charAt(0) == '('\n        def isClosingBracket(c : String) : Boolean\
    \ = c.charAt(0) == ')'\n        val openingBrackets = new mutable.HashSet[String]()\n\
    \        val closingBrackets = new mutable.HashSet[String]()\n        def openingBracketAdd(c\
    \ : String) : Unit = {\n            openingBrackets += c\n        }\n        def\
    \ closingBracketAdd(c : String) : Unit = {\n            closingBrackets += c\n\
    \        }\n        def bracketAdds(c : String) : Unit = {\n            if (isOpeningBracket(c))\
    \ openingBracketAdd(c)\n            else if (isClosingBracket(c)) closingBracketAdd(c)\n\
    \        }\n        brackets.toList.foreach(bracketAdds)\n        openingBrackets.size\
    \ == closingBrackets.size", "        val openingBrackets = brackets.replace(\"\
    )\", \"\").replace(\"(\", \"\").toCharArray\n        val closingBrackets = brackets.replace(\"\
    )\", \"\").replace(\"(\", \"\").reverse.toCharArray\n        val openingBracketMap\
    \ : mutable.Map[Char, Int] = new mutable.HashMap[Char, Int]()\n        val closingBracketMap\
    \ : mutable.Map[Char, Int] = new mutable.HashMap[Char, Int]()\n        openingBrackets.foreach(openingBracket\
    \ => {\n            openingBracketMap(openingBracket) = 1\n        })\n      \
    \  closingBrackets.foreach(closingBracket => {\n            closingBracketMap(closingBracket)\
    \ = 1\n        })\n        openingBracketMap.length == closingBracketMap.length",
  "        val b = new Array[Char](brackets.length)\n        brackets.toCharArray.foreach(bracket\
    \ => b.put(bracket._1, bracket._2))\n        val stack = new Stack[Char](b.length)\n\
    \        val result = {\n            // push opening brackets\n            while\
    \ (stack.nonEmpty) {\n                stack.pop() match {\n                  \
    \  // push \"(\" to the stack\n                    case c if (c == '(') => stack.push('(')\n\
    \                    // push \")\" to the stack\n                    case c if\
    \ (c == ')') => stack.pop()\n                }\n            }\n            //\
    \ pop opening brackets\n            while (stack.nonEmpty) {\n               \
    \ stack.peek() match {\n                    // push \"]\" to the stack\n     \
    \               case c if (c == ')') => stack.pop()\n                    // push\
    \ \"]\" to the stack\n                    case c if (c == ']') => stack.pop()\n\
    \                }\n            }\n            stack.isEmpty\n        }\n    \
    \    result", "        var bracketCount : Int = 0\n        var openingBracket\
    \ : Char = ' '\n        var closingBracket : Char = ' '\n        for(i <- 0 until\
    \ brackets.length) if(brackets(i) equals('(')) {\n            openingBracket =\
    \ brackets(i)\n            bracketCount += 1\n        } else if(brackets(i) equals(')'))\
    \ {\n            closingBracket = brackets(i)\n            bracketCount -= 1\n\
    \        }\n        if(bracketCount != 0) false\n        else {\n            if(brackets(0)\
    \ equals('(')) false\n            else true\n        }", "        if (brackets\
    \ == null || brackets.isEmpty) {\n            return false\n        }\n      \
    \  // a stack of characters that need to be balanced.\n        // each character\
    \ is pushed onto the stack as it appears.\n        val stack : List[Char] = ListBuffer.empty\n\
    \        for (c <- brackets.toCharArray) {\n            // push \"c\" onto the\
    \ stack if it isn't a left or right bracket.\n            if (c != ')' && c !=\
    \ '(') {\n                stack ++= c\n            }\n        }\n        // check\
    \ to see if there are any remaining characters.\n        if (stack.nonEmpty) {\n\
    \            // if not, then brackets are balanced\n            return false\n\
    \        }\n        return true", "        val bracketsSet = brackets.toSet\n\
    \        bracketsSet.map( b => if (bracketsSet.count(b) > 1) true else false).sum\
    \ == bracketsSet.size", "        if(brackets.length !=1)\n            return false\n\
    \        val stack = mutable.Stack[String]()\n        val current: String = brackets.head\n\
    \        stack.push(current)\n        var openCount = 1\n        while(stack.size>0)\
    \ {\n            val current = stack.pop()\n            if(current.equals(openCount+\"\
    (\")) {\n                openCount += 1\n                stack.push(current+\"\
    (\")\n            } else if(current.equals(openCount+\")\")) {\n             \
    \   openCount -= 1\n                stack.push(current+\")\")\n            } else\
    \ {\n                return false\n            }\n        }\n        return true",
  "        // the stack is a mutable stack of pairs.\n        // the pair is (opening\
    \ bracket, closing bracket)\n        val stack = new mutable.Stack[(String, String)]\n\
    \        // loop through the brackets.\n        for (i <- 0 until brackets.length)\n\
    \            // if the brackets contains the open bracket, push it onto the stack.\n\
    \            if (brackets(i) == '(')\n                stack.push((brackets(i),\
    \ \"\"))\n            // if the brackets contains the close bracket, replace it\
    \ with the open bracket.\n            else if (brackets(i) == ')')\n         \
    \       stack.pop() match {\n                    case ('(', \"\") => stack.pop()\n\
    \                    case ('', ')') => stack.push((brackets(i), '('))\n      \
    \              case _ => stack.push((brackets(i), brackets(i)))\n            \
    \    }\n            // if the brackets does not contain the open or close bracket,\
    \ return false immediately.\n            else\n                return false\n\n\
    \        // if the stack is empty, then the bracketing is correct.\n        stack.isEmpty",
  "        var count : Int = 0\n        var position : Int = 0\n        for (bracket\
    \ <- brackets) {\n            if (bracket.equals(\"(\")) {\n                count\
    \ += 1\n            } else if (bracket.equals(\")\")) {\n                if (count\
    \ > 0) {\n                    count -= 1\n                }\n            }\n \
    \           position += bracket.length\n        }\n        if (count > 0) return\
    \ false\n        position >= brackets.length &&\n            (brackets.slice(position).equals(\"\
    ()\") ||\n                brackets.slice(position).equals(\"[]\"))", "       \
    \ var openingBracket = -1;\n        var openingBrackets : List[Int] = List();\n\
    \        var closingBracket = -1\n        var closingBrackets : List[Int] = List();\n\
    \n        // iterate through all the characters in brackets string\n        //\
    \ if openingBracket == -1 then we are dealing with a closing bracket\n       \
    \ // else we are dealing with a opening bracket\n        for ( var i = 0; i <\
    \ brackets.length; i++ ) {\n            if ( brackets.charAt(i) == '(' )\n   \
    \             openingBracket = i\n            else if ( brackets.charAt(i) ==\
    \ ')' )\n                closingBracket = i\n        }\n\n        // if openingBracket\
    \ == -1 or closingBracket == -1 then there is an \"unbalanced\" pair\n       \
    \ if ( openingBracket == -1 || closingBracket == -1 ) {\n            return false\n\
    \        }\n\n        // get a list of all brackets before the openingBracket\n\
    \        val before = brackets.substring(0, openingBracket)\n\n        // get\
    \ a list of all brackets after the openingBracket\n        val after = brackets.substring(openingBracket,\
    \ closingBracket)\n\n        // add 1 to all brackets before the openingBracket\n\
    \        before.zipWithIndex.foreach { x => x._2 += 1; x._1 += 1 }\n\n       \
    \ // add 1 to all brackets after the openingBracket\n        after.zipWithIndex.foreach\
    \ { x => x._2 += 1; x._1 += 1 }\n\n        // go through the brackets after the\
    \ openingBracket\n        // if one of them is equal to -1 then we know that there\
    \ is a unbalanced pair\n        // if they are all equal then we have an \"unbalanced\"\
    \ pair\n        // otherwise we have a correct pair\n        var correctBracketing\
    \ = false\n        for ( i <- after.zipWithIndex.filter(_._1 == -1) ) {\n    \
    \        if ( i._1 == openingBracket )\n                correctBracketing = true\n\
    \        }\n\n        if ( correctBracketing )\n            return false\n   \
    \     else\n            return true", "        val counting = brackets.groupBy(c\
    \ => c).mapValues(_.length)\n        val opening = counting.filter(_._2 > 1).map(_._1)\n\
    \        val closing = counting.filter(_._2 <= 1).map(_._1)\n        opening.forall(opening\
    \ => closing.contains(opening))", "        val bracketsSet = brackets.toList\n\
    \        val closingBrackets = bracketsSet.foldLeft(List[String]()){ case (acc,\
    \ b) =>\n            if(acc.contains(b)) acc else acc ::: List(b)\n        }\n\
    \        val openingBrackets = bracketsSet.diff(closingBrackets)\n        openingBrackets.size\
    \ == bracketsSet.size", "        var inside = false\n        var i = 0\n     \
    \   var j = 0\n        while (i < brackets.length) {\n            j = brackets.length\n\
    \            while (j < brackets.length && !inside) {\n                if (brackets(i)\
    \ == brackets(j)) {\n                    inside = true\n                    j++\n\
    \                } else {\n                    j++\n                }\n      \
    \      }\n            i += 1\n        }\n        i == brackets.length", "    \
    \    var foundBracket = false // true if we found an opening bracket\n       \
    \ var foundClosingBracket = false // true if we found a closing bracket\n    \
    \    for (bracket <- brackets.toCharArray) {\n            if (foundBracket) {\n\
    \                if (foundClosingBracket) {\n                    return false\n\
    \                }\n                if (bracket = ')') {\n                   \
    \ foundClosingBracket = true\n                }\n            } else {\n      \
    \          if (bracket = ')') {\n                    return false\n          \
    \      }\n                foundBracket = true\n            }\n        }\n    \
    \    return foundClosingBracket", "        val stack = mutable.Stack[String]()\n\
    \        val pairs = brackets.chars.toList.flatMap(c => {\n            if (c ==\
    \ '(') stack += '('\n            else if (c == ')') stack -= '('\n           \
    \ else if (c != ')' && c != ')()') stack += '('\n            else stack\n    \
    \    })\n        if (stack.size == 0) true\n        else if (stack.head.isEmpty)\
    \ false\n        else pairs.toList.forall(c => stack.last.head.isEmpty || stack.last.head\
    \ == c) // if all open brackets are closed, then this string is correct", "  \
    \      // initialize a stack containing open brackets\n        var stack = ListBuffer[String]()\n\
    \        // initialize a mutable container to store our result\n        var result\
    \ = 0\n        // loop through the input string\n        for (c <- brackets) {\n\
    \            // if we see a left bracket, push to stack\n            if (c ==\
    \ '(') stack += '('\n            // if we see a right bracket, pop from stack\n\
    \            else stack -= '('\n            // if we are on the stack count the\
    \ number of left brackets\n            // and compare to our target count of open\
    \ brackets\n            if (stack.length >= target) result = stack.length\n  \
    \      }\n        // if we got to the end of the input string, our result is correct\n\
    \        result == target", "        // The brackets string will always have one\
    \ opening bracket and one closing bracket.\n        // If not, then this is not\
    \ a correct bracketing expression.\n        if (brackets.length != 1) return false\n\
    \n        // Keep track of the number of opening brackets.\n        // If this\
    \ number is not 1, then we do not have a correctly bracketing expression.\n  \
    \      var openingBrackets = 0\n        // Keep track of the number of closing\
    \ brackets.\n        // If this number is not 1, then we do not have a correctly\
    \ bracketing expression.\n        var closingBrackets = 0\n\n        // Iterate\
    \ over the length of the brackets string.\n        // For each character, increment\
    \ the corresponding counter by 1.\n        // If the character is the opening\
    \ bracket, increment the opening brackets counter.\n        // If the character\
    \ is the closing bracket, decrement the closing brackets counter.\n        //\
    \ Stop when the counter reaches 0.\n        for( i <- 0 until brackets.length\
    \ ) {\n            if( brackets(i) == '(' ) {\n                openingBrackets\
    \ += 1\n            } else if ( brackets(i) == ')' ) {\n                closingBrackets\
    \ -= 1\n            } else\n                if( closingBrackets != openingBrackets\
    \ ) {\n                    return false\n                }\n        }\n\n    \
    \    // If we made it here, then every bracket has a corresponding closing bracket.\n\
    \        return true", "        val stack = mutable.Stack[String]()\n        for\
    \ (char <- brackets) {\n            // if char equals \")\"\n            if (char\
    \ == \"(\") {\n                // then push a new string onto the stack \n   \
    \             stack.push(\")\")\n            } else { // otherwise, check whether\
    \ stack is empty or not\n                if (stack.nonEmpty) {\n             \
    \       // if the stack is not empty, then we have a matching closing bracket\n\
    \                    val top = stack.pop()\n                    if (top != char)\
    \ {\n                        return false\n                    }\n           \
    \     }\n            }\n        }\n        true", "        val pairs = brackets.toList\n\
    \        val firstIndex = pairs.indexOf(\"(\")\n        if (firstIndex < 0 ||\
    \ firstIndex >= pairs.length-1)\n            return false\n        val secondIndex\
    \ = pairs.indexOf(\")\", firstIndex+1)\n        if (secondIndex < 0)\n       \
    \     return false\n        return pairs(firstIndex+1) != pairs(secondIndex)",
  "        val stack = mutable.Stack[String]()\n        // go through each character\
    \ of the brackets\n        for (c <- brackets) {\n            val openingBracket\
    \ = c\n            if (stack.isEmpty) {\n                stack += openingBracket\n\
    \            } else if (openingBracket == stack.last) {\n                stack\
    \ += openingBracket\n            } else if (openingBracket != stack.last) {\n\
    \                stack += openingBracket\n            }\n        }\n        //\
    \ return true if there are exactly same number of \"(\",\")\" pairs \n       \
    \ // and if the last one is \"(\" and the stack is empty.\n        // otherwise,\
    \ return false.\n        stack.size == brackets.length && stack.isEmpty ", " \
    \       val chars = brackets.toList\n        var found = false\n        val opening\
    \ = mutable.ListBuffer[String]()\n        var closing = mutable.ListBuffer[String]()\n\
    \        chars.foreach { c =>\n            if (c == '(') opening += c\n      \
    \      else if (c == ')') closing += c\n            else {\n                if\
    \ (opening.isEmpty && closing.isEmpty) {\n                    found = true\n \
    \                   true\n                } else {\n                    val open\
    \ = opening.last\n                    val close = closing.last\n             \
    \       if (open != close && c == '(') {\n                        opening += c\n\
    \                        closing.clear()\n                    } else {\n     \
    \                   opening += c\n                        closing.clear()\n  \
    \                  }\n                }\n            }\n        }\n        found",
  "        brackets.length == 0 ||\n            (brackets.charAt(0) == brackets.charAt(brackets.length-1)\
    \ &&\n             brackets.contains(\"()\"))", "        var bracketStack = ListBuffer[String]()\n\
    \        for ( bracket <- brackets ) {\n            if ( bracket == \"(\" ) {\n\
    \                bracketStack += bracket\n            } else if ( bracket == \"\
    )\" ) {\n                if ( bracketStack.isEmpty ) {\n                    return\
    \ false\n                }\n                bracketStack -= bracket\n        \
    \    }\n        }\n        return bracketStack.size == 0", "        val numOpenBrackets\
    \ = brackets.split(\"\\\\(\").length\n        val numClosedBrackets = brackets.split(\"\
    \\\\)\").length\n        if (numOpenBrackets == numClosedBrackets) {\n       \
    \     false\n        } else {\n            true\n        }", "        // Keep\
    \ track of how many pairs have been seen (pairCount starts at 0\n        // and\
    \ increases with each opening bracket). We can't close\n        // a bracket until\
    \ we opened a corresponding opening bracket.\n        var pairCount = 0\n\n  \
    \      // Keep track of how many opening brackets we have seen so far.\n     \
    \   var openCount = 0\n\n        val bracketsAsList = brackets.toList\n\n    \
    \    // Iterate through bracketsAsList starting at index 0.\n        // This way\
    \ the first index in the bracketsAsList is the\n        // first opening bracket\
    \ in the string.\n        var currentBracket = bracketsAsList.head\n        while\
    \ (openCount < openBrackets(currentBracket)) {\n            // Increment the count\
    \ by one\n            pairCount += 1\n            // Keep track of the number\
    \ of opening brackets\n            // we have seen so far\n            openCount\
    \ += 1\n            // Now move to the next opening bracket\n            currentBracket\
    \ = bracketsAsList(openCount)\n        }\n        // Now that we've iterated through\
    \ all brackets\n        // and we have counted all pairs, we can safely\n    \
    \    // return whether we've seen all of the opening\n        // brackets\n  \
    \      openCount == openBrackets(currentBracket)", "        var count = 0\n  \
    \      var opening_symbol = \"\"\n        for {\n            opening <- brackets.toList\n\
    \            opening match {\n                case \"(\" => opening_symbol = \"\
    (\" //to count the brackets we begin from left and go towards right\n        \
    \        case \")\" => opening_symbol = \")\" //to count the brackets we begin\
    \ from right and go towards left\n                case x => opening_symbol = \"\
    \"\n            }\n            if opening == opening_symbol { count += 1\n   \
    \         } else if (opening != opening_symbol) {\n                count = 0\n\
    \                opening_symbol = \"\"\n            }\n        } while (count\
    \ != brackets.toList.length)\n        count == brackets.toList.length", "    \
    \    if (brackets.length == 0)\n            return true\n        var open = 0\n\
    \        var close = 0\n        var inside = false\n        for (cc <- brackets.toCharArray)\
    \ {\n            if (cc == '(')\n                open += 1\n            if (cc\
    \ == ')')\n                close += 1\n            if (cc == '(' && close > open)\
    \ {\n                inside =\n                    (inside || open == close)\n\
    \            }\n        }\n        return !inside", "        brackets match {\n\
    \            case \"()\" => false\n            case \"()()\" => true\n       \
    \     case \")(\"  => true\n            case \")(\" => false\n            case\
    \ _     => correctBracketing(brackets.tail)\n        }"]
stop_tokens:
- "\n    }\n"
