name: HumanEval_18_how_many_times
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n    // >>> howManyTimes((\"\"), (\"a\"))\n    // (0l)\n\
  \    // >>> howManyTimes((\"aaa\"), (\"a\"))\n    // (3l)\n    // >>> howManyTimes((\"\
  aaaa\"), (\"aa\"))\n    // (3l)\n    def howManyTimes(string : String, substring\
  \ : String) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(howManyTimes((\"\"\
  ), (\"x\")) == (0l));\n    assert(howManyTimes((\"xyxyxyx\"), (\"x\")) == (4l));\n\
  \    assert(howManyTimes((\"cacacacac\"), (\"cac\")) == (4l));\n    assert(howManyTimes((\"\
  john doe\"), (\"john\")) == (1l));\n    }\n\n}\n"
completions: ["        val result = new mutable.HashSet[String]()\n        var substringLen\
    \ = substring.length\n        var i = string.length\n        while(i >= 0) {\n\
    \            var found = false\n            while(i <= string.length - substringLen)\
    \ {\n                if(string.substring(i, i+substringLen) == substring) {\n\
    \                    found = true\n                    result.add(string.substring(i,\
    \ i+substringLen))\n                    i += substringLen\n                  \
    \  break\n                }\n                i += 1\n            }\n         \
    \   if(!found) {\n                break\n            }\n        }\n        result.size",
  "        var count = 1\n        for( i <- string.indices) {\n            if(string.substring(i,\
    \ i + substring.length) == substring) {\n                count += 1\n        \
    \    }\n        }\n        \n        count", "        var count : Long = 1\n \
    \       // Iterate through the substring and check each character\n        for\
    \ (i <- 0 until substring.length) {\n            if (string.indexOf(substring.charAt(i))\
    \ > -1) count = count + 1\n        }\n        count", "        val strings = string.toLowerCase.split(substring.toLowerCase)\n\
    \        if (strings.length == 0)\n            return 0\n        var count = 0\n\
    \        var lastPos = strings(0)(0).length\n        for (i<-0 until strings.length)\
    \ {\n            if (strings(i)(0).length < lastPos)\n                count +=\
    \ 1\n            lastPos = strings(i)(0).length\n        }\n        count", " \
    \       val count = mutable.HashMap.empty[String, Long]\n        val result =\
    \ mutable.HashSet.empty[String]\n        val charArray = string.toCharArray\n\
    \        for(i <- 0 until charArray.length){\n            if(charArray(i) == substring(0)){\
    \ // match start\n                val start = i\n                for(j <- start\
    \ + 1 until charArray.length){\n                    if(charArray(j) == substring(1)){\
    \ // match end\n                        val end = j\n                        count.put(substring(0,1),\
    \ count.get(substring(0,1)) + 1)\n                        count.put(substring(1,2),\
    \ count.get(substring(1,2)) + 1)\n                        val range = (start to\
    \ end)\n                        result = result.union(range)\n               \
    \     }\n                }\n            }\n        }\n        count.size", " \
    \       if(string.length < substring.length) 0l\n        else string.indexOf(substring)\
    \ + substring.length", "        val count = mutable.HashMap[(String, Int), Long]()\n\
    \        for (i <- 0 until string.length) {\n            val key = substring+string(i)\n\
    \            val count = count(key, count) + 1\n            count(key, 0)\n  \
    \      }\n        count.filter(_._2 > 1).size", "        val indexMap = mutable.HashMap.empty[String,\
    \ Long]\n        val startIndex = string.length - substring.length\n        for\
    \ (i <- 0 until substring.length) {\n            indexMap(substring.substring(i,\
    \ i + 1)) += string.length - startIndex + i\n        }\n        indexMap.size\
    \ + 1", "        val count = string.length\n        val subLength = substring.length\n\
    \n        var index = 0\n        var count = 0\n        var index1 = -1\n    \
    \    var index2 = -1\n        var nextIndex = 0\n\n        while (index < count\
    \ && index < subLength) {\n            if (string.charAt(index) == substring.charAt(0))\
    \ {\n                index1 = index\n            }\n            index += 1\n \
    \       }\n\n        while (index < count && index < subLength) {\n          \
    \  if (string.charAt(index) == substring.charAt(index1)) {\n                index1\
    \ = index\n            }\n            index += 1\n        }\n\n        while (index\
    \ < count && index < subLength) {\n            if (string.charAt(index) == substring.charAt(index2))\
    \ {\n                index2 = index\n            }\n            index += 1\n \
    \       }\n\n        while (nextIndex < count && nextIndex < subLength) {\n  \
    \          if (string.charAt(nextIndex) == substring.charAt(nextIndex + 1)) {\n\
    \                nextIndex = nextIndex + 1\n            }\n            nextIndex\
    \ += 1\n        }\n\n        if (index1 == -1 || index2 == -1) {\n           \
    \ return 0\n        }\n        return (nextIndex - index1 + subLength) + 1", " \
    \       val list = string.split(substring)\n        // print (list)\n        list.size\
    \ match {\n            case 0 => 0\n            case 1 => list.head match {\n\
    \                case \"\" => 0\n                case _ => 1\n            }\n\
    \            case _ => list.size * (list.head match {\n                case \"\
    \" => 0\n                case _ => 1\n            } + howManyTimes(list.tail,\
    \ substring)) + 1\n        }", "        if (string.length == substring.length)\
    \ 0\n        else {\n            val map = new mutable.HashMap[(String, Int),\
    \ Int]()\n            var count = 0\n            var pos = 0\n            var\
    \ pos = string.length\n            while (pos < substring.length)\n          \
    \  {\n                if (map.contains((substring, pos))) {\n                \
    \    count = count + 1\n                }\n                pos = pos + 1\n   \
    \         }\n            count\n        }", "        val stringBuilder = new StringBuilder\n\
    \        var total = 0\n        var currentChar = 0\n        var currentStart\
    \ = 0\n        var currentEnd = 0\n        \n        // Iterate over the string\n\
    \        for(i <- string.length - 1){\n            stringBuilder.append(string.charAt(i))\n\
    \            currentChar = string.charAt(i)\n            currentEnd = i + substring.length\n\
    \            currentStart = i + 1\n            while(currentStart <= currentEnd\
    \ - substring.length){\n                if(stringBuilder.substring(currentStart,\
    \ currentEnd).equals(substring)){\n                    total += 1\n          \
    \          currentStart = currentEnd + 1\n                }\n                else{\n\
    \                    currentStart = currentEnd + 1\n                }\n      \
    \      }\n        }\n        \n        return total", "        val count = new\
    \ mutable.HashMap[String, Long]()\n        substring.foreach{ c =>\n         \
    \   var temp = 0L\n            val index = string.indexOf(c)\n            while\
    \ (index >= 0) {\n                val start = index\n                val end =\
    \ index + c.length\n                if (start < end)\n                    temp\
    \ += (end - start)\n                index = string.indexOf(c, index + c.length)\n\
    \            }\n            if (count.contains(c))\n                count.update(c,\
    \ count.get(c) + temp)\n            else\n                count.put(c, temp)\n\
    \        }\n        count.size", "        var count = 0\n        for(i <- 0 until\
    \ string.length) if(string.charAt(i) == substring.charAt(0)) count+=1\n      \
    \  \n        \n        val start = string.indexOf(string)\n        val end = substring.indexOf(string)\n\
    \        \n        val len1 = string.substring(0, start).length\n        val len2\
    \ = string.substring(end, string.length).length\n        \n        val len3 =\
    \ string.substring(0, end).length\n        val len4 = string.substring(start,\
    \ end).length\n        \n        \n        if(start > end) count+((len2-len4)+(len3-len1))\n\
    \        else if(start < end) count+((len4-len3)+(len1-len2))\n        else count",
  "        // return if either string is empty\n        if (string.isEmpty || substring.isEmpty)\
    \ {\n            return 0l\n        }\n        // Create an array of booleans\
    \ where each boolean indicates the presence of a substring in each string\n  \
    \      var result = Array[Boolean](string.length).fill(false)\n        // Loop\
    \ through the substring\n        substring.foreach{s => result(0) = result(0)\
    \ && string.indexOf(s) >= 0}\n        // return total of indices where substring\
    \ exists in string \n        return result.count(_)", "        val originalString\
    \ = string\n        val subStringSet = substring.split(\"\\\\W+\")\n        val\
    \ subStringSetSet = subStringSet.toSet\n        var count = 0\n        for (i\
    \ <- 0 until originalString.length-1) {\n            if (originalString.startsWith(originalString(i))\
    \ && subStringSet.contains(originalString(i - 1)) && subStringSet.contains(originalString(i+1))\
    \ ){\n                count += 1\n            }\n        }\n        count", " \
    \       var count = 0\n        for(char <- string.toCharArray) {\n           \
    \ if(char == substring(0))\n                count += howManyTimes(string.substring(1),\
    \ substring)\n        }\n        count", "        var cnt = 0\n        var charIdx\
    \ = 0\n        var subStringIdx = 0\n\n        while (subStringIdx < substring.length)\
    \ {\n            var nextCharIdx = string.indexOf(substring.charAt(subStringIdx),\
    \ charIdx + 1)\n            if (nextCharIdx == -1) {\n                // No match\n\
    \                nextCharIdx = charIdx + 1\n            }\n            if (charIdx\
    \ + 1 == substring.length) {\n                // Match found\n               \
    \ cnt = cnt + 1\n            } else {\n                // Match not found, advance\
    \ charIdx to the right of the substring match\n                charIdx = nextCharIdx\n\
    \            }\n            subStringIdx = subStringIdx + 1\n        }\n     \
    \   cnt", "        val result = string.count(substring)\n        if (result ==\
    \ 0) 1 else result + 1", "        val substrings = string.split(substring).toSet\n\
    \        var count = 0\n        for(sub in substrings){\n            if(sub ==\
    \ substring) count+=1\n            else {\n                if(sub.startsWith(substring)){\n\
    \                    count+=(sub.length-substring.length)\n                }\n\
    \                else {\n                    count+=substring.length\n       \
    \         }\n            }\n        }\n        count", "        var counter =\
    \ 0L\n        var index = -1\n        while( (index = (string.indexOf(substring,\
    \ index+1)+1)) != -1){\n            if(index > 0){\n                if(string.charAt(index-1)\
    \ == substring.charAt(0))\n                    counter = counter + 1\n       \
    \         else {\n                    counter = 0\n                    break\n\
    \                }\n            }\n        }\n        counter", "        val counter\
    \ = mutable.ListBuffer(substring)\n        var i = 0\n        while (i < string.length)\
    \ {\n            val c = string.charAt(i)\n            if (counter.nonEmpty &&\
    \ c == counter.last) counter.last = (counter.last + 1l)\n            else counter.append(c)\n\
    \            i += 1\n        }\n        if (counter.last == substring.length)\
    \ counter.last else 0l", "        var count = 0\n        for(i <- 0 to string.length\
    \ - substring.length)\n            if(string.substring(i, i + substring.length)\
    \ == substring)\n                count += 1\n        count", "        val count\
    \ = string.length\n        val substringIndex = string.indexOf(substring)\n  \
    \      if (substringIndex == -1) return 0\n        if (substringIndex < count)\
    \ return 0\n        val beginIndex = substringIndex + substring.length\n     \
    \   val endIndex = count\n        val foundOnce = 0L\n        val found = Array.empty[Int]\n\
    \        val currentCount = 0\n        var i = beginIndex\n        while (i <=\
    \ endIndex) {\n            val index = string.indexOf(\"a\", i)\n            if\
    \ (index == -1) currentCount += 1\n            else {\n                foundOnce\
    \ += 1\n                found(index) = 1\n            }\n            i = index\
    \ + 1 // move to next char\n        }\n        // If all chars have been found\
    \ once, we return 0\n        if (foundOnce == string.length) 0\n        // If\
    \ only some chars have been found once, we return 1\n        else if (foundOnce\
    \ < string.length) 1\n        // Otherwise, return number of chars found > 1\n\
    \        else foundOnce.asInstanceOf[Int]", "        val strings = mutable.MutableList[Int]()\n\
    \        val count = mutable.MutableList[Int]()\n        val counts = mutable.MutableList[Int]()\n\
    \        val l = string.length\n        for (i <- 0 until l) {\n            if\
    \ (string.charAt(i) == substring.charAt(0)) {\n                val index = string.indexOf(strings(0),\
    \ i + 1)\n                if (index != -1) {\n                    count(i) = count(i)\
    \ + 1\n                    counts(i) = count(i) - 1\n                }\n     \
    \           strings(0) = i + 1\n                counts(0) = strings(0) - i + 1\n\
    \            } else {\n                val index = string.indexOf(strings(0),\
    \ i + 1)\n                if (index != -1) {\n                    count(i) = count(i)\
    \ - 1\n                }\n                strings(i) = i + 1\n               \
    \ counts(i) = strings(i) - i + 1\n            }\n            if (count(i) == 0)\
    \ {\n                strings(i) = -1\n                counts(i) = -1\n       \
    \     }\n        }\n        for (i <- 0 until l) if (strings(i) == -1) {\n   \
    \         count(i) = -1\n            counts(i) = -1\n        }\n        val totalCount\
    \ = 0\n        for (i <- 0 until l) if (count(i) > 0) totalCount += 1\n      \
    \  return totalCount", "        // We use regex to extract our substring\n   \
    \     val pattern = substring + \"\"\"(.*\"\"\" + substring + \"\"\".*)\"\"\"\
    .r\n        val matches: Seq[String] = pattern.findAllIn(string).get\n       \
    \ // We use a map to keep count of all the matches\n        val map: Map[String,\
    \ Long] = matches.map(_.toLowerCase).map(m => m -> 1l).groupBy(m => m).map(_._2)\n\
    \        // We use the reduce function to sum the counts\n        map.reduce(_\
    \ + _)", "        // Write your code here\n        var count = 0\n        string.count(s\
    \ => substring.count(ss => s == ss))", "        var count = 0\n        // loop\
    \ through substring and add ones for each character in the string\n        for(x\
    \ <- substring) {\n            count = count + 1\n            // if the character\
    \ doesn't exist in the string, add one\n            if (string.indexOf(x.toString())\
    \ == -1) {\n                count = count + 1\n            }\n        }\n    \
    \    count = count + 1\n        // loop through string to find how many times\
    \ it occurs\n        for (x <- string) {\n            // if the character doesn't\
    \ exist in the substring, add one\n            if (string.indexOf(x.toString())\
    \ == -1) {\n                count = count + 1\n            }\n        }\n    \
    \    count", "        // Create an array of all substrings and number of times\
    \ they appear\n        val substringArray = string.split(substring, -1).map(_.toLong).toArray\n\
    \        // Find the length of longest substring\n        val maxSubstring = substringArray.max\n\
    \        // Find the difference between max and min length. Will be used as divisor\
    \ to scale number of substring occurrences.\n        val subStringLength = string.count(substring)\
    \ - string.count(substring.replace(substring, \"\"))\n        // Find number of\
    \ occurrences of every substring\n        val occurrences = substringArray.map(elem\
    \ => string.count(elem))\n        // Find the quotient of max length and substring\
    \ length\n        val quotient = maxSubstring.count(_ > 0) / subStringLength\n\
    \        // Divide quotient by max length so it doesn't get truncated\n      \
    \  val scale: Int = quotient.max(quotient.min).max\n        // Multiply number\
    \ of occurrences by the scale\n        occurrences.toList.foldLeft(0)((result,\
    \ elem) => result * elem * scale).toLong", "        var count = 0\n        var\
    \ index = 0\n        var startIndex = 0\n        var endIndex = 0\n        for\
    \ (i <- 0 until string.length) {\n            endIndex = string.indexOf(substring,\
    \ index)\n            if (endIndex != -1) {\n                count += endIndex\
    \ - startIndex\n                startIndex = endIndex + 1\n                index\
    \ = startIndex\n            }\n        }\n        return count", "        var\
    \ i = 0\n        for (c <- string) {\n            if (c == substring(i)) {\n \
    \               i += 1\n            }\n            else {\n                break\n\
    \            }\n        }\n        string.size - (i + 1)", "        // Use Java\
    \ Collections to search through all the substrings.\n        // Create a list\
    \ of strings from the given string and substring.\n        val list = string.split(substring).toList\n\
    \        // Use HashMap to count the substring and store it in a Map.\n      \
    \  // The key is the substring, the value is the number of times the substring\
    \ appears in the string.\n        // When a substring is already in the Map then\
    \ the value will be increased by one.\n        val counts = list.foldLeft(HashMap[String,\
    \ Long]())( (acc, item) => acc + (item.trim -> 1) )\n        // Return how many\
    \ times the substring can be found in the string.\n        counts.keySet.count(_\
    \ == substring)", "        val pattern = scala.util.matching.Regexp(substring)\n\
    \        var count = 0\n        var currentIndex = 0\n        while(currentIndex\
    \ < string.length) {\n            if(pattern.findFirstIn(string.substring(currentIndex))\
    \ != null) {\n                count += 1\n            }\n            currentIndex\
    \ += 1\n        }\n        return count", '        string.count(_ == substring)
    + string.count(substring(_)) // counts overlaping cases as well', "        //\
    \ Split the string at every possible index, except the last one, which will contain\
    \ the substring.\n        // As the strings are immutable lists, we can use the\
    \ mutable.Buffer collection, which doesn't allocate additional memory until needed.\n\
    \        // >>> val a = mutable.Buffer[String]()\n        // >>> a += \"\"\n \
    \       // >>> a += \"\"\n        // >>> a += \"\"\n        // >>> val b = mutable.Buffer[String]()\n\
    \        // >>> b += \"\"\n        // >>> b += \"\"\n        // >>> b += \"\"\n\
    \        // >>> b.drop(1).contains(substring)\n        // True\n        // >>>\
    \ val c = mutable.Buffer[String]()\n        // >>> c += \"\"\n        // >>> c\
    \ += \"\"\n        // >>> c += \"\"\n        // >>> c.drop(1).contains(substring)\n\
    \        // True\n        // >>> val d = mutable.Buffer[String]()\n        //\
    \ >>> d += \"\"\n        // >>> d += \"\"\n        // >>> d += \"\"\n        //\
    \ >>> d.drop(1).contains(substring)\n        // True\n        val strings = string.splitAt((string.lastIndexOf(substring)\
    \ + 1).toInt)\n        // Count the number of times the substring appears in each\
    \ string\n        // >>> val c = mutable.Buffer[Long]()\n        // >>> strings.length.foreach\
    \ { length => c.updated(length, strings.length.times(strings.length diff length))}\n\
    \        // >>> c.filter(_ > 1).length\n        // (1l)\n        strings.map(strings.length).reduce((acc,\
    \ _) => acc + _).filter(_ > 1).length", "        val found = string.count(s =>\
    \ s substring == substring(0,s.length))\n        val notFound = string.count(s\
    \ => s substring == substring(0,s.length))\n        (found + notFound).toLong",
  "        val count = mutable.HashMap.empty[String, Long]\n        for (i <- 0 until\
    \ string.length) {\n            if (string.charAt(i) == substring.charAt(0)) {\n\
    \                val key = substring.substring(1)\n                val value =\
    \ count.get(key)\n                if (value != null) {\n                    count.update(key,\
    \ value + 1)\n                } else {\n                    count.update(key,\
    \ 1L)\n                }\n            } else {\n                val key = substring.substring(0,\
    \ substring.length)\n                val value = count.get(key)\n            \
    \    if (value != null) {\n                    count.update(key, value + 1)\n\
    \                } else {\n                    count.update(key, 1L)\n       \
    \         }\n            }\n        }\n        count.values.sum", "        var\
    \ count = 0\n        for(a <- 0 to string.length-1){\n            for(b <- 0 to\
    \ string.length-1){\n                if(string.contains(substring, a, a+substring.length,\
    \ b+substring.length))\n                    count += 1\n            }\n      \
    \  }\n        count", "        val result = new mutable.ListBuffer[Int]()\n  \
    \      var pos = 0\n        var i = 0\n        while (pos < string.length) {\n\
    \            while (i < substring.length && pos < string.length && string.charAt(pos)\
    \ == substring.charAt(i))\n                i += 1\n            result += i\n \
    \           pos += 1\n        }\n        if (result.length > 0) result.length.toLong\n\
    \        else\n            if (substring.length == 1) 0\n            else -1",
  "        val startIndex = string.indexOf(substring)\n        val endIndex = startIndex\
    \ + substring.length\n        if (startIndex == -1L) 0L\n        else if (endIndex\
    \ > string.length-1L) 0L\n        else 1L * string.count(_ => string.indexOf(substring,\
    \ _) < endIndex)", "        // Get a sorted list of the substrings, so that we\
    \ can binary search it.\n        // The substrings themselves are already sorted,\
    \ so this will do for us.\n        // >>> howManyTimes((\"aaaaa\"), (\"a\"))\n\
    \        // (3l)\n        // >>> howManyTimes((\"aaa\"), (\"b\"))\n        //\
    \ (1l)\n        val subStrings = string.splitToList(substring).toList\n      \
    \  // Find the position of the first substring in the string.\n        // >>>\
    \ howManyTimes((\"aaaaa\"), (\"b\"))\n        // (1l)\n        // >>> howManyTimes((\"\
    aaaaa\"), (\"c\"))\n        // (1l)\n        val startIndex = string.indexOf(substring)\n\
    \        // Search for substring in substrings starting from startIndex, and count\
    \ how many we find.\n        // >>> howManyTimes((\"aaaaa\"), (\"b\"))\n     \
    \   // (1l)\n        val subStringsCount = subStrings.length\n        var i =\
    \ 0\n        while (i < subStringsCount) {\n            val currentSubString =\
    \ subStrings(i)\n            if (string.indexOf(currentSubString, startIndex)\
    \ == startIndex) {\n                i += 1\n            } else {\n           \
    \     return i + 1\n            }\n        }\n        return subStringsCount",
  "        val count = mutable.HashMap[String, (Long, Long)]()\n        val index\
    \ = 0\n        while (index < string.length) {\n            val currentChar =\
    \ string.charAt(index)\n            val currentCharCount = count.get(currentChar)\n\
    \            if (currentCharCount == null) {\n                count.put(currentChar,\
    \ (0, 0))\n            } else {\n                count.put(currentChar, (currentCharCount(0),\
    \ currentCharCount(1) + 1))\n            }\n            index += substring.length\n\
    \        }\n        count.values.foldLeft(0L) { (acc, tuple) => acc + tuple._1\
    \ }", "        var count = 0\n        var subStringIter = string.iterator\n  \
    \      subStringIter.foreach { currentSubString =>\n            if(currentSubString\
    \ == substring){\n                count += 1\n            }else{\n           \
    \     var overlap = subStringIter.takeWhile(currentSubString => currentSubString\
    \ != substring).takeWhile(currentSubString => currentSubString != currentSubString).size\n\
    \                if(overlap == 0){\n                    count += 1\n         \
    \       }else{\n                    count = overlap\n                }\n     \
    \       }\n        }\n        return count", "        val charIndices = string.indices.filter(idx\
    \ => string.substring(idx, idx + substring.length) == substring).map (idx => idx\
    \ - substring.size)\n        // Case where substring is a whole character, then\
    \ no match\n        if (charIndices.contains(0)) {\n            return 0L\n  \
    \      }\n        val substringLength = substring.length\n        // Iterate over\
    \ each character in original string and see if that character is in substring\n\
    \        // If we find a match, we return the number of characters that match.\n\
    \        var count = 1\n        for (i <- 0 until string.length) {\n         \
    \   val charCount = charIndices.takeWhile(idx => string.substring(idx, idx + substringLength)\
    \ == substring.substring(i, i + substringLength)).length\n            if (charCount\
    \ > count) {\n                count = charCount\n            }\n        }\n  \
    \      count", "        var count = 0L\n        string.count(substring) match\
    \ {\n            case 0 => count\n            case 1 => count\n            case\
    \ _ =>\n                val subStringSize = substring.length\n               \
    \ val subStringStartIndex = string.indexOf(substring)\n                if (subStringStartIndex\
    \ >= 0) {\n                    val subStringEndIndex = subStringStartIndex + substring.length\n\
    \                    var start = subStringStartIndex\n                    val\
    \ end = subStringEndIndex\n                    while (start <= end) {\n      \
    \                  val subStringSubStartIndex = start - 1\n                  \
    \      val subStringSubEndIndex = end + 1\n                        val subStringSubSize\
    \ = subStringSubEndIndex - subStringSubStartIndex\n                        val\
    \ subStringSubStartIndex = string.substring(subStringSubStartIndex, subStringSubEndIndex).indexOf(substring)\n\
    \                        if (subStringSubStartIndex >= 0) {\n                \
    \            count += Math.max(count, 1 + howManyTimes(string.substring(start,\
    \ subStringSubStartIndex + subStringSubSize), substring))\n                  \
    \          start = subStringSubStartIndex\n                            end = subStringSubEndIndex\
    \ + 1\n                        } else {\n                            count = Math.max(count,\
    \ 1 + howManyTimes(string.substring(start, end), substring))\n               \
    \             start = end\n                            end = end + 1\n       \
    \                 }\n                    }\n                    count\n      \
    \          } else {\n                    count\n                }\n        }",
  "        var count = 0\n        var index = 0\n        while(index != -1) {\n  \
    \          index = string.indexOf(substring, index)\n            count += 1\n\
    \            if(index != -1) index += substring.length\n        }\n        count",
  "        var count = 0\n        var startIndex = -1\n        var endIndex = -1\n\
    \        for (i <- 0 to string.length-1){\n            if(!string.equals(substring)){\n\
    \                for(j <- 0 to substring.length-1){\n                    if(!string.equals(substring.substring(0,j+i))){\n\
    \                        startIndex = i\n                        endIndex = j\n\
    \                        break\n                    }\n                }\n   \
    \             if(startIndex != -1 && endIndex != -1){\n                    count\
    \ += endIndex - startIndex\n                }\n                startIndex = -1\n\
    \                endIndex = -1\n            }\n        }\n        count", "  \
    \      var count = 0L\n        for(i <- string.indices(substring) + 1 until string.length)\
    \ {\n            for(j <- string.indices(substring) + 1 until string.length) {\n\
    \                if(i != j) {\n                    if(string.charAt(i) == string.charAt(j)\
    \ && i != j && string.charAt(i) != substring)\n                        count+=1L\n\
    \                }\n            }\n        }\n        count", "        var count\
    \ = 1 \n        for (i <- 0 until string.length until substring.length) {\n  \
    \          if (string.charAt(i) == substring.charAt(0)) {\n                var\
    \ j = i\n                for (j <- i until substring.length until string.length)\
    \ {\n                    if (string.charAt(j) == substring.charAt(1)) {\n    \
    \                    count += 1 \n                        break\n            \
    \        }\n                }\n                break\n            }\n        }\n\
    \        count", "        var i = 0\n        var count = 0\n        string.takeWhile(c\
    \ => c != substring(0)) foreach { s =>\n            string.dropWhile(c => c !=\
    \ substring(0)) foreach { s =>\n                if (s == substring(i)) {\n   \
    \                 count = count + 1\n                }\n                i = i\
    \ + 1\n            }\n        }\n        math.max(0, count - i)", "        var\
    \ count = 0L\n        var inStringIndex = 0\n        var subStringIndex = 0\n\
    \        while (subStringIndex < substring.length) {\n            if (string.indexOf(substring(subStringIndex,\
    \ substring.length)) < 0) {\n                inStringIndex += 1\n            \
    \    subStringIndex += 1\n            } else {\n                count += 1L\n\
    \                inStringIndex += 1\n                subStringIndex += 1\n   \
    \         }\n        }\n        count", "        val substringList = substring.split(\"\
    (?=[a-z])\")\n        val stringList = string.split(\"(?=[a-z])\")\n        var\
    \ i = 0\n        var count = 0\n        var startIndex = 0\n        for (x <-\
    \ substringList if stringList.length >= x) {\n            startIndex = stringList.length\n\
    \            while (i < stringList.length && stringList(i) == x) {\n         \
    \       i += 1\n                count += 1\n            }\n            i += substringList.length\
    \ - x.length\n        }\n        count", "        val index = string.toLowerCase.indexOf(substring.toLowerCase)\n\
    \        if (index >= 0) math.pow(2,(index+1)) else {\n            val index =\
    \ string.toLowerCase.indexOf(substring.toLowerCase.toLowerCase)\n            if\
    \ (index >= 0) math.pow(2,(index+1)) else {\n                val index = string.toLowerCase.indexOf(substring.toLowerCase.toUpperCase)\n\
    \                if (index >= 0) math.pow(2,(index+1)) else {\n              \
    \      val index = string.toLowerCase.indexOf(substring.toLowerCase.toUpperCase)\n\
    \                    if (index >= 0) math.pow(2,(index+1)) else {\n          \
    \              val index = string.toLowerCase.indexOf(substring.toUpperCase)\n\
    \                        if (index >= 0) math.pow(2,(index+1)) else {\n      \
    \                      val index = string.toLowerCase.indexOf(substring.toUpperCase.toUpperCase)\n\
    \                            if (index >= 0) math.pow(2,(index+1)) else {\n  \
    \                              0\n                            }\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }", "        val stringList = string.split(substring)\n        val list =\
    \ new Array[Long](stringList.length + 1)\n        list(0) = 0\n        list.length\
    \ = 1\n\n        var i = 1\n        while(i < list.length){\n            if(stringList(i).equals(substring))\
    \ {\n                list(i) = 1\n            }else {\n                list(i)\
    \ = 0\n            }\n            i += 1\n        }\n        list(0)", "     \
    \   var count = 0L\n        for(i <- string.indicesOf(string))\n            for(j\
    \ <- string.indicesOf(string,i+1))\n                if(string.substring(i,j) ==\
    \ substring)\n                    count += 1 \n        return count", "      \
    \  val start = string.indexOf(substring)\n        val end = start + substring.length\n\
    \        var count = 0\n        var count = 0\n        var lastFound = \"\"\n\
    \        var lastFound = \"\"\n        for(i <- start until end){\n          \
    \  val testString = string.substring(0,i) + string.substring(i+1,end)\n      \
    \      if(testString == string){\n                count = count + 1\n        \
    \        lastFound = string\n            }\n            if(testString.equals(string)){\n\
    \                count = count + 1\n                lastFound = string\n     \
    \       }\n        }\n        count + howManyTimes(string, lastFound)", "    \
    \    val chars = string.toCharArray.takeWhile(_ != substring.head)\n        val\
    \ indices = chars.indices(substring)\n        indices.map(indices.length).sum",
  "        if (string == substring) 0 // No overlap\n        else {\n            var\
    \ count = 0\n            var i = 0\n            var j = 0\n            var lastFoundIndex\
    \ = -1\n            var lastFoundChar = -1\n            var lastSubstringIndex\
    \ = -1\n            while (i < string.length && j < substring.length) {\n    \
    \            if (string.charAt(i) == substring.charAt(j)) {\n                \
    \    count += 1\n                    lastFoundIndex = i\n                    lastFoundChar\
    \ = string.charAt(i)\n                    lastSubstringIndex = j\n           \
    \     } else {\n                    i += 1\n                    j += 1\n     \
    \           }\n            }\n            if (lastFoundChar == -1) return count\n\
    \            while (i < string.length) {\n                count += 1\n       \
    \         if (string.charAt(i) == substring.charAt(lastSubstringIndex)) {\n  \
    \                  lastSubstringIndex += 1\n                } else {\n       \
    \             i += 1\n                }\n            }\n            return count\n\
    \        }", "        var count = 0l\n        var start = 0\n        var end =\
    \ string.length\n        while ( start < end ) {\n            // start from current\
    \ position\n            var index = string.indexOf( substring, start )\n     \
    \       if ( index >= start ) {\n                // find next occurence\n    \
    \            var endIndex = string.indexOf( substring, index + substring.length\
    \ )\n                if ( endIndex > index ) {\n                    // if found\
    \ then increment count\n                    count += 1\n                    start\
    \ = endIndex\n                }\n                else {\n                    //\
    \ if found but no more occurence then remove found char and continue\n       \
    \             start = index\n                }\n            }\n            else\
    \ {\n                // if reached end then remove all occurences and start searching\
    \ from start\n                start = index\n                end = string.length\n\
    \            }\n        }\n        count", "        val pattern = scala.util.matching.Regex.quote(substring)\n\
    \        var count = 0\n        var start = 0\n        var end = 0\n\n       \
    \ while(end < string.length) {\n            start = end + 1\n            end =\
    \ string.indexOf(substring, start)\n            if(end >= 0) {\n             \
    \   count += 1\n            }\n        }\n        count", "        val count =\
    \ mutable.HashMap[String, Long]()\n        var i = 0\n        while (i < string.length\
    \ && i < substring.length) {\n            val substringStart = i - substring.length\n\
    \            val substringEnd = i + substring.length\n            if (i >= string.length)\
    \ substringEnd -= 1\n            if (string(i) == substring(substringStart, substringEnd))\
    \ count(substring(substringStart, substringEnd)) += 1\n            i += 1\n  \
    \      }\n        count.values.sum", "        val indexStart = string.length()\
    \ - substring.length\n        val indexEnd = indexStart + substring.length\n \
    \       val count = 0L\n        // TODO: Write a smarter way to handle case where\
    \ substring is longer than original string\n        // TODO: Refactor code to\
    \ avoid duplication\n        if(indexStart < 0 || indexEnd < 0) {\n          \
    \  return count\n        }\n        for(i <- indexStart to indexEnd) {\n     \
    \       if(string.charAt(i) == substring.charAt(0)) {\n                count +=\
    \ howManyTimes(string.subSequence(1, i), substring)\n            }\n         \
    \   else if(string.charAt(i) == substring.charAt(substring.length)) {\n      \
    \          count += howManyTimes(string.subSequence(0, i), substring.substring(1,\
    \ substring.length))\n            }\n        }\n        count", "        val index\
    \ = 0\n        val substringLen = substring.length\n        var count = 1\n  \
    \      var currentString = \"\"\n        var currentSubstring = \"\"\n\n     \
    \   while(index < string.length && count <= substringLen) {\n            currentString\
    \ = string.substring(index, index+count)\n            currentSubstring = substring.substring(index,\
    \ index+count)\n            if(currentString == currentSubstring) {\n        \
    \        count += 1\n            } else {\n                count = 0\n       \
    \     }\n            index += count\n        }\n\n        count", "        //\
    \ Create a Map to store how many times the substring is found in each case\n \
    \       val countMap = mutable.Map[String, Int]()\n\n        // Loop over the\
    \ characters of the original string\n        string.map((c: Char) => {\n     \
    \       // If the character is a letter, store the number of times the substring\
    \ occurred in each case\n            if(c.isLetter) {\n                countMap\
    \ += (c -> countMap.getOrElse(c, 0)+1)\n            }\n        }).toArray\n\n\
    \        // Return the number of times each case occurs\n        countMap.getOrElse(substring(0),\
    \ 0)", "        var count = 1\n        var startIndex = -1\n        var index\
    \ = -1\n        while(index != -1) {\n            index = string.indexOf(substring,startIndex)\n\
    \            if(index != -1) count++\n            startIndex = index + 1\n   \
    \     }\n        count", "        val charArray = string.toCharArray\n       \
    \ var found = 0L\n        var i = 0\n        while (i < charArray.length) {\n\
    \            val start = charArray(i)\n            var found = false\n       \
    \     while (i < charArray.length) {\n                val end = charArray(i)\n\
    \                if ((start == substring(0)) && (end == substring(1))) {\n   \
    \                 found = true\n                    break\n                }\n\
    \                i += 1\n            }\n            if (found) {\n           \
    \     found += 1\n            } else {\n                found += 1\n         \
    \       val newString = string + substring(start)\n                found += howManyTimes(newString,\
    \ substring)\n            }\n        }\n        found", "        var count = 0\n\
    \        string.split(substring).map(_.length).foreach(l => {\n            if\
    \ ((substring.indexOf(l) > -1) && (count < string.length())) {\n             \
    \   count = string.length()\n            }\n        })\n        return count",
  "        var count = 0\n        string.split(\"\\\\W\").foreach {\n            if\
    \ ((string.indexOf(substring) > -1 || substring.indexOf(string > -1) && substring.indexOf(string\
    \ < -1)) && string.indexOf(substring) < 0) {\n                count += 1\n   \
    \         }\n        }\n        count", '        string.splitIterator.find(_.toUpperCase
    == substring.toUpperCase).toList.length', "        if (string == null || substring.length\
    \ == 0 || substring.length == 0) 0\n        else {\n            var count : Long\
    \ = 0\n            val pos = string.indexOf(substring)\n            while (pos\
    \ != -1) {\n                count += 1\n                pos = string.indexOf(substring,\
    \ pos + 1)\n            }\n            count\n        }", "        val list =\
    \ string.split(\" \")\n        var count = 0\n        var j = 0\n        for (i\
    \ <- 0 until list.length)\n        {\n            if (i == list.length - 1 ||\
    \ list(i) == substring) count = 1\n            else if list(i + 1) != list(i)\
    \ \n            { \n                for (k <- 0 until j)\n                {\n\
    \                    if (string.charAt(k) == substring.charAt(0)) count += 1 \n\
    \                    else if string.charAt(k + 1) != substring.charAt(0) && string.charAt(k\
    \ + 1) != substring.charAt(1) \n                    { \n                     \
    \   count += 1\n                        j = k + 2\n                        break\n\
    \                    }\n                }\n            }\n            j += 1\n\
    \        }\n        return count", "        var count = 0l\n        for (i <-\
    \ string.indices) {\n            if (string.charAt(i) == substring.charAt(0))\
    \ {\n                if (string.charAt(i+1) == substring.charAt(1)) {\n      \
    \              count += 1\n                }\n                i += 1\n       \
    \     } else {\n                break\n            }\n        }\n        count",
  "        string.length.times {\n            string.indexWhere(s => s.contains(substring))\n\
    \        }", "        val stringList = string.split(\" \")\n        val substringList\
    \ = substring.split(\" \")\n        var count = 0\n        val stringIndex = new\
    \ HashMap[String, Long]()\n        val substringIndex = new HashMap[String, Long]()\n\
    \        for (i <- 0 to stringList.length-1) {\n            stringIndex.put(stringList(i),\
    \ i)\n        }\n        for (i <- 0 to substringList.length-1) {\n          \
    \  substringIndex.put(substringList(i), i)\n        }\n        for (key <- stringIndex.keys)\
    \ {\n            val index = stringIndex.get(key)\n            if (substringIndex.get(key)\
    \ != null) {\n                count = count + 1\n            }\n        }\n  \
    \      count", '        string.count(s => substring.toSet.contains(s))', "   \
    \     var count = 0\n        var index = 0\n        var charArray = string.toCharArray\n\
    \        var substringArray = substring.toCharArray\n\n        while (index <=\
    \ charArray.length - substringArray.length) {\n            if (charArray.takeWhile(_\
    \ == substringArray(0)).mkString == substringArray(0) &&\n                charArray.dropWhile(_\
    \ == substringArray(substringArray.length-1)).mkString == substringArray(substringArray.length-1))\
    \ {\n                count = count + 1\n                index = index + 1\n  \
    \          } else {\n                index = 0\n            }\n        }\n   \
    \     count", "        string match {\n            case s if substring == \"\"\
    \ => (0 until s.length).count(i => s.charAt(i) == s.charAt(string.length))\n \
    \           case s if substring == s => s.length\n            case _ => 0 // overlaping\
    \ case\n        }", "        // return 0l if string is not long enough\n     \
    \   if (string.length < substring.length)\n            return 0l\n\n        //\
    \ map each character of the string to a unique integer\n        var characterToIndex\
    \ = Map(\"a\" -> 0, \"b\" -> 1, \"c\" -> 2, \"d\" -> 3, \"e\" -> 4, \"f\" -> 5,\
    \ \"g\" -> 6, \"h\" -> 7, \"i\" -> 8, \"j\" -> 9, \"k\" -> 10, \"l\" -> 11, \"\
    m\" -> 12, \"n\" -> 13, \"o\" -> 14, \"p\" -> 15, \"q\" -> 16, \"r\" -> 17, \"\
    s\" -> 18, \"t\" -> 19, \"u\" -> 20, \"v\" -> 21, \"w\" -> 22, \"x\" -> 23, \"\
    y\" -> 24, \"z\" -> 25).toMap\n\n        // map each character of the substring\
    \ to a unique integer\n        var characterToIndexSub = Map(\"a\" -> 0, \"b\"\
    \ -> 1, \"c\" -> 2, \"d\" -> 3, \"e\" -> 4, \"f\" -> 5, \"g\" -> 6, \"h\" -> 7,\
    \ \"i\" -> 8, \"j\" -> 9, \"k\" -> 10, \"l\" -> 11, \"m\" -> 12, \"n\" -> 13,\
    \ \"o\" -> 14, \"p\" -> 15, \"q\" -> 16, \"r\" -> 17, \"s\" -> 18, \"t\" -> 19,\
    \ \"u\" -> 20, \"v\" -> 21, \"w\" -> 22, \"x\" -> 23, \"y\" -> 24, \"z\" -> 25).toMap\n\
    \n        // map the characters to integers and subtract to find their difference\n\
    \        var characterToIndexSubDiff = characterToIndexSub.map { case (k, v) =>\
    \ (v - characterToIndex.get(k)) }\n\n        // find how many characters are different\n\
    \        var characterToIndexSubDiffSum = characterToIndexSubDiff.sum\n\n    \
    \    // find the index of the first character\n        var i = 0\n\n        //\
    \ loop through all the characters of the original string\n        while (i < string.length)\
    \ {\n\n            // if the characters are different and we haven't found the\
    \ substring yet\n            if (characterToIndexSubDiffSum > 0 && characterToIndexSubDiffSum\
    \ - characterToIndexSub.get(string(i)) < 0) {\n                // increment the\
    \ index and keep going\n                i += 1\n                characterToIndexSubDiffSum\
    \ += characterToIndexSubDiff.getOrElse(string(i), 0l)\n            }\n       \
    \     else {\n                // if we found the substring, increment the index\
    \ and break\n                if (characterToIndexSub.get(string(i)).isDefined)\
    \ {\n                    i += 1\n                    characterToIndexSubSumS",
  '        return string.split(substring).length', "        var count = 0L\n     \
    \   var index = 0\n        while (index != string.length-1) {\n            if\
    \ (string.charAt(index) == substring.charAt(0)) {\n                if (string.charAt(index+1)\
    \ == substring.charAt(1)) {\n                    if (string.charAt(index+2) ==\
    \ substring.charAt(2)) {\n                        count += 1L\n              \
    \      }\n                }\n            }\n            index += 1\n        }\n\
    \        return count", "        var count = 0\n        val len = string.length\n\
    \        var i = 0\n        val len = substring.length\n        var j = 0\n  \
    \      while (i < len && j < len) {\n            if (string.charAt(i) == substring.charAt(j))\
    \ {\n                count += 1\n                i += 1\n                j +=\
    \ 1\n            }\n            else {\n                if (string.charAt(i) >\
    \ substring.charAt(j)) {\n                    count += 1\n                }\n\
    \                i += 1\n            }\n        }\n        return count", "  \
    \    val count = new mutable.HashMap[String, Long]()\n      val sub = substring.toLowerCase\
    \ + substring.toUpperCase + substring\n      for(i <- 0 to string.length - sub.length\
    \ + 1){\n        val search = string.substring(i, i + sub.length).toLowerCase\
    \ + string.substring(i, i + sub.length).toUpperCase + string.substring(i, i +\
    \ sub.length)\n        if(count.contains(search)){\n          count(search, count)\n\
    \        }else{\n          count.put(search, 1)\n        }\n      }\n      count(sub,\
    \ count)", "        var count = 0\n        for(i <- 0 until string.length){\n\
    \            count += string.substring(i , string.length).contains(substring)\n\
    \        }\n        count", "        var count = 0\n        val startIndex = string.indexOf(substring)\n\
    \        while (startIndex != -1) {\n            count += 1\n            startIndex\
    \ = string.indexOf(substring, startIndex + 1)\n        }\n        count", "  \
    \      if (string.isEmpty)\n            return 0\n        if (substring.forall(string.isEmpty))\n\
    \            return 0\n        var counter = 0\n        var count = 0\n      \
    \  var startIndex = 0\n        var subStringLength = substring.length\n      \
    \  var currentIndex = 0\n        var subStringStartIndex = 0\n        while (currentIndex\
    \ < string.length) {\n            var subStringEndIndex = string.indexOf(substring,\
    \ currentIndex)\n            if (subStringEndIndex == -1)\n                subStringEndIndex\
    \ = string.length\n            if (currentIndex < subStringEndIndex) {\n     \
    \           count += 1\n                currentIndex = subStringEndIndex\n   \
    \         } else {\n                counter += count + subStringLength\n     \
    \           count = 0\n                currentIndex = subStringStartIndex\n  \
    \              subStringStartIndex = subStringEndIndex\n            }\n      \
    \  }\n        return counter", "        val originalLength = string.length\n \
    \       val substringLength = substring.length\n\n        // return 0 if the string\
    \ and substring are the same\n        if (string.length == 0 || substring.length\
    \ == 0)\n            return 0\n        // return 1 if there is no substring at\
    \ all\n        if (substringLength == 0)\n            return 1\n        // return\
    \ if the substring appears right in the middle of the string\n        if (string.substring(substringLength,\
    \ string.length).equals(substring))\n            return substringLength\n    \
    \    // if the last character of the original string matches the last character\
    \ of the substring,\n        // there is no overlap with it\n        if (string[originalLength\
    \ - 1] == substring[substringLength - 1])\n            return substringLength\n\
    \        // if the last characters of the original string and the substring don't\
    \ match\n        if (string[originalLength - 1] != substring[substringLength -\
    \ 1])\n            return 0\n        // if the length of the substring is the\
    \ same, there is no overlap with the substring\n        if (substring.length ==\
    \ substringLength)\n            return substringLength\n        // otherwise,\
    \ find the longest substring that ends with the last character of the original\
    \ string\n        // and the shortest substring that starts with the first character\
    \ of the substring\n        val endSubstring = string.substring(originalLength,\
    \ string.length - substringLength)\n        val beginSubstring = string.substring(0,\
    \ substringLength)\n        // if we found a substring that ends with the last\
    \ character of the original string\n        // and a substring that starts with\
    \ the first character of the substring,\n        // then the length of the longest\
    \ substring ends with the length of the shorter substring\n        if (endSubstring.equals(beginSubstring))\n\
    \            return substring.length\n        // otherwise we return 0\n     \
    \   return 0", "        val counter = new mutable.HashMap[String, Int]()\n   \
    \     for (i <- 0 until string.length) {\n            if (string.contains(substring))\n\
    \                counter += substring -> (counter(substring) + 1l)\n         \
    \   else counter += string.substring(i, string.length) -> (counter(string.substring(i,\
    \ string.length)) + 1l)\n        }\n        counter.size", "        val list =\
    \ string.split(substring).map(_.length).toList\n        val result = list.reduceLeft((a,\
    \ b) => a + b)\n        result / (substring.length + 1)", "        // Count overlapping\
    \ cases\n        val found = string.count(substring)\n        // Count non-overlapping\
    \ cases\n        val length = string.length\n        if (substring == string.dropRight(length))\
    \ 0 else {\n            val end = string.length\n            val start = end -\
    \ substring.length\n            val sub = string.substring(start, end)\n     \
    \       found + howManyTimes(string.dropRight(start), sub)\n        }", "    \
    \    val start = string.indexOf(substring)\n        if (start != -1) {\n     \
    \       var count = 0\n            for (i <- 1 to string.length) if (string.charAt(i)\
    \ == substring(i)) count += i\n            count\n        } else {\n         \
    \   0\n        }", '        string.count(substring)', "        val result = new\
    \ mutable.HashMap[Int, Long]()\n        for (i <- 0 until string.length) {\n \
    \           if (string.substring(0, i).equals(substring)) {\n                val\
    \ n = result + (i -> (result.getOrElse(i, 0L) + 1))\n                result -=\
    \ n\n            }\n        }\n        result + (substring -> (result.getOrElse(substring,\
    \ 0L)))", "        val sSet = new HashSet[Char](substring)\n        string.chars.filter(c\
    \ => sSet.contains(c)).size", "        var count = 0\n        var i = 0\n    \
    \    while i < string.length {\n            val start = i\n            i += 1\n\
    \            val end = i\n            if (string.contains(substring, start, end))\
    \ {\n                count += 1\n            }\n        }\n        count", " \
    \       var count : Long = 0\n        for( i <- 0 until string.length ) {\n  \
    \          if(string.charAt(i) == substring.charAt(0)) {\n                if(string.charAt(i+1)\
    \ == substring.charAt(1)) {\n                    count = count + 1\n         \
    \       }\n                if(string.charAt(i+1) == substring.charAt(2)) {\n \
    \                   count = count + 1\n                }\n                i =\
    \ i + 1\n            }\n        }\n        count", "        val stringBuilder\
    \ = MutableStackBuilder[String]()\n        val substringBuilder = MutableStackBuilder[String]()\n\
    \        var count = 0\n        for (i <- 0 to string.length - substring.length)\
    \ {\n            stringBuilder.push(string.substring(i, i + substring.length))\n\
    \            substringBuilder.push(substring.substring(i, i + substring.length))\n\
    \            if (stringBuilder.isEmpty && substringBuilder.isEmpty) count += 1\n\
    \        }\n        count", "        var count = 0\n        for (i <- 0 until\
    \ string.length()) {\n            if (string.charAt(i) == substring.charAt(0))\
    \ {\n                for (j <- 0 until substring.length()) {\n               \
    \     if (string.charAt(i + j) == substring.charAt(j)) {\n                   \
    \     count += howManyTimes(string.substring(i, j + 1), substring)\n         \
    \               val newStart = i + j + 1\n                        break\n    \
    \                }\n                }\n            }\n        }\n        count",
  "        var count = 0\n        var lastIndex = string.lastIndexOf(substring)\n\
    \        while (lastIndex >= 0) {\n            if (string.lastIndexOf(substring,\
    \ lastIndex + 1) != lastIndex) {\n                count += lastIndex - string.lastIndexOf(substring)\
    \ + 1 // +1 to remove overlapping cases\n            }\n            lastIndex\
    \ = string.lastIndexOf(substring, lastIndex + 1)\n        }\n        count", " \
    \       var i = 0\n        var count = 0\n        var j = 0\n        while (i\
    \ < string.length) {\n            while (j < substring.length) {\n           \
    \     if (string.charAt(i) == substring.charAt(j)) {\n                    count\
    \ += 1\n                    j++\n                }\n                else {\n \
    \                   j++\n                }\n            }\n            i += 1\n\
    \        }\n        count", "        var counter : Long = 0\n        var index\
    \ = 0\n        while (index < string.length) {\n            val position = string.indexOf(substring,\
    \ index)\n            if (position >= 0) {\n                counter = counter\
    \ + 1\n                index = position + 1\n            }\n            else {\n\
    \                index = index + 1\n            }\n        }\n        return counter",
  "        if (string.isEmpty)\n            0\n        else if (substring.isEmpty)\n\
    \            1\n        else if (string.head == substring.head)\n            howManyTimes(string.tail,\
    \ substring.tail)\n        else\n            howManyTimes(string.tail, substring.tail)\
    \ + howManyTimes(string.tail, substring.head)", "        var currentCount = 0\n\
    \        var subStringIndex = -1\n        var index = -1\n        string.foreach(c\
    \ => {\n            if (c == substring(0)) {\n                subStringIndex =\
    \ index\n                index = -1\n            } else if (c == substring(1))\
    \ {\n                index = subStringIndex\n                currentCount = currentCount\
    \ + 1\n            }\n        })\n        return currentCount", "        val res\
    \ = mutable.ListBuffer[String]()\n        val index = string.indexOf(substring)\n\
    \        var count = 0\n\n        while (index >= 0) {\n            count += string.lastIndexOf(substring,\
    \ index + 1)\n            res += string.substring(index + substring.length)\n\
    \            index = string.lastIndexOf(substring, index + 1)\n        }\n\n \
    \       res.size match {\n            case 0 => 0l\n            case _ => count.toLong\n\
    \        }", "        var count = 0L\n        var i = 0\n        while (i < string.length)\
    \ {\n            if (string.substring(i, i + substring.length).equals(substring))\
    \ {\n                count += 1L\n                i += (substring.length) - 1\n\
    \            }\n            i += 1\n        }\n        count", "        val charSet\
    \ = string.chars.toSet\n        val substringSet = substring.chars.toSet\n   \
    \     val intersection = charSet.intersect(substringSet)\n        intersection.count\
    \ {\n            case c if charSet.contains(c) =>\n                substringSet.count(_\
    \ == c) + 1\n            case _ => 0\n        }", "        val charCount = mutable.Map[Char,\
    \ Long]()\n        for (c <- string) {\n            if (c == substring(0)) {\n\
    \                var count = charCount(c)\n                if (count > 0) count\
    \ += howManyTimes(string.substring(1, string.length - 1), substring)\n       \
    \         charCount(c) = count\n            }\n        }\n        charCount.toSeq.sum",
  "        string match {\n            case x if x == substring => 1\n           \
    \ case _ => {\n                var count = 0\n                for (i <- 0 until\
    \ string.length) {\n                    if (string.charAt(i) == substring.charAt(0))\
    \ {\n                        val j = (i + 1) until string.length\n           \
    \             val k = (i + substring.length) until string.length\n           \
    \             val temp1 = (string.substring(0, i) + string.substring(i, j) + string.substring(k,\
    \ string.length)).mkString(\"\")\n                        val temp2 = (temp1 +\
    \ string.substring(i, string.length)).mkString(\"\")\n                       \
    \ val temp3 = (temp1 + string.substring(k, string.length)).mkString(\"\")\n  \
    \                      if (temp2 == temp3)\n                            count\
    \ = count + 1\n                    }\n                }\n                count\n\
    \            }\n        }", "        val result: Long = new scala.collection.mutable.HashMap[String,Long]();\n\
    \        for (x <- string.toCharArray; y <- substring.toCharArray) if (x == y)\
    \ result(y) = new Long(result(y) + 1L);\n        result.size", "        var count\
    \ = 0\n        for(i <- 0 until string.length){\n            if(!string.substring(i,\
    \ i + substring.length).equals(substring)){\n                count = count + 1\n\
    \            }\n        }\n        count", "        var count = 0L\n        string.sliding(substring.length).foreach(s\
    \ => {\n            if (s contains substring) count += 1\n        })\n       \
    \ count", "        var i = 0\n        string.count(substring) match {\n      \
    \      case 0 =>\n            case _ => {\n                val restString = string.rest\n\
    \                restString.count(substring) match {\n                    case\
    \ 0 =>\n                    case _ => {\n                        restString.takeWhile(_.isUpper).count(substring)\
    \ match {\n                            case 0 =>\n                           \
    \ case _ => {\n                                restString.dropWhile(_.isUpper).count(substring)\
    \ match {\n                                    case 0 =>\n                   \
    \                 case _ => i + 1\n                                }\n       \
    \                     }\n                        }\n                    }\n  \
    \              }\n            }\n        }", "        var count = 0L\n       \
    \ for (char <- string) {\n            if (char == substring(0)) {\n          \
    \      if (string.takeWhile(_ == char).forall(c => c == substring(1)))\n     \
    \               count += 1\n            }\n        }\n        count", "      \
    \  // For each substring, we store how many times the substring occurs in the\
    \ string.\n        // For example, we know that (\"aaa\") (\"a\") => 0\n     \
    \   // Therefore, we store a Long(0) and increment the count when there is a match.\n\
    \        // The first element will be an incremented count of 0.\n        var\
    \ counter = Long(0)\n        for (str <- substring.charIterator) {\n         \
    \   // Iterate through all the characters in the substring.\n            counter\
    \ = counter + count(string, str)\n        }\n        // Return the accumulated\
    \ count.\n        return counter", "        val charArray = string.split(\" \"\
    ).toList\n        val searchArray = substring.split(\" \").toList\n        charArray.foldLeft(0l)\
    \ { (count, char) =>\n            val searchIndex = searchArray.indexOf(char)\
    \ + 1\n            if (searchIndex != -1) {\n                count + 1\n     \
    \       } else {\n                count\n            }\n        }", "        //\
    \ return if either string is empty\n        if (string.isEmpty || substring.isEmpty)\
    \ return 0\n\n        val stringCharArray = string.toCharArray\n        val substringCharArray\
    \ = substring.toCharArray\n        var count = 0\n\n        // go through each\
    \ char from string and compare with substring\n        var i = 0\n        while\
    \ (stringCharArray.length >= i) {\n            if (substringCharArray.length >=\
    \ i) {\n                if (stringCharArray(i) == substringCharArray(i)) {\n \
    \                   count += 1\n                } else {\n                   \
    \ count += substringCharArray.length\n                }\n            } else {\n\
    \                count += stringCharArray.length\n            }\n\n          \
    \  i += 1\n        }\n\n        count", "        var counter = 0\n        val\
    \ regex = new Regex(substring)\n        for(c <- string.toCharArray) {\n     \
    \       counter += regex.findFirstMatchIn(c).result() == None\n        }\n   \
    \     counter", "        val set = mutable.Set[String]()\n        for (i <- 0\
    \ to string.length -substring.length)\n            if string.substring(i,i+substring.length)\
    \ == substring\n            set += string.substring(i,i+substring.length)\n  \
    \      val n = string.length - substring.length\n        val c = set.size\n  \
    \      if (n > 1)\n            c * (n-1)\n        else\n            set.size *\
    \ (n+1)", '        string.count(_ == substring) + string.count(substring + _)',
  "        var count = 0\n        for(i <- 0 until string.length) {\n            if(string.charAt(i)\
    \ == substring.charAt(0))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(1))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(2))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(3))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(4))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(5))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(6))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(7))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(8))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(9))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(10))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(11))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(12))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(13))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(14))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(15))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(16))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(17))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(18))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(19))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(20))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(21))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(22))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(23))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(24))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(25))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(26))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(27))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(28))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(29))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(30))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(31))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(32))\n                count += 1\n            else if(string.charAt(i)\
    \ == substring.charAt(33))\n                count += 1\n            else if(string.",
  "        var count = 0\n        var i = 0\n        while(i < string.length) {\n\
    \            val j = (i + substring.length)\n            val found = string.substring(i,\
    \ j).equals(substring)\n            if(found) {\n                count += 1\n\
    \                i = j\n            }\n            i += 1\n        }\n       \
    \ count", "        var count = 0\n        string.takeWhile(_ == substring).foreach(c\
    \ => {\n            if(!string.dropWhile(_ == c).takeWhile(_ == substring).isEmpty)\
    \ {\n                count += 1\n            }\n        })\n        count", " \
    \       val count = mutable.Set[String]()\n        for (i <- 0 until string.length)\
    \ {\n            count += substring.span(i -> string.length).filter(_._1 == i).toSet\n\
    \        }\n        count.count(_ == substring)", "        val length = string.length\n\
    \        val index = string.toSet[Char].indexOfSubstring(substring)\n        if\
    \ (index == -1)\n            return 0\n        if (length == substring.length)\n\
    \            return 1\n        val newString = string.substring(0, index) + string.substring(index\
    \ + substring.length)\n        howManyTimes(newString, substring)", '        string.zipWithIndex.flatMap(i
    => substring.map(_ == i._2 || i == -1) && i._1 > 0).foldLeft(0)(_ + 1).foldLeft(0)(_
    + 1)', "        if(string.isEmpty || substring.isEmpty)\n            return 0\n\
    \        val result = new mutable.ListBuffer[String]()\n        for(i <- 0 until\
    \ string.size) {\n            val start = i\n            val stop = i + substring.length\n\
    \            for(j <- start until stop) {\n                if(string.substring(i)\
    \ == substring || string.substring(j) == substring) {\n                    result\
    \ += string.substring(i) + string.substring(j)\n                }\n          \
    \  }\n        }\n        val count = new mutable.ListBuffer[String]()\n      \
    \  for(x <- result) count += x\n        count.length", "        // Your code here\n\
    \        var count = 0L\n        var index = 0\n        var index = string.indexOf(substring)\n\
    \        while(index != -1){\n            count += 1\n            index = string.indexOf(substring,\
    \ index + substring.length)\n        }\n        count", "        var count = 0\n\
    \        val indexList = string.toList.indexWhere(_ == substring)\n        if\
    \ (indexList == List.Empty) count = 0\n        else {\n            for (index\
    \ <- indexList) {\n                count = count + 1\n            }\n        }\n\
    \        count", "        string.zip(substring).zipWithIndex.collect {\n     \
    \       case (e1, e2) if (e1._1 == e2._1) => e1._2\n            case _ => 0\n\
    \        }.length", '        return string.count(substring)', "      val chars\
    \ = string.chars\n      val subChars = substring.chars\n\n      val indexMap =\
    \ mutable.Map[Int, Int]()\n      var currentIndex = 0\n\n      while (currentIndex\
    \ < chars.length) {\n        val currentChar = chars(currentIndex)\n        if\
    \ (currentChar == subChars(0)) {\n          indexMap(currentIndex) = indexMap(currentIndex)\
    \ + 1\n        }\n\n        if (currentChar == subChars(1)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(2)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(3)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(4)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(5)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(6)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(7)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(8)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(9)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(10)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(11)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(12)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(13)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar == subChars(14)) {\n          indexMap(currentIndex)\
    \ = indexMap(currentIndex) + 1\n          currentIndex = currentIndex + 1\n  \
    \      }\n\n        if (currentChar", '        string.foldLeft(0L) { (sum, element)
    => sum += substring.count(_ == element)  }', "        val start = string.length\n\
    \        val end = substring.length\n        val counter = mutable.HashMap.empty[String,\
    \ Long]\n        if (start < 0 || end < 0) {\n            return -1\n        }\n\
    \        val startIndex = string.lastIndexOf(substring)\n        if (startIndex\
    \ < 0 || startIndex >= end) {\n            return 0\n        }\n        val endIndex\
    \ = string.indexOf(substring, startIndex + 1)\n        if (endIndex < 0) {\n \
    \           return -1\n        }\n        counter.updated(substring, (endIndex\
    \ - startIndex))\n        val keySet = counter.keys\n        keySet.filter(_.equals(substring)).length",
  "        val substringSet = substring.toSet\n        var result = 0\n        for(i\
    \ <- 0 until string.length)\n            if(string.substring(i).contains(substringSet))\n\
    \                result += 1\n        result", "        var counter = Long.MinValue\n\
    \        for(i <- 0 until string.length) {\n            val index = string.indexOf(substring,\
    \ i)\n            if((index > -1) && (index < string.length) && (i != index))\
    \ {\n                counter += 1\n            }\n        }\n        counter",
  "        val startIndex = string.toList.find(x => x.equals(substring)).getOrElse(0)\n\
    \        val endIndex = startIndex + substring.length\n\n        var count = 0;\n\
    \        for (i <- startIndex to endIndex) {\n            if (string.charAt(i)\
    \ == substring.charAt(0)) {\n                count += 1\n            }\n     \
    \       else {\n                break\n            }\n        }\n        count",
  "      string.count{i => string.contains(substring, i) && substring.isEmpty} +\n\
    \      string.count(i => string.contains(substring, i) && !substring.isEmpty)",
  "        val substring_length = substring.length\n        if (string.length == 0\
    \ || substring.length == 0) 0\n        else if(string.startsWith(substring)) {\n\
    \            howManyTimes(string.substring(substring_length), substring)\n   \
    \     }\n        else if(string.endsWith(substring)) {\n            howManyTimes(string.substring(0,\
    \ string.length-substring_length), substring)\n        }\n        else howManyTimes(string.substring(substring_length),\
    \ substring) + 1", "        val map = mutableMap.empty[String, Long]\n       \
    \ for (i <- 0 until string.length) {\n            if (string.charAt(i) == substring.charAt(0))\
    \ {\n                for (j <- 0 until substring.length) {\n                 \
    \   if (string.charAt(i+j) == substring.charAt(j)) {\n                       \
    \ map += ((string.charAt(i), string.charAt(i+j)) -> (map.getOrElse(string.charAt(i),\
    \ 0l) + 1l))\n                    }\n                }\n            }\n      \
    \  }\n        map.values.sum", "        val matches = string.count(substring)\n\
    \        matches + howManyTimesHelper(string, substring, matches)", "        val\
    \ len = string.length\n        val start = substring.length\n        val end =\
    \ string.length - substring.length\n        val stringList = new ArrayBuffer[String]()\n\
    \        var count = 0\n        while (start < end) {\n            stringList.append(substring(start,\
    \ start + 1))\n            count += 1\n            start += 1\n        }\n   \
    \     stringList.filter(string.contains).map(s => (s.toInt, 1)).groupBy(_._1).map(t\
    \ => t._2).map(t => (t.toString -> t.size)).foldLeft(0)(_ + _)", "        if(string.length\
    \ < substring.length) 0\n        else if(string.substring(0, substring.length)\
    \ == substring) 1\n        else string.count(substring) match {\n            case\
    \ 1 => 1\n            case 0 => 0\n            case _ => howManyTimes(string.substring(0,\
    \ string.length - substring.length), substring) + 1\n        }", "        var\
    \ count = 0L\n        var startIndex = 0\n        var index = string.length\n\n\
    \        while (index >= 0) {\n            if (string.charAt(index) == substring.charAt(0))\
    \ {\n                if (startIndex == index) {\n                    count +=\
    \ 1\n                }\n                startIndex = index + 1\n            }\
    \ else if (string.charAt(index) == substring.charAt(1)) {\n                count\
    \ += 1\n                startIndex = index + 1\n            } else if (string.charAt(index)\
    \ == substring.charAt(2)) {\n                count += 1\n                startIndex\
    \ = index + 1\n            } else if (string.charAt(index) == substring.charAt(3))\
    \ {\n                count += 1\n                startIndex = index + 1\n    \
    \        } else {\n                index -= 1\n            }\n        }\n    \
    \    count", "        val regex = \"\"\"^${substring}+$\"\"\".r\n        val matches\
    \ = string.count(regex)\n        matches > 0 ? matches : 0", "        val strings\
    \ = string.split(substring)\n        val strings2 = strings.map(x => substring+x)\n\
    \        strings2.foldLeft(0l) { (sum, item) =>\n            val count = sum +\
    \ 1\n            if( sum < string.length ) count + howManyTimes(string, item)\
    \ else count\n        }", "        // Convert string to chars, remove all occurrences\
    \ of substring\n        // Convert substring to chars, remove all occurrences\
    \ of original string\n        var count = 1\n        val sub = substring.map {\
    \ c => string.indexOf(c.toDouble) - 1 }\n        val str = string\n        val\
    \ substr = sub.map { c => str.indexOf(c.toDouble) - 1 }\n        for (i <- 1 to\
    \ sub.length) count = count + substr.last.drop(i).length\n        count", "  \
    \      val array = string.split(substring).toList\n        val count = mutable.Buffer.empty[Long]\n\
    \        for (i <- 0 until array.length)\n            if(array(i) != \"\") {\n\
    \                val index = array(i)\n                val index = index + 1\n\
    \                count(index) = count(index) + 1\n            }\n        count.sum",
  "        val result = new mutable.HashSet[String]\n        string.split(substring).map(_.length).foreach(i\
    \ => result += i)\n        string.split(substring).count(i => result.contains(i))",
  '        string.count(substring)', "        val subStringList = substring.split(\"\
    \")\n        var count = 0\n        for(string <- string){\n            count\
    \ = count + 1\n            for(subString <- subStringList){\n                if(string.contains(subString)){\n\
    \                    count = count - 1\n                }\n            }\n   \
    \     }\n        return count", "        def countOverlaps(string : String, substring\
    \ : String) : Long = {\n            val indexStart = string.toSeq.indexOf(substring)\n\
    \            val indexEnd = string.toSeq.indexOf(substring, indexStart + 1)\n\
    \            if (indexStart < 0 || indexEnd < 0) {\n                return 0\n\
    \            }\n            var count = 0\n            var i = 0\n           \
    \ while (i < indexStart && i < indexEnd) {\n                count += 1\n     \
    \           i +=1\n            }\n            if (indexEnd == indexStart + 1)\
    \ {\n                count += 1\n            }\n            return count\n   \
    \     }\n        return countOverlaps(string, substring)", "        if(string\
    \ == substring) 0 // If no more letters, we found the answer\n        else if(string.length\
    \ < substring.length) 0 // If not even a full match, return 0\n        else {\
    \ // If we still have letters, we check each substring. If any of them match,\
    \ return 1.\n            var result = 0\n            for(i <- 0 until substring.length)\
    \ {\n                if(string.indexOf(substring.charAt(i)) > -1) result = result\
    \ + 1\n            }\n            return result\n        }", "      var count\
    \ = 0\n      var i = 0\n      while(i < string.length){\n          while(i < string.length\
    \ && string.charAt(i) == substring.charAt(0)) count += 1\n          i += 1\n \
    \     }\n      return count", "        val countMap: Map[Char,Long] = string.split(substring).toMap\
    \ map {\n            case(el) => el -> (1L)\n        }.toMap\n        val countMap2:\
    \ Map[Char,Long] = string.split(substring.reverse).toMap map {\n            case(el)\
    \ => el -> (1L)\n        }.toMap\n        \n        countMap.keys ++ countMap2.keys\
    \ map {\n            el1 =>\n            el2 =>\n                if (countMap.get(el1)>countMap2.get(el2))\
    \ {\n                    countMap(el1) + (countMap2.get(el2) - countMap.get(el1))\n\
    \                } else {\n                    countMap2.get(el1) + (countMap.get(el2)\
    \ - countMap2.get(el1))\n                }\n        }", "        val startIndexes\
    \ = string.zipWithIndex.map {\n            case (character, index) => (index,\
    \ character)\n        }\n\n        val endIndexes = startIndexes.zip(substring.zipWithIndex.map\
    \ {\n            case (startIndex, substringChar) => (startIndex + 1, substringChar)\n\
    \        }).filter(_._2._1 == 0)\n\n        val chars = startIndexes ++ endIndexes\n\
    \        val substringCount = chars.count(_._2 == substring)\n        val substringLength\
    \  = substring.length\n        val startIndexCount = substringCount + substringLength\n\
    \        val endIndexCount = substringCount\n        val allCharCount = startIndexCount\
    \ + endIndexCount\n        val allChars    = chars.map(x => (x._2, x._1)).distinct\n\
    \n        val result = allChars.count {\n            case (startIndex, character)\
    \ => startIndex <= endIndexCount && endIndexCount + 1 < allCharCount && allChars(endIndexCount\
    \ + 1) == character\n        }\n\n        result / allChars.length", "       \
    \ var count = 0.0\n        string.split(' ').foreach { string =>\n           \
    \ if (string.contains(substring)) {\n                count += 1.0\n          \
    \  }\n        }\n        count", "        val start = string.toCharArray\n   \
    \     var start = start.indexWhere(c => c == substring.head)\n        var end\
    \ = string.toCharArray\n        end = end.toArray.drop(start)\n        val newStart\
    \ = start.toArray.zip(end).collect {\n            case (startIndex, endIndex)\
    \ => startIndex + (endIndex - startIndex)\n        }\n        var count = 0L\n\
    \        for (index <- newStart) {\n            if (string.substring(index) ==\
    \ substring) {\n                count += 1L\n            }\n        }\n      \
    \  count", '        string.count(substring) / substring.length', '        string.count(substring)
    + substring.count(string) - substring.count(substring)', '        string.count(substring)',
  "        val count = mutable.HashMap.empty[Char, Long]\n        for( i <- 0 until\
    \ string.length ) {\n            val char = string.charAt(i)\n            if(\
    \ char == substring.charAt(0) ) {\n                if( string.contains(substring)\
    \ ) {\n                    count.getOrElse(char, 1)\n                } else {\n\
    \                    count.getOrElse(char, 0) + 1\n                }\n       \
    \     }\n        }\n        count.values.sum", "        var count = 0L\n     \
    \   for(i <- 0 to string.length -substring.length){\n            if(string.substring(i,\
    \ i+substring.length) == substring) count += 1\n        }\n        count", " \
    \       var count = 0\n        for(i <- 0 until string.length){\n            val\
    \ substringLength = substring.length\n            val start = i\n            for(j\
    \ <- 0 until substringLength){\n                if(string.charAt(start+j) != substring.charAt(j)){\n\
    \                    break\n                }\n                if(j == substringLength){\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \        count", "        val count = substring.count(string.contains(_))\n  \
    \      val maxCount = string.count(_ == substring)\n        (maxCount.toLong *\
    \ count).toLong", "        val startIndex = string.indexOf(substring)\n      \
    \  if(startIndex < 0) return 0\n        val endIndex = string.lastIndexOf(substring)\n\
    \        if(endIndex < 0) return 0\n        val length = endIndex - startIndex\n\
    \        (length - substring.size) / substring.length", "        var count = 0\n\
    \        for(i <- string.length to substring.length)\n        for(j <- string.length\
    \ to substring.length)\n        if(i == j)\n        if(string.charAt(i) == substring.charAt(j))\n\
    \        if(string.charAt(j) == substring.charAt(i))\n        count += 1\n   \
    \     count", "        var found = 0\n        var i = 0\n        val endPosition\
    \ = string.length\n        val endIndex = string.toSet.find(substring).map(s =>\
    \ s.length)\n        while (i < endPosition) {\n            val found = string.indexOf(string(i),\
    \ i)\n            if (found > -1) {\n                found = endIndex\n      \
    \      }\n            found += 1\n            i = found + 1\n        }\n     \
    \   return found", "        string match {\n            case \"\" => 0\n     \
    \       case _ if string.startsWith(substring) => 1\n            case _ => 0\n\
    \        }", "        var count = 0\n        for(x <- string.toCharArray if x\
    \ == substring(0)) {\n            count = count + 1\n            for(y <- substring.toCharArray\
    \ if x == y) {\n                count = count + 1\n            }\n        }\n\
    \        count", "        val m = string.indexOf(substring)\n        if (m ==\
    \ -1) -1\n        else string.count(substring) - string.count(string.substring(0,m))",
  "        if (string.length < substring.length) 0\n        else if (string.substring(0,substring.length)\
    \ == substring) return string.length\n        else string.substring(0,substring.length).lastIndexOf(substring)\
    \ + howManyTimes(string.substring(string.substring(0,substring.length).lastIndexOf(substring)\
    \ + substring.length), substring)", "        var total = 0\n        var i = 0\n\
    \        while(i < string.length) {\n            val found = string.indexOf(substring,\
    \ i)\n            if (found >= 0) {\n                total += found - i\n    \
    \            i = found + 1\n            } else {\n                i += 1\n   \
    \         }\n        }\n        return total", "        if(string.contains(substring))\
    \ {\n            string.count(_ == substring) + 1\n        } else {\n        \
    \    1\n        }", "        var num = 0\n        val arr = string.split(substring)\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) != \"\") num\
    \ += arr.length - i\n        }\n        return num", "        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        val subStringLength : Int = substring.length\n        var index : Int\
    \ = 0\n        val stringLength = string.length\n\n        while (index<stringLength)\
    \ {\n            val c = string.charAt(index)\n            val s = substring.charAt(subStringLength-1)\n\
    \            if (c==s) result.append(1L)\n            else {\n               \
    \ if (c!=s) index+=1\n                else index+=subStringLength+1\n        \
    \    }\n        }\n        result.length", "        // Convert substring to an\
    \ iterator\n        var stringItr = string.iterator\n        var substringItr\
    \ = substring.iterator\n\n        // Compare each character from string against\
    \ substring\n        var count = 0\n        while (substringItr.hasNext) {\n \
    \           if (stringItr.hasNext) {\n                // Compare the current character\
    \ from string against substring\n                // if there is a match, increment\
    \ count\n                // If the characters are not the same, skip to the next\
    \ character\n                if (stringItr.next() == substringItr.next()) {\n\
    \                    count += 1\n                }\n            } else {\n   \
    \             // String is exhausted\n                break\n            }\n \
    \       }\n\n        // Return the number of matches found\n        count", " \
    \       val n = string.length\n        val m = substring.length\n        \n  \
    \      val result = new mutable.HashMap[String, Long]()\n        var i = 0\n \
    \       for (i <- 0 to n by m) \n          val currentSubstring = string.substring(i)\n\
    \          if (currentSubstring.startsWith(substring))\n          result(currentSubstring)\
    \ = result.getOrElse(currentSubstring, 0) + 1\n        result", "        // Keep\
    \ track of the number of times we've seen each letter in substring\n        var\
    \ counts = mutable.Map[Character, Long]()\n        // Create a mutable buffer\
    \ to hold the current position\n        var buffer = new StringBuilder()\n   \
    \     var i = 0\n        while (i < string.length) {\n            // Append the\
    \ character to the buffer\n            buffer.append(string(i))\n            //\
    \ Add the letter from buffer to counts\n            if (counts.getOrElse(buffer.charAt(0),\
    \ 0L) == 0) {\n                counts.update(buffer.charAt(0), 1L)\n         \
    \   } else {\n                // If we've seen it before count the overlap\n \
    \               counts.update(buffer.charAt(0), counts.getOrElse(buffer.charAt(0),\
    \ 0L) + 1L)\n            }\n            // Move on in the string\n           \
    \ i += 1\n        }\n        // Now we have all of the counts. Look for the substring\
    \ in the counts\n        var found = 0L\n        for (letter <- substring) {\n\
    \            if (counts.getOrElse(letter, 0L) > 0) {\n                found +=\
    \ 1\n            }\n        }\n        // Return the total number of overlaps\n\
    \        return found", "        var cnt = 0\n        for(a <- 0 to string.length){\n\
    \            val sub = string.substring(a,a+substring.length)\n            if(sub\
    \ == substring)\n                cnt = cnt + 1\n        }\n        return cnt",
  "        // Initialize a counting variable to store the count of substring\n   \
    \     var count = 0.0\n        val charSet = string.toSet\n        for (i <- 0\
    \ to string.length - substring.length) {\n            val subCharSet = substring.asInstanceOf[CharSet]\n\
    \            val subChars = string.substring(i, i + substring.length).toSet\n\
    \            val allChars = charSet.union(subChars)\n            count = allChars.count(c\
    \ => subCharSet.contains(c))\n        }\n        count", "        val countMap\
    \ = mutable.Map[String, Long]()\n        val stringSplit = string.split(substring)\n\
    \        val substringSplit = substring.split(string)\n        for (i <- 0 until\
    \ substringSplit.length) {\n            if (!stringSplit(i).equals(substringSplit(i)))\
    \ {\n                countMap ++= substringSplit(i)\n            } else {\n  \
    \              countMap += (substringSplit(i) -> 1)\n            }\n        }\n\
    \        string.split(substring).length * substringSplit.length", "        val\
    \ chars = string.split(substring)\n        // Count the number of chars overlapping\
    \ each substring\n        chars.count(_ == substring).map(n => string.count(_\
    \ == substring).filter(_ >= n).length)", "        // If string and substring are\
    \ empty\n        if (string.isEmpty || substring.isEmpty) {\n            return\
    \ 0\n        }\n\n        // Count substring\n        var count = 0L\n       \
    \ var pos = 0\n        while ((pos = string.indexOf(substring, pos)) != -1) {\n\
    \            count += 1L\n            pos += substring.length\n        }\n\n \
    \       count", "        var count = 0\n        var strArray = string.toCharArray\n\
    \        var substrArray = substring.toCharArray\n        // Use a mutable list\
    \ to keep track of which characters have already been found.\n        // The mutable\
    \ list will track duplicates. So \"aaba\" has duplicates.\n        var found =\
    \ new mutable.ListBuffer[Char]()\n        // Keep going until we run out of characters\
    \ in the string or the substring\n        while (strArray.length > 0 && substrArray.length\
    \ > 0) {\n            // If the current character in the string hasn't been seen\
    \ yet...\n            if (strArray[0] != substrArray[0]) {\n                //\
    \ Add it to the found list\n                found += strArray(0)\n           \
    \     // Remove the character from the array\n                strArray = strArray.drop(1)\n\
    \            }\n            // If we haven't reached the end of the substring...\n\
    \            if (substrArray.length > 0) {\n                // Get the first character\
    \ of the substring and see if we've found it\n                if (strArray.length\
    \ > 0) {\n                    count += found.contains(strArray(0))\n         \
    \       }\n                // Remove the character from the array\n          \
    \      substrArray = substrArray.drop(1)\n            }\n        }\n        count",
  "        val regex = new Regex(substring)\n        val matches = regex.findAllIn(string).size\n\
    \        matches.toLong", "        val subList: mutable.List[String] = mutable.ArrayBuffer.empty[String]\n\
    \        subList.add(substring)\n        var count = 0\n        while(subList.length\
    \ < (string.length -1 )) {\n            val index = string.indexOf(subList.head)\n\
    \            if (index > -1) {\n                subList.add(string.substring(0,index))\n\
    \                count += 1\n            }\n        }\n        count", "     \
    \   val pattern = substring ++ \"+\"\n        var i = 0\n        var count = 0\n\
    \        while(i < string.length) {\n            if (string.startsWith(substring,\
    \ i)) {\n                count +=1\n            }\n            i += 1\n      \
    \  }\n        count", "        var count = 0\n        var i = -1\n        var\
    \ j = 0\n        while ((i = string.indexOf(substring, j)) != -1) {\n        \
    \    count += 1\n            j = i + 1\n        }\n        count", "        var\
    \ count = 0\n        var start = 0\n        var subStringCount = 0\n        var\
    \ charCount = string.length\n\n        while (start < charCount) {\n         \
    \   start = string.indexOf(stringSub(string, start), start)\n            if (start\
    \ == -1) break\n            count++\n            start += 1\n        }\n\n   \
    \     if (count > 0) subStringCount = count\n        return subStringCount", " \
    \       // Convert string to array\n        val array = string.split(\"\")\n\n\
    \        // Create an array of all substrings to count how many times they appear.\n\
    \        val allSubstrings = array.map(_.toLowerCase()).filter(s => s.contains(substring.toLowerCase()))\n\
    \        val numberOfSubstrings = allSubstrings.size\n\n        // Count the overlaping\
    \ cases\n        val numberOfOverlaping = array.filter(s => allSubstrings.contains(s)).size\n\
    \n        numberOfSubstrings + numberOfOverlaping", "        var total = 0\n \
    \       for (i <- 0 until string.length) {\n            if (string.indexOfSubstring(substring,\
    \ i) == i) {\n                total += 1\n            }\n        }\n        return\
    \ total", "        var count = 0\n        for(i <- 0 until string.length -1 ){\n\
    \            val current = string.charAt(i)\n            val next = string.charAt(i+1)\n\
    \            if( current == substring.charAt(0) && next == substring.charAt(1)\
    \ ){\n                count +=1\n            }\n        }\n        count", " \
    \       var count = 0\n        for (c1 <- string) {\n            val found = substring.indexOf(c1)\n\
    \            if (found > -1 && found == substring.indexOf(c1, found + 1)) {\n\
    \                count += 1\n            }\n        }\n        count", "     \
    \   // Step 1: Convert the string to Array\n        val stringArray = string.split(\"\
    \\\\s\").toList\n        val substringArray = substring.split(\"\\\\s\").toList\n\
    \        // Step 2: Sort the two Arrays\n        stringArray.sortWith(_ > _)\n\
    \        substringArray.sortWith(_ > _)\n        // Step 3: Calculate the overlap\n\
    \        var overlap : Long = 0\n        for (i<- 0 until stringArray.length-1)\
    \ {\n            if (stringArray(i) == substringArray(i)) {\n                overlap\
    \ = overlap + 1\n            }\n        }\n        // Step 4: Return result\n\
    \        overlap", "        var count : Long = 0L\n        // Find how many times\
    \ substring appears in string\n        var i : Int = 0\n        while (i < string.length\
    \ && i < substring.length) {\n            if (string.charAt(i) != substring.charAt(i))\
    \ {\n                break\n            } else {\n                i += 1\n   \
    \         }\n        }\n        // If substring appears once, return 1, else return\
    \ length of string - substring.length\n        if (i == string.length && i ==\
    \ substring.length) {\n            count += 1\n        } else {\n            count\
    \ = string.length - (substring.length)\n        }\n        count", "        def\
    \ countSubstrings(string : String, substring : String, counter : Int) : Int =\
    \ {\n            if (string == \"\") {\n                counter\n            }\
    \ else {\n                counter + countSubstrings(string.substring(1), substring,\
    \ 0)\n            }\n        }\n        countSubstrings(string, substring, 0)",
  "        // Split string into character set. Keep all character sets that have the\
    \ same number of elements as the substring\n        // This assumes that there\
    \ are no duplicates\n        def countSameLength(set: Set[Char], substring: Set[Char],\
    \ count : Long) : Long = {\n            val setWithoutSubstring = set - substring\n\
    \            val setWithSubstring = setWithoutSubstring + substring\n        \
    \    if(setWithSubset.isEmpty) count else countSameLength(setWithSubstring, substring,\
    \ count + 1)\n        }\n        // Split string into character sets. Keep all\
    \ character sets that have the same number of elements as the substring\n    \
    \    // This assumes that there are no duplicates\n        def countAllLength(set:\
    \ Set[Char], substring: Set[Char], count : Long) : Long = {\n            val setWithoutSubstring\
    \ = set - substring\n            val setWithSubstring = setWithoutSubstring +\
    \ substring\n            if(setWithSubset.isEmpty) count else countAllLength(setWithSubstring,\
    \ substring, count + 1)\n        }\n        val characterSet = string.split(\"\
    \")\n        val substringSet = substring.split(\"\")\n        // Keep all character\
    \ sets with same number of elements as the substring\n        if(characterSet.size\
    \ == substringSet.size)\n            return countAllLength(characterSet, substringSet,\
    \ 0)\n        else if(characterSet.size > substringSet.size)\n            return\
    \ countSameLength(characterSet, substringSet, 0)\n        else\n            return\
    \ countSameLength(characterSet, substringSet, 1)", "        if (string.length\
    \ == 0) 0\n        else {\n            val indexArray = string.split(substring).zipWithIndex\n\
    \            val indexSet = new HashSet[Int](indexArray.size)\n            indexArray.toSet.map(indexSet.add)\n\
    \        }.sum", "        var counter = 0\n        var pos = -1\n        val pattern\
    \ = substring.r\n\n        while(pos <= string.length - pattern.length)\n    \
    \    pos = string.indexOf(pattern, pos + pattern.length)\n\n        counter +=\
    \ 1\n        pos ++= pattern.length\n        counter += 1\n        pos", "   \
    \     // Using hashset is a better solution, that reduces the time complexity\
    \ from O(n) to O(1)\n        val strings = string.toLowerCase.toList.distinct\n\
    \        val substrings = substring.toLowerCase.toList.distinct\n\n        //\
    \ Using a mutable collection will reduce the complexity from O(n) to O(1)\n  \
    \      val counts : mutable.HashSet[Long] = mutable.HashSet.empty\n\n        //\
    \ Iterating through strings to find overlaping substrings\n        for(s <- strings)\
    \ for(ss <- substrings) {\n            // Overlapping cases\n            if (s\
    \ == ss) {\n                counts += 2\n                continue\n          \
    \  }\n\n            if (s.startsWith(ss) && s.endsWith(ss.reverse)) {\n      \
    \          counts += 2\n                continue\n            }\n\n          \
    \  // Non-overlapping cases\n            counts += 1\n        }\n\n        //\
    \ Counting overlaping cases\n        strings.size - counts.size", "        def\
    \ checkSubstring(t1, t2) : Boolean = {\n            var count : Long = 0\n   \
    \         val s1 = Array(t1)\n            val s2 = Array(t2)\n            val\
    \ i = s1.length\n            val j = s2.length\n            while (i < j) {\n\
    \                if (s1(i) ne s2(i)) {\n                    count = count + 1\n\
    \                    i = i + 1\n                } else {\n                   \
    \ i = i + 1\n                }\n            }\n            return count == s2.length\n\
    \        }\n        if (substring == \"\") return 0\n        if (string == \"\"\
    ) return 0\n        var count = 0\n        var lastIdx = 0\n        var lastIdxEnd\
    \ = 0\n        var lastSubstringEnd = 0\n        var idx = -1\n        while (idx\
    \ < string.length()) {\n            lastIdx = idx\n            idx = string.indexOf(stringToCharArray(substring),\
    \ idx + 1)\n            lastIdxEnd = idx\n            idx = idx + 1\n        \
    \    if (idx == 0) return count\n            if (idx == string.length()) return\
    \ count\n            var substringEnd = string.length()\n            var substringIdx\
    \ = 0\n            while (substringIdx < substring.length) {\n               \
    \ substringEnd = substringEnd + 1\n                substringIdx = substringIdx\
    \ + 1\n                if (idx < substringEnd) {\n                    substringIdx\
    \ = substringIdx + 1\n                    var substring = stringToCharArray(substring.substring(substringIdx))\n\
    \                    var substringEndInString = 1\n                    var substringCharInString\
    \ = 0\n                    var idx2 = -1\n                    while (substringCharInString\
    \ < substring.length) {\n                        if (substringCharInString ==\
    \ 0) {\n                            idx2 = idx\n                            substringCharInString\
    \ = substring.length\n                        }\n                        idx2\
    \ = idx + substringCharInString\n                        if (idx2 == string.length())\
    \ return count\n                        if (string.charAt(idx2) != substring)\
    \ {\n                            substringCharInString = substringCharInString\
    \ + 1\n                        }\n                        if (idx2 >= lastIdx)\
    \ {\n                            if (checkSubstring(string.substring(lastIdx,\
    \ idx2), substring)) {\n                                count = count + 1\n  \
    \                          }\n                        }\n                    \
    \    substringCharInString = substringCharInString + 1\n                    }\n\
    \                }\n            }\n        }\n        return count"]
stop_tokens:
- "\n    }\n"
