name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val seen = mutable.HashSet[Long]()\n        numbers.foreach\
    \ { n =>\n            seen(n)\n        }\n        numbers filterNot { n => seen.contains(n)\
    \ }", '        numbers.groupBy(_).filter({ case (key, values) => values.size ==
    1 })', "        val result = numbers.foldLeft(List[Long]())((l,t) => {\n     \
    \       if (l.isEmpty || l.exists(l => t == l)) {\n                l :+ t\n  \
    \          }\n            else {\n                l\n            }\n        })\n\
    \        result.reverse", "        def remove(acc : mutable.HashSet[Long], x :\
    \ Long) : Boolean = x match {\n            case 1l => false\n            case\
    \ 2l => acc -= x\n            case 3l => acc -= x\n            case 4l => acc\
    \ -= x\n            case 5l => acc -= x\n            case 6l => acc -= x\n   \
    \         case 7l => acc -= x\n            case 8l => acc -= x\n            case\
    \ 9l => acc -= x\n            case 10l => acc -= x\n            case 11l => acc\
    \ -= x\n            case 12l => acc -= x\n            case 13l => acc -= x\n \
    \           case 14l => acc -= x\n            case 15l => acc -= x\n         \
    \   case 16l => acc -= x\n            case 17l => acc -= x\n            case 18l\
    \ => acc -= x\n            case 19l => acc -= x\n            case 20l => acc -=\
    \ x\n            case 21l => acc -= x\n            case 22l => acc -= x\n    \
    \        case 23l => acc -= x\n            case 24l => acc -= x\n            case\
    \ 25l => acc -= x\n            case 26l => acc -= x\n            case 27l => acc\
    \ -= x\n            case 28l => acc -= x\n            case 29l => acc -= x\n \
    \           case 30l => acc -= x\n            case 31l => acc -= x\n         \
    \   case 32l => acc -= x\n            case 33l => acc -= x\n            case 34l\
    \ => acc -= x\n            case 35l => acc -= x\n            case 36l => acc -=\
    \ x\n            case 37l => acc -= x\n            case 38l => acc -= x\n    \
    \        case 39l => acc -= x\n            case 40l => acc -= x\n            case\
    \ 41l => acc -= x\n            case 42l => acc -= x\n            case 43l => acc\
    \ -= x\n            case 44l => acc -= x\n            case 45l => acc -= x\n \
    \           case 46l => acc -= x\n            case 47l => acc -= x\n         \
    \   case 48l => acc -= x\n            case 49l => acc -= x\n            case 50l\
    \ => acc -= x\n            case 51l => acc -= x\n            case 52l => acc -=\
    \ x\n            case 53l => acc -= x\n            case 54l => acc -= x\n    \
    \        case 55l => acc -= x\n            case 56l => acc -= x\n            case\
    \ 57l => acc -= x\n            case 58l => acc -= x\n            case 59l => acc\
    \ -= x\n            case 60l => acc -= x\n            case 61l => acc -= x\n \
    \           case 62l => acc -= ", "        val counts = mutable.HashMap[Long,\
    \ Int]()\n        numbers.foreach{n => counts.update(n, n + 1)}\n        val result\
    \ = numbers.filter{n => !counts.contains(n)}.toList\n        result", "      \
    \  var newList = numbers.toList\n        newList.toSet.filterNot(_ == 1).toList",
  "        numbers.groupBy(_).mapValues(_.size)\n            .toList.sortWith(_._2\
    \ < _._2) \n            .toList", "        var result: List[Long] = List()\n \
    \       numbers.foldLeft(List[Long]()) { (result, number) => {\n            var\
    \ newResult = result\n            if(newResult contains number) {\n          \
    \      newResult = newResult - number\n            }\n            if(newResult.nonEmpty)\
    \ {\n                result = result :+ number\n            }\n            newResult\n\
    \        }}\n        result", "        val newNumbers = mutable.LinkedHashSet[Long]()\n\
    \        for (n <- numbers) {\n            if (!newNumbers.contains(n))\n    \
    \            newNumbers += n\n        }\n        newNumbers.toList", '        numbers.groupBy(identity).filter{
    case (_, list) => list.size() == 1 }.map{ case (_, list) => list.toList}', '        numbers.groupBy(_).filter(_.size
    > 1).map(_.min).values', "        val grouped = numbers.groupBy(x => x)\n    \
    \    val distinctGrouped = grouped.filter(_._2.length == 1)\n        distinctGrouped.map(_._1).sort",
  "        var list = numbers.toList\n        var uniqueNumbers = List[Long]()\n \
    \       for (i<-list) {\n            if (uniqueNumbers.contains(i)) {\n      \
    \          uniqueNumbers.remove(i)\n            }\n            else {\n      \
    \          uniqueNumbers += i\n            }\n        }\n        return uniqueNumbers.toList",
  "        val seenSet = mutable.Set.empty[Long]\n        numbers.foreach {\n    \
    \        n =>\n            if (seenSet.contains(n)) numbers.remove(seenSet.indexOf(n))\n\
    \            else seenSet.add(n)\n        }\n        numbers", '        numbers.groupBy(_).toList.filter(_._2
    > 1)', "        // Count how many times each element occurs in numbers.\n    \
    \    val counts = numbers.groupBy(_).mapValues(_.size)\n\n        // Get the list\
    \ of numbers that occur more than once.\n        val dups = numbers.filter(e =>\
    \ counts(e) > 1)\n\n        // Return the list of numbers that occur only once.\n\
    \        dups.filter(e => counts(e) == 1)", "        var toReturn = numbers.filterNot(_\
    \ == numbers.last)\n        for (i<-numbers.indices) {\n            if (toReturn.exists(x=>\
    \ x == numbers[i])) {\n                toReturn = numbers.filterNot(x=> x == numbers[i])\n\
    \            } else {\n                toReturn = toReturn::numbers[i:i+1]\n \
    \           }\n        }\n        toReturn", "        val result = new ArrayBuffer[Long]()\n\
    \        numbers.foreach(n => if (result.contains(n)) else result += n)\n    \
    \    result.toList", "        var nums = mutable.Set.empty[Long]\n        for(n\
    \ <- numbers) nums ++= n\n        nums filter (n => nums.contains(n))", "    \
    \    numbers.foldLeft(List[Long]())((acc, n) => {\n            acc :+ n\n    \
    \        val duplicates = acc filter (_ == n)\n            if (duplicates.size\
    \ == 1)\n                acc\n            else duplicates\n        })", "    \
    \    var uniqueNumbers : Set[Long] = Set()\n        var result : List[Long] =\
    \ numbers.filter(n => !uniqueNumbers.contains(n) && uniqueNumbers.add(n))\n  \
    \      result", '        numbers.groupBy(_._1).mapValues(_.map(_._2)).map(_._2.toList.sortWith(_._2
    < _._2))', "        val set = Set[Long]() ++ numbers\n        var result = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < set.size) {\n            if (set.contains(i))\
    \ {\n                result += numbers(i)\n                set.delete(i)\n   \
    \         } else {\n                result += numbers(i)\n                i +=\
    \ 1\n            }\n        }\n        result", "        val mc = mutable.Map[Long,\
    \ Int]()\n        for (i <- numbers) {\n            if (mc.getOrElse(i, 0) ==\
    \ 1) {\n                mc.update(i, 0)\n            } else {\n              \
    \  mc.update(i, 1)\n            }\n        }\n        numbers.filter(!(mc.getOrElse(_,\
    \ 0) == 1)).toList", "      val map = new mutable.HashMap[Long, Int]()\n     \
    \ numbers.foreach{ x => map.putIfAbsent(x, 0) }\n      val result = new ListBuffer[Long]()\n\
    \      numbers.foreach{ x =>\n        if (map.get(x) <2) result += x\n       \
    \ map.putIfAbsent(x, map.get(x) + 1)\n      }\n      result.toList", "       \
    \ val unique = numbers.distinct\n        val duplicates = numbers.filter(x =>\
    \ unique.count(_ == x) > 1)\n        unique.filter(x => numbers.count(_ == x)\
    \ > 1).distinct", "        val seen = mutable.HashSet[Long]()\n        var numbersList\
    \ = numbers;\n        numbersList.foreach(i => if(!seen.add(i)) numbersList -=\
    \ i)\n        return numbersList", "        var uniques = scala.collection.mutable.HashSet.empty[Long]\n\
    \        for (number <- numbers) {\n            if (uniques.contains(number))\
    \ {\n                uniques.remove(number)\n            }\n            else {\n\
    \                uniques += number\n            }\n        }\n        uniques.toList",
  "        var seen = mutable.HashSet[Long]()\n        var output = mutable.ArrayBuffer.empty[Long]\n\
    \        var current = 0\n\n        for (current <- numbers) {\n            if\
    \ (seen.contains(current)) {\n                continue\n            }\n      \
    \      output += current\n            seen += current\n        }\n        output.toList",
  "        // Using an index to keep track of how many times we've seen an element\
    \ and\n        // removing it when it's seen twice or more times. \n        val\
    \ seen = scala.collection.mutable.HashSet[Long]()\n        \n        for(number\
    \ <- numbers) {\n            if(seen.add(number)) {\n                seen.diff(number)\n\
    \            } else {\n                numbers filter { _ != number }\n      \
    \      }\n        }", "        numbers.foldLeft(List[Long]())((list, n) => list\
    \ match {\n            case head :: tail if n != head => head :: tail\n      \
    \      case _ => list\n        })", '        numbers.toList groupBy (_) mapValues
    (_.size)', "        val counts = numbers.foldLeft(Map(1l -> 0l, 2l -> 0l, 3l ->\
    \ 0l, 4l -> 0l)) {\n            case (acc, x) => acc + (x -> (acc.getOrElse(x,\
    \ 0l) + 1l))\n        }\n\n        numbers.filter(x => counts.getOrElse(x, 0l)\
    \ > 1).map(x => counts.getOrElse(x, 0l)).distinct", "        val result = numbers.filterNot(numbers.contains(_))\n\
    \        result.sortWith((x, y) => x - y)\n        result", "        val seen\
    \ = new mutable.HashSet[Long]\n        val newList = new mutable.ListBuffer[Long]()\n\
    \        numbers foreach { x =>\n            seen += x\n        }\n        numbers\
    \ foreach { x =>\n            if(seen.contains(x)) {\n                newList\
    \ += x\n                seen.delete(x)\n            }\n        }\n        newList.toList",
  "        numbers.groupBy(x => x).map(_.size)\n            .filter(_._2 > 1) // Filter\
    \ out elements that have repeated count of 1.\n            .filter(x => numbers.count(_\
    \ == x) == 1)\n            .map(x => numbers.remove(x))", "        val seen =\
    \ mutable.HashSet[Long]()\n        numbers.filterNot(seen.add)", "        var\
    \ set = mutable.HashSet[Long]()\n        var result: List[Long] = numbers.toList\n\
    \        for(n <- numbers) if (set.contains(n)) result = result.filterNot(_ ==\
    \ n)\n        result += set.iterator.toList", "        var removed = new HashSet[Long]()\n\
    \        numbers.foreach(number => {\n            if (removed.contains(number))\n\
    \                removed = removed.filter(_ != number)\n            else\n   \
    \             removed = removed + number\n        })\n        numbers.toList.filter(_\
    \ != removed.toSet[Long]).reverse", "        val seen = mutable.Set[Long]()\n\
    \        var output: List[Long] = Nil\n        for (i <- numbers) {\n        \
    \    if (seen(i) == true) output = output :+ i\n            else seen(i) = true\n\
    \        }\n        return output", "        val seen = new mutable.HashSet[Long]()\n\
    \        val output: List[Long] = new ListBuffer[Long]()\n        for (i <- numbers)\n\
    \          if (seen.contains(i))\n            output += i\n          else\n  \
    \          seen += i\n        output.toList", "        val numSet = numbers.toSet\n\
    \        numbers filterNot numSet", "        // 1. Create a map of numbers ->\
    \ counts\n        // 2. For each number in input, increment count\n        //\
    \ 3. Remove any numbers that have count < 2\n        // 4. If counts == 0, return\
    \ input\n        val map = numbers.groupBy(x => x).mapValues(_.size.toLong).withDefaultValue(0)\n\
    \n        numbers.filter(_ < map.get(numbers)) match {\n            case head\
    \ :: tail => {\n                map.get(numbers) -= 1\n                removeDuplicates(tail)\n\
    \            }\n            case _ => numbers = map.filterValues(_.toLong == 0).keys.toList\n\
    \        }", "        val set = new mutable.HashSet[Long]\n        numbers.foreach(x\
    \ => if (!set.add(x)) set.remove(x))\n        set.map(_._1)", "        var result\
    \ = numbers.filter(_ => numbers.count(_ != _) == 1)\n        result.sortWith((a,\
    \ b) => a.compareTo(b) < 0)\n        result", "        val counts = numbers.map(x\
    \ => x -> 1l).groupBy(x => x._1).map(x => (x._1, x._2.size)).toMap\n        if\
    \ (counts.isEmpty) numbers else {\n            val keys = (0 to counts.length).map(i\
    \ => counts(i)).toArray\n            val rest = removeDuplicates(numbers.filterNot(x\
    \ => keys.contains(x)))\n            (keys ++ rest).map(x => counts(x))\n    \
    \    }", "        var newList = List(numbers.head) ::: numbers.tail\n        var\
    \ seen = scala.collection.mutable.Set.empty[Long]\n        for(i <- numbers) {\n\
    \            if(seen.contains(i)) {\n                // If we've already seen\
    \ it, then leave it in.\n            } else {\n                seen += i\n   \
    \             newList -= i\n            }\n        }\n        newList.map { case\
    \ i => i }", "        val seen = new mutable.HashSet[Long]()\n        var numbersToRemove:\
    \ List[Long] = List()\n        for (number <- numbers) {\n            if (seen.contains(number))\
    \ {\n                numbersToRemove ::= number\n            } else {\n      \
    \          seen += number\n            }\n        }\n        numbersToRemove",
  "        val nums = numbers.toSet\n        val newNumbers = nums.filterNot(nums.contains(_)).toList\n\
    \        val newList = newNumbers.map(n => n+1).toList\n        newList", "  \
    \      val hashSet = mutable.HashSet[Long]()\n        for (i<-0 until numbers.size)\
    \ {\n            if (hashSet.contains(numbers(i)) {\n                hashSet.remove(numbers(i))\n\
    \            } else {\n                hashSet += numbers(i)\n            }\n\
    \        }\n        hashSet.toList", "        var result = List[Long]()\n    \
    \    var seen = mutable.HashSet[Long]()\n        for ( n <- numbers ) {\n    \
    \        if ( !seen(n) ) {\n                result = (n :: result)\n         \
    \   }\n            seen = n\n        }\n        result", "        // Find all\
    \ unique elements\n        val unique = numbers.distinct.toList\n        // Keep\
    \ only elements occuring more than once\n        val result = unique.filter( x\
    \ => numbers.count(_ == x) > 1 )\n        return result", "        var duplicates\
    \ = new mutable.HashSet[Long]\n        var result : List[Long] = new ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            if (duplicates.contains(number))\
    \ {\n            } else {\n                duplicates += number\n            \
    \    result += number\n            }\n        }\n        result.toList", "   \
    \     val seen = new mutable.HashSet[Long]()\n        numbers map { n =>\n   \
    \         if (seen.contains(n)) {\n                -1\n            } else {\n\
    \                seen.add(n)\n                n\n            }\n        }", " \
    \       val result = numbers.groupBy(n => n).filter(_._2 > 1).keys\n        val\
    \ copy = numbers.toList\n        copy.foreach{ x => x :: result.get(x) }\n   \
    \     copy.toList", "        var seen : scala.collection.mutable.Map[Long, Long]\
    \ = scala.collection.mutable.Map()\n        numbers.foreach{ n => seen.getOrElseUpdate(n,\
    \ n) match { case None => seen += (n, n) case Some(seenN) => if (seenN > n) seen\
    \ += (n, seenN) } }\n        seen.values.toList", "        // Use a set to remove\
    \ duplicates\n        var seen: Set[Long] = Set.empty\n        // Iterate through\
    \ the list keeping track of duplicates\n        var result: List[Long] = numbers\
    \ map { x =>\n            if !seen.contains(x) {\n                // The element\
    \ was seen before, just add it to the new list\n                result ::= x\n\
    \                seen += x\n            } else {\n                // The element\
    \ was not seen before, add the element to the list of numbers to keep\n      \
    \          result ::= x\n            }\n        }\n        // Return the new list\n\
    \        result", "        val counts = mutable.Map.empty[Long, Int]\n       \
    \ numbers.foreach { n =>\n            counts.getOrElseUpdate(n, (n: Int) => 1).toInt\n\
    \        }\n        numbers.filter(n => counts(n) > 1)", "        val seen = new\
    \ mutable.HashSet[Long]\n        numbers.filter(n => n != null && seen.add(n))",
  "        val seen = mutable.HashSet[Long]()\n        for (i <- numbers)\n      \
    \      if (!seen.contains(i)) {\n                seen += i\n            }\n  \
    \      seen.toList.sort", "        val seen = new mutable.HashSet[Long]()\n  \
    \      val out = new mutable.HashSet[Long]()\n        numbers.foreach {\n    \
    \        case x if !seen.add(x) => out.add(x)\n        }\n        val numsOut\
    \ = out.toList\n        out.clear()\n        out.retainAll(seen)\n        numsOut",
  "        var nums : List[Long] = Nil\n        for (i <- 0 until numbers.size) {\n\
    \            if (nums.contains(numbers(i))) {\n                nums = nums.filter\
    \ { _ != numbers(i) }\n            } else {\n                nums = nums :+ numbers(i)\n\
    \            }\n        }\n        nums", "        val counts = mutable.Map[Long,\
    \ Long]()\n        for (number <- numbers) {\n            val count = counts.getOrElse(number,\
    \ 0)\n            counts += (number -> (count + 1))\n        }\n        val result\
    \ = numbers.filterNot(i => counts.contains(i))\n        result", "        val\
    \ uniqueNumbers = numbers.toSet.map(_ -> None).toList\n        uniqueNumbers.map(_.swap).getOrElse(Nil)",
  "        val nums = numbers.toSet\n        val res = ListBuffer.empty[Long]\n  \
    \      numbers foreach (num => nums remove num)\n        numbers foreach (num\
    \ => res.append(num))\n        res", "        var toRemove : Set[Long] = new HashSet[Long]\n\
    \        numbers.foreach { x =>\n            if (!toRemove.contains(x)) {\n  \
    \              toRemove.add(x)\n            }\n        }\n        numbers.filterNot(toRemove.toList)",
  '        numbers.groupBy(_.toLong).values.toList.sortBy(_.toLong).map(_._1).distinct',
  "        val numberSet = numbers.toSet\n        val doubles = numbers.filterNot(numberSet)\n\
    \        doubles ++ numbers.filterNot(numberSet)", "        val listWithDuplicates\
    \ =  numbers.groupBy(x => x)\n        val listWithoutDuplicates = listWithDuplicates.filter(x\
    \ => x._2.size === 1)\n        val list = listWithoutDuplicates.map(x => x._1)\n\
    \        list", "        // Make a new mutable list, so that we can mutate it\
    \ while iterating over the list.\n        val numbersInOrder = mutable.ListBuffer.empty[Long]\n\
    \        for (number <- numbers)\n            numbersInOrder.append(number)\n\n\
    \        // Traverse the list in reverse order and remove numbers whose count\
    \ is greater than 1.\n        for (i <- numbersInOrder.length - 1 downto 0 by\
    \ -1)\n            if (numbersInOrder.count(numbersInOrder.elementAt(i)) > 1)\n\
    \                numbersInOrder.remove(numbersInOrder.elementAt(i))\n\n      \
    \  numbersInOrder", '        numbers.distinct', '        numbers.groupBy(x =>
    x).filter(x => x.size === 1).mapValues(_.toList)', "        val seen = mutable.Set[Long]()\n\
    \        numbers.foreach(x => { if (seen.contains(x)) numbers.remove(x) else seen.add(x)\
    \ })\n        numbers.toList", "        var result = new Array[Long](numbers.size)\n\
    \        var distinctNumbers = mutable.Set[Long]()\n        numbers.foreach {\
    \ n =>\n            if( !distinctNumbers.contains(n) ) {\n                distinctNumbers\
    \ += n\n                result += n\n            }\n        }\n        result",
  "        if (numbers.isEmpty) numbers else {\n            val seen = new mutable.HashSet[Long]()\n\
    \            var result = numbers match {\n                case Nil => Nil\n \
    \               case head :: tail =>\n                    if (seen.contains(head))\
    \ removeDuplicates(tail)\n                    else result ::: List(head)\n   \
    \             case _ =>\n                    throw new IllegalArgumentException(\"\
    Expected a List with at least one element\")\n            }\n            return\
    \ result\n        }", "        var duplicates = Set.empty[Long]\n        for (number\
    \ in numbers) {\n            if (!duplicates.contains(number)) {\n           \
    \     duplicates = duplicates + number\n            }\n        }\n        numbers.toList.filter(_\
    \ != duplicates.head).toList", "        val listOfNumbers = numbers.toSet\n  \
    \      val newList = ListBuffer[Long]()\n        for (el <- numbers) {\n     \
    \       if (!listOfNumbers.contains(el)) {\n                newList.append(el)\n\
    \            }\n        }\n        return newList.toList", "        var newList:\
    \ List[Long] = List.empty\n        numbers.groupBy(_).filter(_._2 > 1).foreach\
    \ {\n            case (_, numberToRemove) =>\n                newList ::= numberToRemove\n\
    \        }\n        newList", "        var sets = Nil\n        for( i <- numbers\
    \ ) {\n            if( sets.isEmpty() ) {\n                sets = Set(i.toLong)\n\
    \            }\n            if( sets.contains(i.toLong) ) {\n                sets.remove(i.toLong)\n\
    \            }\n            else {\n                sets = sets :+ i.toLong\n\
    \            }\n        }\n        sets.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var seen = 0\n        for (n <- numbers) {\n            if (n != seen)\
    \ {\n                seen += 1\n                result += n\n            }\n \
    \       }\n        result", "        val seen = mutable.Set.empty[Long]\n    \
    \    numbers filter { number =>\n            if (seen(number)) false else seen(number)\
    \ = true\n        }", "        val counts = numbers.groupBy(i => i).mapValues(_.length)\n\
    \        numbers.filterNot(i => counts.get(i) > 1)", "        numbers.foldLeft(List.empty[Long])\
    \ { (result, elem) =>\n            var newList: List[Long] = Nil\n           \
    \ for(i <- result) if(newList.contains(elem)) newList else newList = newList :+\
    \ elem\n            newList :+ elem\n        }", "        numbers.toList.groupBy(identity).collect\
    \ { case (number, list) =>\n            if (list.length == 1)\n              \
    \  number\n            else\n                list.head\n        }.toList", " \
    \       // Initialize result list\n        var result: List[Long] = Nil\n    \
    \    \n        // Traverse list of numbers\n        for (i <- 0 until numbers.size)\
    \ {\n            // Check if number is already in result list\n            if\
    \ (numbers.exists(n => n == numbers(i))) {\n                // If number is in\
    \ result list, remove it \n                numbers.remove(numbers(i))\n      \
    \      } else {\n                // If number is not in result list, add it to\
    \ result list\n                result = number::result\n            }\n      \
    \  }\n        \n        return result", "        var output: List[Long] = Nil\n\
    \        var seen: Set[Long] = Set()\n        for (i <- numbers) {\n         \
    \   seen += i\n        }\n        for (i <- numbers) {\n            if (seen.contains(i))\
    \ {\n                continue\n            }\n            output = output :+ i\n\
    \            seen += i\n        }\n        return output", "        numbers.foldLeft(List[Long]()){\n\
    \          case (acc, elem) =>\n            // Add number to the accumulator if\
    \ it does not exist yet,\n            // or if it has already been seen, remove\
    \ it from the accumulator.\n            if (acc contains elem) acc else acc :+\
    \ elem\n        }", "        var counts : mutable.Map[Long, Long] = mutable.Map[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            counts += (number\
    \ -> (counts.getOrElse(number, 0) + 1l))\n        }\n        numbers.filter(number\
    \ => counts.getOrElse(number, 0) > 1l).sortWith(_ < _)", "        var uniques\
    \ = scala.collection.mutable.HashSet.empty[Long]\n        for(i <- numbers)\n\
    \            uniques +=(i)\n        numbers.filterNot(uniques.contains)", "  \
    \      var result : List[Long] = numbers match {\n            case Nil => Nil\n\
    \            case x::xs => if (numbers.count(_ == x) > 1) x :: removeDuplicates(xs)\
    \ else x::removeDuplicates(xs)\n        }\n        result", "        // Add each\
    \ element to a Set\n        // If a element already exists in the set (that is,\
    \ it was in the input list),\n        // then remove it from the list.\n     \
    \   // Return the new list of elements.\n        val unique = mutable.Set[Long]()\n\
    \        numbers.foreach(unique+=_)\n        unique.toList", "        var seen\
    \ = mutable.Set.empty[Long]\n        numbers foreach {n =>\n            if (seen.contains(n))\n\
    \                numbers.remove(numbers.indexWhere(_ == n))\n            else\n\
    \                seen += n\n        }\n        numbers", "        val result =\
    \ mutable.ListBuffer[Long]()\n        numbers.foldLeft(0) { (acc, x) =>\n    \
    \        if(acc == 0) x\n            else {\n                if(numbers.takeWhile(_\
    \ != x).length == 1) x else acc - 1\n            }\n        }\n        result.reverse.toList",
  "        numbers.foldLeft(List[Long]()){\n            (acc, val) =>\n          \
    \      if (acc.contains(val)) {\n                    acc :+ val\n            \
    \    } else {\n                    acc\n                }\n        }", "     \
    \   val result = numbers.distinct.toList\n        result.sortBy(-_) //sort in\
    \ descending order\n        result", "        val res = new mutable.HashSet[Long]()\n\
    \        for (i <- numbers) {\n            if (!res.contains(i))\n           \
    \     res += i\n        }\n        res.toList", "        // Use HashSet for fast\
    \ lookup\n        val set = new mutable.HashSet[Long]\n        val output: List[Long]\
    \ = numbers.toList\n        for (i <- numbers) {\n            if (set.contains(i))\
    \ {\n                output.remove(i)\n            } else {\n                set\
    \ += i\n            }\n        }\n        return output", "        val result:\
    \ List[Long] = numbers filterNot (_ == numbers.toSet.toSeq.head) filterNot (_\
    \ == numbers.toSeq.head)\n        result.sortWith(_.compareTo(_) == 0)", "   \
    \     // Create a map of duplicate numbers and filter them out\n        val duplicateNumbers\
    \ = numbers.groupBy(x => x).filter(_._2 > 1).map(_._1)\n        // Remove any\
    \ duplicates\n        numbers - duplicateNumbers", "        // use set to remove\
    \ duplicate elements\n        val result = new mutable.HashSet[Long]()\n     \
    \   // for each number in input, if that number is not in set add it else do nothing\n\
    \        numbers foreach { number =>\n            if (!result.contains(number))\
    \ {\n                result add number\n            }\n        }\n        result\
    \ toList", '        numbers.distinct', "        // Create a set for numbers seen\
    \ so far, also a map of counts for each number seen\n        var seen : scala.collection.mutable.Set[Long]\
    \ = scala.collection.mutable.Set[Long]()\n        var counts : Map[Long, Int]\
    \ = scala.collection.mutable.Map[Long, Int]()\n\n        // Remove numbers that\
    \ have already been seen\n        numbers foreach { number =>\n            val\
    \ count = counts.getOrElse(number, 0)\n            counts = counts.updated(number,\
    \ count + 1)\n            if (count > 1)\n                seen = seen + (number)\n\
    \        }\n\n        // Create new list with numbers removed or return old list\n\
    \        numbers filterNot { number => seen.contains(number) }", "        val\
    \ seen = mutable.HashSet[Long]()\n        numbers.filter(x => x != numbers(seen.add(x)))",
  "        val set = mutable.HashSet[Long]()\n        numbers.foldLeft(Set.empty[Long])\
    \ { case (result, number) => set.add(number); result + number }", "        var\
    \ result: List[Long] = Nil\n        var duplicates = 0\n        numbers.foreach\
    \ {number =>\n            if (numbers.contains(number)) {\n                duplicates\
    \ = duplicates + 1\n            } else {\n                if (duplicates == 0)\
    \ {\n                    result = numbers :+ number\n                } else if\
    \ (duplicates > 1) {\n                    result = numbers :+ number\n       \
    \             duplicates = 0\n                } else {\n                    duplicates\
    \ = 0\n                }\n            }\n        }\n        return result", " \
    \       numbers.foldLeft((List[Long](), Set.empty[Long])) { ( (acc, el) =>\n \
    \           if (acc._2.contains(el))\n                (acc._1 :+ el, (acc._2 --\
    \ el))\n            else\n                (acc._1 :+ el, (acc._2 ++ Set(el)))\n\
    \        }._1", "        // Use a map of counts, to keep track of how many times\
    \ each number occurs.\n        val countMap = numbers.foldLeft(new scala.collection.mutable.HashMap[Long,\
    \ Int]()) { case (accMap, num) =>\n            if (accMap.contains(num)) {\n \
    \               accMap.updated(num, accMap(num) + 1)\n            } else {\n \
    \               accMap.updated(num, 1)\n            }\n        }\n\n        //\
    \ Filter numbers where the count is less than 2, and return the keys only\n  \
    \      val uniqueNumbers = countMap.filter(_._2 < 2).keys\n        uniqueNumbers",
  "        if (numbers.isEmpty) {\n            return Nil\n        }\n        val\
    \ res = []\n        val seen = new mutable.HashSet[Long]\n        for (number\
    \ <- numbers) {\n            if (seen.contains(number)) {\n                continue\n\
    \            }\n            seen.add(number)\n            res += number\n    \
    \    }\n        res", "        // Remove duplicates in order, leaving first occurrences\
    \ unchanged:\n        // (1l, 1l, 3l, 3l, 4l)\n        var duplicates : List[Long]\
    \ = Nil\n        numbers.foreach{\n            case x if numbers.contains(x) =>\n\
    \                duplicates = x :: duplicates\n            case x =>\n       \
    \         duplicates = x :: duplicates\n        }\n        numbers.toList", " \
    \       // Create a HashMap to store the count\n        // If key exists, update\
    \ the count\n        // If the key doesn't exist, add the number to the HashMap\n\
    \        // Convert the HashMap values to List\n        val counts = numbers.toList.groupBy(x\
    \ => x).mapValues(_.size)\n        for (count <- 0 until counts.size) {\n    \
    \        if (counts(count) > 1) {\n                counts.remove(count)\n    \
    \        }\n        }\n        counts.values.toList", "        val count = mutable.HashMap[Long,\
    \ Int]()\n        numbers.foreach(x => count(x) += 1)\n        val result = numbers.filter(_\
    \ < (count.values.max))\n        count.values.foreach(x => if(x > 1) result -=\
    \ x)\n        result", "        val nums = new mutable.HashSet[Long]()\n     \
    \   for ((i, _) <- numbers) {\n            if (nums.contains(i)) numbers.remove(new\
    \ Long(i))\n            else nums += i\n        }\n        numbers.toList", " \
    \       // 1. Create set of numbers seen\n        val seen = mutable.Set[Long]()\n\
    \        // 2. Remove elements seen more than once\n        val result = numbers.filterNot(x\
    \ => seen.add(x))\n        // 3. Return to original order\n        result.toList",
  "        val result = numbers.foldLeft(List[Long]()) {\n            (_, number)\
    \ => {\n                if (numbers.contains(number)) {\n                    numbers.remove(number)\n\
    \                }\n                (number :: _)\n            }\n        }\n\
    \        result", "        val seen = mutable.Set[Long]()\n        val result\
    \ = numbers.filter(x => seen.contains(x))\n        seen.clear()\n        result",
  "        val freqs = mutable.HashMap.empty[Long, Int]\n        numbers foreach {\
    \ n =>\n            val f = freqs.getOrElseUpdate(n, 0) + 1\n            freqs\
    \ += n -> (f > 1 ? f : 1)\n        }\n        numbers filter (n => freqs.get(n)\
    \ > 1)", "        var result = List(numbers(0)); //The first element does not\
    \ count\n        var unique = ListBuffer[Long]()\n\n        for (i <- 1 to numbers.size\
    \ - 1) {\n            val element = numbers(i)\n            if (unique(element)\
    \ != element) {\n                unique += element\n                result +=\
    \ List(element)\n            }\n        }\n        result", "        val uniqueList\
    \ = mutable.Set[Long]()\n        numbers.foreach { x => uniqueList += x }\n  \
    \      val result = numbers.filter(_ != uniqueList.last)\n        result", " \
    \       val setNumbers = numbers.groupBy(_ % 100).toList\n        val setDuplicates\
    \ = setNumbers.map(_._2).toSet\n        val nums = setNumbers.filterNot(setDuplicates).toList\n\
    \        setNumbers.filterNot(setDuplicates).map(_._1)", "        var result =\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { x =>\n            result.add(x)\n\
    \        }\n        result.toList", "        var nums: List[Long] = numbers\n\
    \        for ((n, i) => i >= nums.length) nums = List(n)\n        nums.tail.sliding(2).map(_.toList)\n\
    \            .filter { x => x.count(_ == x.head) > 1 }\n            .map { x =>\
    \ x.head + x.last.asInstanceOf[Long] }", "        var removed = Set[Long]()\n\
    \        var toRet = List[Long]()\n        for (num <- numbers) {\n          \
    \  if (!removed.contains(num)) {\n                toRet = toRet:+ num\n      \
    \          removed += num\n            }\n        }\n        toRet", "       \
    \ var list = mutable.ListBuffer.empty[Long]\n        numbers.foreach {n => list\
    \ += n}\n        val res = numbers.filter { n => list.contains(n) == false }\n\
    \        res", "        val resultList = new mutable.MutableList[Long]()\n   \
    \     var numbersList = numbers.toList\n        var currentNumber = 0\n      \
    \  while (numbersList.length > 0) {\n            var currentNumber = numbersList(numbersList.length-1)\n\
    \            if (resultList.contains(currentNumber)) {\n                numbersList.remove(currentNumber)\n\
    \            } else {\n                resultList += currentNumber\n         \
    \   }\n        }\n        return resultList", '        numbers.groupBy(i => i).filter(_._2.length
    == 1).map(_._1)', "        var result = numbers.clone\n        for (i <- 0 until\
    \ result.length) \n            if (result.exists(_ == result(i))) result.filterNot(_\
    \ == result(i))\n        else result", "        val m1 = mutable.Map[Long, Boolean]()\n\
    \        val m2 = mutable.Map[Long, Boolean]()\n        numbers.foreach(x => {\n\
    \            if (!m1.contains(x)) {\n                m1.put(x , true)\n      \
    \      } else {\n                m1.get(x) match {\n                    case true\
    \ => m2.put(x, true)\n                    case _ => m2.put(x, false)\n       \
    \         }\n            }\n        })\n        m2.values.toList.sortWith(_ <\
    \ _)", "        // Find the next index to remove and record its value\n      \
    \  var nextIndex = 0\n        var nextValue = numbers(nextIndex)\n        // Remove\
    \ next index until we hit one that has not been removed yet\n        while (nextIndex\
    \ < numbers.length) {\n            while (nextIndex < numbers.length && numbers(nextIndex)\
    \ == nextValue) {\n                nextIndex += 1\n            }\n           \
    \ numbers(nextIndex) = numbers(nextIndex + 1)\n            nextIndex += 1\n  \
    \          nextValue = numbers(nextIndex)\n        }\n        numbers", "    \
    \    val map  = mutable.Map[Long,Int]()\n        val result = mutable.List[Long]()\n\
    \        for(i <- numbers) {\n            if(!map.contains(i)) {\n           \
    \     result += i\n                map(i) = 1 // keep track of occurences\n  \
    \          } else {\n                map(i) = map(i) + 1\n            }\n    \
    \    }\n        result.toList", "        var i = 0\n        var j = numbers.size\
    \ -1\n        var output = new ListBuffer[Long]()\n        while (i < j) { \n\
    \            if (numbers(i) == numbers(j)) {\n                i += 1\n       \
    \         j += 1\n            }\n            else {\n                output.+=(numbers(i))\n\
    \                i += 1\n                j -= 1\n            }\n        }\n  \
    \      output.+=(numbers(i))\n        return output.toList", "        val seen\
    \ = new mutable.HashSet[Long]()\n        numbers.filterNot(_._2 in seen)", " \
    \       var result: List[Long] = Nil\n        for (x <- numbers ) {\n        \
    \    if(numbers.contains(x)) {\n                numbers.remove(x)\n          \
    \  } else {\n                result += List(x)\n            }\n        }\n   \
    \     return result", "        val groups = numbers.groupBy(x => x)\n        val\
    \ result = groups.filter(_._2.size < 2).map {\n            x => x._1 }\n     \
    \   return result", "        val set = mutable.HashSet[Long]()\n        numbers.foreach{\
    \ n =>\n            if (set.add(n)) numbers else n :: numbers \n        }\n  \
    \      numbers.reverse", "        // Map from previous number to current number.\n\
    \        val counts = numbers.foldLeft(Map.empty[Long, Long]) { case (acc, x)\
    \ => \n            // Increment count for current number\n            val count\
    \ = acc.getOrElse(x, 0) + 1\n\n            // Increment count for previous number\n\
    \            acc + (x -> (acc.getOrElse(x, 0) + count))\n        }\n\n       \
    \ // Filter out numbers that occur more than once\n        numbers.filterNot(numbers.contains(_))",
  "      numbers.groupBy(identity).collect {\n        case (key, value) => key ::\
    \ value.toList\n      }.toList", "        numbers.foldLeft(List.empty[Long])((result,\
    \ current) => {\n            if(result.contains(current)){\n                result\
    \ :+ current\n            }else{\n                result :+ current\n        \
    \    }\n        })", "        numbers.groupBy(identity).collect {\n          \
    \  case (number, numberList) => number :: numberList\n        }.flatten", "  \
    \    val set = numbers.toSet\n      val newList = numbers.filter(_ <> set.remove(_))\n\
    \      newList.sorted", "        val nums = numbers.toSet\n        val ans = nums.filter(_\
    \ > 1)\n        nums.filter(!_ > 1)", "        val mapVals = numbers.groupBy(x\
    \ => x)\n        val result = numbers.filter(_ != maps.values.head._1)\n     \
    \   result", "        val map1 = numbers.groupBy(identity).map(e => (e._1, e._2.size)).toMap\n\
    \        val map2 = map1.filter(_._2 > 1).map(_._1).toSet\n        map2.map(e\
    \ => numbers.filter(_ == e).length)", "        val map = numbers.groupBy(x =>\
    \ x)\n        val results = map.values.flatMap { values =>\n            val count\
    \ = values.size\n            if (count == 1) values else values :: List().distinct\n\
    \        }\n        results", "        val map = collection.mutable.HashMap.empty[Long,\
    \ Boolean]\n        for (i <- numbers) {\n            map += i -> map.getOrElse(i,\
    \ false)\n        }\n        map map { case (k, v) => k }.toList", "        val\
    \ count = mutable.Map[Long,Int]()\n        val result = mutable.ListBuffer[Long]()\n\
    \        for (i <- numbers) {\n            count+=i\n        }\n        numbers.foreach\
    \ {\n            case x if count.contains(x) =>\n                count -= 1\n\
    \            case x =>\n                result += x\n        }\n        result.toList",
  "        val numSet = mutable.Set[Long]()\n        numbers.foreach(num => numSet\
    \ += num)\n        val res = (0 to numbers.size - 1).filter { i => !numSet.contains(numbers(i))\
    \ }.toList\n        res.sortBy(_ - numbers(0))", '        numbers.groupBy(x =>
    x).values.flatMap(x => x.toList)', "        val counts : Map[Long, Int] = numbers.groupBy(_._2).mapValues(_.size)\n\
    \        val newList : List[Long] = counts.keys.toList.sortBy(-_.toLong).reverse.map(number\
    \ => numbers(number)).filter(_._2 > 1).map(x => x._1)\n        newList", "   \
    \     var nums = numbers groupBy (_ % 2l) mapValues (_.length)\n        var rem\
    \ = numbers filterNot (num => nums.contains(num)) map (_.toLong)\n        (rem.reverse\
    \ ++ nums.filterNot (_ => rem contains _))", "        val seen = mutable.HashSet[Long]()\n\
    \        val answer = numbers.filter(n => n != seen)\n        val leftovers =\
    \ numbers.filterNot(n => n in seen)\n        seen.clear()\n        answer ++ leftovers",
  "        numbers.foldLeft(List[Long]())((acc, element) => {\n            if (acc.contains(element))\
    \ {\n                acc.remove(element)\n            } else {\n             \
    \   acc :+ element\n            }\n        })", "        val seen = mutable.Set.empty[Long]\n\
    \        numbers.filter { n =>\n            if (seen.contains(n)) false else seen+=n\n\
    \        }", "        val seen = mutable.HashSet[Long]()\n        numbers.foreach\
    \ { number =>\n            if(seen.contains(number)) {\n                numbers.remove(number)\n\
    \            }\n            else {\n                seen.add(number)\n       \
    \     }\n        }\n        numbers", "        val nums = mutable.ListBuffer(numbers)\n\
    \        var i = 0\n        while (i < nums.size) {\n            if (nums(i) !=\
    \ nums(i + 1)) {\n                nums(i) = nums(i + 1)\n                i +=\
    \ 1\n            }\n            else {\n                i += 1\n            }\n\
    \        }\n        List(nums.toList)", "        var nums :List[Long] = Nil\n\
    \        var numSet = new mutable.HashSet[Long]\n        for (i <- numbers) {\n\
    \            if (numSet.contains(i)) {\n                nums = nums.filterNot(_\
    \ == i)\n            } else {\n                nums = nums :+ i\n            \
    \    numSet = numSet :+ i\n            }\n        }\n        nums", "        val\
    \ seen = new mutable.HashSet[Long]()\n        numbers.toList.foldLeft(List[Long]())((list,\
    \ current) => {\n            if (seen.contains(current)) {\n                list.::(current)\n\
    \            } else {\n                seen += current\n                list\n\
    \            }\n        })", "        var result = new mutable.ArrayBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            if (result.contains(number))\
    \ {\n                result -= number\n            } else {\n                result\
    \ += number\n            }\n        }\n        result.toList", "        val hashMap\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\n           \
    \ number =>\n                if (hashMap.contains(number))\n                 \
    \   hashMap.put(number, hashMap.get(number) + 1)\n                else {\n   \
    \                 hashMap.put(number, 1)\n                }\n        }\n     \
    \   val result: List[Long] = numbers.filter { number =>\n            if (hashMap.contains(number))\n\
    \                hashMap.get(number) == 1\n            else\n                false\n\
    \        }\n        result", "        val seenNumbers = mutable.Set[Long]()\n\
    \        numbers.filter(x => seenNumbers.contains(x))", "        val counts =\
    \ numbers.groupBy(_)\n            .mapValues(_.size)\n            .toList\n  \
    \      val toRemove = counts.filter(_._2 > 1)\n        numbers.filter(num => !toRemove.contains(num))",
  "        // Convert to a set which removes duplicates.\n        val set = numbers.toSet\n\
    \n        // Convert the set back to a list for returning.\n        val list =\
    \ set.toList\n\n        // Return the list with duplicates removed.\n        list",
  "        val seen = mutable.HashSet[Long]()\n        numbers.foreach { number =>\n\
    \            if (seen.contains(number)) {\n                numbers.remove(number)\n\
    \            }\n            else {\n                seen += number\n         \
    \   }\n        }\n        numbers", "      numbers.groupBy(_.toInt).mapValues(_.size)\n\
    \              .filter(x => x._2 > 1)\n              .map{ case (k, v) => k ->\
    \ v}\n              .keys", "        var result : List[Long] = Nil\n        var\
    \ lastNumber : Option[Long] = Some(numbers.head)\n        numbers match {\n  \
    \          case Nil => result\n            case head :: tail => {\n          \
    \      if (lastNumber.isDefined && head == lastNumber + 1) {\n               \
    \     lastNumber = Some(head)\n                } else if (lastNumber.isDefined\
    \ && head == lastNumber + 2) {\n                    lastNumber = Some(head)\n\
    \                } else {\n                    lastNumber = None\n           \
    \     }\n                result :+ head\n                removeDuplicates(tail)\n\
    \            }\n        }\n        result", "        var lastElem = -1\n     \
    \   var lastNum = -1\n        var result : List[Long] = List()\n        for(n\
    \ <- numbers){\n            if(lastNum != -1){\n                if(lastNum ==\
    \ n){\n                    lastElem = -1\n                }\n                else\
    \ if(lastNum != n){\n                    result = result :+ lastElem\n       \
    \             lastElem = -1\n                    lastNum = n\n               \
    \ }\n            }else{\n                lastElem = n\n                lastNum\
    \ = n\n            }\n        }\n        if(lastNum != -1){\n            result\
    \ = result :+ lastElem\n        }\n        return result", "        val result\
    \ = new ListBuffer[Long]()\n        var lastValue = scala.math.Ordering.Long.MaxValue\n\
    \        numbers.foreach{ x =>\n            if (x == lastValue) {\n          \
    \      x += 1\n            }\n            else {\n                lastValue =\
    \ x\n            }\n            result += x\n        }\n        result.toList",
  "        val uniques = HashSet[Long]()\n        val result = new mutable.ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (uniques.contains(number))\
    \ {\n            } else {\n                uniques.add(number)\n             \
    \   result += number\n            }\n        }\n        result.toList", "    \
    \    var uniques : Set[Long] = Set.empty\n        for (num <- numbers) {\n   \
    \         if (uniques.contains(num)) continue\n            uniques += num\n  \
    \      }\n        numbers.toList", "        if (numbers.isEmpty) return List()\n\
    \        val map = new mutable.HashMap[Long, Int]()\n        numbers.foreach{\
    \ number =>\n            val count = map.getOrElse(number, 0)\n            map\
    \ += number -> count + 1\n        }\n        val uniques = map.toSeq.filter(_._2\
    \ > 1)\n        uniques.map(_.key).sorted", "        val unique = numbers.groupBy(identity).map(x\
    \ => (x._1, x._2.length)).toMap\n        val result: List[Long] = numbers.filter(_._2.length\
    \ == unique.getOrElse(_, 0)).map(_._1)\n        result", "        var result :\
    \ List[Long] = numbers.toList\n        var count : Int = 0\n        var lastElem\
    \ : Long = 0\n        while(result.nonEmpty) {\n            count += 1\n     \
    \       if(result.exists(_ == lastElem)) {\n                result.remove(lastElem)\n\
    \            } else {\n                lastElem = result(0)\n                result\
    \ = result.drop(1)\n            }\n        }\n        if(count < result.length)\
    \ {\n            result ++= result.take(count).reverse\n        }\n        return\
    \ result", "        val counts = mutable.HashMap[Long, Long]()\n        numbers.foreach\
    \ {\n            _ <- counts += _\n        }\n        numbers.filter { _ =>\n\
    \            counts.get(_) match {\n                case None => true\n      \
    \          case Some(n) => n > 1\n            }\n        }", "      numbers.foldLeft(List(numbers.head))\
    \ { (result: List[Long], elem: Long) => \n        if(!result.contains(elem)) {\n\
    \          result += elem\n        }\n        result\n      }", "        var result\
    \ = List[Long]()\n        numbers.foreach { n =>\n            if (!result.contains(n))\
    \ {\n                result += n\n            }\n        }\n        return result",
  "        var lastNumber = 0\n        var duplicateNumbers = List[Long]()\n     \
    \   var nextNumber = 0\n        var duplicateCount = 1\n        for (number <-\
    \ numbers) {\n            if (number == nextNumber) {\n                duplicateCount\
    \ += 1\n                if (duplicateCount == 2) {\n                    duplicateNumbers\
    \ += lastNumber\n                }\n            } else {\n                lastNumber\
    \ = nextNumber\n                duplicateCount = 1\n                nextNumber\
    \ = number\n            }\n        }\n        return duplicateNumbers", '        numbers.distinct',
  "        def removeDuplicatesHelper(currentNums: List[Long], acc: List[Long]) :\
    \ List[Long] = currentNums match {\n            case Nil => acc\n            case\
    \ h :: t => {\n                val h = h.toLong\n                if(currentNums.contains(h))\
    \ {\n                    removeDuplicatesHelper(t, h :: acc)\n               \
    \ } else {\n                    removeDuplicatesHelper(t, acc)\n             \
    \   }\n            }\n        }\n\n        val result = removeDuplicatesHelper(numbers,\
    \ Nil)\n        numbers.zip(result).toList", "        val seen = new mutable.HashSet[Long]()\n\
    \        numbers.foreach { n =>\n            if (seen.contains(n)) numbers.remove(n)\n\
    \            else {\n                seen += n\n            }\n        }\n   \
    \     numbers", '        numbers.foldLeft(List[Long]())(_ diff ++ _)', "     \
    \   val set = new mutable.HashSet[Long]()\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set.add(number)\n \
    \           }\n        }\n        set.iterator.map( _ => numbers.remove(_)).toList",
  "        var result = new scala.collection.mutable.ArrayBuffer[Long]()\n       \
    \ numbers.foreach(number => {\n            if (numbers.contains(number)) {\n \
    \               result += number\n            }\n        })\n        result toList",
  "      var tempList = mutable.LinkedHashSet[Long]()\n      var result = mutable.LinkedHashSet[Long]()\n\
    \      numbers.foreach(elem => if(!tempList.contains(elem)) tempList += elem)\n\
    \      numbers.foreach(elem => if(!result.contains(elem)) result += elem)\n  \
    \    return (tempList.toList ++ result.toList).sortBy(_.toLong).toList // Order\
    \ from left to right is same as the input", "        var result = List[Long]()\n\
    \        var seen = mutable.HashSet[Long]()\n        numbers.foreach { n =>\n\
    \            if (!seen(n)) {\n                result += n\n                seen\
    \ += n\n            }\n        }\n        result", "        def removeDupes(num\
    \ : Long, list : List[Long]) = num match {\n            case 1 => list\n     \
    \       case 2 :: rest => removeDupes(rest, list.filter(_ != 2))\n           \
    \ case x :: rest => if (list.contains(x)) removeDupes(rest, list.filter(_ != x))\n\
    \            else removeDupes(rest, list.filter(_ != 2))\n        }\n        removeDupes(numbers(0),\
    \ numbers.drop(1))", "        var result : List[Long] = List.empty\n        val\
    \ seen = mutable.Set.empty[Long]\n        numbers.foreach(x => {\n           \
    \ if (seen.contains(x)) return\n            result ::= x\n            seen.add(x)\n\
    \        })\n        result", "        numbers.groupBy(x => x).mapValues(_.length)\n\
    \            .toList", "        val res = numberList.foldLeft(List[Long]())(\n\
    \            (res, curr)=>{\n                if(numbers.contains(curr)) res :+\
    \ curr\n                else {\n                    val nextNums = numbers.filter\
    \ { n => n != curr}\n                    res :+ curr\n                    nextNums\n\
    \                }\n            }\n        )\n        numbers", "        numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            if (numbers.contains(elem))\n                acc else\
    \ \n                acc :+ elem\n        })", "        val hashMap = new collection.mutable.HashMap[Long,\
    \ Int]\n        var output = new List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val value = numbers(i)\n            if (!hashMap.contains(value))\
    \ {\n                hashMap += value -> 1\n                output.append(value)\n\
    \            } else {\n                hashMap.remove(value)\n            }\n\
    \        }\n        return output", "        val seen = new mutable.HashSet[Long]()\n\
    \        val result = new mutable.ListBuffer[Long]()\n        for (i <- numbers\
    \ ) {\n            if (seen.contains(i)) continue // skip duplicates\n       \
    \     seen.add (i)\n            result += i\n        }\n        return result.toList",
  '        numbers.foldRight(List[Long]())((list, number) => number :: list)', '        numbers.foldLeft(List[Long]())(_
    :+ (_._2)).filter(_._1 < _._1).map(n => n.toLong)', '        numbers.filter(x
    => numbers.count(_ == x) > 1)', '        numbers.toList.distinct', "        val\
    \ set: mutable.Set[Long] = mutable.Set[Long]()\n        numbers.foreach{ n =>\
    \ set.add(n) }\n        numbers filterNot set.contains", "        var result =\
    \ new ListBuffer[Long]()\n        var count = 0\n        for(n <- numbers) {\n\
    \            if(!result.contains(n)) {\n                result += n\n        \
    \        count += 1\n            }\n        }\n        result += (count * count).toLong\n\
    \        return result.toList", "        val freq = new mutable.HashMap[Long,\
    \ Long]\n        for (n <- numbers)\n            if (freq.contains(n))\n     \
    \           freq(n) += 1\n            else\n                freq(n) = n\n    \
    \    numbers.filter(_ => freq(_) > 1)", "        val uniques = new mutable.HashSet[Long]\n\
    \        for (x <- numbers) {\n            if (!uniques.contains(x)) {\n     \
    \           uniques += x\n            }\n        }\n        numbers.toList.filter(_\
    \ != 0L)", "        val seen = mutable.Set.empty[Long]\n        val toReturn =\
    \ numbers.filterNot(n => seen.contains(n))\n        seen ++= toReturn\n      \
    \  toReturn", "        val countMap : mutable.Map[Long, Int] = mutable.HashMap.empty[Long,\
    \ Int]\n        var output: List[Long] = List()\n        for( n <- numbers)\n\
    \            if (countMap.contains(n))\n                countMap(n) += 1\n   \
    \         else {\n                countMap(n) = numbers.size\n               \
    \ output = n::output\n            }\n        output"]
stop_tokens:
- "\n    }\n"
