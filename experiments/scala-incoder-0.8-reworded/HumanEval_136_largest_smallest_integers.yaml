name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        val minusCount = lst.count(x => x < 0l)\n        val plusCount\
    \ = lst.count(x => x > 0l)\n        val min = lst.min\n        val max = lst.max\n\
    \        if(minusCount > plusCount){\n            return (Some(min), Some(max))\n\
    \        }\n        else if(minusCount < plusCount){\n            return (Some(max),\
    \ Some(min))\n        }\n        else\n            return (Nil, Nil)", "     \
    \   val negatives = lst.filter(l => l.toLong < 0)\n        val positives = lst.filter(l\
    \ => l.toLong > 0)\n        negatives.reverse.takeWhile(l => positives.isEmpty)\n\
    \            .filter(l => l > positives.min).lastOption\n            .reverse.map(l\
    \ => l.toLong)\n            .find(positives.isDefined) match {\n            case\
    \ Some(positive) => positive\n            case None => None\n            }", " \
    \       // Create a Set with the integers in the list.\n        var numbers =\
    \ Set(lst: _*)\n        \n        // If there are no negative integers, return\
    \ an empty Tuple2.\n        if (numbers.forall(n => n < 0l.toLong)) \n       \
    \     (None, None)\n        \n        // Else, add all the negative integers to\
    \ the Set.\n        else {\n            numbers = numbers.filterNot(n => n < 0l.toLong)\n\
    \        }\n        \n        // If there are no positive integers, return an\
    \ empty Tuple2.\n        if (numbers.forall(n => n > 0l.toLong)) \n          \
    \  (None, None)\n        \n        // Else, add all the positive integers to the\
    \ Set.\n        else {\n            numbers = numbers.filterNot(n => n > 0l.toLong)\n\
    \        }\n        \n        // Sort the Set of integers\n        val numbersSorted\
    \ = numbers.toSorted\n        \n        // Find the first integer that is negative,\
    \ and the first integer that is positive.\n        val firstNegativeNumber = numbersSorted.find(n\
    \ => n < 0l.toLong)\n        val firstPositiveNumber = numbersSorted.find(n =>\
    \ n > 0l.toLong)\n        \n        // Return the smallest negative integer, and\
    \ smallest positive integer\n        // if the positive integer is larger than\
    \ the negative integer, or \n        // the negative integer is larger than the\
    \ positive integer, \n        // respectively.\n        if (firstPositiveNumber\
    \ > firstNegativeNumber)\n            (Some(firstNegativeNumber), Some(firstPositiveNumber))\n\
    \        else\n            (Some(firstPositiveNumber), Some(firstNegativeNumber))",
  "        val ints = lst.filter(i => i < 0l || i > 0l)\n        if (ints.isEmpty)\
    \ None\n        else Some(ints.min), Some(ints.max)", "        val negInts = lst.filter(x\
    \ => x < 0l)\n        val posInts = lst.filter(x => x > 0l)\n        negInts.reduceLeft((a,\
    \ b) => Option(a).getOrElse(Option(b).getOrElse(None)))", "        var result\
    \ = Option[Long]()\n        var temp1 = Option[Long]()\n        var temp2 = Option[Long]()\n\
    \        for(i <- 0 until lst.length) {\n            temp1 = Option[Long](if(lst(i)\
    \ < 0) Option(-lst(i)) else lst(i))\n            temp2 = Option[Long](if(lst(i)\
    \ > 0) Option(lst(i)) else -lst(i))\n            if(temp1.isEmpty && temp2.isDefined)\
    \ result = temp2\n            else if(temp2.isEmpty && temp1.isDefined) result\
    \ = temp1\n            else result = Some(Math.max(result.get, Math.min(-result.get,\
    \ temp1.get)))\n        }\n        result.filter(_ != None).map {\n          \
    \  case Some(number) => Tuple2(Some(number), Some(-number))\n            case\
    \ _ => Tuple2(Some(None), Some(None))\n        }", "        var positive: List[Long]\
    \ = Nil\n        var negative: List[Long] = Nil\n        lst.foreach(i => if (i\
    \ < 0) negative += i else positive += i)\n\n        var positiveMin = positive.min\n\
    \        var positiveMax = positive.max\n        var negativeMin = negative.min\n\
    \        var negativeMax = negative.max\n        if (positiveMin < 0L) positiveMin\
    \ = None\n        if (positiveMax > 0L) positiveMax = None\n        if (negativeMin\
    \ < 0L) negativeMin = None\n        if (negativeMax > 0L) negativeMax = None\n\
    \n        val tuple = positiveMin min negativeMin max positiveMax max negativeMax\n\
    \        if (tuple == None) tuple else tuple._1.asInstanceOf[Tuple2[Option[Long],\
    \ Option[Long]]]", "        def loop(lst : List[Long], min: Long, max: Long) :\
    \ Tuple2[Option[Long], Option[Long]] = \n            lst match {\n           \
    \     case Nil => (None, None)\n                case head :: tail =>\n       \
    \             if (head < min && head > max) loop(lst, head, head)\n          \
    \          else if (head > min) loop(lst, head, max)\n                    else\
    \ loop(lst, min, head)\n            }\n        loop(lst, Long.MinValue, Long.MaxValue)",
  "        if(lst.nonEmpty) {\n            var maxPositive = lst(0)\n            var\
    \ minNegative = lst(0)\n            for(i<-lst.indices) {\n                if(lst(i)\
    \ < 0) {\n                    minNegative = lst(i)\n                } else if(lst(i)\
    \ > 0) {\n                    maxPositive = lst(i)\n                }\n      \
    \      }\n            (Option(maxPositive), Option(minNegative))\n        } else\
    \ {\n            (None, None)\n        }", "        val negNums = lst.filter(x\
    \ => x < 0l)\n        val posNums = lst.filter(x => x > 0l)\n        if(negNums.isEmpty)\
    \ {\n            (Some(None), Some(None))\n        } else if(posNums.isEmpty)\
    \ {\n            (Some(None), (negNums.min))\n        } else {\n            (Some(negNums.max),\
    \ Some(posNums.min))\n        }", "        val smallest = lst.minBy(_.toInt)\n\
    \        val largest = lst.maxBy(_.toInt)\n        if (smallest < 0 || largest\
    \ > 0) {\n            Some((Some(largest), Some(smallest)))\n        }\n     \
    \   else {\n            None\n        }", "        var maxOption: Option[Long]\
    \ = None\n        var minOption: Option[Long] = None\n        var max = None\n\
    \        var min = None\n        for(i <- lst) {\n            if(i < 0) {\n  \
    \              if (maxOption.isEmpty) {\n                    maxOption = Some(i)\n\
    \                } else if (max.isLessThan(i - 1l)) {\n                    max\
    \ = Some(i)\n                }\n            } else {\n                if (minOption.isEmpty)\
    \ {\n                    minOption = Some(i)\n                } else if (min.isLessThan(i\
    \ + 0l)) {\n                    min = Some(i)\n                }\n           \
    \ }\n        }\n        (maxOption, minOption)", "        lst.foldRight(\n   \
    \         ((Option(Long.MaxValue), Option(Long.MinValue)): Option[(Long, Long)]),\n\
    \            (a, b) => a match {\n                case (Some(a1), Some(b1)) if\
    \ a1 < b1 => (Some(a1), Some(b1))\n                case (Some(a1), Some(b1)) if\
    \ a1 > b1 => (Some(b1), Some(a1))\n                case _ => (a, b)\n        \
    \    }\n        )", "        def getMax(lst : List[Long], max : Long) : Long =\
    \ {\n            max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max ", "        val sortedList = lst.sortBy(math.abs)\n    \
    \    var largest = sortedList.head\n        var smallest = sortedList.last\n \
    \       sortedList.foreach { x =>\n            if (x < 0) {\n                if\
    \ (largest < x) {\n                    largest = x\n                }\n      \
    \      } else {\n                if (smallest > x) {\n                    smallest\
    \ = x\n                }\n            }\n        }\n        (Option(largest),\
    \ Option(smallest))", "        def largest(n : Long) : Option[Long] = {\n    \
    \        if (n <= 0l) None\n            else Some(n)\n        }\n        def smallest(n\
    \ : Long) : Option[Long] = {\n            if (n >= 0l) None\n            else\
    \ Some(n)\n        }\n        def compare(a: Long, b: Long) : Int = {\n      \
    \      if (a < b) -1\n            else if (a > b) 1\n            else 0\n    \
    \    }\n        val sorted = lst.sorted(compare)\n        (largest(sorted.head),\
    \ smallest(sorted.last))", "        def largest(v : Long) : Option[Long] = {\n\
    \            if (v > 0l) {\n                return Some(v)\n            }\n  \
    \          else None\n        }\n        def smallest(v : Long) : Option[Long]\
    \ = {\n            if (v < 0l) {\n                return Some(v)\n           \
    \ }\n            else None\n        }\n        val lists = lst.map(_ => largest(_).map(_\
    \ -> _))\n        val negLists = lists.filter(_.exists(_.isEmpty))\n        val\
    \ posLists = lists.filter(_.exists(!_.isEmpty))\n        if (negLists.isEmpty)\
    \ {\n            return (None, None)\n        } else if (posLists.isEmpty) {\n\
    \            return (None, negLists.headOption)\n        } else if (negLists.size\
    \ > posLists.size) {\n            return (negLists.headOption, None)\n       \
    \ } else if (negLists.size < posLists.size) {\n            return (posLists.headOption,\
    \ None)\n        } else {\n            val list = negLists.head.map(_._1).reduce(_.max)\n\
    \            val other = negLists.map(_.headOption).find(_.isEmpty).getOrElse(posLists.headOption)\n\
    \            return (list, other)\n        }", "        val negInts = lst.filter(x\
    \ => x < 0)\n        val posInts = lst.filter(x => x > 0)\n\n        val negativeMax\
    \ = negInts.maxBy(_.toLong)\n        val positiveMin = posInts.minBy(_.toLong)\n\
    \n        if(negativeMax.isEmpty && positiveMin.isEmpty) return (None, None)\n\
    \        if(negativeMax.isEmpty) return (Some(negativeMax), None)\n        if(positiveMin.isEmpty)\
    \ return (Some(positiveMin), None)\n        return (Some(negativeMax), Some(positiveMin))",
  "      lst.foldLeft((Some(None.asInstanceOf[Long]), Some(None.asInstanceOf[Long])))\
    \ {\n        (pair: (Option[Long], Option[Long]), x: Long) => {\n          val\
    \ negI = if (x < 0l) None\n          else if (x < 0l && pair._2.isDefined) Some(pair._2)\n\
    \          else if (pair._1.isDefined) Some(pair._1)\n          else None\n  \
    \        val posI = if (x >= 0l) None\n          else if (x >= 0l && pair._2.isDefined)\
    \ Some(pair._2)\n          else if (pair._1.isDefined) Some(pair._1)\n       \
    \   else None\n          if (negI.nonEmpty && posI.nonEmpty)\n            pair\n\
    \          else if (negI.nonEmpty)\n            pair._1.map(_ => negI.get)\n \
    \         else if (posI.nonEmpty)\n            pair._2.map(_ => posI.get)\n  \
    \        else\n            (pair._1, pair._2)\n        }\n      }", "        lst.sortWith(_.signum\
    \ < 0).reduceRight(_ match {\n            case (a, b) => if (a > b) (a, None)\
    \ else (None, b)\n        }).map(_._1)", "        def isNegative(i: Long): Boolean\
    \ = i >= 0\n        def isPositive(i: Long): Boolean = i < 0\n        val minusList:\
    \ mutable.Buffer[Long] = mutable.Buffer.empty\n        val plusList: mutable.Buffer[Long]\
    \ = mutable.Buffer.empty\n        for(i <- lst) {\n            if(isNegative(i))\
    \ {\n                minusList += i\n            }\n            if(isPositive(i))\
    \ {\n                plusList += i\n            }\n        }\n        val minus:\
    \ Option[Long] = minusList.isEmpty match {\n            case true => None\n  \
    \          case false => Some(minusList.max)\n        }\n        val plus: Option[Long]\
    \ = plusList.isEmpty match {\n            case true => None\n            case\
    \ false => Some(plusList.min)\n        }\n        (minus, plus)", "        val\
    \ a = lst.foldLeft(Option.empty[Long], Option.empty[Long]){\n            case\
    \ (acc, elem) =>\n                val b = (elem - acc._2).getOrElse(0)\n     \
    \           val c = acc._1 + (b > 0)\n                (Some(c), Some(b))\n   \
    \     }\n        (a._1, a._2)", "        if(lst.size < 2)\n            return\
    \ ( Some(None), Some(None))\n        if(lst.size == 0)\n            return ( Some(None),\
    \ Some(None))\n        val l = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        val max: Option[Long] = None\n        val min: Option[Long] = None\n\
    \        for(i <- 0 until lst.size) {\n            l.append(lst(i))\n        \
    \    if(l.last < 0l){\n                max = Some(l.last)\n            }\n   \
    \         if(l.last > 0l){\n                min = Some(l.last)\n            }\n\
    \        }\n        ( max, min)", "        val smallestNegative = None\n     \
    \   val smallestPositive = None\n        for(i <- 0 until lst.size) {\n      \
    \      if(lst(i) < 0) {\n                if(smallestNegative == None) smallestNegative\
    \ = Some(lst(i))\n                else smallestNegative = Some(smallestNegative.getOrElse(lst(i)))\n\
    \            } else {\n                if(smallestPositive == None) smallestPositive\
    \ = Some(lst(i))\n                else smallestPositive = Some(smallestPositive.getOrElse(lst(i)))\n\
    \            }\n        }\n        smallestNegative match {\n            case\
    \ None => (Some(None), smallestPositive)\n            case Some(smallestNegative)\
    \ => smallestPositive\n        }", "        // 1. Find the largest negative number\
    \ in the list.\n        var largestNegativeInt = -math.max(lst.filter(x => x <\
    \ 0).max)\n        // 2. Find the smallest positive number in the list.\n    \
    \    var smallestPositiveInt = math.min(lst.filter(x => x > 0).min)\n        //\
    \ 3. Return tuple (a, b) where b is the smallest positive number\n        // \
    \    in the list and a is the largest negative number in the list.\n        //\
    \ Return them as Option[Long] since we might need to return None if\n        //\
    \ there is no negative or positive numbers.\n        return (Some(largestNegativeInt),\
    \ Some(smallestPositiveInt))", "        val negative = lst.filter(i => i < 0l)\n\
    \        val positive = lst.filter(i => i >= 0l)\n        val min = negative.min\n\
    \        val max = positive.max\n        if(min < max){\n            val smallerNegative\
    \ = negative.filter(i => i < min)\n            val smallerPositive = positive.filter(i\
    \ => i < min)\n            val smallestPositive = smallerPositive.min\n      \
    \      val smallestNegative = smallerNegative.min\n            return (Some(smallestPositive),\
    \ Some(smallestNegative))\n        }else{\n            return (None, None)\n \
    \       }", "        val positive = lst.filter(_.isPositive)\n        val negative\
    \ = lst.filter(_.isNegative)\n        positive.exists(_.max < negative.min) match\
    \ {\n            case true => Some(Some(positive.max), Some(negative.min))\n \
    \           case false => Some(None, None)\n        }", "        val n = lst.head\n\
    \        val maxNegative = Some(math.min.pound(lst: _*))\n        val minPositive\
    \ = Some(math.max.pound(lst: _*))\n        if(maxNegative.isEmpty || minPositive.isEmpty)\
    \ None else (maxNegative, minPositive)", "        val biggest_int = None\n   \
    \     val smallest_int = None\n        lst.for( i => biggest_intOption match {\n\
    \            case None =>\n                smallest_intOption = Some(i)\n    \
    \        case Some(biggest) =>\n                if ( biggest > i)\n          \
    \          biggest_intOption = Some(i)\n                else if ( biggest < smallest_int)\n\
    \                    smallest_intOption = Some(i)\n        })\n        (smallest_intOption,\
    \ biggest_intOption)", "        var largest = lst.max\n        var smallest =\
    \ lst.min\n        lst.reverse.foreach { l =>\n            if (-l.asInstanceOf[Long]\
    \ <= smallest && smallest < l.asInstanceOf[Long]) smallest = l.asInstanceOf[Long]\n\
    \            if (l.asInstanceOf[Long] <= largest && largest < l.asInstanceOf[Long])\
    \ largest = l.asInstanceOf[Long]\n        }\n        if (smallest == Long.MinValue)\
    \ smallest = Option.empty[Long]\n        if (largest == Long.MaxValue) largest\
    \ = Option.empty[Long]\n        (smallest, largest)", "        val minValue =\
    \ lst.min\n        val maxValue = lst.max\n        if (minValue == 0l) {\n   \
    \         (Some(None), Some(None))\n        } else if (maxValue == 0l) {\n   \
    \         (Some(None), None)\n        } else {\n            (Some(maxValue), Some(minValue))\n\
    \        }", "        import scala.math._\n        import scala.collection.mutable.Queue\n\
    \        val q = Queue.empty[Long]\n        for (i <- 0 until lst.size) {\n  \
    \          val x = lst(i)\n            if (x < 0) q.enqueue(x)\n            else\
    \ if (x > 0) {\n                val y = q.dequeue()\n                if (y > x)\
    \ Some(y) else None\n                q.enqueue(x)\n            }\n        }\n\
    \        val b = q.dequeue()\n        if (q.size == 0) (Some(b), None)\n     \
    \   else (Some(b), Some(q.head))", "        val negInts = lst.filter( x => x <\
    \ 0 );\n        val posInts = lst.filter( x => x >= 0 );\n        if (negInts.isEmpty)\
    \ {\n            (None, Some(posInts.min))\n        } else if (posInts.isEmpty)\
    \ {\n            (Some(negInts.max), None)\n        } else {\n            (Some(negInts.max),\
    \ Some(posInts.min))\n        }", "        val l = lst.sorted\n        val isNegative\
    \ = l map (_ < 0l) exists _\n        if (l.isEmpty) None \n        else (Some(l.head),\
    \ if (isNegative) l.head else l.tail.min) ", "        // Initialize max and min\
    \ to None (no negative or positive integers).\n        val max = Option(-lst.min)\n\
    \        val min = Option(-lst.max)\n        // Loop through each item in lst,\
    \ see if it is a negative or positive integer.\n        // If so, update max and\
    \ min accordingly.\n        for (i <- lst) {\n            if (i < 0)\n       \
    \         max = i\n            else if (i > 0)\n                min = i\n    \
    \    }\n        // If max and min are not None, return the tuple (max, min).\n\
    \        (max, min)", "        val listTuple = lst match {\n            case head\
    \ :: tail => {\n                val headInt = head.asInstanceOf[Int]\n       \
    \         val tailInt = tail.filter(_.asInstanceOf[Int]).sortBy(_.asInstanceOf[Int]).head\n\
    \                (Some(headInt), Some(tailInt))\n            }\n            case\
    \ _ => None\n        }\n        listTuple", "        val ints = lst.filter(_ >\
    \ 0l).filter(_ < 0l)\n        val negs = lst.filter(_ < 0l).filter(_ > 0l)\n \
    \       if (ints.isEmpty) {\n            (None, None)\n        } else if (negs.isEmpty)\
    \ {\n            (Some(ints.min.toLong), None)\n        } else {\n           \
    \ (Some(ints.min.toLong), Some(ints.max.toLong))\n        }", "        lst.foldLeft(Option(-1l.toLong),\
    \ Option(1l.toLong))((acc, val) => {\n            val maxValue = acc._2 max val\n\
    \            val minValue = acc._1 min val\n            (maxValue, minValue)\n\
    \        })", "        val negativeValues = lst.filter { _ < 0l }\n        val\
    \ positiveValues = lst.filter { _ > 0l }\n        if(negativeValues.length ==\
    \ 0 || positiveValues.length == 0) {\n            (None, None)\n        } else\
    \ {\n            val positiveMax = positiveValues.max\n            val negativeMin\
    \ = negativeValues.min\n            (Some(positiveMax), Some(negativeMin))\n \
    \       }", "        val (minInt, maxInt) = lst.foldLeft((None[Long], None[Long]))((_,\
    \ (minInt, maxInt)) => {\n            val (a, b) = minInt max maxInt\n       \
    \     (Some(a), Some(b))\n        })\n        (minInt.isDefined || maxInt.isDefined).tupled",
  "        val min = Integer.MIN_VALUE\n        val max = Integer.MAX_VALUE\n    \
    \    lst.foldLeft(Option(Integer.MIN_VALUE), Option(Integer.MAX_VALUE)) { (acc,\
    \ x) => {\n            val minValue = acc.getOrElse(Integer.MIN_VALUE)\n     \
    \       val maxValue = acc.getOrElse(Integer.MAX_VALUE)\n            if (x < min\
    \ && x > max) None\n            else if (x > max) Some(x)\n            else Some(x)\n\
    \        }}", "        val max = lst.foldLeft((-Int.MaxValue, Int.MinValue))((a,\
    \ b) => if (b < 0) a else (b > a._2 ? b : a._2))\n        val min = lst.foldLeft((Int.MaxValue,\
    \ 0))((a, b) => if (b > 0) a else (b < a._2 ? b : a._2))\n        (Some(max._1),\
    \ Some(min._1))", "      lst.sortWith(_ < _)\n      val firstInt = lst.headOption\n\
    \      val secondInt = lst.tail.find(_ > 0).toOption\n      (firstInt, secondInt)",
  "        lst.map{x => if (x < 0) None else Some(x)}\n        .reduce((a, b) => if\
    \ (a.isEmpty) b else a) match {\n            case (a: List[Option[Long]], b: List[Option[Long]])\
    \ =>\n                ((a ++ b).lastOption, a.head)\n            case (a: List[Option[Long]],\
    \ _) =>\n                (a, None)\n            case (_: List[Option[Long]], b:\
    \ List) =>\n                (None, b)\n        }", "        if (lst.isEmpty) \n\
    \            (None, None)\n        else {\n            var max : Option[Long]\
    \ = None\n            var min : Option[Long] = None\n            lst.foreach(\
    \ elem => if(elem > 0){\n                if(max != None)\n                   \
    \ max = Some(elem)\n                else\n                    min = Some(elem)\n\
    \            }\n            else {\n                if(min != None)\n        \
    \            min = Some(elem)\n                else\n                    max =\
    \ Some(elem)\n            }\n            )\n            (max, min)\n        }",
  "        val max = new Long(math.MinPositiveInteger)\n        val min = new Long(math.MaxPositiveInteger)\n\
    \        var res = Some(max)\n        lst.foreach(n => {\n            if (n <\
    \ min) {\n                min = n\n                res = Some(min)\n         \
    \   }\n            if (n > max) {\n                max = n\n                res\
    \ = Some(max)\n            }\n        })\n        res", "        // Solution\n\
    \        // Step 1: First element is the minimum\n        // Step 2: Second element\
    \ is the maximum\n        val minIndex = lst.map((_ < 0).fold(1) { minIndex =>\
    \ minIndex + 1 }).min\n        val maxIndex = lst.map((_ > 0).fold(1) { maxIndex\
    \ => maxIndex + 1 }).max\n        (Some(lst.drop(minIndex).max), Some(lst.take(maxIndex).min))",
  "        def largest(x : Long) : Option[Long] = if (x < 0) Some(x) else None\n \
    \       def smallest(x : Long) : Option[Long] = if (x > 0) Some(x) else None\n\
    \        def largestSmallestIntegersHelper(lst : List[Long], idx : Int) : Tuple2[Option[Long],\
    \ Option[Long]] = {\n            if (lst == Nil) \n                (None, None)\n\
    \            else if (lst.size < idx) {\n                (None, None)\n      \
    \      } else if (idx < lst.size) {\n                (\n                    if\
    \ (largest(lst.head) == Some(None)) largest(lst.head)\n                    else\
    \ smallest(lst.head),\n                    largestSmallestIntegersHelper(lst.tail,\
    \ idx + 1)\n                )\n            } else \n                (\n      \
    \              largestSmallestIntegersHelper(lst.tail, idx + 1),\n           \
    \         if (smallest(lst.head) == Some(None)) smallest(lst.head)\n         \
    \           else largest(lst.head)\n                )\n        }\n        val\
    \ smallestPositiveOption = smallest(lst.head) match {\n            case Some(x)\
    \ => Some(x)\n            case None => None\n        }\n        val largestNegativeOption\
    \ = largest(lst.head) match {\n            case Some(x) => Some(x)\n         \
    \   case None => None\n        }\n        val smallestPositiveOption2 = smallest(lst.head)\
    \ match {\n            case Some(x) => Some(x)\n            case None => None\n\
    \        }\n        val largestPositiveOption3 = largest(lst.head) match {\n \
    \           case Some(x) => Some(x)\n            case None => None\n        }\n\
    \        val smallestPositiveOption4 = smallest(lst.head) match {\n          \
    \  case Some(x) => Some(x)\n            case None => None\n        }\n       \
    \ val largestPositiveOption5 = largest(lst.head) match {\n            case Some(x)\
    \ => Some(x)\n            case None => None\n        }\n        val smallestPositiveOption6\
    \ = smallest(lst.head) match {\n            case Some(x) => Some(x)\n        \
    \    case None => None\n        }\n        val smallestPositiveOption7 = smallest(lst.head)\
    \ match {\n            case Some(x) => Some(x)\n            case None => None\n\
    \        }\n        val largestPositiveOption8 = largest(lst.head) match {\n \
    \           case Some(x) => Some(x)\n            case None => None\n        }\n\
    \        val smallestPositiveOption9 = smallest(lst.head) match {\n          \
    \  case Some(x) => Some(x)\n            case None => None\n        }\n       \
    \ val largestPositiveOption10 = largest(lst.head) match {\n            case Some(x)\
    \ => Some(x)", "        val mn = lst.min\n        val mx = lst.max\n        (if\
    \ (mx < 0) Some(mx) else None), if (mn >= 0) Some(mn) else None", "        val\
    \ minValue = lst.min\n        val maxValue = lst.max\n        val negMinValue\
    \ = lst.filter(_ < minValue).max\n        val negMaxValue = lst.filter(_ > maxValue).min\n\
    \        if(negMaxValue == negMinValue){\n            (None, None)\n        }else{\n\
    \            (Some(negMaxValue), Some(negMinValue))\n        }", "        val\
    \ negatives = lst.filter(n => n < 0)\n        val positives = lst.filter(n =>\
    \ n > 0)\n        if(negatives.isEmpty) \n            (Some(None), Some(None))\
    \ \n        else \n            (Some(positives.reduceLeftOption(_ > _).getOrElse(lst.min))\n\
    \                , Some(negatives.reduceLeftOption(_ < _).getOrElse(lst.max)))",
  "        val (minOption, maxOption) = lst.span(_ < 0)\n        val minOption = minOption.filterNot(_\
    \ < 0l)\n        val maxOption = maxOption.filterNot(_ > 0l)\n        (minOption,\
    \ maxOption)", "        val positive = lst.filter(_ < 0l).toList\n        val\
    \ negative = lst.filter(_ >= 0l).toList\n        val minPos = min(positive)\n\
    \        val maxNeg = max(negative)\n        (if (minPos == 0l)\n            None\n\
    \        else\n            (Some(minPos), Some(maxNeg))\n        )", "       \
    \ def largest(a: Long, b: Long): Option[Long] = if (a < b) Some(a) else None\n\
    \        def smallest(a: Long, b: Long): Option[Long] = if (a > b) Some(a) else\
    \ None\n        val pair = lst.foldLeft((None, None))((acc: List[Long]) => acc\
    \ match {\n            case (a, b) => (largest(a, a), smallest(a, b))\n      \
    \      case (a, b) => (None, None)\n            case (a, b) => (smallest(a, b),\
    \ largest(a, b))\n        }).getOrElse((None, None))\n        val a = pair._1.getOrElse(None)\n\
    \        val b = pair._2.getOrElse(None)\n        (a, b)", "        if(lst.nonEmpty)\
    \ {\n            val m = lst.head\n            val n = lst.reverse.head\n    \
    \        val i = (m <= 0) ? n.toLong : m.toLong\n            val j = (n <= 0)\
    \ ? m.toLong : n.toLong\n            return Some(i), Some(j)\n        } else {\n\
    \            return None, None\n        }", "        val numbers = lst.sortWith(_\
    \ < _)\n        (numbers.head max numbers.tail.headOption, numbers.tail.headOption\
    \ min numbers.head)", "        val list = lst filterNot (_ < 0) filterNot (_ >\
    \ 0)\n        var smallest = None\n        var largest = None\n        for (i\
    \ <- list toSeq) {\n            if (smallest == None || i > smallest) {\n    \
    \            smallest = i\n            }\n            if (largest == None || i\
    \ < largest) {\n                largest = i\n            }\n        }\n      \
    \  (smallest, largest)", "        val nums = lst.filterNot(_ < 0l).sortWith(_\
    \ < _)\n        if (nums.isEmpty)\n            (None, None)\n        else\n  \
    \          (nums.headOption, nums.lastOption)", "        val nums = lst.foldLeft[List[Long]](List[Long]()){\n\
    \            case (acc, x) => acc :+ x\n        }\n        val isNegative = nums.exists(_\
    \ < 0)\n        val isPositive = nums.exists(_ > 0)\n\n        if(isNegative &&\
    \ isPositive) return (Some(BigInt(nums.sortBy(_.toInt).last.toLong)), Some(BigInt(nums.sortBy(_.toInt).head.toLong)))\n\
    \        if(isPositive) return (Some(BigInt(nums.sortBy(_.toInt).head.toLong)),\
    \ None)\n        if(isNegative) return (None, Some(BigInt(nums.sortBy(_.toInt).last.toLong)))",
  "        if (lst.isEmpty) \n            Tuple2(None, None)\n        else {\n   \
    \         var a = None\n            var b = None\n            lst.foreach{ x =>\
    \ \n                val y = math.min(-x, x)\n                val z = math.max(-x,\
    \ x)\n                if (a eq None || a eq None)\n                    a = new\
    \ Some(y)\n                else\n                    a = if (y > b) new Some(y)\
    \ else a\n                b = if (z < a) new Some(z) else b\n            }\n \
    \           Tuple2(a, b)\n        }", "        val result = for (i <- 0 until\
    \ lst.size) yield {\n            if (lst(i) < 0l) {\n                Some(lst(i))\n\
    \            } else if (lst(i) > 0l) {\n                Some(lst(i))\n       \
    \     } else {\n                None\n            }\n        }\n\n        val\
    \ small = lst.sortWith((a, b) => a.compareTo(b) <= 0)\n        val large = lst.sortWith((a,\
    \ b) => a.compareTo(b) >= 0)\n\n        // If no negative or positive numbers\
    \ are found, return as None.\n        if (result.isEmpty || small.isEmpty || large.isEmpty)\
    \ {\n            val Nones = for {\n                smalle <- small\n        \
    \        larg <- large\n            } yield None\n            val SomeNones =\
    \ for {\n                small <- small\n                larg <- large\n     \
    \       } yield Some(None)\n            Some(None.unzip Nones)\n        } else\
    \ {\n            Some(result.unzip(small.unzip(large)))\n        }", "       \
    \ val positive = lst.filter(_ > 0l)\n        val negative = lst.filter(_ < 0l)\n\
    \        (positive.sorted.head, negative.sorted.head)", "        // If there is\
    \ no list, return None\n        if(lst.isEmpty) {\n            return (None, None)\n\
    \        }\n        // Keep track of the largest and smallest values in an Array\n\
    \        var largest = lst.head\n        var smallest = lst.head\n        // Iterate\
    \ through the list and keep track of the largest and smallest values seen\n  \
    \      lst.tail.foreach(x => {\n            if(x < smallest) {\n             \
    \   smallest = x\n            }\n            if(x > largest) {\n             \
    \   largest = x\n            }\n        })\n        // Return the tuple\n    \
    \    return (Some(largest), Some(smallest))", "        val lstSorted  = lst.sortWith(_\
    \ < _) // sort by descending order\n        val minPossible = lstSorted.takeWhile(_\
    \ < 0) // take negative integers\n        val maxPossible = lstSorted.takeWhile(_\
    \ >= 0) // take positive integers\n        \n        (minPossible, maxPossible)",
  "        if (lst.forall(_.isPositive)) \n            return (Some(lst.max), Some(lst.min))\
    \ \n        else if (lst.forall(_.isNegative)) \n            return (None, Some(lst.min))\
    \ \n        else \n            return (None, None)", "        // Create local\
    \ variables to hold the largest and smallest values.\n        var largest = None\n\
    \        var smallest = None\n        // Iterate through the list.\n        lst.foreach{\
    \ elem =>\n            // If the value is negative, set the largest to that value\
    \ and\n            // keep track of the smallest value.\n            if (elem\
    \ < 0){\n                largest = Some(elem)\n                smallest = elem\n\
    \            }\n            // If the value is positive, set the smallest value\
    \ to that\n            // value and keep track of the largest value.\n       \
    \     else{\n                smallest = Some(elem)\n                largest =\
    \ elem\n            }\n        }\n        // Return the largest and smallest values.\n\
    \        return (largest, smallest)", "        var minIn = -1\n        var maxIn\
    \ = 0\n        var minOut = None\n        var maxOut = None\n        for (i <-\
    \ lst) {\n            if (i < minIn) minIn = i\n            if (i > maxIn) maxIn\
    \ = i\n        }\n        for (j <- lst) {\n            if (j < minOut) minOut\
    \ = j\n            if (j > maxOut) maxOut = j\n        }\n        if (minIn !=\
    \ maxIn) {\n            (minOut, maxOut)\n        } else {\n            (None,\
    \ None)\n        }", "        def largest(acc : List[Long], elem : Long) : Option[Long]\
    \ = {\n            if (acc contains elem) Option(acc)\n            else {\n  \
    \              val newAcc = acc ::: List(elem);\n                val newAcc =\
    \ newAcc.sorted // sort and get the first element\n                val maxEle\
    \ = newAcc.head\n                if (maxEle < 0) None else Some(maxEle)\n    \
    \        }\n        }\n\n        def smallest(acc : List[Long], elem : Long) :\
    \ Option[Long] = {\n            if (acc contains elem) Option(acc)\n         \
    \   else {\n                val newAcc = acc ::: List(elem);\n               \
    \ val newAcc = newAcc.sorted // sort and get the first element\n             \
    \   val minEle = newAcc.last\n                if (minEle > 0) None else Some(minEle)\n\
    \            }\n        }\n        largest(lst.toSeq.filter(_.isNegative), lst.min)\
    \ match {\n            case Some(optLargest) =>\n                smallest(lst.toSeq.filter(_.isPositive),\
    \ lst.max) match {\n                    case Some(optSmallest) => Some(optLargest,\
    \ optSmallest)\n                    case _ => None\n                }\n      \
    \      case _ => None\n        }", "        val positive = lst.filter(elem =>\
    \ elem > 0)\n        val negative = lst.filter(elem => elem < 0)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            return (None, None)\n        else if (positive.isEmpty\
    \ || negative.isEmpty)\n            return (Some(negative.head), Some(positive.head))\n\
    \        else if (positive.head < negative.head)\n            return (Some(negative.head),\
    \ Some(positive.head))\n        else\n            return (Some(positive.head),\
    \ Some(negative.head))", "        val negatives = lst.filter(x => x < 0l)\n  \
    \      val positives = lst.filter(x => x >= 0l)\n        (if(negatives.isEmpty)\
    \ None else Some(negatives.min), if(positives.isEmpty) None else Some(positives.max))",
  "        val negInts = lst.filter(_ < 0)\n        val posInts = lst.filter(_ > 0)\n\
    \        if (negInts.isEmpty) {\n            return ((None, None))\n        }\n\
    \        if (posInts.isEmpty) {\n            return ((None, negInts.head))\n \
    \       }\n        // Find the largest of negative integers, and smallest of positive\
    \ integers\n        val minPosInt = posInts.min\n        val maxNegInt = negInts.max\n\
    \        // If none of them are negative or positive, return None\n        if\
    \ (minPosInt == 0l && maxNegInt == 0l) {\n            return ((None, None))\n\
    \        }\n        // Otherwise, return the smallest and largest integers as\
    \ tuple\n        val smallestInt = minPosInt\n        val largestInt = maxNegInt\n\
    \        return ((Some(smallestInt), Some(largestInt)))", "        lst.sortWith(_.isLess(_)).lastOption\n\
    \                .map(i => if (i < 0) Some(i.toLong) else None) match {\n    \
    \            case Some(a) => a.minOption\n                case None => None\n\
    \            }", "        val mn = lst.foldLeft(Long.MinValue, Long.MaxValue)(\n\
    \            (max, elem) => if (max < elem) max else elem\n        )\n       \
    \ val mx = lst.foldRight(Long.MinValue, Long.MaxValue)(\n            (min, elem)\
    \ => if (min > elem) min else elem\n        )\n        Some(mx), Some(mn)", " \
    \     require(!lst.isEmpty)\n      val (minPositive, maxNegative) =\n        if(lst.isEmpty)\
    \ \n            (None, None)\n        else {\n          val minNegative = lst.headOption.getOrElse(-1L).filter(_\
    \ < 0l)\n          val maxPositive = lst.lastOption.getOrElse(1L).filter(_ > 0l)\n\
    \          (Some(minNegative), Some(maxPositive))\n        }\n      (minPositive,\
    \ maxNegative)", "        def largestSmallestIntegers_(l : List[Long], acc: mutable.Set[Long],\
    \ current: Long, currentSum: Long): Tuple2[Option[Long], Option[Long]] = {\n \
    \           val currentMax = current + currentSum\n            if(l.isEmpty){\n\
    \                if (acc.size > 0) {\n                    acc.remove(currentMax)\n\
    \                    (Some(Some(currentMax)), None)\n                } else {\n\
    \                    (Some(None), Some(currentMax))\n                }\n     \
    \       } else if (currentSum < 0l){\n                if (acc.size > 0) {\n  \
    \                  acc.remove(currentMax)\n                    (Some(Some(currentMax)),\
    \ Some(current))\n                } else {\n                    (Some(None), Some(current))\n\
    \                }\n            } else if (currentSum > 0l){\n               \
    \ val currentMin = current - currentSum\n                if(l.contains(currentMin)){\n\
    \                    val currentSum = currentSum + currentMin\n              \
    \      largestSmallestIntegers_(l - currentMin, acc, currentMin, currentSum)\n\
    \                } else {\n                    if (acc.size > 0) {\n         \
    \               acc.remove(currentMax)\n                        (Some(Some(currentMax)),\
    \ Some(current))\n                    } else {\n                        (Some(None),\
    \ Some(current))\n                    }\n                }\n            } else\
    \ {\n                val currentSum = currentSum + current\n                if\
    \ (acc.contains(currentSum)) {\n                    val currentMin = current -\
    \ currentSum\n                    if (l.contains(currentMin)) {\n            \
    \            largestSmallestIntegers_(l - currentMin, acc, currentMin, currentSum)\n\
    \                    } else {\n                        val currentMax = current\
    \ + currentSum\n                        if (acc.contains(currentMax)) {\n    \
    \                        (Some(Some(currentMax)), Some(current))\n           \
    \             } else {\n                            (Some(None), Some(current))\n\
    \                        }\n                    }\n                } else {\n\
    \                    if (acc.size > 0) {\n                        acc.remove(currentMax)\n\
    \                        (Some(Some(currentMax)), Some(current))\n           \
    \         } else {\n                        (Some(None), Some(current))\n    \
    \                }\n                }\n            }\n        }\n        val acc\
    \ = mutable.Set.empty[Long]\n        largestSmallestIntegers_(lst, acc, 0l, 0l)",
  "      val minNegative = lst.minBy(_.toInt)\n      val maxPositive = lst.maxBy(_.toInt)\n\
    \      (Some(minNegative.toLong), Some(maxPositive.toLong))", "        if (lst.isEmpty)\n\
    \            return (None, None)\n        else if (lst.head.isEmpty)\n       \
    \     return (Some(lst.head), None)\n        else {\n            val largest =\
    \ lst.maxBy(math.abs)\n            val smallest = lst.minBy(math.abs)\n      \
    \      if (largest < smallest)\n                return (None, None)\n        \
    \    else (Some(largest), Some(smallest))\n        }", "        val (smallest,\
    \ largest) = (None, None)\n        lst.foreach {\n            case x if (x < 0)\
    \ => smallest = None\n            case x if (x > 0) => largest = x\n        }\n\
    \        (smallest, largest)", "        var max: Option[Long] = None\n       \
    \ var min: Option[Long] = None\n        for (i <- 0 until lst.size) {\n      \
    \      if (lst(i) < 0)\n            {\n                if (max != None)\n    \
    \            {\n                    // Found a larger negative number. Set max\
    \ to new value\n                    max = Some(lst(i))\n                }\n  \
    \          }\n            else if (lst(i) > 0)\n            {\n              \
    \  if (min != None)\n                {\n                    // Found a larger\
    \ positive number. Set min to new value\n                    min = Some(lst(i))\n\
    \                }\n            }\n            else\n            {\n         \
    \       // None of them were negative or positive, so ignore it\n            }\n\
    \        }\n        // If none of the numbers are negative, just return None\n\
    \        if (max.isEmpty) None\n        else if (min.isEmpty) Some(None)\n   \
    \     else\n        {\n            // Both min and max are positive values. Return\
    \ them as Tuple2[Long, Long]\n            Some(max.get -> min.get)\n        }",
  "        if (lst.isEmpty)\n            (None, Some(None))\n        else\n      \
    \      val maxVal : Option[Long] = lst.maxBy(_.toLong)\n            val minVal\
    \ : Option[Long] = lst.minBy(_.toLong)\n            if (maxVal.isDefined && minVal.isDefined)\n\
    \                (Some(maxVal.get), Some(minVal.get))\n            else\n    \
    \            (None, None)", "        if (lst.isEmpty) return (None, None)\n  \
    \      def findLargest(x : Long) : Option[Long] = {\n            if (x < 0) None\n\
    \            else Some(x)\n        }\n        def findSmallest(x : Long) : Option[Long]\
    \ = {\n            if (x > 0) None\n            else Some(x)\n        }\n    \
    \    def largestSmallestTuple(lst : List[Long]) : Tuple2[Option[Long], Option[Long]]\
    \ = {\n            val largest = findLargest(lst(0).max)\n            val smallest\
    \ = findSmallest(lst(0).min)\n            if (largest.isDefined && smallest.isDefined)\
    \ ( largest.get, smallest.get)\n            else (None, None)\n        }\n   \
    \     largestSmallestTuple(lst)", "        val mn = lst.minBy(math.abs)\n    \
    \    val mx = lst.maxBy(math.abs)\n        if (mn == mx) Some(mn) else None",
  "        def largestSmallestIntegersHelper(lst1 : List[Long], lst2 : List[Long])\
    \ : List[Long] = {\n            lst1 match {\n                case Nil => lst2\n\
    \                case h::t => if (h > 0 && h < lst2.get) largestSmallestIntegersHelper(t,\
    \ lst2 :+ h)\n                           else if (h < 0 && h < lst2.get) largestSmallestIntegersHelper(t,\
    \ lst2 :- h)\n                           else largestSmallestIntegersHelper(t,\
    \ lst2 :+ h)\n            }\n        }\n        largestSmallestIntegersHelper(lst,\
    \ Nil)", "        val negatives = lst.filter(x => x < 0)\n        val positives\
    \ = lst.filter(x => x >= 0)\n        val a = negatives.max\n        val b = positives.min\n\
    \        if (a.exists(x => x == 0)) (a,b) else\n            (a, b)", "       \
    \ var negInts = false\n        var posInts = false\n        var maxPosInt: Option[Long]\
    \ = None\n        var minNegInt: Option[Long] = None\n        var maxNegInt: Option[Long]\
    \ = None\n        for(a <- lst) {\n            if(a.toInt == 0) {\n          \
    \      if(maxNegInt == None) maxNegInt = Some(-a)\n                if(minNegInt\
    \ == None) minNegInt = Some(-a)\n                continue\n            }\n   \
    \         if(-a.toInt > 0) negInts = true\n            else posInts = true\n \
    \           if(a.toInt == maxPosInt) maxPosInt = Some(a.toInt)\n            if(a.toInt\
    \ == minNegInt) minNegInt = Some(a.toInt)\n        }\n        val maxPosIntOpt\
    \ = maxPosInt.toOption\n        val minNegIntOpt = minNegInt.toOption\n      \
    \  if(negInts && !posInts) maxPosIntOpt -> Some(-1l)\n        else if(!negInts\
    \ && posInts) minNegIntOpt -> Some(1l)\n        else (maxPosIntOpt.toOption, minNegIntOpt.toOption)",
  "        def largest(lst : List[Long]) = {\n            if (lst.isEmpty) None\n\
    \            else {\n                val max = lst.max\n                val min\
    \ = lst.min\n                if (max < min) None\n                else Some(max)\n\
    \            }\n        }\n\n        def smallest(lst : List[Long]) = {\n    \
    \        if (lst.isEmpty) None\n            else {\n                val max =\
    \ lst.max\n                val min = lst.min\n                if (max > min) None\n\
    \                else Some(min)\n            }\n        }\n\n        lst.map(x\
    \ => if (x % 2 == 0) {\n            if (x < 0) smallest(lst.filter(_ > x))\n \
    \           else largest(lst.filter(_ < x))\n        }\n        else largest(lst.filter(_\
    \ > x)))", "        lst.sortWith(_ < _)\n        // If there are no negative/positive\
    \ integers, return them as None.\n        if (lst.isEmpty) None else (Some(lst(0).max),\
    \ Some(lst(0).min))", "        // Sort the list and get the lowest and highest\
    \ integer values.\n        val sorted = lst.sortWith(_.compareTo(_) < 0)\n   \
    \     val low = sorted.head\n        val high = sorted.last\n        (Some(low),\
    \ Some(high))", "        val smallest = lst.minBy(_ < 0l)\n        val largest\
    \ = lst.maxBy(_ > 0l)\n        (smallest == None, largest == None)", "       \
    \ val minNegative = lst.filter(x => x < 0).toList\n        val minPositive = lst.filter(x\
    \ => x >= 0).toList\n        if (minNegative.isEmpty || minPositive.isEmpty)\n\
    \            throw new IllegalArgumentException(\"List has no positive and negative\
    \ numbers\")\n        val minValueNegative = minNegative.min\n        val minValuePositive\
    \ = minPositive.min\n        (minValueNegative < minValuePositive) match {\n \
    \           case true => Some(minValueNegative), Some(minValuePositive)\n    \
    \        case false => None\n        }", "        val sortedList = lst.sortBy(\
    \ l => -l )\n        val smallestNegative = sortedList.dropWhile( l => l < 0l\
    \ ).head\n        val smallestPositive = sortedList.takeWhile( l => l > 0l ).head\n\
    \        val largestNegative = sortedList.last\n        (smallestNegative, smallestPositive)",
  "      if (lst.isEmpty) \n        (None, None)\n      else if (lst.head < 0) \n\
    \        (Some(lst.max), None)\n      else if (lst.head > 0)\n        (None, Some(lst.min))\n\
    \      else\n        (None, None)", "        var max = 0\n        var min = 0\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (max <\
    \ i) {\n                    max = i\n                }\n            } else {\n\
    \                if (min > i) {\n                    min = i\n               \
    \ }\n            }\n        }\n        (Some(max), Some(min))", "        val m\
    \ = lst.minBy(_.toInt)\n        val n = lst.maxBy(_.toInt)\n        if (m < n)\
    \ (Nil, Some(m)) else (Some(n), Nil)", "        lst.foldLeft((None, None)){\n\
    \            case ((maxA, maxB), item) =>\n                (if (item < 0l) item\
    \ :: maxA :: maxB\n                else if (item > 0l) maxB :: item :: maxA\n\
    \                else maxA :: maxB :: item)\n        }", "        // Create a\
    \ set that stores the negative integers\n        val negative = mutable.HashSet[Long]()\n\
    \        // Create a set that stores the positive integers\n        val positive\
    \ = mutable.HashSet[Long]()\n        // Create a tuple to store the largest and\
    \ smallest numbers\n        val tuple = scala.util.Success(None, None)\n     \
    \   // Go through the list lst, store the negative and positive integers\n   \
    \     // and calculate the largest and smallest numbers in the list\n        for\
    \ (i <- 0 until lst.size) {\n            val integer = lst(i)\n            //\
    \ If the integer is negative, add it to negative\n            if (integer < 0L)\
    \ {\n                negative += integer\n            }\n            // If the\
    \ integer is positive, add it to positive\n            else {\n              \
    \  positive += integer\n            }\n        }\n        // If there are no negative\
    \ and positive integers, return None\n        if (negative.isEmpty && positive.isEmpty)\
    \ {\n            return tuple\n        }\n        // If there are no negative\
    \ integers, return (Some(None), None)\n        if (negative.isEmpty) {\n     \
    \       return scala.util.Success(None, tuple.product)\n        }\n        //\
    \ If there are no positive integers, return (Some(None), None)\n        if (positive.isEmpty)\
    \ {\n            return scala.util.Success(Some(None), tuple.product)\n      \
    \  }\n        // Calculate the largest\n        val largest = negative.foldLeft(positive.max)((a,\
    \ b) => if (a > b) a else b)\n        // Calculate the smallest\n        val smallest\
    \ = positive.foldLeft(negative.min)((a, b) => if (a < b) a else b)\n        //\
    \ Return tuple with the largest and smallest numbers\n        scala.util.Success(Some(largest),\
    \ Some(smallest))", "        val mins = lst.foldLeft((None, null))((a, b) => if\
    \ (a.isEmpty || b.isEmpty || a.get._2 > b.get._2) (a, b) else (a, b))\n      \
    \  val maxs = lst.foldLeft((null, null))((a, b) => if (a.isEmpty || b.isEmpty\
    \ || a.get._2 < b.get._2) (a, b) else (a, b))\n        val smallest = lst.foldLeft((null,\
    \ null))((a, b) => if (a.isEmpty || b.isEmpty) (a, b) else (a, b))\n        val\
    \ largest = lst.foldLeft((null, null))((a, b) => if (a.isEmpty || b.isEmpty) (a,\
    \ b) else (a, b))\n        val minA = mins.get.map(_.get)\n        val minB =\
    \ mins.get.map(_.get)\n        val maxA = maxs.get.map(_.get)\n        val maxB\
    \ = maxs.get.map(_.get)\n        val minC = smallest.get.map(_.get)\n        val\
    \ maxC = largest.get.map(_.get)\n        if ((minA.isEmpty) && (minB.isEmpty)\
    \ && (maxA.isEmpty) && (maxB.isEmpty)) return (None, None)\n        if ((minA.isEmpty)\
    \ && (minB.isEmpty)) return (minC, maxC)\n        if ((maxA.isEmpty) && (maxB.isEmpty))\
    \ return (maxC, minC)\n        if ((minA != minB) && (maxA != maxB)) return (None,\
    \ None)\n        if ((minA != minB) && (maxA != maxB) && (minA != minC) && (maxA\
    \ != maxC)) return (None, None)\n        if ((minA != minB) && (maxA != maxB)\
    \ && (minA != minC) && (maxA != maxC)) return (minC, maxC)\n        if ((minA\
    \ != minB) && (maxA != maxB) && (minA != minC) && (maxA != maxC)) return (None,\
    \ None)\n        if ((maxA != maxB) && (maxA != maxC)) return (None, None)\n \
    \       if ((maxA != maxB) && (maxA != maxC) && (maxA != minC) && (maxA != minC))\
    \ return (None, None)\n        if ((maxA != maxB) && (maxA != maxC) && (maxA !=\
    \ minC) && (maxA != minC)) return (None, None)\n        if ((minA != minB) &&\
    \ (minA != minC) && (minA != minC)) return (minA, maxB)\n        if ((maxA !=\
    \ maxB) && (maxA != maxC) && (maxA != minC) && (maxA != minC)) return (maxA, minB)\n\
    \        if ((minA != minB) && (", "        // Write your code here.\n       \
    \ if (lst.isEmpty)\n            (None, None)\n        else {\n            def\
    \ largestNegative(arr : List[Long]) : List[Long] = {\n                arr.filter(num\
    \ => num < 0l).sortWith(_.compareTo(0l) < 0)\n            }\n            def largestPositive(arr\
    \ : List[Long]) : List[Long] = {\n                arr.filter(num => num > 0l).sortWith(_.compareTo(0l)\
    \ > 0)\n            }\n            def largestNegativeOrNone(arr : List[Long])\
    \ : Option[List[Long]] = {\n                Option(largestNegative(arr))\n   \
    \         }\n            def largestPositiveOrNone(arr : List[Long]) : Option[List[Long]]\
    \ = {\n                Option(largestPositive(arr))\n            }\n         \
    \   def largestNegativeOrNoneOrEmpty(arr : List[Long]) : Option[(List[Long], Option[List[Long]])]\
    \ = {\n                val a = largestNegativeOrNone(arr)\n                val\
    \ b = largestPositiveOrNone(arr)\n                if (a.isEmpty || b.isEmpty)\n\
    \                    None\n                else {\n                    val c =\
    \ (a.get, b.get)\n                    Some((c, a.orElse(b.orElse(List()))))\n\
    \                }\n            }\n            def smallestPositiveOrNone(arr\
    \ : List[Long]) : Option[List[Long]] = {\n                Option(arr.sortWith(_.compareTo(0l)\
    \ == 0))\n            }\n            def smallestPositiveOrNoneOrEmpty(arr : List[Long])\
    \ : Option[(List[Long], Option[List[Long]])] = {\n                val a = smallestPositiveOrNone(arr)\n\
    \                val b = smallestPositiveOrNone(arr)\n                if (a.isEmpty\
    \ || b.isEmpty)\n                    None\n                else {\n          \
    \          val c = (a.get, b.get)\n                    Some((c, a.orElse(b.orElse(List()))))\n\
    \                }\n            }\n            largestNegativeOrNoneOrEmpty(lst).flatMap\
    \ { case (a, b) => if (a.isEmpty) Some(b) else None}\n                orElse largestPositiveOrNoneOrEmpty(lst).flatMap\
    \ { case (a, b) => if (a.isEmpty) Some(b) else None}\n                orElse smallestPositiveOrNoneOrEmpty(lst).flatMap\
    \ { case (a, b) => if (a.isEmpty) Some(b) else None}\n        }", "        val\
    \ negInts = lst.filter(_ < 0)\n        val posInts = lst.filter(_ > 0)\n     \
    \   if (negInts.isEmpty) {\n            return ((Some(None), Some(None)), None)\n\
    \        } else {\n            val maxVal = negInts.max\n            val minVal\
    \ = posInts.min\n            val maxAbsVal = maxVal abs\n            val minAbsVal\
    \ = minVal abs\n            if (maxAbsVal == minAbsVal) {\n                return\
    \ ((Some(maxVal), Some(minVal)), None)\n            } else {\n               \
    \ return ((Some(maxAbsVal), Some(minAbsVal)), None)\n            }\n        }",
  "        val largest = lst.maxBy(-_)\n        val smallest = lst.minBy(+_)\n   \
    \     if (largest == smallest) {\n            (Some(largest), Some(largest))\n\
    \        } else {\n            (None, None)\n        }", "        val sortedList\
    \ = lst.sortWith(_ > _)\n        val minList = SortedList[Long](sortedList.head)\n\
    \        val maxList = SortedList[Long](sortedList.last)\n\n        minList match\
    \ {\n            case Empty =>\n                maxList match {\n            \
    \        case Empty =>\n                        Some(None, None)\n           \
    \         case HNil => None\n                    case _ =>\n                 \
    \       None\n                }\n            case HNil =>\n                maxList\
    \ match {\n                    case Empty =>\n                        None\n \
    \                   case HNil => None\n                    case _ =>\n       \
    \                 None\n                }\n            case _ =>\n           \
    \     maxList match {\n                    case Empty =>\n                   \
    \     None\n                    case HNil =>\n                        None\n \
    \                   case _ =>\n                        None\n                }\n\
    \        }", "        def largest(x : Long) : Long = if (x < 0) x else 0\n   \
    \     def smallest(x: Long) : Long = if (x > 0) x else 0\n        val sortedList\
    \ = lst.sorted\n        val a = if (sortedList.head < 0) None else Some(sortedList.head)\
    \  \n        val b = if (sortedList.last > 0) None else Some(sortedList.last)\n\
    \        (a, b)", "        var smallestVal = None\n        var largestVal = None\n\
    \        lst.foreach {x => if(x < 0L) smallestVal = Some(x); if(x > 0L) largestVal\
    \ = Some(x)}\n        if(smallestVal.isEmpty && largestVal.isEmpty) None\n   \
    \     else if(smallestVal.isEmpty && largestVal.isDefined) None\n        else\
    \ if(smallestVal.isDefined && largestVal.isEmpty) smallestVal.map(_ -> 0L)\n \
    \       else largestVal.map(_ -> 0L)", "        val largestNegative = lst.filter(x\
    \ => x < 0l).max\n        val largestPositive = lst.filter(x => x > 0l).min\n\n\
    \        if ( largestNegative == None  &&  largestPositive == None ) return (None,\
    \ None)\n        if ( largestNegative == None ) return (Some(largestPositive),\
    \ None)\n        if ( largestPositive == None ) return (None, Some(largestNegative))\n\
    \n        (Some(largestPositive), Some(largestNegative))", "        val maxValue\
    \ = lst.foldLeft(-math.min(0l, math.max(0l, lst.head))) { case (acc, x) =>\n \
    \           if (x < acc) {\n                (math.min(math.max(0l, lst.head),\
    \ acc), x)\n            } else {\n                (x = acc, x)\n            }\n\
    \        }._1\n        val minValue = lst.foldLeft(math.max(0l, lst.head)) { case\
    \ (acc, x) =>\n            if (x > acc) {\n                (acc, math.max(0l,\
    \ lst.head))\n            } else {\n                (x = acc, x)\n           \
    \ }\n        }._1\n        (Some(maxValue), Some(minValue))", "        var maxVal\
    \ = lst.max\n        var minVal = lst.min\n        val maxIsNegative = lst.forall(_.isNegative)\n\
    \        val minIsNegative = lst.forall(_.isNegative)\n        val maxIsPositive\
    \ = lst.forall(_.isPositive)\n        val minIsPositive = lst.forall(_.isPositive)\n\
    \n        if(maxIsNegative && minIsNegative) return (None, None)\n        if(maxIsPositive\
    \ && minIsPositive) return (None, None)\n        if(maxIsNegative) {\n       \
    \     maxVal = lst.max\n            minVal = lst.min\n        } else if(maxIsPositive)\
    \ {\n            maxVal = lst.max\n            minVal = lst.min\n        } else\
    \ {\n            maxVal = lst.min\n            minVal = lst.max\n        }\n \
    \       // Return the tuple (Some(max), Some(min))\n        return (Some(maxVal),\
    \ Some(minVal))", "        // TODO: Implement your solution\n        def largestPositiveInner(a:\
    \ Long, b: Long, lst: List[Long]) : (Option[Long], Option[Long]) = {\n       \
    \     if (a == 0) (b, None)\n            else if ((a < 0) && (b > 0)) (b,None)\
    \ //b < a\n            else (Some(a), Some(b))\n        }\n\n        def largestNegativeInner(a:\
    \ Long, b: Long, lst: List[Long]) : (Option[Long], Option[Long]) = {\n       \
    \     if (a == 0) (b, None)\n            else if ((a > 0) && (b < 0)) (a, b) //b\
    \ > a\n            else (Some(a), Some(b))\n        }\n\n        def largestPositive(lst:\
    \ List[Long]) : Option[Long] = {\n            val a = lst.min\n            val\
    \ b = lst.max\n            if (a < 0) b\n            else a\n        }\n\n   \
    \     def largestNegative(lst: List[Long]) : Option[Long] = {\n            val\
    \ a = lst.max\n            val b = lst.min\n            if (a > 0) b\n       \
    \     else a\n        }\n\n        val negative = lst.filter(a => a < 0)\n   \
    \     val positive = lst.filter(a => a > 0)\n        val maxPositive = largestPositive(positive)\n\
    \        val maxNegative = largestNegative(negative)\n        (maxPositive, maxNegative)",
  "        val negativeLongs = lst.filter(_.isNegative)\n        val positiveLongs\
    \ = lst.filter(_.isPositive)\n\n        val maxPositiveLong = positiveLongs.max\n\
    \        val minNegativeLong = negativeLongs.min\n\n        val maxNegativeLong\
    \ = maxPositiveLong.map(_.abs)\n        val minPositiveLong = minNegativeLong.map(_.abs)\n\
    \n        (\n            if (minPositiveLong.isEmpty && minNegativeLong.isEmpty)\
    \ None\n            else Some(maxNegativeLong.get),\n            if (maxPositiveLong.isEmpty\
    \ && maxNegativeLong.isEmpty) None\n            else Some(maxPositiveLong.get)\n\
    \        )", "        val negative = lst.filter(_ < 0l)\n        val positive\
    \ = lst.filter(_ >= 0l)\n\n        if (negative.isEmpty) None else {\n       \
    \     val max = negative.maxBy(-_)\n            val min = positive.minBy(_)\n\n\
    \            Some(Some(max), Some(min))\n        }", "        // Set default values\
    \ to None\n        var a = None\n        var b = None\n        // Iterate over\
    \ list and test if both values are greater than zero\n        for (elem <- lst)\
    \ {\n            if (a != None) a = if (elem < 0) a else elem\n            if\
    \ (b != None) b = if (elem > b) elem else b\n        }\n        // Return result\
    \ as tuple\n        (Some(a), Some(b))", "        // A list can be empty or contain\
    \ no elements.\n        if (lst.size < 2)\n            return (None, None)\n\n\
    \        // First, sort the list so that all negative numbers are in front\n \
    \       // and all positive numbers are at the end.\n        val reversedLst =\
    \ lst.sortBy(x => x < 0l).reverse\n        val negativeNumbers = reversedLst.takeWhile(x\
    \ => x < 0l)\n        val positiveNumbers = reversedLst.dropWhile(x => x < 0l).drop(1)\n\
    \        val sortedNumbers = negativeNumbers ++ positiveNumbers\n\n        //\
    \ Now, iterate through the sorted list, and find the first negative\n        //\
    \ integer and the first positive integer.\n        val negativeMin = negativeNumbers.head\n\
    \        val positiveMin = positiveNumbers.head\n\n        // If the first element\
    \ of the list is negative, find the\n        // smallest positive integer.\n \
    \       // If the first element of the list is positive, find the\n        //\
    \ smallest negative integer.\n        if (sortedNumbers.head < 0l)\n         \
    \   return (Some(positiveMin), Some(negativeMin))\n        if (sortedNumbers.head\
    \ > 0l)\n            return (Some(negativeMin), Some(positiveMin))\n        return\
    \ (None, None)", "        val negative = lst.filter(n => n < 0L)\n        val\
    \ positive = lst.filter(n => n > 0L)\n        negative.max match {\n         \
    \   case None => positive.min\n            case Some(None) => None\n         \
    \   case Some(x) => Some(x)\n        }", "        val ints = lst.map(i => (if\
    \ (i < 0l) Some(i) else None)).toList\n        if (ints.isEmpty)\n           \
    \ (None, None)\n        else {\n            val maxI = ints.max\n            val\
    \ minI = ints.min\n            if (maxI == minI)\n                (None, None)\n\
    \            else\n                (Some(maxI), Some(minI))\n        }", "   \
    \     // Use fold to find the max and min in a single pass\n        // This will\
    \ be much more efficient than sorting and finding the max and min in the loop\n\
    \        val max = lst.foldLeft((Option(Long.MaxValue), Option(Long.MinValue)))\
    \ { case ((max,min), e) => (if (e < min) (e, min) else (max, e))}._1\n       \
    \ val min = lst.foldLeft((Option(Long.MaxValue), Option(Long.MinValue))) { case\
    \ ((max,min), e) => (if (e > max) (e, max) else (max, e))}._1\n        max match\
    \ {\n            case None    => (None, None)\n            case Some(x) => x match\
    \ {\n                case None    => (None, None)\n                case Some(y)\
    \ => y match {\n                    case None    => (None, None)\n           \
    \         case Some(z) => (Some(z), Some(z))\n                }\n            }\n\
    \        }", "        val lstWithMax = lst.map(x => (x, x))\n        val lstWithMin\
    \ = lst.map(x => (x, -x))\n        val lstWithMaxMin = lstWithMax.zip(lstWithMin)\n\
    \        val lstWithMaxMinMin = lstWithMaxMin.filter(x => x._1 < x._2)\n     \
    \   val max = lstWithMaxMinMin.map(x => x._1).max\n        val min = lstWithMaxMinMin.map(x\
    \ => x._1).min\n        (Option(max), Option(min))", "        val positiveLongs\
    \ = new mutable.Queue[Long]()\n        val negativeLongs = new mutable.Queue[Long]()\n\
    \n        var a = lst.head\n        var b = lst.last\n\n        lst.foreach{\n\
    \            value => if (value < 0) negativeLongs += value else positiveLongs\
    \ += value\n        }\n\n        if (positiveLongs.isEmpty) (a, b) else None",
  "        val negInt = lst.filter(_<0).length\n        val posInt = lst.filter(_>=0).length\n\
    \        if(negInt==0 && posInt==0)\n            (None, None)\n        else if(negInt==0)\n\
    \            (Some(None), Some(None)) // no negative ints, nothing to do\n   \
    \     else if(posInt==0)\n            (None, Some(None)) // no positive ints,\
    \ nothing to do\n        else\n        {\n            val largest = lst.max //\
    \ largest is positive if and only if the list is sorted\n            val smallest\
    \ = lst.min // smallest is negative if and only if the list is sorted\n      \
    \      (Some(largest), Some(smallest))\n        }", "        // If there's one\
    \ positive integer in the list, return it as (a, b)\n        if (lst.contains(1l))\
    \ (Some(1l), None)\n        // Otherwise, if there's one negative integer in the\
    \ list, return it as (b, -a)\n        else if (lst.contains(-1l)) (Some(-1l),\
    \ Some(1l))\n        // Otherwise, there's no negative or positive integers, return\
    \ them as None\n        else (None, None)", "        val minLong = lst.min.orElse(-1l)\n\
    \        val maxLong = lst.max.orElse(0l)\n        (if (minLong < 0l) None else\
    \ Some(minLong), if (maxLong > 0l) None else Some(maxLong))", "        val max:\
    \ Option[Long] = lst.max match{\n            case Some(x) if x < 0l  => Some(xl.toLong)\n\
    \            case _                  => None\n        }\n        val min: Option[Long]\
    \ = lst.min match{\n            case Some(x) if x > 0l  => Some(xl.toLong)\n \
    \           case _                  => None\n        }\n        if(max.isEmpty\
    \ || min.isEmpty)\n            None else\n            ((Some(max), Some(min)))",
  "        // If there is no list, return None as a tuple\n        if(lst.isEmpty)\
    \ \n            (None, None)\n        else {\n            // If there is an even\
    \ number of elements, return smallest\n            // and largest as tuple\n \
    \           if(lst.size % 2 == 0) \n                (Some(lst.min), Some(lst.max))\n\
    \            // If there is an odd number of elements, return smallest and\n \
    \           // largest as None if either is None.\n            else if(lst.size\
    \ % 2 != 0) \n                (Some(lst.min), Some(lst.max))\n            // If\
    \ the number of elements is even, create two new lists\n            // one with\
    \ positive elements and another with negative elements\n            else {\n \
    \               // Get a mutable list to hold negative integers\n            \
    \    val negInList = lst.filter(_.toInt == -1)\n                // Get a mutable\
    \ list to hold positive integers\n                val posInList = lst.filter(_.toInt\
    \ == 1)\n                // Find the minimum and maximum from the two lists\n\
    \                val smallest = posInList.min\n                val largest = posInList.max\n\
    \                // Return the smallest and largest integers\n               \
    \ (Some(smallest), Some(largest))\n            }\n        }", "        def largestFirst(num\
    \ : Long, acc: List[Long]) : Option[Long] = {\n            if (num <= 0L) {\n\
    \                Some(num)\n            } else if (num <= acc.last)\n        \
    \        largestFirst(num - acc.last, acc)\n            else\n               \
    \ largestFirst(num - acc.last, acc + List(num))\n        }\n\n        def smallestFirst(num\
    \ : Long, acc: List[Long]) : Option[Long] = {\n            if (num > 0L)\n   \
    \             smallestFirst(num - acc.last, acc)\n            else if (acc.nonEmpty)\n\
    \                smallestFirst(acc.last, acc :+ num)\n            else\n     \
    \           None\n        }\n\n        def largestSmallest(lst : List[Long]) :\
    \ Option[Long] = {\n            val max = lst.foldLeft(0L){ (a, e) =>\n      \
    \          if (e > a)\n                    e\n                else\n         \
    \           a\n            }\n\n            val min = lst.foldLeft((-1L, 0L))((a,\
    \ e) =>\n                if (e < a)\n                    (e, a)\n            \
    \    else\n                    a\n            )\n\n            smallestFirst(max,\
    \ min._1).getOrElse(max)\n        }\n        largestFirst(lst.last, lst.init :+\
    \ 0L)", "        if (lst.isEmpty) \n            return (None, None)\n        var\
    \ largest = lst.head\n        var smallest = lst.head\n        for (i <- lst.tail)\
    \ {\n            if (i < 0) {\n                if (largest < 0) largest = i\n\
    \            } else {\n                if (smallest > 0) smallest = i\n      \
    \      }\n        }\n        return (Option(largest), Option(smallest))", "  \
    \      val n = lst.length\n        if(n < 2)\n            (None, None)\n     \
    \   else {\n            val min: Option[Long] = None\n            val max: Option[Long]\
    \ = None\n            val minus: Option[Long] = None\n            val plus: Option[Long]\
    \ = None\n            for(i <- 0 until n-1) {\n                if(lst(i) < 0)\
    \ {\n                    minus += lst(i)\n                }\n                else\
    \ {\n                    plus += lst(i)\n                }\n            }\n  \
    \          if(minus.isEmpty)\n                minus.orNull\n            else {\n\
    \                val m = (minus.orNull.max) minus.orNull\n                max\
    \ = minus match {\n                    case Some(i) => Some(m.max(i))\n      \
    \              case None => Some(m)\n                }\n            }\n      \
    \      if(plus.isEmpty)\n                plus.orNull\n            else {\n   \
    \             val m = (plus.orNull.min) plus.orNull\n                min = plus\
    \ match {\n                    case Some(i) => Some(m.min(i))\n              \
    \      case None => Some(m)\n                }\n            }\n            (min,\
    \ max)\n        }", "        val positiveInts = lst.filter { x => x < 0 }\n  \
    \      val negativeInts = lst.filter { x => x >= 0 }\n        negativeInts.min\
    \ match {\n            case None => (None, None)\n            case Some(x) =>\
    \ positiveInts.max match {\n                case None => (None, None)\n      \
    \          case Some(y) => Some(Some(x < y ? x : y))\n            }\n        }",
  "        def helper(acc : List[(Long, Long)])(min : Long, max : Long) : Option[(Long,\
    \ Long)] = {\n            if(!acc.isEmpty) {\n                if(acc match {\n\
    \                    case Nil => None\n                    case x :: xs => {\n\
    \                        if(x < min) None\n                        else if(x >\
    \ max) None\n                        else if(min == max && x == min) Some(x)\n\
    \                        else if(x < min && x > max) helper(xs, x)\n         \
    \               else if(min == max && x == min) Some(min :: Nil)\n           \
    \             else if(min < x && x < max) Some(x :: Nil)\n                   \
    \     else helper(xs, max)\n                    }\n                })\n      \
    \      } else if(lst.isEmpty) None\n            else helper(lst.tail, lst(0))\n\
    \        }\n        helper(Nil, lst(0))", "        if (lst.isEmpty) \n       \
    \     (None, None)\n        else {\n            var minL = -1l\n            var\
    \ maxL = 1l\n            var nextMinL = -1l\n            var nextMaxL = 1l\n \
    \           lst.toList foreach { e =>\n                if (e < minL) {\n     \
    \               minL = e\n                }\n                if (e > maxL) {\n\
    \                    maxL = e\n                }\n            }\n            val\
    \ result = if (minL < -1l) Some(None) else Some(minL)\n            if (maxL >\
    \ 1l) Some(maxL) else result\n        }", "      var positive = Long.MaxValue\n\
    \      var negative = Long.MinValue\n      lst.foldLeft(Some(negative), Some(positive))\
    \ { (t, l) =>\n        if(l < 0) (Some(negative), Some(positive))\n        else\
    \ if(l > 0) (Some(positive), Some(positive))\n        else (t, Some(positive))\n\
    \      }", "        val negative = (lst.filter(x => x < 0l))\n        val positive\
    \ = (lst.filter(x => x > 0l))\n        val min = min(positive)\n        val max\
    \ = max(negative)\n        (Some(min), Some(max))", "        lst.foldLeft((None,\
    \ None)) { (tl, el) => \n            val a = if (el < 0l) None else Some(el)\n\
    \            val b = if (el > 0l) None else Some(el)\n            (a._1, b._1)\
    \ \n        }", "        // Find negative and positive integer values using 'filter'.\n\
    \        // 'filter' will return a list with all the positive and negative integers,\
    \ respectively.\n        val posNbl = lst.filter(x => x < 0l)\n        val negNbl\
    \ = lst.filter(x => x > 0l)\n        \n        // Take the maximum of both lists\
    \ to get the largest of them\n        val posSmallest = posNbl.max(negNbl)\n \
    \       val negLargest = negNbl.max(posNbl)\n        \n        // return None\
    \ if there is no negative or positive integers\n        if (posSmallest.isEmpty\
    \ && negLargest.isEmpty) return (None, None)\n        // else return the (Option[Int],\
    \ Option[Int]) tuple, where 'a' is the largest of positive integers, and 'b' is\
    \ the smallest of negative integers.\n        return (Some(negLargest.get), Some(posSmallest.get))",
  "        import scala.math._\n        import scala.collection.mutable._\n\n    \
    \    val l = new mutable.ListBuffer[Long]()\n        var a : Option[Long] = None\n\
    \        var b : Option[Long] = None\n        for(i <- lst){\n            if(i.<0){\n\
    \                if(b.isDefined && a.isDefined){\n                    l.clear()\n\
    \                    l.append(b.get)\n                    b.set(i.get)\n     \
    \               a = Some(i.get)\n                }else if(a.isDefined && b.isDefined)\
    \ l.append(i.get)\n                else l.append(i.get)\n            }else if(i>0){\n\
    \                if(b.isDefined && a.isDefined){\n                    l.clear()\n\
    \                    l.append(a.get)\n                    a.set(i.get)\n     \
    \               b = Some(i.get)\n                }else if(a.isDefined && b.isDefined)\
    \ l.append(i.get)\n                else l.append(i.get)\n            }\n     \
    \   }\n        if(l.isEmpty) (a,b) else {\n            l.foldLeft((a, Some(0l))){\n\
    \                case ((Some(a), Some(b)) , v) => if(v>b) (b,v) else (a,v)\n \
    \           }\n        }", "        val max = lst.maxBy(_.toInt)\n        val\
    \ min = lst.minBy(_.toInt)\n        (Some(max), Some(min))", "        val lstOpt\
    \ = lst.headOption\n        val lst1 = lst.tail\n        val lst1Opt = lst1.headOption\n\
    \n        val min = if (lstOpt.isDefined && lst1Opt.isDefined) lst1Opt.get.toLong\
    \ max lstOpt.get.toLong else lst1Opt\n        val max = if (lstOpt.isDefined &&\
    \ lst1Opt.isDefined) lst1Opt.get.toLong min lstOpt.get.toLong else lstOpt\n\n\
    \        if (lstOpt.isDefined && lst1Opt.isDefined) {\n            (Some(min),\
    \ Some(max))\n        }\n        else (None, None)", "        val negInts = lst.filter(_\
    \ < 0l)\n        val posInts = lst.filter(_ > 0l)\n        val maxInt = negInts.maxBy(neg\
    \ => neg)\n        val minInt = posInts.minBy(pos => pos)\n        (maxInt ==\
    \ None) match {\n            case true => {\n                (maxInt == None)\
    \ match {\n                    case true => (None, None)\n                   \
    \ case false => (None)(None)\n                }\n            }\n            case\
    \ false => val maxIntTuple = (maxInt.asInstanceOf[Long], None) match {\n     \
    \           case (neg, None) => Some(neg)\n                case (neg, _) => Some(neg)\n\
    \                case (_, pos) => Some(pos)\n            }\n            (minInt\
    \ == None) match {\n                case true => {\n                    (minInt\
    \ == None) match {\n                        case true => (None, None)\n      \
    \                  case false => (None)(None)\n                    }\n       \
    \         }\n                case false => val minIntTuple = (minInt.asInstanceOf[Long],\
    \ None) match {\n                    case (pos, None) => Some(pos)\n         \
    \           case (pos, _) => Some(pos)\n                    case (_, neg) => Some(neg)\n\
    \                }\n                ((maxIntTuple, minIntTuple))\n           \
    \ }\n        }", "        def getMaxPositive(lst : List[Long]) : Option[Long]\
    \ = {\n            val max = lst.foldLeft(0l.toLong)(math.max(_, _))\n       \
    \     lst.find(_ > max).getOrElse(None)\n        }\n        def getMinNegative(lst\
    \ : List[Long]) : Option[Long] = {\n            val min = lst.foldLeft(0l.toLong)(math.min(_,\
    \ _))\n            lst.find(_ < min).getOrElse(None)\n        }\n        val maxPosOpt\
    \ = getMaxPositive(lst.sortWith(_ > _))\n        val minNegOpt = getMinNegative(lst.sortWith(_\
    \ < _))\n        (maxPosOpt, minNegOpt)", "        val min = lst.min\n       \
    \ val max = lst.max\n        val minOpt = lst.find(_.toLong < min.toLong)\n  \
    \      val maxOpt = lst.find(_.toLong > max.toLong)\n        if (minOpt.isDefined\
    \ && maxOpt.isDefined) {\n            return Some((minOpt.get, maxOpt.get))\n\
    \        }\n        else {\n            return Some(None)\n        }", "     \
    \   def largest(acc : Option[Long], xs: List[Long]) : Option[Long] = {\n     \
    \       if (xs.isEmpty) acc\n            else largest(acc.max(xs.head), xs.tail)\n\
    \        }\n        def smallest(acc : Option[Long], xs: List[Long]) : Option[Long]\
    \ = {\n            if (xs.isEmpty) acc\n            else smallest(acc.min(xs.head),\
    \ xs.tail)\n        }\n        (largest(Option.empty, lst.filter(_ < 0l)),\n \
    \        smallest(Option.empty, lst.filter(_ > 0l)))", "        val negative =\
    \ lst.filter(l => l < 0l).sort((l, r) => r - l)\n        val positive = lst.filter(l\
    \ => l > 0l).sort((l, r) => r - l)\n        val first = if (negative.isEmpty &&\
    \ positive.isEmpty) None else Some(negative.head)\n        val second = if (positive.isEmpty\
    \ && negative.isEmpty) None else Some(positive.last)\n        val firstIsLarger\
    \ = (negative.head > positive.last)\n        val secondIsSmaller = (negative.last\
    \ < positive.head)\n        val firstIsSmaller = (negative.last < positive.head)\n\
    \        val firstIsBigger = (negative.head > positive.last)\n        val secondIsBigger\
    \ = (positive.last < positive.head)\n\n        val firstIsMorePositiveOrNegative\
    \ = (first == None) || (first.isEmpty && ((firstIsLarger) && secondIsSmaller))\n\
    \        val secondIsMorePositiveOrNegative = (second == None) || (second.isEmpty\
    \ && ((secondIsSmaller) && firstIsSmaller))\n\n        val firstIsNegativeOrPositive\
    \ = (first == None) || (first.isEmpty && ((firstIsSmaller) && secondIsBigger))\n\
    \        val secondIsNegativeOrPositive = (second == None) || (second.isEmpty\
    \ && ((secondIsBigger) && firstIsBigger))\n        val bothAreNegativeOrPositive\
    \ = firstIsNegativeOrPositive && secondIsNegativeOrPositive\n        val bothAreMorePositiveOrNegative\
    \ = firstIsMorePositiveOrNegative || secondIsMorePositiveOrNegative\n        val\
    \ bothAreNegativeOrPositiveOrMorePositiveOrNegative = firstIsNegativeOrPositive\
    \ && secondIsNegativeOrPositive && firstIsMorePositiveOrNegative || secondIsNegativeOrPositive\
    \ && firstIsMorePositiveOrNegative\n        val bothAreNegativeOrPositiveOrMorePositiveOrNegativeOrBothAreMorePositiveOrNegative\
    \ = firstIsNegativeOrPositive && secondIsNegativeOrPositive && firstIsMorePositiveOrNegative\
    \ && secondIsMorePositiveOrNegative\n\n        val allAreMorePositiveOrNegative\
    \ = (first == None) || (first.isEmpty && ((firstIsMorePositiveOrNegative) && secondIsMorePositiveOrNegative))\n\
    \        val allAreMorePositiveOrNegativeOrBothAreMorePositiveOrNegative = firstIsMorePositiveOrNegative\
    \ || secondIsMorePositiveOrNegative && ((firstIsMorePositiveOrNegative) && secondIsMorePositiveOrNegative)\n\
    \        val allAreNegativeOrPositiveOrBothAreMorePositiveOrNegative = first",
  "        def largestOfInt(lst : List[Long]) : Option[Long] = {\n            for\
    \ (i <- lst) yield if (i >= 0) i else None\n        }\n        val positives =\
    \ largestOfInt(lst)\n        val negatives = lst.filter(_ >= 0)\n        val minNegative\
    \ = negatives.min\n        val maxPositive = positives.max\n        if (minNegative.isEmpty\
    \ || maxPositive.isEmpty) return (None, None)\n        return (Some(maxPositive),\
    \ Some(minNegative))", "      val (min, max) = lst.foldLeft((None, Long.MaxValue))\
    \ {\n        case ((Some(x), y), x) if x < y => (Some(x), y)\n        case ((None,\
    \ x), y) => (y, x)\n      }\n      (Some(min), Some(max))", "        var biggestInt\
    \ : Option[Long] = None\n        var smallestInt : Option[Long] = None\n     \
    \   var i : Int = 0\n        while (i < lst.size){\n            if (lst(i) < 0l){\n\
    \                if (biggestInt.isEmpty || biggestInt.get < lst(i)){\n       \
    \             biggestInt = Some(lst(i))\n                }\n            }\n  \
    \          if (lst(i) > 0l){\n                if (smallestInt.isEmpty || smallestInt.get\
    \ > lst(i)){\n                    smallestInt = Some(lst(i))\n               \
    \ }\n            }\n            i += 1\n        }\n        if ((biggestInt ==\
    \ None) || (smallestInt == None) || (biggestInt.get.equals(smallestInt.get))){\n\
    \            return (None, None)\n        }\n        return (Some(biggestInt.get),\
    \ Some(smallestInt.get))", "        val negInts = lst.filter( x => x < 0l )\n\
    \        val posInts = lst.filter( x => x >= 0l )\n\n        if (negInts.isEmpty)\
    \ {\n            return (None,None)\n        }\n        if (posInts.isEmpty) {\n\
    \            return (Some(negInts.min), Some(negInts.max))\n        }\n      \
    \  val negMin = negInts.min\n        val negMax = negInts.max\n        val posMin\
    \ = posInts.min\n        val posMax = posInts.max\n\n        if (negMin > negMax)\
    \ {\n            return (Some(negMax), Some(negMin))\n        } else if (posMin\
    \ < posMax) {\n            return (Some(posMin), Some(posMax))\n        }\n  \
    \      val ints = (negMin, negMax)\n        if (negMax.compare(posMin) < 0) {\n\
    \            ints = (negMin, posMin)\n        }\n        if (negMin.compare(posMax)\
    \ > 0) {\n            ints = (negMax, posMax)\n        }\n        (ints.max max\
    \ ints.min min ints.maxOption, ints.min min ints.max maxOption)", "        //\
    \ Sort the list and keep track of where each element lies.\n        val sorted\
    \ = lst.sortWith(_.compareTo(_) < 0)\n        val sortedIdx = sorted.zipWithIndex\n\
    \n        // Loop over the sorted list, keeping track of the largest and smallest\
    \ values\n        var smallestValue = sortedIdx(0)._2 //None\n        var largestValue\
    \ = sortedIdx(sortedIdx.size - 1)._2 //None\n\n        for (i <- 1 to sorted.size-1)\
    \ {\n            // If the current value is smaller than the smallest we've seen\
    \ so far,\n            // store the smallest value and mark that we've seen it\n\
    \            if (sortedIdx(i)._2 < smallestValue) {\n                smallestValue\
    \ = sortedIdx(i)._2\n            }\n            // If the current value is larger\
    \ than the largest we've seen so far,\n            // store the largest value\
    \ and mark that we've seen it\n            if (sortedIdx(i)._2 > largestValue)\
    \ {\n                largestValue = sortedIdx(i)._2\n            }\n        }\n\
    \        // If we haven't seen any positive and no negative values, return None\n\
    \        if (smallestValue == None) None else if (largestValue == None) Some(None)\
    \ else (Some(smallestValue), Some(largestValue))", "        val n = lst.size\n\
    \        val n = n - 1\n        var smallest = Option.empty[Long]\n        var\
    \ largest = Option.empty[Long]\n        for(i <- 0 until n) {\n            val\
    \ current = lst(i)\n            if(current.isLessThanOrEqualTo(0)) {\n       \
    \         smallest = current\n            } else {\n                largest =\
    \ current\n            }\n        }\n        (smallest, largest)", "      lst.foldLeft(\n\
    \        (Some(None): Option[Long], Some(None): Option[Long]),\n        (acc,\
    \ i) => {\n          val maxPosInt = (acc max i)\n          val minNegInt = (acc\
    \ min i)\n          if (maxPosInt > 0 || minNegInt < 0) {\n            (Some(maxPosInt),\
    \ Some(minNegInt))\n          } else {\n            (None, Some(i))\n        \
    \  }\n        })", "        var largest = lst.headOption\n        var smallest\
    \ = lst.lastOption\n        for(i<-lst.indices) largest = lst.applyOrElse(i, largest)\n\
    \        for(i<-lst.indices) smallest = lst.applyOrElse(i, smallest)\n       \
    \ if (largest.isEmpty || smallest.isEmpty) None else (Some(largest), Some(smallest))",
  "        def largest(l : List[Long]) : Option[Long] = {\n            if (l.isEmpty)\
    \ None\n            else Some(l.max)\n        }\n        def smallest(l : List[Long])\
    \ : Option[Long] = {\n            if (l.isEmpty) None\n            else Some(l.min)\n\
    \        }\n        val max = largest(lst.filter(_.isNegative))\n        val min\
    \ = smallest(lst)\n        (max, min)", "        val n = lst.size\n        val\
    \ sorted = lst.sortBy(x => x)\n        var firstPosInList = false\n        var\
    \ firstNegInList = false\n        var lastPosInList = false\n        var lastNegInList\
    \ = false\n        var firstPosInArray = false\n        var firstNegInArray =\
    \ false\n        var lastPosInArray = false\n        var lastNegInArray = false\n\
    \n        for (i <- 0 until n) {\n            if (sorted(i) < 0) {\n         \
    \       if (firstPosInList == false) {\n                    firstPosInList = i\n\
    \                }\n                lastPosInList = i\n            } else if (sorted[i]\
    \ > 0) {\n                if (firstNegInList == false) {\n                   \
    \ firstNegInList = i\n                }\n                lastNegInList = i\n \
    \           } else {\n                if (firstPosInArray == false) {\n      \
    \              firstPosInArray = i\n                }\n                lastPosInArray\
    \ = i\n                if (firstNegInArray == false) {\n                    firstNegInArray\
    \ = i\n                }\n                lastNegInArray = i\n            }\n\
    \        }\n\n        if (firstNegInList == false && firstNegInArray == false)\
    \ return (None, None)\n        if (firstPosInList == false && firstPosInArray\
    \ == false) return (None, None)\n\n        if ((firstNegInList != lastNegInArray)\
    \ || (firstPosInList != lastPosInArray)) {\n            return (None, None)\n\
    \        }\n\n        if (lastNegInList == 0) return (None, None)\n        if\
    \ (lastPosInList == 0) return (None, None)\n\n        return (Some(sorted(firstNegInList).last),\
    \ Some(sorted(lastPosInList).first))", "        def largestPositive(lst : List[Long])\
    \ : List[Long] = {\n            val max = lst.foldLeft(List[Long](0l))(_ + _)\n\
    \            val res = lst filter (_ > max) ::: List(max) \n            res\n\
    \        }\n        def largestNegative(lst : List[Long]) : List[Long] = {\n \
    \           val max = lst.foldLeft(List[Long](0l))(_ + _)\n            val res\
    \ = lst filter (_ < max) ::: List(max) \n            res\n        }\n        if\
    \ (lst exists _ > 0l)\n            (Some(largestPositive(lst filter (_ > 0l))),\
    \ Some(largestPositive(lst filter (_ < 0l))))\n        else if (lst exists _ <\
    \ 0l)\n            (Some(largestNegative(lst filter (_ > 0l))), Some(largestNegative(lst\
    \ filter (_ < 0l))))\n        else\n            None", "        val positive =\
    \ lst.filter(_ > 0).toList\n        val negative = lst.filter(_ < 0).toList\n\
    \        positive.foldLeft(None, Some(0)){ case (maxPos, pos) if maxPs.isEmpty\
    \ || pos > maxPs(1) => (Some(pos), maxPos) }\n        negative.foldLeft(Some(0),\
    \ None){ case (minPos, neg) if minPs.isEmpty || neg < minPs(1) => (Some(minPos),\
    \ neg)}", "        val negative = lst.filter(_ < 0).toList\n        val positive\
    \ = lst.filter(_ >= 0).toList\n        if (negative.isEmpty && positive.isEmpty)\n\
    \            (None, None)\n        else if (negative.isEmpty)\n            (Some(positive.min),\
    \ Some(negative.max))\n        else if (positive.isEmpty)\n            (Some(negative.max),\
    \ Some(positive.min))\n        else\n            (Some(positive.min), Some(negative.max)).unzip",
  "        val (smalls, larges) = (lst.filter(_ <= 0l), lst.filter(_ > 0l))\n    \
    \    smalls.min match {\n            case Some(small) if small > larges => (Some(small),\
    \ Some(larges))\n            case _ => (None, Some(larges.min))\n        }", " \
    \       val negative = lst.filter(_ < 0l)\n        val positive = lst.filter(_\
    \ > 0l)\n        if (negative.isEmpty && positive.isEmpty) {\n            (None,\
    \ None)\n        } else if (negative.isEmpty) {\n            (None, positive.minBy(_.toLong))\n\
    \        } else {\n            (Some(negative.minBy(_.toLong)), Some(positive.maxBy(_.toLong)))\n\
    \        }", "        val negativeInts = lst.filter(x => x < 0l)\n        val\
    \ positiveInts = lst.filter(x => x > 0l)\n        if(negativeInts.isEmpty) \n\
    \            (Some(None), Some(None))\n        else if (positiveInts.isEmpty)\n\
    \            (Some(None), Some(None))\n        else\n            (Some(positiveInts.max),\
    \ Some(negativeInts.min))", "        def largestPositive(l: List[Long], acc: Option[Long])\
    \ = l.headOption.filter(_ > 0).map(acc)\n        def largestNegative(l: List[Long],\
    \ acc: Option[Long]) = l.headOption.filter(_ < 0).map(acc)\n        def smallestPositive(l:\
    \ List[Long], acc: Option[Long]) = l.headOption.filter(_ >= 0).map(acc)\n    \
    \    def smallestNegative(l: List[Long], acc: Option[Long]) = l.headOption.filter(_\
    \ <= 0).map(acc)\n        largestPositive(lst, None) match {\n            case\
    \ None => smallestNegative(lst, None)\n            case Some(x) => smallestPositive(lst,\
    \ x)\n        }\n        largestNegative(lst, None) match {\n            case\
    \ None => smallestPositive(lst, None)\n            case Some(x) => smallestNegative(lst,\
    \ x)\n        }", "        val numbers = lst.filter(_ > 0).filter(_ < Integer.MAX_VALUE).sorted\n\
    \        if (numbers.isEmpty) None\n        else (Some(numbers.last), Some(numbers.first))",
  "        if (lst.nonEmpty) {\n            val posSum = lst.filter(_ > 0l).sum\n\
    \            val negSum = lst.filter(_ < 0l).sum\n            val posSumAbs =\
    \ lst.filter(_ > 0l).abs.sum\n            val negSumAbs = lst.filter(_ < 0l).abs.sum\n\
    \            val max = if (negSumAbs > posSumAbs) negSum else posSum\n       \
    \     val min = if (posSumAbs < negSumAbs) posSum else negSum\n            (Some(max),\
    \ Some(min))\n        }\n        else {\n            (None, None)\n        }",
  '        lst.foldLeft((None,None))((a, b) => a.map(_ > b).getOrElse(b).map(_ < a).getOrElse(a))',
  "        if (lst.isEmpty) \n            ((None,None), None)\n        else if (lst.head.compareTo(0l)\
    \ < 0)\n            ((Some(None),None), (Some(lst.head), None))\n        else\n\
    \            largestSmallestIntegersHelper(lst, lst.head)", "        val negIntegers\
    \ = lst.filter(_ < 0L)\n        val posIntegers = lst.filter(_ > 0L)\n\n     \
    \   // If there is no negative or positive integers, return them as None\n   \
    \     val ans = if (negIntegers.isEmpty) None else Some(negIntegers.max)\n   \
    \     val ans2 = if (posIntegers.isEmpty) None else Some(posIntegers.min)\n\n\
    \        (ans, ans2)", "        val (small, large) = lst.partition(_.isPositive)\n\
    \        val negative = (small.lastOption, large.headOption)\n        val none\
    \ = (None, None) match {\n            case (Some(e1), Some(e2)) => Some(e1.toLong\
    \ - e2.toLong)\n            case (_, _) => None\n        }\n        negative match\
    \ {\n            case (Some(e1), Some(e2)) => Some(Some(e1), Some(e2))\n     \
    \       case (_, None) => Some(none, none)\n            case (None, _) => Some(none,\
    \ none)\n        }", "        val positiveInts = lst.filter(_.toInt < 0)\n   \
    \     val negativeInts = lst.filter(_.toInt > 0)\n\n        if (positiveInts.isEmpty)\n\
    \            (None, None)\n\n        else {\n            val maxPos = positiveInts.maxBy(_.toInt)\n\
    \            val minNeg = negativeInts.minBy(_.toInt)\n\n            (Some(maxPos.toLong),\
    \ Some(minNeg.toLong))\n        }", "        val lb = lst.minBy(math.abs)\n  \
    \      val ub = lst.maxBy(math.abs)\n        (Some(lb), Some(ub))", "        if(lst.isEmpty)\
    \ return (None, None)\n        val n = lst.head\n        val max_neg = lst.filter(_\
    \ < 0).max\n        val min_pos = lst.filter(_ > 0).min\n        if(max_neg.isEmpty\
    \ && min_pos.isEmpty) {\n            return (None, None)\n        }\n        if(max_neg.isEmpty\
    \ && min_pos.nonEmpty) {\n            return (Some(n), None)\n        }\n    \
    \    if(max_neg.nonEmpty && min_pos.isEmpty) {\n            return (None, Some(n))\n\
    \        }\n        if(max_neg.nonEmpty && min_pos.nonEmpty) {\n            return\
    \ (Some(n), Some(max_neg))\n        }", "      val max: Option[Long] = lst.maxBy\
    \ { x => -x}\n      val min: Option[Long] = lst.minBy { x => x}\n      (max, min)",
  "        val posInt = lst.filter(x => x < 0)\n        val negInt = lst.filter(x\
    \ => x >= 0)\n        if (posInt.isEmpty) None\n        else {\n            val\
    \ firstPosInt = posInt.min\n            val firstNegInt = negInt.min\n       \
    \     val secondPosInt = posInt.filter(x => x < firstPosInt)\n            val\
    \ secondNegInt = negInt.filter(x => x < firstNegInt)\n            val thirdPosInt\
    \ = posInt.filter(x => x > firstPosInt && x < secondPosInt)\n            val thirdNegInt\
    \ = negInt.filter(x => x > firstNegInt && x < secondNegInt)\n            if (secondPosInt.isEmpty)\
    \ Some(firstPosInt)\n            else {\n                if (thirdPosInt.isEmpty)\
    \ Some(firstNegInt)\n                else {\n                    val largestPosInt\
    \ = thirdPosInt.max\n                    val largestNegInt = thirdNegInt.max\n\
    \                    (Some(largestPosInt), Some(largestNegInt))\n            \
    \    }\n            }\n        }", "        var max: Option[Long] = None\n   \
    \     var min: Option[Long] = None\n        for(x<-lst){\n            if(!x.isNegative){\n\
    \                if(!max.isEmpty && max < x){\n                    max = None\n\
    \                }\n                if(!min.isEmpty && min > x){\n           \
    \         min = None\n                }\n            }else{\n                if(max.isEmpty\
    \ && x != 0){\n                    max = Some(x)\n                }\n        \
    \        if(min.isEmpty && x != 0){\n                    min = Some(x)\n     \
    \           }\n            }\n        }\n        if(max.isEmpty && min.isEmpty)\
    \ return (None, None)\n        return (max, min)", "        lst.foldLeft((None,\
    \ None)){\n          case ((a, b), x) =>\n            if (x < 0l && b == None)\
    \ (a, b)\n            else if (b == None) (a, b)\n            else (a, b)\n  \
    \      }", "        val positive = lst.filter(_.toLong > 0l)\n        val negative\
    \ = lst.filter(_.toLong < 0l)\n        val positiveIntegersCount = positive.map(_.toInt).sum\n\
    \        val negativeIntegersCount = negative.map(_.toInt).sum\n        val maximum\
    \ = if (positiveIntegersCount == 0) None else positive.max // O(n), so O(n^2)\n\
    \        val minimum = if (negativeIntegersCount == 0) None else negative.min\
    \ // O(n), so O(n^2)\n        (maximum, minimum)", "        if (lst.isEmpty) {\n\
    \            return (None, None)\n        }\n\n        var largest = None\n  \
    \      var smallest = None\n\n        for(ix <- 0 until lst.size) {\n        \
    \    val v = lst(ix)\n            if (v < 0 && largest == None) {\n          \
    \      largest = v\n            } else if (v > 0 && smallest == None) {\n    \
    \            smallest = v\n            }\n        }\n\n        (largest, smallest)",
  "        var bestA = None\n        var bestB = None\n        lst.foreach(x => {\
    \ \n            if(x<0) bestA = Some(x); \n            if(x>0) bestB = Some(x)\
    \ \n        })\n        (bestA, bestB)", "        lst.sortWith( (a, b) => b.compareTo(a)\
    \ < 0)\n        val positive = lst.takeWhile(x => x < 0l)\n        val negative\
    \ = lst.dropWhile(x => x < 0l)\n        if (negative.isEmpty) ( Some(None) , Some(None)\
    \ )\n        else if (positive.isEmpty) ( Some(None) , Some(None) )\n        else\
    \ ( Some(positive.last) , Some(negative.head))", "        val negativeLst : mutable.Buffer[Long]\
    \ = mutable.Buffer[Long]()\n        val positiveLst : mutable.Buffer[Long] = mutable.Buffer[Long]()\n\
    \n        lst.foreach { number => \n            if (number < 0l) {\n         \
    \       negativeLst += number\n            }\n            if (number > 0l) {\n\
    \                positiveLst += number\n            }\n        }\n\n        (\n\
    \            Some(negativeLst.maxBy(_.toInt)), \n            Some(positiveLst.minBy(_.toInt))\n\
    \        )", "        val mn = lst.head\n        val mx = lst.last\n\n       \
    \ if (mx < 0L && mx >= 0L) Some(mx) else if (mn > 0L && mn > 0L) Some(mn) else\
    \ None", "        val max = -sys.maxLong\n        val min = sys.maxLong\n    \
    \    lst.foreach{x =>\n            val nx = math.abs(x)\n            if (nx<min)\
    \ {min = nx}\n            if (nx>max) {max = nx}\n        }\n        if (min<0)\
    \ {min = None}\n        if (max>0) {max = None}\n        (min, max)", "      \
    \  if (lst.isEmpty) return (None, None)\n        var smallestPositive = Some(1L)\n\
    \        var smallestNegative = Some(1L)\n        var largest = None\n       \
    \ lst.foreach(i => {\n            if (i < 0L) smallestNegative = Some(i)\n   \
    \         if (i > 0L) smallestPositive = Some(i)\n            if (largest == None)\
    \ largest = Some(i)\n            if (smallest == None) {\n                if (i\
    \ >= 0L) {\n                    largest = Some(i)\n                }\n       \
    \     }\n        })\n        return (smallestPositive, smallestNegative)", " \
    \       // Code goes here\n        val max = 0\n        val min = sys.maxsize\n\
    \        for (i <- 0 until lst.size) {\n            if (lst(i) < min) min = lst(i)\n\
    \            if (lst(i) > max) max = lst(i)\n        }\n        (Some(max), Some(min))",
  "        val (minus, pos) = lst.partition(i => i < 0l)\n        (\n            Some(minus.toList.max)\n\
    \            if (minus.isEmpty) None else Some(minus.min),\n            Some(pos.toList.min)\n\
    \            if (pos.isEmpty) None else Some(pos.max)\n        )", "        //\
    \ Create a mutable map that stores the negative and positive numbers\n       \
    \ // indexed by a counter.\n        val negativeAndPositive = {\n            var\
    \ counter = 0\n            lst.map { number => if (number < 0) counter += 1 else\
    \ counter = 0 }\n        }\n        // Scan through the map to find the largest\
    \ negative and the smallest positive number\n        negativeAndPositive.scanLeft(Option.empty[Long],\
    \ Option.empty[Long]){ case (negativeAndPositivePositive, negativeAndPositiveNegative)\
    \ if negativeAndPositivePositive.isEmpty => None }", "        val positive = lst.filter(_\
    \ > 0).toSet\n        val negative = lst.filter(_ < 0).toSet\n        val smallest\
    \ = if (positive.isEmpty && negative.isEmpty)\n            None\n        else\n\
    \            Some(negative.min)\n        val largest = if (positive.isEmpty &&\
    \ negative.isEmpty)\n            None\n        else\n            Some(positive.max)\n\
    \        (smallest, largest)", "        // We will need to add new element to\
    \ the list only once.\n        val smallestNegativeLong = Some(0l)\n        val\
    \ largestPositiveLong = Some(-1l)\n        if (lst.exists(_ < 0l)) {\n       \
    \     smallestNegativeLong :+= 0l\n        } else if (lst.exists(_ > 0l)) {\n\
    \            largestPositiveLong :+= 1l\n        } else {\n            smallestNegativeLong\
    \ :+= None\n            largestPositiveLong :+= None\n        }\n        (smallestNegativeLong,\
    \ largestPositiveLong)", "        var max = lst.head\n        var min = lst.head\n\
    \        for (_ <- lst ) {\n            if (_ > max)\n                max = _\n\
    \            if (_ < min)\n                min = _\n        }\n        (Some(max),\
    \ Some(min))", "        if (lst.isEmpty) \n            (None, None)\n        else\
    \ if (lst.head < 0l)\n            (Some(lst.head), None)\n        else\n     \
    \       {\n                var min: Long = lst.head\n                var max:\
    \ Long = lst.head\n                lst foreach { x =>\n                    if\
    \ (x < 0l)\n                        max = x\n                    else if (x >\
    \ 0l)\n                        min = x\n                }\n                (Some(min),\
    \ Some(max))\n            }", "        val positiveInts : List[Long] = lst.filter(_\
    \ > 0)\n        val negativeInts : List[Long] = lst.filter(_ < 0)\n        if(positiveInts.isEmpty)\n\
    \            (Some(None), Some(None))\n        else if(negativeInts.isEmpty)\n\
    \            (Some(positiveInts.head), None)\n        else\n            (Some(positiveInts.max),\
    \ Some(negativeInts.min))", "        val positiveInts = lst.filter(_ > 0L)\n \
    \       val negativeInts = lst.filter(_ < 0L)\n        positiveInts match {\n\
    \            case Nil => (None, None)\n            case x::xs => if (x < 0L) None\
    \ else Some(x.toLong)\n            case _ => negativeInts match {\n          \
    \      case Nil => (None, None)\n                case x::xs => if (x > 0L) None\
    \ else Some(x.toLong)\n                case _ => largestSmallestIntegers(xs)\n\
    \            }\n        }", "        // Create a mutable list of negative integers.\n\
    \        var negInts = mutable.ListBuffer[Long]()\n        // Create a mutable\
    \ list of positive integers.\n        var posInts = mutable.ListBuffer[Long]()\n\
    \        // Loop through the list and add to the lists depending on whether it\
    \ is positive or negative\n        lst.foreach( x => {\n            if (x < 0)\
    \ negInts += x.toLong\n            else posInts += x.toLong\n        })\n\n  \
    \      // Find the max and min.\n        var maxPosInt = posInts.reduce((x, y)\
    \ => if (x > y) x else y)\n        var minNegInt = negInts.reduce((x, y) => if\
    \ (x < y) x else y)\n        // Return if no values exist to make the function\
    \ return None\n        if (maxPosInt == 0) (Some(None), Some(None))\n        else\
    \ if (minNegInt == 0) (Some(None), Some(None))\n        else (Some(maxPosInt),\
    \ Some(minNegInt))", "        val negativeIntegers : List[Long] = lst.filter(_\
    \ < 0l)\n        val positiveIntegers : List[Long] = lst.filter(_ >= 0l)\n   \
    \     if(negativeIntegers.length == 0 && positiveIntegers.length == 0) {\n   \
    \         None // both negative and positive integers are empty lists\n      \
    \  } else {\n            // sort negative integers descending\n            val\
    \ sortedNegativeIntegers = negativeIntegers.sortWith((x, y) => y - x)\n      \
    \      // sort positive integers descending\n            val sortedPositiveIntegers\
    \ = positiveIntegers.sortWith((x, y) => y - x)\n            // return largest\
    \ (positive) integer, and smallest (negative) integer\n            Some(sortedPositiveIntegers.last)\
    \ match {\n                case None =>\n                    Some(sortedNegativeIntegers.head)\n\
    \                case Some(x) => \n                    None\n            }\n \
    \       }", "        if (lst.size == 0) (None, None)\n        else {\n       \
    \     val positive = lst.filter(_.isPositive)\n            val negative = lst.filter(_.isNegative)\n\
    \            val biggest = if (positive.size < negative.size) positive.head else\
    \ negative.head\n            val smallest = if (positive.size == negative.size)\
    \ None\n                            else {\n                                if\
    \ (positive.size < negative.size) None\n                                else positive.last\n\
    \                            }\n            (biggest, smallest)\n        }", " \
    \       val positives  = lst.filter( _ > 0)\n        val negatives  = lst.filter(\
    \ _ < 0)\n        val smallMin   = Math.min(positives.min, negatives.min)\n  \
    \      val largeMax   = Math.max(positives.max, negatives.max)\n        positives.exists(\
    \ _ == smallMin) ? Some(largeMax) : Some(smallMin)", "      if(lst.isEmpty) \n\
    \        (None, None)\n      else if(lst.head.isNegative) \n        (Some(lst.sorted.head),\
    \ None)\n      else \n        (None, Some(lst.sorted.head))", "        lst.foldLeft((None,\
    \ Option.empty[Long])) {\n            case ((maxv, m), v) if v < 0l => (v, m)\n\
    \            case ((maxv, m), v) if v > maxv => (maxv, m)\n            case ((maxv,\
    \ m), v) => (v, m)\n        }", "        var posInts = Set[Long]()\n        var\
    \ negInts = Set[Long]()\n        lst.foreach { x =>\n            if (x < 0l) {\n\
    \                negInts += x\n            } else if (x > 0l) {\n            \
    \    posInts += x\n            }\n        }\n        if (negInts.isEmpty) {\n\
    \            return (None, None)\n        }\n        var maxInts = negInts.max\n\
    \        var minInts = negInts.min\n        negInts.foreach { x =>\n         \
    \   if (x > maxInts) {\n                maxInts = x\n            }\n        }\n\
    \        if (maxInts > 0l) {\n            return (Some(maxInts), None)\n     \
    \   }\n        minInts = posInts.min\n        posInts.foreach { x =>\n       \
    \     if (x < minInts) {\n                minInts = x\n            }\n       \
    \ }\n        return (None, Some(minInts))", "        val min = lst.min\n     \
    \   val max = lst.max\n        if (min >= max) Tuple2(Some(max), Some(min))\n\
    \        else largestSmallestIntegers(lst.filter(_ > min))", "        val a =\
    \ lst.filter(_ < 0).sortBy(_).lastOption\n        val b = lst.filter(_ > 0).sortBy(_).firstOption\n\
    \        (a.getOrElse(None), b.getOrElse(None))", "        val negLst = lst.filter(num\
    \ => num < 0l)\n        val posLst = lst.filter(num => num > 0l)\n        if (negLst.size\
    \ < posLst.size) {\n            val result = negLst.headOption match {\n     \
    \           case None => posLst.headOption\n                case Some(_) => None\n\
    \            }\n            (result, Some(negLst.lastOption))\n        }\n   \
    \     else {\n            val result = posLst.headOption match {\n           \
    \     case None => negLst.lastOption\n                case Some(_) => None\n \
    \           }\n            (result, Some(posLst.lastOption))\n        }", "  \
    \      val posInts = lst.filter(_ > 0).toList\n        val negInts = lst.filter(_\
    \ < 0).toList\n\n        if (posInts.isEmpty() && negInts.isEmpty()) {\n     \
    \       (Some(None), Some(None))\n        } else if (posInts.isEmpty()) {\n  \
    \          (None, negInts.head)\n        } else if (negInts.isEmpty()) {\n   \
    \         (posInts.head, None)\n        } else {\n            val posSmallestInt\
    \ = posInts.min\n            val negSmallestInt = negInts.min\n\n            (Some(posSmallestInt),\
    \ Some(negSmallestInt))\n        }", "        val m = lst.foldLeft(None)((max,\
    \ min) =>\n            if (min.isEmpty && max.isDefined) Some(max.toLong)\n  \
    \          if (max.isDefined && min.isDefined && max.toLong < min.toLong) Some(max.toLong)\n\
    \            if (min.isDefined && max.isDefined && min.toLong > max.toLong) Some(min.toLong)\n\
    \            else\n                if (max.isDefined) Some(max.toLong)\n     \
    \           else if (min.isDefined) Some(min.toLong)\n                else None\n\
    \        )\n        (m, None)", "        val positiveIntegers = lst.filter(i =>\
    \ i >= 0).toList\n        val negativeIntegers = lst.filter(i => i < 0).toList\n\
    \        if (positiveIntegers.isEmpty) {\n            (None, Some(None))\n   \
    \     } else if (negativeIntegers.isEmpty) {\n            (Some(positiveIntegers.head),\
    \ None)\n        } else {\n            (Some(positiveIntegers.max), Some(negativeIntegers.min))\n\
    \        }", "      if (lst.isEmpty) {\n        (None, None)\n      } else if\
    \ (lst.head < 0) {\n        val max = lst.lastOption\n        (Some(max.filter(_\
    \ >= 0)), None)\n      } else {\n        val min = lst.headOption\n        (None,\
    \ Some(min.filter(_ <= 0)))\n      }"]
stop_tokens:
- "\n    }\n"
