name: HumanEval_110_exchange
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // In this problem, you will implement a function that takes two lists of numbers,\n\
  \    // and determines whether it is possible to perform an exchange of elements\n\
  \    // between them to make lst1 a list of only even numbers.\n    // There is\
  \ no limit on the number of exchanged elements between lst1 and lst2.\n    // If\
  \ it is possible to exchange elements between the lst1 and lst2 to make\n    //\
  \ all the elements of lst1 to be even, return \"YES\".\n    // Otherwise, return\
  \ \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n\
  \    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n    //\
  \ (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n    def\
  \ exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
  NO\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
  \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
  \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
  \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
  NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
  \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
  \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n \
  \   }\n\n}\n"
completions: ["        // Solution goes here\n        val set1 = lst1.toSet\n    \
    \    val set2 = lst2.toSet\n        if (set1.size < set2.size) {\n           \
    \ if (set1.size + set2.size > 1) {\n                if (set2.contains(\"even\"\
    ) && set1.contains(\"even\")) {\n                    return \"YES\"\n        \
    \        }\n            }\n            else {\n                if (set1.contains(\"\
    even\") && set2.contains(\"even\")) {\n                    return \"YES\"\n  \
    \              }\n            }\n        }\n        else {\n            if (set2.size\
    \ + set1.size > 1) {\n                if (set2.contains(\"even\") && set1.contains(\"\
    even\")) {\n                    return \"YES\"\n                }\n          \
    \  }\n            else {\n                if (set1.contains(\"even\") && set2.contains(\"\
    even\")) {\n                    return \"YES\"\n                }\n          \
    \  }\n        }\n        return \"NO\"", "        if (lst1.isEmpty) {\n      \
    \      if (lst2.isEmpty) {\n                return \"NO\"\n            }\n   \
    \         return \"YES\"\n        }\n        if (lst2.isEmpty) {\n           \
    \ return \"YES\"\n        }\n        if (lst1.head < lst2.head) {\n          \
    \  return \"YES\"\n        }\n        // if (lst1.head > lst2.head) {\n      \
    \  //    return \"NO\"\n        // }\n        if (lst1.head == lst2.head && lst1.head\
    \ % 2 == 0) {\n            return \"YES\"\n        }\n        // if (lst1.head\
    \ != lst2.head && lst1.head % 2 == 0) {\n        //    return \"NO\"\n       \
    \ // }\n        var exchange = false\n        lst1.foreach(x => {\n          \
    \  if (lst2.exists(y => x == y))\n                exchange = true\n        })\n\
    \        if (exchange) {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"", "        if(lst1.isEmpty) lst2\n        else {\n            val evens\
    \ = lst1.filter(x => x % 2 == 0l)\n            val evensB = evens.toList\n   \
    \         val odds = lst1.filter(x => x % 2 != 0l)\n            val oddsB = odds.toList\n\
    \            evensB.map(x => {\n                val tmp = lst2\n             \
    \   lst2 = lst2.filterNot(x => x == x)\n                lst2 += x\n          \
    \      lst2 += tmp\n            })\n            oddsB.map(x => {\n           \
    \     val tmp = lst2\n                lst2 = lst2.filterNot(x => x == x)\n   \
    \             lst2 += x\n                lst2 += tmp\n            })\n       \
    \     val evensA = evens.toList\n            val oddsA = lst1.filter(x => x %\
    \ 2 == 0l)\n            val evensList = evensA.zipWithIndex.filter(x => x._2 ==\
    \ 0).map {\n                x => x._1\n            }\n            val oddsList\
    \ = oddsA.zipWithIndex.filter(x => x._2 == 1).map {\n                x => x._1\n\
    \            }\n            if(evensList.forall(x => x == x)) \"YES\"\n      \
    \      else exchange(evensList, oddsList)\n        }", "        var list1 = lst1\n\
    \        var list2 = lst2\n        var i = 0\n        var j = 0\n        val lst3=\
    \ List[Long]()\n        var flag = if (list1.length == 0) list2 else list1\n \
    \       while(flag != List())\n        {\n            if(flag(j) % 2 == 1)\n \
    \           {\n                list1 =  list1.drop(j)\n            }\n       \
    \     else\n            {\n                list2 =  list2.drop(j)\n          \
    \  }\n            j+=1\n        }\n        if (list1 != List() || list2 != List())\n\
    \        {\n            lst3 =  list1.intersect(list2)\n            if (lst3 !=\
    \ List())\n            {\n                val lst4 = lst3.toList.sortBy(_ % 2)\n\
    \                if (lst4.size == list1.length)\n                {\n         \
    \           return \"YES\"\n                }\n                else\n        \
    \        {\n                    return \"NO\"\n                }\n           \
    \ }\n        }\n        else\n        {\n            return \"NO\"\n        }",
  "        // O(n2) code\n        // (use two nested loops over the two lists)\n \
    \       // sort the two lists\n        val lst1_sorted = lst1.toList.sort\n  \
    \      val lst2_sorted = lst2.toList.sort\n        // loop over lst2\n       \
    \ for(x <- lst2_sorted) {\n            // loop over lst1\n            for(y <-\
    \ lst1_sorted) {\n                // if the lists are equal, return\n        \
    \        if(lst1_sorted == lst2_sorted) {\n                    return \"YES\"\n\
    \                }\n                // if the lists differ in one element and\
    \ y, return\n                else if(lst1_sorted(x) != lst2_sorted(y)) {\n   \
    \                 return \"NO\"\n                }\n            }\n        }\n\
    \        \"NO\"", "        var result : Boolean = false\n        var list1_count\
    \ = 0\n        var list2_count = 0\n        for(i <- 0 to lst1.length - 1) {\n\
    \            if(lst1(i % 2) != 0) {\n                result = (lst1(i % 2) !=\
    \ lst2(i % 2))\n            } else {\n                result = (lst1(i % 2) ==\
    \ lst2(i % 2))\n            }\n            list1_count = list1_count + (result\
    \ ? 1 : 0)\n        }\n        list2_count = 0\n        for(i <- 0 to lst2.length\
    \ - 1) {\n            if(lst2(i % 2) != 0) {\n                result = (lst1(i\
    \ % 2) != lst2(i % 2))\n            } else {\n                result = (lst1(i\
    \ % 2) == lst2(i % 2))\n            }\n            list2_count = list2_count +\
    \ (result ? 1 : 0)\n        }\n        if((list1_count == lst1.length) && (list2_count\
    \ == lst2.length)) {\n            return \"YES\"\n        } else {\n         \
    \   return \"NO\"\n        }", "        // Your code here\n        val arr1 =\
    \ lst1.toArray\n        val arr2 = lst2.toArray\n        if(arr1.length == 0 ||\
    \ arr2.length == 0)\n            return \"NO\"\n        val ls = arr2.toList.sortWith(_\
    \ > _)\n        var j = 0\n        var i = 0\n        var evenArr = 0\n      \
    \  var evenLst2 = 0\n        var evenLst1 = 0\n        while(i < arr1.length)\
    \ {\n            if(arr1(i) % 2 == 0) {\n                evenArr += arr1(i)\n\
    \                evenLst2 += arr2(j)\n                j += 1\n            }\n\
    \            i += 1\n        }\n        i = arr2.length\n        while(i < arr2.length)\
    \ {\n            if(arr2(i) % 2 == 0) {\n                evenArr += arr2(i)\n\
    \                evenLst1 += arr1(i)\n                i += 1\n            }\n\
    \            i += 1\n        }\n        if (evenArr % evenLst1 == 0 && evenArr\
    \ % evenLst2 == 0)\n            return \"YES\"\n        else\n            return\
    \ \"NO\"", "        // your code here\n        var lst3 = lst1.toList\n      \
    \  var lst4 = lst2.toList\n        var exchanged = false\n        var even = false\n\
    \        var first = true\n        var second=true\n        while(lst3.length>0\
    \ && !lst4.isEmpty){\n            if(first){\n                if(lst3.head.isEven){\n\
    \                    lst3 = lst3.tail\n                    lst4 = lst4.tail\n\
    \                    exchanged = true\n                }\n                else{\n\
    \                    lst3 = lst3.tail\n                    lst4 = lst4.tail\n\
    \                    even = false\n                }\n                first =\
    \ false\n            }\n            if(lst4.head.isEven){\n                lst4\
    \ = lst4.tail\n                even = true\n            }\n            else if(even){\n\
    \                lst4 = lst4.tail\n                even = false\n            }\n\
    \        }\n        if(exchanged || even ){\n            return \"YES\"\n    \
    \    }\n        return \"NO\"", "        var lst1 = lst1.toSet\n        var lst2\
    \ = lst2.toSet\n        if (lst1 == lst2) {\n            return \"NO\"\n     \
    \   }\n        if (lst1.isEmpty)\n            return \"NO\"\n        if (lst2.isEmpty)\n\
    \            return \"NO\"\n        val result = lst1 & lst2\n        result.forall(x\
    \ => x % 2 == 0) match {\n            case false => \"NO\"\n            case true\
    \ => \"YES\"\n        }", "        if(lst1.isEmpty) lst2.toList.mkString(\",\"\
    )\n        else if(lst2.isEmpty) lst1.toList.mkString(\",\")\n        else if(lst1.tail.isEmpty)\
    \ exchange(lst1.tail, lst2.tail).mkString(\",\")\n        else exchange(lst1.tail,\
    \ lst2.tail).mkString(\",\") + \",\" + exchange(lst1, lst2.tail).mkString(\",\"\
    )", "        val length = lst1.length\n        val a = lst1.toIterator\n     \
    \   val b = lst2.toIterator\n        var result = \"NO\"\n        if (length ==\
    \ 0 || length == 1) {\n            result = \"YES\"\n        } else {\n      \
    \      val even = a.remove\n            val odd = b.remove\n            while\
    \ (a != null && b != null) {\n                if (even.compareTo(b) < 0)\n   \
    \                 a.next()\n                else if (even.compareTo(b) > 0)\n\
    \                    b.next()\n                else\n                    even.next(odd)\n\
    \            }\n        }\n        result", "        // The variable count will\
    \ hold the number of elements that are even in lst1\n        val count = 0\n \
    \       // The variable l2 will hold the elements that we want to exchange in\
    \ lst1\n        val l2 = lst2.filter{ a => a % 2 == 0 }\n        // The variable\
    \ l1 will hold all the odd elements in lst1\n        val l1 = lst1.filter{ a =>\
    \ a % 2 != 0 }\n        // The variable c will hold the number of elements that\
    \ will be exchanged\n        val c = l1.size + l2.size\n        // If l1 is empty,\
    \ return \"NO\"\n        if (l1.isEmpty) {\n            return \"NO\"\n      \
    \  }\n        // Otherwise, go through each element of l2 in order, check whether\
    \ it is even in lst1\n        for (a2@(a <- l2; a <= l2.last) <- l1) {\n     \
    \       // If it is even in lst1, increment the count and move on to the next\
    \ element in l2\n            if (a % 2 == 0) {\n                count += 1\n \
    \           } else {\n                // Otherwise, we do nothing, since if the\
    \ current element of l2 is not even in lst1, \n                // we will still\
    \ go through all the elements of l2 before we move on to the next element in l2\n\
    \            }\n        }\n        // If count is equal to the number of elements\
    \ in l1, return \"YES\"\n        if (count == l1.size) {\n            return \"\
    YES\"\n        }\n        // Otherwise, if count is less than the number of elements\
    \ in l1, return \"NO\"\n        if (count < l1.size) {\n            return \"\
    NO\"\n        }", "        // Your code goes here\n        // return \"NO\"",
  "        lst1 match {\n            case Nil => lst2 match {\n                case\
    \ Nil => \"YES\"\n                case _ => \"NO\"\n            }\n          \
    \  case _  => lst1 match {\n                case x :: xs => lst2 match {\n   \
    \                 case Nil => lst1 match {\n                        case x ::\
    \ xs => lst2 match {\n                            case Nil => \"YES\"\n      \
    \                      case x :: xs => \"NO\"\n                        }\n   \
    \                     case x :: xs => exchange(xs, lst2)\n                   \
    \ }\n                    case y :: ys => exchange(lst1, ys)\n                }\n\
    \            }\n        }", '        // Your code here', "        if(lst1.isEmpty)\
    \ \"\"\n        else {\n            if(lst2.isEmpty) \"\"\n            else {\n\
    \                if(lst1.head == lst2.head) {\n                    exchange(lst1.tail,\
    \ lst2.tail)\n                }\n                else {\n                    exchange(lst1,\
    \ lst2.tail)\n                }\n            }\n        }", "        val res =\
    \ lst2.map {\n            case x if x == 0l => \"NO\"\n            case x if x\
    \ % 2 == 0l => \"YES\"\n            case x => \"NO\"\n        }\n        res.reduceLeft(\"\
    NO\") {\n            case x if x.equals(\"NO\") => \"NO\"\n            case x\
    \ if x.equals(\"YES\") => \"YES\"\n            case x => \"NO\"\n        }", " \
    \       lst1.foreach(element => {\n            if(lst2.contains(element)) {\n\
    \                lst2.remove(element)\n            } else {\n                lst2\
    \ += element\n            }\n        })\n        if(lst2.isEmpty) \"\" else lst2.reverse.mkString(\"\
    \ \").concat(\"is even\")", "        val lst3 = (lst1 union lst2).sortWith(_ <\
    \ _).map(_ %2l).toList\n        if(lst3.size == lst1.size) {\n            val\
    \ res = lst3.zip(lst1).map(x => if (x._1 == x._2) \"YES\" else \"NO\").mkString\n\
    \            if(res.equals(\"NO\")) \n                throw new IllegalArgumentException(\"\
    Invalid inputs\")\n            else\n                res\n        }\n        else\n\
    \            \"NO\"", "        val evens = lst1.filter(f => f % 2 == 0).foldLeft(mutable.ListBuffer[Long]())((a,\
    \ b) => a :+ b)\n        val odds = lst1.filter(f => f % 2 == 1).foldLeft(mutable.ListBuffer[Long]())((a,\
    \ b) => a :+ b)\n        if (evens.equals(lst2.filter(f => f % 2 == 0))) {\n \
    \           return \"YES\"\n        } else if (odds == lst2.filter(f => f % 2\
    \ == 1)) {\n            return \"YES\"\n        } else {\n            return \"\
    NO\"\n        }", "        // write your solution here\n        val evens = lst1.filter(i\
    \ => i % 2 == 0).sorted\n        val odds = lst2.filter(i => i % 2 != 0).sorted\n\
    \n        if (evens.head == odds.head) {\n            val first = evens.tail.head\n\
    \            val second = odds.tail.head\n            if (evens.head + 1 == odds.head)\
    \ odds = odds ++ List(first + second - 1)\n            else evens = evens ++ List(first\
    \ - second)\n            return \"NO\"\n        }\n        else {\n          \
    \  val first = odds.tail.head\n            val second = evens.tail.head\n    \
    \        if (odds.head + 1 == evens.head) evens = evens ++ List(first + second\
    \ - 1)\n            else odds = odds ++ List(first - second)\n            return\
    \ \"NO\"\n        }\n", '        lst1.toSet.intersect(lst2.toSet).size == lst1.size
    ? "YES" : "NO"', "        val length = lst1.size + lst2.size\n        val even\
    \ = lst1.filter(_ % 2 == 0).toList\n        val odd = lst2.filter(_ % 2 == 1).toList\n\
    \        if (even.length == 0 && odd.isEmpty) {\n            return \"YES\"\n\
    \        } else if (even.size == 0 && odd.length != 0) {\n            return \"\
    NO\"\n        } else if (even.length != 0 && odd.length == 0) {\n            return\
    \ \"NO\"\n        } else {\n            val evenList = even.foldRight((ListBuffer[Long](),\
    \ ListBuffer[Long]()))((a, e) => {\n                val tmp = a._1 + e\n     \
    \           a._1 += e\n                (tmp, a._2)\n            })\n         \
    \   val oddList = odd.foldRight((ListBuffer[Long](), ListBuffer[Long]()))((a,\
    \ e) => {\n                val tmp = a._1 + e\n                a._1 += e\n   \
    \             (a._2, tmp)\n            })\n            val result = oddList.takeWhile((a,\
    \ b) => a < b).map((a, b) => a ++ b).toList ++ evenList.takeWhile((a, b) => a\
    \ < b).map((a, b) => a ++ b)\n            if (even.size != result.size) {\n  \
    \              return \"NO\"\n            } else {\n                even.zip(result).forall((a,\
    \ b) => a.toLong == b.toLong)\n            }\n        }", "        val evenLst1\
    \ = lst1.filter(_%2 == 0)\n        val evenLst2 = lst2.filter(_%2 == 0)\n    \
    \    val evenLst3 = evenLst1.filter(_ != evenLst2(0))\n        val evenLst4 =\
    \ evenLst3.map(_ - evenLst2(0))\n        if(evenLst4.length != 0) {\n        \
    \    val evenLst5 = evenLst4.filter(_ == evenLst2(0))\n            if(evenLst5.length\
    \ == 0)\n                return \"NO\"\n            else\n                return\
    \ \"YES\"\n        } else\n            return \"NO\"", "        val evenLst =\
    \ lst1.filter(x=> x % 2 == 0).size\n        val exchangedLst = lst2.filter(x=>\
    \ x % 2 == 0).size\n        if (exchangedLst == evenLst)\n            \"YES\"\n\
    \        else\n            \"NO\"", '        lst1.zip(lst2).filter { case (a:
    Long, b: Long) => (a % 2) == (b % 2) }.map(x => x.toString()).mkString("|")',
  "        val map1 = lst1.map(x=>x%2).toList\n        val map2 = lst2.map(x=>x%2).toList\n\
    \        var count = 0\n        val map3 = map1.zip(map2).map(x=>(x._1, x._2))\n\
    \        val map4 = map3.filter(x=>!map2.contains(x))\n        map4.foreach(x=>count+=1)\
    \ // count is number of even numbers found in both maps\n        if(count==map1.length)\
    \ \n          \"YES\" \n        else\n          \"NO\"", "        // Your code\
    \ goes here\n        var listOfNumbers1 : List[Long] = lst1\n        var listOfNumbers2\
    \ : List[Long] = lst2\n        var listOfNumbers3 : List[Long] = listOfNumbers1.distinct\n\
    \        var listOfNumbers4 : List[Long] = listOfNumbers2.distinct\n        var\
    \ evenNumbers1 : List[Long] = listOfNumbers3.filter(_ % 2 == 0)\n        var evenNumbers2\
    \ : List[Long] = listOfNumbers4.filter(_ % 2 == 0)\n        var evenNumbers3 :\
    \ List[Long] = listOfNumbers1.filter(_ % 2 == 0).filter(_ % 2 == 0)\n        var\
    \ evenNumbers4 : List[Long] = listOfNumbers2.filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 0)\n        evenNumbers1 match {\n            case Nil => evenNumbers2.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \            case x => evenNumbers2.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \        }\n        evenNumbers2 match {\n            case Nil => evenNumbers3.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \            case x => evenNumbers3.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \        }\n        evenNumbers3 match {\n            case Nil => evenNumbers4.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(_))}\n\
    \            case x => evenNumbers4.foreach{listOfNumbers2.remove(listOfNumbers2.indexOf(x))}\n\
    \        }\n        listOfNumbers2.filter(_ % 2 == 0).size", "        if (lst1\
    \ == null || lst2 == null || lst1.isEmpty){\n            return \"NO\"\n     \
    \   }\n        var oddList1 = (lst1.filter(x => x % 2 != 0)).sortWith((x,y) =>\
    \ x.compareTo(y))\n        var oddList2 = (lst2.filter(x => x % 2 != 0)).sortWith((x,y)\
    \ => x.compareTo(y))\n        if (oddList1.size <= 1 && oddList2.size <= 1) {\n\
    \            return (oddList1.head % 2 + \"\\n\" + oddList2.head % 2) \n     \
    \   }\n        else {\n            return \"NO\"\n        }", "        var i =\
    \ 0\n        var j = 0\n        var even = 0\n        var odd = 0\n        var\
    \ evenList = []\n        var oddList = []\n\n        while(i < lst1.length &&\
    \ j < lst2.length) {\n            i += 1\n            j += 1\n\n            if(lst1(j)\
    \ mod 2 == 0){\n                even += 1\n                evenList += lst1(j)\n\
    \            }\n            else if(lst1(j) mod 2 != 0){\n                odd\
    \ += 1\n                oddList += lst1(j)\n            }\n        }\n\n     \
    \   if(even > odd){\n            return \"YES\"\n        }\n        else if(even\
    \ < odd){\n            return \"NO\"\n        }\n\n        if(evenList.size ==\
    \ lst1.length){\n            return \"YES\"\n        }\n        else if(oddList.size\
    \ == lst1.length){\n            return \"NO\"\n        }\n\n        else{\n  \
    \          return exchange(evenList, lst2) || exchange(oddList, lst2)\n      \
    \  }", "        val lst3 = lst1.zip(lst2).filter(_._1.toString.toDouble % 2 ==\
    \ _._1.toString.toDouble % 2)\n        if(lst3.size == lst2.size)\n          \
    \  \"YES\"\n        else\n            \"NO\"", "        val even1 = lst1.filter(x\
    \ => x % 2 == 0).toList\n        val even2 = lst2.filter(x => x % 2 == 0).toList\n\
    \        val odd1 = lst1.filter(x => x % 2 != 0).toList\n        val odd2 = lst2.filter(x\
    \ => x % 2 != 0).toList\n        if even1.length == even2.length ||\n        \
    \    odd1.length == odd2.length\n            { return \"YES\" }\n        else\n\
    \            { return \"NO\" }", "        val evens = lst1.filter(_ % 2 == 0)\n\
    \        val odds = lst1.filter(_ % 2 != 0)\n        if (evens.length == 0) \"\
    NO\"\n        else if (evens.length != lst1.length) \"NO\"\n        else odds\
    \ match {\n            case Nil => \"NO\"\n            case ev :: odf => ev match\
    \ {\n                case 0 => \"NO\"\n                case _ => \"YES\"\n   \
    \         }\n            case _ => \"NO\"\n        }", "        if (lst1.length\
    \ != lst2.length) {\n            return \"NO\"\n        } else {\n           \
    \ var lst = lst2\n            lst = lst.filter(x => (lst1.count(x => x == x) %\
    \ 2 == 0))\n            val even = lst.count(x => x == x) % 2 == 0\n         \
    \   if (even) {\n                return \"YES\"\n            } else {\n      \
    \          return \"NO\"\n            }\n        }", "        if(lst1.isEmpty)\
    \ lst2.isEmpty\n        else if(lst2.isEmpty) lst1.isEmpty\n        else if (lst1.head\
    \ == lst2.head) exchange(lst1.tail, lst2.tail)\n        else exchange(lst1, lst2.tail)",
  "    }\n}\n</code>\nFor Scala 2.10.x, Scala IDE will provide an IDE-friendly solution\
    \ for you, which can solve this problem in one line.\n<code>\nscala> List(1l,\
    \ 2l, 3l, 4l) intersect List(5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l,\
    \ 16l, 17l, 18l, 19l, 20l, 21l, 22l, 23l, 24l, 25l, 26l, 27l, 28l, 29l, 30l, 31l,\
    \ 32l, 33l, 34l, 35l, 36l, 37l, 38l, 39l, 40l, 41l, 42l, 43l, 44l, 45l, 46l, 47l,\
    \ 48l, 49l, 50l, 51l, 52l, 53l, 54l, 55l, 56l, 57l, 58l, 59l, 60l, 61l, 62l, 63l,\
    \ 64l, 65l, 66l, 67l, 68l, 69l, 70l, 71l, 72l, 73l, 74l, 75l, 76l, 77l, 78l, 79l,\
    \ 80l, 81l, 82l, 83l, 84l, 85l, 86l, 87l, 88l, 89l, 90l, 91l, 92l, 93l, 94l, 95l,\
    \ 96l, 97l, 98l, 99l, 100l, 101l, 102l, 103l, 104l, 105l, 106l, 107l, 108l, 109l,\
    \ 110l, 111l, 112l, 113l, 114l, 115l, 116l, 117l, 118l, 119l, 120l, 121l, 122l,\
    \ 123l, 124l, 125l, 126l, 127l, 128l, 129l, 130l, 131l, 132l, 133l, 134l, 135l,\
    \ 136l, 137l, 138l, 139l, 140l, 141l, 142l, 143l, 144l, 145l, 146l, 147l, 148l,\
    \ 149l, 150l, 151l, 152l, 153l, 154l, 155l, 156l, 157l, 158l, 159l, 160l, 161l,\
    \ 162l, 163l, 164l, 165l, 166l, 167l, 168l, 169l, 170l, 171l, 172l, 173l, 174l,\
    \ 175l, 176l, 177l, 178l, 179l, 180l, 181l, 182l, 183l, 184l, 185l, 186l, 187l,\
    \ 188l, 189l, 190l, 191l, 192l, 193l, 194l, 195l, 196l, 197l, 198l, 199l, 200l,\
    \ 201l, 202l, 203l, 204l, 205l, 206l, 207l, 208l, 209l, 210l, 211l, 212l, 213l,\
    \ 214l, 215l, 216l, 217l, 218l, 219l, 220l, 221l, 222l, 223", "        // TODO\n\
    \        val lst3 = lst1 ++ lst2\n        if (lst3.sum % 2 == 0) \"YES\" else\
    \ \"NO\"", "        var lst1copy: List[Long] = lst1.toList\n        var lst2copy:\
    \ List[Long] = lst2.toList\n        var even = true\n        var evenlst1 = 0\n\
    \        var evenlst2 = 0\n        var evenlst1index = 0\n        var evenlst2index\
    \ = 0\n        var evenlst1list = 0\n        var evenlst2list = 0\n        var\
    \ lst1even = []\n        var lst2even = []\n        var lst1evenindex = 0\n  \
    \      var lst2evenindex = 0\n        while(lst1copy.length > 0 || lst2copy.length\
    \ > 0) {\n            if(lst1copy.length > 0 && lst2copy.length > 0) {\n     \
    \           if(lst1copy(0).toLong % 2 == 0 && lst2copy(0).toLong % 2 == 0) {\n\
    \                    if(lst1copy(0).toLong == lst2copy(0).toLong) {\n        \
    \                lst1copy.remove(0)\n                        lst2copy.remove(0)\n\
    \                    } else if(lst1copy(0).toLong > lst2copy(0).toLong) {\n  \
    \                      lst1copy.remove(0)\n                        lst2copy.remove(0)\n\
    \                    } else {\n                        lst1copy.remove(0)\n  \
    \                      lst2copy.remove(0)\n                    }\n           \
    \     } else {\n                    even = false\n                }\n        \
    \    }\n            if(even) {\n                if(evenlst1 == lst1copy.length\
    \ + lst2copy.length) {\n                    evenlst1 = 0\n                   \
    \ evenlst2 = 0\n                    evenlst1index = 0\n                    evenlst2index\
    \ = 0\n                    evenlst1list = 0\n                    evenlst2list\
    \ = 0\n                    lst1even = []\n                    lst2even = []\n\
    \                    lst1evenindex = 0\n                    lst2evenindex = 0\n\
    \                    lst1copy.remove(0)\n                    lst2copy.remove(0)\n\
    \                } else if(evenlst1 == lst1copy.length || evenlst1 == 0) {\n \
    \                   if(lst1copy.length + evenlst1 == lst1copy.length) {\n    \
    \                    lst1even ++= lst1copy\n                        lst1copy.remove(0)\n\
    \                        evenlst1 = lst1copy.length\n                        evenlst1index\
    \ = 0\n                    } else if(lst1copy.length + evenlst1 == 0) {\n    \
    \                    lst1even ++= lst1copy\n                        lst1copy.remove(0)\n\
    \                        evenlst1 = lst1copy.length\n                        evenlst1index\
    \ = 0\n                        lst1even ++= lst1copy\n                       \
    \ lst1copy.remove(0)\n                        evenlst1 = lst1copy.length\n   \
    \                     evenlst1index = 0\n                        lst1even ++=\
    \ lst1copy\n                        lst1copy.remove(0)\n                     \
    \   evenlst1 = lst1copy.length\n                        evenlst1index = 0\n  \
    \                      lst1even ++= lst", "      // Your code here\n      // If\
    \ there are more elements in lst1 than elements in lst2, then it is\n      //\
    \ impossible to make lst1 a list of only even numbers. Therefore, return \"NO\"\
    .\n      if (lst1.size > lst2.size) {\n        return \"NO\"\n      }\n      val\
    \ evens = lst1.filter(_ % 2 == 0).toList\n      val odds = lst2.filter(_ % 2 !=\
    \ 0).toList\n      val newList = evens.zip(odds)\n      if (newList.size == evens.size)\
    \ {\n        return \"YES\"\n      } else {\n        return \"NO\"\n      }",
  "        val num1 = lst1.toSet.toList.size\n        val num2 = lst2.toSet.toList.size\n\
    \        if (num1 != num2) {\n            s\"NO\"\n        }\n        else if\
    \ (num1 == num2 && lst1.toSet == lst2.toSet) {\n            if (lst1.toSet.contains(2l.toLong)\
    \ && lst2.toSet.contains(2l.toLong)) {\n                \"YES\"\n            }\n\
    \            else {\n                \"NO\"\n            }\n        }", "    \
    \    def exchanges(lst1 : List[Long], lst2 : List[Long]) : List[Long] = ???\n\n\
    \        def findSum (lst1 : List[Long], lst2 : List[Long]) : List[Long] = ???\n\
    \n        val sum1 = findSum(lst1,lst2)\n        val sum2 = findSum(lst2,lst1)\n\
    \        if (sum1.toLong == sum2.toLong)\n            return \"YES\"\n       \
    \ else\n            return \"NO\"", "        val evens = lst1.filter( l => l.toDouble\
    \ % 2 == 0 ).toList\n        val odds = lst2.filter( l => l.toDouble % 2 != 0\
    \ ).toList\n        val result = evens.head + odds(0).filter( l => odds(1) contains\
    \ l ).head + evens.tail.filter( l => evens(0) contains l ).head + odds(1).filter(\
    \ l => evens(1) contains l ).head + evens.tail.filter( l => odds(0) contains l\
    \ ).head + odds(0) + evens.tail.filter( l => evens(0) contains l ).head + odds(1)\
    \ + evens.tail.filter( l => odds(0) contains l ).head + odds(1) + evens.tail.filter(\
    \ l => evens(1) contains l ).head + evens.tail.filter( l => odds(1) contains l\
    \ )\n        if ( result > 0 ) \"\" else \"NO\"", "        // write your code\
    \ here\n        lst1 foreach (x => lst2 filter (x % 2 == 0).toList)\n        lst1\
    \ filter (x => lst2 filter (x % 2 == 0).toList).length == 0", "        val even\
    \ = lst1.filter(x => x % 2 == 0).toList\n        val odd = lst2.filter(x => x\
    \ % 2 == 1).toList\n        val evenLength = even.size\n        val oddLength\
    \ = odd.size\n        if(evenLength == 0 || oddLength == 0) {\n            \"\"\
    \n        } else {\n            if(evenLength == oddLength){\n               \
    \ val common = even.intersect(odd)\n                val evenCommon = even.filter(x\
    \ => common.contains(x)) // even in common\n                val oddCommon = odd.filter(x\
    \ => common.contains(x)) // odd in common\n                if(evenCommon.size\
    \ == evenLength && oddCommon.size == oddLength){\n                    if(evenCommon.isEmpty\
    \ || oddCommon.isEmpty){\n                        \"\"\n                    }\
    \ else {\n                        if(evenCommon.size == evenLength){\n       \
    \                     evenCommon.toList.mkString(\",\")\n                    \
    \    } else {\n                            oddCommon.toList.mkString(\",\")\n\
    \                        }\n                    }\n                } else {\n\
    \                    \"\"\n                }\n            } else {\n         \
    \       \"\"\n            }\n        }", '        // TODO', "        \n      \
    \  // Code here\n        \n        return \"\"", "        val lst3 = lst1.filter(x\
    \ => !lst2.contains(x))\n        val lst4 = lst1.filter(x => !lst3.contains(x))\n\
    \        val lst5 = lst2.filter(x => !lst4.contains(x))\n        val lst6 = lst2.filter(x\
    \ => !lst5.contains(x))\n\n        if (lst3.isEmpty) \"\"\n        else if (lst4.isEmpty)\
    \ \"\"\n        else if (lst5.isEmpty) \"\"\n        else if (lst6.isEmpty) \"\
    \"\n        else if (lst1.size < lst2.size) \"\"\n        else if (lst2.size <\
    \ lst1.size) \"\"\n        else if (lst4.contains(lst5.head)) \"NO\"\n       \
    \ else if (lst4.contains(lst5.last)) \"NO\"\n        else if (lst5.contains(lst4.head))\
    \ \"NO\"\n        else if (lst5.contains(lst4.last)) \"NO\"\n        else if (lst6.contains(lst5.head))\
    \ \"NO\"\n        else if (lst6.contains(lst5.last)) \"NO\"\n        else if (lst5.contains(lst6.head))\
    \ \"NO\"\n        else if (lst5.contains(lst6.last)) \"NO\"\n        else if (lst3.contains(lst4.head))\
    \ \"NO\"\n        else if (lst3.contains(lst4.last)) \"NO\"\n        else if (lst4.contains(lst3.head))\
    \ \"NO\"\n        else if (lst4.contains(lst3.last)) \"NO\"\n        else if (lst5.contains(lst6.head))\
    \ \"NO\"\n        else if (lst5.contains(lst6.last)) \"NO\"\n        else if (lst6.contains(lst5.head))\
    \ \"NO\"\n        else if (lst6.contains(lst5.last)) \"NO\"\n        else if (lst3.contains(lst5.head))\
    \ \"NO\"\n        else if (lst3.contains(lst5.last)) \"NO\"\n        else if (lst5.contains(lst3.head))\
    \ \"NO\"\n        else if (lst5.contains(lst3.last)) \"NO\"\n        else if (lst6.contains(lst3.head))\
    \ \"NO\"\n        else if (lst6.contains(lst3.last)) \"NO\"\n        else if (lst4.contains(lst6.head))\
    \ \"NO\"\n        else if (lst4.contains(lst6.last)) \"NO\"\n        else if (lst6.contains(lst4.head))\
    \ \"NO\"\n        else if (lst6.contains(lst4.last)) \"NO\"\n        else if (lst3.contains(lst6.head))\
    \ \"NO\"\n        else if (lst3.contains(lst6.last)) \"NO\"\n        else if (lst5.contains(lst6.head))\
    \ \"NO\"\n        else if (lst5.contains(lst6.last)) \"NO\"\n        else if (lst6.contains(lst5.head))\
    \ \"NO\"\n        else if (lst6.contains(lst5.last)) \"NO\"\n        else if (lst3.contains(lst4.head))\
    \ \"NO\"\n        else if (", "        if(lst1.isEmpty){\n            return \"\
    NO\";\n        }else if(lst2.isEmpty){\n            return \"NO\";\n        }else{\n\
    \            val a = lst1.head\n            val b = lst2.head\n            if(a\
    \ % 2 == 0 && b % 2 == 0){\n                val lst3 = lst1.tail\n           \
    \     val lst4 = lst2.tail\n                if(lst3.size == 0){\n            \
    \        return \"NO\"\n                }else if(lst4.size == 0){\n          \
    \          return \"NO\"\n                }else{\n                    return \"\
    YES\"\n                }\n            }else if(a % 2 == 0 && b % 2 != 0){\n  \
    \              val lst3 = lst1.tail\n                val lst4 = lst2.tail\n  \
    \              if(lst3.size == 0){\n                    return \"NO\"\n      \
    \          }else if(lst4.size == 0){\n                    return \"NO\"\n    \
    \            }else{\n                    return \"YES\"\n                }\n \
    \           }else{\n                return \"NO\"\n            }\n        }",
  "      val evens = lst1.filter(_ % 2l.toLong == 0)\n      val odds = lst2.filter(_\
    \ % 2l.toLong != 0)\n      evens.size == 0 && (\"NO\") || (evens.length < odds.length)\
    \ && \"YES\"", "        // YOUR CODE HERE\n        val lst3 = lst1 ++ lst2.reverse\n\
    \        val even = lst3.map(x => if(x % 2 == 0) x else x * 2)\n        val even2\
    \ = even.sort\n        val even3 = even2.takeWhile(x => x < lst3.last).toList\n\
    \        val even4 = even3.take(even3.size - even2.size)\n        if(even4 forall\
    \ even.contains(x => x == x)) \"YES\" else \"NO\"", "        lst1.map { x =>\n\
    \            if(lst2.contains(x)){\n                lst2 -=x\n            }else{\n\
    \                lst2 += x\n            }\n        }\n        if(lst2.isEmpty){\n\
    \            return \"YES\"\n        }else{\n            return \"NO\"\n     \
    \   }", "        if(lst1.isEmpty) {\n            return \"NO\"\n        } else\
    \ if(lst2.isEmpty) {\n            return \"NO\"\n        }\n        if(lst1(0)\
    \ < lst2(0) && lst1(0) >= 0) {\n            exchangeHelper(lst1, lst2, 1l.toLong)\n\
    \        } else if(lst2(0) < lst1(0) && lst2(0) >= 0) {\n            exchangeHelper(lst2,\
    \ lst1, 1l.toLong)\n        } else {\n            exchangeHelper(lst1, lst2, 0l.toLong)\n\
    \        }", "        var tmp1 : List[Long] = lst1.toList\n        var tmp2 :\
    \ List[Long] = lst2.toList\n        var flag : Boolean = false\n        var count\
    \ : Int = 1\n        while(count <= lst2.length){\n            flag =  (lst1.contains(tmp2(0))\
    \ && lst2.contains(tmp1(0)) && tmp1.contains(tmp2(0)) && lst1.contains(tmp2(0))\
    \ && lst2.contains(tmp1(0)))\n            if(!flag){\n                tmp1 = tmp1.drop(1)\n\
    \                tmp2 = tmp2.drop(1)\n                count +=1\n            }else{\n\
    \                break\n            }\n        }\n        if(lst1.size == count){\n\
    \            if(lst2.size == count){\n                if(lst1.contains(tmp2(0))\
    \ && lst2.contains(tmp1(0))){\n                    return \"YES\"\n          \
    \      }else{\n                    return \"NO\"\n                }\n        \
    \    }\n        }\n        return \"NO\"", '        // Your implementation goes
    here', "        // Your code goes here\n        var lst3 = lst1\n        lst3\
    \ = lst2 ++ lst3\n        if (lst3.forall(x => x % 2 == 0)) {\n            \"\
    YES\"\n        } else {\n            \"NO\"\n        }", "        if(lst1.isEmpty)\
    \ return \"NO\";\n        if(lst2.isEmpty) return \"NO\";\n        var even =\
    \ true;\n        for(i <- lst1.indices) {\n            if(lst1(i).toInt % 2 ==\
    \ 0) {\n                even = false\n            }\n        }\n        for(i\
    \ <- lst2.indices) {\n            if(lst2(i).toInt % 2 == 0) {\n             \
    \   even = false\n            }\n        }\n        if(even) \n            return\
    \ \"YES\"\n        else \n            return \"NO\"", "        // Write your code\
    \ here\n        // Write your code here\n        var lst3 = (lst1 take lst2.length)\
    \ intersect (lst2 take lst1.length)\n        if (lst3 != Nil) lst3 else \"NO\"",
  "        // Your code here\n        if(lst1.isEmpty){\n            \"\"\n      \
    \  }\n        else if(lst2.isEmpty){\n            \"\"\n        }\n        else\
    \ if(lst1.last.isEven){\n            exchange(lst1.dropRight(1),lst2)\n      \
    \  }\n        else{\n            exchange(lst1,lst2.dropRight(1))\n        }",
  "       val evens = lst1.filter(_ % 2l.toLong == 0)\n       val odds  = lst2.filter(_\
    \ % 2l.toLong == 0)\n\n       val exchangedElements = evens.zip(odds)\n      \
    \ exchangedElements.foreach {\n         case(evenElem, oddElem)  =>\n        \
    \   lst1 ++= (evenElem.toLong)\n           lst2 ++= (oddElem.toLong)\n       }\n\
    \n       if (lst1.size == evens.size) (\"YES\")\n       else (\"NO\")", "    \
    \    val evens = lst1.filter((x => x % 2 ==0l)).distinct\n        val odds  =\
    \ lst2.filter((x => x % 2 ==1l)).distinct\n        val evenOdds = evens ++ odds\n\
    \        var result = \"\"\n        for (ev in evenOdds) {\n            val l1\
    \ = lst1.filter((x => x % 2 ==0l)).distinct\n            val l2 = lst2.filter((x\
    \ => x % 2 ==1l)).distinct\n            val l1 = l1.filter((x => x % 2 ==ev%2l)).distinct\n\
    \            val l2 = l2.filter((x => x % 2 ==ev%2l)).distinct\n            val\
    \ s1 = l1.size\n            val s2 = l2.size\n            val s3 = evenOdds.filter((x\
    \ => x % 2 ==ev%2l)).size\n            val s4 = evenOdds.filter((x => x % 2 !==ev%2l)).size\n\
    \            val n1 = l1.size - s1\n            val n2 = l2.size - s2\n      \
    \      val n3 = evenOdds.filter((x => x % 2 !==ev%2l)).size\n            val n4\
    \ = evenOdds.filter((x => x % 2 ==ev%2l)).size\n            if (n1 === n2 && n2\
    \ === n3) {\n                result = \"YES\"\n                break\n       \
    \     } else if (n1 === n2 && n2 === n4) {\n                result = \"YES\"\n\
    \                break\n            } else if (n1 === n2 && n3 === n4) {\n   \
    \             result = \"NO\"\n                break\n            } else if (n1\
    \ === n3 && n2 === n4) {\n                result = \"NO\"\n                break\n\
    \            } else if (n1 === n3 && n2 === n3) {\n                result = \"\
    YES\"\n                break\n            } else if (n1 === n4 && n2 === n3) {\n\
    \                result = \"NO\"\n                break\n            } else if\
    \ (n1 === n4 && n2 === n4) {\n                result = \"YES\"\n             \
    \   break\n            }\n        }\n        return result", "        val n =\
    \ lst1.size\n        if(lst1.isEmpty) {\n            lst2.toList.mkString(\"[\"\
    , \", \", \"]\") \n        } else if (lst2.isEmpty) {\n            lst1.toList.mkString(\"\
    [\", \", \", \"]\") \n        } else {\n            // do some magic!\n      \
    \  }", '        ', "        if(lst1 == null || lst2 == null || lst1.isEmpty()\
    \ || lst2.isEmpty) return \"NO\"\n        val lst3 = new ListBuffer[Long]\n  \
    \      lst2.foreach(x => lst3 += x)\n        lst1.foreach(x => lst3 -= x)\n  \
    \      if(lst3.isEmpty || lst3.toSet.size == 0) \"NO\" else \"YES\"", '        lst1.filter(x
    => ((lst2.exists(y => x == y)).toSeq).isEmpty)', '      lst1.toSet.intersect(lst2.toSet).isEmpty',
  '        // SOLUTION GOES BELOW', "        val resultSet = mutable.Set[Long]()\n\
    \        // TODO: Write your code here\n        resultSet.addAll(lst2)\n     \
    \   resultSet.removeAll(lst1)\n        val resultString = resultSet.toList.mkString(\"\
    ,\")\n        resultString", "        val xs = lst1 ++ (0 until lst2.length)\n\
    \        val ys = lst2 ++ (0 until lst1.length)\n        xs zip ys filter (x =>\
    \ x % 2 == 0) forall {\n            x => lst1 exists y => x == y\n        }\n\
    \        \"YES\"", "      if(lst1.length == 0 || lst2.length == 0){\n        return\
    \ \"\";\n      }\n      var list3 = lst1.diff(lst2)\n      var list4 = lst2.diff(lst1)\n\
    \      val list5 = list3.toList.sortWith(_ < _)\n      val list6 = list4.toList.sortWith(_\
    \ < _)\n      if(list5.toSet == list6.toSet){\n        return \"YES\"\n      }\n\
    \      else{\n        return \"NO\"\n      }", "        var count = 0\n      \
    \  for(a <- lst1; b <- lst2) {\n            if(a.toDouble % 2 == 0) && (b.toDouble\
    \ % 2 == 0) {\n                count++\n            }\n        }\n        if(count\
    \ == lst2.size)\n            \"YES\"\n        else\n            \"NO\"", "   \
    \     val lst1 = lst1.toList\n        val lst2 = lst2.toList\n        val even1\
    \ = lst1.filter(x => x % 2 == 0).toList\n        val even2 = lst2.filter(x =>\
    \ x % 2 == 0).toList\n        var evenToDelete = 0\n        val list1 = lst1\n\
    \        var list2 = lst2\n        var isEven = True\n\n        while(list1.nonEmpty\
    \ || list2.nonEmpty) {\n            var countEven = 0\n            if (list1.nonEmpty\
    \ && list2.nonEmpty) {\n                countEven = even1.size + even2.size\n\
    \                isEven = (countEven <= 1) ? True : isEven\n                evenToDelete\
    \ = (countEven == 1) ? 1 : countEven\n            } else if (list1.nonEmpty) {\n\
    \                countEven = even1.size\n                isEven = (countEven <=\
    \ 1) ? True : isEven\n                evenToDelete = countEven\n            }\
    \ else if (list2.nonEmpty) {\n                countEven = even2.size\n       \
    \         isEven = (countEven <= 1) ? True : isEven\n                evenToDelete\
    \ = countEven\n            }\n\n            if (isEven) {\n                if\
    \ (countEven == 1) {\n                    val even = even1.head\n            \
    \        val evenList = even1.tail\n                    list1 = list1 diff List(even)\n\
    \                    list2 = list2 diff List(even)\n                    lst1 =\
    \ lst1.filterNot(x => x == even)\n                    lst2 = lst2.filterNot(x\
    \ => x == even)\n                    even1 = evenList.filter(x => x % 2 == 0).toList\n\
    \                    even2 = evenList.filter(x => x % 2 == 0).toList\n       \
    \             evenToDelete = (countEven == 1) ? 1 : countEven\n              \
    \  } else {\n                    val even = even1.head\n                    val\
    \ evenList = even1.tail\n                    list1 = list1 diff List(even)\n \
    \                   list2 = list2 diff List(even)\n                    lst1 =\
    \ lst1.filterNot(x => x == even)\n                    lst2 = lst2.filterNot(x\
    \ => x == even)\n                    even1 = evenList.filter(x => x % 2 == 0).toList\n\
    \                    even2 = evenList.filter(x => x % 2 == 0).toList\n       \
    \             evenToDelete = (countEven == 1) ? 1 : countEven\n              \
    \  }\n            } else {\n                if (countEven == 1) {\n          \
    \          val even = even2.head\n                    val evenList = even2.tail\n\
    \                    list1 = list1 diff List(even)\n                    list2\
    \ = list2 diff List(even)\n                    lst1 = lst1.filterNot(x => x ==\
    \ even)\n                    lst2 = lst", "        var lst3 = lst1 ++ lst2\n \
    \       var lst4 = ListBuffer[Long]()\n        var even = true\n        while\
    \ (lst3.nonEmpty && even) {\n            var value = lst3.head\n            var\
    \ removeValue = lst3.remove(0)\n            lst4 += value\n            even =\
    \ !even\n            lst3 += removeValue\n        }\n        even = even\n   \
    \     if (lst3.nonEmpty) {\n            return \"NO\"\n        } else {\n    \
    \        return \"YES\"\n        }", "        lst1.zip(lst2).map{case (number1,number2)\
    \ => if(number1 % 2 == 0 && number2 % 2 == 0){ number1 -> number2 } else { number1\
    \ -> number2 } }.foldLeft(List[Long]()){\n            case (acc, elem) => acc\
    \ ++ elem\n        }.count(_ % 2 == 0).isEmpty match {\n            case true\
    \  => \"YES\"\n            case false => \"NO\"\n        }", "        // TODO:\
    \ fill in the body of the function here.\n        ", "        val exSet = mutable.HashSet[Long]()\n\
    \        for(a <- lst1; b <- lst2){\n            if(b < a){\n                exSet.add(a)\n\
    \                exSet.add(b)\n            }else{\n                exSet.add(b)\n\
    \                exSet.add(a)\n            }\n        }\n        if(exSet.size\
    \ == lst2.size){\n            return \"YES\"\n        }else{\n            return\
    \ \"NO\"\n        }", "        var even = lst1.filter(x => x % 2 == 0).toList\n\
    \        var odd = lst2.filter(x => x % 2 == 0).toList\n        var lst3 = lst1.toList\n\
    \        var lst4 = lst2.toList\n        var lst5 = even.union(odd).distinct\n\
    \        var lst6 = lst3.filter(x => !lst5.contains(x))\n        var lst7 = lst4.filter(x\
    \ => !lst5.contains(x))\n        var lst8 = lst6.toList\n        var lst9 = lst7.toList\n\
    \        var lst10 = lst8.toList\n        lst10.foreach(x => if (x % 2 == 0) even\
    \ = even.filterNot(x => x == x) else odd = odd.filterNot(x => x == x))\n     \
    \   if (lst10.size == 0) \"YES\" else \"NO\"", '      // Your code goes here',
  "        var lst1_temp = lst1\n        var lst2_temp = lst2\n        while(lst1_temp.nonEmpty\
    \ || lst2_temp.nonEmpty) {\n            lst1_temp = lst1_temp map {\n        \
    \        val elm = lst1_temp.head\n                if (lst1_temp.head % 2 == 0)\
    \ {\n                    lst1_temp.remove(elm)\n                }\n          \
    \      elm\n            }\n            lst2_temp = lst2_temp map {\n         \
    \       val elm = lst2_temp.head\n                if (lst2_temp.head % 2 == 0)\
    \ {\n                    lst2_temp.remove(elm)\n                }\n          \
    \      elm\n            }\n            if (lst1_temp.size == 0 && lst2_temp.size\
    \ == 0) return \"YES\"\n            if (lst1_temp.size == 0) return \"NO\"\n \
    \           if (lst2_temp.size == 0) return \"NO\"\n        }", "        // TODO:\
    \ Implement this function\n        lst1.foldLeft(\"\"){\n        case (acc, i)\
    \ => acc += s\"($i), ($lst2.head), ($lst2.tail)\\n\"\n        }", '        //
    Your code here', '        // Your code here', "        val map1 = lst1.groupBy(identity).mapValues(_.length)\n\
    \        val map2 = lst2.groupBy(identity).mapValues(_.length)\n\n        val\
    \ res = map1.filter(_._2 > map2.get(_._1)).exists { case (_, v) => v == 2 }\n\
    \        res match {\n            case true => \"YES\"\n            case false\
    \ => \"NO\"\n        }", "        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var exchanged = 0\n        while(i < lst1.length && j < lst2.length)\
    \ {\n            if(lst1(k) == lst2(j)) {\n                if(lst1(k).even) {\n\
    \                    lst1(k) = lst1(k).odd.get\n                    lst1(exchanged)\
    \ = lst1(k).even.get\n                    exchanged = exchanged + 1 \n       \
    \         } else {\n                    lst1(k) = lst1(k).even.get\n         \
    \           lst1(exchanged) = lst1(k).odd.get\n                    exchanged =\
    \ exchanged + 1 \n                }\n                i = i + 1\n             \
    \   j = j + 1\n                k = k + 1\n            } else {\n             \
    \   i = i + 1\n                j = j + 1\n                k = k + 1\n        \
    \    }\n        }\n        exchanged = exchanged\n        if(exchanged == lst1.length)\
    \ {\n            return \"YES\"\n        } else if(exchanged == 0) {\n       \
    \     return \"NO\"\n        }", "        // Your code goes here\n        \n \
    \       val list1 = lst1.toSet.toList\n        val list2 = lst2.toSet.toList\n\
    \        \n        var list3 = list1\n        list3.foreach(list3 => {\n     \
    \       val list4 = list2\n            list4.foreach(list4 => {\n            \
    \    \n            })\n        })\n        list3", '        // Your code goes
    here!', '        // TODO: Write your function here', "        // Write your solution\
    \ here\n        val result = lst2.foldLeft(lst1.size)((x, y) => x+y)\n       \
    \ result != lst1.size ? \"NO\" : \"YES\"", "        lst1.foreach { x =>\n    \
    \        lst2.foreach { y =>\n                if (x % 2 == 0 & y % 2 == 0) {\n\
    \                    if (x != y) {\n                        lst2 += (x - y)\n\
    \                        lst1 += (y)\n                        println(lst1)\n\
    \                        println(lst2)\n                        //return \"YES\"\
    \n                    }\n                }\n            }\n        }\n       \
    \ //return \"NO\"", "        if (lst1.isEmpty)\n        {\n            return\
    \ \"NO\"\n        }\n        else if (lst2.isEmpty)\n        {\n            return\
    \ \"NO\"\n        }\n        else if (lst1.head % 2 == 0 & lst2.head % 2 == 0)\n\
    \        {\n            return \"YES\"\n        }\n        else if (lst1.head\
    \ == lst2.head)\n        {\n            return exchange(lst1.tail, lst2.tail)\n\
    \        }\n        else\n        {\n            return \"NO\"\n        }", " \
    \       // TODO:\n        // 1. Your code here\n        // 2. Make sure you return\
    \ \"NO\" if the lists are empty.\n        // 3. Make sure you use only immutable\
    \ types (Long, Integer, etc)\n        // 4. In particular, make sure your code\
    \ can handle the case where the lists are both empty.\n        // 5. Make sure\
    \ you understand what a \"functional programming\" solution would look like.\n\
    \        // 6. Make sure you understand how recursion works.\n        if (lst1.isEmpty)\
    \ lst2 match {\n            case Nil => \"NO\"\n            case _ => lst1 match\
    \ {\n                case Nil => \"NO\"\n                case _ => \"YES\"\n \
    \           }\n        }\n        else if (lst2.isEmpty) lst1 match {\n      \
    \      case Nil => \"NO\"\n            case _ => lst2 match {\n              \
    \  case Nil => \"NO\"\n                case _ => \"YES\"\n            }\n    \
    \    }\n        else if (lst1.head % 2 == lst2.head % 2) \"YES\"\n        else\
    \ exchange(lst1.tail, lst2.tail)", "        val lst = lst1.map(x => x)\n     \
    \   val lst2 = lst2.map(x => x)\n        var x = 0\n        var y = 0\n      \
    \  val len1 = lst1.length\n        val len2 = lst2.length\n        if (len1 <\
    \ len2) {\n            lst = lst2.zip(lst).map(x => (x._1.toLong :: x._2.toLong))\n\
    \        } else {\n            lst = lst1.zip(lst2).map(x => (x._1.toLong :: x._2.toLong))\n\
    \        }\n        if (lst.distinct.map{x => x.toLong}.distinct.length == lst2.distinct.map{x\
    \ => x.toLong}.distinct.length && lst.distinct.map{x => x.toLong}.distinct.length\
    \ == lst2.distinct.map{x => x.toLong}.distinct.length)\n        {\n          \
    \  val length = lst.distinct.map{x => x.toLong}.distinct.length\n            var\
    \ i = 0\n            var j = length\n            while (i < j && lst(j).toLong\
    \ % 2 == 0) {\n                i = i + 1\n                j = j - 1\n        \
    \    }\n            if (i == j)\n            {\n                var j = 0\n  \
    \              while (j < length && lst(j).toLong % 2 == 0) {\n              \
    \      lst(j).toLong = lst(j).toLong + lst(j).toLong\n                    j =\
    \ j + 1\n                }\n                for (i <- i until lst(length).toLong)\n\
    \                {\n                    if (lst(i).toLong % 2 == 0) lst(i).toLong\
    \ = lst(i).toLong - lst(i).toLong\n                    else lst(i).toLong = lst(i).toLong\
    \ - lst(i).toLong\n                }\n                lst(length).toLong = lst(length).toLong\
    \ + lst(length).toLong\n                if (lst(length).toLong % 2 == 0) \"YES\"\
    \ else \"NO\"\n            } else \"NO\"\n        } else \"NO\"", "        //\
    \ TODO:\n        // 1) Declare a mutable list to store elements from lst1\n  \
    \      // 2) Declare a mutable list to store elements from lst2\n        // 3)\
    \ Add all elements of lst1 to a mutable list\n        // 4) Add all elements of\
    \ lst2 to a mutable list\n        // 5) Remove all elements from lst1 that do\
    \ not have even value\n        // 6) Remove all elements from lst2 that do not\
    \ have even value\n        // 7) Loop through both lists, if an even value exists\
    \ in both lists\n        // 8) If it exists swap elements and update both lists\n\
    \        // 9) Return either \"YES\" or \"NO\"\n        // 10) Return an empty\
    \ string if there are no even values in either list\n        val list1 = lst1.toList\n\
    \        val list2 = lst2.toList\n        list1.toList.map(x => if (x % 2 == 0)\
    \ { x } else { \"\" }).filter(x => x != \"\").flatMap(x => list2.filter(y => y\
    \ % 2 == 0).map(y => x -> y))\n        list2.toList.map(x => if (x % 2 == 0) {\
    \ x } else { \"\" }).filter(x => x != \"\").flatMap(x => list1.filter(y => y %\
    \ 2 == 0).map(y => x -> y))\n        list1.toList.map(x => if (x % 2 == 0) { x\
    \ } else { \"\" }).filter(x => x != \"\").flatMap(x => list2.filter(y => y % 2\
    \ == 0).map(y => x -> y)).filter(x => x != \"\").map(x => x -> list1.count(i =>\
    \ i % 2 == 0))\n        list2.toList.map(x => if (x % 2 == 0) { x } else { \"\"\
    \ }).filter(x => x != \"\").flatMap(x => list1.filter(y => y % 2 == 0).map(y =>\
    \ x -> y)).filter(x => x != \"\").map(x => x -> list2.count(i => i % 2 == 0))",
  "        val even = lst1.filter(_%2==0)\n        val odd = lst1.filter(_%2!=0)\n\
    \        if (even.length==lst1.length && even.mkString.equalsIgnoreCase(lst2.mkString)){\n\
    \            return \"YES\"\n        }\n        if (odd.length==lst1.length &&\
    \ odd.mkString.equalsIgnoreCase(lst2.mkString)){\n            return \"YES\"\n\
    \        }\n        return \"NO\"", "        // TODO: Write your implementation\
    \ here\n        if(lst1.size != lst2.size)\n            return \"NO\"\n      \
    \  if(lst1.size == 0)\n            return \"YES\"\n        val list = lst1.clone\n\
    \        val evenList = lst2.filter(_%2 == 0l)\n        for(i <- evenList){\n\
    \            if(list.contains(i))\n                list.remove(i)\n        }\n\
    \        if(list.size == 0)\n            return \"YES\"\n        return \"NO\"",
  '        //TODO: write the code here', "        val lst = lst1.toList ++ lst2.toList\n\
    \        val lst1 = lst.filter(x => x % 2 == 0)\n        val lst2 = lst.filter(x\
    \ => x % 2 != 0)\n        lst1.size == lst2.size && lst1.map((x => lst2.indexOf(x)\
    \ > -1 && lst1.indexOf(x) == lst2.indexOf(x)) _).forall(x => x == true)", "  \
    \      // Your code goes here\n        val even = lst1.filter (x => x % 2 == 0)\n\
    \        val odd = lst2.filter (x => x % 2 == 1)\n        val pairs = lst1.zip(lst2).filter\
    \ (x => even.contains(x._1) && odd.contains(x._2))\n        if (pairs.size < 2)\
    \ \"NO\" else \"YES\"", "        // Write your solution here\n        lst1.toSet.intersect(lst2.toSet).size\
    \ == lst1.size ? \"YES\" : \"NO\"", "        val lst1s = lst1.sort\n        val\
    \ lst2s = lst2.sort\n        val evens = lst1s.filter(x => x % 2 == 0)\n     \
    \   val evenCount = lst2s.count(x => x % 2 == 0)\n        if (evenCount < evens.length)\
    \ {\n            return \"NO\"\n        }\n        val nums = lst1s.zip(lst2s).filter(_._1\
    \ == _._2)\n        val numsSet = nums.toSet\n        val numsSetCopy = numsSet.clone()\n\
    \        val numsSetCopy2 = numsSet.clone().map(x => x * 2)\n        val numsSetCopy3\
    \ = numsSet.clone().map(x => x * 3)\n        val numsSetCopy4 = numsSet.clone().map(x\
    \ => x * 4)\n        val numsSetCopy5 = numsSet.clone().map(x => x * 5)\n    \
    \    val numsSetCopy6 = numsSet.clone().map(x => x * 6)\n        val numsSetCopy7\
    \ = numsSet.clone().map(x => x * 7)\n        val numsSetCopy8 = numsSet.clone().map(x\
    \ => x * 8)\n        val numsSetCopy9 = numsSet.clone().map(x => x * 9)\n    \
    \    val numsSetCopy10 = numsSet.clone().map(x => x * 10)\n        val numsSetCopy11\
    \ = numsSet.clone().map(x => x * 11)\n        val numsSetCopy12 = numsSet.clone().map(x\
    \ => x * 12)\n        val numsSetCopy13 = numsSet.clone().map(x => x * 13)\n \
    \       val numsSetCopy14 = numsSet.clone().map(x => x * 14)\n        val numsSetCopy15\
    \ = numsSet.clone().map(x => x * 15)\n        val numsSetCopy16 = numsSet.clone().map(x\
    \ => x * 16)\n        val numsSetCopy17 = numsSet.clone().map(x => x * 17)\n \
    \       val numsSetCopy18 = numsSet.clone().map(x => x * 18)\n        val numsSetCopy19\
    \ = numsSet.clone().map(x => x * 19)\n        val numsSetCopy20 = numsSet.clone().map(x\
    \ => x * 20)\n        val numsSetCopy21 = numsSet.clone().map(x => x * 21)\n \
    \       val numsSetCopy22 = numsSet.clone().map(x => x * 22)\n        val numsSetCopy23\
    \ = numsSet.clone().map(x => x * 23)\n        val numsSetCopy24 = numsSet.clone().map(x\
    \ => x * 24)\n        val nums", "        var even1 = false\n        var even2\
    \ = false\n        val size = lst1.size\n        val evenList = new mutable.MutableList[Long](lst1.size)\n\
    \        for(i <- 0 to lst1.size -1 ) {\n            if(lst1(i) % 2 == 0) {\n\
    \                even1 = true\n            }\n            evenList(i) = lst1(i)\n\
    \        }\n        val even2 = true\n        for(i <- 0 to lst2.size -1 ) {\n\
    \            if(lst2(i) % 2 == 0) {\n                even2 = true\n          \
    \  }\n            evenList(i+size) = lst2(i)\n        }\n        if(even1 && even2)\
    \ {\n            return \"NO\"\n        }\n        else if(even1 && even2) {\n\
    \            for(i <- 0 to lst1.size -1 ) {\n                if(evenList(i) !=\
    \ 0) {\n                    return \"NO\"\n                }\n            }\n\
    \            return \"YES\"\n        }\n        else {\n            for(i <- 0\
    \ to lst1.size -1 ) {\n                if(evenList(i) != 0) {\n              \
    \      return \"NO\"\n                }\n            }\n            return \"\
    YES\"\n        }", "        var lst3 = lst1\n        var lst4 = lst2\n       \
    \ for( i <- 0 until lst3.length ) {\n            // if lst3 contains all even\
    \ numbers, we can remove it\n            if(lst3.forall( (x:Long) => x%2 == 0)\
    \ ) {\n                lst3.remove(lst3.last)\n                lst4 += lst3.last\n\
    \            } else {\n                // if lst3 contains some even numbers,\
    \ remove it and append it at first\n                if(lst3.forall( (x:Long) =>\
    \ x%2 == 1 ) ) {\n                    lst3.remove(lst3.last)\n               \
    \     lst3 += lst3.last\n                }\n                // if lst3 doesn't\
    \ contain even numbers, remove it and append it at the last\n                else\
    \ {\n                    lst3.remove(lst3.last)\n                    lst4 += lst3.last\n\
    \                }\n            }\n        }\n        if(lst3 == lst4.map(_.toLong).toList\
    \ ) {\n            return \"YES\"\n        }\n        else {\n            return\
    \ \"NO\"\n        }", '        lst1.toSet.toList.intersect(lst2.toSet).toList.forall(x
    => x % 2 == 0)', "        val even_lst = lst1.filter(_ % 2 == 0)\n        if(even_lst.size\
    \ != lst1.size) return(\"NO\")\n        val exchange_lst = lst2.filter(_ % 2 ==\
    \ 0).filterNot(lst1.contains(_))\n        if(exchange_lst.size != lst2.size) return(\"\
    NO\")\n        val result = even_lst.zip(exchange_lst).map(_._1).take(2).exists(_\
    \ % 2 == 0)\n        if(!result) return(\"NO\")\n        \"YES\"", "        //\
    \ TODO: implement the body of this function\n        val numOfElementsBetweenLists\
    \ = lst2.length() - lst1.length()\n        if(numOfElementsBetweenLists < 0 ||\
    \ numOfElementsBetweenLists > 0){\n            return \"NO\"\n        }\n    \
    \    val numOfExchangedElements = 0\n        lst2.zip(lst1).filter(_._1.toLong\
    \ % 2 == 0 && _._1.toLong > _._2.toLong).foreach {case (a, b) =>\n           \
    \ val index = lst2.indexOf(b)\n            lst2.remove(index)\n            lst2.insert(index,\
    \ b)\n            numOfExchangedElements += 1\n        }\n        if(lst2.size\
    \ < lst1.size){\n            return \"NO\"\n        }\n        else{\n       \
    \     if((lst1.size == lst2.size) && lst2.size == numOfExchangedElements){\n \
    \               return \"YES\"\n            }\n            else{\n           \
    \     return \"NO\"\n            }\n        }", "        var lst3 = lst1\n   \
    \     val evenNumbers = lst3.filter(x => x.toDouble % 2 == 0)\n        val lst4\
    \ = lst2.filter(x => x.toDouble % 2 == 0)\n        if (lst4.size == 0) return\
    \ \"NO\"\n        val lst5 = evenNumbers.filterNot(lst4.contains)\n        val\
    \ lst6 = lst5.map(x => x - lst4.size)\n        lst3.zip(lst6).map(x => (x._1,\
    \ x._2)).toList.sortBy(x => x._1).reverse.map {\n            x => (x(0)._1, x(1)._2)\n\
    \        }.forall { x =>\n            lst3.contains(x._1)\n        }.foldLeft(\"\
    \") {\n            (x, y) => x + (if (y.contains(\"YES\")) \"YES\" else \"NO\"\
    )\n        }", "        var lst3 = (lst1 zip lst2).filter(_._1 == _._1)\n    \
    \    if (lst3.isEmpty && lst2.isEmpty && lst1.isEmpty)\n        \treturn \"NO\"\
    \n        else if (lst3.isEmpty && lst2.isEmpty && lst1.isDefinedAt){\n      \
    \      return \"YES\"\n        }\n        else if (lst2.isEmpty && lst1.isDefinedAt){\n\
    \            return \"NO\"\n        }\n        else if (lst1.isDefinedAt && !lst3.isDefinedAt){\n\
    \            return \"YES\"\n        }\n        else if (!lst1.isDefinedAt &&\
    \ lst2.isDefinedAt){\n            return \"NO\"\n        }\n        else if (lst1.isDefinedAt\
    \ && !lst2.isDefinedAt){\n            return \"NO\"\n        }\n        else{\n\
    \            lst3.foreach{t => lst1 = List(t._1, t._2)}\n            if (lst1.isEven)\
    \ {\n                return \"YES\"\n            }\n            else{\n      \
    \          return \"NO\"\n            }\n        }", "        def exchangeElements(lst1\
    \ : List[Long], lst2 : List[Long], i : Int, lstResults : List[Long]) : List[Long]\
    \ = {\n            if (lst1.isEmpty) {\n                lstResults\n         \
    \   } else if (lst2.isEmpty) {\n                if (lst1.head % 2 != 0 && lst2.head\
    \ % 2 != 0) {\n                    lstResults ::= lst1.head :: lst2.head\n   \
    \             } else {\n                    if (lst1.head % 2 == 0 && lst2.head\
    \ % 2 != 0) {\n                        lstResults ::= lst1.head :: lst2.head ::\
    \ lst1.last\n                    } else if (lst1.head % 2 != 0 && lst2.head %\
    \ 2 == 0) {\n                        lstResults ::= lst1.head :: lst2.head ::\
    \ lst1.last\n                    } else if (lst1.head % 2 == 0 && lst2.head %\
    \ 2 == 0) {\n                        lstResults ::= lst1.head :: lst2.head ::\
    \ lst1.last :: lst2.last\n                    }\n                }\n         \
    \   } else if (lst1.head == lst2.head) {\n                lstResults ::= lst2.head\
    \ :: lst2.last\n            } else {\n                val lst3 = lst1.head ::\
    \ lst1.last\n                val lst4 = lst2.head :: lst2.last\n             \
    \   if (lst3 % 2 == 0) {\n                    if (lst4 % 2 != 0) {\n         \
    \               lstResults ::= lst3 :: lst4.head :: lst4.last\n              \
    \      } else if (lst4 % 2 == 0) {\n                        lstResults ::= lst3\
    \ :: lst4.head :: lst4.last :: lst2.last\n                    }\n            \
    \    } else {\n                    if (lst4 % 2 != 0) {\n                    \
    \    lstResults ::= lst3.head :: lst4 :: lst2.head :: lst2.last\n            \
    \        } else if (lst4 % 2 == 0) {\n                        lstResults ::= lst3.head\
    \ :: lst4 :: lst2.head :: lst2.last :: lst2.last\n                    }\n    \
    \            }\n            }\n            exchangeElements(lst1.tail, lst2.tail,\
    \ i + 1, lstResults)\n        }\n        exchangeElements(lst1, lst2, 0, Nil)",
  "        val even = lst1.filter( x => x % 2 == 0)\n        val odd = lst2.filter(\
    \ x => x % 2 == 1)\n        if(even.size == 0 && odd.size == 0){\n           \
    \ return \"NO\"\n        }\n        else if(even.size == 0 || odd.size == 0){\n\
    \            return \"NO\"\n        }\n        if(even.size != 0 && odd.size !=\
    \ 0){\n            if(even.length != odd.length){\n                return \"NO\"\
    \n            }\n            else if(even.size == 1){\n                even.headOption\
    \ match {\n                    case Some(evenNum) => odd.headOption match {\n\
    \                        case Some(oddNum) =>\n                            lst1.remove(evenNum)\n\
    \                            lst2.remove(oddNum)\n                           \
    \ return \"NO\"\n                        case None => return \"NO\"\n        \
    \            }\n                    case None => return \"NO\"\n             \
    \   }\n            }\n            else if(odd.size == 1){\n                even.headOption\
    \ match {\n                    case Some(evenNum) => odd.headOption match {\n\
    \                        case Some(oddNum) =>\n                            lst1.remove(evenNum)\n\
    \                            lst2.remove(oddNum)\n                           \
    \ return \"NO\"\n                        case None => return \"NO\"\n        \
    \            }\n                    case None => return \"NO\"\n             \
    \   }\n            }\n        }\n        else if(even.size == 1 && odd.size ==\
    \ 1){\n            even.headOption match {\n                case Some(evenNum)\
    \ => odd.headOption match {\n                    case Some(oddNum) =>\n      \
    \                  lst1.remove(evenNum)\n                        lst2.remove(oddNum)\n\
    \                        return \"NO\"\n                    case None => return\
    \ \"NO\"\n                }\n                case None => return \"NO\"\n    \
    \        }\n        }\n        else{\n            return \"NO\"\n        }", " \
    \       var exchange :List[Long] = lst1\n        var list : List[Long] = lst2\n\
    \        for (x <- exchange ; if list.contains(x)){\n            exchange.remove(x)\n\
    \            exchange.insert(x, list.indexOf(x))\n        }\n        if (exchange.isEmpty)\
    \ (\"YES\")\n        else (\"NO\")", '        // Your code here', "        val\
    \ evens = lst1.filter(x => x % 2 == 0)\n        val odds = lst2.filter(x => x\
    \ % 2 == 1)\n        val lst3 = evens.union(odds)\n        if (lst3.length ==\
    \ lst1.length) \n            lst3.map(x=>x%2).toString.equals(\"YES\") ? \"YES\"\
    \ : \"NO\" \n        else\n            \"\"", "        // Your code here\n   \
    \     var even1 = false\n        var even2 = false\n        for(i <- lst1){\n\
    \            even1 = even1 || ((i.toLong % 2) == 0l)\n        }\n        for(i\
    \ <- lst2){\n            even2 = even2 || ((i.toLong % 2) == 0l)\n        }\n\
    \        if(even1 && even2)\n            return \"YES\"\n        else if(even1\
    \ && !even2)\n            return \"NO\"\n        else if(!even1 && even2)\n  \
    \          return \"NO\"\n        else if(!even1 && !even2)\n            return\
    \ \"NO\"", "        if(lst1 == null || lst2 == null || lst1.length == 0 || lst2.length\
    \ == 0) \"NO\"\n        else {\n            var count = 1\n            val map1\
    \ = lst1.map(_.toLong).distinct.toMap\n            val map2 = lst2.map(_.toLong).distinct.toMap\n\
    \            map1.foreach {\n                case (x: Long) => {\n           \
    \         map2.remove(x)\n                    count += 1\n                }\n\
    \            }\n            if(count > 1) \"YES\"\n            else exchange(lst1.filterNot(x\
    \ => map1.contains(x)).toList, lst2.filterNot(x => map2.contains(x)).toList)\n\
    \        }", "        var i = 0\n        // while lst1 contains even nums\n  \
    \      while (i < lst1.length-1 && lst1(i).even) {\n            i += 1\n     \
    \   }\n\n        var j = 0\n        // while lst2 contains even nums\n       \
    \ while (j < lst2.length-1 && lst2(j).even) {\n            j += 1\n        }\n\
    \n        // if lst1 and lst2 are different\n        if (i != j) {\n         \
    \   var exchanged_even = 0\n            // while lst1 contains even nums\n   \
    \         while (i < lst1.length-1 && lst1(i).even) {\n                i += 1\n\
    \                exchanged_even += 1\n            }\n            // while lst2\
    \ contains even nums\n            while (j < lst2.length-1 && lst2(j).even) {\n\
    \                j += 1\n                exchanged_even += 1\n            }\n\
    \            // if lst1 and lst2 are not the same\n            // but lst1 is\
    \ longer and has more even nums\n            if (i != j && exchanged_even > lst1.length\
    \ - lst2.length) {\n                return \"NO\"\n            }\n           \
    \ // if lst1 and lst2 are not the same\n            // and lst2 is longer and\
    \ has more even nums\n            if (i != j && exchanged_even > lst1.length -\
    \ lst2.length && exchanged_even > lst2.length - lst1.length) {\n             \
    \   return \"NO\"\n            }\n            // if lst1 and lst2 are the same\
    \ or lst1 is longer\n            if (i != j && exchanged_even < lst1.length -\
    \ lst2.length) {\n                return \"YES\"\n            }\n        }\n \
    \       // if lst1 and lst2 are the same or lst1 is longer\n        if (i != j\
    \ && i < lst1.length-1) {\n            return \"YES\"\n        }\n        // if\
    \ lst1 and lst2 are the same or lst1 is longer\n        if (i != j && j < lst2.length-1)\
    \ {\n            return \"YES\"\n        }\n        // if lst1 and lst2 are the\
    \ same or lst1 is longer\n        if (i < lst1.length-1) {\n            return\
    \ \"YES\"\n        }\n        // if lst1 and lst2 are the same or lst1 is longer\n\
    \        if (j < lst2.length-1) {\n            return \"YES\"\n        }\n   \
    \     // if lst1 and lst2 are the same or lst1 is longer\n        // and they\
    \ all have even nums\n        return \"YES\"", "        //TODO: Your code goes\
    \ here\n        //assert(lst1.isEmpty)\n        //assert(lst2.isEmpty)\n     \
    \   if (lst1.length == 0 || lst2.length == 0) {\n            return \"\"\n   \
    \     }\n        val lst1set = lst1.toSet\n        val lst2set = lst2.toSet\n\
    \        val exchangeSet = lst1set & lst2set\n        val exchange = exchangeSet.count(_\
    \ % 2 == 0).toString.toUpperCase\n        if (exchange == \"YES\") {\n       \
    \     return \"YES\"\n        } else {\n            return \"NO\"\n        }",
  "        val lst1Copy = lst1.copy.toList\n        val lst2Copy = lst2.copy.toList\n\
    \        lst2Copy.foreach{ x =>\n            lst1Copy.remove(x)\n        }\n \
    \       lst1Copy.foreach{ x =>\n            if (x % 2 == 0) {\n              \
    \  return \"YES\"\n            }\n        }\n        return \"NO\"", "       \
    \ val even = lst2.filter(x => x.toInt%2 == 0).toList\n        val odd = lst2.filter(x\
    \ => x.toInt%2 != 0).toList\n        val evenAndOdd = even.intersect(odd)\n  \
    \      evenAndOdd.filter(x => lst1.contains(x)).toList.map(x => if (lst1.contains(x)).toList.map(x\
    \ => (x,x)).toSet.toList.map(x => x(0) + x(1)).map(\"+\"+_).map(x => if (x ==\
    \ x) \"+\"+_ else \"+\"+x).mkString(\" \") -> \"YES\"\n        else \"\"", " \
    \       val count = new HashMap[Long,Int]()\n        for (i <- lst1 diff lst2){\n\
    \            val count = count.getOrElse(i, 0) + 1\n            if (count == 2){\n\
    \                return \"YES\"\n            }\n            count.put(i, count)\n\
    \        }\n        return \"NO\"", '        // Your code here', "        // Your\
    \ code here\n        var evenNums = lst1.filter(x => x % 2 == 0).sortWith((a,\
    \ b) => a < b).map(x => x.toLong)\n        var oddNums = lst2.filter(x => x %\
    \ 2 == 1).sortWith((a, b) => a < b).map(x => x.toLong)\n        var exchanged\
    \ = evenNums.intersect(oddNums).map(x => x + 1).toList\n        if (exchanged.isEmpty)\
    \ {\n            return \"NO\"\n        } else {\n            return \"YES\"\n\
    \        }", "        // TODO: Replace this line by code that solves the problem\n\
    \        // Explain in words the steps you need to take to solve the problem",
  "        if (lst1 == null || lst2 == null || lst1.isEmpty) {\n            lst1 match\
    \ {\n                case Nil => \"NO\"\n                case _ => \"YES\"\n \
    \           }\n        }\n        if (lst1 == null || lst2 == null || lst2.isEmpty)\
    \ {\n            lst2 match {\n                case Nil => \"NO\"\n          \
    \      case _ => \"YES\"\n            }\n        }\n        var temp1 = lst1.drop(1).toList\n\
    \        var temp2 = lst2.drop(1).toList\n        val lst1_copy = temp1.takeWhile(_\
    \ % 2 == 0)\n        val lst2_copy = temp2.takeWhile(_ % 2 == 0)\n        temp1\
    \ = lst1_copy.reverse\n        temp2 = lst2_copy.reverse\n        if (lst1.size\
    \ == lst2.size) {\n            var found = 0\n            var result = \"NO\"\n\
    \            var index = 0\n            while (index != lst1_copy.size) { //while\
    \ not equal\n                if (lst2_copy(index) == lst1_copy(index)) {\n   \
    \                 found += 1\n                    val temp1 = lst1_copy.take(found).toList\n\
    \                    val temp2 = lst2_copy.take(found).toList\n              \
    \      temp1 = temp1.reverse\n                    temp2 = temp2.reverse\n    \
    \                lst1_copy = temp1\n                    lst2_copy = temp2\n  \
    \              } else {\n                    if (found == (lst1_copy.size - 1))\
    \ {\n                        result = \"YES\"\n                    }\n       \
    \         }\n                index += 1\n            }\n            result\n \
    \       }\n        else {\n            \"NO\"\n        }", "        // TODO: Complete\
    \ this function\n        var i = 1\n        var j = 1\n        var found = false\n\
    \        var exchanged_element_count = 0\n        while(i < lst1.length && j <\
    \ lst2.length) {\n            if(lst1(i) == lst2(j)) {\n                found\
    \ = true\n                exchanged_element_count += 1\n                i += 1\n\
    \                j += 1\n            }\n            else if(found == true) {\n\
    \                if(exchanged_element_count == lst1.length - 1){\n           \
    \         if((lst1(i) % (lst2(j)))==0) {\n                        found = false\n\
    \                    }\n                    else {\n                        i\
    \ += 1\n                        j += 1\n                    }\n              \
    \  }\n                else {\n                    i += 1\n                }\n\
    \            }\n            else {\n                i += 1\n            }\n  \
    \      }\n        while(i < lst1.length) {\n            if(lst1(i) != 0) {\n \
    \               found = true\n                exchanged_element_count += 1\n \
    \               i += 1\n            }\n            else {\n                i +=\
    \ 1\n            }\n        }\n        while(j < lst2.length) {\n            if(lst2(j)\
    \ != 0) {\n                found = true\n                exchanged_element_count\
    \ += 1\n                j += 1\n            }\n            else {\n          \
    \      j += 1\n            }\n        }\n        if(exchanged_element_count ==\
    \ lst1.length)\n            return \"NO\"\n        else\n            return \"\
    YES\"", "        if(lst1.isEmpty)\n           if(lst2.isEmpty)\n             \
    \ return \"NO\"\n           else\n              return \"YES\"\n        else\n\
    \           if(lst2.isEmpty)\n              return \"YES\"\n           else\n\
    \              return  exchange(lst1.tail, lst2.tail).map(\"YES\").orElse(\"NO\"\
    )", "        // TODO: implement the function here\n        return \"NO\"", " \
    \       val first = lst1(0)\n        val second = lst2(0)\n        val exchanged\
    \ = mutable.LinkedListBuffer.empty[Long]\n        val even = mutable.LinkedListBuffer.empty[Long]\n\
    \n        var temp = second\n        var j = 0\n        lst2.remove(second)\n\
    \        lst1.remove(first)\n        lst2.remove(temp)\n        lst1.remove(temp)\n\
    \        lst1 foreach {\n            x => exchanged += x\n        }\n\n      \
    \  lst2 foreach {\n            x => even += x\n        }\n\n        if (exchanged.size\
    \ == 0 && even.size == 0){\n            return \"YES\"\n        }else{\n     \
    \       return \"NO\"\n        }", "        // DO NOT USE Arrays or Lists.\n \
    \       // Arrays cannot be modified.\n        // Lists cannot be modified.\n\
    \        \n        lst1.toSet.intersect(lst2.toSet).forall(x => x % 2 == 0)",
  "        // Your code here\n        val lst3 = lst1.takeWhile( x => lst2.contains(x)\
    \ )\n        val lst4 = lst2.takeWhile( x => lst1.contains(x) )\n        if(lst3.length\
    \ == 0){\n            \"NO\"\n        }else if(lst4.length == 0){\n          \
    \  \"NO\"\n        }else{\n            \"YES\"\n        }", "        var lst1Len\
    \ = lst1.length\n        var lst2Len = lst2.length\n        var res = \"\"\n\n\
    \        while(lst1Len != lst2Len){\n            var temp = lst1.head\n      \
    \      lst1.head = (lst1.head % 2l).toLong\n            lst1.head = (lst1.head\
    \ + temp%2l).toLong\n            lst1.tail -= (lst2.head % 2l).toLong\n      \
    \      lst2.head = (lst2.head + temp%2l).toLong\n            lst2.tail -= (lst1.head\
    \ % 2l).toLong\n            res = res + \"YES\"\n        }\n        if(lst1.length\
    \ == 0 && lst2.length == 0){\n            res = \"NO\"\n        }\n        else\
    \ if(lst1.length == 0){\n            res = res + \"NO\"\n        }\n        else{\n\
    \            res = res + \"NO\"\n        }\n        res", '        // Solution
    here', "        val temp1 = lst1.toSet\n        val temp2 = lst2.toSet\n     \
    \   temp1 -- temp2", "        if(lst1.isEmpty) return \"NO\"\n        val lst3\
    \ = lst1.filter(_.toLong % 2 == 0)\n        if(lst3.isEmpty) return \"NO\"\n \
    \       val l1 = lst3.head + 1\n        val l2 = lst3.last\n        val l3 = lst2.head\
    \ + 1\n        val l4 = lst2.last\n        if(l1 == l2 && l2 == l3) \"YES\"\n\
    \        else if(l1 == l2 && l2 != l3) \"NO\"\n        else if(l1 == l2 && l3\
    \ == l4) \"NO\"\n        else if(l1 == l2 && l2 != l4) \"YES\"\n        else if(l1\
    \ == l3 && l2 == l4) \"NO\"\n        else if(l1 == l3 && l2 != l4) \"YES\"\n \
    \       else if(l1 == l4 && l2 == l3) \"NO\"\n        else if(l1 == l4 && l2 !=\
    \ l3) \"YES\"\n        else exchange(lst1, lst2)", "        val lst3 = lst1.toList\n\
    \        val lst4 = lst2.toList\n        val lst5 = lst3.filter(_ % 2 == 0).filter(_\
    \ != 2l.toLong)\n        val lst6 = lst4.filter(_ % 2 == 0).filter(_ != 2l.toLong)\n\
    \        if(lst5.size == lst6.size){\n            return \"NO\"\n        }\n \
    \       var i = 0\n        var j = 0\n        while(i < lst5.size && j < lst6.size){\n\
    \            if(lst5(i) > lst6(j)){\n                lst3(j) = lst5(i)\n     \
    \           lst5(i) = lst6(j)\n                lst6(j) = 2l.toLong\n         \
    \       j++\n            }\n            else{\n                lst3(j) = lst5(i)\n\
    \                lst5(i) = lst6(j)\n                lst6(j) = 2l.toLong\n    \
    \            i++\n            }\n        }\n        if(lst5.size == lst6.size){\n\
    \            return \"YES\"\n        }\n        lst3.toList.foreach(println)\n\
    \        return \"NO\"", "        lst1 ++ lst2.filter( x => x % 2 == 0 ) match\
    \ {\n            case x :: y => if (x.toDouble == y.toDouble) \"YES\" else \"\
    NO\"\n            case x :: y => \"NO\"\n            case _ => \"NO\"\n      \
    \  }", "        var even = lst1 filter { _ % 2 == 0 }\n        var odd = lst2\
    \ filter { _ % 2 == 1 }\n        if (even.isEmpty || odd.isEmpty) {\n        \
    \    return \"NO\"\n        }\n        val evenlist = even.map(_.toLong)\n   \
    \     val oddlist = odd.map(_.toLong)\n        val neweven = evenlist.zip(oddlist).map\
    \ { case (e1, e2) => e1.toLong to e2.toLong }.toMap\n        val newodd = evenlist.zip(oddlist).map\
    \ { case (e1, e2) => e2.toLong to e1.toLong }.toMap\n        if (neweven.keySet.forall(newodd.contains))\
    \ return \"YES\"\n        return \"NO\"", '        ', '        // TODO: Your code
    here!', "        val evenList = lst1.filter(_ % 2 == 0).sortWith(_ < _)\n    \
    \    val oddList = lst2.filter(_ % 2 != 0).sortWith(_ < _)\n        val evenListLength\
    \ = evenList.length\n        val oddListLength = oddList.length\n        if (evenListLength\
    \ == 0) \"NO\" else if (oddListLength == 0) \"YES\" else if (evenListLength <=\
    \ oddListLength) \"YES\" else \"NO\"", "        def allEven(lst: List): Boolean\
    \ = {\n          lst.filter{ x => x % 2 == 0 }.size == lst.size \n        }\n\
    \        if(lst1 == lst2 || lst2 == lst1 && !allEven(lst2) ) {\n            return\
    \ \"YES\"\n        } else {\n            return \"NO\"\n        }", "        lst1\
    \ map {n => (n % 2 == 0 && lst2 contains n) match {\n            case true =>\
    \ \"YES\"\n            case false => \"NO\"\n        }", '        // TODO: define
    your solution here', "        val evens = lst1.filter(x => x % 2l.toLong == 0l.toLong)\n\
    \        val odds = lst2.filter(x => x % 2l.toLong != 0l.toLong)\n        var\
    \ even = 0\n        var odd = 0\n        var c = 0\n        var i = 0\n      \
    \  var j = 0\n        var even1 = 0\n        var odd1 = 0\n        var even2 =\
    \ 0\n        var odd2 = 0\n        while (c < evens.size || c < evens.size + odds.size)\
    \ {\n            if (c < evens.size) {\n                if (odd < evens.size)\
    \ {\n                    if (odd1 >= evens.size + odds.size) {\n             \
    \           even1 += even(c).toLong\n                        odd1 += odd(c).toLong\n\
    \                        even1 += even1\n                        odd1 += odd1\n\
    \                    } else {\n                        even1 += even(c).toLong\n\
    \                        even1 += even1\n                    }\n             \
    \   } else {\n                    if (even1 >= evens.size + odds.size) {\n   \
    \                     even1 += even(c).toLong\n                        even1 +=\
    \ even1\n                    } else {\n                        even1 += even(c).toLong\n\
    \                        even1 += even1\n                    }\n             \
    \   }\n                even += even1\n                even1 += even(c).toLong\n\
    \            }\n            if (c < evens.size + odds.size) {\n              \
    \  if (odd < odds.size) {\n                    if (odd2 >= evens.size + odds.size)\
    \ {\n                        odd2 += odd(c).toLong\n                        odd2\
    \ += odd1\n                        even2 += even(c).toLong\n                 \
    \       even2 += even2\n                    } else {\n                       \
    \ odd2 += odd(c).toLong\n                        odd2 += odd2\n              \
    \      }\n                } else {\n                    if (even2 >= evens.size\
    \ + odds.size) {\n                        even2 += even(c).toLong\n          \
    \              even2 += even2\n                    } else {\n                \
    \        even2 += even(c).toLong\n                        even2 += even2\n   \
    \                 }\n                }\n                odd += odd2\n        \
    \        odd2 += odd(c).toLong\n            }\n            c += 2\n        }\n\
    \        if (even % 2l.toLong == 0l.toLong) {\n            if (odd % 2l.toLong\
    \ == 0l.toLong) {\n                return \"NO\"\n            } else {\n     \
    \           return \"YES\"\n            }\n        } else {\n            if (odd\
    \ % 2l.toLong == 0l.toLong) {\n                return \"YES\"\n            } else\
    \ {\n                return \"NO\"\n            }\n        }", "        lst1 match\
    \ {\n            case x :: Nil => \"NO\"\n            case y :: Nil => \"YES\"\
    \n            case x :: y :: xs => {\n                val i = lst1.indexOf(x)\n\
    \                val j = lst2.indexOf(y)\n                if (i < j) {\n     \
    \               if (i==0) {\n                        val temp = lst1(1); lst1(1)\
    \ =lst2(1); lst2(1) = temp\n                        exchange(lst1, lst2)\n   \
    \                 } else {\n                        val temp = lst1(1); lst1(1)\
    \ =lst2(1); lst2(1) = temp\n                        exchange(lst1, lst2)\n   \
    \                 }\n                } else {\n                    if (j==0) {\n\
    \                        val temp = lst1(1); lst1(1) =lst2(1); lst2(1) = temp\n\
    \                        exchange(lst1, lst2)\n                    } else {\n\
    \                        val temp = lst1(1); lst1(1) =lst2(1); lst2(1) = temp\n\
    \                        exchange(lst1, lst2)\n                    }\n       \
    \         }\n            }\n        }", "        // TODO: Write your code in here.\n\
    \        var i = lst1.head - 1\n        var j = lst2.head - 1\n        var count\
    \ = 0\n        while (i <= j) {\n            if (lst1(j) % lst1(i) == 0) {\n \
    \               count += 1\n            } else {\n                count -= 1\n\
    \            }\n            i += 1\n            j -= 1\n        }\n        if\
    \ (count == 0) {\n            return \"YES\"\n        } else {\n            return\
    \ \"NO\"\n        }", "        //Write your code here\n        \n        if (lst1.isEmpty)\
    \ {\n            lst1 +: lst2\n        }\n        if (lst2.isEmpty) {\n      \
    \      lst1 +: lst2\n        }\n        if (lst1.isEmpty && lst2.isEmpty) {\n\
    \            lst1 +: lst2\n        }\n        if (lst1.isEmpty) {\n          \
    \  lst1 +: lst2\n        }\n        if (lst2.isEmpty) {\n            lst1 +: lst2\n\
    \        }\n        if (lst1.isEmpty || lst2.isEmpty) {\n            \"NO\"\n\
    \        }\n        \n        val lst1_even = lst1.filter(x => x % 2 == 0).toList\n\
    \        val lst2_even = lst2.filter(x => x % 2 == 0).toList\n        if (lst1_even.isEmpty\
    \ || lst2_even.isEmpty) {\n            \"NO\"\n        }\n        var lst3 = lst1.toList\n\
    \        lst3 ++= lst2\n        lst3 ++= lst2_even\n        lst3 ++= lst1_even\n\
    \        //lst3 ++= lst1.filter(x => x % 2 == 0)\n        //lst3 ++= lst2.filter(x\
    \ => x % 2 == 0)\n        val isEven = lst3.filter(x => x % 2 == 0).toList.size\
    \ == lst3.size\n        val result = if (isEven) \"YES\" else \"NO\"\n       \
    \ \n        return result", "        // TODO: Implement me\n        val len =\
    \ lst1.length\n        val len2 = lst2.length\n        val ev = mutable.Buffer[Long]()\n\
    \        if(len == 0 || len2 == 0){\n            \"\"\n        }else{\n      \
    \      for(i<- 0 until len){\n                if(lst1(i) ==  lst2(i)){\n     \
    \               ev += lst1(i)\n                }\n            }\n            val\
    \ even = ev.filter(x => x % 2 == 0)\n            if(even.length == 0){\n     \
    \           return \"NO\"\n            }else{\n                \"\"\n        \
    \    }\n        }", "        // Your code here\n        var count = 0\n      \
    \  for( i <- 0 until lst1.length ){\n            if( lst1(i) == lst2(0) ){\n \
    \               count += 1\n            }\n        }\n        if( count == lst2.length\
    \ ) {\n            val even = lst1.filter { x => x % 2 == 0 }\n            val\
    \ evenList = even.mkString\n            val odd = lst2.filter { x => x % 2 ==\
    \ 1 }\n            val oddList = odd.mkString\n            if( (evenList == even)\
    \ && (oddList == odd) ){\n                return \"YES\"\n            }\n    \
    \    }\n        return \"NO\"", "        // Write your code here.\n        var\
    \ lst1 : (List[Long], List[Long]) = (lst1, lst2)\n        var lst2 : List[Long]\
    \ = lst1\n        var temp : List[Long] = lst1\n        for (l1 <- lst1 :: lst2)\
    \ {\n            if (l1 % 2 == 0) {\n                lst1.remove(l1)\n       \
    \         lst2.remove(l1)\n            }\n        }\n        if (lst2.isEmpty)\
    \ {\n            return \"YES\"\n        } else {\n            return \"NO\"\n\
    \        }", "        lst1.foreach { (x @ _) =>\n            lst2.foreach { (y\
    \ @ _) =>\n                if (x != y && x * y == x)\n                    return\
    \ \"YES\"\n            }\n        }\n        \"NO\"", "        val a = lst1 diff\
    \ lst2\n        val b = lst1 diff a\n        val c = a diff lst2\n        val\
    \ d = a diff c\n        val e = b diff c\n        val f = b diff e\n        val\
    \ g = c diff e\n        val h = c diff f\n        val i = d diff f\n        val\
    \ j = d diff h\n        val k = e diff h\n        val l = e diff k\n        val\
    \ m = f diff k\n        val n = f diff l\n        val o = g diff l\n        val\
    \ p = g diff m\n        val q = h diff m\n        val r = h diff n\n        val\
    \ s = i diff n\n        val t = i diff o\n        val u = j diff o\n        val\
    \ v = j diff p\n        val w = k diff p\n        val x = k diff q\n        val\
    \ y = l diff q\n        val z = l diff r\n\n        if(a.contains(0l) || b.contains(0l)\
    \ ||\n            c.contains(0l) || d.contains(0l) ||\n            e.contains(0l)\
    \ || f.contains(0l) ||\n            g.contains(0l) || h.contains(0l) ||\n    \
    \        i.contains(0l) || j.contains(0l) ||\n            k.contains(0l) || l.contains(0l)\
    \ ||\n            m.contains(0l) || n.contains(0l) ||\n            o.contains(0l)\
    \ || p.contains(0l) ||\n            q.contains(0l) || r.contains(0l) ||\n    \
    \        s.contains(0l) || t.contains(0l) ||\n            u.contains(0l) || v.contains(0l)\
    \ ||\n            w.contains(0l) || x.contains(0l) ||\n            y.contains(0l)\
    \ || z.contains(0l)) {\n            return \"NO\"\n        }\n        else {\n\
    \            return \"YES\"\n        }", "        def exchange(lst1 : List[Long],\
    \ lst2 : List[Long], result : List[Long]) : String = {\n            val numExchanged\
    \ : Int = 0\n            val newResult = result.take(result.size)\n          \
    \  val newLst = newResult.filter(x => x % 2 == 0).map(x => x - 1).toList\n   \
    \         val newLst1 = lst1.filter(x => x % 2 == 0).map(x => x - 1).toList\n\
    \            val newLst2 = lst2.filter(x => x % 2 == 0).map(x => x - 1).toList\n\
    \            newLst match {\n                case Nil =>\n                   \
    \ if (newResult.size == 0){\n                        result\n                \
    \    } else {\n                        exchange(newLst1, newLst2, newResult)\n\
    \                    }\n                case x => exchange(newLst1, newLst2, newResult\
    \ ++ newLst)\n            }\n        }\n        exchange(lst1, lst2, Nil).mkString(\"\
    \ \")", "        var count = 0\n        var j = 0\n        var k = 0\n       \
    \ var n = 0\n        while(j < lst1.length && k < lst2.length) {\n           \
    \ if(lst1(j) == lst2(k)) {\n                count += 1\n                j += 1\n\
    \                k += 1\n            }\n            else if(lst1(j) < lst2(k))\
    \ {\n                j += 1\n            }\n            else {\n             \
    \   k += 1\n            }\n        }\n        if(count != lst1.length) {\n   \
    \         return \"NO\"\n        }\n        else if(count == lst1.length) {\n\
    \            var count = 0\n            var n = 0\n            while(n < lst1.length)\
    \ {\n                if(lst1(n) % 2 == 0) {\n                    count += 1\n\
    \                }\n                n += 1\n            }\n            if(count\
    \ != lst1.length) {\n                return \"NO\"\n            }\n          \
    \  else {\n                return \"YES\"\n            }\n        }", "      \
    \  // Your code goes here\n        var result = \"NO\"\n        for(i <- 0 until\
    \ lst1.length){\n            var a = lst1(i).toInt\n            var b = lst2(i).toInt\n\
    \            var c = a * b\n            if(c % 2 == 0){\n                result\
    \ = \"YES\"\n            }\n        }\n        return result", "        if(lst1.size\
    \ == 0)\n            \"\"\n        else if(lst2.size == 0)\n            exchange(lst2.tail,\
    \ lst1.tail)\n        else {\n            val firstEven = lst1.filter(v => v.toInt\
    \ == 0).toList\n            val secondEven = lst2.filter(v => v.toInt == 0).toList\n\
    \            if(firstEven.size == lst1.size && secondEven.size == lst2.size)\n\
    \                exchange(lst1.tail, lst2.tail)\n            else if(firstEven.size\
    \ != lst1.size || secondEven.size != lst2.size)\n                \"NO\"\n    \
    \        else\n                exchange(firstEven, secondEven)\n        }", " \
    \       val even = lst1 filter (x => x % 2 == 0)\n        val odd = lst2 filter\
    \ (x => x % 2 == 1)\n        val evenEven = even zip odd.map(x => x._1 -> x._2)\n\
    \        val evenOdd = even zip odd.map(x => x._2 -> x._1)\n        val evenEvenOddEven\
    \ = evenEven zip evenOdd.map(x => x._1 -> x._2)\n        val evenEvenOddOdd =\
    \ evenEvenOdd zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOdd\
    \ = evenEvenOddEven zip evenOdd.map(x => x._1 -> x._2)\n        val evenEvenOddEvenOddOdd\
    \ = evenEvenOddEvenOdd zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOddEvenOdd\
    \ = evenEvenOddEvenOddEven zip evenOdd.map(x => x._1 -> x._2)\n        val evenEvenOddEvenOddEvenOddOdd\
    \ = evenEvenOddEvenOddEvenOdd zip evenOdd.map(x => x._2 -> x._1)\n        val\
    \ evenEvenOddEvenOddEvenOddEvenOdd = evenEvenOddEvenOddEvenOddOdd zip evenOdd.map(x\
    \ => x._1 -> x._2)\n        val evenEvenOddEvenOddEvenOddEvenOddOdd = evenEvenOddEvenOddEvenOddEvenOdd\
    \ zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOddEvenOddEvenOddEvenOdd\
    \ = evenEvenOddEvenOddEvenOddEvenOddOdd zip evenOdd.map(x => x._1 -> x._2)\n \
    \       val evenEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd = evenEvenOddEvenOddEvenOddEvenOddEvenOddOdd\
    \ zip evenOdd.map(x => x._2 -> x._1)\n        val evenEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddEvenOdd\
    \ = evenEvenOddEvenOddEvenOddEvenOddEvenOddEvenOddO", '        ', "        if(lst1.isEmpty)\
    \ {\n            \"\"\n        } else if(lst2.isEmpty) {\n            \"\"\n \
    \       } else {\n            val evenList = lst1.filter(_ % 2 == 0).map(x =>\
    \ x % 2 == 0).filter(x => lst2.contains(x))\n            if(evenList.forall(x=>x)){\n\
    \                \"YES\"\n            } else {\n                \"NO\"\n     \
    \       }\n        }", "        // Your code here.\n        var lst3 = lst1.sorted\n\
    \        var lst4 = lst2.sorted\n        var even = 0\n        var odd = 0\n \
    \       while (lst3.nonEmpty) {\n            even += lst3.head._2\n          \
    \  lst3.remove(lst3.head._1)\n        }\n        while (lst4.nonEmpty) {\n   \
    \         odd += lst4.head._2\n            lst4.remove(lst4.head._1)\n       \
    \ }\n        if ((even.equals(0l)) && (odd.equals(0l))) {\n            return\
    \ \"NO\"\n        }\n        if ((even.equals(0l)) && (odd.equals(0l))) {\n  \
    \          return \"YES\"\n        }\n        if ((even.equals(0l)) && (odd.equals(1l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(1l)) && (odd.equals(0l)))\
    \ {\n            return \"YES\"\n        }\n        if ((even.equals(1l)) && (odd.equals(1l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(2l)) && (odd.equals(0l)))\
    \ {\n            return \"YES\"\n        }\n        if ((even.equals(2l)) && (odd.equals(1l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(2l)) && (odd.equals(2l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(3l)) && (odd.equals(0l)))\
    \ {\n            return \"YES\"\n        }\n        if ((even.equals(3l)) && (odd.equals(1l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(3l)) && (odd.equals(2l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(3l)) && (odd.equals(3l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(4l)) && (odd.equals(0l)))\
    \ {\n            return \"YES\"\n        }\n        if ((even.equals(4l)) && (odd.equals(1l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(4l)) && (odd.equals(2l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(4l)) && (odd.equals(3l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(4l)) && (odd.equals(4l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(5l)) && (odd.equals(0l)))\
    \ {\n            return \"YES\"\n        }\n        if ((even.equals(5l)) && (odd.equals(1l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(5l)) && (odd.equals(2l)))\
    \ {\n            return \"NO\"\n        }\n        if ((even.equals(5l)) && (od",
  "        val l1 = lst1.toSet\n        val l2 = lst2.toSet\n        if (l1.size !=\
    \ l2.size) throw new Exception(\"The lists have different sizes\")\n        //\
    \ initialize result set to empty\n        var result = \"\"\n        // check\
    \ if there are any elements that can be exchanged.\n        if (l1.size == l2.size)\
    \ {\n            // if there are elements that can be exchanged, then add them\
    \ to result list.\n            for (x <- l1) {\n                if (l2.contains(x))\
    \ result = \"YES\"\n                else result = \"NO\"\n            }\n    \
    \    }\n        return result", "        lst1.zipWithIndex.zip(lst2.zipWithIndex).map\
    \ { case ((a, b), (c, d)) =>\n            // check whether an even index of each\
    \ list can be swapped\n            val evenIndex = a % 2 == 0 && b % 2 == 0 &&\
    \ c % 2 == 0 && d % 2 == 0\n            evenIndex && a != d && b != c && lst1(a)\
    \ == lst1(b) && lst1(b) == lst1(c) && lst1(c) == lst1(d) match {\n           \
    \     case true => \"YES\"\n                case _ => \"NO\"\n            }\n\
    \        }.last.map { x => x }", '        // TODO: Write your implementation here!',
  '        lst1.zip(lst2).filter(x => x._1 % 2 == 0).map { x => x._1.toLong + x._2.toLong
    }.toList.size == lst1.length ? "YES" : "NO"', "        // Your code here\n   \
    \     val a1 = lst1.toArray\n        val a2 = lst2.toArray\n        var i = 1\n\
    \        var j = 1\n        var even = true\n        while (i < a1.length && j\
    \ < a2.length){\n            if (a1(j) %% 2 == 0){\n                even = false\n\
    \            }\n            if (a2(j) %% 2 == 0){\n                even = false\n\
    \            }\n            if (even == true){\n                if (a1(j) >= a2(j)){\n\
    \                    a1(j) -= 1\n                    a2(j) -= 1\n            \
    \    }else{\n                    a1(j) += 1\n                    a2(j) += 1\n\
    \                }\n            }\n            i += 1\n            j += 1\n  \
    \      }\n        val evens = List(a1.filter(_ %% 2 == 0).toArray.mkString(\"\"\
    ))\n        if(evens.toList.size == 0){\n            \"NO\"\n        }else{\n\
    \            \"YES\"\n        }", "      var list1 = lst1.toSeq.sortWith(_ < _)\n\
    \      var list2 = lst2.toSeq.sortWith(_ < _)\n      var list1Even = list1.filter(_%2\
    \ == 0).map(x => x + list1.indexOf(x) + 1)\n      var list2Even = list2.filter(_%2\
    \ == 0).map(x => x + list2.indexOf(x) + 1)\n      var list1Odd = list1.filter(_%2\
    \ != 0).map(x => x + list1.indexOf(x))\n      var list2Odd = list2.filter(_%2\
    \ != 0).map(x => x + list2.indexOf(x))\n      var newList1 = new mutable.ArrayList[Long]()\n\
    \      var newList2 = new mutable.ArrayList[Long]()\n      var newList1Even =\
    \ new mutable.ArrayList[Long]()\n      var newList2Even = new mutable.ArrayList[Long]()\n\
    \      var newList1Odd = new mutable.ArrayList[Long]()\n      var newList2Odd\
    \ = new mutable.ArrayList[Long]()\n      var index1 = 0\n      var index2 = 0\n\
    \      while(index1 < list1.length && index2 < list2.length){\n        if(list1Even(index1)\
    \ == list2Even(index2)){\n          newList1Even.append(list1Even(index1))\n \
    \         newList2Even.append(list2Even(index2))\n          newList1.append(list1Odd(index1))\n\
    \          newList2.append(list2Odd(index2))\n          index1 += 1\n        \
    \  index2 += 1\n        } else if(list1Even(index1) != list2Even(index2)){\n \
    \         newList1Odd.append(list1Odd(index1))\n          newList2Odd.append(list2Odd(index2))\n\
    \          index1 += 1\n          index2 += 1\n        } else if(list1Odd(index1)\
    \ == list2Odd(index2)){\n          newList1Even.append(list1Even(index1))\n  \
    \        newList2Even.append(list2Even(index2))\n          index1 += 1\n     \
    \     index2 += 1\n        } else if(list1Odd(index1) != list2Odd(index2)){\n\
    \          newList1Odd.append(list1Odd(index1))\n          newList2Odd.append(list2Odd(index2))\n\
    \          index1 += 1\n          index2 += 1\n        } else {\n          newList1Odd.append(list1Odd(index1))\n\
    \          newList2Odd.append(list2Odd(", "        if (lst1.isEmpty) return \"\
    NO\"\n        if (lst2.isEmpty) return \"NO\"\n        \n        // A mutable\
    \ variable for storing number of exchanged elements.\n        // Initialize to\
    \ zero.\n        val exchanged = 0\n        \n        // Two variables for storing\
    \ two elements from lst1 and lst2 at a time.\n        var elem1 = lst1.head\n\
    \        var elem2 = lst2.head\n        \n        while (elem1 != elem2){\n  \
    \          \n            // If elem1 is even and elem2 is odd, we can exchange\n\
    \            // elem1.\n            if (elem1 % 2 == 0 && elem2 % 2 == 1) {\n\
    \                lst1 ::= elem2.toLong\n                lst2 ::= elem1.toLong\n\
    \                exchanged += 1\n            }\n            \n            // If\
    \ elem1 is odd and elem2 is even, we can exchange\n            // elem2.\n   \
    \         if (elem1 % 2 != 0 && elem2 % 2 != 0) {\n                lst1 ::= elem1.toLong\n\
    \                lst2 ::= elem2.toLong\n                exchanged += 1\n     \
    \       }\n            \n            // Update elem1.\n            elem1 = lst1.head\n\
    \            \n            // Update elem2.\n            elem2 = lst2.head\n \
    \       }\n        \n        // Return string \"YES\" if exchanged all elements\
    \ from lst1 and lst2.\n        if (exchanged >= lst1.length) return(\"YES\") else\
    \ \"NO\"", "        val lst1Odd : mutable.Set[Long] = new mutable.HashSet[Long](lst1)\n\
    \        val lst2Odd : mutable.Set[Long] = new mutable.HashSet[Long](lst2)\n \
    \       val newLst : mutable.List[Long] = new mutable.ArrayList[Long](lst1.size\
    \ + lst2.size)\n        var i = 0\n        while (i < lst1.size) {\n         \
    \   if (lst1Odd(i) == true) newLst.add(lst1(i))\n            if (lst2Odd(i) ==\
    \ true) newLst.add(lst2(i))\n            i += 1\n        }\n        val newLstOdd\
    \ : mutable.Set[Long] = new mutable.HashSet[Long](newLst)\n        if (lst1.size\
    \ == lst2.size && lst2Odd.size == lst1Odd.size) {\n            if (newLstOdd.size\
    \ == lst1Odd.size) return \"YES\"\n            return \"NO\"\n        }", "  \
    \      if(lst1.length == 0 || lst2.length == 0){\n            return \"NO\"\n\
    \        }\n        if(lst1.head == lst2.head){\n            if(lst1.head % 2\
    \ == 0){\n                return \"NO\"\n            }\n        }\n        else\
    \ if(lst2.head == lst1.head){\n            if(lst2.head % 2 == 0){\n         \
    \       return \"NO\"\n            }\n        }\n        else{\n            var\
    \ lst3 = lst1.tail\n            var lst4 = lst2.tail\n            val l = lst3.length\n\
    \            val r = lst4.length\n            var i = 0\n            var j = 0\n\
    \            for(i <- 0 until l){\n                for(j <- 0 until r){\n    \
    \                if(lst3(j) == lst4(i)){\n                        lst3(j) = lst3(i)\
    \ - lst3(i)\n                        lst4(i) = lst4(j) - lst4(i)\n           \
    \             break\n                    }\n                }\n            }\n\
    \            if(lst3.sum % 2 == 0){\n                return \"NO\"\n         \
    \   }\n        }\n        return \"YES\"", "        lst1.zip(lst2).map{\n    \
    \    case (a,b) if (b == 0) a.toLong * 2 == a.toLong else a.toLong / b\n    }.takeWhile{\
    \ elem => elem % 2 == 0}.isEmpty ? \"YES\" : \"NO\"", "        val evenList =\
    \ lst1.filter(_ % 2 == 0).toList\n        val oddList = lst1.filter(_ % 2 != 0).toList\n\
    \        val evenList2 = lst2.filter(_ % 2 == 0).toList\n        val oddList2\
    \ = lst2.filter(_ % 2 != 0).toList\n        if(evenList.size == 0 && oddList.size\
    \ == 0){\n            return \"NO\"\n        }else if(evenList.size == 0 && oddList.size\
    \ > 0){\n            return \"NO\"\n        }else if(evenList.size > 0 && oddList.size\
    \ == 0){\n            return \"NO\"\n        }else if(evenList.size == 0 && oddList.size\
    \ >0){\n            return \"YES\"\n        }else if(evenList.size == 0 && oddList.size\
    \ ==0 && evenList2.size ==0){\n            return \"YES\"\n        }else if(evenList.size\
    \ == 0 && oddList.size == 0 && evenList2.size >0){\n            return \"YES\"\
    \n        }else if(evenList.size > 0 && oddList.size == 0 && evenList2.size ==0){\n\
    \            return \"YES\"\n        }else if(evenList.size > 0 && oddList.size\
    \ == 0 && evenList2.size >0){\n            return \"YES\"\n        }else if(evenList.size\
    \ == 0 && oddList.size == 0){\n            return \"NO\"\n        }else if(evenList.size\
    \ > 0 && oddList.size == 0){\n            return \"YES\"\n        }else if(evenList.size\
    \ == 0 && oddList.size > 0){\n            return \"NO\"\n        }else if(evenList.size\
    \ > 0 && oddList.size >0){\n            return \"YES\"\n        }else{\n     \
    \       return \"NO\"\n        }", "        // Write your code here\n        lst1.toSet.toList.exists(lst2.toSet.toList.contains(_))",
  "        val n1 = lst1.size\n        val n2 = lst2.size\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var count = 0\n        while(i < n1\
    \ && j < n2){\n            if(lst1(j) == lst2(k)){\n                lst1(k) =\
    \ lst1(i)\n                lst1(i) = lst1(j)\n                lst1(j) = lst1(k)\n\
    \                lst2(k) = lst2(j)\n                lst2(j) = lst2(k)\n      \
    \          lst2(k) = lst2(j)\n                count +=1\n            }\n     \
    \       i += 1\n            j += 1\n            k += 1\n        }\n        if(count\
    \ == n1 && count == n2){\n            return \"YES\"\n        }\n        return\
    \ \"NO\"", "        var firstEven = lst1.filter(_ % 2 == 0).length\n        var\
    \ secondEven = lst2.filter(_ % 2 == 0).length\n\n        if (firstEven != secondEven)\
    \ {\n            return \"NO\"\n        }\n        // we only have odd numbered\
    \ elements in the list\n        // we check if each element in lst2 is even\n\
    \        lst2.filter(_ % 2 == 0).foreach {\n            x => if (lst1.contains(x))\
    \ {\n                firstEven = lst1.filter(_ % 2 == 0).length\n            \
    \    lst1.remove(x)\n            } else {\n                secondEven = lst2.filter(_\
    \ % 2 == 0).length\n                lst2.remove(x)\n            }\n        }\n\
    \n        if (firstEven != secondEven) {\n            return \"NO\"\n        }\n\
    \        // we have no remaining even-numbered elements in the list\n        //\
    \ we check if each element in lst1 is even\n        lst1.filter(_ % 2 == 0).foreach\
    \ {\n            x => if (lst2.contains(x)) {\n                firstEven = lst1.filter(_\
    \ % 2 == 0).length\n                lst1.remove(x)\n            } else {\n   \
    \             secondEven = lst2.filter(_ % 2 == 0).length\n                lst2.remove(x)\n\
    \            }\n        }\n        if (firstEven != secondEven) {\n          \
    \  return \"NO\"\n        }\n        // we have no remaining even-numbered elements\
    \ in the list\n        // we check if each element in lst2 is even\n        lst2.filter(_\
    \ % 2 == 0).foreach {\n            x => if (lst1.contains(x)) {\n            \
    \    firstEven = lst1.filter(_ % 2 == 0).length\n                lst1.remove(x)\n\
    \            } else {\n                secondEven = lst2.filter(_ % 2 == 0).length\n\
    \                lst2.remove(x)\n            }\n        }\n\n        // We have\
    \ all the even-numbered elements in lst1 list\n        // We have all the even-numbered\
    \ elements in lst2 list\n        // We exchange them together to make lst1 a list\
    \ with only even numbered elements\n        // We exchange them together to make\
    \ lst2 a list with only even numbered elements\n        // We check if lst1 and\
    \ lst2 are disjoint set\n        val set1 = new mutable.HashSet[Long]()\n    \
    \    val set2 = new mutable.HashSet[Long]()\n        lst1.foreach {\n        \
    \    x => if (!set1.contains(x)) {\n                set1 += x\n            }\n\
    \        }\n        lst2.foreach {\n            x => if (!set2.contains(x)) {\n\
    \                set2 += x\n            }\n        }\n        if (set1.toSet.subsetOf(set2))\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n", '        //
    SOLUTION GOES HERE', '        // Solution here', '        if(lst2.isEmpty) list1IsEven
    else list1IsNotEven', "        val lst1len = lst1.size\n        val lst2len =\
    \ lst2.size\n        var x = 0\n        var y = 0\n        val arr1 = new mutable.ArrayList[Long]\n\
    \        val arr2 = new mutable.ArrayList[Long]\n        while (x < lst1len) {\n\
    \            arr1.add(lst1.get(x))\n            x += 1\n        }\n        while\
    \ (y < lst2len) {\n            arr2.add(lst2.get(y))\n            y += 1\n   \
    \     }\n        val lst1even = arr1.filter(x=> x % 2 == 0).length\n        val\
    \ lst2even = arr2.filter(x=> x % 2 == 0).length\n        if (lst1even == lst2even)\
    \ {\n            // If list 1 and list 2 have same number of even elements, exchange\n\
    \            // will make them even too.\n            lst1.zipAll(lst2).map(x\
    \ => x(0))\n            val res1 = lst1.foldLeft(true)((acc, x) => {acc && x.toLong\
    \ % 2 == 0})\n            val res2 = lst2.foldLeft(true)((acc, x) => {acc && x.toLong\
    \ % 2 == 0})\n            if (res1 && res2) {\n                return \"YES\"\n\
    \            } else {\n                return \"NO\"\n            }\n        }",
  "        // TODO: Your code goes here\n        val even = lst1 filter (_ % 2 ==\
    \ 0)\n        if(even.nonEmpty) \n            \"YES\"\n        else \n       \
    \     \"NO\"", "        val list3 = lst1.take(lst1.size)\n        val list4 =\
    \ lst2.take(lst2.size)\n        if (list3.size == list4.size) {\n            val\
    \ list5 = list3.intersect(list4)\n            if (list5.size == 0)\n         \
    \       \"NO\"\n            else\n                \"YES\"\n        }\n       \
    \ else {\n            \"NO\"\n        }", '        ', "        val even = lst1\
    \ filter (_ % 2l.toLong == 0)\n        val odd : List[Long] = lst1 filter (_ %\
    \ 2l.toLong != 0)\n        if (even.isEmpty) odd.toString else \"NO\"", "    \
    \    // TODO: Write your code here\n        val countLst1 = lst1.count(x => x\
    \ % 2 == 0)\n        val countLst2 = lst2.count(x => x % 2 == 0)\n        if(countLst1\
    \ == countLst2){\n            \"NO\"\n        }else{\n            \"YES\"\n  \
    \      }", '        //YOUR CODE HERE', "        // Write your solution here!\n\
    \        lst1.zip(lst2).foldLeft(true) {\n            (acc,cur) => {\n       \
    \         val temp = cur._1\n                val temp2 = cur._2\n            \
    \    if(temp % 2 == 0) {\n                    acc && false\n                }\
    \ else {\n                    acc && true\n                }\n            }\n\
    \        }", "      val lst1 = lst1.toSet\n      val lst2 = lst2.toSet\n     \
    \ if(lst2.isEmpty && lst1.isEmpty) \"YES\" else (lst2 ++ lst1).foldLeft(\"\")({\n\
    \          case \"YES\" => \"NO\"\n          case \"NO\" => \"\"\n          case\
    \ (\"\", l1) =>\n            val even = (l1.toSet & lst2).toSet.toSeq\n      \
    \      val odd = (l1 -- even).toSet.toSeq\n            even.forall { x => odd\
    \ contains x }\n        })", "        var tmp : List[Long] = lst1.toList\n   \
    \     var a : Boolean = lst1.toList.size == lst2.toList.size\n        \n     \
    \   \n        \n        if(a == true){\n            var l1 = lst1.toList\n   \
    \         var l2 = lst2.toList\n            var a = false\n            var a :\
    \ Boolean = false\n            var a : Boolean = false\n            \n       \
    \     while(a != true){\n                \n                tmp = l1.takeWhile(a)\
    \ //l1.takeWhile(x => x != l2.head)\n                l1 -= tmp //l1 - tmp\n  \
    \              tmp = l2.takeWhile(a) //l2.takeWhile(x => x != l1.head)\n     \
    \           l2 -= tmp //l2 - tmp\n                a = true\n                \n\
    \                \n            }\n            \n            l1.zip(l2)\n     \
    \       .foreach(x => println(x._1 + \", \" + x._2))\n            \n        }\n\
    \        \n        if(a == false){\n            var l1 = lst1.toList\n       \
    \     var l2 = lst2.toList\n            var a = true\n            var a : Boolean\
    \ = false\n            \n            while(a != false){\n                \n  \
    \              tmp = l1.takeWhile(a) //l1.takeWhile(x => x != l2.head)\n     \
    \           l1 -= tmp //l1 - tmp\n                tmp = l2.takeWhile(a) //l2.takeWhile(x\
    \ => x != l1.head)\n                l2 -= tmp //l2 - tmp\n                a =\
    \ false\n                \n                \n            }\n            \n   \
    \         l1.zip(l2)\n            .foreach(x => println(x._1 + \", \" + x._2))\n\
    \            \n        }\n        \n        \n        \n        \n        ", " \
    \       // Write your code here\n        var a = lst1\n        var b = lst2\n\
    \        var c = a\n        var d = b\n        if(b.size > 0){\n            while(b.size\
    \ > 0){\n                if(a(0) < b(0) || (a(0) === b(0) && a(1) < b(1)) || (a(0)\
    \ === b(0) && a(1) === b(1) && a(2) < b(2))){\n                    a = b\n   \
    \                 d = a\n                    b.remove(0)\n                }\n\
    \                else{\n                    c = b\n                    c = a\n\
    \                    a.remove(0)\n                }\n            }\n         \
    \   a foreach println\n        }\n        else if(b.size == 0){\n            a\
    \ foreach println\n        }\n        else{\n            a foreach println\n \
    \       }\n        if(c.size > 0){\n            while(c.size > 0){\n         \
    \       if(a(0) < c(0) || (a(0) === c(0) && a(1) < c(1)) || (a(0) === c(0) &&\
    \ a(1) === c(1) && a(2) < c(2))){\n                    a = c\n               \
    \     d = a\n                    c.remove(0)\n                }\n            \
    \    else{\n                    b = c\n                    b = a\n           \
    \         a.remove(0)\n                }\n            }\n            a foreach\
    \ println\n        }\n        else if(c.size == 0){\n            a foreach println\n\
    \        }\n        else{\n            a foreach println\n        }\n        if(d.size\
    \ > 0){\n            while(d.size > 0){\n                if(a(0) < d(0) || (a(0)\
    \ === d(0) && a(1) < d[1]) || (a(0) === d(0) && a(1) === d(1) && a(2) < d[2])){\n\
    \                    a = d\n                    d = a\n                    d.remove(0)\n\
    \                }\n                else{\n                    b = d\n       \
    \             b = a\n                    a.remove(0)\n                }\n    \
    \        }\n            a foreach println\n        }\n        else if(d.size ==\
    \ 0){\n            a foreach println\n        }\n        else{\n            a\
    \ foreach println\n        }\n        if(b.size > 0){\n            while(b.size\
    \ > 0){\n                if(a(0) < b(0) || (a(0) === b(0) && a(1) < b(1)) || (a(0)\
    \ === b(0) && a(1) === b(1) && a(2) < b(2))){\n                    a = b\n   \
    \                 d = a\n                    b.remove(0)\n                }\n\
    \                else{\n                    c = b\n                    c = a\n\
    \                    a.remove(0)\n                }\n            }\n         \
    \   a foreach println\n        }\n        else if(b.size == 0){\n            a\
    \ foreach println\n        }\n        else{\n            a foreach println", " \
    \       if (lst2.isEmpty)\n            \"NO\"\n        else if (lst2.size > lst1.size)\n\
    \            \"NO\"\n        else if (lst2.size == lst1.size) {\n            var\
    \ i = 0\n            while (i < lst1.size) {\n                if (lst2(i) % 2\
    \ == 0) {\n                    lst1(i) = lst2(i)\n                    lst2(i)\
    \ = lst1(i)\n                }\n                i += 1\n            }\n      \
    \  }\n        \"YES\"", "        val newList = lst1.filter(x => !lst2.contains(x)).sorted\n\
    \        val newLst2 = lst2.filter(x => !lst1.contains(x))\n        val lst3 =\
    \ (newList ++ newLst2).distinct\n        val lst4 = lst3.filter(_ % 2 == 0).sorted\n\
    \        if(lst4.size == lst3.size) {\n            if(lst3.size == lst1.size ||\
    \ lst3.size == lst2.size) {\n                if(lst1.contains(lst3(0)) && lst2.contains(lst3(0)))\
    \ {\n                    return \"YES\"\n                }\n            }\n  \
    \      }\n        return \"NO\"", "        lst1 match {\n            case xs if\
    \ (xs.isEmpty) => \"NO\"\n            case xs if (xs.size != 2) => \"NO\"\n  \
    \          case xs => lst1 match {\n                case xs if (xs.size < 2) =>\
    \ \"NO\"\n                case xs if (xs.size == 2) => {\n                   \
    \ val lst3 = lst1 ::: lst2\n                    lst3.foreach( x => {\n       \
    \                 lst1 += x.toInt/2\n                        lst2 += x.toInt/2\n\
    \                    })\n                    lst3.foreach( x => {\n          \
    \              lst1 -= x\n                        lst2 -= x\n                \
    \    })\n                    if (lst1 == 0 :: lst2 == 0 :: Nil => \"NO\"\n   \
    \                 else if (lst1 == 0 :: lst2 == 1 :: Nil || lst1 == 1 :: lst2\
    \ == 0 :: Nil || lst1 == 1 :: lst2 == 1 :: Nil || lst1 == 2 :: lst2 == 0 :: Nil\
    \ || lst1 == 2 :: lst2 == 1 :: Nil) then \"YES\"\n                    else exchange(lst1,\
    \ lst2)\n                }\n                case xs if (xs.size == 3) => {\n \
    \                   val lst3 = lst1 ::: lst2\n                    lst3.foreach(\
    \ x => {\n                        lst1 += x.toInt/3\n                        lst2\
    \ += x.toInt/3\n                    })\n                    lst3.foreach( x =>\
    \ {\n                        lst1 -= x\n                        lst2 -= x\n  \
    \                  })\n                    if (lst1 == 0 :: lst2 == 0 :: Nil =>\
    \ \"NO\"\n                    else if (lst1 == 0 :: lst2 == 1 :: Nil || lst1 ==\
    \ 1 :: lst2 == 0 :: Nil || lst1 == 1 :: lst2 == 1 :: Nil || lst1 == 2 :: lst2\
    \ == 0 :: Nil || lst1 == 2 :: lst2 == 1 :: Nil) then \"YES\"\n               \
    \     else exchange(lst1, lst2)\n                }\n                case xs if\
    \ (xs.size == 4) => {\n                    val lst3 = lst1 ::: lst2\n        \
    \            lst3.foreach( x => {\n                        lst1 += x.toInt/4\n\
    \                        lst2 += x.toInt/4\n                    })\n         \
    \           lst3.foreach( x => {\n                        lst1 -= x\n        \
    \                lst2 -= x\n                    })\n                    if (lst1\
    \ == 0 :: lst2 == 0 :: Nil => \"NO\"\n                    else if (lst1 == 0 ::\
    \ lst2 == 1 :: Nil || lst1 == 1 :: lst2 == 0 :: Nil || lst1 == 1 :: lst2 == 1\
    \ :: Nil || lst1 == 2 :: lst2 == 0 :: Nil || lst", "        val lst1Map = lst1.map(x\
    \ => x -> 1).toMap\n        val lst2Map = lst2.map(x => x -> 1).toMap\n      \
    \  val newMap = lst1Map ++ lst2Map\n        val newList = newMap.map(x => x._1\
    \ -> x._2).map(x => x._1).filter(_ % 2 == 0).sortBy(_).toList\n        if(newList.size\
    \ == lst1.size)\n        { \n            val newListMap = newList.map(x => x ->\
    \ 1).toMap\n            val newListList = newListMap.map(x => x._1).filter(_ %\
    \ 2 == 0).sortBy(_).toList\n            if(newListList.size == lst2.size)\n  \
    \          {\n                if(newListList.mkString.equals(lst2.mkString))\n\
    \                {\n                    return(\"YES\")\n                }\n \
    \               else\n                {\n                    return(\"NO\")\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      return(\"NO\")\n        }", "        if(lst1.isEmpty) \"\"\n        if(lst2.isEmpty)\
    \ \"\"\n        val xs = lst2.toSet\n        val ys = lst1.toSet\n        val\
    \ zs = xs.intersection(ys)\n        if(zs.isEmpty) \"\"\n        else if(zs.size\
    \ == xs.size) \"YES\"\n        else \"\"", "        if (lst2.isEmpty) return \"\
    NO\"\n        var lst3 = lst1\n        var i = lst2.indexOf(lst1.last)\n     \
    \   if (i != -1) lst3 = lst3.remove(i)\n        val x = lst1.last\n        val\
    \ y = lst2.last\n        var j = 0\n        var k = lst2.lastIndexOf(x)\n    \
    \    while (k != -1) {\n            lst3.insert(j, lst2(k))\n            j++\n\
    \            k = lst2.lastIndexOf(x)\n        }\n        if (lst1 == lst3) \"\
    YES\" else \"NO\"", "        if (lst1.isEmpty)\n            (lst2.head % 2 ==\
    \ 0)\n        else\n            lst1.takeWhile(x => lst2.head % 2 == 0).last.isEven\
    \ == exchange(lst1.drop(1), lst2.drop(1))", "        var even = 0 //to keep track\
    \ of even numbers in lst1\n        var odd = 0 //to keep track of odd numbers\
    \ in lst1\n        var evenIndex = 0\n        var oddIndex = 0\n        evenIndex\
    \ = lst1.find(_ % 2 == 0).map(x => even += 1).orElse(evenIndex = 0)\n        oddIndex\
    \ = lst1.find(_ % 2 == 1).map(x => odd += 1).orElse(oddIndex = 0)\n        if(evenIndex\
    \ == 0 && oddIndex == 0){\n            return \"YES\"\n        }\n        if(evenIndex\
    \ == 0 && oddIndex != 0){\n            return \"NO\"\n        }\n        else\
    \ if(evenIndex != 0 && oddIndex == 0){\n            return \"NO\"\n        }\n\
    \        else if(evenIndex != 0 && oddIndex != 0){\n            val temp = lst1.take(evenIndex)\n\
    \            val temp2 = lst1.drop(evenIndex)\n            val temp3 = lst2.take(oddIndex)\n\
    \            val temp4 = lst2.drop(oddIndex)\n            if(lst1.size == temp4.size){\n\
    \                if(lst2.size == temp3.size){\n                    return exchange(temp,\
    \ temp2)\n                }\n                else{\n                    return\
    \ exchange(temp, temp3)\n                }\n            }\n            else if(lst2.size\
    \ == temp3.size){\n                return exchange(temp2, temp4)\n           \
    \ }\n            else{\n                return exchange(temp2, temp3)\n      \
    \      }\n        }", "        val even = lst1 filter (x => x % 2 == 0)\n    \
    \    val evenAndOdd = lst2 filter (x => x % 2 == 0)\n        if (even.isEmpty\
    \ || evenAndOdd.isEmpty) {\n            return \"NO\"\n        }\n        var\
    \ a = even(0)\n        var b = evenAndOdd(0)\n        for (i = 1 until evenAndOdd.size)\
    \ {\n            a = even(0)\n            b = evenAndOdd(i)\n            if (a\
    \ % 2 == 0) {\n                if (b > a && b % 2 == 0) {\n                  \
    \  even(0) = b\n                } else {\n                    even(0) = a\n  \
    \              }\n            } else {\n                if (b > a && b % 2 ==\
    \ 1) {\n                    even(0) = b\n                } else {\n          \
    \          even(0) = a\n                }\n            }\n        }\n        if\
    \ (even.isEmpty || evenAndOdd.isEmpty) {\n            return \"NO\"\n        }\n\
    \        return \"YES\"", "        if (lst1.length == 0){\n            if (lst2.length\
    \ == 0){\n                return \"NO\"\n            }\n            return \"\
    NO\"\n        }\n        var evenNum : List[Long] = lst1\n        var oddNum :\
    \ List[Long] = lst2\n        val newList = if (evenNum.filter(x => x % 2 == 0).length\
    \ == evenNum.size && oddNum.filter(x => x % 2 != 0).length == oddNum.size)\n \
    \           evenNum.filter(x => x % 2 == 0).zip(oddNum.filter(x => x % 2 != 0)).map(x\
    \ => (x(0).asInstanceOf[Long], x(1).asInstanceOf[Long])).toList\n        else\
    \ evenNum.filter(x => x % 2 == 0).zip(oddNum.filter(x => x % 2 != 0)).map(x =>\
    \ (x(0).asInstanceOf[Long], x(1).asInstanceOf[Long])).toList\n        if (newList.length\
    \ == 0){\n            return \"NO\"\n        }\n        else {\n            return\
    \ \"YES\"\n        }", "        val result: mutable.HashSet[Long] = mutable.HashSet()\n\
    \        lst1.foreach{x=>result.add(x)}\n        lst2.foreach{x=>result.add(x)}\n\
    \        if(result.toSet.size==lst1.size)\n            return \"YES\"\n      \
    \  else\n            return \"NO\"", "        // Write your code here\n      \
    \  val x = lst1.takeWhile(i => !lst2.contains(i))\n        val y = lst2.filter(i\
    \ => !lst1.contains(i))\n        if(x == y) \"YES\" else \"NO\"", "        var\
    \ count = 1\n        for(i <- 0 until lst1.length) yield {\n            if(lst1(count)\
    \ == lst1(count+1)) count += 1\n            else if(lst1(count) != lst1(count+1))\
    \ count = 1\n            else if(lst1(count) == lst1(count-1) && lst1(count) ==\
    \ lst1(count-2)) count += 1\n            else if(lst1(count) != lst1(count-1)\
    \ && lst1(count) != lst1(count-2)) count = 1\n            else count = 1\n   \
    \         if(count == lst1.length) return \"YES\"\n            else return \"\
    NO\"\n        }", "        if(lst1.isEmpty)\n            return lst2.isEmpty\n\
    \        else if(lst2.isEmpty)\n            return lst1.isEmpty\n        else\
    \ if(lst1.head % 2 == 0 && lst2.head % 2 == 0) {\n            val evens = lst1.tail\n\
    \            val odds  = lst2.tail\n            val exchanges = odds - evens\n\
    \            if(exchanges.isEmpty)\n                return \"YES\"\n         \
    \   else\n                return \"NO\"\n        }\n        else\n           \
    \ return \"NO\""]
stop_tokens:
- "\n    }\n"
