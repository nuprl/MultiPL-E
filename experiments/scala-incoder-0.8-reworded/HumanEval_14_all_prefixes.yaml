name: HumanEval_14_all_prefixes
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list of all prefixes from shortest to longest of the input string\n\
  \    // >>> allPrefixes((\"abc\"))\n    // (List[String](\"a\", \"ab\", \"abc\"\
  ))\n    def allPrefixes(string : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(allPrefixes((\"\"\
  )).equals((List[String]())));\n    assert(allPrefixes((\"asdfgh\")).equals((List[String](\"\
  a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"))));\n    assert(allPrefixes((\"\
  WWW\")).equals((List[String](\"W\", \"WW\", \"WWW\"))));\n    }\n\n}\n"
completions: ["        val prefix = new StringBuilder()\n        var index = -1\n\
    \        var i = 0\n        while (i < string.length) {\n            if (string.charAt(i)\
    \ == 'a') {\n                prefix.append(string.charAt(i))\n               \
    \ index = i\n            }\n            i += 1\n        }\n        if (prefix\
    \ == \"\") {\n            List(\"\")\n        } else {\n            var longest\
    \ = string.length\n            var longestIndex = 0\n            var i = 0\n \
    \           while (i < string.length) {\n                if (string.charAt(i)\
    \ == 'a') {\n                    prefix.append(string.charAt(i))\n           \
    \         longestIndex = i\n                    longest = string.length\n    \
    \            }\n                i += 1\n            }\n            for (i = longestIndex\
    \ + 1; i < string.length; i ++) {\n                prefix.append(string.charAt(i))\n\
    \            }\n            prefix.reverse\n        }", "        var allPrefixes\
    \ = new ListBuffer[String]()\n        var prefixLength = string.length\n     \
    \   while (prefixLength > 0) {\n            allPrefixes += string.substring(0,\
    \ prefixLength)\n            string = string.substring(prefixLength)\n       \
    \     prefixLength = string.length\n        }\n        allPrefixes += string\n\
    \        allPrefixes.toList", "        var result : List[String] = Nil\n     \
    \   var shortest = string\n        var longest = string\n        for(str <- string.length\
    \ until 0){\n            val prefix = string take(str)\n            result ::=\
    \ prefix\n            shortest = if (shortest.length > str) shortest.drop(str)\
    \ else shortest\n            longest = if (longest < prefix) prefix else longest\
    \ \n        }\n        result ::= shortest\n        result ::= longest\n     \
    \   result", "        var prefixes : List[String] = Nil\n        string match\
    \ {\n        case \"\" => prefixes = Nil\n        case s => allPrefixes(s.tail)\
    \ foreach (prefix => prefixes ::= prefix :: prefix.tail)\n        }\n        prefixes",
  "        val prefixes = new mutable.ListBuffer[String]\n        // Loop over the\
    \ string and append the first character\n        var currentLength = string.length\n\
    \        var currentPrefixes = List[String]()\n        while(currentLength > 0)\
    \ {\n            prefixes += string.substring(0, currentLength)\n            //\
    \ Add rest of the characters\n            currentPrefixes += string.substring(currentLength)\n\
    \            // Move to the next character\n            currentLength -= 1\n \
    \       }\n        // Return the list of prefixes\n        return prefixes.toList",
  "        var prefixes: List[String] = Nil\n        var current = string\n      \
    \  while (current != \"\") {\n            var next = current.substring(0,1);\n\
    \            var newPrefixes = prefixes :+ next\n            prefixes = newPrefixes\n\
    \            current = current.substring(1,current.length)\n        }\n      \
    \  prefixes", "        val prefixes = new mutable.ListBuffer[String]\n       \
    \ var prefix = \"\"\n        for( char <- string.toCharArray )\n            if(\
    \ char == prefix )\n                prefixes += prefix\n            else\n   \
    \             prefix = char+prefix\n        prefixes.toList", "        val prefixes\
    \ = mutable.ListBuffer.empty[String]\n        var currentPrefix = \"\"\n     \
    \   var length = string.length\n\n        for (x  <- 0 until length) {\n     \
    \       if (string(x) == currentPrefix)\n                prefixes += currentPrefix\n\
    \            else\n                prefixes += currentPrefix + string(x)\n   \
    \         currentPrefix = string(x - 1)\n        }\n        prefixes", "     \
    \   val prefix = List.empty[String]\n        var length = 0\n        var newPrefix\
    \ = prefix\n        for {\n            x <- string\n            y <- newPrefix\n\
    \        } yield {\n            x :: y\n        }", "        def recursive(string\
    \ : String, prefixes: List[String]) : List[String] =\n            if (string.length\
    \ == 0) prefixes else prefixes ::: recursive(string.substring(1), prefixes)\n\
    \        recursive(string, Nil).reverse", "       string.foldLeft(List[String]())((acc,\
    \ s) => {\n           if (acc.length == 0 || s.length < acc.head.length) acc :+\
    \ s\n           else allPrefixes(s.tail)\n       })", "        var prefixes: List[String]\
    \ = Nil\n        var i = 0\n        var j = string.length - 1\n        while (i\
    \ <= j) {\n            prefixes = prefixes :+ (string.substring(i, string.length))\n\
    \            i += 1\n        }\n        prefixes", "        val result = new mutable.MutableList[String]()\n\
    \        var i = 0\n        var temp = ''\n        while (i < string.length) {\n\
    \            temp = string.substring(i, string.length)\n            result.add(temp)\n\
    \            i = result.size - 1\n        }\n        return result.toList", " \
    \       val length = new mutable.HashMap[String, Int]()\n        def allPrefixesRecursive(prefix\
    \ : List[String]) : List[String] = {\n            if(string.length <= 0) prefix\n\
    \            else allPrefixesRecursive(prefix ::: prefix.reverse.tail) match {\n\
    \                case Nil => prefix\n                case prefix :: Nil => prefix\n\
    \                case prefix :: suffix => allPrefixesRecursive(prefix :: suffix)\n\
    \            }\n        }\n        length += (string -> string.length)\n     \
    \   allPrefixesRecursive(List[String]())", "        string.split(\"\").foldLeft(List[String]()){\n\
    \            (allPrefix, c) => allPrefix ::: list.takeWhile(_.length < c.length)\n\
    \        }.reverse", "        var prefixes = new mutable.ArrayBuffer[String]()\n\
    \        var current = new ListBuffer[String]()\n        for (ch <- string) {\n\
    \            current.append(ch)\n            if (ch == string.last) prefixes ++=\
    \ current\n        }\n        return prefixes.toList", "        def getPrefixes(i\
    \ : Int, string : String) : List[String] = {\n            if (i == string.length)\
    \ List(string)\n            else (0 to string.length - i)\n                .map\
    \ { x => string.substring(i, i+x) }\n                .map(x => getPrefixes(x +\
    \ 1, string))\n                .reduceLeft(_ ++ _)\n        }\n        getPrefixes(1,\
    \ string)", "        if (string.length == 1) List(string)\n        else allPrefixes(string.takeWhile(_\
    \ != 'a')) ++ allPrefixes(string.dropWhile(_ != 'a'))", "        val prefixes\
    \ = ListBuffer[String]()\n        for (c <- string) {\n            prefixes +=\
    \ c.toString\n            prefixes += c.toString.reverse\n            prefixes\
    \ += c.toString.reverse.tail\n            prefixes += c.toString.reverse.tail.tail\n\
    \        }\n        prefixes.reverse", "        var prefixes : List[String] =\
    \ Nil\n        var i = string.length\n        while (i >= 0) {\n            prefixes\
    \ = prefixes :+ string.substring(0, i)\n            i -= 1\n        }\n      \
    \  return prefixes", "        // Using mutable collection\n        val prefix\
    \ = mutable.ListBuffer[String]()\n        def findAllPrefixes(s : String, prefix\
    \ : mutable.ListBuffer[String]) : Unit = {\n            if (s.length == 0) prefix.foreach(prefix.append)\n\
    \            else {\n                prefix.append(s.head)\n                findAllPrefixes(s.tail,\
    \ prefix)\n            }\n        }\n        findAllPrefixes(string, prefix)\n\
    \        prefix.toList", "        if (string == \"\") {\n            return Nil\n\
    \        }\n        val (prefix, rest) = string.span(_.isPrefixOf(_))\n      \
    \  val (restPrefix, restRest) = rest.span(_.isPrefixOf(_))\n        if (restPrefix.isEmpty)\
    \ {\n            prefix :: allPrefixes(restRest)\n        } else {\n         \
    \   prefix :: allPrefixes(restPrefix) :: allPrefixes(restRest)\n        }", " \
    \       var prefixes = List.empty[String]\n        for (i <- 0 until string.length)\
    \ {\n            prefixes ::= string(0, i)\n        }\n        prefixes", "  \
    \      def getPrefixes(currentLength : Int, strings : mutable.Stack[String], stringList\
    \ : List[String]) : List[String] = {\n            if (currentLength > stringList.size)\
    \ stringList :+ strings(0)\n            else if (currentLength == stringList.size)\
    \ stringList :+ strings(0)\n            else {\n                strings(currentLength)\
    \ match {\n                    case \"\" => getPrefixes(currentLength + 1, strings,\
    \ stringList :+ strings(0))\n                    case _ => getPrefixes(currentLength\
    \ + 1, strings, stringList :+ strings(0)) :+ strings(currentLength + 1)\n    \
    \            }\n            }\n        }\n        getPrefixes(0, mutable.Stack(string),\
    \ List())", "        string.foldLeft((List[String](), string)) {\n           \
    \ case ((prefix, str), ch) =>\n                (prefix.takeRight(1) :+ str, prefix\
    \ :+ ch)\n        }._1.reverse", "        string.split(' ').tails.map(_.toString).reverse.map(_.substring(0,\
    \ _.length)).takeWhile(_.length > 0).reverse", "      var prefixes = scala.collection.mutable.ListBuffer.empty[String]\n\
    \      var lastPrefixLength = scala.math.minInt\n      var len = string.length\n\
    \      var i = 1\n      while (i < len) {\n        var curPrefix = string.take(i)\n\
    \        var curPrefixLength = curPrefix.length\n        if (curPrefixLength >\
    \ lastPrefixLength) {\n          prefixes = prefixes :+ curPrefix\n          lastPrefixLength\
    \ = curPrefixLength\n        }\n        i += 1\n      }\n      prefixes.toList",
  "        // Initialize prefixes list as empty list\n        var prefixes: List[String]\
    \ = Nil\n        // Loop over each letter in string\n        for (letter <- string)\
    \ {\n            // If prefix is not empty and current letter is first letter\
    \ of new prefix, add prefix to prefixes\n            if (prefixes.nonEmpty &&\
    \ letter == prefixes.head) {\n                prefixes = prefixes ::: List(letter)\n\
    \            } else {\n                // If prefix is not empty and current letter\
    \ is not first letter of new prefix, append this letter to prefix and continue\n\
    \                if (prefixes.nonEmpty && letter != prefixes.head) {\n       \
    \             prefixes = prefixes ::: List(letter)\n                } else {\n\
    \                    // If prefix is not empty and current letter is first letter\
    \ of new prefix, append this letter to prefix and continue\n                 \
    \   if (prefixes.nonEmpty && letter == prefixes.head) {\n                    \
    \    prefixes = prefixes ::: List(letter)\n                    }\n           \
    \     }\n            }\n        }\n        return prefixes", "        val l =\
    \ string.tail.length\n        string match {\n            case \"\"  => List(string)\n\
    \            case x => allPrefixes(string.take(l) + x)\n        }", "        string\
    \ match{\n            case \"\" => Nil\n            case _ => string.tails.tails.map(_.head).filter(string.head==_).toList\n\
    \        }", "        val s = collection.mutable.Stack[String]()\n        for\
    \ (x <- string) {\n            if (s.length == 0) s.push(x.toString)\n       \
    \     else for (y <- s) if (y.length >= x.length) s.push(x + y)\n            else\
    \ s.push(x.toString)\n        }\n        if (s.length == 0) List()\n        else\
    \ s.toList.reverse", "        var allPrefixes = List[String]()\n        var current\
    \ = \"\"\n        var currentLength = 0\n        string.foreach {\n          \
    \  if (_ == current) {\n                currentLength += 1\n            } else\
    \ {\n                currentLength = 1\n            }\n            current +=\
    \ _\n            if (currentLength > allPrefixes.last) {\n                allPrefixes\
    \ :+= current\n            }\n        }\n        allPrefixes", "        val prefix\
    \ = new mutable.ListBuffer[String]\n        var current = string\n        var\
    \ temp = \"\"\n        var i = 0\n        while(i < current.length) {\n      \
    \      temp += current(i)\n            if(temp.startsWith(prefix(0))){\n     \
    \           prefix.remove(prefix(0))\n                prefix.prepend(temp)\n \
    \               temp = \"\"\n            } else {\n                i += 1\n  \
    \          }\n        }\n        prefix.toList", "        val prefix = new Array[Char](string.length)\n\
    \        var i : Int = 0\n        while (i < string.length) {\n            prefix(i)\
    \ = string(i)\n            i += 1\n        }\n        prefix", "        def prefixes(string\
    \ : String, res : List[String], prefix : String) : List[String] = {\n        \
    \    if(string.length == 0) res.append(prefix)\n            else prefixes(string.substring(1),\
    \ res :+ prefix, prefix + string.charAt(0))\n        }\n        prefixes(string,\
    \ nil, \"\")", "        def loop(current : String, list : List[String], prefixes\
    \ : List[String]) = {\n            if (current.length == string.length) list :+\
    \ prefixes\n            else {\n                loop(string takeRight 1, (current\
    \ + prefixes.head) :: list, prefixes)\n            }\n        }\n        loop(\"\
    \", List[String](), List())", "        if(string.length <= 2) return List(string)\n\
    \        var res = new ListBuffer[String]\n        var curString = string\n  \
    \      while(curString.length != 1) {\n            res += curString\n        \
    \    curString = curString.dropRight(1)\n        }\n        res ++= curString.dropRight(1)\n\
    \        res ++= List(\"\")\n        return res", '        string.sliding(2).map(_.mkString).toList',
  "        string match {\n            case x +: xs => allPrefixes(x) ++ allPrefixes(xs)\n\
    \            case x => List(x)\n        }", "        val prefixList = List[String]()\n\
    \        string.foldLeft(prefixList){\n            list => list ::: (list.head\
    \ :: list.tail)\n        }", "        // O(n) time, O(n) memory\n        val prefix\
    \ = new Array[String](string.length)\n        var i = 0\n        for (l <- string)\
    \ {\n            while (i < prefix.length && prefix(i) != l)\n               \
    \ i += 1\n            prefix(i) = l\n        }\n        prefix.toList", "    \
    \    val prefixesList = List[String]()\n        for {\n            i <- 0\n  \
    \      } while (i < string.length)\n        for (\n            s <- string.toCharArray\n\
    \            if (s.equals(string.subSequence(i, i + 1).head))\n              \
    \  prefixesList :+ string.subSequence(i, i + 1).head\n        )\n        prefixesList",
  "        var prefixes: List[String] = Nil\n        string.foreach { x =>\n     \
    \       val newPrefixes = for (prefix <- prefixes) yield x :: prefix\n       \
    \     prefixes = newPrefixes\n        }\n        prefixes.reverse", "        val\
    \ prefixes = List.empty[String]\n        var curPrefix = \"\"\n        for (c\
    \ <- string) if (c.isLetter) {\n            if (curPrefix == \"\") curPrefix =\
    \ c\n            else curPrefix = curPrefix + c\n        } else {\n          \
    \  prefixes = prefixes ::: List(curPrefix)\n            curPrefix = \"\"\n   \
    \     }\n        prefixes", '        string :: string.toLowerCase :: string.toUpperCase
    :: Nil.', "        val short = string.length\n        val longer = string.reverse.length\n\
    \n        val combinations = mutable.ListBuffer.empty[(Int, Int)]\n        (short,\
    \ longer) foreach {\n            x =>\n                for( y <- 1 to longer if\
    \ x > y ) combinations.++= ( x -> y )\n        }\n        combinations.toList.reverse",
  "        if (string.size() <= 1) List(\"a\" + string)\n        else string :: allPrefixes(string.substring(1,\
    \ string.length))", "        def allPrefixesImpl(string : String, n = 0) : List[String]\
    \ = {\n            string match {\n                case \"abc\" => List(string.substring(0,\
    \ n).asInstanceOf[String])\n                case _ =>\n                    for\
    \ (x <- allPrefixesImpl(string.substring(0, n), n + 2)) yield x +: x\n       \
    \     }\n        }\n        allPrefixesImpl(string, 0)", "        var prefixes\
    \ = List[String]()\n        var prefix = \"\"\n        for (i <- 0 until string.length)\
    \ {\n            prefix += string(i)\n            prefixes = prefixes :+ prefix\n\
    \        }\n        prefixes", "        val l = string.length\n        val prefixes\
    \ = mutable.ListBuffer.empty[String]\n\n        // Go through each index and build\
    \ prefix\n        for (i <- 0 until l) {\n            // Build prefix by concatenating\
    \ all previous values\n            val prefix = prefixes take i\n            val\
    \ appendString = string.substring (i, l)\n            prefixes += prefix ++ appendString\n\
    \        }\n        prefixes", "        // Create a list of all characters in\
    \ the string\n        val allChars = string.map(c => c)\n        // Create a list\
    \ of all possible prefixes of length 1\n        val prefixes = allChars.takeWhile(c\
    \ => c != allChars.last).map(c => c + \"a\")\n        // Return list with longest\
    \ prefixes at the end\n        prefixes.reverse", "        val prefixes = List[String]()\n\
    \        allPrefixesRec(prefixes, \"\", string)", "        val prefix = new Array[String](string.length)\n\
    \        for( i <- 0 until prefix.length ) {\n            prefix(i) = string.charAt(i)\n\
    \        }\n        prefix.reverse ::: prefix.takeWhile( i => i < string.length\
    \ ).reverse", "        val n = string.length\n        def allPrefixesRecursion(n:\
    \ Int, acc: List[String]) : List[String] = {\n            if (n == 0)\n      \
    \          acc\n            else {\n                val head = string.substring(0,\
    \ n)\n                val tail = allPrefixesRecursion(n-1, head :: acc)\n    \
    \            tail\n            }\n        }\n        allPrefixesRecursion(n-1,\
    \ Nil)", "        val lengths = new mutable.HashSet[Int]()\n        var prefixes:\
    \ List[String] = Nil\n        for (c <- string) {\n            if (lengths.contains(c.length))\
    \ {\n                prefixes = prefixes :+ string\n            }\n          \
    \  lengths += c.length\n        }\n        return prefixes", "        val prefixes\
    \ = mutable.ListBuffer[String]()\n        string.split(\"(?<=^)\").foreach { prefix\
    \ =>\n            val temp = mutable.ListBuffer[String]()\n            for (x\
    \ <- prefix) {\n                temp += x\n                prefixes += temp.mkString\n\
    \            }\n        }\n        prefixes.toList", "        val array = string.split(\"\
    \")\n        var res = List.empty[String]\n        for ((x, i) in array.zipWithIndex)\
    \ {\n            if (i + 1 < array.length) res += x + array(i + 1)\n        }\n\
    \        res", "        var result: List[String] = Nil\n        for {\n      \
    \      c <- string\n            prefix <- allPrefixes(c.tail)\n        } yield\
    \ prefix :: result", "        val prefixes: List[String] = Nil\n        var i\
    \ = string.head.length\n\n        val substrings = string.split\n\n        while\
    \ (i < substrings.length) {\n            prefixes = prefixes :+ substrings(i)\n\
    \            i += 1\n        }\n        prefixes", "        val prefixes = mutable.Buffer.empty[String]\n\
    \        var startIndex = 0\n        var currentIndex = 0\n\n        while (startIndex\
    \ < string.length) {\n            val currentChar = string.charAt(startIndex)\n\
    \            if (currentIndex < startIndex) {\n                prefixes += string.substring(startIndex,\
    \ currentIndex)\n            }\n            if (currentChar == 'a') {\n      \
    \          currentIndex = startIndex + 1\n                prefixes += \"a\"\n\
    \            } else if (currentChar == 'b') {\n                currentIndex =\
    \ startIndex + 2\n                prefixes += \"ab\"\n            } else {\n \
    \               currentIndex = startIndex + 3\n                prefixes += string.substring(startIndex,\
    \ currentIndex)\n            }\n            startIndex += 1\n        }\n\n   \
    \     prefixes", "        val lst : List[String] = Nil\n        var str : String\
    \ = string\n        while (str.length > 1) {\n            str = str.replaceFirst(\"\
    \\\\w+\", \" \").trim()\n            lst ::= str\n        }\n        lst ::= str",
  "        // Return empty list if string is null\n        if(string == null) Nil\n\
    \        else { \n            // Create empty set that we'll fill in with prefixes\
    \ from string until we exhaust it\n            var prefixSet = new mutable.HashSet[String]();\n\
    \            // Create stack to hold current prefix\n            var stack = new\
    \ mutable.Stack[String]();\n            // Push string onto stack\n          \
    \  stack += string\n            while(stack.nonEmpty) {\n                // Pop\
    \ string off stack\n                val nextString = stack.pop()\n           \
    \     // Add string to set\n                prefixSet += nextString\n        \
    \        // Add all prefixes of string to stack\n                for(prefix <-\
    \ nextString.split(\"[\\\\W]\").flatMap(x => prefixSet))\n                   \
    \ stack += prefix\n            }\n            // Return prefix set\n         \
    \   prefixSet.toList\n        }", "        val prefixes = mutable.ArrayBuffer.empty[String]\n\
    \        string match {\n            case \"\" => prefixes\n            case xs\
    \ if xs.size < 4 => prefixes\n            case _ => {\n                for( x\
    \ <- string.length until 4 ) {\n                    prefixes += string(0)\n  \
    \                  string.replace(0, x, \"\")\n                }\n           \
    \     prefixes\n            }\n        }", "        def recurse(s: String, acc:\
    \ List[String]) : List[String] = \n        if (s.isEmpty) acc\n        else recurse(s.tail,\
    \ acc + s.head)\n        recurse(string, Nil)", "        require(string.length\
    \ > 1, \"Input string cannot be empty\")\n        // Return empty list when empty\
    \ string\n        if (string.length == 0) return Nil\n        val prefix = new\
    \ mutable.ListBuffer[String]\n        var index = 0\n        // Iterate over all\
    \ possible combination of prefix of string except last\n        while (index <\
    \ string.length) {\n            val prefix1 = prefix.tail\n            val prefix2\
    \ = prefix.init :+ string\n            prefix += prefix1 :+ prefix2\n        \
    \    index++\n        }\n        prefix.toList", "        string match {\n   \
    \         case Nil => Nil\n            case x :: xs => allPrefixes(xs) ::: List(x)\n\
    \        }", "        string.split(\"\").reverse.foldLeft(List[String]()){ case\
    \ (acc, s) =>\n            if(s.head==string(0)) acc else acc + allPrefixes(s.tail)\n\
    \        }.reverse", "        val str = new String(string.getBytes)\n        val\
    \ len = string.length\n        var pre = new mutable.ListBuffer[String]()\n  \
    \      var i = len\n        var cur = 0\n        while(i>0) {\n            pre.append(str.get(cur))\n\
    \            i -= 1\n            cur += 1\n        }\n        pre", "      def\
    \ prefixes(s: String, remainingPrefix: List[String], prefixLength : Int) : List[String]\
    \ = \n        if (s.isEmpty) {\n            remainingPrefix\n        } else {\n\
    \          prefixes(s.tail, remainingPrefix :+ s.head, prefixLength + 1) match\
    \ {\n            case Nil => remainingPrefix\n            case prefixes => prefixes\
    \ ++ prefixes(s.head, remainingPrefix, prefixLength)\n          }\n        }\n\
    \      prefixes(string, Nil, 0)", "        string.zipWithIndex.foldLeft[List[String]](Nil)(\n\
    \            (xs, z) => (if (z._2 >= xs.size + 1) xs.toList else z._2.toList ::\
    \ xs)\n        )", "        val prefixes = mutable.ListBuffer.empty[String]\n\
    \        val current = mutable.Stack[String]()\n        current.push(string)\n\
    \        while (!current.isEmpty) {\n            val top = current.get\n     \
    \       current -= top\n            prefixes += top\n        }\n        prefixes.reverse",
  "        if (string.length == 1) List(string)\n        else string.combinations(string.length).filter(\
    \ _.forall(string.startsWith)).toList", "        val prefixes = mutable.ArrayBuffer.empty[String]\n\
    \        def addPrefix(current : String) = {\n            if(current.length >=\
    \ string.length) prefixes += current\n            else {\n                var\
    \ current = string\n                while(current.length >= current.substring(0,\
    \ current.length-1)) {\n                    current += current.substring(0, current.length-1)\n\
    \                    addPrefix(current)\n                }\n            }\n  \
    \      }\n        addPrefix(string)\n        prefixes.toList", "        def recurse(prefix\
    \ : List[String]) : List[String] = {\n            prefix match {\n           \
    \     case Nil => Nil\n                case prefix :: tail => recurse(tail.map(x\
    \ => x + prefix)) ++ prefix\n            }\n        }\n        return recurse(Nil)",
  "        val prefix = new scala.collection.mutable.ListBuffer[String]()\n      \
    \  for (char <- string) {\n            if (string.length > 1)\n              \
    \  allPrefixes(string -> char).foreach(prefix += _)\n            else\n      \
    \          prefix += char\n        }\n        prefix.toList", "        val lengths\
    \ = string.split(\"(?<=\\\\G.{1})\").map(_.length).toList\n        val candidates\
    \ = length :: lengths.dropRight(1)\n        val allPrefixes = Seq.empty[String]\n\
    \        for (prefix <- candidates)\n            allPrefixes ::= prefix.toString\n\
    \        allPrefixes", "        var res = ListBuffer[String]()\n        var lastPrefix:\
    \ String = \"\"\n        for (c <- string) {\n            if (lastPrefix.length\
    \ < c.length) {\n                lastPrefix = c\n            }\n            res.append(lastPrefix)\n\
    \        }\n        res.toList", "      def prefixesIter(list: List[String], prefix:\
    \ List[String]): List[String] = {\n        if (list.isEmpty) return prefix\n \
    \       val newPrefix = prefix :+ list.head\n        prefixesIter(list.tail, newPrefix)\n\
    \      }\n      prefixesIter(string.split(''), Nil)", "        var prefixes =\
    \ List[String]()\n        var currentPrefix: Option[String] = None\n        for(i\
    \ <- 0 to string.length - 1) {\n            if(currentPrefix == None || string(i)\
    \ != currentPrefix.get) {\n                currentPrefix = Some(string(i))\n \
    \               prefixes ::= currentPrefix\n            }\n        }\n       \
    \ prefixes", "        if (string.size == 0) List(string)\n        else {\n   \
    \         val (prefixes, remainder) = string.span(_.length > 1)\n            allPrefixes(remainder)\
    \ ++ prefixes\n        }", "        string.sliding(2).map(_.toList) match {\n\
    \            case Array(prefix, _*) => prefix\n            case _ => throw new\
    \ RuntimeException\n        }", "        val res = mutable.ListBuffer.empty[String]\n\
    \        for (i <- 0 until string.length){\n            for (j <- i until string.length){\n\
    \                val str = string.substring(i, j).trim\n                if (str.isEmpty)\n\
    \                    continue\n                else {\n                    res\
    \ ++= str.split(\"\\\\s\").toList\n                }\n            }\n        }\n\
    \        res.toList", "        val prefixes = mutable.ListBuffer[String]()\n \
    \       var i = 0\n        while (i < string.length) {\n            if (string(i)\
    \ == string(i+1))\n                prefixes += string(i)\n            else {\n\
    \                var j = i + 1\n                while (j < string.length) {\n\
    \                    if (string(i) == string(j)) {\n                        prefixes\
    \ += string(i) \n                        break\n                    } else {\n\
    \                        j++\n                    }\n                }\n     \
    \       }\n            i += 1\n        }\n        prefixes.toList", "        var\
    \ prefixes = List[String]()\n        var currentPrefix = \"\"\n        for (i\
    \ <- 0 until string.length) {\n            currentPrefix += string.charAt(i)\n\
    \            if (!(currentPrefix has prefix string.substring(0, i))) {\n     \
    \           prefixes ::= currentPrefix\n                currentPrefix = \"\"\n\
    \            }\n        }\n        prefixes ::= currentPrefix\n        prefixes",
  "        val stringList = string.split(\"\\\\W+\")\n        var newStringList =\
    \ new ListBuffer[String]()\n        var currentWord = new String\n        var\
    \ currentPrefix  = new String\n        for (word <- stringList) {\n          \
    \  currentWord = word\n            currentPrefix = \"\"\n            for (prefix\
    \ <- currentWord.substring(0, currentWord.length - 1).split(\"\\\\W+\")) {\n \
    \               currentPrefix += \"\\\\W+\"\n            }\n            newStringList\
    \ += currentPrefix\n        }\n        return newStringList.toList", "       \
    \ val result: List[String] = new ListBuffer[String]()\n\n        def recursivePrefixes(prefix:\
    \ String, remaining: String) : List[String] = {\n            if (remaining.nonEmpty)\
    \ {\n                result += prefix :: recursivePrefixes(prefix, remaining.tail)\n\
    \            }\n            result\n        }\n\n        recursivePrefixes(\"\"\
    , string)\n        result.toList", "        def longestPrefix(prefix: String):\
    \ String = {\n            if (string.length >= prefix.length) {\n            \
    \    string\n            } else {\n                longestPrefix(prefix.substring(1))\n\
    \            }\n        }\n        var longestPrefixes: List[String] = Nil\n \
    \       for (prefix <- longestPrefix(string.substring(0, string.length-1))) {\n\
    \            longestPrefixes ::= prefix\n        }\n        longestPrefixes",
  "        val prefixes = mutable.Buffer.empty[String]\n        for(i <- 0 until string.length){\n\
    \            prefixes += string.substring(0, i)\n        }\n        prefixes.toList",
  "        if (string.isEmpty) return Nil\n        val current = string\n        val\
    \ nextPrefixes = allPrefixes(string.tail)\n        val prefixes = nextPrefixes\
    \ ++ List(current)\n        prefixes", "        if(string.length == 0) List(string)\n\
    \        else allPrefixes(string.substring(0, string.length - 1)) ++ List(string)",
  "      def prefixes(string : String, current : String, list : List[String], prev\
    \ : List[String]): List[String] = {\n        if (string.length == 0) list :: prev\n\
    \        else {\n          prefixes(string , current + string , list ++ List(current)\
    \ , list ++ prev)\n        }\n      }\n      prefixes(string , \"\", Nil , Nil)",
  "        val prefixes: List[String] = Nil\n        string match {\n            case\
    \ Nil => prefixes\n            case _ => {\n                val (smallest, longest)\
    \ = string.span(_.length < string.length)\n                prefixes = allPrefixes(smallest)\
    \ ++ allPrefixes(longest)\n            }\n        }\n        prefixes", '        string
    :: allPrefixes(string.tail)', "        if (string.length == 0) {\n           \
    \ Nil\n        } else {\n            val prefixes = allPrefixes(string.substring(1))\n\
    \            val head = string.substring(0, string.length-1)\n            if (prefixes.contains(head))\
    \ {\n                prefixes :+ head\n            } else {\n                prefixes\n\
    \            }\n        }", "        string.splitIterator.mkString(\"\") //convert\
    \ to iterator of chars then back to string\n            .sliding(2) //create sliding\
    \ windows of length 2\n            .flatMap(p => p take 1) //take the first character\
    \ from each sliding window\n            .distinct  //remove duplicates\n     \
    \       .filter(!_.isEmpty) //filter empty strings", "        var result = Nil\n\
    \        var currentPrefixLength = 0\n        for(x <- string.toList)\n      \
    \  {\n            currentPrefixLength = x.length\n            result = x :: result\n\
    \        }\n        result", "        def allPrefixes(string : String, prefix\
    \ : List[String], current : Int) : List[String] = {\n            if (string.length\
    \ <= current) {\n                prefix :+ string.substring(0, current)\n    \
    \        } else {\n                prefix :+ string.substring(0, current)\n  \
    \              allPrefixes(string.substring(current), prefix, current + 1)\n \
    \           }\n        }\n        allPrefixes(string, Nil, 0)", "      def findPrefixes(s:\
    \ String, prefixes: List[String], prefixLength: Int): (List[String], Int) = {\n\
    \        if (s.length < prefixLength) {\n          return (prefixes, prefixLength)\n\
    \        }\n        val prefix = s.take(prefixLength).toList\n        val (prefixes,\
    \ prefixLength) = findPrefixes(s.drop(prefixLength), prefixes ::: prefix, prefixLength\
    \ + 1)\n        (prefixes ::: prefix, prefixLength)\n      }\n      findPrefixes(string,\
    \ Nil, 0)", "        val prefixes = mutable.ListBuffer[String]()\n        for(i\
    \ <- string.length to 0) {\n            prefixes += string.substring(0, i)\n \
    \       }\n        prefixes", "        val prefixes = mutable.Queue[String]()\n\
    \        for(i <- 0 until string.length)\n            prefixes += string.substring(0,\
    \ i)\n        prefixes.toList", "      var prefixes: List[String] = Nil\n    \
    \  for(i <- 0 until string.length) {\n        prefixes = allPrefixesRec(string.substring(0,\
    \ i), prefixes)\n      }\n      prefixes", "        var prefixes = ListBuffer[String]()\n\
    \        var cur = string\n        while (cur.length > 0) {\n            prefixes\
    \ = prefixes :+ cur\n            cur = cur.substring(1)\n        }\n        prefixes.toList",
  "        string.iterator.toList.foldLeft[List[String]](List[String]()){\n      \
    \      case (acc, c) => acc.map(s => (0, s, c)) :: acc.map(s => (1, s, c))\n \
    \       }.tail.map(p => (p._3 + p._1, p._2, p._3)).sortBy(_._1).map(_._2)", " \
    \       val prefixes = mutable.ListBuffer.empty[String]\n        for (length <-\
    \ 1 to string.length)\n            for (prefix <- string.take(length))\n     \
    \           prefixes += prefix\n        prefixes", "        def allPrefixes(string\
    \ : String, prefix : List[String] = Nil) : List[String] = prefix match {\n   \
    \         case Nil => prefix :: Nil\n            case x :: xs => allPrefixes(xs,\
    \ prefix :+ x)\n        }\n        allPrefixes(string)", "        val prefixes\
    \ = mutable.MutableList[String]()\n        if (string.nonEmpty) {\n          \
    \  val prefix = string.head\n            val tail = string.tail\n            prefixes\
    \ :+= prefix\n            for (s <- allPrefixes(tail)) {\n                prefixes\
    \ :+= s\n            }\n        }\n        prefixes", "        var output = List[String]()\n\
    \        var i = 0\n        var currentLength = 0\n\n        while (i < string.length)\
    \ {\n            if (string(i) == string(0)) {\n                currentLength\
    \ = 1\n            } else {\n                currentLength += 1\n            }\n\
    \            i += 1\n        }\n\n        i <- 0 until currentLength\n       \
    \ if (string(i) == string(0)) {\n            output = output :+ string(i)\n  \
    \      }\n        while (i < string.length) {\n            if (string(i) == string(i+1))\
    \ {\n                i += 1\n            } else {\n                output = output\
    \ :+ string(i)\n                i += 1\n            }\n        }\n        output",
  "        if (string.length == 0) List(\"\")\n        else {\n            // create\
    \ mutable list of prefixes\n            val prefixes = new mutable.MutableList[String]\n\
    \            prefixes.head :: allPrefixes(string.substring(1))\n        }", " \
    \       val result = new mutable.ListBuffer[String]()\n        for (i <- 0 until\
    \ string.length) {\n            val prefix = string.take(i)\n            if (string.length\
    \ > i) {\n                result.+=(prefix)\n                allPrefixes(string.drop(i))\n\
    \            }\n        }\n        result.toList", "      def allPrefixesAux(i:\
    \ Int, strings: List[String], prefixes: List[String]) : List[String] = {\n   \
    \     if (strings.length < i)\n          allPrefixesAux(i + 1, strings, prefixes\
    \ :+ string.substring(0, i))\n        else\n          allPrefixesAux(i + 1, strings\
    \ :+ string.substring(0, i), prefixes)\n      }\n      allPrefixesAux(0 ,List(),\
    \ List())", "        var prefixes: List[String] = Nil\n        var index = string.length\n\
    \        while (index > 0) {\n            prefixes ::= string.substring(0, index)\n\
    \            index = index - 1\n        }\n        prefixes", "        string.takeWhile(_\
    \ != 'a').toList +: allPrefixes(string.dropWhile(_ != 'a'))", "        def allPrefixesHelper(list:\
    \ List[String], acc: List[String]) : List[String] = {\n            list.map {\n\
    \                x => allPrefixesHelper(list.remove(x), x :: acc)\n          \
    \  } ++ acc\n        }\n        allPrefixesHelper(string.split[String](\"\"),\
    \ List.empty[String])", "        // Base case\n        if(string.length < 2) return\
    \ Nil\n        // Recursive case\n        var prefixes = Nil\n        var i =\
    \ 0\n        while(i < string.length) {\n            // Add character at i to\
    \ list of prefixes from i to end of string\n            prefixes = prefixes :+\
    \ string.substring(i, string.length)\n            // Increment i until you pass\
    \ the end of the string\n            i = i + 1 // Start from new position\n  \
    \      }\n        // Return list of prefixes\n        return prefixes", "    \
    \    val longest = string.tail\n        val shortest = string.head\n        val\
    \ longestPrefix = longest.takeWhile(c => shortest == c).toList\n        val shortestPrefix\
    \ = shortest.takeWhile(c => longest == c).toList\n        val prefixes = longestPrefix.concat(shortestPrefix)\n\
    \        prefixes", "        val result = new mutable.ListBuffer[String]()\n \
    \       val prefixes = string.foldLeft(\"\")( (s, c) => s + c).split(\"\").reverse\n\
    \        for(prefix <- prefixes) yield prefix +: result", "        // Base case:\
    \ empty string\n        if (string.length == 0) return Nil\n        // Recursive\
    \ case: not empty\n        // Choose starting point based on length\n        var\
    \ current = string(0)\n        val result : List[String] = Nil\n        for (c\
    \ <- string.tail) {\n            if (current.length < c.length) {\n          \
    \      result = result ::: List(current)\n                current = c\n      \
    \      } else {\n                current = c\n            }\n        }\n     \
    \   result = result ::: List(current)\n        return result", "        require(string\
    \ != null , \"Error: Null argument\")\n        val length = string.length\n  \
    \      val prefixes = mutable.ListBuffer[String]()\n        var current = \"\"\
    \n        for (i<-0 until length) {\n            if (string.charAt(i) == '_')\n\
    \                current += string.charAt(i)\n            else {\n           \
    \     prefixes += current\n                current = string.charAt(i)\n      \
    \      }\n        }\n        prefixes += current\n        prefixes", "      var\
    \ prefixes = List[String]()\n      var cur = string\n\n      while(cur.length\
    \ > 0) {\n          val p = cur.takeWhile(_ != \" \")\n          prefixes = p\
    \ :: prefixes\n          cur = cur.drop(p.length)\n      }\n      prefixes", " \
    \       val prefix = new mutable.LinkedListBuffer[String]\n        var current\
    \ = 0\n        string.foreach(x => {\n            if (x == string.charAt(current))\
    \ current += 1\n            else prefix.append(string.charAt(current))\n     \
    \   })\n        if (current == 0) prefix.reverse\n        else allPrefixes(prefix.reverse)",
  "        var result = new collection.mutable.ListBuffer[String]()\n        // Traverse\
    \ string from beginning\n        var index = 0\n        var nextSubStringLength\
    \ = string.length\n        while (index < nextSubStringLength) {\n           \
    \ val currentSubString = string.substring(index, nextSubStringLength)\n      \
    \      // Find all prefixes of current substring\n            // >>> allPrefixes(\"\
    abc\")\n            // (List[String](\"a\", \"ab\", \"abc\"))\n            //\
    \ >>> allPrefixes(\"ab\")\n            // (List[String](\"a\", \"ab\"))\n    \
    \        // >>> allPrefixes(\"b\")\n            // (List[String](\"b\"))\n   \
    \         var prefixes = findPrefixes(currentSubString)\n            // If this\
    \ prefix is not part of result yet, add it\n            if (prefixes == null)\
    \ prefixes = findPrefixes(\"\")\n            result += prefixes\n            //\
    \ Move forward the index\n            index += 1\n            // Move forward\
    \ the length of the string\n            nextSubStringLength += nextSubStringLength\n\
    \        }\n        result.toList", "      var result: List[String] = Nil\n  \
    \    var n = string.length\n      while ( n != 0 ) {\n        result = (string\
    \ take (n)) :: result\n        n = math.min(n, string.length)\n      }\n     \
    \ result", "        val r = new mutable.ListBuffer[String]()\n        val len\
    \ = string.length\n        if (len == 0) r\n        else {\n            allPrefixes(string.substring(0,len-1),\
    \ r)\n            r += string.substring(0,len-1)\n        }", "        var prefixes\
    \ = List[String]()\n        for ((prefix, s) <- string.zipWithIndex) {\n     \
    \       if (s == 0) prefixes ::= prefix\n            else allPrefixes(prefix.substring(1)\
    \ + s)\n        }\n        return prefixes", "        var result : List[String]\
    \ = Nil\n        var minIndex = 0\n        var minLength = string.length\n   \
    \     var maxIndex = minLength\n        var maxLength = string.length\n      \
    \  var i = 0\n        var j = 0\n        var k = 0\n        var iEnd = 0\n   \
    \     var jEnd = 0\n        var kEnd = 0\n\n        while(i < minLength) {\n \
    \           if(string.charAt(i) == string.charAt(minIndex)) {\n              \
    \  minIndex = i + 1\n                minLength = minIndex + 1\n            } else\
    \ if(string.charAt(i) == string.charAt(maxIndex)) {\n                maxIndex\
    \ = i - 1\n                maxLength = maxIndex - 1\n            }\n         \
    \   i += 1\n        }\n\n        while(j < maxLength) {\n            if(string.charAt(j)\
    \ == string.charAt(minIndex)) {\n                minIndex = j + 1\n          \
    \      minLength = minIndex + 1\n            } else if(string.charAt(j) == string.charAt(maxIndex))\
    \ {\n                maxIndex = j - 1\n                maxLength = maxIndex -\
    \ 1\n            }\n            j += 1\n        }\n\n        while(k <= minIndex)\
    \ {\n            result::= string.substring(k, minIndex)\n            k += 1\n\
    \        }\n\n        while(iEnd < minLength) {\n            if(string.charAt(iEnd)\
    \ == string.charAt(minIndex)) {\n                minIndex = iEnd + 1\n       \
    \         minLength = minIndex + 1\n            } else if(string.charAt(iEnd)\
    \ == string.charAt(maxIndex)) {\n                maxIndex = iEnd - 1\n       \
    \         maxLength = maxIndex - 1\n            }\n            iEnd += 1\n   \
    \     }\n\n        while(jEnd < maxLength) {\n            if(string.charAt(jEnd)\
    \ == string.charAt(minIndex)) {\n                minIndex = jEnd + 1\n       \
    \         minLength = minIndex + 1\n            } else if(string.charAt(jEnd)\
    \ == string.charAt(maxIndex)) {\n                maxIndex = jEnd - 1\n       \
    \         maxLength = maxIndex - 1\n            }\n            jEnd += 1\n   \
    \     }\n\n        while(k <= minIndex) {\n            result::= string.substring(k,\
    \ minIndex)\n            k += 1\n        }\n\n        while(iEnd < minLength)\
    \ {\n            if(string.charAt(iEnd) == string.charAt(minIndex)) {\n      \
    \          minIndex = iEnd + 1\n                minLength = minIndex + 1\n   \
    \         } else if(string.charAt(iEnd) == string.charAt(maxIndex)) {\n      \
    \          maxIndex = iEnd - 1\n                maxLength = maxIndex - 1\n   \
    \         }\n            iEnd += 1\n        }\n\n        while(jEnd < maxLength)\
    \ {\n            if(string.charAt(jEnd) == string.charAt(minIndex)) {\n      \
    \          minIndex = jEnd + 1\n                minLength = minIndex + 1\n   \
    \         } else if(string.charAt(jEnd) == string.charAt(maxIndex)) {\n      \
    \          maxIndex = jEnd - 1\n                maxLength = maxIndex - 1\n   \
    \         }\n            jEnd += 1\n        }", "        var prefixes: List[String]\
    \ = Nil\n        var start = 0\n\n        while(start < string.length){\n    \
    \        val end = string.indexOf(\"_\", start)\n            prefix = string.substring(start,\
    \ end+1)\n            prefixes ::= prefix\n            start = end + 1\n     \
    \   }\n        return prefixes", '       string.substrings().map(_.toString).reverse.takeWhile(_.length
    >= string.length).reverse', "        val longestPrefixList = longestPrefix(string,\
    \ \"\", \"\")\n        val longestPrefixListReversed = longestPrefix(string, \"\
    \", \"\").reverse\n        longestPrefixList ++ longestPrefixListReversed", " \
    \     val (shortest, longest) = (string.length, string.length)\n      if (shortest\
    \ > longest) {\n        val r = new scala.collection.mutable.StringBuilder(string)\n\
    \        for(i <- 0 until shortest) r.append(string.charAt(i))\n        allPrefixes(r.toString)\n\
    \      } else {\n        for(i <- 0 until longest) if(string.charAt(i) == string.charAt(longest))\
    \ longest = i\n        for(i <- 0 until longest) if(string.charAt(i) != string.charAt(longest))\
    \ result +=  string.charAt(i)\n        result\n      }", "        val result =\
    \ new mutable.ArrayBuffer[String]()\n        var i = 0\n        val len = string.length\n\
    \        while (i < len) {\n            if (string.charAt(i) == 'a') {\n     \
    \           result.add(\"a\")\n            }\n            if (string.charAt(i)\
    \ == 'b') {\n                result.add(\"ab\")\n            }\n            if\
    \ (string.charAt(i) == 'c') {\n                result.add(\"abc\")\n         \
    \   }\n            i += 1\n        }\n        result.reverse", "        var prefix\
    \ = new mutable.ListBuffer[String]()\n        var start = 0\n        var end =\
    \ string.length - 1\n        while(start <= end) {\n            prefix += string.substring(start,\
    \ end + 1).trim\n            end -= 1\n            start += 1\n        }\n   \
    \     prefix.toList", "        var prefixes = mutable.ListBuffer.empty[String]\n\
    \        for (char <- string) {\n            prefixes += char\n        }\n   \
    \     prefixes", "        var list : List[String] = Nil\n        var current =\
    \ \"\"\n        var i = 0\n        var j = string.length()\n\n        while (i\
    \ <= j) {\n            current = string.substring(i, j)\n            list = list\
    \ ::: List(current)\n            i = j\n            j -= 1\n        }\n      \
    \  list", '        string.tails.flatMap { n => allPrefixes(n) ++ n }', "     \
    \   val prefixes = mutable.ArrayBuffer.empty[String]\n        // get longest prefix\
    \ of the string \n        // longest is prefix of string without its first character\n\
    \        val longestPrefix = string.indexOfPrefix(string.substring(1))\n     \
    \   // loop over all prefixes of the string \n        // longest prefix is the\
    \ prefix of string without first character\n        for (i <- 0 until longestPrefix)\
    \ {\n            // add string without its first character to the list prefixes\n\
    \            prefixes += string.substring(0,i)\n        }\n        // return list\
    \ of all prefixes\n        return prefixes.toList", "        val prefixes = (string\
    \ split \"\").toList\n        if (prefixes.size == 1) {\n            List(prefixes.head)\n\
    \        } else {\n            var result: List[String] = Nil\n            prefixes\
    \ foreach {prefix =>\n                for {prefix <- allPrefixes(string.substring(0,prefix.length))}\n\
    \                result += prefix\n            }\n            result\n       \
    \ }", "        val minSize = Math.min(string.length, 3).toInt\n        val suffixes\
    \ = mutable.ListBuffer.empty[String]\n        var current = string.tail.trim\n\
    \        while(current != \"\") {\n            suffixes += current\n         \
    \   current = current.tail.trim\n        }\n        suffixes.reverse.take(minSize).toList",
  "      var prefixes = Nil\n      string match {\n        case prefix +: s => prefixes\
    \ = prefixes :+ prefix\n        case x => prefixes = prefixes :+ x\n      }\n\
    \      prefixes.reverse", "        val prefix = new mutable.ListBuffer[String]()\n\
    \        var index = string.length - 1\n        while(index >= 0) {\n        \
    \    prefix.append(string.charAt(index))\n            index--\n        }\n   \
    \     prefix.toList", "        val prefixes = mutable.ListBuffer.empty[String]\n\
    \        var currLen = 0\n        for(letter <- string){\n            if(letter\
    \ == '\\0'){\n                prefixes += string.substring(1, currLen)\n     \
    \           currLen = 1\n            }\n            else currLen += 1\n      \
    \  }\n        prefixes += string.substring(1, currLen)\n        prefixes.toList",
  "        def addPrefix(prefix : List[String], string : List[String]) : List[String]\
    \ = {\n            if (string.length == prefix.length) prefix :+ string(0)\n \
    \           else {\n                val newPrefix = prefix :+ string(0)\n    \
    \            val newString = string.drop(1)\n                addPrefix(newPrefix,\
    \ newString)\n            }\n        }\n        val prefixes = mutable.Stack[List[String]]()\n\
    \        addPrefix(prefixes, List())(prefixes, string)\n        prefixes.toList.reverse.map(_.mkString).reverse",
  "        val charArray = string.chars\n        val prefixArray = charArray.sliding(2)\n\
    \        val result = new collection.mutable.ArrayList[String]()\n        for\
    \ (prefix <- prefixArray) {\n            val prefix = prefix.mkString\n      \
    \      result.add(prefix)\n        }\n        result.toList", "        val prefixes\
    \ = mutable.ListBuffer.empty[String]\n        var current = string\n        while\
    \ (current != \"\") {\n            current :: prefixes\n            current =\
    \ current.dropRight(1)\n        }\n        prefixes.toList", "        val stack\
    \ = new mutable.Stack[String]()\n        val result = new mutable.ListBuffer[String]()\n\
    \        for (i <- 0 until string.length) {\n            for (prefix <- 0 until\
    \ string.length) {\n                stack += (string(prefix) + (if (i < (prefix\
    \ - 1)) \",\" else \"\"))\n            }\n            if (stack.size == 0) {\n\
    \                result += stack\n                stack = new mutable.Stack[String]()\n\
    \            }\n        }\n        return result.toList", "        var prefixes\
    \ = List[String]()\n        string.split(\"\").foreach {\n            char =>\n\
    \                prefixes ::= string\n        }\n        prefixes", "        var\
    \ prefixes = new mutable.ListBuffer[String]\n        var currentPrefix : String\
    \ = \"\"\n        for(c <- string){\n            currentPrefix += c\n        \
    \    if(currentPrefix != \"\") {\n                prefixes += currentPrefix\n\
    \            }\n        }\n        prefixes.toList", "        def recurse(string\
    \ : String, prefix : Option[String] = Some(string)) : List[String] =\n       \
    \     if (string.length <= 0) prefix else recurse(string.reverse, prefix :+ string.reverse.reverse)\n\
    \        recurse(string)", "        val prefixes = mutable.MutableList[String]()\n\
    \        if (string.size == 0)\n            prefixes\n        else\n         \
    \   for (i <- 0 until string.length)\n                allPrefixes(string takeWhile\
    \ {\n                    charAt => string.charAt(i) != charAt\n              \
    \  })\n                prefixes += string\n                prefixes", "      \
    \  val prefixes = new ArrayBuffer[String]()\n        var longestIndex = 0\n  \
    \      for ((index, char) <- string.span(_ == 'a')) {\n            if (index >\
    \ longestIndex) {\n                prefixes ++= string.getChars(longestIndex,\
    \ index).mkString(\"\")\n                longestIndex = index\n            }\n\
    \        }\n        if (longestIndex < string.length) prefixes ++= string.getChars(longestIndex,\
    \ string.length).mkString(\"\")\n        prefixes ++= string.getChars(longestIndex,\
    \ string.length).mkString(\"\")\n        return prefixes", "        val prefix\
    \ = new scala.collection.mutable.ArrayList[String]()\n        var index = 0\n\
    \        while(index < string.length){\n            if(string.charAt(index) !=\
    \ string.charAt(index - 1)){\n                prefix.append(string.substring(index,index+1))\n\
    \                index += 1\n            }\n            else{\n              \
    \  index += 1\n            }\n        }\n        if(string.charAt(string.length-1)\
    \ == string.charAt(0)){\n            prefix.append(string.substring(0,string.length-1))\n\
    \        }\n        prefix", "        val len = string.length\n        val prefix\
    \ = new ListBuffer[String]()\n        var start = 0\n        var pos = -1\n  \
    \      while(pos < len) {\n            pos = string.indexOf('a',pos)\n       \
    \     while (pos < len && string((pos+1)) == 'a') { \n                prefix +=\
    \ string((pos+1))\n                pos = string.indexOf('a',pos+1)\n         \
    \   }\n            pos = string.lastIndexOf('a',pos)\n            while (pos >\
    \ start && string((pos-1)) == 'a') { \n                prefix += string((pos-1))\n\
    \                pos = string.lastIndexOf('a',pos-1)\n            }\n        \
    \    pos = string.lastIndexOf('a',len)\n            while (pos > start && string((pos-1))\
    \ == 'a') { \n                prefix += string((pos-1))\n                pos =\
    \ string.lastIndexOf('a',pos-1)\n            }\n            pos += 1\n       \
    \ }\n        prefix.toList", "        def allPrefixes(prefix: String, strings:\
    \ List[String]): List[String] = {\n            if (strings.length <= 1) \n   \
    \             return string::prefix\n            else\n                allPrefixes(prefix\
    \ :+ strings.last, strings.dropRight(1));\n        }\n        allPrefixes(\"\"\
    , List(string))", '        string.size.toList.flatMap(x => string.substring(x).split("").toList).toList.map(x
    => x + x)', "        var list : List[String] = Nil\n        var index = 0\n  \
    \      while ( index < string.length ) {\n            list = list :+ string.substring(0,index)\
    \ \n            index = index + 1\n        }\n        return list", "        if\
    \ (string.length == 1) {\n            List(string)\n        } else {\n       \
    \     val list = new mutable.ListBuffer[String]()\n            for (x <- allPrefixes(string.substring(0,\
    \ string.length - 1)))\n                list += x + \"|\" + string\n         \
    \   list += string\n            list.toList\n        }", "        val prefixes\
    \ = mutable.ListBuffer.empty[String]\n        allPrefixes(\"\", string, prefixes)",
  "        string.map { i =>\n            string = i\n            i +: allPrefixes(string).reverse\n\
    \        }.flatten", "        val strs = mutable.ListBuffer.empty[String]\n  \
    \      for(x <- string){\n            strs += x\n        }\n        var prefixes\
    \ = mutable.ListBuffer.empty[String]\n        var prefix = \"\"\n        for(x\
    \ <- strs){\n            if(x.length == 1){\n                prefix += x\n   \
    \         }else{\n                if(x.startsWith(prefix)){\n                \
    \    prefixes += prefix\n                }\n                prefix = x\n     \
    \       }\n        }\n        prefixes += prefix\n        return prefixes.toList",
  "        var prefixes = ListBuffer[String]()\n        var lastChar = string(0)\n\
    \        for ( char <- string) {\n            if (char == lastChar) {\n      \
    \          prefixes += char\n            } else {\n                prefixes +=\
    \ lastChar\n                prefixes += char\n                lastChar = char\n\
    \            }\n        }\n        prefixes.toList", "        var prefixes = List[String]()\n\
    \        var current = string\n        while(current != \"\") {\n            prefixes\
    \ = prefixes ::: ListBuffer.apply(current)\n            current = current.substring(1)\n\
    \        }\n        prefixes.reverse", "        string.foldLeft(List.empty[String]){\n\
    \            case (prefix, str) =>\n                val prefix = prefix ++ List(str)\n\
    \                if (prefix.length == str.length) prefix\n                else\
    \ allPrefixes(str)\n        }", "        val (prefixes, suffix) = string.span(_.nonEmpty)\n\
    \        val reversedSuffix = (suffix.reverse)\n        val reversedPrefixes =\
    \ prefixes.reverse\n        (reversedPrefixes :: reversedSuffix).filterNot(_ ==\
    \ \"\")", "        require(string != null)\n        require(string != \"\", \"\
    Prefix is undefined\")\n        val chars = string.toCharArray\n        var i\
    \ = 0\n        var result: List[String] = Nil\n        val stringLen = string.length\n\
    \        while (i < stringLen) {\n            val prefix = string(i).asInstanceOf[Char]\n\
    \            val prefixString = string.substring(0, i).toString.asInstanceOf[String]\n\
    \            require(prefix != prefix, \"String cannot have a prefix of itself\"\
    )\n            require(prefix != chars(0), \"String cannot have an empty prefix\"\
    )\n            if (i < stringLen - 1) {\n                val nextChar = chars(i\
    \ + 1).asInstanceOf[Char]\n                if (prefix != nextChar) {\n       \
    \             result += prefix :: prefixString\n                }\n          \
    \  }\n            i += 1\n        }\n        result", '        string.sliding(1,1).flatMap(_+_).toList',
  "        string.zipWithIndex.flatMap {\n            case (prefix, index) => allPrefixes(prefix.takeRight(index+1))\n\
    \            case _ => Nil\n        }", "        if (string.isEmpty) return Nil\n\
    \        val list = MutableList[String]()\n        var currentPrefix = \"a\"\n\
    \        var currentString = \"\"\n        for ((char, currentIndex) <- string.indices)\
    \ {\n            if (char == currentPrefix) {\n                currentString +=(char)\n\
    \            } else {\n                if (currentString.isEmpty) currentString\
    \ += char\n                else {\n                    list += (currentPrefix:currentString)\n\
    \                    currentPrefix = char\n                    currentString =\
    \ char\n                }\n            }\n        }\n        list += (currentPrefix:currentString)\n\
    \        return list.toList", "        var currentPrefix = \"\"\n        var allPrefixes\
    \ = new Array[String](string.size)\n        for( i <- 0 until string.size) {\n\
    \            allPrefixes(i) = currentPrefix\n            currentPrefix = currentPrefix.concat(string.charAt(i))\n\
    \        }\n        return allPrefixes", "        val prefixes = mutable.ListBuffer.empty[String]\n\
    \        var i = 0\n        for (symbol <- string) {\n            i +=1\n    \
    \        prefixes += string.slice(0, i)\n        }\n        prefixes += string.slice(0,\
    \ i)\n        prefixes.toList", '        string.split("").reverse.map(x => string.substring(0,
    x)).toList', '        string.sliding(2).map(_.mkString).distinct.sorted', "  \
    \      var ret: List[String] = Nil\n        var length : Int = string.length\n\
    \        while length >= 1 {\n            length += 1\n            ret = ret :+\
    \ string.substring(0, length)\n        }\n        ret", "        if(string.length\
    \ == 0) return Nil\n        var prefixes = ListBuffer[String]()\n        var minLength\
    \ = string.length\n        val chars = string.chars\n        while(chars.nonEmpty)\
    \ {\n            var currentPrefix = \"\"\n            var currentChar = chars.head\n\
    \            var endOfWord = false\n            var wordLength = 0\n         \
    \   while(!endOfWord) {\n                if(currentChar == ' ') {\n          \
    \          if(wordLength > 0)\n                        prefixes = prefixes :+\
    \ currentPrefix\n                    wordLength = 0\n                } else {\n\
    \                    currentPrefix = currentPrefix.dropRight(1) ++ currentChar\n\
    \                    wordLength += 1\n                }\n                currentChar\
    \ = chars.next()\n                endOfWord = currentChar == ' ' || currentChar\
    \ == '.'\n            }\n            if(wordLength > 0) {\n                if(wordLength\
    \ < minLength) {\n                    minLength = wordLength\n               \
    \ }\n                prefixes = prefixes :+ currentPrefix\n            }\n   \
    \     }\n        prefixes.toList", "        var result : List[String] = Nil\n\
    \        for (i <- 0 until string.length) {\n            for (prefix <- 0 until\
    \ i) {\n                result :+= string.substring(0, prefix)\n            }\n\
    \        }\n        result", "        var current = string\n        var result:\
    \ List[String] = Nil\n\n        while (current.length >= 1) {\n            current\
    \ =\n                if (current.charAt(0) == string.charAt(0)) current.substring(1)\n\
    \                else current + string.charAt(0)\n            result += List(current)\n\
    \        }\n\n        return result", "        string.takeWhile{_ => true}\n \
    \           .foldRight(List[String]()){ (prefix, c) =>\n            if (prefix.isEmpty)\
    \ List(c) :: prefix else List(c, prefix) }", "        string.sliding(2).sliding(2).filter(\
    \ x => x._2 > x._1).map {\n            x => x._1 -> x._2\n        }.toList", " \
    \       var prefixes = List[String]()\n        var start = string(0)\n       \
    \ var end = string.length\n\n        while (start != end) {\n            prefixes\
    \ = prefixes :+ string.substring(start, end)\n            start = end + 1\n  \
    \          end = string.indexOf((start, end), start) + start\n        }\n    \
    \    prefixes", '        string.foldLeft[List[String]](List.empty[String]) { case
    (acc, x) => acc + x.takeWhile(_.isUpper).toList }.reverse', "        // TODO:\
    \ replace with dynamic programming\n        val prefixes = mutable.ListBuffer[String]()\n\
    \        prefixes ++= string.dropRight(1).map(_.toString)\n        for(i <- 1\
    \ to string.length)\n            prefixes ++= string.take(i).drop(1).map(_.toString)\n\
    \        prefixes.toList", '        string.dropWhile(_.length < string.length)
    ++ (0 to string.length - 1).map{_ => string}.reverse.foldLeft(List[String]()){
    (list, i) => list :+ list.last(i) }.reverse', "      val prefix = mutable.ListBuffer[String]()\n\
    \      allPrefixes(string, prefix)", "        val prefixes = mutable.ArrayBuffer.empty[String]\n\
    \        for { x <- string.toCharArray\n            if x.isPrefixOf } { prefixes\
    \ += x }\n        return prefixes.toList", "        var prefixes: List[String]\
    \ = Nil\n        var current = \"\"\n        for (character <- string) {\n   \
    \         current += character\n            prefixes = current::prefixes\n   \
    \     }\n        prefixes", "        def allPrefixes(string : String, nPrefixes\
    \ : MutableList[String]) =\n            if (string.length == nPrefixes.length)\n\
    \                nPrefixes :+ string\n            else\n                allPrefixes(string.substring(0,\
    \ string.length), nPrefixes :+ string)\n\n        allPrefixes(string, new MutableList[String]())",
  '        string.head :: allPrefixes(string.tail)', "        if (string.isEmpty)\
    \ return Nil\n        val arr = new Array[Char](string.length)\n        for (i\
    \ <- 0 until string.length) {\n            arr(i) = string.charAt(i)\n       \
    \ }\n        val prefixes = allPrefixesHelper(arr, string.lenght)\n        prefixes.map(_.toString).sorted",
  '        string.takeWhile(_ => string.indexOf(_) != string.length).tail', "    \
    \    var prefixes = ListBuffer.empty[String]\n        allPrefixesHelper(string,\
    \ prefixes)\n        prefixes.toList", "      if(string.length == 0)\n       \
    \ return Nil\n\n      def prefixes(string : String) : List[String] = {\n     \
    \   if(string.length == 0)\n          return Nil\n\n        val prefix = string.toList(0)\n\
    \        var result: List[String] = Nil\n        for(i <- 0 until string.length\
    \ - 1){\n          result :=  prefixes (string.substring(0,i)) :: prefix\n   \
    \     }\n        result\n      }\n      prefixes(string)", "        val prefixList\
    \ = mutable.ListBuffer[String]()\n        def dfs(string : String) : Unit = string\
    \ match {\n            case \"\" => prefixList ++= List(string)\n            case\
    \ x => dfs(x +: string.tail)\n        }\n        dfs(string.tail)\n        prefixList.toList",
  "        def go (string : String, prefix : List[String]) : List[String] = {\n  \
    \          if(string.length < prefix.length) go(string.substring(1), prefix:+\
    \ prefix)\n            else if(string.length == prefix.length) prefix :+ string\n\
    \            else go(string.substring(1), prefix:+ prefix)\n        }\n      \
    \  go(string, new ListBuffer[String]())", "        var output : List[String] =\
    \ Nil\n        var currPrefix: String = \"\"\n        var currentLength : Int\
    \ = string.length\n        while(currentLength > 0) {\n            var lastChar\
    \ = string.last\n            currentLength = currentLength - lastChar.length\n\
    \            var newPrefix = currPrefix + lastChar\n            if(string.startsWith(newPrefix))\
    \ {\n                output = output :+ newPrefix\n                currPrefix\
    \ = newPrefix\n            }\n        }\n        output.reverse", "        val\
    \ prefixes = mutable.Stack[String]()\n        var current = \"\"\n        for(\
    \ c <- string) {\n            current += c\n            prefixes += current\n\
    \        }\n        prefixes.reverse.tail.map(_.toString)", "        val prefix\
    \ = new Array[String]()\n        allPrefixesAux(string, 0, prefix, new mutable.ListBuffer[String]())",
  "        var list = List[String]()\n        var cur = string\n        while (cur.length\
    \ > 0) {\n            val newList: List[String] = cur splitTo List(\"aa\", \"\
    ab\", \"ac\", \"ba\", \"bb\", \"bc\", \"ca\", \"cb\", \"cc\")\n            list\
    \ :+ newList.head\n            cur = newList.tail.head\n        }\n        list.reverse",
  "        string.headOption match {\n            case None => List(string.tail)\n\
    \            case Some(head) =>\n                val tail = string.tail\n    \
    \            tail.headOption match {\n                    case None => List(head\
    \ :: tail)\n                    case Some(tailhead) =>\n                     \
    \   allPrefixes(tail) ::: List(tailhead)\n                }\n        }", "   \
    \     // If string contains only one character, it is a prefix of empty string\n\
    \        if (string.length <= 1) {\n            return Nil\n        }\n      \
    \  \n        // Set of all possible prefixes\n        var prefixes = mutable.Set[String]()\n\
    \        \n        // If string is a prefix of empty string, it is also a prefix\
    \ of any other string.\n        // So add it to the prefix set\n        prefixes\
    \ += string\n        \n        // Repeat till we find longest possible prefix\n\
    \        var i = string.length\n        while (i > 0) {\n            prefixes\
    \ += string(i)\n            i -= 1\n        }\n        \n        // Convert prefix\
    \ set to a list\n        prefixes.toList", "        val len = string.length\n\
    \        val prefixes = List(string.substring(0), string.substring(1, len-1)).map(x\
    \ => x + string.substring(len-1))\n        val longestPrefixes = prefixes.sortBy(_.length).reverse\n\
    \        longestPrefixes.map(_ + string.substring(len-1))", "        val prefixes\
    \ = ListBuffer.empty[String]\n        for (i <- string.length to 1 by -1) {\n\
    \            prefixes ++= allPrefixesIterative(string, i)\n        }\n       \
    \ prefixes", "        val startIndex = math.min(string.length, string.length-4)\n\
    \        val prefixes = List.newBuilder[String]\n        for (i <- 0 to startIndex)\
    \ {\n            prefixes += (string.take(i) + string.drop(i+1))\n        }\n\
    \        prefixes.result"]
stop_tokens:
- "\n    }\n"
