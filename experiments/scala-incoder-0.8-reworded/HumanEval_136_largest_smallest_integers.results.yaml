language: scala
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val minusCount = lst.count(x\
    \ => x < 0l)\n        val plusCount = lst.count(x => x > 0l)\n        val min\
    \ = lst.min\n        val max = lst.max\n        if(minusCount > plusCount){\n\
    \            return (Some(min), Some(max))\n        }\n        else if(minusCount\
    \ < plusCount){\n            return (Some(max), Some(min))\n        }\n      \
    \  else\n            return (Nil, Nil)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5aydttf2.scala:27:20\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mreturn\e[0m\
    \ (Nil, Nil)\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e\
    [0m                    Found:    collection.immutable.Nil.type\n\e[31m   |\e[0m\
    \                    Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp5aydttf2.scala:27:25 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mreturn\e[0m (Nil, Nil)\n\e[31m\e[31m\
    \   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m                 \
    \        Found:    collection.immutable.Nil.type\n\e[31m   |\e[0m            \
    \             Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(l\
    \ => l.toLong < 0)\n        val positives = lst.filter(l => l.toLong > 0)\n  \
    \      negatives.reverse.takeWhile(l => positives.isEmpty)\n            .filter(l\
    \ => l > positives.min).lastOption\n            .reverse.map(l => l.toLong)\n\
    \            .find(positives.isDefined) match {\n            case Some(positive)\
    \ => positive\n            case None => None\n            }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkut7f_op.scala:20:13 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        negatives.reverse.takeWhile(\e[36ml\e[0m => positives.isEmpty)\n\
    \e[31m19 |\e[0m            .filter(\e[36ml\e[0m => l > positives.min).lastOption\n\
    \e[31m20 |\e[0m            .reverse.map(\e[36ml\e[0m => l.toLong)\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        value reverse is not a member\
    \ of Option[Long]\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkut7f_op.scala:22:35\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e\
    [0m Some(positive) => positive\n\e[31m\e[31m   |\e[0m                        \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   Not\
    \ found: positive\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkut7f_op.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m None\
    \ => None\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    None.type\n\e[31m   |\e[0m             \
    \            Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Create a Set with the integers\
    \ in the list.\n        var numbers = Set(lst: _*)\n        \n        // If there\
    \ are no negative integers, return an empty Tuple2.\n        if (numbers.forall(n\
    \ => n < 0l.toLong)) \n            (None, None)\n        \n        // Else, add\
    \ all the negative integers to the Set.\n        else {\n            numbers =\
    \ numbers.filterNot(n => n < 0l.toLong)\n        }\n        \n        // If there\
    \ are no positive integers, return an empty Tuple2.\n        if (numbers.forall(n\
    \ => n > 0l.toLong)) \n            (None, None)\n        \n        // Else, add\
    \ all the positive integers to the Set.\n        else {\n            numbers =\
    \ numbers.filterNot(n => n > 0l.toLong)\n        }\n        \n        // Sort\
    \ the Set of integers\n        val numbersSorted = numbers.toSorted\n        \n\
    \        // Find the first integer that is negative, and the first integer that\
    \ is positive.\n        val firstNegativeNumber = numbersSorted.find(n => n <\
    \ 0l.toLong)\n        val firstPositiveNumber = numbersSorted.find(n => n > 0l.toLong)\n\
    \        \n        // Return the smallest negative integer, and smallest positive\
    \ integer\n        // if the positive integer is larger than the negative integer,\
    \ or \n        // the negative integer is larger than the positive integer, \n\
    \        // respectively.\n        if (firstPositiveNumber > firstNegativeNumber)\n\
    \            (Some(firstNegativeNumber), Some(firstPositiveNumber))\n        else\n\
    \            (Some(firstPositiveNumber), Some(firstNegativeNumber))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcchly70c.scala:38:36 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mnumbersSorted\e[0m = numbers.toSorted\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    value toSorted is not a member of scala.collection.mutable.Set[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val ints = lst.filter(i =>\
    \ i < 0l || i > 0l)\n        if (ints.isEmpty) None\n        else Some(ints.min),\
    \ Some(ints.max)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpywd5p34a.scala:18:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m Some(ints.min), Some(ints.max)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     end of statement expected but ',' found\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpywd5p34a.scala:17:26 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (ints.isEmpty) None\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m               \
    \           Found:    None.type\n\e[31m   |\e[0m                          Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(x\
    \ => x < 0l)\n        val posInts = lst.filter(x => x > 0l)\n        negInts.reduceLeft((a,\
    \ b) => Option(a).getOrElse(Option(b).getOrElse(None)))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplbbzcyxq.scala:18:77\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        negInts.reduceLeft((\e\
    [36ma\e[0m, \e[36mb\e[0m) => Option(a).getOrElse(Option(b).getOrElse(None)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                        Found:    None.type\n\e[31m   |\e[0m                \
    \                                     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var result = Option[Long]()\n\
    \        var temp1 = Option[Long]()\n        var temp2 = Option[Long]()\n    \
    \    for(i <- 0 until lst.length) {\n            temp1 = Option[Long](if(lst(i)\
    \ < 0) Option(-lst(i)) else lst(i))\n            temp2 = Option[Long](if(lst(i)\
    \ > 0) Option(lst(i)) else -lst(i))\n            if(temp1.isEmpty && temp2.isDefined)\
    \ result = temp2\n            else if(temp2.isEmpty && temp1.isDefined) result\
    \ = temp1\n            else result = Some(Math.max(result.get, Math.min(-result.get,\
    \ temp1.get)))\n        }\n        result.filter(_ != None).map {\n          \
    \  case Some(number) => Tuple2(Some(number), Some(-number))\n            case\
    \ _ => Tuple2(Some(None), Some(None))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpno4y50km.scala:16:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = Option[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmissing argument for parameter x of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mobject\e[0m \e[35mOption\e[0m: (x: Long): Option[Long]\n\e[31m\e\
    [31m-- Error: /tmp/tmpno4y50km.scala:17:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mtemp1\e[0m = Option[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmissing argument for parameter x of \e[33mmethod\e[0m \e[35mapply\e[0m\
    \ in \e[33mobject\e[0m \e[35mOption\e[0m: (x: Long): Option[Long]\n\e[31m\e[31m--\
    \ Error: /tmp/tmpno4y50km.scala:18:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mtemp2\e[0m = Option[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmissing argument for parameter x of \e[33mmethod\e[0m \e[35mapply\e[0m\
    \ in \e[33mobject\e[0m \e[35mOption\e[0m: (x: Long): Option[Long]\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpno4y50km.scala:20:54 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            temp1 = Option[\e[35mLong\e[0m](\e[33mif\e\
    [0m(lst(i) < \e[31m0\e[0m) Option(-lst(i)) \e[33melse\e[0m lst(i))\n\e[31m\e[31m\
    \   |\e[0m                                                ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                Found:    Option[Long]\n\
    \e[31m   |\e[0m                                                Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpno4y50km.scala:21:54\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            temp2 = Option[\e\
    [35mLong\e[0m](\e[33mif\e[0m(lst(i) > \e[31m0\e[0m) Option(lst(i)) \e[33melse\e\
    [0m -lst(i))\n\e[31m\e[31m   |\e[0m                                          \
    \      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \              Fou"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var positive: List[Long] =\
    \ Nil\n        var negative: List[Long] = Nil\n        lst.foreach(i => if (i\
    \ < 0) negative += i else positive += i)\n\n        var positiveMin = positive.min\n\
    \        var positiveMax = positive.max\n        var negativeMin = negative.min\n\
    \        var negativeMax = negative.max\n        if (positiveMin < 0L) positiveMin\
    \ = None\n        if (positiveMax > 0L) positiveMax = None\n        if (negativeMin\
    \ < 0L) negativeMin = None\n        if (negativeMax > 0L) negativeMax = None\n\
    \n        val tuple = positiveMin min negativeMin max positiveMax max negativeMax\n\
    \        if (tuple == None) tuple else tuple._1.asInstanceOf[Tuple2[Option[Long],\
    \ Option[Long]]]\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2f3ntsv4.scala:18:45 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.foreach(\e[36mi\e[0m => \e[33mif\e[0m (i\
    \ < \e[31m0\e[0m) negative += i \e[33melse\e[0m positive += i)\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    value += is not a member of List[Long] - did you mean List[Long].!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2f3ntsv4.scala:18:64 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.foreach(\e[36mi\e[0m => \e[33mif\e[0m (i\
    \ < \e[31m0\e[0m) negative += i \e[33melse\e[0m positive += i)\n\e[31m\e[31m \
    \  |\e[0m                                                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value += is not a member of List[Long] - did you mean\
    \ List[Long].!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2f3ntsv4.scala:24:44\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (positiveMin\
    \ < \e[31m0L\e[0m) positiveMin = None\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                     Found:    None.type\n\e[31m   |\e[0m                   \
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2f3ntsv4.scala:25:44 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mif\e[0m (positiveMax > \e[31m0L\e[0m) positiveMax\
    \ = None\n\e[31m\e[31m   |\e[0m                                            ^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    None.type\n\
    \e[31m   |\e[0m                                            Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2f3ntsv4.scala:26:44\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (negativeMin\
    \ < \e[31m0L\e[0m) negativeMin = None\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                     "
  stdout: ''
  timestamp: 1660028885
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def loop(lst : List[Long],\
    \ min: Long, max: Long) : Tuple2[Option[Long], Option[Long]] = \n            lst\
    \ match {\n                case Nil => (None, None)\n                case head\
    \ :: tail =>\n                    if (head < min && head > max) loop(lst, head,\
    \ head)\n                    else if (head > min) loop(lst, head, max)\n     \
    \               else loop(lst, min, head)\n            }\n        loop(lst, Long.MinValue,\
    \ Long.MaxValue)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660028888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if(lst.nonEmpty) {\n     \
    \       var maxPositive = lst(0)\n            var minNegative = lst(0)\n     \
    \       for(i<-lst.indices) {\n                if(lst(i) < 0) {\n            \
    \        minNegative = lst(i)\n                } else if(lst(i) > 0) {\n     \
    \               maxPositive = lst(i)\n                }\n            }\n     \
    \       (Option(maxPositive), Option(minNegative))\n        } else {\n       \
    \     (None, None)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprl7gs0n4.scala:32)\n\tat Problem.main(tmprl7gs0n4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negNums = lst.filter(x\
    \ => x < 0l)\n        val posNums = lst.filter(x => x > 0l)\n        if(negNums.isEmpty)\
    \ {\n            (Some(None), Some(None))\n        } else if(posNums.isEmpty)\
    \ {\n            (Some(None), (negNums.min))\n        } else {\n            (Some(negNums.max),\
    \ Some(posNums.min))\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphah0rzpr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphah0rzpr.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphah0rzpr.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), (negNums.min))\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\e\
    [31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmphah0rzpr.scala:21:26 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            (Some(None), (negNums.min))\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                  Found:    Long\n\e[31m   |\e[0m                          Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val smallest = lst.minBy(_.toInt)\n\
    \        val largest = lst.maxBy(_.toInt)\n        if (smallest < 0 || largest\
    \ > 0) {\n            Some((Some(largest), Some(smallest)))\n        }\n     \
    \   else {\n            None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpny165ne5.scala:19:16\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            Some((Some(largest),\
    \ Some(smallest)))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    \e[1m\e[31mSome\e[0m\e[1m\e[31m[\e[0m(\e\
    [1m\e[31mSome\e[0m[Long], \e[1m\e[31mSome\e[0m[Long])\e[1m\e[31m]\e[0m\n\e[31m\
    \   |\e[0m            Required: (\e[1m\e[32mOption\e[0m[Long], \e[1m\e[32mOption\e\
    [0m[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpny165ne5.scala:22:12\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            None\n\e[31m\e[31m\
    \   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            Found:    None.type\n\
    \e[31m   |\e[0m            Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var maxOption: Option[Long]\
    \ = None\n        var minOption: Option[Long] = None\n        var max = None\n\
    \        var min = None\n        for(i <- lst) {\n            if(i < 0) {\n  \
    \              if (maxOption.isEmpty) {\n                    maxOption = Some(i)\n\
    \                } else if (max.isLessThan(i - 1l)) {\n                    max\
    \ = Some(i)\n                }\n            } else {\n                if (minOption.isEmpty)\
    \ {\n                    minOption = Some(i)\n                } else if (min.isLessThan(i\
    \ + 0l)) {\n                    min = Some(i)\n                }\n           \
    \ }\n        }\n        (maxOption, minOption)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsntvd3gf.scala:24:31 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (max.isLessThan(i\
    \ - \e[31m1l\e[0m)) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value isLessThan is not a member\
    \ of object None\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsntvd3gf.scala:25:30\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    max = Some(i)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Found:    Some[Long]\n\e[31m   |\e[0m              \
    \            Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsntvd3gf.scala:30:31 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                } \e[33melse\e[0m \e[33mif\e[0m (min.isLessThan(i + \e[31m0l\e\
    [0m)) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         value isLessThan is not a member of object\
    \ None\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsntvd3gf.scala:31:30\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    min = Some(i)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Found:    Some[Long]\n\e[31m   |\e[0m              \
    \            Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldRight(\n         \
    \   ((Option(Long.MaxValue), Option(Long.MinValue)): Option[(Long, Long)]),\n\
    \            (a, b) => a match {\n                case (Some(a1), Some(b1)) if\
    \ a1 < b1 => (Some(a1), Some(b1))\n                case (Some(a1), Some(b1)) if\
    \ a1 > b1 => (Some(b1), Some(a1))\n                case _ => (a, b)\n        \
    \    }\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfkr1iplo.scala:17:13\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            ((Option(Long.MaxValue),\
    \ Option(Long.MinValue)): \e[35mOption\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m)]),\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    \e[1m\e[31m(\e[0mOption[Long\e[1m\e\
    [31m]\e[0m, \e[1m\e[31mOption\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e[0m]\e[1m\e\
    [31m)\e[0m\n\e[31m   |\e[0m             Required: Option[\e[1m\e[32m(\e[0m\e[1m\e\
    [32mLong\e[0m, Long)\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpfkr1iplo.scala:18:13 -----------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            (\e[36ma\e[0m, \e[36mb\e[0m) => a \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m             I could not infer\
    \ the type of the parameter a.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfkr1iplo.scala:18:16\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            (\e[36ma\e\
    [0m, \e[36mb\e[0m) => a \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m            \
    \    ^\e[0m\n\e[31m   |\e[0m                Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                I could not infer the type of the parameter\
    \ b.\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfkr1iplo.scala:19:45 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m (Some(a1), Some(b1))\
    \ \e[33mif\e[0m a1 < b1 => (Some(a1), Some(b1))\n\e[31m\e[31m   |\e[0m       \
    \                                      ^^\e[0m\n\e[31m   |\e[0m              \
    \                               Not found: a1\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfkr1iplo.scala:19:62 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m (Some(a1), Some(b1))\
    \ \e[33mif\e[0m a1 < b1 => (Some(a1), Some(b1))\n\e[31m\e[31m   |\e[0m       \
    \                                                  "
  stdout: ''
  timestamp: 1660028882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def getMax(lst : List[Long],\
    \ max : Long) : Long = {\n            max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3wwvttfr.scala:17:1995 -------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max "
  stdout: 'java.lang.StackOverflowError while compiling /tmp/tmp3wwvttfr.scala

    '
  timestamp: 1660028877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val sortedList = lst.sortBy(math.abs)\n\
    \        var largest = sortedList.head\n        var smallest = sortedList.last\n\
    \        sortedList.foreach { x =>\n            if (x < 0) {\n               \
    \ if (largest < x) {\n                    largest = x\n                }\n   \
    \         } else {\n                if (smallest > x) {\n                    smallest\
    \ = x\n                }\n            }\n        }\n        (Option(largest),\
    \ Option(smallest))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjjqd7c9q.scala:33)\n\tat Problem.main(tmpjjqd7c9q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(n : Long) : Option[Long]\
    \ = {\n            if (n <= 0l) None\n            else Some(n)\n        }\n  \
    \      def smallest(n : Long) : Option[Long] = {\n            if (n >= 0l) None\n\
    \            else Some(n)\n        }\n        def compare(a: Long, b: Long) :\
    \ Int = {\n            if (a < b) -1\n            else if (a > b) 1\n        \
    \    else 0\n        }\n        val sorted = lst.sorted(compare)\n        (largest(sorted.head),\
    \ smallest(sorted.last))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbui41j_t.scala:33)\n\tat Problem.main(tmpbui41j_t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(v : Long) : Option[Long]\
    \ = {\n            if (v > 0l) {\n                return Some(v)\n           \
    \ }\n            else None\n        }\n        def smallest(v : Long) : Option[Long]\
    \ = {\n            if (v < 0l) {\n                return Some(v)\n           \
    \ }\n            else None\n        }\n        val lists = lst.map(_ => largest(_).map(_\
    \ -> _))\n        val negLists = lists.filter(_.exists(_.isEmpty))\n        val\
    \ posLists = lists.filter(_.exists(!_.isEmpty))\n        if (negLists.isEmpty)\
    \ {\n            return (None, None)\n        } else if (posLists.isEmpty) {\n\
    \            return (None, negLists.headOption)\n        } else if (negLists.size\
    \ > posLists.size) {\n            return (negLists.headOption, None)\n       \
    \ } else if (negLists.size < posLists.size) {\n            return (posLists.headOption,\
    \ None)\n        } else {\n            val list = negLists.head.map(_._1).reduce(_.max)\n\
    \            val other = negLists.map(_.headOption).find(_.isEmpty).getOrElse(posLists.headOption)\n\
    \            return (list, other)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp20lnk1xw.scala:28:41 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlists\e[0m = lst.map(_ =>\
    \ largest(_).map(_ -> _))\n\e[31m\e[31m   |\e[0m                             \
    \            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => largest(_$2).map((_$3, _$4) => _$3 -> _$4).\n\
    \e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp20lnk1xw.scala:28:48 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlists\e[0m = lst.map(_ =>\
    \ largest(_).map(_ -> _))\n\e[31m\e[31m   |\e[0m                             \
    \                   ^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \    Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp20lnk1xw.scala:29:38 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mnegLists\e[0m = lists.filter(_.exists(_.isEmpty))\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value exists is not a member of\
    \ Any\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp20lnk1xw.scala:30:38 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mposLists\e[0m = lists.filter(_.exists(!_.isEmpty))\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value exists is not a member of\
    \ Any\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp20lnk1xw.scala:34:35\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mreturn\e[0m\
    \ (None, negLists.headOption)\n\e[31m\e[31m   |\e[0m                         \
    \ ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:  \
    \  Option[\e[1m\e[31mAny\e[0m]\n\e[31m   |\e[0m                          Required:\
    \ Option[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp20lnk1xw.scala:36:29 ------------------"
  stdout: ''
  timestamp: 1660028886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(x\
    \ => x < 0)\n        val posInts = lst.filter(x => x > 0)\n\n        val negativeMax\
    \ = negInts.maxBy(_.toLong)\n        val positiveMin = posInts.minBy(_.toLong)\n\
    \n        if(negativeMax.isEmpty && positiveMin.isEmpty) return (None, None)\n\
    \        if(negativeMax.isEmpty) return (Some(negativeMax), None)\n        if(positiveMin.isEmpty)\
    \ return (Some(positiveMin), None)\n        return (Some(negativeMax), Some(positiveMin))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2cj2gt_e.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m(negativeMax.isEmpty && positiveMin.isEmpty)\
    \ \e[33mreturn\e[0m (None, None)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value isEmpty is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2cj2gt_e.scala:23:23 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m(negativeMax.isEmpty) \e[33mreturn\e\
    [0m (Some(negativeMax), None)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value isEmpty is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2cj2gt_e.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m(positiveMin.isEmpty) \e[33mreturn\e\
    [0m (Some(positiveMin), None)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value isEmpty is not a member of Long\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      lst.foldLeft((Some(None.asInstanceOf[Long]),\
    \ Some(None.asInstanceOf[Long]))) {\n        (pair: (Option[Long], Option[Long]),\
    \ x: Long) => {\n          val negI = if (x < 0l) None\n          else if (x <\
    \ 0l && pair._2.isDefined) Some(pair._2)\n          else if (pair._1.isDefined)\
    \ Some(pair._1)\n          else None\n          val posI = if (x >= 0l) None\n\
    \          else if (x >= 0l && pair._2.isDefined) Some(pair._2)\n          else\
    \ if (pair._1.isDefined) Some(pair._1)\n          else None\n          if (negI.nonEmpty\
    \ && posI.nonEmpty)\n            pair\n          else if (negI.nonEmpty)\n   \
    \         pair._1.map(_ => negI.get)\n          else if (posI.nonEmpty)\n    \
    \        pair._2.map(_ => posI.get)\n          else\n            (pair._1, pair._2)\n\
    \        }\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnb0gu4t8.scala:29:23\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            pair._1.map(_ =>\
    \ negI.get)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Found:    Option[Option[Long]\e[1m\e[31m]\e[0m\n\e\
    [31m   |\e[0m            Required: \e[1m\e[32m(\e[0mOption[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnb0gu4t8.scala:31:23\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            pair._2.map(_ =>\
    \ posI.get)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Found:    Option[Option[Long]\e[1m\e[31m]\e[0m\n\e\
    [31m   |\e[0m            Required: \e[1m\e[32m(\e[0mOption[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.sortWith(_.signum < 0).reduceRight(_\
    \ match {\n            case (a, b) => if (a > b) (a, None) else (None, b)\n  \
    \      }).map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp9ydtmrb0.scala:16:21 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.sortWith(_.signum < \e[31m0\e[0m).reduceRight(_\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp9ydtmrb0.scala:16:47 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.sortWith(_.signum < \e[31m0\e[0m).reduceRight(_\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \             ^\e[0m\n\e[31m   |\e[0m                                 Wrong number\
    \ of parameters, expected: 2\n\e[31m17 |\e[0m            \e[33mcase\e[0m (a, b)\
    \ => \e[33mif\e[0m (a > b) (a, None) \e[33melse\e[0m (None, b)\n\e[31m18 |\e[0m\
    \        }).map(_._1)\n2 errors found\n"
  stdout: ''
  timestamp: 1660028879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def isNegative(i: Long): Boolean\
    \ = i >= 0\n        def isPositive(i: Long): Boolean = i < 0\n        val minusList:\
    \ mutable.Buffer[Long] = mutable.Buffer.empty\n        val plusList: mutable.Buffer[Long]\
    \ = mutable.Buffer.empty\n        for(i <- lst) {\n            if(isNegative(i))\
    \ {\n                minusList += i\n            }\n            if(isPositive(i))\
    \ {\n                plusList += i\n            }\n        }\n        val minus:\
    \ Option[Long] = minusList.isEmpty match {\n            case true => None\n  \
    \          case false => Some(minusList.max)\n        }\n        val plus: Option[Long]\
    \ = plusList.isEmpty match {\n            case true => None\n            case\
    \ false => Some(plusList.min)\n        }\n        (minus, plus)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp88vujo61.scala:18:23 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mminusList\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer.empty\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp88vujo61.scala:18:46\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mminusList\e[0m: mutable.Buffer[\e[35mLong\e[0m] = mutable.Buffer.empty\n\e\
    [31m\e[31m   |\e[0m                                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp88vujo61.scala:19:22\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mplusList\e[0m: mutable.Buffer[\e[35mLong\e[0m] = mutable.Buffer.empty\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp88vujo61.scala:19:45 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mplusList\e[0m: mutable.Buffer[\e[35mLong\e[0m]\
    \ = mutable.Buffer.empty\n\e[31m\e[31m   |\e[0m                              \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val a = lst.foldLeft(Option.empty[Long],\
    \ Option.empty[Long]){\n            case (acc, elem) =>\n                val b\
    \ = (elem - acc._2).getOrElse(0)\n                val c = acc._1 + (b > 0)\n \
    \               (Some(c), Some(b))\n        }\n        (a._1, a._2)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxt510v4y.scala:18:30 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e[0m \e[36mb\e[0m = (elem -\
    \ acc._2).getOrElse(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mmatch arguments ((acc._2 : => Option[Long]))\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpxt510v4y.scala:19:31 ------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m                \e[33mval\e[0m \e[36mc\e[0m = acc._1 + (b > \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of Option[Long], but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if(lst.size < 2)\n       \
    \     return ( Some(None), Some(None))\n        if(lst.size == 0)\n          \
    \  return ( Some(None), Some(None))\n        val l = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        val max: Option[Long] = None\n        val min: Option[Long] = None\n\
    \        for(i <- 0 until lst.size) {\n            l.append(lst(i))\n        \
    \    if(l.last < 0l){\n                max = Some(l.last)\n            }\n   \
    \         if(l.last > 0l){\n                min = Some(l.last)\n            }\n\
    \        }\n        ( max, min)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdkakqbh_.scala:17:26\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mreturn\e[0m\
    \ ( Some(None), Some(None))\n\e[31m\e[31m   |\e[0m                          ^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    None.type\n\e[31m   |\e\
    [0m                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdkakqbh_.scala:17:38 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mreturn\e[0m ( Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                      Found:    None.type\n\e[31m   |\e\
    [0m                                      Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdkakqbh_.scala:19:26 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mreturn\e[0m ( Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                      Found:    None.type\n\e[31m   |\e[0m                  \
    \        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdkakqbh_.scala:19:38\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mreturn\e[0m\
    \ ( Some(None), Some(None))\n\e[31m\e[31m   |\e[0m                           \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                                      Found:\
    \    None.type\n\e[31m   |\e[0m                                      Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdkakqbh_.scala:26:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                max\
    \ = Some(l.last)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val max\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer expl"
  stdout: ''
  timestamp: 1660028884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val smallestNegative = None\n\
    \        val smallestPositive = None\n        for(i <- 0 until lst.size) {\n \
    \           if(lst(i) < 0) {\n                if(smallestNegative == None) smallestNegative\
    \ = Some(lst(i))\n                else smallestNegative = Some(smallestNegative.getOrElse(lst(i)))\n\
    \            } else {\n                if(smallestPositive == None) smallestPositive\
    \ = Some(lst(i))\n                else smallestPositive = Some(smallestPositive.getOrElse(lst(i)))\n\
    \            }\n        }\n        smallestNegative match {\n            case\
    \ None => (Some(None), smallestPositive)\n            case Some(smallestNegative)\
    \ => smallestPositive\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0duhb8tp.scala:20:68\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mif\e[0m(smallestNegative\
    \ == None) smallestNegative = Some(lst(i))\n\e[31m\e[31m   |\e[0m            \
    \                                                    ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                   Found:    Some[Long]\n\
    \e[31m   |\e[0m                                                   Required: object\
    \ None\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0duhb8tp.scala:21:44\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                \e[33melse\e\
    [0m smallestNegative = Some(smallestNegative.getOrElse(lst(i)))\n\e[31m\e[31m\
    \   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Some[Long]\n\
    \e[31m   |\e[0m                                        Required: object None\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0duhb8tp.scala:23:68\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m(smallestPositive\
    \ == None) smallestPositive = Some(lst(i))\n\e[31m\e[31m   |\e[0m            \
    \                                                    ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                   Found:    Some[Long]\n\
    \e[31m   |\e[0m                                                   Required: object\
    \ None\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0duhb8tp.scala:24:44\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33melse\e\
    [0m smallestPositive = Some(smallestPositive.getOrElse(lst(i)))\n\e[31m\e[31m\
    \   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Some[Long]\n\
    \e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1660028890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // 1. Find the largest negative\
    \ number in the list.\n        var largestNegativeInt = -math.max(lst.filter(x\
    \ => x < 0).max)\n        // 2. Find the smallest positive number in the list.\n\
    \        var smallestPositiveInt = math.min(lst.filter(x => x > 0).min)\n    \
    \    // 3. Return tuple (a, b) where b is the smallest positive number\n     \
    \   //     in the list and a is the largest negative number in the list.\n   \
    \     // Return them as Option[Long] since we might need to return None if\n \
    \       // there is no negative or positive numbers.\n        return (Some(largestNegativeInt),\
    \ Some(smallestPositiveInt))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7u4gvktc.scala:17:39 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mlargestNegativeInt\e[0m\
    \ = -math.max(lst.filter(\e[36mx\e[0m => x < \e[31m0\e[0m).max)\n\e[31m\e[31m\
    \   |\e[0m                                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Long)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7u4gvktc.scala:19:39\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e\
    [0m \e[36msmallestPositiveInt\e[0m = math.min(lst.filter(\e[36mx\e[0m => x > \e\
    [31m0\e[0m).min)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments (Long)\n2 errors found\n"
  stdout: ''
  timestamp: 1660028890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(i\
    \ => i < 0l)\n        val positive = lst.filter(i => i >= 0l)\n        val min\
    \ = negative.min\n        val max = positive.max\n        if(min < max){\n   \
    \         val smallerNegative = negative.filter(i => i < min)\n            val\
    \ smallerPositive = positive.filter(i => i < min)\n            val smallestPositive\
    \ = smallerPositive.min\n            val smallestNegative = smallerNegative.min\n\
    \            return (Some(smallestPositive), Some(smallestNegative))\n       \
    \ }else{\n            return (None, None)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp2pgp4wpu.scala:18)\n\tat Problem$.main(tmp2pgp4wpu.scala:31)\n\
    \tat Problem.main(tmp2pgp4wpu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_.isPositive)\n\
    \        val negative = lst.filter(_.isNegative)\n        positive.exists(_.max\
    \ < negative.min) match {\n            case true => Some(Some(positive.max), Some(negative.min))\n\
    \            case false => Some(None, None)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmper_09i96.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpositive\e[0m = lst.filter(_.isPositive)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                value isPositive is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmper_09i96.scala:17:36 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnegative\e[0m = lst.filter(_.isNegative)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                value isNegative is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmper_09i96.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        positive.exists(_.max < negative.min) \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue < is not a member of Long => Long, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmper_09i96.scala:19:29\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m \e\
    [31mtrue\e[0m => Some(Some(positive.max), Some(negative.min))\n\e[31m\e[31m  \
    \ |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    \e[1m\e[31mSome\e[0m\e\
    [1m\e[31m[\e[0m(\e[1m\e[31mSome\e[0m[Long], \e[1m\e[31mSome\e[0m[Long])\e[1m\e\
    [31m]\e[0m\n\e[31m   |\e[0m                         Required: (\e[1m\e[32mOption\e\
    [0m[Long], \e[1m\e[32mOption\e[0m[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmper_09i96.scala:20:30 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m \e[31mfalse\e[0m => Some(None,\
    \ None)"
  stdout: ''
  timestamp: 1660028896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val n = lst.head\n       \
    \ val maxNegative = Some(math.min.pound(lst: _*))\n        val minPositive = Some(math.max.pound(lst:\
    \ _*))\n        if(maxNegative.isEmpty || minPositive.isEmpty) None else (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5q3linjp.scala:17:36 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxNegative\e[0m = Some(math.min.pound(lst:\
    \ \e[35m_*\e[0m))\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch expected type ?{ pound: ? }\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp5q3linjp.scala:18:36 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mminPositive\e[0m = Some(math.max.pound(lst:\
    \ \e[35m_*\e[0m))\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch expected type ?{ pound: ? }\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp5q3linjp.scala:19:55 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m(maxNegative.isEmpty || minPositive.isEmpty)\
    \ None \e[33melse\e[0m (maxNegative, minPositive)\n\e[31m\e[31m   |\e[0m     \
    \                                                  ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    None.type\n\e[31m   |\e[0m      \
    \                            Required: (Option[Long], Option[Long])\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val biggest_int = None\n \
    \       val smallest_int = None\n        lst.for( i => biggest_intOption match\
    \ {\n            case None =>\n                smallest_intOption = Some(i)\n\
    \            case Some(biggest) =>\n                if ( biggest > i)\n      \
    \              biggest_intOption = Some(i)\n                else if ( biggest\
    \ < smallest_int)\n                    smallest_intOption = Some(i)\n        })\n\
    \        (smallest_intOption, biggest_intOption)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpahfu5npe.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.\e[33mfor\e[0m( i => biggest_intOption \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m \
    \           an identifier expected, but 'for' found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpahfu5npe.scala:27:9 -------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        (smallest_intOption, biggest_intOption)\n\e[31m\e\
    [31m   |\e[0m         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Not found:\
    \ smallest_intOption\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahfu5npe.scala:27:29\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        (smallest_intOption,\
    \ biggest_intOption)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: biggest_intOption\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var largest = lst.max\n  \
    \      var smallest = lst.min\n        lst.reverse.foreach { l =>\n          \
    \  if (-l.asInstanceOf[Long] <= smallest && smallest < l.asInstanceOf[Long]) smallest\
    \ = l.asInstanceOf[Long]\n            if (l.asInstanceOf[Long] <= largest && largest\
    \ < l.asInstanceOf[Long]) largest = l.asInstanceOf[Long]\n        }\n        if\
    \ (smallest == Long.MinValue) smallest = Option.empty[Long]\n        if (largest\
    \ == Long.MaxValue) largest = Option.empty[Long]\n        (smallest, largest)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakkumwwf.scala:22:62\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (smallest\
    \ == Long.MinValue) smallest = Option.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    Option[Long]\n\
    \e[31m   |\e[0m                                                  Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakkumwwf.scala:23:60\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (largest\
    \ == Long.MaxValue) largest = Option.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                                                ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                Found:    Option[Long]\n\
    \e[31m   |\e[0m                                                Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakkumwwf.scala:24:9\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        (smallest, largest)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:  \
    \  (smallest : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakkumwwf.scala:24:19 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        (smallest, largest)\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    (largest\
    \ : Long)\n\e[31m   |\e[0m                   Required: Option[Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val minValue = lst.min\n \
    \       val maxValue = lst.max\n        if (minValue == 0l) {\n            (Some(None),\
    \ Some(None))\n        } else if (maxValue == 0l) {\n            (Some(None),\
    \ None)\n        } else {\n            (Some(maxValue), Some(minValue))\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp249_6f15.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp249_6f15.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp249_6f15.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), None)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\e[31m   |\e\
    [0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        import scala.math._\n    \
    \    import scala.collection.mutable.Queue\n        val q = Queue.empty[Long]\n\
    \        for (i <- 0 until lst.size) {\n            val x = lst(i)\n         \
    \   if (x < 0) q.enqueue(x)\n            else if (x > 0) {\n                val\
    \ y = q.dequeue()\n                if (y > x) Some(y) else None\n            \
    \    q.enqueue(x)\n            }\n        }\n        val b = q.dequeue()\n   \
    \     if (q.size == 0) (Some(b), None)\n        else (Some(b), Some(q.head))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: empty collection\n\tat scala.collection.mutable.ArrayDeque.removeHead(ArrayDeque.scala:303)\n\
    \tat scala.collection.mutable.Queue.dequeue(Queue.scala:77)\n\tat Problem$.largestSmallestIntegers$$anonfun$1(tmpgsznsot4.scala:23)\n\
    \tat Problem$.largestSmallestIntegers$$anonfun$adapted$1(tmpgsznsot4.scala:27)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.largestSmallestIntegers(tmpgsznsot4.scala:27)\n\
    \tat Problem$.main(tmpgsznsot4.scala:33)\n\tat Problem.main(tmpgsznsot4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(\
    \ x => x < 0 );\n        val posInts = lst.filter( x => x >= 0 );\n        if\
    \ (negInts.isEmpty) {\n            (None, Some(posInts.min))\n        } else if\
    \ (posInts.isEmpty) {\n            (Some(negInts.max), None)\n        } else {\n\
    \            (Some(negInts.max), Some(posInts.min))\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_xj0ku4t.scala:27)\n\tat Problem.main(tmp_xj0ku4t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val l = lst.sorted\n     \
    \   val isNegative = l map (_ < 0l) exists _\n        if (l.isEmpty) None \n \
    \       else (Some(l.head), if (isNegative) l.head else l.tail.min) \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp2p4ix4sh.scala:17:47 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36misNegative\e[0m = l map\
    \ (_ < \e[31m0l\e[0m) exists _\n\e[31m\e[31m   |\e[0m                        \
    \                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2\
    \ of expanded function:\n\e[31m   |\e[0m   _$2 => l map (_$1 => _$1 < \e[31m0L\e\
    [0m) exists _$2.\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2p4ix4sh.scala:18:23\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (l.isEmpty)\
    \ None \n\e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    None.type\n\e[31m   |\e[0m                 \
    \      Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2p4ix4sh.scala:19:46 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m (Some(l.head), \e[33mif\e[0m\
    \ (isNegative) l.head \e[33melse\e[0m l.tail.min) \n\e[31m\e[31m   |\e[0m    \
    \                                        ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                    Found:    Long\n\e[31m   |\e[0m         \
    \                                   Required: Option[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2p4ix4sh.scala:19:56 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m (Some(l.head), \e[33mif\e[0m\
    \ (isNegative) l.head \e[33melse\e[0m l.tail.min) \n\e[31m\e[31m   |\e[0m    \
    \                                                    ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                                  Found:    Long\n\e\
    [31m   |\e[0m                                                  Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Initialize max and min\
    \ to None (no negative or positive integers).\n        val max = Option(-lst.min)\n\
    \        val min = Option(-lst.max)\n        // Loop through each item in lst,\
    \ see if it is a negative or positive integer.\n        // If so, update max and\
    \ min accordingly.\n        for (i <- lst) {\n            if (i < 0)\n       \
    \         max = i\n            else if (i > 0)\n                min = i\n    \
    \    }\n        // If max and min are not None, return the tuple (max, min).\n\
    \        (max, min)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxaaxv884.scala:23:22\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                max = i\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Found:    (i : Long)\n\e[31m   |\e[0m                      Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxaaxv884.scala:25:22\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                min = i\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Found:    (i : Long)\n\e[31m   |\e[0m                      Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val listTuple = lst match\
    \ {\n            case head :: tail => {\n                val headInt = head.asInstanceOf[Int]\n\
    \                val tailInt = tail.filter(_.asInstanceOf[Int]).sortBy(_.asInstanceOf[Int]).head\n\
    \                (Some(headInt), Some(tailInt))\n            }\n            case\
    \ _ => None\n        }\n        listTuple\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps_y15f7i.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m\
    \ \e[36mtailInt\e[0m = tail.filter(_.asInstanceOf[\e[35mInt\e[0m]).sortBy(_.asInstanceOf[\e\
    [35mInt\e[0m]).head\n\e[31m\e[31m   |\e[0m                                   \
    \       ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \              Found:    Int\n\e[31m   |\e[0m                                \
    \          Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmps_y15f7i.scala:24:8 ---------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        listTuple\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (listTuple : Object)\n\e[31m   |\e[0m        Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028896
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val ints = lst.filter(_ >\
    \ 0l).filter(_ < 0l)\n        val negs = lst.filter(_ < 0l).filter(_ > 0l)\n \
    \       if (ints.isEmpty) {\n            (None, None)\n        } else if (negs.isEmpty)\
    \ {\n            (Some(ints.min.toLong), None)\n        } else {\n           \
    \ (Some(ints.min.toLong), Some(ints.max.toLong))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc9302i59.scala:27)\n\tat Problem.main(tmpc9302i59.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldLeft(Option(-1l.toLong),\
    \ Option(1l.toLong))((acc, val) => {\n            val maxValue = acc._2 max val\n\
    \            val minValue = acc._1 min val\n            (maxValue, minValue)\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjb43nmtg.scala:16:66 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.foldLeft(Option(-\e[31m1l\e[0m.toLong), Option(\e\
    [31m1l\e[0m.toLong))((\e[36macc\e[0m, \e[33mval\e[0m) => {\n\e[31m\e[31m   |\e\
    [0m                                                                  ^^^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjb43nmtg.scala:17:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValue\e[0m = acc._2 max \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                                   ^^^\e[0m\n\e[31m   |\e[0m                \
    \                      expression expected but \e[31mval\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjb43nmtg.scala:20:9 ---------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        })\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e\
    [31m   |\e[0m         Found:    Unit\n\e[31m   |\e[0m         Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028896
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negativeValues = lst.filter\
    \ { _ < 0l }\n        val positiveValues = lst.filter { _ > 0l }\n        if(negativeValues.length\
    \ == 0 || positiveValues.length == 0) {\n            (None, None)\n        } else\
    \ {\n            val positiveMax = positiveValues.max\n            val negativeMin\
    \ = negativeValues.min\n            (Some(positiveMax), Some(negativeMin))\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph83ji8j_.scala:27)\n\tat Problem.main(tmph83ji8j_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val (minInt, maxInt) = lst.foldLeft((None[Long],\
    \ None[Long]))((_, (minInt, maxInt)) => {\n            val (a, b) = minInt max\
    \ maxInt\n            (Some(a), Some(b))\n        })\n        (minInt.isDefined\
    \ || maxInt.isDefined).tupled\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpm4uz4g6o.scala:16:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m (minInt, maxInt) = lst.foldLeft((None[\e\
    [35mLong\e[0m], None[\e[35mLong\e[0m]))((_, (minInt, maxInt)) => {\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \             not a legal formal parameter\n\e[31m\e[31m-- Error: /tmp/tmpm4uz4g6o.scala:16:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \ \e[33mval\e[0m (minInt, maxInt) = lst.foldLeft((None[\e[35mLong\e[0m], None[\e\
    [35mLong\e[0m]))((_, (minInt, maxInt)) => {\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \    \e[33mobject\e[0m \e[35mNone\e[0m in \e[33mpackage\e[0m \e[35mscala\e[0m\
    \ does not take type parameters\n\e[31m\e[31m-- Error: /tmp/tmpm4uz4g6o.scala:16:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \ \e[33mval\e[0m (minInt, maxInt) = lst.foldLeft((None[\e[35mLong\e[0m], None[\e\
    [35mLong\e[0m]))((_, (minInt, maxInt)) => {\n\e[31m\e[31m   |\e[0m           \
    \                                              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              \e[33mobject\e[0m \e[35mNone\e[0m in \e[33mpackage\e[0m \e[35mscala\e\
    [0m does not take type parameters\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm4uz4g6o.scala:16:13\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ (minInt, maxInt) = lst.foldLeft((None[\e[35mLong\e[0m], None[\e[35mLong\e[0m]))((_,\
    \ (minInt, maxInt)) => {\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e\
    [0m             Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm4uz4g6o.scala:17:17 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m (a, b) = minInt max maxInt\n\
    \e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                \
    \ Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |"
  stdout: ''
  timestamp: 1660028893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val min = Integer.MIN_VALUE\n\
    \        val max = Integer.MAX_VALUE\n        lst.foldLeft(Option(Integer.MIN_VALUE),\
    \ Option(Integer.MAX_VALUE)) { (acc, x) => {\n            val minValue = acc.getOrElse(Integer.MIN_VALUE)\n\
    \            val maxValue = acc.getOrElse(Integer.MAX_VALUE)\n            if (x\
    \ < min && x > max) None\n            else if (x > max) Some(x)\n            else\
    \ Some(x)\n        }}\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3yllkkbo.scala:19:31 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mminValue\e[0m = acc.getOrElse(Integer.MIN_VALUE)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m           value getOrElse is not a member of (Option[Int], Option[Int])\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp3yllkkbo.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mmaxValue\e[0m = acc.getOrElse(Integer.MAX_VALUE)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m           value getOrElse is not a member of (Option[Int], Option[Int])\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yllkkbo.scala:21:36 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (x < min && x > max) None\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e[31m   |\e\
    [0m                                    Found:    None.type\n\e[31m   |\e[0m  \
    \                                  Required: (Option[Int], Option[Int])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yllkkbo.scala:22:34 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (x > max) Some(x)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    Some[Long]\n\e[31m   |\e[0m       \
    \                       Required: (Option[Int], Option[Int])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yllkkbo.scala:23:21 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m Some(x)\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    Some[Long]\n\
    \e[31m   |\e[0m                 Required: (Option[Int], Option[Int])\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val max = lst.foldLeft((-Int.MaxValue,\
    \ Int.MinValue))((a, b) => if (b < 0) a else (b > a._2 ? b : a._2))\n        val\
    \ min = lst.foldLeft((Int.MaxValue, 0))((a, b) => if (b > 0) a else (b < a._2\
    \ ? b : a._2))\n        (Some(max._1), Some(min._1))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsc05a5rq.scala:16:108 -----------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = lst.foldLeft((-Int.MaxValue,\
    \ Int.MinValue))((\e[36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (b < \e[31m0\e\
    [0m) a \e[33melse\e[0m (b > a._2 ? b : a._2))\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \      type _2 is not a member of (Int, Int)\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpsc05a5rq.scala:16:100 -----------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = lst.foldLeft((-Int.MaxValue, Int.MinValue))((\e\
    [36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (b < \e[31m0\e[0m) a \e[33melse\e[0m\
    \ (b > a._2 ? b : a._2))\n\e[31m\e[31m   |\e[0m                              \
    \                                                                 ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                          value ? is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsc05a5rq.scala:17:96\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mmin\e[0m = lst.foldLeft((Int.MaxValue, \e[31m0\e[0m))((\e[36ma\e[0m, \e[36mb\e\
    [0m) => \e[33mif\e[0m (b > \e[31m0\e[0m) a \e[33melse\e[0m (b < a._2 ? b : a._2))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                      ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                       type _2 is not a member of (Int, Int)\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsc05a5rq.scala:17:88 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = lst.foldLeft((Int.MaxValue,\
    \ \e[31m0\e[0m))((\e[36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (b > \e[31m0\e\
    [0m) a \e[33melse\e[0m (b < a._2 ? b : a._2))\n\e[31m\e[31m   |\e[0m         \
    \                                                                          ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          value ? is not a\
    \ member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1660028897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      lst.sortWith(_ < _)\n      val\
    \ firstInt = lst.headOption\n      val secondInt = lst.tail.find(_ > 0).toOption\n\
    \      (firstInt, secondInt)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnzyv79ix.scala:18:43 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36msecondInt\e[0m = lst.tail.find(_\
    \ > \e[31m0\e[0m).toOption\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value toOption is not a member of Option[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.map{x => if (x < 0) None\
    \ else Some(x)}\n        .reduce((a, b) => if (a.isEmpty) b else a) match {\n\
    \            case (a: List[Option[Long]], b: List[Option[Long]]) =>\n        \
    \        ((a ++ b).lastOption, a.head)\n            case (a: List[Option[Long]],\
    \ _) =>\n                (a, None)\n            case (_: List[Option[Long]], b:\
    \ List) =>\n                (None, b)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vy9g_a1.scala:19:26\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                ((a ++ b).lastOption,\
    \ a.head)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                 Found:    Option[\e[1m\e[31mOption\e[0m\e[1m\e[31m[\e\
    [0mLong\e[1m\e[31m]\e[0m]\n\e[31m   |\e[0m                 Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vy9g_a1.scala:21:17\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                (a, None)\n\e\
    [31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    \e[1m\e[31m(\e[0m\e[1m\e[31ma\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mOption[Long\e[1m\e[31m]\e[0m]\e\
    [1m\e[31m)\e[0m\n\e[31m   |\e[0m                 Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E056] Syntax Error: /tmp/tmp1vy9g_a1.scala:22:44 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m (_: List[Option[Long]], b:\
    \ List) =>\n\e[31m\e[31m   |\e[0m                                            ^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Missing type parameter\
    \ for List\n3 errors found\n"
  stdout: ''
  timestamp: 1660028898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) \n      \
    \      (None, None)\n        else {\n            var max : Option[Long] = None\n\
    \            var min : Option[Long] = None\n            lst.foreach( elem => if(elem\
    \ > 0){\n                if(max != None)\n                    max = Some(elem)\n\
    \                else\n                    min = Some(elem)\n            }\n \
    \           else {\n                if(min != None)\n                    min =\
    \ Some(elem)\n                else\n                    max = Some(elem)\n   \
    \         }\n            )\n            (max, min)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbd5k15n1.scala:38)\n\tat Problem.main(tmpbd5k15n1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val max = new Long(math.MinPositiveInteger)\n\
    \        val min = new Long(math.MaxPositiveInteger)\n        var res = Some(max)\n\
    \        lst.foreach(n => {\n            if (n < min) {\n                min =\
    \ n\n                res = Some(min)\n            }\n            if (n > max)\
    \ {\n                max = n\n                res = Some(max)\n            }\n\
    \        })\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpt298wfqw.scala:16:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ \e[35mLong\e[0m(math.MinPositiveInteger)\n\e[31m\e[31m   |\e[0m            \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         too many\
    \ arguments for \e[33mconstructor\e[0m \e[35mLong\e[0m in \e[33mclass\e[0m \e\
    [35mLong\e[0m: (): Long\n\e[31m\e[31m-- Error: /tmp/tmpt298wfqw.scala:17:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = \e[33mnew\e[0m\
    \ \e[35mLong\e[0m(math.MaxPositiveInteger)\n\e[31m\e[31m   |\e[0m            \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         too many\
    \ arguments for \e[33mconstructor\e[0m \e[35mLong\e[0m in \e[33mclass\e[0m \e\
    [35mLong\e[0m: (): Long\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpt298wfqw.scala:21:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                min\
    \ = n\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpt298wfqw.scala:25:20 -----------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                max = n\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val max\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt298wfqw.scala:29:8\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m        res\n\e[31m\e[31m  \
    \ |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m        Found:    (res : Some[Nothing])\n\
    \e[31m   |\e[0m        Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660028900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Solution\n        // Step\
    \ 1: First element is the minimum\n        // Step 2: Second element is the maximum\n\
    \        val minIndex = lst.map((_ < 0).fold(1) { minIndex => minIndex + 1 }).min\n\
    \        val maxIndex = lst.map((_ > 0).fold(1) { maxIndex => maxIndex + 1 }).max\n\
    \        (Some(lst.drop(minIndex).max), Some(lst.take(maxIndex).min))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp1m7a1s3j.scala:19:32 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m = lst.map((_\
    \ < \e[31m0\e[0m).fold(\e[31m1\e[0m) { \e[36mminIndex\e[0m => minIndex + \e[31m1\e\
    [0m }).min\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$1 of expanded function:\n\e[31m   |\e\
    [0m   _$1 => _$1 < 0.\n\e[31m\e[31m-- Error: /tmp/tmp1m7a1s3j.scala:19:80 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m = lst.map((_\
    \ < \e[31m0\e[0m).fold(\e[31m1\e[0m) { \e[36mminIndex\e[0m => minIndex + \e[31m1\e\
    [0m }).min\n\e[31m\e[31m   |\e[0m                                            \
    \                                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35mmin\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmp1m7a1s3j.scala:20:32 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = lst.map((_\
    \ > \e[31m0\e[0m).fold(\e[31m1\e[0m) { \e[36mmaxIndex\e[0m => maxIndex + \e[31m1\e\
    [0m }).max\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$2 of expanded function:\n\e[31m   |\e\
    [0m   _$2 => _$2 > 0.\n\e[31m\e[31m-- Error: /tmp/tmp1m7a1s3j.scala:20:80 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = lst.map((_\
    \ > \e[31m0\e[0m).fold(\e[31m1\e[0m) { \e[36mmaxIndex\e[0m => maxIndex + \e[31m1\e\
    [0m }).max\n\e[31m\e[31m   |\e[0m                                            \
    \                                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByte\e[0m in \e[3"
  stdout: ''
  timestamp: 1660028900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(x : Long) : Option[Long]\
    \ = if (x < 0) Some(x) else None\n        def smallest(x : Long) : Option[Long]\
    \ = if (x > 0) Some(x) else None\n        def largestSmallestIntegersHelper(lst\
    \ : List[Long], idx : Int) : Tuple2[Option[Long], Option[Long]] = {\n        \
    \    if (lst == Nil) \n                (None, None)\n            else if (lst.size\
    \ < idx) {\n                (None, None)\n            } else if (idx < lst.size)\
    \ {\n                (\n                    if (largest(lst.head) == Some(None))\
    \ largest(lst.head)\n                    else smallest(lst.head),\n          \
    \          largestSmallestIntegersHelper(lst.tail, idx + 1)\n                )\n\
    \            } else \n                (\n                    largestSmallestIntegersHelper(lst.tail,\
    \ idx + 1),\n                    if (smallest(lst.head) == Some(None)) smallest(lst.head)\n\
    \                    else largest(lst.head)\n                )\n        }\n  \
    \      val smallestPositiveOption = smallest(lst.head) match {\n            case\
    \ Some(x) => Some(x)\n            case None => None\n        }\n        val largestNegativeOption\
    \ = largest(lst.head) match {\n            case Some(x) => Some(x)\n         \
    \   case None => None\n        }\n        val smallestPositiveOption2 = smallest(lst.head)\
    \ match {\n            case Some(x) => Some(x)\n            case None => None\n\
    \        }\n        val largestPositiveOption3 = largest(lst.head) match {\n \
    \           case Some(x) => Some(x)\n            case None => None\n        }\n\
    \        val smallestPositiveOption4 = smallest(lst.head) match {\n          \
    \  case Some(x) => Some(x)\n            case None => None\n        }\n       \
    \ val largestPositiveOption5 = largest(lst.head) match {\n            case Some(x)\
    \ => Some(x)\n            case None => None\n        }\n        val smallestPositiveOption6\
    \ = smallest(lst.head) match {\n            case Some(x) => Some(x)\n        \
    \    case None => None\n        }\n        val smallestPositiveOption7 = smallest(lst.head)\
    \ match {\n            case Some(x) => Some(x)\n            case None => None\n\
    \        }\n        val largestPositiveOption8 = largest(lst.head) match {\n \
    \           case Some(x) => Some(x)\n            case None => None\n        }\n\
    \        val smallestPositiveOption9 = smallest(lst.head) match {\n          \
    \  case Some(x) => Some(x)\n            case None => None\n        }\n       \
    \ val largestPositiveOption10 = largest(lst.head) match {\n            case Some(x)\
    \ => Some(x)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1ky8xt23.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ky8xt23.scala:27:49\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    largestSmallestIntegersHelper(lst.tail,\
    \ idx + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    \e[1m\e[31m(\e[0mOption[Long\e\
    [1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mOption\e[0m\e[1m\e\
    [31m[\e[0m\e[1m\e[31mLong\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m            \
    \        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1ky8xt23.scala:31:49 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    largestSmallestIntegersHelper(lst.tail, idx + \e[31m1\e\
    [0m),\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    \e[1m\e[31m(\e[0mOption[Long\e\
    [1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mOption\e[0m\e[1m\e\
    [31m[\e[0m\e[1m\e[31mLong\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m            \
    \        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1ky8xt23.scala:93:1 ---------------------\e[0m\e[0m\n\e[31m93\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp1ky8xt23.scala:79:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m79 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660028903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val mn = lst.min\n       \
    \ val mx = lst.max\n        (if (mx < 0) Some(mx) else None), if (mn >= 0) Some(mn)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprfdh_lun.scala:18:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        (\e[33mif\e[0m (mx < \e[31m0\e[0m) Some(mx) \e\
    [33melse\e[0m None), \e[33mif\e[0m (mn >= \e[31m0\e[0m) Some(mn) \e[33melse\e\
    [0m None\n\e[31m\e[31m   |\e[0m                                        ^\e[0m\n\
    \e[31m   |\e[0m                                 end of statement expected but\
    \ ',' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprfdh_lun.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        (\e[33mif\e[0m (mx <\
    \ \e[31m0\e[0m) Some(mx) \e[33melse\e[0m None), \e[33mif\e[0m (mn >= \e[31m0\e\
    [0m) Some(mn) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:    Some[Long]\n\e\
    [31m   |\e[0m                     Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprfdh_lun.scala:18:35 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        (\e[33mif\e[0m (mx < \e[31m0\e[0m) Some(mx) \e\
    [33melse\e[0m None), \e[33mif\e[0m (mn >= \e[31m0\e[0m) Some(mn) \e[33melse\e\
    [0m None\n\e[31m\e[31m   |\e[0m                                   ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val minValue = lst.min\n \
    \       val maxValue = lst.max\n        val negMinValue = lst.filter(_ < minValue).max\n\
    \        val negMaxValue = lst.filter(_ > maxValue).min\n        if(negMaxValue\
    \ == negMinValue){\n            (None, None)\n        }else{\n            (Some(negMaxValue),\
    \ Some(negMinValue))\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpzstqu73e.scala:18)\n\tat Problem$.main(tmpzstqu73e.scala:27)\n\
    \tat Problem.main(tmpzstqu73e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(n\
    \ => n < 0)\n        val positives = lst.filter(n => n > 0)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(None)) \n        else \n            (Some(positives.reduceLeftOption(_\
    \ > _).getOrElse(lst.min))\n                , Some(negatives.reduceLeftOption(_\
    \ < _).getOrElse(lst.max)))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_e5p968v.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\
    \ \n\e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m        \
    \          Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_e5p968v.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\
    \ \n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    None.type\n\e[31m   |\e[0m        \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_e5p968v.scala:21:45 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            (Some(positives.reduceLeftOption(_ > _).getOrElse(lst.min))\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                             Found:    Boolean\n\
    \e[31m   |\e[0m                                             Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_e5p968v.scala:22:50\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                , Some(negatives.reduceLeftOption(_\
    \ < _).getOrElse(lst.max)))\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                        Found:    Boolean\n\e[31m   |\e[0m                  \
    \                                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val (minOption, maxOption)\
    \ = lst.span(_ < 0)\n        val minOption = minOption.filterNot(_ < 0l)\n   \
    \     val maxOption = maxOption.filterNot(_ > 0l)\n        (minOption, maxOption)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprkwb56_m.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminOption\e[0m = minOption.filterNot(_\
    \ < \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminOption is already defined as \e[33mvalue\e[0m \e[35mminOption\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprkwb56_m.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxOption\e[0m = maxOption.filterNot(_\
    \ > \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOption is already defined as \e[33mvalue\e[0m \e[35mmaxOption\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmprkwb56_m.scala:19:9 ---------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        (minOption, maxOption)\n\e[31m\e[31m   |\e[0m         ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Found:    (minOption : List[Long])\n\e[31m   |\e\
    [0m         Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprkwb56_m.scala:19:20 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        (minOption, maxOption)\n\e[31m\e[31m   |\e[0m                \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:    (maxOption :\
    \ List[Long])\n\e[31m   |\e[0m                    Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ < 0l).toList\n        val negative = lst.filter(_ >= 0l).toList\n        val\
    \ minPos = min(positive)\n        val maxNeg = max(negative)\n        (if (minPos\
    \ == 0l)\n            None\n        else\n            (Some(minPos), Some(maxNeg))\n\
    \        )\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbk3zhovh.scala:18:21 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mminPos\e[0m = min(positive)\n\
    \e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((positive : List[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbk3zhovh.scala:19:21\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxNeg\e[0m = max(negative)\n\e[31m\e[31m   |\e[0m                 \
    \    ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((negative : List[Long]))\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbk3zhovh.scala:21:12 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            None\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    None.type\n\e[31m   |\e[0m         \
    \   Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(a: Long, b: Long):\
    \ Option[Long] = if (a < b) Some(a) else None\n        def smallest(a: Long, b:\
    \ Long): Option[Long] = if (a > b) Some(a) else None\n        val pair = lst.foldLeft((None,\
    \ None))((acc: List[Long]) => acc match {\n            case (a, b) => (largest(a,\
    \ a), smallest(a, b))\n            case (a, b) => (None, None)\n            case\
    \ (a, b) => (smallest(a, b), largest(a, b))\n        }).getOrElse((None, None))\n\
    \        val a = pair._1.getOrElse(None)\n        val b = pair._2.getOrElse(None)\n\
    \        (a, b)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ls0a6k5.scala:19:36\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m (a,\
    \ b) => (largest(a, a), smallest(a, b))\n\e[31m\e[31m   |\e[0m               \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \    Found:    (a : Any)\n\e[31m   |\e[0m                                    Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ls0a6k5.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m (a,\
    \ b) => (largest(a, a), smallest(a, b))\n\e[31m\e[31m   |\e[0m               \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \          Found:    (a : Any)\n\e[31m   |\e[0m                              \
    \         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6ls0a6k5.scala:19:52 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mcase\e[0m (a, b) => (largest(a, a), smallest(a, b))\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0m                                                    Found:    (a\
    \ : Any)\n\e[31m   |\e[0m                                                    Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ls0a6k5.scala:19:55\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m (a,\
    \ b) => (largest(a, a), smallest(a, b))\n\e[31m\e[31m   |\e[0m               \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                        Found:    (b : Any)\n\e[31m   |\e[0m\
    \                                                     Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ls0a6k5.scala:21:37 --------------------\e\
    [0m"
  stdout: ''
  timestamp: 1660028910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if(lst.nonEmpty) {\n     \
    \       val m = lst.head\n            val n = lst.reverse.head\n            val\
    \ i = (m <= 0) ? n.toLong : m.toLong\n            val j = (n <= 0) ? m.toLong\
    \ : n.toLong\n            return Some(i), Some(j)\n        } else {\n        \
    \    return None, None\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpitedjd95.scala:21:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mreturn\e[0m Some(i), Some(j)\n\e[31m\e\
    [31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m               \
    \           end of statement expected but ',' found\n\e[31m\e[31m-- Error: /tmp/tmpitedjd95.scala:23:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \     \e[33mreturn\e[0m None, None\n\e[31m\e[31m   |\e[0m                    \
    \   ^\e[0m\n\e[31m   |\e[0m                       end of statement expected but\
    \ ',' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpitedjd95.scala:19:44\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m\
    \ \e[36mi\e[0m = (m <= \e[31m0\e[0m) ? n.toLong : m.toLong\n\e[31m\e[31m   |\e\
    [0m                                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                   type toLong is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpitedjd95.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mi\e[0m = (m <= \e[31m0\e\
    [0m) ? n.toLong : m.toLong\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value ? is not a member of Boolean\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpitedjd95.scala:20:44 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mj\e[0m = (n <= \e[31m0\e\
    [0m) ? m.toLong : n.toLong\n\e[31m\e[31m   |\e[0m                            \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \     type toLong is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpitedjd95.scala:20:29 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            \e[33mval\e[0m \e[36mj\e[0m = (n <= \e[31m0\e[0m) ? m.toLong :\
    \ n.toLong\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                    value ? is not a member of Boolean\n6 errors found\n"
  stdout: ''
  timestamp: 1660028909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val numbers = lst.sortWith(_\
    \ < _)\n        (numbers.head max numbers.tail.headOption, numbers.tail.headOption\
    \ min numbers.head)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppxj1jaf0.scala:17:39\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        (numbers.head max numbers.tail.headOption,\
    \ numbers.tail.headOption min numbers.head)\n\e[31m\e[31m   |\e[0m           \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \          Found:    Option[Long]\n\e[31m   |\e[0m                          Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppxj1jaf0.scala:17:87\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        (numbers.head max numbers.tail.headOption,\
    \ numbers.tail.headOption min numbers.head)\n\e[31m\e[31m   |\e[0m           \
    \                                                                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Found:   \
    \ Long\n\e[31m   |\e[0m                                                Required:\
    \ Ordering[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val list = lst filterNot (_\
    \ < 0) filterNot (_ > 0)\n        var smallest = None\n        var largest = None\n\
    \        for (i <- list toSeq) {\n            if (smallest == None || i > smallest)\
    \ {\n                smallest = i\n            }\n            if (largest == None\
    \ || i < largest) {\n                largest = i\n            }\n        }\n \
    \       (smallest, largest)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnkmloqjv.scala:19:28 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m (i <- list toSeq) {\n\e[31m\e\
    [31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m             \
    \               expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028905
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val nums = lst.filterNot(_\
    \ < 0l).sortWith(_ < _)\n        if (nums.isEmpty)\n            (None, None)\n\
    \        else\n            (nums.headOption, nums.lastOption)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp__yfp28h.scala:23)\n\tat Problem.main(tmp__yfp28h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val nums = lst.foldLeft[List[Long]](List[Long]()){\n\
    \            case (acc, x) => acc :+ x\n        }\n        val isNegative = nums.exists(_\
    \ < 0)\n        val isPositive = nums.exists(_ > 0)\n\n        if(isNegative &&\
    \ isPositive) return (Some(BigInt(nums.sortBy(_.toInt).last.toLong)), Some(BigInt(nums.sortBy(_.toInt).head.toLong)))\n\
    \        if(isPositive) return (Some(BigInt(nums.sortBy(_.toInt).head.toLong)),\
    \ None)\n        if(isNegative) return (None, Some(BigInt(nums.sortBy(_.toInt).last.toLong)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg0uj9ujh.scala:22:56\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m(isNegative\
    \ && isPositive) \e[33mreturn\e[0m (Some(BigInt(nums.sortBy(_.toInt).last.toLong)),\
    \ Some(BigInt(nums.sortBy(_.toInt).head.toLong)))\n\e[31m\e[31m   |\e[0m     \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   BigInt\n\e[31m   |\e[0m                                                  Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg0uj9ujh.scala:22:104\
    \ -------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m(isNegative\
    \ && isPositive) \e[33mreturn\e[0m (Some(BigInt(nums.sortBy(_.toInt).last.toLong)),\
    \ Some(BigInt(nums.sortBy(_.toInt).head.toLong)))\n\e[31m\e[31m   |\e[0m     \
    \                                                                            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    BigInt\n\e\
    [31m   |\e[0m                                                        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg0uj9ujh.scala:23:42\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m(isPositive)\
    \ \e[33mreturn\e[0m (Some(BigInt(nums.sortBy(_.toInt).head.toLong)), None)\n\e\
    [31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    BigInt\n\e[31m\
    \   |\e[0m                                    Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg0uj9ujh.scala:24:48 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m(isNegative) \e[33mreturn\e[0m (None,\
    \ Some(BigInt(nums.sortBy(_.toI"
  stdout: ''
  timestamp: 1660028911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) \n      \
    \      Tuple2(None, None)\n        else {\n            var a = None\n        \
    \    var b = None\n            lst.foreach{ x => \n                val y = math.min(-x,\
    \ x)\n                val z = math.max(-x, x)\n                if (a eq None ||\
    \ a eq None)\n                    a = new Some(y)\n                else\n    \
    \                a = if (y > b) new Some(y) else a\n                b = if (z\
    \ < a) new Some(z) else b\n            }\n            Tuple2(a, b)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb1184f5o.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m (a eq None || a eq None)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       value || is not a member of object None\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpb1184f5o.scala:25:24 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    a = \e[33mnew\e[0m \e[35mSome\e[0m(y)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Found:    Some[Long]\n\e[31m   |\e[0m               \
    \         Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpb1184f5o.scala:27:30 -----------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    a = \e[33mif\e[0m (y > b) \e[33mnew\e[0m \e[35mSome\e\
    [0m(y) \e[33melse\e[0m a\n\e[31m\e[31m   |\e[0m                            ^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long):\
    \ Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\
    \e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m\
    \   |\e[0mmatch arguments ((b : None.type))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb1184f5o.scala:27:35 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    a = \e[33mif\e[0m (y > b) \e[33mnew\e[0m \e[35mSome\e\
    [0m(y) \e[33melse\e[0m a\n\e[31m\e[31m   |\e[0m                              \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    Some[Long]\n\e[31m   |\e[0m                                   Required: None.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpb1184f5o.scala:28:26 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                b = \e[33mif\e[0m (z < a) \e[33mnew\e\
    [0m \e[3"
  stdout: ''
  timestamp: 1660028910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val result = for (i <- 0 until\
    \ lst.size) yield {\n            if (lst(i) < 0l) {\n                Some(lst(i))\n\
    \            } else if (lst(i) > 0l) {\n                Some(lst(i))\n       \
    \     } else {\n                None\n            }\n        }\n\n        val\
    \ small = lst.sortWith((a, b) => a.compareTo(b) <= 0)\n        val large = lst.sortWith((a,\
    \ b) => a.compareTo(b) >= 0)\n\n        // If no negative or positive numbers\
    \ are found, return as None.\n        if (result.isEmpty || small.isEmpty || large.isEmpty)\
    \ {\n            val Nones = for {\n                smalle <- small\n        \
    \        larg <- large\n            } yield None\n            val SomeNones =\
    \ for {\n                small <- small\n                larg <- large\n     \
    \       } yield Some(None)\n            Some(None.unzip Nones)\n        } else\
    \ {\n            Some(result.unzip(small.unzip(large)))\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3p94v1xd.scala:39:33 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            Some(None.unzip Nones)\n\e[31m\e[31m   |\e\
    [0m                                 ^\e[0m\n\e[31m   |\e[0m                  \
    \               expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3p94v1xd.scala:41:42 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            Some(result.unzip(small.unzip(large)))\n\e\
    [31m\e[31m   |\e[0m                                          ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                          Found:    (large : List[Long])\n\
    \e[31m   |\e[0m                                          Required: Long => (Any,\
    \ Any)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0l)\n        val negative = lst.filter(_ < 0l)\n        (positive.sorted.head,\
    \ negative.sorted.head)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfm117axa.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        (positive.sorted.head,\
    \ negative.sorted.head)\n\e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Found:    Long\n\e[31m   |\e[0m         Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfm117axa.scala:18:47\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        (positive.sorted.head,\
    \ negative.sorted.head)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    Long\n\e[31m   |\e\
    [0m                               Required: Option[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // If there is no list, return\
    \ None\n        if(lst.isEmpty) {\n            return (None, None)\n        }\n\
    \        // Keep track of the largest and smallest values in an Array\n      \
    \  var largest = lst.head\n        var smallest = lst.head\n        // Iterate\
    \ through the list and keep track of the largest and smallest values seen\n  \
    \      lst.tail.foreach(x => {\n            if(x < smallest) {\n             \
    \   smallest = x\n            }\n            if(x > largest) {\n             \
    \   largest = x\n            }\n        })\n        // Return the tuple\n    \
    \    return (Some(largest), Some(smallest))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp182sq9yn.scala:36)\n\tat Problem.main(tmp182sq9yn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val lstSorted  = lst.sortWith(_\
    \ < _) // sort by descending order\n        val minPossible = lstSorted.takeWhile(_\
    \ < 0) // take negative integers\n        val maxPossible = lstSorted.takeWhile(_\
    \ >= 0) // take positive integers\n        \n        (minPossible, maxPossible)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcbylns19.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (minPossible, maxPossible)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (minPossible : List[Long])\n\e[31m   |\e[0m         Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcbylns19.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (minPossible, maxPossible)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (maxPossible : List[Long])\n\e[31m   |\e[0m  \
    \                    Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.forall(_.isPositive))\
    \ \n            return (Some(lst.max), Some(lst.min)) \n        else if (lst.forall(_.isNegative))\
    \ \n            return (None, Some(lst.min)) \n        else \n            return\
    \ (None, None)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnvnxaybo.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (lst.forall(_.isPositive)) \n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                      value isPositive is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnvnxaybo.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (lst.forall(_.isNegative))\
    \ \n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            value isNegative is not a member of Long\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Create local variables\
    \ to hold the largest and smallest values.\n        var largest = None\n     \
    \   var smallest = None\n        // Iterate through the list.\n        lst.foreach{\
    \ elem =>\n            // If the value is negative, set the largest to that value\
    \ and\n            // keep track of the smallest value.\n            if (elem\
    \ < 0){\n                largest = Some(elem)\n                smallest = elem\n\
    \            }\n            // If the value is positive, set the smallest value\
    \ to that\n            // value and keep track of the largest value.\n       \
    \     else{\n                smallest = Some(elem)\n                largest =\
    \ elem\n            }\n        }\n        // Return the largest and smallest values.\n\
    \        return (largest, smallest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpenkfjca3.scala:24:30\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                largest = Some(elem)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Found:    Some[Long]\n\e[31m   |\e[0m             \
    \             Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpenkfjca3.scala:25:27 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                smallest = elem\n\e[31m\e[31m   |\e[0m               \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                           Found:    (elem\
    \ : Long)\n\e[31m   |\e[0m                           Required: None.type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpenkfjca3.scala:30:31 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                smallest = Some(elem)\n\e[31m\e[31m \
    \  |\e[0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                  Found:    Some[Long]\n\e[31m   |\e[0m                     \
    \      Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpenkfjca3.scala:31:26 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                largest = elem\n\e[31m\e[31m   |\e[0m                \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                          Found:    (elem\
    \ : Long)\n\e[31m   |\e[0m                          Required: None.type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var minIn = -1\n        var\
    \ maxIn = 0\n        var minOut = None\n        var maxOut = None\n        for\
    \ (i <- lst) {\n            if (i < minIn) minIn = i\n            if (i > maxIn)\
    \ maxIn = i\n        }\n        for (j <- lst) {\n            if (j < minOut)\
    \ minOut = j\n            if (j > maxOut) maxOut = j\n        }\n        if (minIn\
    \ != maxIn) {\n            (minOut, maxOut)\n        } else {\n            (None,\
    \ None)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppt58zyhr.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (i\
    \ < minIn) minIn = i\n\e[31m\e[31m   |\e[0m                                  \
    \ ^\e[0m\n\e[31m   |\e[0m                                   Found:    (i : Long)\n\
    \e[31m   |\e[0m                                   Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppt58zyhr.scala:22:35 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (i > maxIn) maxIn = i\n\e[31m\e\
    [31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m      \
    \                             Found:    (i : Long)\n\e[31m   |\e[0m          \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmppt58zyhr.scala:25:18 -----------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (j < minOut) minOut = j\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e\
    [31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m  \
    \ |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((minOut : None.type))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppt58zyhr.scala:25:37 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (j < minOut) minOut = j\n\e\
    [31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    (j : Long)\n\e[31m   |\e[0m  \
    \                                   Required: None.type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmppt58zyhr.scala:26:18 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    "
  stdout: ''
  timestamp: 1660028912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(acc : List[Long],\
    \ elem : Long) : Option[Long] = {\n            if (acc contains elem) Option(acc)\n\
    \            else {\n                val newAcc = acc ::: List(elem);\n      \
    \          val newAcc = newAcc.sorted // sort and get the first element\n    \
    \            val maxEle = newAcc.head\n                if (maxEle < 0) None else\
    \ Some(maxEle)\n            }\n        }\n\n        def smallest(acc : List[Long],\
    \ elem : Long) : Option[Long] = {\n            if (acc contains elem) Option(acc)\n\
    \            else {\n                val newAcc = acc ::: List(elem);\n      \
    \          val newAcc = newAcc.sorted // sort and get the first element\n    \
    \            val minEle = newAcc.last\n                if (minEle > 0) None else\
    \ Some(minEle)\n            }\n        }\n        largest(lst.toSeq.filter(_.isNegative),\
    \ lst.min) match {\n            case Some(optLargest) =>\n                smallest(lst.toSeq.filter(_.isPositive),\
    \ lst.max) match {\n                    case Some(optSmallest) => Some(optLargest,\
    \ optSmallest)\n                    case _ => None\n                }\n      \
    \      case _ => None\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjlrudhg5.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (acc\
    \ contains elem) Option(acc)\n\e[31m\e[31m   |\e[0m                          \
    \                ^^^\e[0m\n\e[31m   |\e[0m                                   \
    \       Found:    (acc : List[Long])\n\e[31m   |\e[0m                        \
    \                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjlrudhg5.scala:20:20 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                \e[33mval\e[0m \e[36mnewAcc\e[0m = newAcc.sorted \e[34m//\
    \ sort and get the first element\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewAcc is already defined as \e[33mvalue\e[0m \e[35mnewAcc\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjlrudhg5.scala:27:42 --------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m            \e[33mif\e[0m (acc contains elem) Option(acc)\n\e[31m\e\
    [31m   |\e[0m                                          ^^^\e[0m\n\e[31m   |\e\
    [0m                                          Found:    (acc : List[Long])\n\e\
    [31m   |\e[0m                                          Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjlrudhg5.scala:30:20 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mval\e[0m \e[36mnewAcc\e[0m = newAcc.sorted\
    \ \e[34m// sort and get the first element\e[0m\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewAcc is already defined\
    \ as \e[33mvalue\e[0m \e[35mnewAcc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjlrudhg5.scala:35:35 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        largest(lst.toSeq.filter(_.i"
  stdout: ''
  timestamp: 1660028915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(elem\
    \ => elem > 0)\n        val negative = lst.filter(elem => elem < 0)\n        if\
    \ (positive.isEmpty && negative.isEmpty)\n            return (None, None)\n  \
    \      else if (positive.isEmpty || negative.isEmpty)\n            return (Some(negative.head),\
    \ Some(positive.head))\n        else if (positive.head < negative.head)\n    \
    \        return (Some(negative.head), Some(positive.head))\n        else\n   \
    \         return (Some(positive.head), Some(negative.head))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.largestSmallestIntegers(tmpa7z046xf.scala:21)\n\
    \tat Problem$.main(tmpa7z046xf.scala:28)\n\tat Problem.main(tmpa7z046xf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        (if(negatives.isEmpty)\
    \ None else Some(negatives.min), if(positives.isEmpty) None else Some(positives.max))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplc7dmpgx.scala:21)\n\tat Problem.main(tmplc7dmpgx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(_\
    \ < 0)\n        val posInts = lst.filter(_ > 0)\n        if (negInts.isEmpty)\
    \ {\n            return ((None, None))\n        }\n        if (posInts.isEmpty)\
    \ {\n            return ((None, negInts.head))\n        }\n        // Find the\
    \ largest of negative integers, and smallest of positive integers\n        val\
    \ minPosInt = posInts.min\n        val maxNegInt = negInts.max\n        // If\
    \ none of them are negative or positive, return None\n        if (minPosInt ==\
    \ 0l && maxNegInt == 0l) {\n            return ((None, None))\n        }\n   \
    \     // Otherwise, return the smallest and largest integers as tuple\n      \
    \  val smallestInt = minPosInt\n        val largestInt = maxNegInt\n        return\
    \ ((Some(smallestInt), Some(largestInt)))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfkm0ugc8.scala:22:35\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mreturn\e[0m\
    \ ((None, negInts.head))\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    Long\n\e[31m   |\e[0m\
    \                           Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.sortWith(_.isLess(_)).lastOption\n\
    \                .map(i => if (i < 0) Some(i.toLong) else None) match {\n    \
    \            case Some(a) => a.minOption\n                case None => None\n\
    \            }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3k6x59bn.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.sortWith(_.isLess(_)).lastOption\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \        value isLess is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3k6x59bn.scala:18:32 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m                \e[33mcase\e[0m Some(a) => a.minOption\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                             Found:    Option[Long]\n\e[31m   |\e[0m        \
    \                        Required: \e[1m\e[32m(\e[0mOption[Long\e[1m\e[32m]\e\
    [0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0m\e[1m\e[32mOption\e[0m\e[1m\e[32m[\e[0m\e\
    [1m\e[32mLong\e[0m]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3k6x59bn.scala:19:29 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m None => None\n\e[31m\e[31m\
    \   |\e[0m                             ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                 Found:    None.type\n\e[31m   |\e[0m                       \
    \      Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val mn = lst.foldLeft(Long.MinValue,\
    \ Long.MaxValue)(\n            (max, elem) => if (max < elem) max else elem\n\
    \        )\n        val mx = lst.foldRight(Long.MinValue, Long.MaxValue)(\n  \
    \          (min, elem) => if (min > elem) min else elem\n        )\n        Some(mx),\
    \ Some(mn)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp87dqychd.scala:22:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        Some(mx), Some(mn)\n\e[31m\e[31m   |\e[0m   \
    \             ^\e[0m\n\e[31m   |\e[0m                end of statement expected\
    \ but ',' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp87dqychd.scala:17:35\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            (\e[36mmax\e\
    [0m, \e[36melem\e[0m) => \e[33mif\e[0m (max < elem) max \e[33melse\e[0m elem\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of (Long, Long), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp87dqychd.scala:17:52 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            (\e[36mmax\e[0m, \e[36melem\e[0m) => \e[33mif\e\
    [0m (max < elem) max \e[33melse\e[0m elem\n\e[31m\e[31m   |\e[0m             \
    \                                       ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                                      Found:    (\e[1m\e[31melem\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31m:\e[0m Long)\n\e[31m   |\e[0m                           \
    \                      Required: (\e[1m\e[32mLong\e[0m\e[1m\e[32m,\e[0m Long)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp87dqychd.scala:20:35 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            (\e[36mmin\e[0m, \e[36melem\e[0m) => \e[33mif\e\
    [0m (min > elem) min \e[33melse\e[0m elem\n\e[31m\e[31m   |\e[0m             \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e\
    [31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m  \
    \ |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0"
  stdout: ''
  timestamp: 1660028920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      require(!lst.isEmpty)\n    \
    \  val (minPositive, maxNegative) =\n        if(lst.isEmpty) \n            (None,\
    \ None)\n        else {\n          val minNegative = lst.headOption.getOrElse(-1L).filter(_\
    \ < 0l)\n          val maxPositive = lst.lastOption.getOrElse(1L).filter(_ > 0l)\n\
    \          (Some(minNegative), Some(maxPositive))\n        }\n      (minPositive,\
    \ maxNegative)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6xw0ott0.scala:21:58 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m          \e[33mval\e[0m \e[36mminNegative\e[0m = lst.headOption.getOrElse(-\e\
    [31m1L\e[0m).filter(_ < \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value filter is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6xw0ott0.scala:22:57 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m          \e[33mval\e[0m \e[36mmaxPositive\e[0m = lst.lastOption.getOrElse(\e\
    [31m1L\e[0m).filter(_ > \e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                     value filter is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660028921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largestSmallestIntegers_(l\
    \ : List[Long], acc: mutable.Set[Long], current: Long, currentSum: Long): Tuple2[Option[Long],\
    \ Option[Long]] = {\n            val currentMax = current + currentSum\n     \
    \       if(l.isEmpty){\n                if (acc.size > 0) {\n                \
    \    acc.remove(currentMax)\n                    (Some(Some(currentMax)), None)\n\
    \                } else {\n                    (Some(None), Some(currentMax))\n\
    \                }\n            } else if (currentSum < 0l){\n               \
    \ if (acc.size > 0) {\n                    acc.remove(currentMax)\n          \
    \          (Some(Some(currentMax)), Some(current))\n                } else {\n\
    \                    (Some(None), Some(current))\n                }\n        \
    \    } else if (currentSum > 0l){\n                val currentMin = current -\
    \ currentSum\n                if(l.contains(currentMin)){\n                  \
    \  val currentSum = currentSum + currentMin\n                    largestSmallestIntegers_(l\
    \ - currentMin, acc, currentMin, currentSum)\n                } else {\n     \
    \               if (acc.size > 0) {\n                        acc.remove(currentMax)\n\
    \                        (Some(Some(currentMax)), Some(current))\n           \
    \         } else {\n                        (Some(None), Some(current))\n    \
    \                }\n                }\n            } else {\n                val\
    \ currentSum = currentSum + current\n                if (acc.contains(currentSum))\
    \ {\n                    val currentMin = current - currentSum\n             \
    \       if (l.contains(currentMin)) {\n                        largestSmallestIntegers_(l\
    \ - currentMin, acc, currentMin, currentSum)\n                    } else {\n \
    \                       val currentMax = current + currentSum\n              \
    \          if (acc.contains(currentMax)) {\n                            (Some(Some(currentMax)),\
    \ Some(current))\n                        } else {\n                         \
    \   (Some(None), Some(current))\n                        }\n                 \
    \   }\n                } else {\n                    if (acc.size > 0) {\n   \
    \                     acc.remove(currentMax)\n                        (Some(Some(currentMax)),\
    \ Some(current))\n                    } else {\n                        (Some(None),\
    \ Some(current))\n                    }\n                }\n            }\n  \
    \      }\n        val acc = mutable.Set.empty[Long]\n        largestSmallestIntegers_(lst,\
    \ acc, 0l, 0l)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj6q88pav.scala:16:58 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mdef\e[0m \e[36mlargestSmallestIntegers_\e\
    [0m(\e[36ml\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36macc\e[0m: mutable.Set[\e\
    [35mLong\e[0m], \e[36mcurrent\e[0m: \e[35mLong\e[0m, \e[36mcurrentSum\e[0m: \e\
    [35mLong\e[0m): \e[35mTuple2\e[0m[\e[35mOption\e[0m[\e[35mLong\e[0m], \e[35mOption\e\
    [0m[\e[35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                             \
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpj6q88pav.scala:21:30 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    (Some(Some(currentMax)), None)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Found:    \e[1m\e[31mSome\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                          Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj6q88pav.scala:23:26 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    (Some(None), Some(currentMax))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                    Found:    None.type\n\e[31m   |\e[0m                    \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj6q88pav.scala:28:30\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    (Some(Some(currentMax)),\
    \ Some(current))\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    \e[1m\e[31mSome\e[0m\e\
    [1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                        \
    \  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E0"
  stdout: ''
  timestamp: 1660028923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      val minNegative = lst.minBy(_.toInt)\n\
    \      val maxPositive = lst.maxBy(_.toInt)\n      (Some(minNegative.toLong),\
    \ Some(maxPositive.toLong))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9orkoaru.scala:21)\n\tat Problem.main(tmp9orkoaru.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty)\n       \
    \     return (None, None)\n        else if (lst.head.isEmpty)\n            return\
    \ (Some(lst.head), None)\n        else {\n            val largest = lst.maxBy(math.abs)\n\
    \            val smallest = lst.minBy(math.abs)\n            if (largest < smallest)\n\
    \                return (None, None)\n            else (Some(largest), Some(smallest))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshrwpucs.scala:18:26 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (lst.head.isEmpty)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                value isEmpty is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660028921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val (smallest, largest) =\
    \ (None, None)\n        lst.foreach {\n            case x if (x < 0) => smallest\
    \ = None\n            case x if (x > 0) => largest = x\n        }\n        (smallest,\
    \ largest)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp8a4qu57r.scala:18:42 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m (x < \e[31m0\e\
    [0m) => smallest = None\n\e[31m\e[31m   |\e[0m                               \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Reassignment\
    \ to val smallest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8a4qu57r.scala:19:43\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m x\
    \ \e[33mif\e[0m (x > \e[31m0\e[0m) => largest = x\n\e[31m\e[31m   |\e[0m     \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                            Found:    (x : Long)\n\e[31m   |\e[0m           \
    \                                Required: object None\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var max: Option[Long] = None\n\
    \        var min: Option[Long] = None\n        for (i <- 0 until lst.size) {\n\
    \            if (lst(i) < 0)\n            {\n                if (max != None)\n\
    \                {\n                    // Found a larger negative number. Set\
    \ max to new value\n                    max = Some(lst(i))\n                }\n\
    \            }\n            else if (lst(i) > 0)\n            {\n            \
    \    if (min != None)\n                {\n                    // Found a larger\
    \ positive number. Set min to new value\n                    min = Some(lst(i))\n\
    \                }\n            }\n            else\n            {\n         \
    \       // None of them were negative or positive, so ignore it\n            }\n\
    \        }\n        // If none of the numbers are negative, just return None\n\
    \        if (max.isEmpty) None\n        else if (min.isEmpty) Some(None)\n   \
    \     else\n        {\n            // Both min and max are positive values. Return\
    \ them as Tuple2[Long, Long]\n            Some(max.get -> min.get)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppy73pylk.scala:41:25\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mif\e[0m (max.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    None.type\n\e[31m   |\e[0m             \
    \            Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppy73pylk.scala:42:34 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (min.isEmpty) Some(None)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    Some[None.type]\n\e[31m   |\e[0m  \
    \                            Required: (Option[Long], Option[Long])\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppy73pylk.scala:46:16 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            Some(max.get -> min.get)\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Found:    Some[(Long, Long)]\n\e[31m   |\e[0m            Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty)\n       \
    \     (None, Some(None))\n        else\n            val maxVal : Option[Long]\
    \ = lst.maxBy(_.toLong)\n            val minVal : Option[Long] = lst.minBy(_.toLong)\n\
    \            if (maxVal.isDefined && minVal.isDefined)\n                (Some(maxVal.get),\
    \ Some(minVal.get))\n            else\n                (None, None)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwkyco2h.scala:17:24\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            (None, Some(None))\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                  Found:    None.type\n\e[31m   |\e[0m                      \
    \  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwkyco2h.scala:19:40\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e\
    [36mmaxVal\e[0m : \e[35mOption\e[0m[\e[35mLong\e[0m] = lst.maxBy(_.toLong)\n\e\
    [31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Long\n\e\
    [31m   |\e[0m                                        Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwkyco2h.scala:20:40\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e\
    [36mminVal\e[0m : \e[35mOption\e[0m[\e[35mLong\e[0m] = lst.minBy(_.toLong)\n\e\
    [31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Long\n\e\
    [31m   |\e[0m                                        Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) return (None,\
    \ None)\n        def findLargest(x : Long) : Option[Long] = {\n            if\
    \ (x < 0) None\n            else Some(x)\n        }\n        def findSmallest(x\
    \ : Long) : Option[Long] = {\n            if (x > 0) None\n            else Some(x)\n\
    \        }\n        def largestSmallestTuple(lst : List[Long]) : Tuple2[Option[Long],\
    \ Option[Long]] = {\n            val largest = findLargest(lst(0).max)\n     \
    \       val smallest = findSmallest(lst(0).min)\n            if (largest.isDefined\
    \ && smallest.isDefined) ( largest.get, smallest.get)\n            else (None,\
    \ None)\n        }\n        largestSmallestTuple(lst)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6jacsbl8.scala:26:38\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mlargest\e[0m = findLargest(lst(\e[31m0\e[0m).max)\n\e[31m\e[31m   |\e[0m \
    \                                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                               Found:    Long => Long\n\e[31m   |\e[0m      \
    \                                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp6jacsbl8.scala:27:40 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36msmallest\e[0m = findSmallest(lst(\e\
    [31m0\e[0m).min)\n\e[31m\e[31m   |\e[0m                                      \
    \  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        Found:\
    \    Long => Long\n\e[31m   |\e[0m                                        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6jacsbl8.scala:28:67\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (largest.isDefined\
    \ && smallest.isDefined) ( largest.get, smallest.get)\n\e[31m\e[31m   |\e[0m \
    \                                                          ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                  Found:    Long\n\
    \e[31m   |\e[0m                                                  Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6jacsbl8.scala:28:81\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (largest.isDefined\
    \ && smallest.isDefined) ( largest.get, smallest.get)\n\e[31m\e[31m   |\e[0m \
    \                                                                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Long\n\e[31m   |\e[0m                                                  Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer"
  stdout: ''
  timestamp: 1660028924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val mn = lst.minBy(math.abs)\n\
    \        val mx = lst.maxBy(math.abs)\n        if (mn == mx) Some(mn) else None\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp__z4z32u.scala:18:26\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (mn ==\
    \ mx) Some(mn) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:    Some[Long]\n\
    \e[31m   |\e[0m                      Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp__z4z32u.scala:18:36\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (mn ==\
    \ mx) Some(mn) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \ Found:    None.type\n\e[31m   |\e[0m                                  Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largestSmallestIntegersHelper(lst1\
    \ : List[Long], lst2 : List[Long]) : List[Long] = {\n            lst1 match {\n\
    \                case Nil => lst2\n                case h::t => if (h > 0 && h\
    \ < lst2.get) largestSmallestIntegersHelper(t, lst2 :+ h)\n                  \
    \         else if (h < 0 && h < lst2.get) largestSmallestIntegersHelper(t, lst2\
    \ :- h)\n                           else largestSmallestIntegersHelper(t, lst2\
    \ :+ h)\n            }\n        }\n        largestSmallestIntegersHelper(lst,\
    \ Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2_d55sh8.scala:19:51 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m h::t => \e[33mif\e[0m\
    \ (h > \e[31m0\e[0m && h < lst2.get) largestSmallestIntegersHelper(t, lst2 :+\
    \ h)\n\e[31m\e[31m   |\e[0m                                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value get is not a member of List[Long] - did you\
    \ mean lst2.seq?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2_d55sh8.scala:20:54\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                        \
    \   \e[33melse\e[0m \e[33mif\e[0m (h < \e[31m0\e[0m && h < lst2.get) largestSmallestIntegersHelper(t,\
    \ lst2 :- h)\n\e[31m\e[31m   |\e[0m                                          \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2_d55sh8.scala:20:97\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                        \
    \   \e[33melse\e[0m \e[33mif\e[0m (h < \e[31m0\e[0m && h < lst2.get) largestSmallestIntegersHelper(t,\
    \ lst2 :- h)\n\e[31m\e[31m   |\e[0m                                          \
    \                                                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m          value :- is not a member of List[Long] - did you mean lst2.:+?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2_d55sh8.scala:24:37 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        largestSmallestIntegersHelper(lst, Nil)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    List[Long]\n\e[31m   |\e[0m        Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0)\n        val positives = lst.filter(x => x >= 0)\n        val a =\
    \ negatives.max\n        val b = positives.min\n        if (a.exists(x => x ==\
    \ 0)) (a,b) else\n            (a, b)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk9u6snj4.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (a.exists(\e[36mx\e[0m => x ==\
    \ \e[31m0\e[0m)) (a,b) \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value exists is not a member of Long\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpk9u6snj4.scala:20:36 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (a.exists(\e[36mx\e[0m => x ==\
    \ \e[31m0\e[0m)) (a,b) \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m                \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \   Found:    (a : Long)\n\e[31m   |\e[0m                                    Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9u6snj4.scala:20:38\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (a.exists(\e\
    [36mx\e[0m => x == \e[31m0\e[0m)) (a,b) \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                       Found:    (b : Long)\n\e[31m   |\e[0m                \
    \                      Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk9u6snj4.scala:21:13 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            (a, b)\n\e[31m\e[31m   |\e[0m           \
    \  ^\e[0m\n\e[31m   |\e[0m             Found:    (a : Long)\n\e[31m   |\e[0m \
    \            Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpk9u6snj4.scala:21:16 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (a, b)\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                Found:    (b : Long)\n\e[31m   |\e[0m              \
    \  Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660028924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var negInts = false\n    \
    \    var posInts = false\n        var maxPosInt: Option[Long] = None\n       \
    \ var minNegInt: Option[Long] = None\n        var maxNegInt: Option[Long] = None\n\
    \        for(a <- lst) {\n            if(a.toInt == 0) {\n                if(maxNegInt\
    \ == None) maxNegInt = Some(-a)\n                if(minNegInt == None) minNegInt\
    \ = Some(-a)\n                continue\n            }\n            if(-a.toInt\
    \ > 0) negInts = true\n            else posInts = true\n            if(a.toInt\
    \ == maxPosInt) maxPosInt = Some(a.toInt)\n            if(a.toInt == minNegInt)\
    \ minNegInt = Some(a.toInt)\n        }\n        val maxPosIntOpt = maxPosInt.toOption\n\
    \        val minNegIntOpt = minNegInt.toOption\n        if(negInts && !posInts)\
    \ maxPosIntOpt -> Some(-1l)\n        else if(!negInts && posInts) minNegIntOpt\
    \ -> Some(1l)\n        else (maxPosIntOpt.toOption, minNegIntOpt.toOption)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1eo2ix08.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp1eo2ix08.scala:29:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m(a.toInt == maxPosInt) maxPosInt\
    \ = Some(a.toInt)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Values of types Int and Option[Long] cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp1eo2ix08.scala:30:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(a.toInt == minNegInt) minNegInt\
    \ = Some(a.toInt)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Values of types Int and Option[Long] cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1eo2ix08.scala:32:37\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxPosIntOpt\e[0m = maxPosInt.toOption\n\e[31m\e[31m   |\e[0m            \
    \               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     value toOption is not a member of Option[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp1eo2ix08.scala:33:37 ------------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m        \e[33mval\e[0m \e[36mminNegIntOpt\e[0m = minNegInt.toOption\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value toOption is not a member of Option[Long]\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660028925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(lst : List[Long])\
    \ = {\n            if (lst.isEmpty) None\n            else {\n               \
    \ val max = lst.max\n                val min = lst.min\n                if (max\
    \ < min) None\n                else Some(max)\n            }\n        }\n\n  \
    \      def smallest(lst : List[Long]) = {\n            if (lst.isEmpty) None\n\
    \            else {\n                val max = lst.max\n                val min\
    \ = lst.min\n                if (max > min) None\n                else Some(min)\n\
    \            }\n        }\n\n        lst.map(x => if (x % 2 == 0) {\n        \
    \    if (x < 0) smallest(lst.filter(_ > x))\n            else largest(lst.filter(_\
    \ < x))\n        }\n        else largest(lst.filter(_ > x)))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpea816wzo.scala:36:15\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        lst.map(\e[36mx\e[0m\
    \ => \e[33mif\e[0m (x % \e[31m2\e[0m == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \        ^\e[0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mList\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m        Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e\
    [0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e\
    [1m\e[32m)\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (x < \e[31m0\e[0m) smallest(lst.filter(_\
    \ > x))\n\e[31m38 |\e[0m            \e[33melse\e[0m largest(lst.filter(_ < x))\n\
    \e[31m39 |\e[0m        }\n\e[31m40 |\e[0m        \e[33melse\e[0m largest(lst.filter(_\
    \ > x)))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.sortWith(_ < _)\n    \
    \    // If there are no negative/positive integers, return them as None.\n   \
    \     if (lst.isEmpty) None else (Some(lst(0).max), Some(lst(0).min))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1jo6yi40.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (lst.isEmpty)\
    \ None \e[33melse\e[0m (Some(lst(\e[31m0\e[0m).max), Some(lst(\e[31m0\e[0m).min))\n\
    \e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    Found:    None.type\n\e[31m   |\e[0m                    \
    \     Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp1jo6yi40.scala:18:41 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (lst.isEmpty) None \e[33melse\e\
    [0m (Some(lst(\e[31m0\e[0m).max), Some(lst(\e[31m0\e[0m).min))\n\e[31m\e[31m \
    \  |\e[0m                                         ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         Found:    Long => Long\n\e[31m   |\e\
    [0m                                         Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1jo6yi40.scala:18:59 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (lst.isEmpty) None \e[33melse\e\
    [0m (Some(lst(\e[31m0\e[0m).max), Some(lst(\e[31m0\e[0m).min))\n\e[31m\e[31m \
    \  |\e[0m                                                           ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Long => Long\n\e[31m   |\e[0m                                            \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028926
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Sort the list and get the\
    \ lowest and highest integer values.\n        val sorted = lst.sortWith(_.compareTo(_)\
    \ < 0)\n        val low = sorted.head\n        val high = sorted.last\n      \
    \  (Some(low), Some(high))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwebbfhjk.scala:23)\n\tat Problem.main(tmpwebbfhjk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val smallest = lst.minBy(_\
    \ < 0l)\n        val largest = lst.maxBy(_ > 0l)\n        (smallest == None, largest\
    \ == None)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp70nji390.scala:18:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        (smallest == None, largest == None)\n\e[31m\e\
    [31m   |\e[0m         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types\
    \ Long and object None cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp70nji390.scala:18:27 -----------------------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        (smallest == None, largest == None)\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values\
    \ of types Long and object None cannot be compared with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660028926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val minNegative = lst.filter(x\
    \ => x < 0).toList\n        val minPositive = lst.filter(x => x >= 0).toList\n\
    \        if (minNegative.isEmpty || minPositive.isEmpty)\n            throw new\
    \ IllegalArgumentException(\"List has no positive and negative numbers\")\n  \
    \      val minValueNegative = minNegative.min\n        val minValuePositive =\
    \ minPositive.min\n        (minValueNegative < minValuePositive) match {\n   \
    \         case true => Some(minValueNegative), Some(minValuePositive)\n      \
    \      case false => None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpfin7hila.scala:23:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e[31mtrue\e[0m => Some(minValueNegative),\
    \ Some(minValuePositive)\n\e[31m\e[31m   |\e[0m                              \
    \                 ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but ',' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpfin7hila.scala:24:26 --------------------\e[0m\e[0m\n\e[31m24 |\e[0m\
    \            \e[33mcase\e[0m \e[31mfalse\e[0m => None\n\e[31m\e[31m   |\e[0m \
    \                         ^^^^\e[0m\n\e[31m   |\e[0m                         \
    \ Found:    None.type\n\e[31m   |\e[0m                          Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val sortedList = lst.sortBy(\
    \ l => -l )\n        val smallestNegative = sortedList.dropWhile( l => l < 0l\
    \ ).head\n        val smallestPositive = sortedList.takeWhile( l => l > 0l ).head\n\
    \        val largestNegative = sortedList.last\n        (smallestNegative, smallestPositive)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxzxx4unj.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (smallestNegative, smallestPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (smallestNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxzxx4unj.scala:20:27\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (smallestNegative, smallestPositive)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (smallestPositive : Long)\n\e[31m\
    \   |\e[0m                           Required: Option[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      if (lst.isEmpty) \n        (None,\
    \ None)\n      else if (lst.head < 0) \n        (Some(lst.max), None)\n      else\
    \ if (lst.head > 0)\n        (None, Some(lst.min))\n      else\n        (None,\
    \ None)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4zgxi5x8.scala:26)\n\tat Problem.main(tmp4zgxi5x8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var max = 0\n        var min\
    \ = 0\n        for (i <- lst) {\n            if (i < 0) {\n                if\
    \ (max < i) {\n                    max = i\n                }\n            } else\
    \ {\n                if (min > i) {\n                    min = i\n           \
    \     }\n            }\n        }\n        (Some(max), Some(min))\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplvkrwa_.scala:21:26\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    max = i\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (i : Long)\n\e[31m   |\e[0m                    \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplvkrwa_.scala:25:26\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    min = i\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (i : Long)\n\e[31m   |\e[0m                    \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val m = lst.minBy(_.toInt)\n\
    \        val n = lst.maxBy(_.toInt)\n        if (m < n) (Nil, Some(m)) else (Some(n),\
    \ Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2yrca23u.scala:18:20\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (m < n)\
    \ (Nil, Some(m)) \e[33melse\e[0m (Some(n), Nil)\n\e[31m\e[31m   |\e[0m       \
    \             ^^^\e[0m\n\e[31m   |\e[0m                    Found:    collection.immutable.Nil.type\n\
    \e[31m   |\e[0m                    Required: Option[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2yrca23u.scala:18:49 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (m < n) (Nil, Some(m)) \e[33melse\e\
    [0m (Some(n), Nil)\n\e[31m\e[31m   |\e[0m                                    \
    \             ^^^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    collection.immutable.Nil.type\n\e[31m   |\e[0m                          \
    \       Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldLeft((None, None)){\n\
    \            case ((maxA, maxB), item) =>\n                (if (item < 0l) item\
    \ :: maxA :: maxB\n                else if (item > 0l) maxB :: item :: maxA\n\
    \                else maxA :: maxB :: item)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpun_iovbc.scala:18:45 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                (\e[33mif\e[0m (item < \e[31m0l\e[0m)\
    \ item :: maxA :: maxB\n\e[31m\e[31m   |\e[0m                                \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 value\
    \ :: is not a member of object None\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpun_iovbc.scala:19:49\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (item > \e[31m0l\e[0m) maxB :: item :: maxA\n\e[31m\e[31m  \
    \ |\e[0m                                                 ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 value :: is not a member of object\
    \ None\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpun_iovbc.scala:20:34 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33melse\e[0m maxA :: maxB :: item)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                  value :: is not a member of Long\n3\
    \ errors found\n"
  stdout: ''
  timestamp: 1660028930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Create a set that stores\
    \ the negative integers\n        val negative = mutable.HashSet[Long]()\n    \
    \    // Create a set that stores the positive integers\n        val positive =\
    \ mutable.HashSet[Long]()\n        // Create a tuple to store the largest and\
    \ smallest numbers\n        val tuple = scala.util.Success(None, None)\n     \
    \   // Go through the list lst, store the negative and positive integers\n   \
    \     // and calculate the largest and smallest numbers in the list\n        for\
    \ (i <- 0 until lst.size) {\n            val integer = lst(i)\n            //\
    \ If the integer is negative, add it to negative\n            if (integer < 0L)\
    \ {\n                negative += integer\n            }\n            // If the\
    \ integer is positive, add it to positive\n            else {\n              \
    \  positive += integer\n            }\n        }\n        // If there are no negative\
    \ and positive integers, return None\n        if (negative.isEmpty && positive.isEmpty)\
    \ {\n            return tuple\n        }\n        // If there are no negative\
    \ integers, return (Some(None), None)\n        if (negative.isEmpty) {\n     \
    \       return scala.util.Success(None, tuple.product)\n        }\n        //\
    \ If there are no positive integers, return (Some(None), None)\n        if (positive.isEmpty)\
    \ {\n            return scala.util.Success(Some(None), tuple.product)\n      \
    \  }\n        // Calculate the largest\n        val largest = negative.foldLeft(positive.max)((a,\
    \ b) => if (a > b) a else b)\n        // Calculate the smallest\n        val smallest\
    \ = positive.foldLeft(negative.min)((a, b) => if (a < b) a else b)\n        //\
    \ Return tuple with the largest and smallest numbers\n        scala.util.Success(Some(largest),\
    \ Some(smallest))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp96p7k1tm.scala:17:23 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnegative\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp96p7k1tm.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mpositive\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp96p7k1tm.scala:37:19 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mreturn\e[0m tuple\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^\e[0m\n\e[31m   |\e[0m          Found:    (tuple :\
    \ scala.util.Success[(None.type, None.type)])\n\e[31m   |\e[0m          Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp96p7k1tm.scala:41:50 ------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m            \e[33mreturn\e[0m scala.util.Success(None, tuple.product)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue product is not a member of scala.util.Success[(None.type, None.type)]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp96p7k1tm.scala:45:56 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mreturn\e[0m scala.util.Success(Some(None),\
    \ tuple.product)\n\e[31m\e[31m   |\e[0m                                      \
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue product is not a member\
    \ of scala.util.Success[(None.type, None.type)]\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp96p7k1tm.scala:52:26 --------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        scala.util.Success(Some(l"
  stdout: ''
  timestamp: 1660028935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val mins = lst.foldLeft((None,\
    \ null))((a, b) => if (a.isEmpty || b.isEmpty || a.get._2 > b.get._2) (a, b) else\
    \ (a, b))\n        val maxs = lst.foldLeft((null, null))((a, b) => if (a.isEmpty\
    \ || b.isEmpty || a.get._2 < b.get._2) (a, b) else (a, b))\n        val smallest\
    \ = lst.foldLeft((null, null))((a, b) => if (a.isEmpty || b.isEmpty) (a, b) else\
    \ (a, b))\n        val largest = lst.foldLeft((null, null))((a, b) => if (a.isEmpty\
    \ || b.isEmpty) (a, b) else (a, b))\n        val minA = mins.get.map(_.get)\n\
    \        val minB = mins.get.map(_.get)\n        val maxA = maxs.get.map(_.get)\n\
    \        val maxB = maxs.get.map(_.get)\n        val minC = smallest.get.map(_.get)\n\
    \        val maxC = largest.get.map(_.get)\n        if ((minA.isEmpty) && (minB.isEmpty)\
    \ && (maxA.isEmpty) && (maxB.isEmpty)) return (None, None)\n        if ((minA.isEmpty)\
    \ && (minB.isEmpty)) return (minC, maxC)\n        if ((maxA.isEmpty) && (maxB.isEmpty))\
    \ return (maxC, minC)\n        if ((minA != minB) && (maxA != maxB)) return (None,\
    \ None)\n        if ((minA != minB) && (maxA != maxB) && (minA != minC) && (maxA\
    \ != maxC)) return (None, None)\n        if ((minA != minB) && (maxA != maxB)\
    \ && (minA != minC) && (maxA != maxC)) return (minC, maxC)\n        if ((minA\
    \ != minB) && (maxA != maxB) && (minA != minC) && (maxA != maxC)) return (None,\
    \ None)\n        if ((maxA != maxB) && (maxA != maxC)) return (None, None)\n \
    \       if ((maxA != maxB) && (maxA != maxC) && (maxA != minC) && (maxA != minC))\
    \ return (None, None)\n        if ((maxA != maxB) && (maxA != maxC) && (maxA !=\
    \ minC) && (maxA != minC)) return (None, None)\n        if ((minA != minB) &&\
    \ (minA != minC) && (minA != minC)) return (minA, maxB)\n        if ((maxA !=\
    \ maxB) && (maxA != maxC) && (maxA != minC) && (maxA != minC)) return (maxA, minB)\n\
    \        if ((minA != minB) && (\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7_6lkyzg.scala:38:31 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mif\e[0m ((minA != minB) && (\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_6lkyzg.scala:16:62 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmins\e[0m = lst.foldLeft((None,\
    \ \e[31mnull\e[0m))((\e[36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (a.isEmpty ||\
    \ b.isEmpty || a.get._2 > b.get._2) (a, b) \e[33melse\e[0m (a, b))\n\e[31m\e[31m\
    \   |\e[0m                                                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value isEmpty is not a member of (None.type,\
    \ Null)\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7_6lkyzg.scala:16:108\
    \ -------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmins\e\
    [0m = lst.foldLeft((None, \e[31mnull\e[0m))((\e[36ma\e[0m, \e[36mb\e[0m) => \e\
    [33mif\e[0m (a.isEmpty || b.isEmpty || a.get._2 > b.get._2) (a, b) \e[33melse\e\
    [0m (a, b))\n\e[31m\e[31m   |\e[0m                                           \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                       Found:    \e[1m\e[31m(\e[0m\e\
    [1m\e[31ma\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m(\e\
    [0mNone.type\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mNull\e[0m\e[1m\e[31m)\e\
    [0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                                       Required:\
    \ None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7_6lkyzg.scala:16:111\
    \ -------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmins\e\
    [0m = lst.foldLeft((None, \e[31mnull\e[0m))((\e[36ma\e[0m, \e[36mb\e[0m) => \e\
    [33mif\e[0m (a.isEmpty || b.isEmpty || a.get._2 > b.get._2) (a, b) \e[33melse\e\
    [0m (a, b))\n\e[31m\e[31m   |\e[0m                                          "
  stdout: ''
  timestamp: 1660028938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Write your code here.\n\
    \        if (lst.isEmpty)\n            (None, None)\n        else {\n        \
    \    def largestNegative(arr : List[Long]) : List[Long] = {\n                arr.filter(num\
    \ => num < 0l).sortWith(_.compareTo(0l) < 0)\n            }\n            def largestPositive(arr\
    \ : List[Long]) : List[Long] = {\n                arr.filter(num => num > 0l).sortWith(_.compareTo(0l)\
    \ > 0)\n            }\n            def largestNegativeOrNone(arr : List[Long])\
    \ : Option[List[Long]] = {\n                Option(largestNegative(arr))\n   \
    \         }\n            def largestPositiveOrNone(arr : List[Long]) : Option[List[Long]]\
    \ = {\n                Option(largestPositive(arr))\n            }\n         \
    \   def largestNegativeOrNoneOrEmpty(arr : List[Long]) : Option[(List[Long], Option[List[Long]])]\
    \ = {\n                val a = largestNegativeOrNone(arr)\n                val\
    \ b = largestPositiveOrNone(arr)\n                if (a.isEmpty || b.isEmpty)\n\
    \                    None\n                else {\n                    val c =\
    \ (a.get, b.get)\n                    Some((c, a.orElse(b.orElse(List()))))\n\
    \                }\n            }\n            def smallestPositiveOrNone(arr\
    \ : List[Long]) : Option[List[Long]] = {\n                Option(arr.sortWith(_.compareTo(0l)\
    \ == 0))\n            }\n            def smallestPositiveOrNoneOrEmpty(arr : List[Long])\
    \ : Option[(List[Long], Option[List[Long]])] = {\n                val a = smallestPositiveOrNone(arr)\n\
    \                val b = smallestPositiveOrNone(arr)\n                if (a.isEmpty\
    \ || b.isEmpty)\n                    None\n                else {\n          \
    \          val c = (a.get, b.get)\n                    Some((c, a.orElse(b.orElse(List()))))\n\
    \                }\n            }\n            largestNegativeOrNoneOrEmpty(lst).flatMap\
    \ { case (a, b) => if (a.isEmpty) Some(b) else None}\n                orElse largestPositiveOrNoneOrEmpty(lst).flatMap\
    \ { case (a, b) => if (a.isEmpty) Some(b) else None}\n                orElse smallestPositiveOrNoneOrEmpty(lst).flatMap\
    \ { case (a, b) => if (a.isEmpty) Some(b) else None}\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvfer363t.scala:21:53 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                arr.filter(\e[36mnum\e[0m => num < \e\
    [31m0l\e[0m).sortWith(_.compareTo(\e[31m0l\e[0m) < \e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvfer363t.scala:24:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                arr.filter(\e\
    [36mnum\e[0m => num > \e[31m0l\e[0m).sortWith(_.compareTo(\e[31m0l\e[0m) > \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \          ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \        Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvfer363t.scala:39:26 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                    Some((c, a.orElse(b.orElse(List()))))\n\e[31m\e[31m\
    \   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m                  \
    \        Found:    (c : (List[Long], List[Long]))\n\e[31m   |\e[0m           \
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpvfer363t.scala:39:51 --------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m                    Some((c, a.orElse(b.orElse(List()))))\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                            Found:    List[Nothing]\n\
    \e[31m   |\e[0m                                            Required: Option[List[Long]]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvfer363t.scala:43:36\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                Option(arr.sortWith(_.compareTo(\e\
    [31m0l\e[0m) == \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            "
  stdout: ''
  timestamp: 1660028937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(_\
    \ < 0)\n        val posInts = lst.filter(_ > 0)\n        if (negInts.isEmpty)\
    \ {\n            return ((Some(None), Some(None)), None)\n        } else {\n \
    \           val maxVal = negInts.max\n            val minVal = posInts.min\n \
    \           val maxAbsVal = maxVal abs\n            val minAbsVal = minVal abs\n\
    \            if (maxAbsVal == minAbsVal) {\n                return ((Some(maxVal),\
    \ Some(minVal)), None)\n            } else {\n                return ((Some(maxAbsVal),\
    \ Some(minAbsVal)), None)\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgjp8b8se.scala:23:38 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mmaxAbsVal\e[0m = maxVal\
    \ abs\n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m\
    \   |\e[0m                          expression expected but \e[31mend of statement\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgjp8b8se.scala:24:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e\
    [0m \e[36mminAbsVal\e[0m = minVal abs\n\e[31m\e[31m   |\e[0m                 \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \      expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgjp8b8se.scala:19:20 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mreturn\e[0m ((Some(None), Some(None)),\
    \ None)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Found:    (Some[None.type], Some[None.type])\n\
    \e[31m   |\e[0m                    Required: Option[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgjp8b8se.scala:30:9 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0m         Found:    Unit\n\e[31m   |\e[0m         Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028936
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val largest = lst.maxBy(-_)\n\
    \        val smallest = lst.minBy(+_)\n        if (largest == smallest) {\n  \
    \          (Some(largest), Some(largest))\n        } else {\n            (None,\
    \ None)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2kc8x725.scala:25)\n\tat Problem.main(tmp2kc8x725.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val sortedList = lst.sortWith(_\
    \ > _)\n        val minList = SortedList[Long](sortedList.head)\n        val maxList\
    \ = SortedList[Long](sortedList.last)\n\n        minList match {\n           \
    \ case Empty =>\n                maxList match {\n                    case Empty\
    \ =>\n                        Some(None, None)\n                    case HNil\
    \ => None\n                    case _ =>\n                        None\n     \
    \           }\n            case HNil =>\n                maxList match {\n   \
    \                 case Empty =>\n                        None\n              \
    \      case HNil => None\n                    case _ =>\n                    \
    \    None\n                }\n            case _ =>\n                maxList match\
    \ {\n                    case Empty =>\n                        None\n       \
    \             case HNil =>\n                        None\n                   \
    \ case _ =>\n                        None\n                }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboosv2u2.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminList\e[0m = SortedList[\e\
    [35mLong\e[0m](sortedList.head)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: SortedList\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboosv2u2.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = SortedList[\e\
    [35mLong\e[0m](sortedList.last)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: SortedList\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboosv2u2.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m Empty =>\n\e[31m\e[31m  \
    \ |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0m                 Not found:\
    \ Empty\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboosv2u2.scala:23:25\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    \e[33mcase\e\
    [0m Empty =>\n\e[31m\e[31m   |\e[0m                         ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: Empty\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpboosv2u2.scala:24:28 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        Some(None, None)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Found:    Some[(None.type, None.type)]\n\e[31m   |\e[0m  \
    \                      Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpboosv2u2.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            "
  stdout: ''
  timestamp: 1660028938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(x : Long) : Long\
    \ = if (x < 0) x else 0\n        def smallest(x: Long) : Long = if (x > 0) x else\
    \ 0\n        val sortedList = lst.sorted\n        val a = if (sortedList.head\
    \ < 0) None else Some(sortedList.head)  \n        val b = if (sortedList.last\
    \ > 0) None else Some(sortedList.last)\n        (a, b)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp47qloys7.scala:24)\n\tat Problem.main(tmp47qloys7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var smallestVal = None\n \
    \       var largestVal = None\n        lst.foreach {x => if(x < 0L) smallestVal\
    \ = Some(x); if(x > 0L) largestVal = Some(x)}\n        if(smallestVal.isEmpty\
    \ && largestVal.isEmpty) None\n        else if(smallestVal.isEmpty && largestVal.isDefined)\
    \ None\n        else if(smallestVal.isDefined && largestVal.isEmpty) smallestVal.map(_\
    \ -> 0L)\n        else largestVal.map(_ -> 0L)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9ow_9xp.scala:18:55\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        lst.foreach {\e[36mx\e\
    [0m => \e[33mif\e[0m(x < \e[31m0L\e[0m) smallestVal = Some(x); \e[33mif\e[0m(x\
    \ > \e[31m0L\e[0m) largestVal = Some(x)}\n\e[31m\e[31m   |\e[0m              \
    \                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                         Found:    Some[Long]\n\e[31m   |\e[0m\
    \                                                   Required: None.type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9ow_9xp.scala:18:88 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.foreach {\e[36mx\e[0m => \e[33mif\e[0m(x\
    \ < \e[31m0L\e[0m) smallestVal = Some(x); \e[33mif\e[0m(x > \e[31m0L\e[0m) largestVal\
    \ = Some(x)}\n\e[31m\e[31m   |\e[0m                                          \
    \                                          ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Some[Long]\n\e[31m \
    \  |\e[0m                                                    Required: None.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9ow_9xp.scala:19:54\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m(smallestVal.isEmpty\
    \ && largestVal.isEmpty) None\n\e[31m\e[31m   |\e[0m                         \
    \                             ^^^^\e[0m\n\e[31m   |\e[0m                     \
    \             Found:    None.type\n\e[31m   |\e[0m                           \
    \       Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk9ow_9xp.scala:20:61 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(smallestVal.isEmpty\
    \ && largestVal.isDefined) None\n\e[31m\e[31m   |\e[0m                       \
    \                                      ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                      Foun"
  stdout: ''
  timestamp: 1660028938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val largestNegative = lst.filter(x\
    \ => x < 0l).max\n        val largestPositive = lst.filter(x => x > 0l).min\n\n\
    \        if ( largestNegative == None  &&  largestPositive == None ) return (None,\
    \ None)\n        if ( largestNegative == None ) return (Some(largestPositive),\
    \ None)\n        if ( largestPositive == None ) return (None, Some(largestNegative))\n\
    \n        (Some(largestPositive), Some(largestNegative))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpx65hw5ov.scala:19:13 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m ( largestNegative == None  && \
    \ largestPositive == None ) \e[33mreturn\e[0m (None, None)\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types\
    \ Long and object None cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpx65hw5ov.scala:19:42 -----------------------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mif\e[0m ( largestNegative == None  &&  largestPositive\
    \ == None ) \e[33mreturn\e[0m (None, None)\n\e[31m\e[31m   |\e[0m            \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \  Values of types Long and object None cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpx65hw5ov.scala:20:13 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m ( largestNegative == None ) \e\
    [33mreturn\e[0m (Some(largestPositive), None)\n\e[31m\e[31m   |\e[0m         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types Long and\
    \ object None cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpx65hw5ov.scala:21:13\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ \e[33mif\e[0m ( largestPositive == None ) \e[33mreturn\e[0m (None, Some(largestNegative))\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \   Values of types Long and object None cannot be compared with == or !=\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val maxValue = lst.foldLeft(-math.min(0l,\
    \ math.max(0l, lst.head))) { case (acc, x) =>\n            if (x < acc) {\n  \
    \              (math.min(math.max(0l, lst.head), acc), x)\n            } else\
    \ {\n                (x = acc, x)\n            }\n        }._1\n        val minValue\
    \ = lst.foldLeft(math.max(0l, lst.head)) { case (acc, x) =>\n            if (x\
    \ > acc) {\n                (acc, math.max(0l, lst.head))\n            } else\
    \ {\n                (x = acc, x)\n            }\n        }._1\n        (Some(maxValue),\
    \ Some(minValue))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp973juze0.scala:18:16\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                (math.min(math.max(\e\
    [31m0l\e[0m, lst.head), acc), x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    (Long, Long)\n\e[31m   |\e[0m  \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp973juze0.scala:20:19 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                (x = acc, x)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Reassignment to val x\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp973juze0.scala:25:16 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                (acc, math.max(\e[31m0l\e[0m, lst.head))\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Found:    (Long, Long)\n\e[31m   |\e[0m            \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp973juze0.scala:27:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                (x =\
    \ acc, x)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 Reassignment to val x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var maxVal = lst.max\n   \
    \     var minVal = lst.min\n        val maxIsNegative = lst.forall(_.isNegative)\n\
    \        val minIsNegative = lst.forall(_.isNegative)\n        val maxIsPositive\
    \ = lst.forall(_.isPositive)\n        val minIsPositive = lst.forall(_.isPositive)\n\
    \n        if(maxIsNegative && minIsNegative) return (None, None)\n        if(maxIsPositive\
    \ && minIsPositive) return (None, None)\n        if(maxIsNegative) {\n       \
    \     maxVal = lst.max\n            minVal = lst.min\n        } else if(maxIsPositive)\
    \ {\n            maxVal = lst.max\n            minVal = lst.min\n        } else\
    \ {\n            maxVal = lst.min\n            minVal = lst.max\n        }\n \
    \       // Return the tuple (Some(max), Some(min))\n        return (Some(maxVal),\
    \ Some(minVal))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfgxl5e2x.scala:18:41 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxIsNegative\e[0m = lst.forall(_.isNegative)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                value isNegative is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfgxl5e2x.scala:19:41\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mminIsNegative\e[0m = lst.forall(_.isNegative)\n\e[31m\e[31m   |\e[0m     \
    \                                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                        value isNegative is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpfgxl5e2x.scala:20:41 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxIsPositive\e[0m = lst.forall(_.isPositive)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                value isPositive is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfgxl5e2x.scala:21:41\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mminIsPositive\e[0m = lst.forall(_.isPositive)\n\e[31m\e[31m   |\e[0m     \
    \                                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                        value isPositive is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1660028938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // TODO: Implement your solution\n\
    \        def largestPositiveInner(a: Long, b: Long, lst: List[Long]) : (Option[Long],\
    \ Option[Long]) = {\n            if (a == 0) (b, None)\n            else if ((a\
    \ < 0) && (b > 0)) (b,None) //b < a\n            else (Some(a), Some(b))\n   \
    \     }\n\n        def largestNegativeInner(a: Long, b: Long, lst: List[Long])\
    \ : (Option[Long], Option[Long]) = {\n            if (a == 0) (b, None)\n    \
    \        else if ((a > 0) && (b < 0)) (a, b) //b > a\n            else (Some(a),\
    \ Some(b))\n        }\n\n        def largestPositive(lst: List[Long]) : Option[Long]\
    \ = {\n            val a = lst.min\n            val b = lst.max\n            if\
    \ (a < 0) b\n            else a\n        }\n\n        def largestNegative(lst:\
    \ List[Long]) : Option[Long] = {\n            val a = lst.max\n            val\
    \ b = lst.min\n            if (a > 0) b\n            else a\n        }\n\n   \
    \     val negative = lst.filter(a => a < 0)\n        val positive = lst.filter(a\
    \ => a > 0)\n        val maxPositive = largestPositive(positive)\n        val\
    \ maxNegative = largestNegative(negative)\n        (maxPositive, maxNegative)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj88tw8os.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (a\
    \ == \e[31m0\e[0m) (b, None)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Found:    (b : Long)\n\e[31m   |\e\
    [0m                         Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpj88tw8os.scala:19:42 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m ((a < \e[31m0\e\
    [0m) && (b > \e[31m0\e[0m)) (b,None) \e[34m//b < a\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                               Found:    (b : Long)\n\e[31m   |\e[0m        \
    \                                  Required: Option[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj88tw8os.scala:24:25 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (a == \e[31m0\e[0m) (b, None)\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Found:    (b : Long)\n\e[31m   |\e[0m                      \
    \   Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpj88tw8os.scala:25:42 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33melse\e[0m \e[33mif\e[0m ((a > \e[31m0\e[0m) && (b <\
    \ \e[31m0\e[0m)) (a, b) \e[34m//b > a\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                   Found:    (a : Long)\n\e[31m   |\e[0m                    \
    \                      Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpj88tw8os.scala:25:45 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m ((a > \e[31m0"
  stdout: ''
  timestamp: 1660028940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negativeLongs = lst.filter(_.isNegative)\n\
    \        val positiveLongs = lst.filter(_.isPositive)\n\n        val maxPositiveLong\
    \ = positiveLongs.max\n        val minNegativeLong = negativeLongs.min\n\n   \
    \     val maxNegativeLong = maxPositiveLong.map(_.abs)\n        val minPositiveLong\
    \ = minNegativeLong.map(_.abs)\n\n        (\n            if (minPositiveLong.isEmpty\
    \ && minNegativeLong.isEmpty) None\n            else Some(maxNegativeLong.get),\n\
    \            if (maxPositiveLong.isEmpty && maxNegativeLong.isEmpty) None\n  \
    \          else Some(maxPositiveLong.get)\n        )\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpueyjfmhk.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnegativeLongs\e[0m = lst.filter(_.isNegative)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                value isNegative is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpueyjfmhk.scala:17:41\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mpositiveLongs\e[0m = lst.filter(_.isPositive)\n\e[31m\e[31m   |\e[0m     \
    \                                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                        value isPositive is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpueyjfmhk.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxNegativeLong\e[0m = maxPositiveLong.map(_.abs)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              value map is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpueyjfmhk.scala:23:46 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mminPositiveLong\e[0m = minNegativeLong.map(_.abs)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              value map is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpueyjfmhk.scala:28:32 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (maxPositiveLong.isEmpty &&\
    \ maxNegativeLong.isEmpty) None\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value isEmpty is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpueyjfmhk.scala:29:38 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33melse\e[0m Some(maxPositiveLong.get)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                      value get is not a member of Long\n6 errors found\n"
  stdout: ''
  timestamp: 1660028939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n\n        if (negative.isEmpty)\
    \ None else {\n            val max = negative.maxBy(-_)\n            val min =\
    \ positive.minBy(_)\n\n            Some(Some(max), Some(min))\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd22qnr24.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (negative.isEmpty)\
    \ None \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m                              ^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    None.type\n\e[31m\
    \   |\e[0m                              Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpd22qnr24.scala:21:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = positive.minBy(_)\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m \
    \  |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\e\
    [31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n2 errors found\n"
  stdout: ''
  timestamp: 1660028939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Set default values to None\n\
    \        var a = None\n        var b = None\n        // Iterate over list and\
    \ test if both values are greater than zero\n        for (elem <- lst) {\n   \
    \         if (a != None) a = if (elem < 0) a else elem\n            if (b != None)\
    \ b = if (elem > b) elem else b\n        }\n        // Return result as tuple\n\
    \        (Some(a), Some(b))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgbj5lsyz.scala:21:52\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (a\
    \ != None) a = \e[33mif\e[0m (elem < \e[31m0\e[0m) a \e[33melse\e[0m elem\n\e\
    [31m\e[31m   |\e[0m                                                    ^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  (elem : Long)\n\e[31m   |\e[0m                                            \
    \     Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpgbj5lsyz.scala:22:40 -----------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mif\e[0m (b != None) b = \e[33mif\e[0m (elem > b) elem\
    \ \e[33melse\e[0m b\n\e[31m\e[31m   |\e[0m                                   ^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long):\
    \ Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\
    \e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m\
    \   |\e[0mmatch arguments ((b : None.type))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgbj5lsyz.scala:22:45 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mif\e[0m (b != None) b = \e[33mif\e[0m (elem > b) elem\
    \ \e[33melse\e[0m b\n\e[31m\e[31m   |\e[0m                                   \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \     Found:    (elem : Long)\n\e[31m   |\e[0m                               \
    \              Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgbj5lsyz.scala:25:14 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        (Some(a), Some(b))\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\
    \e[31m   |\e[0m              Found:    (a : None.type)\n\e[31m   |\e[0m      \
    \        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available "
  stdout: ''
  timestamp: 1660028940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // A list can be empty or\
    \ contain no elements.\n        if (lst.size < 2)\n            return (None, None)\n\
    \n        // First, sort the list so that all negative numbers are in front\n\
    \        // and all positive numbers are at the end.\n        val reversedLst\
    \ = lst.sortBy(x => x < 0l).reverse\n        val negativeNumbers = reversedLst.takeWhile(x\
    \ => x < 0l)\n        val positiveNumbers = reversedLst.dropWhile(x => x < 0l).drop(1)\n\
    \        val sortedNumbers = negativeNumbers ++ positiveNumbers\n\n        //\
    \ Now, iterate through the sorted list, and find the first negative\n        //\
    \ integer and the first positive integer.\n        val negativeMin = negativeNumbers.head\n\
    \        val positiveMin = positiveNumbers.head\n\n        // If the first element\
    \ of the list is negative, find the\n        // smallest positive integer.\n \
    \       // If the first element of the list is positive, find the\n        //\
    \ smallest negative integer.\n        if (sortedNumbers.head < 0l)\n         \
    \   return (Some(positiveMin), Some(negativeMin))\n        if (sortedNumbers.head\
    \ > 0l)\n            return (Some(negativeMin), Some(positiveMin))\n        return\
    \ (None, None)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.largestSmallestIntegers(tmpqtvbd5aa.scala:29)\n\
    \tat Problem$.main(tmpqtvbd5aa.scala:43)\n\tat Problem.main(tmpqtvbd5aa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(n\
    \ => n < 0L)\n        val positive = lst.filter(n => n > 0L)\n        negative.max\
    \ match {\n            case None => positive.min\n            case Some(None)\
    \ => None\n            case Some(x) => Some(x)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhaiwl3g.scala:19:17\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m None\
    \ => positive.min\n\e[31m\e[31m   |\e[0m                 ^^^^\e[0m\n\e[31m   |\e\
    [0m                 Found:    None.type\n\e[31m   |\e[0m                 Required:\
    \ Long\n\e[31m   |\e[0m                 pattern type is incompatible with expected\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhaiwl3g.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m None\
    \ => positive.min\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m \
    \                        Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhaiwl3g.scala:20:31 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m Some(None) => None\n\e[31m\e\
    [31m   |\e[0m                               ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                        Found:    None.type\n\e[31m   |\e[0m                \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwhaiwl3g.scala:21:32 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m Some(x) => Some(x)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                     Found:    Some[Any]\n\e[31m   |\e[0m                   \
    \         Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val ints = lst.map(i => (if\
    \ (i < 0l) Some(i) else None)).toList\n        if (ints.isEmpty)\n           \
    \ (None, None)\n        else {\n            val maxI = ints.max\n            val\
    \ minI = ints.min\n            if (maxI == minI)\n                (None, None)\n\
    \            else\n                (Some(maxI), Some(minI))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps0duv4xv.scala:25:22\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                (Some(maxI),\
    \ Some(minI))\n\e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                      Found:    (maxI : Option[Long])\n\e[31m   |\e[0m\
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmps0duv4xv.scala:25:34 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                (Some(maxI), Some(minI))\n\e[31m\e[31m   |\e\
    [0m                                  ^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    (minI : Option[Long])\n\e[31m   |\e[0m        \
    \                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Use fold to find the max\
    \ and min in a single pass\n        // This will be much more efficient than sorting\
    \ and finding the max and min in the loop\n        val max = lst.foldLeft((Option(Long.MaxValue),\
    \ Option(Long.MinValue))) { case ((max,min), e) => (if (e < min) (e, min) else\
    \ (max, e))}._1\n        val min = lst.foldLeft((Option(Long.MaxValue), Option(Long.MinValue)))\
    \ { case ((max,min), e) => (if (e > max) (e, max) else (max, e))}._1\n       \
    \ max match {\n            case None    => (None, None)\n            case Some(x)\
    \ => x match {\n                case None    => (None, None)\n               \
    \ case Some(y) => y match {\n                    case None    => (None, None)\n\
    \                    case Some(z) => (Some(z), Some(z))\n                }\n \
    \           }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4fl769nz.scala:18:111 ----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = lst.foldLeft((Option(Long.MaxValue),\
    \ Option(Long.MinValue))) { \e[33mcase\e[0m ((max,min), e) => (\e[33mif\e[0m (e\
    \ < min) (e, min) \e[33melse\e[0m (max, e))}._1\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                          ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e\
    [31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m  \
    \ |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((min : Option[Long]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fl769nz.scala:18:119 -------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = lst.foldLeft((Option(Long.MaxValue),\
    \ Option(Long.MinValue))) { \e[33mcase\e[0m ((max,min), e) => (\e[33mif\e[0m (e\
    \ < min) (e, min) \e[33melse\e[0m (max, e))}._1\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                                    ^\e[0m\n\e[31m   |\e[0m                 \
    \                                 Found:    (e : Long)\n\e[31m   |\e[0m      \
    \                                            Required: Option[Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fl769nz.scala:18:138 -------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = lst.foldLeft((Option(Long.MaxValue),\
    \ Option(Long.MinValue))) { \e[33mcase\e[0m ((max,min), e) => (\e[33mif\e[0m (e\
    \ < min) (e, min) \e[33melse\e[0m (max, e))}._1\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                    "
  stdout: ''
  timestamp: 1660028943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val lstWithMax = lst.map(x\
    \ => (x, x))\n        val lstWithMin = lst.map(x => (x, -x))\n        val lstWithMaxMin\
    \ = lstWithMax.zip(lstWithMin)\n        val lstWithMaxMinMin = lstWithMaxMin.filter(x\
    \ => x._1 < x._2)\n        val max = lstWithMaxMinMin.map(x => x._1).max\n   \
    \     val min = lstWithMaxMinMin.map(x => x._1).min\n        (Option(max), Option(min))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdna6ak2e.scala:19:62 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlstWithMaxMinMin\e[0m =\
    \ lstWithMaxMin.filter(\e[36mx\e[0m => x._1 < x._2)\n\e[31m\e[31m   |\e[0m   \
    \                                                      ^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue < is not a member of (Long, Long), but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdna6ak2e.scala:22:16 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        (Option(max), Option(min))\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m                Found:    (max : (Long,\
    \ Long))\n\e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdna6ak2e.scala:22:29 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        (Option(max), Option(min))\n\e[31m\e[31m   |\e\
    [0m                             ^^^\e[0m\n\e[31m   |\e[0m                    \
    \         Found:    (min : (Long, Long))\n\e[31m   |\e[0m                    \
    \         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positiveLongs = new mutable.Queue[Long]()\n\
    \        val negativeLongs = new mutable.Queue[Long]()\n\n        var a = lst.head\n\
    \        var b = lst.last\n\n        lst.foreach{\n            value => if (value\
    \ < 0) negativeLongs += value else positiveLongs += value\n        }\n\n     \
    \   if (positiveLongs.isEmpty) (a, b) else None\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn8ppci4r.scala:16:32 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpositiveLongs\e[0m = \e\
    [33mnew\e[0m mutable.Queue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m         \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpn8ppci4r.scala:17:32 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        \e[33mval\e[0m \e[36mnegativeLongs\e[0m = \e[33mnew\e[0m mutable.Queue[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8ppci4r.scala:26:36 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (positiveLongs.isEmpty) (a, b)\
    \ \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                                \
    \    ^\e[0m\n\e[31m   |\e[0m                                    Found:    (a :\
    \ Long)\n\e[31m   |\e[0m                                    Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8ppci4r.scala:26:39\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (positiveLongs.isEmpty)\
    \ (a, b) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                         \
    \              ^\e[0m\n\e[31m   |\e[0m                                       Found:\
    \    (b : Long)\n\e[31m   |\e[0m                                       Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8ppci4r.scala:26:47\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (positiveLongs.isEmpty)\
    \ (a, b) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m                         \
    \                      ^^^^\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1660028943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInt = lst.filter(_<0).length\n\
    \        val posInt = lst.filter(_>=0).length\n        if(negInt==0 && posInt==0)\n\
    \            (None, None)\n        else if(negInt==0)\n            (Some(None),\
    \ Some(None)) // no negative ints, nothing to do\n        else if(posInt==0)\n\
    \            (None, Some(None)) // no positive ints, nothing to do\n        else\n\
    \        {\n            val largest = lst.max // largest is positive if and only\
    \ if the list is sorted\n            val smallest = lst.min // smallest is negative\
    \ if and only if the list is sorted\n            (Some(largest), Some(smallest))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8bz6e41k.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(None))\
    \ \e[34m// no negative ints, nothing to do\e[0m\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\e\
    [31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8bz6e41k.scala:21:30 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(None)) \e[34m// no negative\
    \ ints, nothing to do\e[0m\n\e[31m\e[31m   |\e[0m                            \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                              Found:    None.type\n\
    \e[31m   |\e[0m                              Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8bz6e41k.scala:23:24 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (None, Some(None)) \e[34m// no positive ints,\
    \ nothing to do\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\
    \e[31m   |\e[0m                        Found:    None.type\n\e[31m   |\e[0m  \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028943
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // If there's one positive\
    \ integer in the list, return it as (a, b)\n        if (lst.contains(1l)) (Some(1l),\
    \ None)\n        // Otherwise, if there's one negative integer in the list, return\
    \ it as (b, -a)\n        else if (lst.contains(-1l)) (Some(-1l), Some(1l))\n \
    \       // Otherwise, there's no negative or positive integers, return them as\
    \ None\n        else (None, None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1btpiv81.scala:24)\n\tat Problem.main(tmp1btpiv81.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val minLong = lst.min.orElse(-1l)\n\
    \        val maxLong = lst.max.orElse(0l)\n        (if (minLong < 0l) None else\
    \ Some(minLong), if (maxLong > 0l) None else Some(maxLong))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpixt120yp.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminLong\e[0m = lst.min.orElse(-\e\
    [31m1l\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value orElse is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpixt120yp.scala:17:30 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxLong\e[0m = lst.max.orElse(\e\
    [31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value orElse is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val max: Option[Long] = lst.max\
    \ match{\n            case Some(x) if x < 0l  => Some(xl.toLong)\n           \
    \ case _                  => None\n        }\n        val min: Option[Long] =\
    \ lst.min match{\n            case Some(x) if x > 0l  => Some(xl.toLong)\n   \
    \         case _                  => None\n        }\n        if(max.isEmpty ||\
    \ min.isEmpty)\n            None else\n            ((Some(max), Some(min)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoic1fs0k.scala:17:30 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m Some(x) \e[33mif\e[0m x <\
    \ \e[31m0l\e[0m  => Some(xl.toLong)\n\e[31m\e[31m   |\e[0m                   \
    \         ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of Any, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoic1fs0k.scala:17:44 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m Some(x) \e[33mif\e[0m x <\
    \ \e[31m0l\e[0m  => Some(xl.toLong)\n\e[31m\e[31m   |\e[0m                   \
    \                         ^^\e[0m\n\e[31m   |\e[0m                           \
    \                 Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpoic1fs0k.scala:21:30 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            \e[33mcase\e[0m Some(x) \e[33mif\e[0m x > \e[31m0l\e[0m  => Some(xl.toLong)\n\
    \e[31m\e[31m   |\e[0m                            ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ > is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoic1fs0k.scala:21:44 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m Some(x) \e[33mif\e[0m x >\
    \ \e[31m0l\e[0m  => Some(xl.toLong)\n\e[31m\e[31m   |\e[0m                   \
    \                         ^^\e[0m\n\e[31m   |\e[0m                           \
    \                 Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007"
  stdout: ''
  timestamp: 1660028952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // If there is no list, return\
    \ None as a tuple\n        if(lst.isEmpty) \n            (None, None)\n      \
    \  else {\n            // If there is an even number of elements, return smallest\n\
    \            // and largest as tuple\n            if(lst.size % 2 == 0) \n   \
    \             (Some(lst.min), Some(lst.max))\n            // If there is an odd\
    \ number of elements, return smallest and\n            // largest as None if either\
    \ is None.\n            else if(lst.size % 2 != 0) \n                (Some(lst.min),\
    \ Some(lst.max))\n            // If the number of elements is even, create two\
    \ new lists\n            // one with positive elements and another with negative\
    \ elements\n            else {\n                // Get a mutable list to hold\
    \ negative integers\n                val negInList = lst.filter(_.toInt == -1)\n\
    \                // Get a mutable list to hold positive integers\n           \
    \     val posInList = lst.filter(_.toInt == 1)\n                // Find the minimum\
    \ and maximum from the two lists\n                val smallest = posInList.min\n\
    \                val largest = posInList.max\n                // Return the smallest\
    \ and largest integers\n                (Some(smallest), Some(largest))\n    \
    \        }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq9znnt2o.scala:44)\n\tat Problem.main(tmpq9znnt2o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largestFirst(num : Long,\
    \ acc: List[Long]) : Option[Long] = {\n            if (num <= 0L) {\n        \
    \        Some(num)\n            } else if (num <= acc.last)\n                largestFirst(num\
    \ - acc.last, acc)\n            else\n                largestFirst(num - acc.last,\
    \ acc + List(num))\n        }\n\n        def smallestFirst(num : Long, acc: List[Long])\
    \ : Option[Long] = {\n            if (num > 0L)\n                smallestFirst(num\
    \ - acc.last, acc)\n            else if (acc.nonEmpty)\n                smallestFirst(acc.last,\
    \ acc :+ num)\n            else\n                None\n        }\n\n        def\
    \ largestSmallest(lst : List[Long]) : Option[Long] = {\n            val max =\
    \ lst.foldLeft(0L){ (a, e) =>\n                if (e > a)\n                  \
    \  e\n                else\n                    a\n            }\n\n         \
    \   val min = lst.foldLeft((-1L, 0L))((a, e) =>\n                if (e < a)\n\
    \                    (e, a)\n                else\n                    a\n   \
    \         )\n\n            smallestFirst(max, min._1).getOrElse(max)\n       \
    \ }\n        largestFirst(lst.last, lst.init :+ 0L)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiciqx5tr.scala:22:49 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                largestFirst(num - acc.last, acc + List(num))\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpiciqx5tr.scala:43:22 -----------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                \e[33mif\e[0m (e < a)\n\e[31m\e[31m   |\e\
    [0m                    ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e\
    [31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m  \
    \ |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((a : (Long, Long)))\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiciqx5tr.scala:44:24 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    (e, a)\n\e[31m\e[31m   |\e[0m   \
    \                     ^\e[0m\n\e[31m   |\e[0m                        Found:  \
    \  (a : (Long, Long))\n\e[31m   |\e[0m                        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiciqx5tr.scala:49:35\
    \ --------------------\e[0m\e[0m\n\e[31m49 |\e[0m            smallestFirst(max,\
    \ min._1).getOrElse(max)\n\e[31m\e[31m   |\e[0m                              \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                               Found:    Long\n\e\
    [31m   |\e[0m                               Required: \e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mLong\e[1m\e[3"
  stdout: ''
  timestamp: 1660028953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) \n      \
    \      return (None, None)\n        var largest = lst.head\n        var smallest\
    \ = lst.head\n        for (i <- lst.tail) {\n            if (i < 0) {\n      \
    \          if (largest < 0) largest = i\n            } else {\n              \
    \  if (smallest > 0) smallest = i\n            }\n        }\n        return (Option(largest),\
    \ Option(smallest))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2y00vusi.scala:30)\n\tat Problem.main(tmp2y00vusi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val n = lst.length\n     \
    \   if(n < 2)\n            (None, None)\n        else {\n            val min:\
    \ Option[Long] = None\n            val max: Option[Long] = None\n            val\
    \ minus: Option[Long] = None\n            val plus: Option[Long] = None\n    \
    \        for(i <- 0 until n-1) {\n                if(lst(i) < 0) {\n         \
    \           minus += lst(i)\n                }\n                else {\n     \
    \               plus += lst(i)\n                }\n            }\n           \
    \ if(minus.isEmpty)\n                minus.orNull\n            else {\n      \
    \          val m = (minus.orNull.max) minus.orNull\n                max = minus\
    \ match {\n                    case Some(i) => Some(m.max(i))\n              \
    \      case None => Some(m)\n                }\n            }\n            if(plus.isEmpty)\n\
    \                plus.orNull\n            else {\n                val m = (plus.orNull.min)\
    \ plus.orNull\n                min = plus match {\n                    case Some(i)\
    \ => Some(m.min(i))\n                    case None => Some(m)\n              \
    \  }\n            }\n            (min, max)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfboivpb9.scala:35:48 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m \e[36mm\e[0m = (minus.orNull.max)\
    \ minus.orNull\n\e[31m\e[31m   |\e[0m                                        \
    \        ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfboivpb9.scala:44:46 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m                \e[33mval\e[0m \e[36mm\e[0m = (plus.orNull.min) plus.orNull\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfboivpb9.scala:26:26\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    minus\
    \ += lst(i)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m       value += is not a member of Option[Long] - did you mean minus.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfboivpb9.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    plus += lst(i)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a\
    \ member of Option[Long] - did you mean plus.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpfboivpb9.scala:35:38 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                \e[33mval\e[0m \e[36mm\e[0m = (minus.orNull.max) minus.orNull\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue max is not a member of Matchable, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpfboivpb9.scala:36:20"
  stdout: ''
  timestamp: 1660028952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positiveInts = lst.filter\
    \ { x => x < 0 }\n        val negativeInts = lst.filter { x => x >= 0 }\n    \
    \    negativeInts.min match {\n            case None => (None, None)\n       \
    \     case Some(x) => positiveInts.max match {\n                case None => (None,\
    \ None)\n                case Some(y) => Some(Some(x < y ? x : y))\n         \
    \   }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ufcugni.scala:19:17\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m None\
    \ => (None, None)\n\e[31m\e[31m   |\e[0m                 ^^^^\e[0m\n\e[31m   |\e\
    [0m                 Found:    None.type\n\e[31m   |\e[0m                 Required:\
    \ Long\n\e[31m   |\e[0m                 pattern type is incompatible with expected\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ufcugni.scala:21:21\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e\
    [0m None => (None, None)\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\
    \e[31m   |\e[0m                     Found:    None.type\n\e[31m   |\e[0m     \
    \                Required: Long\n\e[31m   |\e[0m                     pattern type\
    \ is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_ufcugni.scala:22:54 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m Some(y) => Some(Some(x < y\
    \ ? x : y))\n\e[31m\e[31m   |\e[0m                                           \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \            Not found: type y\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp_ufcugni.scala:22:44 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m                \e[33mcase\e[0m Some(y) => Some(Some(x < y ? x : y))\n\e[31m\e\
    [31m   |\e[0m                                          ^^^\e[0m\n\e[31m   |\e\
    [0mvalue < is not a member of Any, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ufcugni.scala:22:48\
    \ ------------"
  stdout: ''
  timestamp: 1660028952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def helper(acc : List[(Long,\
    \ Long)])(min : Long, max : Long) : Option[(Long, Long)] = {\n            if(!acc.isEmpty)\
    \ {\n                if(acc match {\n                    case Nil => None\n  \
    \                  case x :: xs => {\n                        if(x < min) None\n\
    \                        else if(x > max) None\n                        else if(min\
    \ == max && x == min) Some(x)\n                        else if(x < min && x >\
    \ max) helper(xs, x)\n                        else if(min == max && x == min)\
    \ Some(min :: Nil)\n                        else if(min < x && x < max) Some(x\
    \ :: Nil)\n                        else helper(xs, max)\n                    }\n\
    \                })\n            } else if(lst.isEmpty) None\n            else\
    \ helper(lst.tail, lst(0))\n        }\n        helper(Nil, lst(0))\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvufaoyhn.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(lst.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            'then'\
    \ expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvufaoyhn.scala:19:32\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                    \e[33mcase\e\
    [0m Nil => None\n\e[31m\e[31m   |\e[0m                                ^^^^\e[0m\n\
    \e[31m   |\e[0m                                Found:    None.type\n\e[31m   |\e\
    [0m                                Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvufaoyhn.scala:21:29 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                        \e[33mif\e[0m(x < min) None\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of (Long, Long), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvufaoyhn.scala:21:36 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                        \e[33mif\e[0m(x < min) None\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e[31m   |\e\
    [0m                                    Found:    None.type\n\e[31m   |\e[0m  \
    \                                  Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvufaoyhn.scala:22:34 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                        \e[33melse\e[0m \e[33mif\e[0m(x\
    \ > max) None\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\
    \e[31m   |\e[0mvalue > is not a member of (Long, Long), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660028955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) \n      \
    \      (None, None)\n        else {\n            var minL = -1l\n            var\
    \ maxL = 1l\n            var nextMinL = -1l\n            var nextMaxL = 1l\n \
    \           lst.toList foreach { e =>\n                if (e < minL) {\n     \
    \               minL = e\n                }\n                if (e > maxL) {\n\
    \                    maxL = e\n                }\n            }\n            val\
    \ result = if (minL < -1l) Some(None) else Some(minL)\n            if (maxL >\
    \ 1l) Some(maxL) else result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy4s8twg0.scala:32:31\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (maxL\
    \ > \e[31m1l\e[0m) Some(maxL) \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m  \
    \                         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \        Found:    Some[Long]\n\e[31m   |\e[0m                           Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpy4s8twg0.scala:32:43 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mif\e[0m (maxL > \e[31m1l\e[0m) Some(maxL) \e[33melse\e\
    [0m result\n\e[31m\e[31m   |\e[0m                                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (result : Some[None.type\
    \ | Long])\n\e[31m   |\e[0m                             Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      var positive = Long.MaxValue\n\
    \      var negative = Long.MinValue\n      lst.foldLeft(Some(negative), Some(positive))\
    \ { (t, l) =>\n        if(l < 0) (Some(negative), Some(positive))\n        else\
    \ if(l > 0) (Some(positive), Some(positive))\n        else (t, Some(positive))\n\
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp57tw68hx.scala:21:14\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (t, Some(positive))\n\
    \e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              Found:\
    \    (t : (Some[Long], Some[Long]))\n\e[31m   |\e[0m              Required: Some[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = (lst.filter(x\
    \ => x < 0l))\n        val positive = (lst.filter(x => x > 0l))\n        val min\
    \ = min(positive)\n        val max = max(negative)\n        (Some(min), Some(max))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa807bd42.scala:18:18 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(positive)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa807bd42.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(negative)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldLeft((None, None))\
    \ { (tl, el) => \n            val a = if (el < 0l) None else Some(el)\n      \
    \      val b = if (el > 0l) None else Some(el)\n            (a._1, b._1) \n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8lc2ytvo.scala:19:15 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            (a._1, b._1) \n\e[31m\e[31m   |\e[0m    \
    \         ^^^^\e[0m\n\e[31m   |\e[0m             value _1 is not a member of Option[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8lc2ytvo.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            (a._1, b._1) \n\e[31m\e[31m   |\e[0m    \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                   value _1 is not a\
    \ member of Option[Long]\n2 errors found\n"
  stdout: ''
  timestamp: 1660028953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Find negative and positive\
    \ integer values using 'filter'.\n        // 'filter' will return a list with\
    \ all the positive and negative integers, respectively.\n        val posNbl =\
    \ lst.filter(x => x < 0l)\n        val negNbl = lst.filter(x => x > 0l)\n    \
    \    \n        // Take the maximum of both lists to get the largest of them\n\
    \        val posSmallest = posNbl.max(negNbl)\n        val negLargest = negNbl.max(posNbl)\n\
    \        \n        // return None if there is no negative or positive integers\n\
    \        if (posSmallest.isEmpty && negLargest.isEmpty) return (None, None)\n\
    \        // else return the (Option[Int], Option[Int]) tuple, where 'a' is the\
    \ largest of positive integers, and 'b' is the smallest of negative integers.\n\
    \        return (Some(negLargest.get), Some(posSmallest.get))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf8fqbm7t.scala:22:37\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mposSmallest\e\
    [0m = posNbl.max(negNbl)\n\e[31m\e[31m   |\e[0m                              \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                                     Found:\
    \    (negNbl : List[Long])\n\e[31m   |\e[0m                                  \
    \   Required: Ordering[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpf8fqbm7t.scala:23:36 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mnegLargest\e[0m = negNbl.max(posNbl)\n\e\
    [31m\e[31m   |\e[0m                                    ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                    Found:    (posNbl : List[Long])\n\e[31m\
    \   |\e[0m                                    Required: Ordering[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf8fqbm7t.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (posSmallest.isEmpty && negLargest.isEmpty)\
    \ \e[33mreturn\e[0m (None, None)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value isEmpty is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpf8fqbm7t.scala:28:32 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m (Some(negLargest.get), Some(posSmallest.get))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     value get is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf8fqbm7t.scala:28:55 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m (Some(negLargest.get), Some(posSmallest.get))\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       value get is not a\
    \ member of Long\n5 errors found\n"
  stdout: ''
  timestamp: 1660028954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        import scala.math._\n    \
    \    import scala.collection.mutable._\n\n        val l = new mutable.ListBuffer[Long]()\n\
    \        var a : Option[Long] = None\n        var b : Option[Long] = None\n  \
    \      for(i <- lst){\n            if(i.<0){\n                if(b.isDefined &&\
    \ a.isDefined){\n                    l.clear()\n                    l.append(b.get)\n\
    \                    b.set(i.get)\n                    a = Some(i.get)\n     \
    \           }else if(a.isDefined && b.isDefined) l.append(i.get)\n           \
    \     else l.append(i.get)\n            }else if(i>0){\n                if(b.isDefined\
    \ && a.isDefined){\n                    l.clear()\n                    l.append(a.get)\n\
    \                    a.set(i.get)\n                    b = Some(i.get)\n     \
    \           }else if(a.isDefined && b.isDefined) l.append(i.get)\n           \
    \     else l.append(i.get)\n            }\n        }\n        if(l.isEmpty) (a,b)\
    \ else {\n            l.foldLeft((a, Some(0l))){\n                case ((Some(a),\
    \ Some(b)) , v) => if(v>b) (b,v) else (a,v)\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2e0_v6km.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(i.<\e[31m0\e[0m){\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  ')' expected,\
    \ but integer literal found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2e0_v6km.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36ml\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2e0_v6km.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    b.set(i.get)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0mvalue set\
    \ is not a member of Option[Long] - did you mean Option[Long].get?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2e0_v6km.scala:27:28 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    b.set(i.get)\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     value get is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2e0_v6km.scala:28:31 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m                    a = Some(i.get)\n\e[31m\e[31m   |\e[0m                \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                             value get\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2e0_v6km.scala:35:22\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    a.set(i.get)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0mvalue set\
    \ is not a member of Option[Long] - did you mean Option[Long].get?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2e0_v6km.scala:35:28 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    a.set(i.get)\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     value get is not a member of Long\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1660028954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val max = lst.maxBy(_.toInt)\n\
    \        val min = lst.minBy(_.toInt)\n        (Some(max), Some(min))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpohj_ozu_.scala:21)\n\tat Problem.main(tmpohj_ozu_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val lstOpt = lst.headOption\n\
    \        val lst1 = lst.tail\n        val lst1Opt = lst1.headOption\n\n      \
    \  val min = if (lstOpt.isDefined && lst1Opt.isDefined) lst1Opt.get.toLong max\
    \ lstOpt.get.toLong else lst1Opt\n        val max = if (lstOpt.isDefined && lst1Opt.isDefined)\
    \ lst1Opt.get.toLong min lstOpt.get.toLong else lstOpt\n\n        if (lstOpt.isDefined\
    \ && lst1Opt.isDefined) {\n            (Some(min), Some(max))\n        }\n   \
    \     else (None, None)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj32xfwo7.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            (Some(min), Some(max))\n\
    \e[31m\e[31m   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m             \
    \     Found:    (min : Matchable)\n\e[31m   |\e[0m                  Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj32xfwo7.scala:24:29\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            (Some(min), Some(max))\n\
    \e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0m  \
    \                           Found:    (max : Matchable)\n\e[31m   |\e[0m     \
    \                        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(_\
    \ < 0l)\n        val posInts = lst.filter(_ > 0l)\n        val maxInt = negInts.maxBy(neg\
    \ => neg)\n        val minInt = posInts.minBy(pos => pos)\n        (maxInt ==\
    \ None) match {\n            case true => {\n                (maxInt == None)\
    \ match {\n                    case true => (None, None)\n                   \
    \ case false => (None)(None)\n                }\n            }\n            case\
    \ false => val maxIntTuple = (maxInt.asInstanceOf[Long], None) match {\n     \
    \           case (neg, None) => Some(neg)\n                case (neg, _) => Some(neg)\n\
    \                case (_, pos) => Some(pos)\n            }\n            (minInt\
    \ == None) match {\n                case true => {\n                    (minInt\
    \ == None) match {\n                        case true => (None, None)\n      \
    \                  case false => (None)(None)\n                    }\n       \
    \         }\n                case false => val minIntTuple = (minInt.asInstanceOf[Long],\
    \ None) match {\n                    case (pos, None) => Some(pos)\n         \
    \           case (pos, _) => Some(pos)\n                    case (_, neg) => Some(neg)\n\
    \                }\n                ((maxIntTuple, minIntTuple))\n           \
    \ }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6dr0v41q.scala:20:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        (maxInt == None) \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types Long\
    \ and object None cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6dr0v41q.scala:22:17\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \         (maxInt == None) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m         \
    \        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types Long and object\
    \ None cannot be compared with == or !=\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6dr0v41q.scala:24:35\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                   \
    \ \e[33mcase\e[0m \e[31mfalse\e[0m => (None)(None)\n\e[31m\e[31m   |\e[0m    \
    \                               ^^^^\e[0m\n\e[31m   |\e[0m                   \e\
    [33mobject\e[0m \e[35mNone\e[0m in \e[33mpackage\e[0m \e[35mscala\e[0m does not\
    \ take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp6dr0v41q.scala:32:13\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \     (minInt == None) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Values of types Long and object None cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6dr0v41q.scala:34:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    (minInt == None) \e[33mmatch\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m   Values of types Long and object None cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmp6dr0v41q.scala:36:39 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                        \e[33mcase\e[0m \e[31mfalse\e\
    [0m => (None)(None)\n\e[31m\e[31m   |\e[0m                                   \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                   \e[33mobject\e[0m \e[35mNone\e\
    [0m in \e[33mpackage\e[0m \e[35mscala\e[0m does not take parameters\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer exp"
  stdout: ''
  timestamp: 1660028956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def getMaxPositive(lst : List[Long])\
    \ : Option[Long] = {\n            val max = lst.foldLeft(0l.toLong)(math.max(_,\
    \ _))\n            lst.find(_ > max).getOrElse(None)\n        }\n        def getMinNegative(lst\
    \ : List[Long]) : Option[Long] = {\n            val min = lst.foldLeft(0l.toLong)(math.min(_,\
    \ _))\n            lst.find(_ < min).getOrElse(None)\n        }\n        val maxPosOpt\
    \ = getMaxPositive(lst.sortWith(_ > _))\n        val minNegOpt = getMinNegative(lst.sortWith(_\
    \ < _))\n        (maxPosOpt, minNegOpt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnyc1zrxj.scala:18:39\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            lst.find(_ > max).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    Matchable\n\e[31m   |\e[0m            Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnyc1zrxj.scala:22:39\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            lst.find(_ < min).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    Matchable\n\e[31m   |\e[0m            Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val min = lst.min\n      \
    \  val max = lst.max\n        val minOpt = lst.find(_.toLong < min.toLong)\n \
    \       val maxOpt = lst.find(_.toLong > max.toLong)\n        if (minOpt.isDefined\
    \ && maxOpt.isDefined) {\n            return Some((minOpt.get, maxOpt.get))\n\
    \        }\n        else {\n            return Some(None)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuz_5o4q9.scala:21:23\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mreturn\e[0m\
    \ Some((minOpt.get, maxOpt.get))\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Some[(Long, Long)]\n\e[31m  \
    \ |\e[0m                   Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuz_5o4q9.scala:24:23 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mreturn\e[0m Some(None)\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \   Found:    Some[None.type]\n\e[31m   |\e[0m                   Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(acc : Option[Long],\
    \ xs: List[Long]) : Option[Long] = {\n            if (xs.isEmpty) acc\n      \
    \      else largest(acc.max(xs.head), xs.tail)\n        }\n        def smallest(acc\
    \ : Option[Long], xs: List[Long]) : Option[Long] = {\n            if (xs.isEmpty)\
    \ acc\n            else smallest(acc.min(xs.head), xs.tail)\n        }\n     \
    \   (largest(Option.empty, lst.filter(_ < 0l)),\n         smallest(Option.empty,\
    \ lst.filter(_ > 0l)))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu_jtl86j.scala:18:36\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m largest(acc.max(xs.head),\
    \ xs.tail)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Found:    Long\n\e[31m   |\e[0m\
    \                                 Required: Ordering[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu_jtl86j.scala:22:37 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m smallest(acc.min(xs.head),\
    \ xs.tail)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Long\n\e[31m   |\e\
    [0m                                  Required: Ordering[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(l\
    \ => l < 0l).sort((l, r) => r - l)\n        val positive = lst.filter(l => l >\
    \ 0l).sort((l, r) => r - l)\n        val first = if (negative.isEmpty && positive.isEmpty)\
    \ None else Some(negative.head)\n        val second = if (positive.isEmpty &&\
    \ negative.isEmpty) None else Some(positive.last)\n        val firstIsLarger =\
    \ (negative.head > positive.last)\n        val secondIsSmaller = (negative.last\
    \ < positive.head)\n        val firstIsSmaller = (negative.last < positive.head)\n\
    \        val firstIsBigger = (negative.head > positive.last)\n        val secondIsBigger\
    \ = (positive.last < positive.head)\n\n        val firstIsMorePositiveOrNegative\
    \ = (first == None) || (first.isEmpty && ((firstIsLarger) && secondIsSmaller))\n\
    \        val secondIsMorePositiveOrNegative = (second == None) || (second.isEmpty\
    \ && ((secondIsSmaller) && firstIsSmaller))\n\n        val firstIsNegativeOrPositive\
    \ = (first == None) || (first.isEmpty && ((firstIsSmaller) && secondIsBigger))\n\
    \        val secondIsNegativeOrPositive = (second == None) || (second.isEmpty\
    \ && ((secondIsBigger) && firstIsBigger))\n        val bothAreNegativeOrPositive\
    \ = firstIsNegativeOrPositive && secondIsNegativeOrPositive\n        val bothAreMorePositiveOrNegative\
    \ = firstIsMorePositiveOrNegative || secondIsMorePositiveOrNegative\n        val\
    \ bothAreNegativeOrPositiveOrMorePositiveOrNegative = firstIsNegativeOrPositive\
    \ && secondIsNegativeOrPositive && firstIsMorePositiveOrNegative || secondIsNegativeOrPositive\
    \ && firstIsMorePositiveOrNegative\n        val bothAreNegativeOrPositiveOrMorePositiveOrNegativeOrBothAreMorePositiveOrNegative\
    \ = firstIsNegativeOrPositive && secondIsNegativeOrPositive && firstIsMorePositiveOrNegative\
    \ && secondIsMorePositiveOrNegative\n\n        val allAreMorePositiveOrNegative\
    \ = (first == None) || (first.isEmpty && ((firstIsMorePositiveOrNegative) && secondIsMorePositiveOrNegative))\n\
    \        val allAreMorePositiveOrNegativeOrBothAreMorePositiveOrNegative = firstIsMorePositiveOrNegative\
    \ || secondIsMorePositiveOrNegative && ((firstIsMorePositiveOrNegative) && secondIsMorePositiveOrNegative)\n\
    \        val allAreNegativeOrPositiveOrBothAreMorePositiveOrNegative = first\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc1maw7ki.scala:16:47 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnegative\e[0m = lst.filter(\e\
    [36ml\e[0m => l < \e[31m0l\e[0m).sort((\e[36ml\e[0m, \e[36mr\e[0m) => r - l)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue sort is not a member of List[Long] - did you mean List[Long].sortBy?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc1maw7ki.scala:17:47 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpositive\e[0m = lst.filter(\e\
    [36ml\e[0m => l > \e[31m0l\e[0m).sort((\e[36ml\e[0m, \e[36mr\e[0m) => r - l)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue sort is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc1maw7ki.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largestOfInt(lst : List[Long])\
    \ : Option[Long] = {\n            for (i <- lst) yield if (i >= 0) i else None\n\
    \        }\n        val positives = largestOfInt(lst)\n        val negatives =\
    \ lst.filter(_ >= 0)\n        val minNegative = negatives.min\n        val maxPositive\
    \ = positives.max\n        if (minNegative.isEmpty || maxPositive.isEmpty) return\
    \ (None, None)\n        return (Some(maxPositive), Some(minNegative))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn9uq78am.scala:17:12\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mfor\e[0m (i\
    \ <- lst) \e[33myield\e[0m \e[33mif\e[0m (i >= \e[31m0\e[0m) i \e[33melse\e[0m\
    \ None\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[Matchable]\n\e[31m   |\e[0m   \
    \         Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpn9uq78am.scala:23:24 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mif\e[0m (minNegative.isEmpty || maxPositive.isEmpty) \e[33mreturn\e\
    [0m (None, None)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value isEmpty is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660028958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      val (min, max) = lst.foldLeft((None,\
    \ Long.MaxValue)) {\n        case ((Some(x), y), x) if x < y => (Some(x), y)\n\
    \        case ((None, x), y) => (y, x)\n      }\n      (Some(min), Some(max))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E005] Naming Error: /tmp/tmp_z3v1hov.scala:17:28 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mcase\e[0m ((Some(x), y), x) \e[33mif\e\
    [0m x < y => (Some(x), y)\n\e[31m\e[31m   |\e[0m                            ^\e\
    [0m\n\e[31m   |\e[0m                            duplicate pattern variable: x\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_z3v1hov.scala:17:36\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mcase\e[0m ((Some(x),\
    \ y), x) \e[33mif\e[0m x < y => (Some(x), y)\n\e[31m\e[31m   |\e[0m          \
    \                        ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_z3v1hov.scala:17:48 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mcase\e[0m ((Some(x), y), x) \e[33mif\e\
    [0m x < y => (Some(x), y)\n\e[31m\e[31m   |\e[0m                             \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \            Found:    Some[Any]\n\e[31m   |\e[0m                            \
    \                Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_z3v1hov.scala:18:32 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mcase\e[0m ((None, x), y) => (y, x)\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m         \
    \                       Found:    (y : Long)\n\e[31m   |\e[0m                \
    \                Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_z3v1hov.scala:20:12 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m      (Some("
  stdout: ''
  timestamp: 1660028964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var biggestInt : Option[Long]\
    \ = None\n        var smallestInt : Option[Long] = None\n        var i : Int =\
    \ 0\n        while (i < lst.size){\n            if (lst(i) < 0l){\n          \
    \      if (biggestInt.isEmpty || biggestInt.get < lst(i)){\n                 \
    \   biggestInt = Some(lst(i))\n                }\n            }\n            if\
    \ (lst(i) > 0l){\n                if (smallestInt.isEmpty || smallestInt.get >\
    \ lst(i)){\n                    smallestInt = Some(lst(i))\n                }\n\
    \            }\n            i += 1\n        }\n        if ((biggestInt == None)\
    \ || (smallestInt == None) || (biggestInt.get.equals(smallestInt.get))){\n   \
    \         return (None, None)\n        }\n        return (Some(biggestInt.get),\
    \ Some(smallestInt.get))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwwog0p8r.scala:38)\n\tat Problem.main(tmpwwog0p8r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negInts = lst.filter(\
    \ x => x < 0l )\n        val posInts = lst.filter( x => x >= 0l )\n\n        if\
    \ (negInts.isEmpty) {\n            return (None,None)\n        }\n        if (posInts.isEmpty)\
    \ {\n            return (Some(negInts.min), Some(negInts.max))\n        }\n  \
    \      val negMin = negInts.min\n        val negMax = negInts.max\n        val\
    \ posMin = posInts.min\n        val posMax = posInts.max\n\n        if (negMin\
    \ > negMax) {\n            return (Some(negMax), Some(negMin))\n        } else\
    \ if (posMin < posMax) {\n            return (Some(posMin), Some(posMax))\n  \
    \      }\n        val ints = (negMin, negMax)\n        if (negMax.compare(posMin)\
    \ < 0) {\n            ints = (negMin, posMin)\n        }\n        if (negMin.compare(posMax)\
    \ > 0) {\n            ints = (negMax, posMax)\n        }\n        (ints.max max\
    \ ints.min min ints.maxOption, ints.min min ints.max maxOption)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpysa4opgz.scala:42:82 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        (ints.max max ints.min min ints.maxOption, ints.min\
    \ min ints.max maxOption)\n\e[31m\e[31m   |\e[0m                             \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m')'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpysa4opgz.scala:37:17\
    \ -----------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            ints = (negMin,\
    \ posMin)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Reassignment to val ints\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpysa4opgz.scala:40:17 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            ints = (negMax, posMax)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val ints\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpysa4opgz.scala:42:14\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        (ints.max max ints.min\
    \ min ints.maxOption, ints.min min ints.max maxOption)\n\e[31m\e[31m   |\e[0m\
    \         ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue max is not a member of (Long, Long),\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpysa4opgz.scala:42:56 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        (ints.max max ints.min min ints.maxOption, ints.min\
    \ min ints.max maxOption)\n\e[31m\e[31m   |\e[0m                             \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue min is not a member\
    \ of (Long, Long), but could be made available as an e"
  stdout: ''
  timestamp: 1660028965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Sort the list and keep\
    \ track of where each element lies.\n        val sorted = lst.sortWith(_.compareTo(_)\
    \ < 0)\n        val sortedIdx = sorted.zipWithIndex\n\n        // Loop over the\
    \ sorted list, keeping track of the largest and smallest values\n        var smallestValue\
    \ = sortedIdx(0)._2 //None\n        var largestValue = sortedIdx(sortedIdx.size\
    \ - 1)._2 //None\n\n        for (i <- 1 to sorted.size-1) {\n            // If\
    \ the current value is smaller than the smallest we've seen so far,\n        \
    \    // store the smallest value and mark that we've seen it\n            if (sortedIdx(i)._2\
    \ < smallestValue) {\n                smallestValue = sortedIdx(i)._2\n      \
    \      }\n            // If the current value is larger than the largest we've\
    \ seen so far,\n            // store the largest value and mark that we've seen\
    \ it\n            if (sortedIdx(i)._2 > largestValue) {\n                largestValue\
    \ = sortedIdx(i)._2\n            }\n        }\n        // If we haven't seen any\
    \ positive and no negative values, return None\n        if (smallestValue == None)\
    \ None else if (largestValue == None) Some(None) else (Some(smallestValue), Some(largestValue))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprn7n1n_8.scala:37:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (smallestValue == None) None \e\
    [33melse\e[0m \e[33mif\e[0m (largestValue == None) Some(None) \e[33melse\e[0m\
    \ (Some(smallestValue), Some(largestValue))\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Int and object\
    \ None cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmprn7n1n_8.scala:37:35 --------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \        \e[33mif\e[0m (smallestValue == None) None \e[33melse\e[0m \e[33mif\e\
    [0m (largestValue == None) Some(None) \e[33melse\e[0m (Some(smallestValue), Some(largestValue))\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Found:    None.type\n\e[31m   |\e[0m    \
    \                              Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmprn7n1n_8.scala:37:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (smallestValue == None) None \e\
    [33melse\e[0m \e[33mif\e[0m (largestValue == None) Some(None) \e[33melse\e[0m\
    \ (Some(smallestValue), Some(largestValue))\n\e[31m\e[31m   |\e[0m           \
    \                                      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    Values of types Int and object None cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprn7n1n_8.scala:37:75 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (smallestValue == None) None \e\
    [33melse\e[0m \e[33mif\e[0m (largestValue == None) Some(None) \e[33melse\e[0m\
    \ (Some(smallestValue), Some(largestValue))\n\e[31m\e[31m   |\e[0m           \
    \                                                            ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[None.type]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation availab"
  stdout: ''
  timestamp: 1660028967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val n = lst.size\n       \
    \ val n = n - 1\n        var smallest = Option.empty[Long]\n        var largest\
    \ = Option.empty[Long]\n        for(i <- 0 until n) {\n            val current\
    \ = lst(i)\n            if(current.isLessThanOrEqualTo(0)) {\n               \
    \ smallest = current\n            } else {\n                largest = current\n\
    \            }\n        }\n        (smallest, largest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3xxtloap.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3xxtloap.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m(current.isLessThanOrEqualTo(\e\
    [31m0\e[0m)) {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value isLessThanOrEqualTo is not a member of\
    \ Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3xxtloap.scala:23:27\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                smallest = current\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    (current : Long)\n\e[31m   |\e[0m      \
    \                     Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3xxtloap.scala:25:26 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                largest = current\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Found:    (current : Long)\n\e[31m   |\e[0m                          Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      lst.foldLeft(\n        (Some(None):\
    \ Option[Long], Some(None): Option[Long]),\n        (acc, i) => {\n          val\
    \ maxPosInt = (acc max i)\n          val minNegInt = (acc min i)\n          if\
    \ (maxPosInt > 0 || minNegInt < 0) {\n            (Some(maxPosInt), Some(minNegInt))\n\
    \          } else {\n            (None, Some(i))\n          }\n        })\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeytn278q.scala:17:14\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        (Some(None): \e[35mOption\e\
    [0m[\e[35mLong\e[0m], Some(None): \e[35mOption\e[0m[\e[35mLong\e[0m]),\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              Found:    None.type\n\
    \e[31m   |\e[0m              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpeytn278q.scala:17:40 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        (Some(None): \e[35mOption\e[0m[\e[35mLong\e[0m],\
    \ Some(None): \e[35mOption\e[0m[\e[35mLong\e[0m]),\n\e[31m\e[31m   |\e[0m    \
    \                                    ^^^^\e[0m\n\e[31m   |\e[0m              \
    \                          Found:    None.type\n\e[31m   |\e[0m              \
    \                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpeytn278q.scala:18:9 ------------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        (\e[36macc\e[0m, \e[36mi\e[0m) => {\n\e[31m\e[31m\
    \   |\e[0m         ^^^\e[0m\n\e[31m   |\e[0m         Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m         I could not infer the type of the parameter\
    \ acc.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpeytn278q.scala:18:14 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        (\e[36macc\e[0m, \e[36mi\e[0m) => {\n\e[31m\e\
    [31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m              I could not infer the type\
    \ of the parameter i.\n4 errors found\n"
  stdout: ''
  timestamp: 1660028966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var largest = lst.headOption\n\
    \        var smallest = lst.lastOption\n        for(i<-lst.indices) largest =\
    \ lst.applyOrElse(i, largest)\n        for(i<-lst.indices) smallest = lst.applyOrElse(i,\
    \ smallest)\n        if (largest.isEmpty || smallest.isEmpty) None else (Some(largest),\
    \ Some(smallest))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpduxueoav.scala:18:57\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m(i<-lst.indices)\
    \ largest = lst.applyOrElse(i, largest)\n\e[31m\e[31m   |\e[0m               \
    \                                          ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                 Found:    (largest : Option[Long])\n\e[31m \
    \  |\e[0m                                      Required: Int => Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpduxueoav.scala:19:58 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m(i<-lst.indices) smallest = lst.applyOrElse(i,\
    \ smallest)\n\e[31m\e[31m   |\e[0m                                           \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \      Found:    (smallest : Option[Long])\n\e[31m   |\e[0m                  \
    \                   Required: Int => Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpduxueoav.scala:20:49 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (largest.isEmpty || smallest.isEmpty)\
    \ None \e[33melse\e[0m (Some(largest), Some(smallest))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^\e[0m\n\e[31m   |\e[0m \
    \                                 Found:    None.type\n\e[31m   |\e[0m       \
    \                           Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpduxueoav.scala:20:65 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (largest.isEmpty || smallest.isEmpty)\
    \ None \e[33melse\e[0m (Some(largest), Some(smallest))\n\e[31m\e[31m   |\e[0m\
    \                                                                 ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      Found:    (largest : Option[Long])\n\
    \e[31m   |\e[0m                                      Required: Lo"
  stdout: ''
  timestamp: 1660028967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largest(l : List[Long])\
    \ : Option[Long] = {\n            if (l.isEmpty) None\n            else Some(l.max)\n\
    \        }\n        def smallest(l : List[Long]) : Option[Long] = {\n        \
    \    if (l.isEmpty) None\n            else Some(l.min)\n        }\n        val\
    \ max = largest(lst.filter(_.isNegative))\n        val min = smallest(lst)\n \
    \       (max, min)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1163o8oy.scala:24:39 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = largest(lst.filter(_.isNegative))\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                value isNegative is not a member\
    \ of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660028966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val n = lst.size\n       \
    \ val sorted = lst.sortBy(x => x)\n        var firstPosInList = false\n      \
    \  var firstNegInList = false\n        var lastPosInList = false\n        var\
    \ lastNegInList = false\n        var firstPosInArray = false\n        var firstNegInArray\
    \ = false\n        var lastPosInArray = false\n        var lastNegInArray = false\n\
    \n        for (i <- 0 until n) {\n            if (sorted(i) < 0) {\n         \
    \       if (firstPosInList == false) {\n                    firstPosInList = i\n\
    \                }\n                lastPosInList = i\n            } else if (sorted[i]\
    \ > 0) {\n                if (firstNegInList == false) {\n                   \
    \ firstNegInList = i\n                }\n                lastNegInList = i\n \
    \           } else {\n                if (firstPosInArray == false) {\n      \
    \              firstPosInArray = i\n                }\n                lastPosInArray\
    \ = i\n                if (firstNegInArray == false) {\n                    firstNegInArray\
    \ = i\n                }\n                lastNegInArray = i\n            }\n\
    \        }\n\n        if (firstNegInList == false && firstNegInArray == false)\
    \ return (None, None)\n        if (firstPosInList == false && firstPosInArray\
    \ == false) return (None, None)\n\n        if ((firstNegInList != lastNegInArray)\
    \ || (firstPosInList != lastPosInArray)) {\n            return (None, None)\n\
    \        }\n\n        if (lastNegInList == 0) return (None, None)\n        if\
    \ (lastPosInList == 0) return (None, None)\n\n        return (Some(sorted(firstNegInList).last),\
    \ Some(sorted(lastPosInList).first))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps3x3u3ut.scala:30:37\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    firstPosInList\
    \ = i\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    (i : Int)\n\e[31m   |\e\
    [0m                                     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps3x3u3ut.scala:32:32 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                lastPosInList = i\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    (i : Int)\n\e[31m   |\e[0m                           \
    \     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps3x3u3ut.scala:33:30\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            } \e[33melse\e\
    [0m \e[33mif\e[0m (sorted[i] > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m        \
    \                      ^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps3x3u3ut.scala:35:37\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    firstNegInList\
    \ = i\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    (i : Int)\n\e[31m   |\e\
    [0m                                     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps3x3u3ut.scala:37:32 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                lastNegInList = i\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    (i : Int)\n\e[31m   |\e[0m                           \
    \     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explana"
  stdout: ''
  timestamp: 1660028968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largestPositive(lst :\
    \ List[Long]) : List[Long] = {\n            val max = lst.foldLeft(List[Long](0l))(_\
    \ + _)\n            val res = lst filter (_ > max) ::: List(max) \n          \
    \  res\n        }\n        def largestNegative(lst : List[Long]) : List[Long]\
    \ = {\n            val max = lst.foldLeft(List[Long](0l))(_ + _)\n           \
    \ val res = lst filter (_ < max) ::: List(max) \n            res\n        }\n\
    \        if (lst exists _ > 0l)\n            (Some(largestPositive(lst filter\
    \ (_ > 0l))), Some(largestPositive(lst filter (_ < 0l))))\n        else if (lst\
    \ exists _ < 0l)\n            (Some(largestNegative(lst filter (_ > 0l))), Some(largestNegative(lst\
    \ filter (_ < 0l))))\n        else\n            None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxieqkz90.scala:17:53 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = lst.foldLeft(List[\e\
    [35mLong\e[0m](\e[31m0l\e[0m))(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                                  ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpxieqkz90.scala:18:34 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = lst filter\
    \ (_ > max) ::: List(max) \n\e[31m\e[31m   |\e[0m                            \
    \      ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m   I could not infer the type of the parameter _$3 of expanded function:\n\
    \e[31m   |\e[0m   _$3 => _$3 > max.\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxieqkz90.scala:22:53\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m\
    \ \e[36mmax\e[0m = lst.foldLeft(List[\e[35mLong\e[0m](\e[31m0l\e[0m))(_ + _)\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpxieqkz90.scala:23:34 -----------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = lst filter (_\
    \ < max) ::: List(max) \n\e[31m\e[31m   |\e[0m   "
  stdout: ''
  timestamp: 1660028969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0).toList\n        val negative = lst.filter(_ < 0).toList\n        positive.foldLeft(None,\
    \ Some(0)){ case (maxPos, pos) if maxPs.isEmpty || pos > maxPs(1) => (Some(pos),\
    \ maxPos) }\n        negative.foldLeft(Some(0), None){ case (minPos, neg) if minPs.isEmpty\
    \ || neg < minPs(1) => (Some(minPos), neg)}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps18ktxsx.scala:18:64 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        positive.foldLeft(None, Some(\e[31m0\e[0m)){\
    \ \e[33mcase\e[0m (maxPos, pos) \e[33mif\e[0m maxPs.isEmpty || pos > maxPs(\e\
    [31m1\e[0m) => (Some(pos), maxPos) }\n\e[31m\e[31m   |\e[0m                  \
    \                                              ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                     Not found: maxPs\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps18ktxsx.scala:18:104 -------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        positive.foldLeft(None, Some(\e[31m0\e[0m)){\
    \ \e[33mcase\e[0m (maxPos, pos) \e[33mif\e[0m maxPs.isEmpty || pos > maxPs(\e\
    [31m1\e[0m) => (Some(pos), maxPos) }\n\e[31m\e[31m   |\e[0m                  \
    \                                                                            \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \             Found:    Some[Long]\n\e[31m   |\e[0m                          \
    \                          Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmps18ktxsx.scala:18:111 -------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        positive.foldLeft(None, Some(\e[31m0\e[0m)){\
    \ \e[33mcase\e[0m (maxPos, pos) \e[33mif\e[0m maxPs.isEmpty || pos > maxPs(\e\
    [31m1\e[0m) => (Some(pos), maxPos) }\n\e[31m\e[31m   |\e[0m                  \
    \                                                                            \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:\
    \    (maxPos : (None.type, Some[Int]))\n\e[31m   |\e[0m                      \
    \       Required: Some[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmps18ktxsx.scala:19:64 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        negative.foldLeft(Some(\e[31m0\e[0m), None){ \e[33mcase\e[0m (minPos,\
    \ neg) \e[33mif\e[0m minPs"
  stdout: ''
  timestamp: 1660028967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0).toList\n        val positive = lst.filter(_ >= 0).toList\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(positive.min), Some(negative.max)).unzip\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0vdkrhg.scala:25:53 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            (Some(positive.min), Some(negative.max)).unzip\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue unzip is not a member of (Some[Long], Some[Long]) -\
    \ did you mean (Some[Long], Some[Long]).zip?\n1 error found\n"
  stdout: ''
  timestamp: 1660028967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val (smalls, larges) = (lst.filter(_\
    \ <= 0l), lst.filter(_ > 0l))\n        smalls.min match {\n            case Some(small)\
    \ if small > larges => (Some(small), Some(larges))\n            case _ => (None,\
    \ Some(larges.min))\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3atrbxsg.scala:18:38 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m Some(small) \e[33mif\e[0m\
    \ small > larges => (Some(small), Some(larges))\n\e[31m\e[31m   |\e[0m       \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member\
    \ of Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3atrbxsg.scala:18:56 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m Some(small) \e[33mif\e[0m\
    \ small > larges => (Some(small), Some(larges))\n\e[31m\e[31m   |\e[0m       \
    \                                                 ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                 Found:    (small : Any)\n\e\
    [31m   |\e[0m                                                 Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3atrbxsg.scala:18:69\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m Some(small)\
    \ \e[33mif\e[0m small > larges => (Some(small), Some(larges))\n\e[31m\e[31m  \
    \ |\e[0m                                                                     ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    (larges\
    \ : List[Long])\n\e[31m   |\e[0m                                         Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) {\n            (None, None)\n        } else if (negative.isEmpty)\
    \ {\n            (None, positive.minBy(_.toLong))\n        } else {\n        \
    \    (Some(negative.minBy(_.toLong)), Some(positive.maxBy(_.toLong)))\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9o9sarvl.scala:21:19\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (None, positive.minBy(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Found:    Long\n\e[31m   |\e[0m                 \
    \  Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negativeInts = lst.filter(x\
    \ => x < 0l)\n        val positiveInts = lst.filter(x => x > 0l)\n        if(negativeInts.isEmpty)\
    \ \n            (Some(None), Some(None))\n        else if (positiveInts.isEmpty)\n\
    \            (Some(None), Some(None))\n        else\n            (Some(positiveInts.max),\
    \ Some(negativeInts.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoxbgxqg1.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoxbgxqg1.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpoxbgxqg1.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m   |\e[0m          \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\e[31m\
    \   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpoxbgxqg1.scala:21:30 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \          Found:    None.type\n\e[31m   |\e[0m                              Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        def largestPositive(l: List[Long],\
    \ acc: Option[Long]) = l.headOption.filter(_ > 0).map(acc)\n        def largestNegative(l:\
    \ List[Long], acc: Option[Long]) = l.headOption.filter(_ < 0).map(acc)\n     \
    \   def smallestPositive(l: List[Long], acc: Option[Long]) = l.headOption.filter(_\
    \ >= 0).map(acc)\n        def smallestNegative(l: List[Long], acc: Option[Long])\
    \ = l.headOption.filter(_ <= 0).map(acc)\n        largestPositive(lst, None) match\
    \ {\n            case None => smallestNegative(lst, None)\n            case Some(x)\
    \ => smallestPositive(lst, x)\n        }\n        largestNegative(lst, None) match\
    \ {\n            case None => smallestPositive(lst, None)\n            case Some(x)\
    \ => smallestNegative(lst, x)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpohp4cjqa.scala:16:95\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mdef\e[0m \e[36mlargestPositive\e\
    [0m(\e[36ml\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m], \e[36macc\e[0m: \e[35mOption\e\
    [0m[\e[35mLong\e[0m]) = l.headOption.filter(_ > \e[31m0\e[0m).map(acc)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                               ^^^\e[0m\n\e[31m   |\e[0m                    \
    \                      Found:    (acc : Option[Long])\n\e[31m   |\e[0m       \
    \                                   Required: Long => Any\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpohp4cjqa.scala:17:95 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mdef\e[0m \e[36mlargestNegative\e[0m(\e\
    [36ml\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m], \e[36macc\e[0m: \e[35mOption\e[0m[\e\
    [35mLong\e[0m]) = l.headOption.filter(_ < \e[31m0\e[0m).map(acc)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                            ^^^\e[0m\n\e[31m   |\e[0m                       \
    \                   Found:    (acc : Option[Long])\n\e[31m   |\e[0m          \
    \                                Required: Long => Any\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpohp4cjqa.scala:18:97 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mdef\e[0m \e[36msmallestPositive\e[0m(\e\
    [36ml\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m], \e[36macc\e[0m: \e[35mOption\e[0m[\e\
    [35mLong\e[0m]) = l.headOption.filter(_ >= \e[31m0\e[0m).map(acc)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                              ^^^\e[0m\n\e[31m   |\e[0m                     \
    \                     Found:    (acc : Option[Long])\n\e[31m   |\e[0m        \
    \                                  Required: Long => Any\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp"
  stdout: ''
  timestamp: 1660028970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val numbers = lst.filter(_\
    \ > 0).filter(_ < Integer.MAX_VALUE).sorted\n        if (numbers.isEmpty) None\n\
    \        else (Some(numbers.last), Some(numbers.first))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm_8ek1b9.scala:17:29\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (numbers.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                             Found:    None.type\n\e[31m   |\e[0m    \
    \                         Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm_8ek1b9.scala:18:47 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m (Some(numbers.last), Some(numbers.first))\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m  value first is not a member of List[Long] - did you mean numbers.find?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.nonEmpty) {\n    \
    \        val posSum = lst.filter(_ > 0l).sum\n            val negSum = lst.filter(_\
    \ < 0l).sum\n            val posSumAbs = lst.filter(_ > 0l).abs.sum\n        \
    \    val negSumAbs = lst.filter(_ < 0l).abs.sum\n            val max = if (negSumAbs\
    \ > posSumAbs) negSum else posSum\n            val min = if (posSumAbs < negSumAbs)\
    \ posSum else negSum\n            (Some(max), Some(min))\n        }\n        else\
    \ {\n            (None, None)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpct_0w1w_.scala:19:47 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mposSumAbs\e[0m = lst.filter(_\
    \ > \e[31m0l\e[0m).abs.sum\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue abs is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpct_0w1w_.scala:20:47 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mnegSumAbs\e[0m = lst.filter(_\
    \ < \e[31m0l\e[0m).abs.sum\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue abs is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldLeft((None,None))((a,\
    \ b) => a.map(_ > b).getOrElse(b).map(_ < a).getOrElse(a))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp1vhxig_c.scala:16:50 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.foldLeft((None,None))((\e[36ma\e[0m, \e[36mb\e\
    [0m) => a.map(_ > b).getOrElse(b).map(_ < a).getOrElse(a))\n\e[31m\e[31m   |\e\
    [0m                                                  ^\e[0m\n\e[31m   |\e[0m \
    \  Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 =>\
    \ _$1 > b.\n1 error found\n"
  stdout: ''
  timestamp: 1660028967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) \n      \
    \      ((None,None), None)\n        else if (lst.head.compareTo(0l) < 0)\n   \
    \         ((Some(None),None), (Some(lst.head), None))\n        else\n        \
    \    largestSmallestIntegersHelper(lst, lst.head)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq91m3zlv.scala:17:13\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            ((None,None), None)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \   Found:    (None.type, None.type)\n\e[31m   |\e[0m             Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq91m3zlv.scala:19:13\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            ((Some(None),None),\
    \ (Some(lst.head), None))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    (Some[None.type], None.type)\n\e[31m\
    \   |\e[0m             Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpq91m3zlv.scala:19:32 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            ((Some(None),None), (Some(lst.head), None))\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    (Some[Long], None.type)\n\
    \e[31m   |\e[0m                                Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq91m3zlv.scala:21:12 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            largestSmallestIntegersHelper(lst, lst.head)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            Not found: largestSmallestIntegersHelper\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negIntegers = lst.filter(_\
    \ < 0L)\n        val posIntegers = lst.filter(_ > 0L)\n\n        // If there is\
    \ no negative or positive integers, return them as None\n        val ans = if\
    \ (negIntegers.isEmpty) None else Some(negIntegers.max)\n        val ans2 = if\
    \ (posIntegers.isEmpty) None else Some(posIntegers.min)\n\n        (ans, ans2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyf1dytv7.scala:26)\n\tat Problem.main(tmpyf1dytv7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val (small, large) = lst.partition(_.isPositive)\n\
    \        val negative = (small.lastOption, large.headOption)\n        val none\
    \ = (None, None) match {\n            case (Some(e1), Some(e2)) => Some(e1.toLong\
    \ - e2.toLong)\n            case (_, _) => None\n        }\n        negative match\
    \ {\n            case (Some(e1), Some(e2)) => Some(Some(e1), Some(e2))\n     \
    \       case (_, None) => Some(none, none)\n            case (None, _) => Some(none,\
    \ none)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt2j15cnt.scala:16:45 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m (small, large) = lst.partition(_.isPositive)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value isPositive is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt2j15cnt.scala:19:49\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e\
    [0m (Some(e1), Some(e2)) => Some(e1.toLong - e2.toLong)\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpt2j15cnt.scala:23:45 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m (Some(e1), Some(e2)) => Some(Some(e1),\
    \ Some(e2))\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    \e[1m\e[31mSome\e\
    [0m\e[1m\e[31m[\e[0m(\e[1m\e[31mSome\e[0m[Long], \e[1m\e[31mSome\e[0m[Long])\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                Required: (\e\
    [1m\e[32mOption\e[0m[Long], \e[1m\e[32mOption\e[0m[Long])\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt2j15cnt.scala:24:34 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m (_, None) => Some(none, none)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Found:    \e[1m\e[31mSome\e[0m\e[1m\e[31m[\e[0m(Option[\e\
    [1m\e[31mNothing\e[0m], Option[\e[1m\e[31mNothing\e[0m])\e[1m\e[31m]\e[0m\n\e"
  stdout: ''
  timestamp: 1660028973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positiveInts = lst.filter(_.toInt\
    \ < 0)\n        val negativeInts = lst.filter(_.toInt > 0)\n\n        if (positiveInts.isEmpty)\n\
    \            (None, None)\n\n        else {\n            val maxPos = positiveInts.maxBy(_.toInt)\n\
    \            val minNeg = negativeInts.minBy(_.toInt)\n\n            (Some(maxPos.toLong),\
    \ Some(minNeg.toLong))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjygbocq1.scala:30)\n\tat Problem.main(tmpjygbocq1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val lb = lst.minBy(math.abs)\n\
    \        val ub = lst.maxBy(math.abs)\n        (Some(lb), Some(ub))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcdxqxjs6.scala:21)\n\tat Problem.main(tmpcdxqxjs6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if(lst.isEmpty) return (None,\
    \ None)\n        val n = lst.head\n        val max_neg = lst.filter(_ < 0).max\n\
    \        val min_pos = lst.filter(_ > 0).min\n        if(max_neg.isEmpty && min_pos.isEmpty)\
    \ {\n            return (None, None)\n        }\n        if(max_neg.isEmpty &&\
    \ min_pos.nonEmpty) {\n            return (Some(n), None)\n        }\n       \
    \ if(max_neg.nonEmpty && min_pos.isEmpty) {\n            return (None, Some(n))\n\
    \        }\n        if(max_neg.nonEmpty && min_pos.nonEmpty) {\n            return\
    \ (Some(n), Some(max_neg))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvla70b9h.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(max_neg.isEmpty && min_pos.isEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \        value isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpvla70b9h.scala:23:19 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mif\e[0m(max_neg.isEmpty && min_pos.nonEmpty) {\n\e[31m\e\
    [31m   |\e[0m           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvla70b9h.scala:26:19\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m(max_neg.nonEmpty\
    \ && min_pos.isEmpty) {\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m           value nonEmpty is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpvla70b9h.scala:29:19 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mif\e[0m(max_neg.nonEmpty && min_pos.nonEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \         value nonEmpty is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1660028979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      val max: Option[Long] = lst.maxBy\
    \ { x => -x}\n      val min: Option[Long] = lst.minBy { x => x}\n      (max, min)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3mu_qy3e.scala:16:30\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m      \e[33mval\e[0m \e[36mmax\e\
    [0m: \e[35mOption\e[0m[\e[35mLong\e[0m] = lst.maxBy { \e[36mx\e[0m => -x}\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              Found:    Long\n\e[31m   |\e[0m   \
    \                           Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp3mu_qy3e.scala:17:30 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m      \e[33mval\e[0m \e[36mmin\e[0m: \e[35mOption\e[0m[\e\
    [35mLong\e[0m] = lst.minBy { \e[36mx\e[0m => x}\n\e[31m\e[31m   |\e[0m       \
    \                       ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \   Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val posInt = lst.filter(x\
    \ => x < 0)\n        val negInt = lst.filter(x => x >= 0)\n        if (posInt.isEmpty)\
    \ None\n        else {\n            val firstPosInt = posInt.min\n           \
    \ val firstNegInt = negInt.min\n            val secondPosInt = posInt.filter(x\
    \ => x < firstPosInt)\n            val secondNegInt = negInt.filter(x => x < firstNegInt)\n\
    \            val thirdPosInt = posInt.filter(x => x > firstPosInt && x < secondPosInt)\n\
    \            val thirdNegInt = negInt.filter(x => x > firstNegInt && x < secondNegInt)\n\
    \            if (secondPosInt.isEmpty) Some(firstPosInt)\n            else {\n\
    \                if (thirdPosInt.isEmpty) Some(firstNegInt)\n                else\
    \ {\n                    val largestPosInt = thirdPosInt.max\n               \
    \     val largestNegInt = thirdNegInt.max\n                    (Some(largestPosInt),\
    \ Some(largestNegInt))\n                }\n            }\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps6hfc2fw.scala:18:28\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (posInt.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    None.type\n\e[31m   |\e[0m          \
    \                  Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmps6hfc2fw.scala:24:70 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mthirdPosInt\e[0m = posInt.filter(\e\
    [36mx\e[0m => x > firstPosInt && x < secondPosInt)\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments ((secondPosInt : List[Long]))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmps6hfc2fw.scala:25:70 -----------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mval\e[0m \e[36mthirdNegInt\e[0m = negInt.filter(\e[36mx\e\
    [0m => x > firstNegInt && x < secondNegInt)\n\e[31m\e[31m   |\e[0m           \
    \                                                         ^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\
    \e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m\
    \   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e\
    [0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch\
    \ arguments ((secondNegInt : List[Long]))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmps6hfc2fw.scala:26:42 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mif\e[0m (secon"
  stdout: ''
  timestamp: 1660028980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var max: Option[Long] = None\n\
    \        var min: Option[Long] = None\n        for(x<-lst){\n            if(!x.isNegative){\n\
    \                if(!max.isEmpty && max < x){\n                    max = None\n\
    \                }\n                if(!min.isEmpty && min > x){\n           \
    \         min = None\n                }\n            }else{\n                if(max.isEmpty\
    \ && x != 0){\n                    max = Some(x)\n                }\n        \
    \        if(min.isEmpty && x != 0){\n                    min = Some(x)\n     \
    \           }\n            }\n        }\n        if(max.isEmpty && min.isEmpty)\
    \ return (None, None)\n        return (max, min)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2bfm4bnb.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(!x.isNegative){\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ isNegative is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2bfm4bnb.scala:20:39\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mif\e\
    [0m(!max.isEmpty && max < x){\n\e[31m\e[31m   |\e[0m                         \
    \          ^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of Option[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2bfm4bnb.scala:23:39 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                \e[33mif\e[0m(!min.isEmpty && min > x){\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue > is not a member of Option[Long], but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660028980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldLeft((None, None)){\n\
    \          case ((a, b), x) =>\n            if (x < 0l && b == None) (a, b)\n\
    \            else if (b == None) (a, b)\n            else (a, b)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk6exb_j8.scala:24)\n\tat Problem.main(tmpk6exb_j8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_.toLong\
    \ > 0l)\n        val negative = lst.filter(_.toLong < 0l)\n        val positiveIntegersCount\
    \ = positive.map(_.toInt).sum\n        val negativeIntegersCount = negative.map(_.toInt).sum\n\
    \        val maximum = if (positiveIntegersCount == 0) None else positive.max\
    \ // O(n), so O(n^2)\n        val minimum = if (negativeIntegersCount == 0) None\
    \ else negative.min // O(n), so O(n^2)\n        (maximum, minimum)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9sg57hnm.scala:22:9\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m        (maximum, minimum)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:   \
    \ (maximum : Matchable)\n\e[31m   |\e[0m         Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9sg57hnm.scala:22:18 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        (maximum, minimum)\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Found:    (minimum\
    \ : Matchable)\n\e[31m   |\e[0m                  Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) {\n     \
    \       return (None, None)\n        }\n\n        var largest = None\n       \
    \ var smallest = None\n\n        for(ix <- 0 until lst.size) {\n            val\
    \ v = lst(ix)\n            if (v < 0 && largest == None) {\n                largest\
    \ = v\n            } else if (v > 0 && smallest == None) {\n                smallest\
    \ = v\n            }\n        }\n\n        (largest, smallest)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5qk2_a9.scala:26:26\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                largest = v\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (v : Long)\n\e[31m   |\e[0m                    \
    \      Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpe5qk2_a9.scala:28:27 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                smallest = v\n\e[31m\e[31m   |\e[0m                  \
    \         ^\e[0m\n\e[31m   |\e[0m                           Found:    (v : Long)\n\
    \e[31m   |\e[0m                           Required: None.type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var bestA = None\n       \
    \ var bestB = None\n        lst.foreach(x => { \n            if(x<0) bestA = Some(x);\
    \ \n            if(x>0) bestB = Some(x) \n        })\n        (bestA, bestB)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2rvy691r.scala:19:32\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(x<\e\
    [31m0\e[0m) bestA = Some(x); \n\e[31m\e[31m   |\e[0m                         \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:    Some[Long]\n\
    \e[31m   |\e[0m                            Required: None.type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2rvy691r.scala:20:32 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m(x>\e[31m0\e[0m) bestB = Some(x)\
    \ \n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Some[Long]\n\e[31m   |\e[0m         \
    \                   Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.sortWith( (a, b) => b.compareTo(a)\
    \ < 0)\n        val positive = lst.takeWhile(x => x < 0l)\n        val negative\
    \ = lst.dropWhile(x => x < 0l)\n        if (negative.isEmpty) ( Some(None) , Some(None)\
    \ )\n        else if (positive.isEmpty) ( Some(None) , Some(None) )\n        else\
    \ ( Some(positive.last) , Some(negative.head))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsagr99j_.scala:19:37\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (negative.isEmpty)\
    \ ( Some(None) , Some(None) )\n\e[31m\e[31m   |\e[0m                         \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                     Found:\
    \    None.type\n\e[31m   |\e[0m                                     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsagr99j_.scala:19:50\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (negative.isEmpty)\
    \ ( Some(None) , Some(None) )\n\e[31m\e[31m   |\e[0m                         \
    \                         ^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                         Found:    None.type\n\e[31m   |\e[0m               \
    \                                   Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsagr99j_.scala:20:42 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty)\
    \ ( Some(None) , Some(None) )\n\e[31m\e[31m   |\e[0m                         \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \         Found:    None.type\n\e[31m   |\e[0m                               \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsagr99j_.scala:20:55 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) ( Some(None)\
    \ , Some(None) )\n\e[31m\e[31m   |\e[0m                                      \
    \                 ^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \                    Found:    None.type\n\e[31m   |\e[0m                    \
    \                                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negativeLst : mutable.Buffer[Long]\
    \ = mutable.Buffer[Long]()\n        val positiveLst : mutable.Buffer[Long] = mutable.Buffer[Long]()\n\
    \n        lst.foreach { number => \n            if (number < 0l) {\n         \
    \       negativeLst += number\n            }\n            if (number > 0l) {\n\
    \                positiveLst += number\n            }\n        }\n\n        (\n\
    \            Some(negativeLst.maxBy(_.toInt)), \n            Some(positiveLst.minBy(_.toInt))\n\
    \        )\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppeo3kxl6.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnegativeLst\e[0m : mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppeo3kxl6.scala:16:49\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mnegativeLst\e[0m : mutable.Buffer[\e[35mLong\e[0m] = mutable.Buffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                                \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                                              \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppeo3kxl6.scala:17:26\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mpositiveLst\e[0m : mutable.Buffer[\e[35mLong\e[0m] = mutable.Buffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppeo3kxl6.scala:17:49 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpositiveLst\e[0m : mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                                             ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                               Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val mn = lst.head\n      \
    \  val mx = lst.last\n\n        if (mx < 0L && mx >= 0L) Some(mx) else if (mn\
    \ > 0L && mn > 0L) Some(mn) else None\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoqp2dxi.scala:19:37\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (mx < \e\
    [31m0L\e[0m && mx >= \e[31m0L\e[0m) Some(mx) \e[33melse\e[0m \e[33mif\e[0m (mn\
    \ > \e[31m0L\e[0m && mn > \e[31m0L\e[0m) Some(mn) \e[33melse\e[0m None\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                Found:    Some[Long]\n\e[31m   |\e[0m       \
    \                          Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoqp2dxi.scala:19:75 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (mx < \e[31m0L\e[0m && mx >= \e\
    [31m0L\e[0m) Some(mx) \e[33melse\e[0m \e[33mif\e[0m (mn > \e[31m0L\e[0m && mn\
    \ > \e[31m0L\e[0m) Some(mn) \e[33melse\e[0m None\n\e[31m\e[31m   |\e[0m      \
    \                                                                 ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoqp2dxi.scala:19:85\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (mx < \e\
    [31m0L\e[0m && mx >= \e[31m0L\e[0m) Some(mx) \e[33melse\e[0m \e[33mif\e[0m (mn\
    \ > \e[31m0L\e[0m && mn > \e[31m0L\e[0m) Some(mn) \e[33melse\e[0m None\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \     Found:    None.type\n\e[31m   |\e[0m                                  Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val max = -sys.maxLong\n \
    \       val min = sys.maxLong\n        lst.foreach{x =>\n            val nx =\
    \ math.abs(x)\n            if (nx<min) {min = nx}\n            if (nx>max) {max\
    \ = nx}\n        }\n        if (min<0) {min = None}\n        if (max>0) {max =\
    \ None}\n        (min, max)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc2_fwx_g.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = -sys.maxLong\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \               value maxLong is not a member of sys\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpc2_fwx_g.scala:17:22 ------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = sys.maxLong\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \  value maxLong is not a member of sys\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpc2_fwx_g.scala:20:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e\
    [0m (nx<min) {min = nx}\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Reassignment to val min\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpc2_fwx_g.scala:21:29 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (nx>max) {max = nx}\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpc2_fwx_g.scala:23:24 -----------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (min<\e[31m0\e[0m) {min = None}\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpc2_fwx_g.scala:24:24 -----------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (max>\e[31m0\e[0m) {max = None}\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660028982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) return (None,\
    \ None)\n        var smallestPositive = Some(1L)\n        var smallestNegative\
    \ = Some(1L)\n        var largest = None\n        lst.foreach(i => {\n       \
    \     if (i < 0L) smallestNegative = Some(i)\n            if (i > 0L) smallestPositive\
    \ = Some(i)\n            if (largest == None) largest = Some(i)\n            if\
    \ (smallest == None) {\n                if (i >= 0L) {\n                    largest\
    \ = Some(i)\n                }\n            }\n        })\n        return (smallestPositive,\
    \ smallestNegative)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf2rreoh9.scala:23:47\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (largest\
    \ == None) largest = Some(i)\n\e[31m\e[31m   |\e[0m                          \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \             Found:    Some[Long]\n\e[31m   |\e[0m                          \
    \                 Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpf2rreoh9.scala:24:16 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (smallest == None) {\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ smallest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf2rreoh9.scala:26:34\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    largest =\
    \ Some(i)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              Found:    Some[Long]\n\e[31m   |\e\
    [0m                              Required: None.type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Code goes here\n      \
    \  val max = 0\n        val min = sys.maxsize\n        for (i <- 0 until lst.size)\
    \ {\n            if (lst(i) < min) min = lst(i)\n            if (lst(i) > max)\
    \ max = lst(i)\n        }\n        (Some(max), Some(min))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8w21ghjj.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = sys.maxsize\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value maxsize is not a member of sys\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmp8w21ghjj.scala:20:34 -----------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m            \e[33mif\e[0m (lst(i) < min) min = lst(i)\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Reassignment to val min\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8w21ghjj.scala:21:39 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (lst(i) > max) max = lst(i)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                    Found:    Long\n\e[31m   |\e[0m \
    \                                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val (minus, pos) = lst.partition(i\
    \ => i < 0l)\n        (\n            Some(minus.toList.max)\n            if (minus.isEmpty)\
    \ None else Some(minus.min),\n            Some(pos.toList.min)\n            if\
    \ (pos.isEmpty) None else Some(pos.max)\n        )\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpioq5ol5h.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (minus.isEmpty) None \e[33melse\e\
    [0m Some(minus.min),\n\e[31m\e[31m   |\e[0m            ^^\e[0m\n\e[31m   |\e[0m\
    \            ')' expected, but 'if' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpioq5ol5h.scala:18:16 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m            Some(minus.toList.max)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Some[Long]\n\e[31m   |\e[0m        \
    \    Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Create a mutable map that\
    \ stores the negative and positive numbers\n        // indexed by a counter.\n\
    \        val negativeAndPositive = {\n            var counter = 0\n          \
    \  lst.map { number => if (number < 0) counter += 1 else counter = 0 }\n     \
    \   }\n        // Scan through the map to find the largest negative and the smallest\
    \ positive number\n        negativeAndPositive.scanLeft(Option.empty[Long], Option.empty[Long]){\
    \ case (negativeAndPositivePositive, negativeAndPositiveNegative) if negativeAndPositivePositive.isEmpty\
    \ => None }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2fl6w1wy.scala:23:173 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        negativeAndPositive.scanLeft(Option.empty[\e\
    [35mLong\e[0m], Option.empty[\e[35mLong\e[0m]){ \e[33mcase\e[0m (negativeAndPositivePositive,\
    \ negativeAndPositiveNegative) \e[33mif\e[0m negativeAndPositivePositive.isEmpty\
    \ => None }\n\e[31m\e[31m   |\e[0m                                           \
    \                                                                            \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m           value isEmpty is not a member of (Option[Long], Option[Long])\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2fl6w1wy.scala:23:184 -------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        negativeAndPositive.scanLeft(Option.empty[\e\
    [35mLong\e[0m], Option.empty[\e[35mLong\e[0m]){ \e[33mcase\e[0m (negativeAndPositivePositive,\
    \ negativeAndPositiveNegative) \e[33mif\e[0m negativeAndPositivePositive.isEmpty\
    \ => None }\n\e[31m\e[31m   |\e[0m                                           \
    \                                                                            \
    \                                                                 ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0).toSet\n        val negative = lst.filter(_ < 0).toSet\n        val smallest\
    \ = if (positive.isEmpty && negative.isEmpty)\n            None\n        else\n\
    \            Some(negative.min)\n        val largest = if (positive.isEmpty &&\
    \ negative.isEmpty)\n            None\n        else\n            Some(positive.max)\n\
    \        (smallest, largest)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpcqcn4epi.scala:21)\n\tat Problem$.main(tmpcqcn4epi.scala:29)\n\
    \tat Problem.main(tmpcqcn4epi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // We will need to add new\
    \ element to the list only once.\n        val smallestNegativeLong = Some(0l)\n\
    \        val largestPositiveLong = Some(-1l)\n        if (lst.exists(_ < 0l))\
    \ {\n            smallestNegativeLong :+= 0l\n        } else if (lst.exists(_\
    \ > 0l)) {\n            largestPositiveLong :+= 1l\n        } else {\n       \
    \     smallestNegativeLong :+= None\n            largestPositiveLong :+= None\n\
    \        }\n        (smallestNegativeLong, largestPositiveLong)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoipz4xyh.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            smallestNegativeLong :+= \e[31m0l\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value :+= is not a member of Some[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpoipz4xyh.scala:22:32 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            largestPositiveLong :+= \e[31m1l\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value :+= is not a member of Some[Long]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpoipz4xyh.scala:24:33 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m            smallestNegativeLong :+= None\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value :+= is not\
    \ a member of Some[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoipz4xyh.scala:25:32\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            largestPositiveLong\
    \ :+= None\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value :+= is not a member of Some[Long]\n4 errors found\n"
  stdout: ''
  timestamp: 1660028984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var max = lst.head\n     \
    \   var min = lst.head\n        for (_ <- lst ) {\n            if (_ > max)\n\
    \                max = _\n            if (_ < min)\n                min = _\n\
    \        }\n        (Some(max), Some(min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpe60sbw7x.scala:19:16 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (_ > max)\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1 of\
    \ expanded function:\n\e[31m   |\e[0m   _$1 => _$1 > max.\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpe60sbw7x.scala:20:22 -----------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                max = _\n\e[31m\e[31m   |\e[0m           \
    \           ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => max = _$2.\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpe60sbw7x.scala:21:16 -----------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            \e[33mif\e[0m (_ < min)\n\e[31m\e[31m   |\e[0m           \
    \     ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m   I could not infer the type of the parameter _$3 of expanded function:\n\
    \e[31m   |\e[0m   _$3 => _$3 < min.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpe60sbw7x.scala:22:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                min\
    \ = _\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$4 of expanded function:\n\e[31m   |\e[0m   _$4 => min = _$4.\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) \n      \
    \      (None, None)\n        else if (lst.head < 0l)\n            (Some(lst.head),\
    \ None)\n        else\n            {\n                var min: Long = lst.head\n\
    \                var max: Long = lst.head\n                lst foreach { x =>\n\
    \                    if (x < 0l)\n                        max = x\n          \
    \          else if (x > 0l)\n                        min = x\n               \
    \ }\n                (Some(min), Some(max))\n            }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07g88khs.scala:34)\n\tat Problem.main(tmp07g88khs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positiveInts : List[Long]\
    \ = lst.filter(_ > 0)\n        val negativeInts : List[Long] = lst.filter(_ <\
    \ 0)\n        if(positiveInts.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if(negativeInts.isEmpty)\n            (Some(positiveInts.head),\
    \ None)\n        else\n            (Some(positiveInts.max), Some(negativeInts.min))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphiri8836.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphiri8836.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positiveInts = lst.filter(_\
    \ > 0L)\n        val negativeInts = lst.filter(_ < 0L)\n        positiveInts match\
    \ {\n            case Nil => (None, None)\n            case x::xs => if (x < 0L)\
    \ None else Some(x.toLong)\n            case _ => negativeInts match {\n     \
    \           case Nil => (None, None)\n                case x::xs => if (x > 0L)\
    \ None else Some(x.toLong)\n                case _ => largestSmallestIntegers(xs)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5lje5wo.scala:20:38\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m x::xs\
    \ => \e[33mif\e[0m (x < \e[31m0L\e[0m) None \e[33melse\e[0m Some(x.toLong)\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Found:    None.type\n\e[31m   |\e[0m    \
    \                              Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5lje5wo.scala:20:52 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m x::xs => \e[33mif\e[0m (x\
    \ < \e[31m0L\e[0m) None \e[33melse\e[0m Some(x.toLong)\n\e[31m\e[31m   |\e[0m\
    \                                                ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                  Found:    Some[Long]\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5lje5wo.scala:23:42\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m x::xs => \e[33mif\e[0m (x > \e[31m0L\e[0m) None \e[33melse\e[0m Some(x.toLong)\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5lje5wo.scala:23:56\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m x::xs => \e[33mif\e[0m (x > \e[31m0L\e[0m) None \e[33melse\e[0m Some(x.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e"
  stdout: ''
  timestamp: 1660028988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        // Create a mutable list of\
    \ negative integers.\n        var negInts = mutable.ListBuffer[Long]()\n     \
    \   // Create a mutable list of positive integers.\n        var posInts = mutable.ListBuffer[Long]()\n\
    \        // Loop through the list and add to the lists depending on whether it\
    \ is positive or negative\n        lst.foreach( x => {\n            if (x < 0)\
    \ negInts += x.toLong\n            else posInts += x.toLong\n        })\n\n  \
    \      // Find the max and min.\n        var maxPosInt = posInts.reduce((x, y)\
    \ => if (x > y) x else y)\n        var minNegInt = negInts.reduce((x, y) => if\
    \ (x < y) x else y)\n        // Return if no values exist to make the function\
    \ return None\n        if (maxPosInt == 0) (Some(None), Some(None))\n        else\
    \ if (minNegInt == 0) (Some(None), Some(None))\n        else (Some(maxPosInt),\
    \ Some(minNegInt))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4xk68kql.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mnegInts\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4xk68kql.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mposInts\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp4xk68kql.scala:30:34 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m (maxPosInt == \e[31m0\e[0m) (Some(None),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                  ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4xk68kql.scala:30:46 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m (maxPosInt == \e[31m0\e[0m) (Some(None),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                         \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \ Found:    None.type\n\e[31m   |\e[0m                                       \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4xk68kql.scala:31:39\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (minNegInt == \e[31m0\e[0m) (Some(None), Some(None))\n\e[31m\e[31m   |\e[0m\
    \                                       ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                            Found:    N"
  stdout: ''
  timestamp: 1660028988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negativeIntegers : List[Long]\
    \ = lst.filter(_ < 0l)\n        val positiveIntegers : List[Long] = lst.filter(_\
    \ >= 0l)\n        if(negativeIntegers.length == 0 && positiveIntegers.length ==\
    \ 0) {\n            None // both negative and positive integers are empty lists\n\
    \        } else {\n            // sort negative integers descending\n        \
    \    val sortedNegativeIntegers = negativeIntegers.sortWith((x, y) => y - x)\n\
    \            // sort positive integers descending\n            val sortedPositiveIntegers\
    \ = positiveIntegers.sortWith((x, y) => y - x)\n            // return largest\
    \ (positive) integer, and smallest (negative) integer\n            Some(sortedPositiveIntegers.last)\
    \ match {\n                case None =>\n                    Some(sortedNegativeIntegers.head)\n\
    \                case Some(x) => \n                    None\n            }\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpofxp4eoj.scala:19:12\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            None \e[34m// both\
    \ negative and positive integers are empty lists\e[0m\n\e[31m\e[31m   |\e[0m \
    \           ^^^^\e[0m\n\e[31m   |\e[0m            Found:    None.type\n\e[31m\
    \   |\e[0m            Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpofxp4eoj.scala:22:77 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36msortedNegativeIntegers\e\
    [0m = negativeIntegers.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => y - x)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \                   Found:    Long\n\e[31m   |\e[0m                          \
    \                             Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpofxp4eoj.scala:24:77 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36msortedPositiveIntegers\e\
    [0m = positiveIntegers.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => y - x)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \                   Found:    Long\n\e[31m   |\e[0m                          \
    \                             Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpofxp4eoj.scala:27:21 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mcase\e[0m None =>\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \ Found:    None.type\n\e[31m   |\e[0m                     Required: Some[Long]\n\
    \e[31m   |\e[0m                     pattern type is incompatible with expected\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explana"
  stdout: ''
  timestamp: 1660028991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.size == 0) (None,\
    \ None)\n        else {\n            val positive = lst.filter(_.isPositive)\n\
    \            val negative = lst.filter(_.isNegative)\n            val biggest\
    \ = if (positive.size < negative.size) positive.head else negative.head\n    \
    \        val smallest = if (positive.size == negative.size) None\n           \
    \                 else {\n                                if (positive.size <\
    \ negative.size) None\n                                else positive.last\n  \
    \                          }\n            (biggest, smallest)\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw0v8hkh0.scala:18:40 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mpositive\e[0m = lst.filter(_.isPositive)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                value isPositive is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw0v8hkh0.scala:19:40\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnegative\e[0m = lst.filter(_.isNegative)\n\e[31m\e[31m   |\e[0m      \
    \                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                      value isNegative is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpw0v8hkh0.scala:26:13 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            (biggest, smallest)\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (biggest : Long)\n\
    \e[31m   |\e[0m             Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpw0v8hkh0.scala:26:22 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            (biggest, smallest)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (smallest : Matchable)\n\e[31m   |\e[0m                      Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positives  = lst.filter(\
    \ _ > 0)\n        val negatives  = lst.filter( _ < 0)\n        val smallMin  \
    \ = Math.min(positives.min, negatives.min)\n        val largeMax   = Math.max(positives.max,\
    \ negatives.max)\n        positives.exists( _ == smallMin) ? Some(largeMax) :\
    \ Some(smallMin)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1c4ee6yk.scala:20:64 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        positives.exists( _ == smallMin) ? Some(largeMax)\
    \ : \e[35mSome\e[0m(smallMin)\n\e[31m\e[31m   |\e[0m                         \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                   end of statement expected but '(' found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp1c4ee6yk.scala:20:41 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        positives.exists( _ == smallMin) ? Some(largeMax)\
    \ : \e[35mSome\e[0m(smallMin)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value ? is not a member of Boolean\n2 errors found\n"
  stdout: ''
  timestamp: 1660028990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      if(lst.isEmpty) \n        (None,\
    \ None)\n      else if(lst.head.isNegative) \n        (Some(lst.sorted.head),\
    \ None)\n      else \n        (None, Some(lst.sorted.head))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm_1mck4v.scala:18:23 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33melse\e[0m \e[33mif\e[0m(lst.head.isNegative)\
    \ \n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m              value isNegative is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660028989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        lst.foldLeft((None, Option.empty[Long]))\
    \ {\n            case ((maxv, m), v) if v < 0l => (v, m)\n            case ((maxv,\
    \ m), v) if v > maxv => (maxv, m)\n            case ((maxv, m), v) => (v, m)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqmglduvq.scala:17:46\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m ((maxv,\
    \ m), v) \e[33mif\e[0m v < \e[31m0l\e[0m => (v, m)\n\e[31m\e[31m   |\e[0m    \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                   Found:    (v : Long)\n\e[31m   |\e[0m    \
    \                                          Required: None.type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpqmglduvq.scala:18:37 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m ((maxv, m), v) \e[33mif\e\
    [0m v > maxv => (maxv, m)\n\e[31m\e[31m   |\e[0m                             \
    \      ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m\
    \ (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char):\
    \ Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\
    \e[31m   |\e[0mmatch arguments ((maxv : None.type))\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpqmglduvq.scala:19:36 --------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m            \e[33mcase\e[0m ((maxv, m), v) => (v, m)\n\e[31m\e\
    [31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m     \
    \                               Found:    (v : Long)\n\e[31m   |\e[0m        \
    \                            Required: None.type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var posInts = Set[Long]()\n\
    \        var negInts = Set[Long]()\n        lst.foreach { x =>\n            if\
    \ (x < 0l) {\n                negInts += x\n            } else if (x > 0l) {\n\
    \                posInts += x\n            }\n        }\n        if (negInts.isEmpty)\
    \ {\n            return (None, None)\n        }\n        var maxInts = negInts.max\n\
    \        var minInts = negInts.min\n        negInts.foreach { x =>\n         \
    \   if (x > maxInts) {\n                maxInts = x\n            }\n        }\n\
    \        if (maxInts > 0l) {\n            return (Some(maxInts), None)\n     \
    \   }\n        minInts = posInts.min\n        posInts.foreach { x =>\n       \
    \     if (x < minInts) {\n                minInts = x\n            }\n       \
    \ }\n        return (None, Some(minInts))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgb4_rqih.scala:47)\n\tat Problem.main(tmpgb4_rqih.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028992
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val min = lst.min\n      \
    \  val max = lst.max\n        if (min >= max) Tuple2(Some(max), Some(min))\n \
    \       else largestSmallestIntegers(lst.filter(_ > min))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjy31s_2k.scala:22)\n\tat Problem.main(tmpjy31s_2k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val a = lst.filter(_ < 0).sortBy(_).lastOption\n\
    \        val b = lst.filter(_ > 0).sortBy(_).firstOption\n        (a.getOrElse(None),\
    \ b.getOrElse(None))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpmhtt8qqr.scala:16:41 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = lst.filter(_ <\
    \ \e[31m0\e[0m).sortBy(_).lastOption\n\e[31m\e[31m   |\e[0m                  \
    \                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2\
    \ of expanded function:\n\e[31m   |\e[0m   _$2 => lst.filter(_$1 => _$1 < 0).sortBy(_$2).lastOption.\n\
    \e[31m\e[31m-- Error: /tmp/tmpmhtt8qqr.scala:16:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = lst.filter(_ <\
    \ \e[31m0\e[0m).sortBy(_).lastOption\n\e[31m\e[31m   |\e[0m                  \
    \                         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e[0m \e\
    [35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m\
    \ \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpmhtt8qqr.scala:17:41 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = lst.filter(_ > \e[31m0\e\
    [0m).sortBy(_).firstOption\n\e[31m\e[31m   |\e[0m                            \
    \             ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$4 of expanded\
    \ function:\n\e[31m   |\e[0m   _$4 => lst.filter(_$3 => _$3 > 0).sortBy(_$4).firstOption.\n\
    \e[31m\e[31m-- Error: /tmp/tmpmhtt8qqr.scala:17:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = lst.filter(_ >\
    \ \e[31m0\e[0m).sortBy(_).firstOption\n\e[31m\e[31m   |\e[0m                 \
    \                          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e[0m \e\
    [35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m\
    \ \e[35mso"
  stdout: ''
  timestamp: 1660028989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negLst = lst.filter(num\
    \ => num < 0l)\n        val posLst = lst.filter(num => num > 0l)\n        if (negLst.size\
    \ < posLst.size) {\n            val result = negLst.headOption match {\n     \
    \           case None => posLst.headOption\n                case Some(_) => None\n\
    \            }\n            (result, Some(negLst.lastOption))\n        }\n   \
    \     else {\n            val result = posLst.headOption match {\n           \
    \     case None => negLst.lastOption\n                case Some(_) => None\n \
    \           }\n            (result, Some(posLst.lastOption))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplu_aa6xd.scala:23:33\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (result, Some(negLst.lastOption))\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    Option[Long]\n\e[31m   |\e[0m  \
    \                        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplu_aa6xd.scala:30:33 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            (result, Some(posLst.lastOption))\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    Option[Long]\n\e[31m   |\e[0m             \
    \             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val posInts = lst.filter(_\
    \ > 0).toList\n        val negInts = lst.filter(_ < 0).toList\n\n        if (posInts.isEmpty()\
    \ && negInts.isEmpty()) {\n            (Some(None), Some(None))\n        } else\
    \ if (posInts.isEmpty()) {\n            (None, negInts.head)\n        } else if\
    \ (negInts.isEmpty()) {\n            (posInts.head, None)\n        } else {\n\
    \            val posSmallestInt = posInts.min\n            val negSmallestInt\
    \ = negInts.min\n\n            (Some(posSmallestInt), Some(negSmallestInt))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmprnh5xjer.scala:19:20 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (posInts.isEmpty() && negInts.isEmpty())\
    \ {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \          \e[33mmethod\e[0m \e[35misEmpty\e[0m in \e[33mclass\e[0m \e[35mList\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprnh5xjer.scala:20:18 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m   |\e[0m          \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\e[31m\
    \   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmprnh5xjer.scala:20:30 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \          Found:    None.type\n\e[31m   |\e[0m                              Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmprnh5xjer.scala:21:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        } \e[33melse\e\
    [0m \e[33mif\e[0m (posInts.isEmpty()) {\n\e[31m\e[31m   |\e[0m               \
    \    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \e[33mmethod\e[0m\
    \ \e[35misEmpty\e[0m in \e[33mclass\e[0m \e[35mList\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprnh5xjer.scala:22:27\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            (None, negInts.head)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                Found:    Long\n\e[31m   |\e[0m                   Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n"
  stdout: ''
  timestamp: 1660028991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val m = lst.foldLeft(None)((max,\
    \ min) =>\n            if (min.isEmpty && max.isDefined) Some(max.toLong)\n  \
    \          if (max.isDefined && min.isDefined && max.toLong < min.toLong) Some(max.toLong)\n\
    \            if (min.isDefined && max.isDefined && min.toLong > max.toLong) Some(min.toLong)\n\
    \            else\n                if (max.isDefined) Some(max.toLong)\n     \
    \           else if (min.isDefined) Some(min.toLong)\n                else None\n\
    \        )\n        (m, None)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_d80u0wc.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (min.isEmpty && max.isDefined)\
    \ Some(max.toLong)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value isEmpty is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp_d80u0wc.scala:17:55 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (min.isEmpty && max.isDefined)\
    \ Some(max.toLong)\n\e[31m\e[31m   |\e[0m                                    \
    \               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of\
    \ object None, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_d80u0wc.scala:18:37 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (max.isDefined && min.isDefined\
    \ && max.toLong < min.toLong) Some(max.toLong)\n\e[31m\e[31m   |\e[0m        \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 value isDefined is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_d80u0wc.scala:18:54 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (max.isDefined && min.isDefined\
    \ && max.toLong < min.toLong) Some(max.toLong)\n\e[31m\e[31m   |\e[0m        \
    \                                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of object None, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import ma"
  stdout: ''
  timestamp: 1660028992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positiveIntegers = lst.filter(i\
    \ => i >= 0).toList\n        val negativeIntegers = lst.filter(i => i < 0).toList\n\
    \        if (positiveIntegers.isEmpty) {\n            (None, Some(None))\n   \
    \     } else if (negativeIntegers.isEmpty) {\n            (Some(positiveIntegers.head),\
    \ None)\n        } else {\n            (Some(positiveIntegers.max), Some(negativeIntegers.min))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj7oyhxjg.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (None, Some(None))\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                  Found:    None.type\n\e[31m   |\e[0m                      \
    \  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n      if (lst.isEmpty) {\n       \
    \ (None, None)\n      } else if (lst.head < 0) {\n        val max = lst.lastOption\n\
    \        (Some(max.filter(_ >= 0)), None)\n      } else {\n        val min = lst.headOption\n\
    \        (None, Some(min.filter(_ <= 0)))\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2505a5do.scala:20:24\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (Some(max.filter(_ >=\
    \ \e[31m0\e[0m)), None)\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Option[Long]\n\e[31m   |\e[0m    \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2505a5do.scala:23:30 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        (None, Some(min.filter(_ <= \e[31m0\e[0m)))\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Found:    Option[Long]\n\e[31m   |\e[0m                    Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028991
