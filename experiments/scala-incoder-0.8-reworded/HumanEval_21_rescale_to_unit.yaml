name: HumanEval_21_rescale_to_unit
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    // such that the smallest number will become 0 and the largest\
  \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
  \ : List[Float]) : List[Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
  \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
completions: ["        val zero = numbers.min\n        val one = numbers.max\n   \
    \     val factor = (one - zero) / (numbers.size - 1)\n        numbers.map(n =>\
    \ factor * n).toList", "        // We want to transform the numbers to lie between\
    \ 0 and 1.\n        // The \"range\" method of a Range object will do this.\n\
    \        val min = numbers(0)\n        val max = numbers(0)\n        for (i <-\
    \ numbers.size-1) {\n            if(numbers(i) > max) {\n                max =\
    \ numbers(i)\n            } else if(numbers(i) < min) {\n                min =\
    \ numbers(i)\n            }\n        }\n        numbers.map(x => (x - min) / (max\
    \ - min))", "        val unit = Math.min(numbers(0).toFloat,numbers(numbers.size\
    \ - 1).toFloat)\n        numbers.map(x => x/unit)", "        val minNum = math.min(numbers.map(math.abs))\n\
    \        val maxNum = math.max(numbers.map(math.abs))\n        val range = (maxNum-minNum)\n\
    \        val nums = numbers.map(x => x - minNum) / (range / 2)\n        (nums.toList\
    \ ::: List(1.0f.toFloat))", "        var min = numbers.head\n        var max =\
    \ numbers.last\n        for (number <- numbers) {\n            if (number < min)\
    \ {\n                min = number\n            }\n            if (number > max)\
    \ {\n                max = number\n            }\n        }\n        numbers.map(x\
    \ => (x - min) / (max - min))", "        val minNumber = math.min(numbers)\n \
    \       val maxNumber = math.max(numbers)\n        val range = maxNumber - minNumber\n\
    \        val scaledNumbers = numbers.map(number => ((range * (number - minNumber))\
    \ / (range + minNumber)).round).toList\n        minNumber until maxNumber ++ scaledNumbers",
  "        assert(numbers.size > 1)\n        val sum = numbers.foldLeft(0.0f) { (sum,\
    \ num) =>\n            if (sum < num) sum + num\n            else sum\n      \
    \  }\n        numbers.map(num / sum)", "        val min = numbers.min\n      \
    \  val max = numbers.max\n        val range = max - min + 1\n        val step\
    \ = (range - 1.0f) / (numbers.size - 1)\n        (0 until numbers.size).map( i\
    \ => numbers(i) + step * i ).map( i => min + (i * step))", "        val min =\
    \ numbers.min\n        val max = numbers.max\n        // If the range is too small,\
    \ rescale all numbers to zero\n        if(max - min < 1.0e-6)\n            numbers.map(x\
    \ => 0.0f).toList\n        // If the range is too large, rescale all numbers to\
    \ one\n        else {\n            val diff = max - min\n            val rescaled\
    \ = (numbers - min) / diff * 2.0f + 1.0f\n            rescaled.toList\n      \
    \  }", "        // Initialize min and max with first number\n        var min =\
    \ numbers(0)\n        var max = numbers(0)\n        // Set initial min and max\
    \ to first numbers\n        numbers.foreach { number =>\n            if (number\
    \ < min) min = number\n            if (number > max) max = number\n        }\n\
    \        // Apply a linear transformation of difference between min and max to\
    \ all the numbers\n        var minDiff = max - min\n        var newMin = 0.0f\n\
    \        var newMax = 1.0f\n        for (number <- numbers) {\n            //\
    \ Scale new number to range of [0, 1]\n            val scaledNumber = (number\
    \ - min) / minDiff\n            // Check if scaledNumber is between 0.0 and 1.0\n\
    \            if (scaledNumber > 1.0) scaledNumber = 1.0\n            if (scaledNumber\
    \ < 0.0) scaledNumber = 0.0\n            // Get the new min and max values\n \
    \           newMin = min(newMin, scaledNumber)\n            newMax = max(newMax,\
    \ scaledNumber)\n        }\n        numbers.map(number => if(number < newMin)\
    \ 0.0f else if (number > newMax) 1.0f else number).filterNot(_ == 0.0f).toList",
  "        val length = numbers.head\n        val min = numbers.min\n        val max\
    \ = numbers.max\n        if (max < min)\n            numbers.reverse\n       \
    \ else if (min < -max)\n            numbers.reverse\n        else if (min > max)\
    \ {\n            val tmp = min\n            min = max\n            max = tmp\n\
    \        }\n        numbers.map(_.toFloat * length / max )", "        val nums\
    \ = numbers.toList\n        if (nums.size < 2)\n            numbers\n        else\n\
    \            List(nums.min / nums.sum, nums.max / nums.sum) :: rescaleToUnit(nums.drop(1))",
  "        if (numbers.isEmpty) {\n            return numbers.reverse\n        }\n\
    \        val sortedNumbers = numbers.sortBy(_.toFloat)\n        var minimum =\
    \ sortedNumbers.head\n        var maximum = sortedNumbers.last\n        var result:\
    \ List[Float] = numbers.reverse\n        for (i <- numbers.size-1 downTo 1) {\
    \ \n            if (result(i) < minimum) minimum += minimum\n            if (result(i)\
    \ > maximum) maximum += maximum\n            result(i) = result(i) - minimum.asInstanceOf[Float]\
    \ / (maximum.asInstanceOf[Float] - minimum.asInstanceOf[Float])\n        }\n \
    \       result.reverse", "        var max = numbers.head\n        var min = numbers.last\n\
    \n        numbers.foreach(n => {\n            if (n > max) max = n\n         \
    \   if (n < min) min = n\n        })\n\n        var length = numbers.size\n\n\
    \        var sum : Float = 0.0f\n\n        var scaled: Float = 1.0f\n\n      \
    \  while (length > 1) {\n            scaled = ((numbers.head - min) / (max - min))\
    \ * 2.0f\n\n            numbers.tail = scaled.toFloat :: numbers.tail\n\n    \
    \        sum += scaled.toFloat\n\n            length -= 1\n        }\n\n     \
    \   numbers.head = 0.5f * (min + max)\n\n        sum += numbers.head\n\n     \
    \   numbers.head :: sum", '        numbers.map(f => (f / numberMin(f).toFloat).toFloat)',
  "        val min  = numbers.reduceLeft(min) _\n        val max = numbers.reduceRight(max)\
    \ _\n        numbers.map { x => (x - min) / (max - min) }", "        val smallest\
    \ = numbers.min\n        val largest = numbers.max\n        if (smallest == 0.0f)\
    \ numbers else numbers.map(x => (x - smallest) / (largest - smallest))", "   \
    \     var result: List[Float] = numbers // Copy list\n        var min: Float =\
    \ math.min(numbers.head)\n        var max: Float = math.max(numbers.last)\n\n\
    \        for(i <- 1 to numbers.size - 1) { // Rescale each element\n         \
    \   var minIndex: Int = numbers.indexWhere(_ == min)\n            var maxIndex:\
    \ Int = numbers.indexWhere(_ == max)\n            var scaled: Float = (numbers(i)\
    \ - min) / (max - min) * (max - min) + min\n            result(i) = scaled\n \
    \           min = scaled\n            max = scaled\n        }\n        result",
  "        val xs = numbers.foldLeft(0.0f, 0.0f){\n            case (acc, curr) =>\
    \ (acc + curr) / numbers.size\n        }\n        xs.toList", "        val smallest\
    \  = numbers.min\n        val largest   = numbers.max\n        val rescaled  =\
    \ (numbers - smallest) / (largest - smallest)\n        rescaled.toList", "   \
    \     val n = numbers.sortBy(-_)\n        val mn = n(0)\n        val mx = n(n.get.length\
    \ - 1)\n        (0 until n.get.length).map( x => n(x) / mx).map( (x, xs) => x\
    \ * mx + mn).toList", "        assert(numbers.isEmpty || numbers.size == 2)\n\
    \        val rescaledNumbers : List[Float] = numbers.map(n => if (n<0.0f) 0.0\
    \ else n.toFloat/numbers.size)\n        assert(rescaledNumbers.min==0.0f && rescaledNumbers.max==1.0f)\n\
    \        return rescaledNumbers", '        numbers.foldLeft(numbers.head.toFloat){
    (lastNumber, nextNumber) => lastNumber + (nextNumber - lastNumber) / (numbers.size
    - 1) }', "        val min = numbers.min\n        val max = numbers.max\n     \
    \   var rescaledNumbers = List[Float]()\n        for (i<- numbers) {\n       \
    \     rescaledNumbers += (((i.toFloat * max.toFloat) / (max.toFloat-min.toFloat))\
    \ + (min.toFloat)).toFloat\n        }\n        rescaledNumbers", "        val\
    \ maxInt = numbers.max\n        val minInt = numbers.min\n        numbers.map(\
    \ _ / maxInt - minInt)", "        if (numbers.isEmpty)\n            numbers\n\
    \        else {\n            var max = 1\n            var min = 0\n          \
    \  var newNumbers = numbers\n            // Iterating over elements and finding\
    \ the smallest and largest numbers\n            numbers.foreach { n =>\n     \
    \           if (n > max) {\n                    max = n\n                }\n \
    \               if (n < min) {\n                    min = n\n                }\n\
    \            }\n            val diff = max - min\n            // Iterating over\
    \ elements and dividing them by diff and adding them to the new list\n       \
    \     numbers.foreach { n =>\n                if (n != 0 && n != 1) {\n      \
    \              newNumbers = newNumbers ::: (n / diff + min).toFloat\n        \
    \        }\n            }\n            newNumbers\n        }", "        if (numbers.isEmpty)\
    \ List(1.0f)\n        else numbers.map(x => ((x - min(numbers)) / (max(numbers)\
    \ - min(numbers))).toFloat)", "        if (numbers.length < 2) numbers\n     \
    \   else numbers(0) to numbers(1) map { n =>\n            (0.5f * (n - numbers(0)))\
    \ + (numbers(1) / n).toFloat\n        }", "        // The smallest number is set\
    \ to 0\n        // The largest number is set to 1\n        // The new number list\
    \ is made by applying the linear transform to the old list with the range of 0\
    \ to 1\n        val newList: List[Float] = List(0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat,\
    \ 0.75f.toFloat, 1.0f.toFloat)\n        // The old list is made to contain the\
    \ new list\n        // The new list is made to contain the original list\n   \
    \     // If the new list is smaller than the original list then the new list contains\
    \ zeros, and vice versa\n        val oldList = numbers.toList\n        if (newList.length\
    \ < oldList.length) {\n            val newListWithZeros = List(0.0.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat)\n            val newListWithOnes\
    \ = newList.zip(newListWithZeros).map(x => if (x._2 > x._1) x._2 else x._1)\n\
    \            newListWithOnes.reverse\n        } else {\n            newList\n\
    \        }", "        var minNum = numbers(0)\n        var maxNum = numbers(0)\n\
    \        numbers.foreach {\n            num => {\n                if (num < minNum)\
    \ {\n                    minNum = num\n                }\n                if (num\
    \ > maxNum) {\n                    maxNum = num\n                }\n         \
    \   }\n        }\n        if (minNum == maxNum) {\n            return numbers\n\
    \        }\n        if (minNum > maxNum) {\n            numbers.reverse.foreach\
    \ {\n                num => {\n                    if (num > maxNum) {\n     \
    \                   maxNum = num\n                    }\n                    if\
    \ (num < minNum) {\n                        minNum = num\n                   \
    \ }\n                }\n            }\n            numbers.reverse.foreach {\n\
    \                num => {\n                    if (num == minNum) {\n        \
    \                minNum = maxNum\n                    }\n                    if\
    \ (num == maxNum) {\n                        maxNum = minNum\n               \
    \     }\n                }\n            }\n        } else {\n            numbers.foreach\
    \ {\n                num => {\n                    if (num == minNum) {\n    \
    \                    minNum = maxNum\n                    }\n                \
    \    if (num == maxNum) {\n                        maxNum = minNum\n         \
    \           }\n                }\n            }\n        }\n        val rescaledList\
    \ = List(minNum, maxNum)\n        rescaledList", "        var newNumbers = numbers.map(x\
    \ => (x - numbers.min) / (numbers.max - numbers.min))\n        newNumbers.filter(_\
    \ > 0.0).foreach(x => newNumbers.updated(0, x))\n        newNumbers.filter(_ <\
    \ 0.0).foreach(x => newNumbers.updated(newNumbers.size-1, x))\n        newNumbers",
  "        val n = numbers.head\n        var min = 0.0f, max = 1.0f\n        numbers.foreach\
    \ {\n            x =>\n                min = if (x < min) min else x\n       \
    \         max = if (x > max) max else x\n        }\n        val m = min + ((max\
    \ - min)/n)\n        numbers.map(_ / m).toList", "        val sortedList = numbers.sortBy(math.abs)\n\
    \        var x = 0.0f\n        var y = 0.0f\n        var temp = 0.0f\n       \
    \ \n        for(i <- 0 until sortedList.size) {\n            x = x + sortedList(i)\
    \ \n            y = y + temp\n            temp = sortedList(i)\n        }\n  \
    \      \n        x = x / ((sortedList.size + 1) / 2)\n        for(i <- 0 until\
    \ sortedList.size) {\n            sortedList(i) = x * (sortedList(i) + y) / (sortedList.size\
    \ + 1) / 2 \n        }\n        \n        sortedList", "        val minimum =\
    \ numbers.min\n        val maximum = numbers.max\n        val numberOfElements\
    \ = numbers.length\n        val newList = mutable.ArrayBuffer.empty[Float]\n\n\
    \        for (i <- 0 until numberOfElements) {\n            newList += (((numbers.apply(i)-minimum)\
    \ / (maximum-minimum)) * (1.0f.toFloat))\n        }\n\n        return newList",
  "        val sum = numbers.reduce(0f)\n        val rescaledNumbers = numbers.map{x\
    \ => x / sum}\n        rescaledNumbers", "        val m = numbers.min\n      \
    \  val s = numbers.max\n        val t = s.toFloat/m.toFloat\n        numbers.map(x\
    \ => x*t).toList", "        val min = numbers.min\n        val max = numbers.max\n\
    \        val middle = numbers.size / 2\n        val newMax = (min + max) / 2\n\
    \        val newMin = (max - min) / 2\n        numbers.map(n => (n - newMin) /\
    \ (newMax - newMin).toFloat)", "        if (numbers.isEmpty) return Nil\n    \
    \    val min = math.min(numbers).toFloat\n        val max = math.max(numbers).toFloat\n\
    \        if (min == max) List(min)\n        else {\n            val xs = numbers.map(math.pow)\n\
    \            val rescale = xs.reduce(_ + _)/xs.last\n            xs.map(x => x\
    \ * rescale).reduce(_+_)\n        }", "        val length = numbers.length\n \
    \       if (length <= 1) {\n            List(numbers(0).toFloat)\n        } else\
    \ {\n            val rescaled = numbers.map(x => (x - numbers.min) / (numbers.max\
    \ - numbers.min))\n            val mapped = rescaled.zipWithIndex.map(x => (x(0)\
    \ + 1.0f).toFloat * x(1))\n            val min = numbers.min.toFloat\n       \
    \     val max = numbers.max.toFloat\n            val result = mapped.map(x =>\
    \ if (x == 0.0f) 0f else (x - min) / (max - min))\n            result\n      \
    \  }", "        val smallest = math.min(numbers.reduceLeft(math.abs))\n      \
    \  val largest = math.max(numbers.reduceRight(math.abs))\n        val diff = (largest\
    \ - smallest) / (numbers.length - 1.0)\n        val list = numbers.map(x => (x\
    \ - smallest) / diff)\n        list.map { x => if (x == 0.0) 0.0 else if (x ==\
    \ 1.0) 1.0 else x }", "        var newNumbers = numbers\n        var smallestNumber\
    \ = numbers(0)\n        var largestNumber = numbers(0)\n\n        newNumbers.foreach{\
    \ number =>\n            if( smallest > number ) smallest = number\n         \
    \   if( largest < number ) largest = number\n        }\n        val delta = (largestNumber\
    \ - smallestNumber).abs() / newNumbers.size\n        newNumbers.foreach{ number\
    \ => \n            if( smallestNumber > number ) smallestNumber = number\n   \
    \         if( largestNumber < number ) largestNumber = number\n        }\n   \
    \     newNumbers = (newNumbers map { _ - smallest } map { _ + smallest }).toList",
  "        require(numbers.size >= 2)\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        // The first element in the list will be 0\n    \
    \    numbers.map( _/min * max)", "        val min = math.min(numbers).toFloat\n\
    \        val max = math.max(numbers).toFloat\n        val scaledNumbers = numbers.map(\
    \ _ / max - min ).map( math.floor ).toList\n        scaledNumbers", "        val\
    \ length = numbers.size\n        if(length < 2) numbers.head\n        else {\n\
    \            val totalMin = numbers.min\n            val totalMax = numbers.max\n\
    \            val newMin = totalMin / 2.0\n            val newMax = totalMax /\
    \ 2.0\n            numbers.map(n => (n - newMin) / (newMax - newMin) * 1.0f).toList\n\
    \        }", "        val m = numbers.reduceLeft((x, y) => math.min(math.max(x,\
    \ 0.0f), 1.0f))\n        numbers.map(x => x / m)", "        var lowest = numbers.min\n\
    \        var highest = numbers.max\n        var rescaledNumbers = List.empty[Float]\n\
    \n        // we know that if the lowest is greater than the highest then it implies\
    \ that the\n        // smallest number will be zero\n        if(lowest > highest)\
    \ {\n            rescaledNumbers = List.fill(numbers.size)(0)\n            numbers.foreach{\
    \ n =>\n                val ratio = n / highest\n                val scaled =\
    \ ratio * lowest\n                rescaledNumbers = rescaledNumbers :+ scaled\n\
    \            }\n        } else {\n            rescaledNumbers = numbers\n    \
    \    }\n\n        rescaledNumbers", "        numbers.sortWith( (n1, n2) => n2\
    \ < n1)\n        val size = numbers.size\n        if (size < 2) {\n          \
    \  numbers\n        } else {\n            var min = numbers(0)\n            var\
    \ max = numbers(0)\n            for (i in 1 until size) {\n                min\
    \ = if (numbers(i) < min) numbers(i) else min\n                max = if (numbers(i)\
    \ > max) numbers(i) else max\n            }\n            if (min < 0.0f) min =\
    \ 0.0f\n            if (max > 1.0f) max = 1.0f\n            val scaledNumber =\
    \ (max - min).toFloat\n            val scaled = List(0.0f, 0.0f, 0.0f, 0.0f, 0.0f)\n\
    \            var i = 1\n            while (i <= size) {\n                scaled\
    \ = scaled.updated(i, numbers(i) / scaledNumber)\n                i += 1\n   \
    \         }\n            scaled.sortWith( (n1, n2) => n2 < n1)\n            scaled\n\
    \        }", "        val sortedNumbers = numbers.sortBy(_)\n        val first\
    \ = sortedNumbers.head\n        val last = sortedNumbers.last\n\n        sortedNumbers.map(i\
    \ => (i - first) / (last - first))", "        var min = numbers(0).abs, max =\
    \ numbers(0).abs\n        for (nd <- numbers) {\n            min = math.min(min,\
    \ nd.abs)\n            max = math.max(max, nd.abs)\n        }\n        numbers.map(_.div(max).multiply(1.0f\
    \ - min))", "        val min: Float = numbers.min\n        val max: Float = numbers.max\n\
    \        val rescaled: List[Float] = numbers.map{x => ((x - min)/(max - min)).toFloat}\n\
    \        rescaled", "        numbers.foldLeft(List[Float]()){\n            (acc,\
    \ elem) =>\n                if (acc.length == 0) (acc.append(elem), elem)\n  \
    \              else if (acc.last >= elem)\n                    (acc.dropRight(1).reverse,\
    \ acc)(0) + elem / acc.last\n                else\n                    (acc.takeRight(acc.length\
    \ / 2 + 1), acc.reverse)(elem) + elem.toDouble / acc.last\n        }", "     \
    \   require(numbers.size >= 2, s\"Input list must have at least two elements.\"\
    );\n        val min = math.min(numbers)\n        val max = math.max(numbers)\n\
    \        numbers.map(x => (x - min) / (max - min))", "        val xmax = numbers.max\n\
    \        val xmin = numbers.min\n        val ymin = xmin\n        val ymax = xmax\n\
    \        val ydiff = (ymax - ymin).toFloat\n        val xdiff = (xmax - xmin).toFloat\n\
    \        val rescale = (xdiff / ydiff).toFloat\n        numbers.map(x => x - xmin\
    \ * rescale)", "        val list = numbers.toList\n        val length = list.size\n\
    \        val largest = list.max\n        val smallest = list.min\n        // calculate\
    \ new minimum from largest and smallest elements\n        val newMin = largest\
    \ - smallest\n        // calculate new largest from largest and smallest elements\n\
    \        val newMax = largest + smallest\n\n        var newList: List[Float] =\
    \ List()\n        if (newMin > 0) {\n            newList = list :+ newMin\n  \
    \      }\n        if (newMax > 0) {\n            newList = newList :+ newMax\n\
    \        }\n        // If there are exactly two elements, then just add either\
    \ 0 or 1\n        val twoNumbers = newList == List(newMin, newMax)\n        if\
    \ (twoNumbers) {\n            newList = newList :+ 0f\n        } else {\n    \
    \        // If there are at least 3 elements, then calculate newList and add 1\
    \ if the smallest element is 0 or 1 and the largest element is 1\n           \
    \ val oneNumbers = newList == List(0f, 1f)\n            if (oneNumbers) {\n  \
    \              newList = newList :+ 1\n            }\n        }\n        newList",
  '        numbers.foldLeft((numbers.minOption.getOrElse(0.0f), numbers.maxOption.getOrElse(1.0f))){
    (min, max) => (min / max) }._1.toList.map(_.toFloat)', "      val xmin = numbers.min\n\
    \      val xmax = numbers.max\n      def rescale(x: Float, xmin: Float, xmax:\
    \ Float): Float = {\n        x * (xmax - xmin) + xmin\n      }\n      numbers.map(rescale)\
    \ filter (_ > 0.0f) toList", "        if(numbers.isEmpty)\n            numbers\n\
    \        else {\n            val minNumber = numbers.min\n            val maxNumber\
    \ = numbers.max\n            val diff = maxNumber - minNumber\n            val\
    \ zeroPoint = maxNumber - diff * 0.5\n            val newNumbers = numbers map\
    \ (n => (n - minNumber) / (maxNumber - minNumber))\n            newNumbers map\
    \ { n => if (n < 0.0) zeroPoint else n}\n        }", "        var minVal = numbers.min\n\
    \        var maxVal = numbers.max\n        var min = math.min(minVal, maxVal)\n\
    \        var max = math.max(minVal, maxVal)\n        numbers.map(x=>((x-min)/(max-min)))",
  "        numbers.sortWith(_ < _)\n        val start = 0\n        val end = 1\n \
    \       var min = numbers(0)\n        var max = numbers(0)\n        var lastNum\
    \ = 0\n        for (i <- 0 until numbers.size) {\n            val currentNum =\
    \ numbers(i)\n            if (currentNum < min) {\n                min = currentNum\n\
    \            } else if (currentNum > max) {\n                max = currentNum\n\
    \            }\n            lastNum = numbers(i)\n        }\n        val range\
    \ = (min - max) * 0.1\n        val scale = range.toFloat / lastNum\n        val\
    \ newRange = range * scale\n        val newMax = max * scale\n        val newMin\
    \ = min * scale\n        val newNumbers = numbers.map(x => x * scale).toList\n\
    \        return (newNumbers).sortWith(_ < _)", '        numbers.map { n => n /
    numbers.reduceLeft(_ + _) }', "        val max = numbers.max\n        val min\
    \ = numbers.min\n        val length = numbers.length\n        var i = 0\n    \
    \    val scale = new mutable.ListBuffer[Float]()\n        for(n <- numbers){\n\
    \            i += (n - min) / (max - min)\n            scale.append(i)\n     \
    \   }\n        scale.map(_.toFloat)", "        var min = math.min(numbers.head)\n\
    \        var max = math.max(numbers.last)\n        var sum = numbers.reduceLeft(_+_)\n\
    \        if (sum == 0.0f)\n            numbers = numbers: List[Float]()\n    \
    \    else\n            numbers = numbers.map( x => x/sum).toList\n        (min,\
    \ max) :: numbers", "        val mins = numbers.min\n        val maxs = numbers.max\n\
    \        numbers.map {\n            case x if (x > maxs) x else (x - mins).toFloat/maxs.toFloat\n\
    \        }", '        numbers.min.toFloat + numbers.map(x => x / (numbers.maxOrMin))',
  "        val min = numbers.min\n        val max = numbers.max\n        val scale\
    \ = (max - min) / (numbers.size - 1)\n        numbers.map(n => n + (min - max)\
    \ / numbers.size * (n - max))", "        val min: Float = numbers.min\n      \
    \  val max: Float = numbers.max\n        val rescaled: List[Float] = numbers.map(x\
    \ => x.toFloat * max - min)\n        (rescaled.sum, rescaled)", "        val n\
    \ = numbers.size // number of elements input\n        val min = numbers.min  //\
    \ smallest number\n        val max = numbers.max  // largest number\n        val\
    \ range = max - min  // difference between smallest and largest number\n     \
    \   val scaledRange = range / n  // scale of largest to smallest number\n    \
    \    val scaledNumbers = (0 until n) map {\n            i => numbers[i] + min\
    \ * scaledRange\n        }\n        scaledNumbers", "        val min = numbers.min\n\
    \        val max = numbers.max\n        val rescale = (min - max) / (1.0f - min)\n\
    \        numbers.map {\n            n => (n - min) * rescale + max\n        }",
  "        // Convert all numbers to their square root\n        val squareRoot = numbers.map(\
    \ x=>math.sqrt(x).toFloat) \n        // Convert the result from square root to\
    \ range 0 to 1\n        val rescaled = squareRoot.map( x=>x/math.sqrt(numbers.toList.length))\n\
    \        // Convert the result from range 0 to 1 to range 0 to 1\n        rescaled.map(\
    \ x=>x*numbers.length).zipWithIndex.foldLeft((List[Float](0f),List[Float](0f)))\
    \ { \n            (a,i)=>(a._1+i._1,a._2+i._2) \n        }._1.reverse ++ rescaled ",
  "        if (numbers.isEmpty) List(0.0f)\n        else if (numbers.head == numbers.last)\
    \ List(1.0f)\n        else numbers.map(n => n - math.min(numbers)).map(n => n\
    \ / math.max(numbers))", "        numbers.foldLeft((numbers.min - numbers.max)/(numbers.max\
    \ - numbers.min)) { (x, y) =>\n            x + y * (y - x).toFloat\n        }",
  "        val n = numbers.length\n        val m = numbers.min\n        val M = numbers.max\n\
    \n        val min = M - m \n        val max = M - n / 2\n        val range = (max\
    \ - min) / n\n\n        (0 to n).map(i => {\n            (min + range * (i + n\
    \ - 1)) - n / 2\n        })", "        val sum : Float = numbers.reduce(_ + _)\n\
    \        numbers.map(n => n / sum)", "      val minNumber = numbers.min\n    \
    \  val maxNumber = numbers.max\n      numbers.map {\n        n => (n - minNumber)\
    \ / (maxNumber - minNumber)\n      }", "        // The largest element should\
    \ be 1 and the smallest element should be 0\n        var min = 0f\n        var\
    \ max = 0f\n        numbers.foreach{ elem =>\n            if(elem > max) {\n \
    \               max = elem\n            }\n            if(elem < min) {\n    \
    \            min = elem\n            }\n        }\n\n        val rescaledNumbers\
    \ = numbers.map(elem => max + (elem - min))\n        return rescaledNumbers",
  '        numbers.map(x => (x - numbers.min) / (numbers.max - numbers.min))', " \
    \       val newMin = math.min(numbers.head, numbers.last)\n        val newMax\
    \ = math.max(numbers.head, numbers.last)\n        var sum = 0.0f\n        var\
    \ i = 0\n        while (i < numbers.length && numbers(i) < newMin)\n         \
    \   sum += numbers(i)\n        while (i < numbers.length && numbers(i) > newMax)\n\
    \            sum += numbers(i)\n        while (i < numbers.length && numbers(i)\
    \ == newMin)\n            sum += numbers(i)\n        while (i < numbers.length\
    \ && numbers(i) == newMax)\n            sum += numbers(i)\n        while (i <\
    \ numbers.length)\n            numbers(i) /= sum\n        numbers", "        require(numbers.size>1,\
    \ \"List must contain at least two elements\")\n        val sortedNumbers = numbers.sortBy(math.abs)\n\
    \        val unitSize = sortedNumbers.last.toFloat\n        val scaledNumbers\
    \ = sortedNumbers.map{x=>(x/unitSize).toFloat}\n        scaledNumbers", "    \
    \    def linear(number : Float) : Float = {\n            number / numbers.max\n\
    \        }\n        val result = numbers.map(linear).toList\n        result.min\
    \ match {\n            case 0.0f => 0.0f\n            case _  => result.max\n\
    \        }\n        result", "        val min = math.min(numbers.map(_.toFloat))\n\
    \        val max = math.max(numbers.map(_.toFloat))\n        numbers.map(x =>\
    \ (x - min)/(max - min))", "        val total = numbers.reduceLeft( (x, y) =>\
    \ x + y)\n        val rescale = (1.0f / total).toFloat\n        numbers.map( x\
    \ => x * rescale)", "        var smallest : Float = 0.0\n        var largest :\
    \ Float = 1.0\n        numbers foreach {\n            value => {\n           \
    \     val valueInRange = (value - smallest) / (largest - smallest)\n         \
    \       if (valueInRange < 0.0f) smallest -= value\n                if (valueInRange\
    \ > 1.0f) largest += value\n            }\n        }\n        List(smallest.toFloat,\
    \ largest.toFloat)", "        // Compute the linear transform of the list\n  \
    \      // >>> transform(numbers)\n        val values = numbers.map(_/numbers.size).toList.sortBy(_*numbers.size).reverse\n\
    \n        // If the smallest number is 0, remove it from the list as the smallest\
    \ number is 0\n        // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n        // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat))\n        if (values(0) == 0) values.remove(0)\n\
    \n        // If the largest number is 1, remove it from the list as the largest\
    \ number is 1\n        // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n        // (List[Float](1.0f.toFloat,\
    \ 1.0f.toFloat, 1.0f.toFloat, 1.0f.toFloat))\n        if (values(values.size-1)\
    \ == 1) values.remove(values.size - 1)\n\n        // Return the scaled list\n\
    \        // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat)))\n        // (List[Float](0.0f.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat))\n        values", "        val ranges = numbers.map(x\
    \ => x - Math.min(x, Math.max(x, 0)))\n        val scale = ranges.min\n      \
    \  val ranges2 = ranges.map(x => (x - scale).abs)\n        ranges2.take(1).map(x\
    \ => x / scale).reduceLeft((x, y) => x + y)", "        val nMin = min(numbers)\n\
    \        val nMax = max(numbers)\n        numbers.map(x => (x - nMin) / (nMax\
    \ - nMin))", "        val result = numbers(0)\n        var min = 0f;\n       \
    \ var max = numbers\n        var i = 1;\n        while (i < numbers.size) {\n\
    \            if (numbers(i) < min) {\n                min = numbers(i);\n    \
    \        }\n            if (numbers(i) > max) {\n                max = numbers(i);\n\
    \            }\n            i += 1\n        }\n        val range = max - min;\n\
    \        if (range <= 0) {\n            return List(result);\n        }\n    \
    \    val newRange = range / numbers.size;\n        val range = max - min;\n  \
    \      val scale = newRange / range;\n        var newNumbers: List[Float] = numbers.map(x\
    \ => x * scale).toList\n        newNumbers.sortWith((x,y) => x - y)\n        newNumbers",
  "        val firstNumber = numbers(0)\n        var scaleFactor = firstNumber\n \
    \       numbers.foreach { number => scaleFactor = scaleFactor * number }\n   \
    \     val scaled = numbers.map(_/scaleFactor).map(math.pow(_,2)).map(math.pow(_,-1))\n\
    \        numbers.zip(scaled).map { case (x, y) => x + (y-x)/scaleFactor }", " \
    \       require(numbers.length > 0)\n        numbers.map(n => (if (n < 0.0) 0.0f\
    \ else 1.0f)/n)", "        var scale = 0.0f\n        var minVal = math.min(numbers)\n\
    \        var maxVal = math.max(numbers)\n        if (minVal == 0.0f && maxVal\
    \ == 0.0f) {\n            numbers.length match {\n                case 0    =>\
    \ scales\n                case _    => throw new Exception(\"No number in list\"\
    )\n            }\n        } else {\n            numbers.foreach(x => {\n     \
    \           scale = 1.0f - math.pow(x - minVal, 2)\n            })\n        }\n\
    \        numbers.map(_ * scale).sortBy(_)", "        val sortedNumbers = numbers.sortWith(_\
    \ <=> _) // sorted numbers (smallest first, largest last)\n        val zeroed\
    \ = sortedNumbers.takeWhile(x => x < 0f)\n        val scaled  = sortedNumbers.drop(zeroed.length)\n\
    \        scaled.map(_ / zeroed.min).reverse // reverse to get largest to smallest",
  "        val sum : Float = 0.0f\n        numbers.foreach { x =>\n            sum\
    \ += x\n        }\n        if (sum != 0.0f) {\n            val invSum = 1.0f /\
    \ sum\n            numbers.foreach { x =>\n                x *= invSum\n     \
    \       }\n        }\n        numbers", "        // 1. Calculate the sum of all\
    \ numbers \n        val sum = numbers.reduce((x, y) => x + y)\n        // 2. Normalize\
    \ all numbers by dividing each number by its sum\n        val normalized = numbers.map(x\
    \ => x / sum)\n        // 3. Return the normalized list \n        return normalized",
  "        val minNumber = math.min(numbers)\n        val maxNumber = math.max(numbers)\n\
    \        var rescaledList = scala.collection.mutable.ListBuffer.empty[Float]\n\
    \        var i = 1\n        rescaledList += numbers(0)\n        while (i < numbers.size)\
    \ {\n            rescaledList += (numbers(i) - minNumber) / (maxNumber - minNumber)\n\
    \            i += 1\n        }\n        rescaledList", "        var smallest =\
    \ numbers.min\n        var largest = numbers.max\n        var rescaledNumbers\
    \ = scala.collection.mutable.ArrayBuffer.empty[Float]\n        for (n <- numbers)\
    \ {\n            rescaledNumbers = rescaledNumbers :+ n / largest - n / smallest\n\
    \        }\n        rescaledNumbers", "        if (numbers.isEmpty) numbers\n\
    \        else {\n            val result = numbers.map{ x => (x - numbers.min)\
    \ / (numbers.max - numbers.min) }\n            val minMax = numbers.min, numbers.max\n\
    \            if (minMax != 0) {\n                result.map{ x => (x * minMax._2)\
    \ }.maxBy(numbers.max) - result.minBy(numbers.min)\n            } else {\n   \
    \             result.maxBy(numbers.max)\n            }\n        }", "        val\
    \ sumOfSquares = numbers.reduce((a, b) => a + b * b)\n        val min = numbers.min\n\
    \        val max = numbers.max\n        val scale = 1.0f / Math.sqrt(sumOfSquares)\n\
    \        numbers.map(x => min * scale + x * scale)", "        var min = sys.maxFloat\n\
    \        var max = 0.0f\n\n        // This loop is O(n)\n        for (number :\
    \ Float <- numbers) {\n            min = Math.min(min, number)\n            max\
    \ = Math.max(max, number)\n        }\n\n        // This loop is O(n)\n       \
    \ for (number : Float <- numbers) {\n            number = ((number - min) / (max\
    \ - min)) - 0.5f\n        }\n\n        numbers", "        val range = numbers.map(_.toInt).max\n\
    \        numbers.map(_.toInt / range)", "        val m = numbers.min\n       \
    \ val n = numbers.max\n        numbers.map((number: Float) => number*(m-n)/(m+n))",
  "        val numMin = numbers.min\n        val numMax = numbers.max\n        val\
    \ numRange = numMax - numMin\n        if (numRange == 0.0f) numbers else numbers\
    \ map { x => (x - numMin) / numRange }", "        var min = numbers.head\n   \
    \     var max = numbers.last\n        for (i<- numbers) \n            if (min\
    \ > i) \n                min = i\n            if (max < i) \n                max\
    \ = i\n        numbers.map(x => (x - min) / (max - min))", "        // create\
    \ empty list\n        val result = numbers.map { n =>\n            // check min\
    \ and max\n            if (n >= 1.0) 1.0f - n\n            else n\n        }\n\
    \        result", "        val min: Float = math.min(numbers.minOrNull, numbers.min.minOrNull)\n\
    \        val max: Float = math.max(numbers.maxOrNull, numbers.max.maxOrNull)\n\
    \        val newNumbers: List[Float] = List(min, (numbers - min) / (max - min),\
    \ max)\n        return newNumbers", "        val min = numbers.min\n        val\
    \ max = numbers.max\n        numbers.map(x => (x - min) / (max - min))", "   \
    \     val min = math.min(numbers).toFloat\n        val max = math.max(numbers).toFloat\n\
    \        numbers.map(num => (num - min) / (max - min))", "        val unitRange\
    \ = numbers.min/numbers.max\n        val zeroPoint = numbers.min\n        val\
    \ onePoint = numbers.max\n        val result = numbers.map((x: Float) => { ((x\
    \ - zeroPoint) / unitRange).toFloat + onePoint })\n        result", "        def\
    \ scale(x: Float, factor: Float) : Float = {\n            val oldX = x\n     \
    \       x -= 1.0f\n            x /= factor\n            x += 1.0f\n          \
    \  x - oldX\n        }\n        numbers.foldLeft(List[Float]()){ (res, num) =>\
    \ res :+ scale(num, num.toFloat) }", "        numbers.map { n =>\n           \
    \ val diff = (n - min(numbers).toFloat) / (max(numbers) - min(numbers))\n    \
    \        (diff * 1.0f + 1.0f - n)\n        }", "        val minNum = numbers.min\n\
    \        val maxNum = numbers.max\n        var nums = numbers.toList\n       \
    \ nums.map(num => num * (maxNum - minNum) + minNum)", "        require(numbers.nonEmpty)\n\
    \        require(numbers.forall(_ > 0.0f))\n        require(numbers.forall(_ <\
    \ 1.0f))\n\n        val smallestNonZero = numbers.minBy(_ != 0.0f)\n        val\
    \ maxNonZero = numbers.maxBy(_ != 0.0f)\n        var newNums = numbers.map(_ /\
    \ smallestNonZero).map(_ * maxNonZero)\n        newNums = newNums.drop(1).filter(_\
    \ != 0.0f)\n        newNums.sortWith(_ > _) // Sort the list so that the smallest\
    \ value is 0, largest is 1", '        numbers.map( n => (n%1.0f).toFloat / 1.0f
    )', "        val min = numbers.min\n        val max = numbers.max\n        val\
    \ range = max - min\n        val scaledNumbers = numbers.map(n => { val scaled\
    \ = n.toFloat / range }); \n        scaledNumbers.map(_ * range + min)", '        numbers.minBy(_.toFloat).toFloat
    /: numbers.map(_.toFloat) (_ / _) (_ * 1.0f).toList', "        val ns = numbers.toList\n\
    \        val smallestIndex = ns.head.toInt\n        var scaledNumbers = ns map\
    \ { n =>\n            if(n >= smallestIndex) 0.0f - n else 1.0f - n\n        }\n\
    \        scala.util.Sorting.quickSort(scaledNumbers)\n        scaledNumbers",
  "        val sortedNumbers = numbers.sorted\n        val min = sortedNumbers.head\n\
    \        val max = sortedNumbers.last\n        if (max - min < 1e-5f)\n      \
    \      numbers : List[Float]\n        else\n            sortedNumbers.map((n /\
    \ max - min).toFloat * 2.0f - 1.0f).toList :: numbers.reverse", "        var smallest\
    \ = 0f\n        var largest = 1f\n        var range = 0f\n        numbers foreach\
    \ { n =>\n            var nn = n * n\n            if (nn == 0) {\n           \
    \     return\n            }\n            if (nn == n) {\n                smallest\
    \ = math.min(n, smallest)\n                largest = math.max(n, largest)\n  \
    \              range = math.max(range, n)\n            } else {\n            \
    \    smallest = math.min(smallest, n)\n                largest = math.max(largest,\
    \ n)\n                range = math.max(range, nn)\n            }\n        }\n\
    \        if (smallest == 0f && largest == 1f) {\n            return\n        }\n\
    \        if (smallest == 1f) {\n            smallest = 0f\n        } else {\n\
    \            smallest = smallest * (range / smallest + 1f)\n        }\n      \
    \  if (largest == 0f) {\n            largest = 1f\n        } else {\n        \
    \    largest = largest * (range / largest + 1f)\n        }\n        val rangeScaled\
    \ = range / 2f\n        numbers map { n =>\n            if (smallest == 0f) {\n\
    \                if (n < smallest) {\n                    0f\n               \
    \ } else {\n                    ((n - smallest) * rangeScaled + smallest)\n  \
    \              }\n            } else {\n                if (n < smallest) {\n\
    \                    ((n - smallest) * rangeScaled + smallest)\n             \
    \   } else {\n                    if (n == largest) {\n                      \
    \  (largest + 1f)\n                    } else {\n                        ((n -\
    \ smallest) * rangeScaled + smallest)\n                    }\n               \
    \ }\n            }\n        }", "        val numberRange = numbers.last.toDouble\
    \ - numbers.head.toDouble\n        val range = numberRange.toFloat\n        var\
    \ result: List[Float] = List()\n        val min = (numbers.head + numbers.last)\
    \ / 2.0\n        val max = (min * range).roundToInt\n        for(number <- numbers)\
    \ {\n            if(number > max) result = result ::: (List(0.0f.toFloat))\n \
    \           if(number < min) result = result ::: (List((min.toFloat - min).roundToInt))\n\
    \            else result = result ::: (List(number.toFloat))\n        }\n    \
    \    result", "        val min = numbers.min\n        val max = numbers.max\n\
    \        val scaled = numbers.map {x => x - min/(max - min)}.sorted\n        scaled.inits.map(_.toFloat).reverse.take(numbers.size).toList",
  "        def makeLinear(table : List[Float]) : List[Float] = { //make t between\
    \ 0-1\n            val min = math.min(table)\n            val max = math.max(table)\n\
    \            val t = (max - min) / (1.0f - min)\n            (table.toFloat *\
    \ t).toFloat\n        }\n        val min = math.min(numbers)\n        val max\
    \ = math.max(numbers)\n        var i = 0\n        var j = 0\n        var t = makeLinear(List(1.0f\
    \ - min, max))\n        while(i < numbers.length && j < numbers.length){ //loop\
    \ over all the numbers in the list\n            if(numbers[i] < min){\n      \
    \          t = makeLinear(List(numbers[i] + min, min))\n                i += 1\n\
    \            }\n            else if(numbers[i] > max){\n                t = makeLinear(List(min,\
    \ numbers[i] - max))\n                j += 1\n            }\n            else{\n\
    \                i += 1\n                j += 1\n            }\n        }\n  \
    \      while(j < numbers.length){\n            t = makeLinear(List(numbers[j],\
    \ min))\n            j += 1\n        }\n        t", "        val unitNumbers =\
    \ numbers.filter(x => x != 0f).toList\n        if (unitNumbers.isEmpty) {\n  \
    \          return List(0f)\n        } else {\n            val nums = List(1f,\
    \ unitNumbers.min)(0f)\n            val diff = unitNumbers.max - nums.max\n  \
    \          nums :: List(unitNumbers.min.toFloat) + (diff / unitNumbers.size)\n\
    \        }", "        var min = 0\n        var max = Double.PositiveInfinity\n\
    \        for (n <- numbers) {\n            min = math.min(min, n)\n          \
    \  max = math.max(max, n)\n        }\n        // Scale the entire list to range\
    \ [0, 1]\n        val scale = (max - min)/2.0\n        numbers.map(n => n/scale).reverse",
  "        var min : Float = 0.00001\n        var max : Float = 1.0\n        numbers.foreach{\
    \ x => min = math.min(min, x); max = math.max(max, x) }\n        var result =\
    \ numbers.map { x => (x - min) / (max - min) }\n        result.toList", "    \
    \    val listOfNumbers = numbers.toList\n        val smallestNumber = listOfNumbers.min\n\
    \        val largestNumber = listOfNumbers.max\n        listOfNumbers.map { x\
    \ =>\n            x -> math.abs(x - smallestNumber) / (largestNumber - smallestNumber)\n\
    \        }", "        val n = numbers.head\n        val minNum = numbers.min\n\
    \        val maxNum = numbers.max\n        val range = maxNum - minNum\n     \
    \   val range = range / n\n        val min = minNum - range * n\n        val max\
    \ = maxNum + range * n\n        (0 until n).map(_ => min + n * _).toList", " \
    \       val range = (numbers.min - numbers.max).toFloat\n        val length =\
    \ numbers.size + 1\n        val step = range / length\n        numbers.map(x =>\
    \ (x - numbers.min) * step).toList", "        val minNum = numbers.min\n     \
    \   val maxNum = numbers.max\n        var scaled: List[Float] = Nil\n        numbers.foreach\
    \ {\n            case num if num == minNum => scaled = scaled.++ Nil\n       \
    \     case num if num == maxNum => scaled = scaled.++ List(maxNum)\n         \
    \   case num if num < minNum => scaled = scaled.++ List((num - minNum) / (maxNum\
    \ - minNum)* maxNum)\n            case num if num > maxNum => scaled = scaled.++\
    \ List((maxNum - num) / (maxNum - minNum)* maxNum)\n            case num => scaled\
    \ = scaled.++ List(num)\n        }\n        return scaled", "        val maxValue\
    \ = numbers.max\n        val minValue = numbers.min\n        val range = maxValue\
    \ - minValue\n        val scaledNumbers = numbers.map((n) => n * range / numbers.size)\n\
    \        scaledNumbers.toList", "        val min = numbers.min\n        val max\
    \ = numbers.max\n        val range = max - min\n        numbers.map(x => x - min\
    \ / range * 2.0f - 1.0f).toList", "        val n = numbers.size\n        if (n\
    \ == 0) numbersList\n        else {\n            // Scale the first number\n \
    \           val first = numbers.head\n            numbers.head /= (first - numbers.last)\n\
    \            numbers.drop(numbers.size - 1)\n        }", "        // First, find\
    \ out the min and max elements\n        var min = numbers.min\n        var max\
    \ = numbers.max\n        numbers.foreach(num => {\n            if(num < min) min\
    \ = num\n            if(num > max) max = num\n        })\n        // Now, find\
    \ the scale factor\n        var scale = 1.0f / (max - min)\n        // Now, scale\
    \ it\n        numbers.map(num => (num - min) * scale)", "        val minVal =\
    \ min(numbers)\n        val maxVal = max(numbers)\n        val delta = (maxVal\
    \ - minVal) / numbers.size\n        (for (i <- numbers.indices) yield {\n    \
    \        numbers[i] + delta * i\n        })", "        val n = numbers.head\n\
    \        val min = numbers.head\n        val max = numbers.last\n        (min\
    \ until max).map { x =>\n            val scaled = (x - min) / (max - min)\n  \
    \          x.toFloat * (scaled * 2).toFloat\n        }.headOption.toList ++ numbers.tail",
  "        require(numbers.length >= 2, s\"Can't rescale to a unit vector with less\
    \ than two elements. numbers.length=${numbers.length}\")\n        val length =\
    \ numbers.head\n        numbers.map { x =>\n            x / length\n        }",
  "        var min = math.min(numbers.toList.map(_.toFloat))\n        var max = math.max(numbers.toList.map(_.toFloat))\n\
    \        if (min == 0.0f) {\n            min = 0.0f\n        }\n        if (max\
    \ == 0.0f) {\n            max = 1.0f\n        }\n        var transformed = new\
    \ mutable.ArrayList[Float]()\n        for (number <- numbers) {\n            transformed.add(number\
    \ * (max - min) / (max - min).toFloat)\n        }\n        transformed.toList",
  "        var smallest = fmin(numbers(0), numbers(1))\n        var largest = fmax(numbers(0),\
    \ numbers(1))\n        numbers.zipWithIndex.foreach { case (num, i) =>\n     \
    \       if(num > largest) {\n                largest = num\n            }\n  \
    \          else if(num < smallest) {\n                smallest = num\n       \
    \     }\n        }\n        numbers = numbers map { n => (n / largest) * (largest\
    \ - smallest) + smallest }\n        numbers", "        val length = numbers.size\n\
    \        if (length < 2) numbers else (0 until length).map(i => numbers(i).toFloat)",
  "        assert(numbers.length > 1) \n        // Find smallest number in the list\n\
    \        var smallest = numbers.min\n        // Set smallest number to be 0\n\
    \        numbers.map(_ => 0.0f)\n        // Set largest number to be 1\n     \
    \   numbers.map(_ => 1.0f)\n        // Rescale each number by (smallest - number)\
    \ / smallest \n        numbers.map(num => (num - smallest) / smallest)", "   \
    \     var scaledNumbers = numbers.map(_/numbers.length)\n        val smallestIndex\
    \ = scaledNumbers.indexOf(scala.math.min(scaledNumbers))\n        scaledNumbers(smallestIndex)\
    \ = 0.0f\n        val largestIndex = scaledNumbers.indexOf(scala.math.max(scaledNumbers))\n\
    \        scaledNumbers(largestIndex) = 1.0f\n        scaledNumbers", "       \
    \ val min = numbers.min\n        val max = numbers.max\n        // Convert to\
    \ unit\n        val rescale = (max - min) * 0.5f / Float.PositiveInfinity\n  \
    \      val result = numbers.map(x => (x - min) * rescale + min)\n        result",
  "        val min = numbers.min\n        val max = numbers.max\n        val scaled\
    \ = numbers.map( (x) => Math.min( max, Math.max( min, x ) ) ).toList\n       \
    \ scaled", "        val min = numbers.min\n        val max = numbers.max\n   \
    \     val diff = (max - min).toFloat\n        val rangeInt = ((max - min) / diff).toInt\n\
    \        val rangeFloat = (max - min) / diff\n        val scaled = numbers.map((x:\
    \ Float) => x + (min * diff))\n        val zeroed = scaled.map(x => if(x == 0.0f)\
    \ 0.0f else x)\n        val roundedUp = zeroed.map(x => math.floor(x * rangeFloat)\
    \ + rangeFloat)\n        val roundedDown = zeroed.map(x => math.ceil(x * rangeFloat)\
    \ - rangeFloat)\n        val rounded = (roundedUp ++ roundedDown).toList\n   \
    \     rounded", "        var newList = List[Float]()\n        var newMin = 0.0f\n\
    \        var newMax = 1.0f\n        for (i <- 0 until numbers.size)\n        {\n\
    \            newList ::= numbers(i)\n            if (numbers(i) < newMin) newMin\
    \ = numbers(i)\n            if (numbers(i) > newMax) newMax = numbers(i)\n   \
    \     }\n        var scale = (newMax - newMin) / (2.0f * (1.0f - newMax))\n  \
    \      newList = newList.map(x => (x - newMin) * scale)\n        newList = newList.toList",
  '        numbers.sortBy(-_).map(f => (0f - f) / (numbers.size - 1))', "        val\
    \ min = numbers.min\n        val max = numbers.max\n        val range = max -\
    \ min\n        val scaledNumbers = numbers.map(x => if (x == min || x == max)\
    \ 0.0f else (x * (range / (max - min))) + min)\n        scaledNumbers", "    \
    \    val totalSize = numbers.size\n        var min = numbers.reduceLeft((x:Float,\
    \ y:Float) => if (x < y) x else y)\n        var max = numbers.reduceLeft((x:Float,\
    \ y:Float) => if (x > y) x else y)\n        for (i <- 0 until totalSize) {\n \
    \           numbers(i) /= max - min\n            numbers(i) *= max - min\n   \
    \         min = numbers.reduceLeft((x:Float, y:Float) => if (x < y) x else y)\n\
    \            max = numbers.reduceLeft((x:Float, y:Float) => if (x > y) x else\
    \ y)\n        }\n        numbers", "        numbers.sortWith(_ < _)\n        val\
    \ scaled = numbers.map((f => if(f < 0) 0 else 1))\n        scaled.take(numbers.length).foldLeft(List[Float](0f))(\n\
    \            (a, b) => List(a,b).zipped.map(_/2).foldLeft(a)(_+_)\n        )",
  "        val min = numbers.min\n        val max = numbers.max\n        var rescaledNumber\
    \ : Float = 0.0f\n\n        if (numbers.isEmpty)\n            numbers\n      \
    \  else {\n            numbers.foldRight(List[Float]())(_::_).map(x => math.abs(x)).toList.sortBy(math.abs).foreach(x\
    \ => {\n                if (x == max) rescaledNumber = 1.0f\n                else\
    \ if (x == min)\n                    rescaledNumber = 0f\n                else\n\
    \                    rescaledNumber = (x - min)/(max - min).toFloat\n        \
    \    })\n        }\n        numbers.map(x => if(rescaledNumber == 0.0f) 0.0f else\
    \ x*rescaledNumber).toList", "        require(numbers.length > 1, s\"rescaleToUnit\
    \ requires at least two elements in given list: ${numbers}\")\n\n        val length\
    \ = numbers.head\n        var smallest = numbers.head\n        var largest = numbers.head\n\
    \n        var i = 1 // index of smallest number in given list\n        while (i\
    \ < numbers.length) {\n            if (numbers[i] > largest) {\n             \
    \   largest = numbers[i]\n            }\n            if (numbers[i] < smallest)\
    \ {\n                smallest = numbers[i]\n            }\n            i += 1\
    \ // increment index of smallest number in given list\n        }\n\n        val\
    \ scaled = numbers.map(x => x / length).map(x => if (x > largest) largest else\
    \ if (x < smallest) smallest else x)\n\n        if (scaled.head != 0.0f) {\n \
    \           scaled.head *= 1.0f - smallest // rescale smallest number to zero\n\
    \        }\n\n        scaled", "        var min = numbers.head\n        var max\
    \ = numbers.last\n        val n = numbers.tail.size\n        for (i <- 1 to n)\
    \ {\n            min = if (min < numbers.head) min else numbers.head\n       \
    \     max = if (max > numbers.last) max else numbers.last\n        }\n       \
    \ numbers.map(_ / max - min)", "        val minValue = math.min(numbers.min, numbers.max)\n\
    \        val maxValue = math.max(numbers.min, numbers.max)\n        val diff =\
    \ (maxValue - minValue).toFloat\n        val rescale = (1.0f - diff) / (numbers.size\
    \ - 1)\n        (numbers map { x => (x - minValue) * rescale + diff } map { x\
    \ => if (x > 0) x else 0 })", "        var minNumber = math.max(numbers.min) //\
    \ = 2.0\n        var maxNumber = math.min(numbers.max) // = 5.0\n        numbers.map(\
    \ x => { x = ((x - minNumber) / (maxNumber - minNumber)); x; })", "        val\
    \ unitMin = numbers.min\n        val unitMax = numbers.max\n        numbers.map(x\
    \ => (x - unitMin) / (unitMax - unitMin))", "        require(numbers.nonEmpty)\n\
    \        var smallest = 0.0f\n        var largest = 1.0f\n        var rescaled\
    \ = numbers.map{n => (n - smallest) / (largest - smallest)}\n        rescaled",
  "      numbers.min match {\n        case 0.0 => numbers\n        case min if min\
    \ < 1.0f => numbers.map(_ * max - min).map(math.exp(_))\n        case min => numbers.map(_\
    \ * max - min).map(math.exp(_))\n      }", "        val zeroToOne = numbers.map(\
    \ (f => f - Math.min(numbers)) / ( Math.max(numbers) - Math.min(numbers) ) )\n\
    \        zeroToOne.init", "        def minMax(values : List[Float], result : Option[List[Float]]\
    \ = None : Option[List[Float]]): Option[List[Float]] = {\n            if (values.size\
    \ == 1) {\n                result.getOrElse(List.of(0))\n            } else {\n\
    \                val minimum = values.min\n                val maximum = values.max\n\
    \                val unit = (maximum - minimum) / values.size\n              \
    \  val rescaledValues = values.map(x => x.toFloat * unit + minimum)\n        \
    \        result match {\n                    case Some(rescaledValues) =>\n  \
    \                      minMax(rescaledValues, Some(rescaledValues))\n        \
    \            case _ =>\n                        minMax(values.reverse, Some(List(values.reverse)))\n\
    \                }\n            }\n        }\n\n        val result = minMax(numbers)\n\
    \        result.getOrElse(List.empty)", "        val max = numbers.max\n     \
    \   val min = numbers.min\n        val range = max - min\n        val scaled =\
    \ numbers.map{ x => x / range }\n        val result = numbers.map{ x => (x - min)\
    \ * range + min }\n        result", "        val newMin = math.min(numbers)\n\
    \        val newMax = math.max(numbers)\n        val length = numbers.size\n \
    \       val newSize = length + 1 // include the new minimum value at the end\n\
    \        val rescaled = new Array[Float](newSize) // initial array of new size\n\
    \        val newOffset = length - 1 // initial offset for new numbers\n      \
    \  // Start populating the rescaled array\n        var i = 0\n        while (i\
    \ < newSize) {\n            rescaled(i) = newMin + (newOffset * numbers(i))\n\
    \            i += 1\n        }\n        rescaled", "        // find minimum element\n\
    \        val min = numbers.min\n        // find maximum element\n        val max\
    \ = numbers.max\n        val range = max - min\n        // calculate new values\n\
    \        numbers.map { n =>\n            n / range * 0.5f + min\n        }", '        numbers.foldLeft((List[Float](0.toFloat),
    0.0f.toFloat))(_ + _._2)._1', "        def rescale(x : List[Float], l : List[Float],\
    \ u : List[Float]) : List[Float] = {\n            if (x.isEmpty) l\n         \
    \   else (l.head * (u(x.head) - x.head) + rescale(x.tail, l, u)) :: rescale(x.tail,\
    \ l, u)\n        }\n\n        rescale(numbers, List(0f), List(1f, 1f))", "   \
    \     // If no numbers are given, the list is returned.\n        if (numbers.isEmpty)\
    \ {\n            return numbers\n        }\n        // Calculate the maximum and\
    \ minimum elements in the list\n        val max = numbers.max\n        val min\
    \ = numbers.min\n        // If all numbers are equal, the list is already scaled\
    \ between 0 and 1\n        if (min == max) {\n            return numbers\n   \
    \     }\n        // Calculate the new scale\n        val scale = max - min\n \
    \       // Create a new list, by dividing the elements by the new scale\n    \
    \    numbers.map(n => n / scale)", "        val sum = numbers.reduceLeft(_ + _)\n\
    \        val scaled = (numbers map { _ / sum } toList).toList\n        // The\
    \ smallest number will be 0, so if the smallest element is 0 and the sum is 1,\n\
    \        // then rescale all numbers to 1\n        if (scaled.head == 0.0f &&\
    \ sum == 1.0f) {\n            scaled.map(_ = 1.0f)\n        }\n        scaled",
  "        // Initialize max/min values\n        var maxVal = 0.0f\n        var minVal\
    \ = numbers.head\n\n        // Get difference between max and min\n        numbers.foreach\
    \ { n =>\n            if (maxVal < n) maxVal = n\n            if (minVal > n)\
    \ minVal = n\n        }\n\n        // Calculate new values between min and max\n\
    \        var rescaledNumbers = List(0.0f, 0.0f, 0.0f, 0.0f, 0.0f)\n        numbers.foreach\
    \ { n =>\n            rescaledNumbers = rescaledNumbers :+ (((n - minVal) / (maxVal\
    \ - minVal)) * numbers.size)\n        }\n\n        // Return result\n        rescaledNumbers",
  "        if (numbers.isEmpty) return Nil\n        val minValue = math.min(numbers)\n\
    \        val maxValue = math.max(numbers)\n        val newMinValue : Float = 0F\n\
    \        val newMaxValue : Float = 1F\n        val scaledNumbers = numbers.map(x\
    \ => { \n            val newX : Float = (x - minValue)/(maxValue - minValue)\n\
    \            if (newX < 0F) newX else 0F\n        })\n        newMinValue :: scaledNumbers\
    \ ::: newMaxValue :: Nil", '        numbers.reduceLeft((xs, x) => xs.map(_ / x.toFloat))',
  "        val maxNumber : Float = numbers.max\n        val minNumber : Float = numbers.min\n\
    \        val length : Float = numbers.last\n        val newNumbers : List[Float]\
    \ = numbers.map( x => (x - minNumber) / (maxNumber - minNumber) * (length.toFloat\
    \ - 1.0f).toFloat + 1.0f)\n        //TODO: return newNumbers instead of numbers\n\
    \        return newNumbers", "        // Create a mutable list of numbers and\
    \ an auxiliary function to find the smallest number in the list\n        val nums\
    \ = mutable.ListBuffer.empty[Float]\n        def smallest(n: Float) : Float =\
    \ {\n            if (nums.isEmpty) nums += n\n            else if (nums.last()\
    \ < n) nums += n\n            else nums.last\n        }\n\n        // Create a\
    \ mutable list of numbers and an auxiliary function to find the largest number\
    \ in the list\n        val mins = mutable.ListBuffer.empty[Float]\n        def\
    \ largest(n: Float) : Float = {\n            if (mins.isEmpty) mins += n\n   \
    \         else if (mins.last() > n) mins += n\n            else mins.last\n  \
    \      }\n\n        // Calculate the minimum and maximum values from the numbers\
    \ passed in\n        numbers.foreach(num => smallest(num))\n        numbers.foreach(num\
    \ => largest(num))\n\n        // Create an array from the list of numbers\n  \
    \      val arr = nums.toArray\n\n        // Divide each number in the array by\
    \ the maximum and minimum values\n        val scaledArr = arr.map {\n        \
    \    num => num / (largest(num) - smallest(num))\n        }\n\n        // Return\
    \ the list of scaled numbers\n        scaledArr", "        require(numbers.size\
    \ >= 2, \"Expected a list of at least two elements\")\n        val sortedNumbers\
    \ = numbers.sortWith(_ < _)\n        val firstNumber = sortedNumbers.head\n  \
    \      val secondNumber = sortedNumbers.last\n        val diff = firstNumber -\
    \ secondNumber\n        val scale = (1.0f / diff).toFloat\n        sortedNumbers\
    \ map (_ * scale)", "        val rangeMin = numbers.min\n        val rangeMax\
    \ = numbers.max\n        val range = (rangeMax - rangeMin)\n        val rescaledList\
    \ = (rangeMax - rangeMin).map(x => (x - rangeMin) / range).map(x => x * numbers(0))\
    \ + numbers.drop(1)\n        rescaledList", "        // Find smallest and largest\
    \ numbers and store them in 'min' and 'max'\n        var min = Float.MaxValue\n\
    \        var max = Float.MinValue\n        for (n <- numbers) {\n            if\
    \ (n < min)\n                min = n\n            if (n > max)\n             \
    \   max = n\n        }\n        // Apply linear transform to each number in numbers:\
    \ \n        // >>> numbers * 0.0f + (min - min) / (max - min) * (max - max)\n\
    \        numbers.map { n => n * 0.0f + (min - min) / (max - min) * (max - max)\
    \ }", "        val minElement = math.min(numbers)\n        val maxElement = math.max(numbers)\n\
    \        var result = numbers.map(x => x - minElement) / maxElement * (maxElement.toFloat()\
    \ - minElement.toFloat())\n        result = result.map { x => math.min(x, 1.0f)\
    \ }\n        result", "        val minInv = numbers.min\n        val maxInv =\
    \ numbers.max\n        val scale = (maxInv.abs - minInv.abs).toFloat\n       \
    \ numbers.map(x => (x - minInv) / scale)", "        def scale(x : Float) = {\n\
    \            val min = numbers.min\n            val max = numbers.max\n      \
    \      if (min == 0.0f && max == 1.0f) 0.0f\n            else (x - min) / (max\
    \ - min)\n        }\n        numbers.map(x => scale(x))", "        val minNum\
    \ = numbers.min\n        val maxNum = numbers.max\n        (0 until numbers.size).map(_\
    \ => maxNum - numbers.lift(_).sum / numbers.lift(_).size).getOrElse(List(minNum))",
  '      numbers.map(x => (x-min(numbers))/(max(numbers)-min(numbers)))', "      \
    \  val min = numbers.min\n        val max = numbers.max\n        val range = (max\
    \ - min).toFloat\n        if (range == 0) numbers else numbers.map(x => (x - min)\
    \ / range)", "        val minNumber : Float = numbers.min\n        val maxNumber\
    \ : Float = numbers.max\n        val newNumbers = numbers.map(x => minNumber +\
    \ (x - minNumber) / (maxNumber - minNumber).toFloat)\n        numbers.clear()\n\
    \        numbers.addAll(newNumbers)\n        numbers", "        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val range = max - min\n        val\
    \ scale = (range.max to range.min).max / 2.0\n        val transformedMin = min\
    \ - scale\n        val transformedMax = max + scale\n        val transformed =\
    \ numbers.map(x => (x - min) / range)\n        (transformedMin +: transformed\
    \ +: transformedMax).toList", "        val numbersList = numbers.toList\n    \
    \    var minVal: Float = numbersList.min\n        var maxVal: Float = numbersList.max\n\
    \        numbersList.map(x => (x - minVal) / (maxVal - minVal)).map(_ * 2.0f).toList",
  "        val minNum = math.min(numbers).toFloat\n        val maxNum = math.max(numbers).toFloat\n\
    \        // Create a list of values between 0 to 1\n        val range = (maxNum-minNum).toFloat/numbers.size\n\
    \        numbers.map(_ + minNum).toList.map(x => x*range)", "        var rescaledNumbers\
    \ = new mutable.ArrayBuffer[Float]()\n        var smallest = math.min(numbers)\n\
    \        var largest = math.max(numbers)\n        // Normalize all values to range\
    \ between zero and one\n        // >>> 0.0f.toFloat / largest.toFloat - 1.0f.toFloat\
    \ / smallest.toFloat\n        var difference = largest - smallest\n        for(\
    \ x <- numbers ) {\n            rescaledNumbers += (x - smallest) / difference\n\
    \        }\n        // Normalize all values from the original list to range between\
    \ zero and one\n        for( x <- rescaledNumbers ) {\n            rescaledNumbers\
    \ += (x * largest.toFloat / smallest.toFloat) - 1.0f.toFloat\n        }\n    \
    \    rescaledNumbers.toList", "        val total = (numbers: :+: (0 until numbers.size)).reduce(_\
    \ * _)\n        val norm = numbers.map {\n            case x if x == 0.0 => 0.0\n\
    \            case x if x == 1.0 => 1.0\n            case x if x == total => 1.0\n\
    \            case x => x * (1/total)\n        }\n        norm.reverse", "    \
    \    def rescaleToUnitAux(numbers: List[Float], currentIndex : Int) : List[Float]\
    \ = {\n            if (currentIndex < numbers.length - 1) {\n                val\
    \ temp = numbers(currentIndex)\n                numbers(currentIndex) = numbers(currentIndex\
    \ + 1).toFloat\n                numbers(currentIndex + 1) = temp\n           \
    \     rescaleToUnitAux(numbers, currentIndex + 1)\n            } else {\n    \
    \            numbers\n            }\n        }\n        rescaleToUnitAux(numbers,\
    \ 0)", "        require( numbers.nonEmpty )\n        require( numbers.size >=\
    \ 2 )\n\n        // Scale numbers in range (0..1) to (0..1)\n        val min:\
    \ Float = numbers.min\n        val max: Float = numbers.max\n        val delta:\
    \ Float = 1.0f / (max - min)\n        numbers.map { x => (x - min) * delta }",
  "        val minNum = numbers.min\n        val maxNum = numbers.max\n        val\
    \ minNumFloor = math.floor(minNum)\n        val maxNumFloor = math.floor(maxNum)\n\
    \        val deltaX = maxNum - minNum\n        val deltaY = maxNumFloor - minNumFloor\n\
    \        numbers.map(n => minNumFloor + (n - minNumFloor) * deltaX / deltaY)",
  "        val min = numbers.min\n        val max = numbers.max\n        val range\
    \ = max - min\n        val scaledNumbers = numbers.map {x => (x - min) / range\
    \ * 1.0f}\n        if (scaledNumbers.forall(x => x < 0.0f)) {\n            scaledNumbers.reverse\n\
    \        } else {\n            scaledNumbers\n        }", "        val minMax\
    \ = numbers.foldLeft((numbers.head, numbers.last)) {\n            (min, max) =>\n\
    \                if (min > max) (min.asInstanceOf[Float], max.asInstanceOf[Float])\
    \ else (max.asInstanceOf[Float], min.asInstanceOf[Float])\n        }\n\n     \
    \   if (minMax._1 == minMax._2) {\n            List(minMax._1)\n        } else\
    \ {\n            val min = (minMax._1 + minMax._2) / 2\n            val max =\
    \ minMax._1\n            numbers.map(x => if (x == min) 0.0 else x).reverse\n\
    \        }", "        // The smallest number will be 0, and the largest 1\n  \
    \      var smallestNumber = 0f\n        var largestNumber = 1f\n        var output\
    \ = new collection.mutable.ListBuffer[Float]()\n        for(i <- 0 until numbers.size)\
    \ {\n            val number = numbers(i).toFloat\n            if(number > largestNumber)\
    \ {\n                largestNumber = number\n            }\n            if(number\
    \ < smallestNumber) {\n                smallestNumber = number\n            }\n\
    \        }\n        for(i <- 0 until numbers.size) {\n            val number =\
    \ numbers(i).toFloat\n            val outputNumber = number / largestNumber *\
    \ smallestNumber + smallestNumber\n            output.append((outputNumber.toFloat).toFloat)\n\
    \        }\n        output.toList", "        val min = (numbers.min)(math.MaxFloat)\n\
    \        val max = (numbers.max)(math.MinFloat)\n        numbers.map {x => x /\
    \ min - max}", "        // Convert each number in the list to a float\n      \
    \  numbers.map(_.toFloat)\n\n        // Find smallest and largest numbers in the\
    \ list\n        var smallest: Float = numbers(0)\n        var largest: Float =\
    \ numbers(0)\n        for (i<- 1 to numbers.size-1) {\n            if (numbers(i)\
    \ < smallest) smallest = numbers(i)\n            if (numbers(i) > largest) largest\
    \ = numbers(i)\n        }\n\n        // Set the smallest and largest numbers to\
    \ 0 and the list to 1\n        numbers(0) = 0f\n        numbers(numbers.size-1)\
    \ = 1f\n\n        // Subtract the largest number from the smallest number\n  \
    \      var i = 0\n        while (i <= numbers.size-1) {\n            numbers(i]\
    \ -= largest\n            i += 1\n        }\n\n        return numbers", "    \
    \    val maxValue = numbers.max\n        val minValue = numbers.min\n        var\
    \ scaledNumbers = List.empty[Float]\n\n        // Scale the numbers up or down\
    \ to 0.0 or 1.0\n        for ( i <- numbers) {\n            val current = (i *\
    \ 1.0).toFloat\n            val difference = max - min\n            val scale\
    \ = math.min(1.0f, (max - current) / difference)\n            scaledNumbers =\
    \ scaledNumbers :+ current * scale\n        }\n\n        // Make sure that if\
    \ max is 1.0, min is 0.0\n        if (scaledNumbers.isEmpty) {\n            val\
    \ difference = max - min\n            val scale = 1.0f / difference\n        \
    \    scaledNumbers = scaledNumbers :+ (minValue * scale).toFloat\n        }\n\
    \        return scaledNumbers", "        var minInd = numbers.length\n       \
    \ var maxInd = 0\n        var minValue = numbers.head\n        var maxValue =\
    \ numbers.last\n\n        numbers.foreach(n => {\n            if (n < minValue)\
    \ {\n                minInd = 0\n                minValue = n\n            } else\
    \ if (n > maxValue) {\n                maxInd = numbers.length\n             \
    \   maxValue = n\n            }\n        })\n\n        if (minInd == 0) {\n  \
    \          numbers = numbers.map(_ / minValue)\n        } else if (maxInd == numbers.length\
    \ - 1) {\n            numbers = numbers.map(_ / maxValue)\n        } else {\n\
    \            numbers = numbers.map(_ / maxValue) ::: numbers.map(_ / minValue).reverse\n\
    \        }\n\n        numbers", '        numbers.min(number.abs.asInstanceOf[Number]).toFloat/numbers.max(number.abs.asInstanceOf[Number]).toFloat',
  "        // Compute range and scale of numbers, both are in [0, 1)\n        val\
    \ (rangeMin, rangeMax) = (numbers.minInt, numbers.maxInt)\n        val (scaleMin,\
    \ scaleMax) = (numbers.minInt, numbers.maxInt)\n        val rangeDiff = rangeMax\
    \ - rangeMin\n        val scaleDiff = scaleMax - scaleMin\n\n        // If range\
    \ and scale are identical, just return original list\n        if (rangeDiff ==\
    \ scaleDiff) numbers else numbers.map((_ - rangeMin) / rangeDiff * scaleMin) +\
    \ scaleMin", "        val units = new mutable.HashSet[Float]()\n        numbers.foreach(x\
    \ => {\n            if (x != 0.0f) units.add(x)\n        })\n        var max =\
    \ 0.0f\n        var min = 1.0f\n        units.foreach { x => max = math.max(max,\
    \ x); min = math.min(min, x) }\n        numbers.map(x => (x - min) / (max - min))",
  "        // Create a mutable list of numbers, add two copies of the number\n   \
    \     val numbers_scaled = numbers.toList\n        numbers_scaled.addAll(numbers_scaled)\n\
    \        // Find the min/max of the list\n        val minNum = numbers_scaled.min\n\
    \        val maxNum = numbers_scaled.max\n        // Multiply all numbers by their\
    \ difference to max and min\n        numbers_scaled :+ minNum :* maxNum :/ minNum\
    \ :* maxNum", '        numbers.map { x => ((x-numbers.min).toFloat/numbers.max)
    }', "        var result : List[Float] = List()\n        var minNum = numbers.getOrElse(0)\n\
    \        var maxNum = numbers.getOrElse(numbers.size - 1)\n        var smallestNum\
    \ = 0.0\n        var largestNum = 1.0\n        numbers.foreach(x => {\n      \
    \      if (x < minNum) minNum = x\n            if (x > maxNum) maxNum = x\n  \
    \          smallestNum = Math.min(smallestNum, x)\n            largestNum = Math.max(largestNum,\
    \ x)\n        })\n        var smallestNumFixed = smallestNum.toFloat\n       \
    \ var largestNumFixed = largestNum.toFloat\n        var factor = (largestNum -\
    \ smallestNum) / largestNumFixed\n        numbers.foreach(x => {\n           \
    \ x = x * factor\n        })\n        result = numbers\n        result", "   \
    \     var min = Float.MaxValue\n        var max = Float.MinValue\n        numbers.foreach(n\
    \ => { if (n < min) min = n; if (n > max) max = n; });\n        val n = (max -\
    \ min) / numbers.last\n        var scaled = numbers.map(n => n * n)\n        val\
    \ factor = (max - min) / scaled.last\n        for (i <- scaled.size - 2 downTo\
    \ 0) {\n            scaled = scaled.map(n => n * factor + min)\n        }\n  \
    \      scaled.mkList(min)"]
stop_tokens:
- "\n    }\n"
