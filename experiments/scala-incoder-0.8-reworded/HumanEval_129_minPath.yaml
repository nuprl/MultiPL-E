name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:    \n    // >>> minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l))\n    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n\
  \    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l))\n    // (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]],\
  \ k : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val res = grid\n        var currentCell = grid(0, 0)\n    \
    \    val visited = mutable.Set.empty[Long]\n        var j = 0\n        for (i\
    \ <- 1 to grid.length - 1) {\n            val currentCell = grid(0, i)\n     \
    \       var i = 1\n            while (visited.contains(i)) {\n               \
    \ i += 1\n            }\n            visited.add(i)\n            while (i < grid.length)\
    \ {\n                val currentCell = grid(0, i)\n                if (visited.contains(i\
    \ + 1)) {\n                    if (i + 1 < grid.length && visited.contains(i +\
    \ 2)) {\n                        val nextCell = grid(0, i + 1)\n             \
    \           val nextCell2 = grid(0, i + 2)\n                        val nextCell3\
    \ = grid(0, i + 3)\n                        var k = k - 1\n                  \
    \      if (k == 0) {\n                            res = currentCell +: nextCell\
    \ +: nextCell2 +: nextCell3\n                        }\n                     \
    \   else {\n                            if (nextCell < currentCell) {\n      \
    \                          val temp = currentCell\n                          \
    \      currentCell = nextCell\n                                nextCell = temp\n\
    \                            }\n                            if (nextCell2 < currentCell)\
    \ {\n                                val temp = currentCell\n                \
    \                currentCell = nextCell2\n                                nextCell2\
    \ = temp\n                            }\n                            if (nextCell3\
    \ < currentCell) {\n                                val temp = currentCell\n \
    \                               currentCell = nextCell3\n                    \
    \            nextCell3 = temp\n                            }\n               \
    \             k += 1\n                        }\n                    }\n     \
    \               else {\n                        val nextCell = grid(0, i + 1)\n\
    \                        if (nextCell < currentCell) {\n                     \
    \       val temp = currentCell\n                            currentCell = nextCell\n\
    \                            nextCell = temp\n                        }\n    \
    \                    visited.add(i + 1)\n                        val currentCell\
    \ = grid(0, i)\n                        val nextCell = grid(0, i + 1)\n      \
    \                  if (nextCell < currentCell) {\n                           \
    \ val temp = currentCell\n                            currentCell = nextCell\n\
    \                            nextCell = temp\n                        }\n    \
    \                    visited.add(i + 1)\n                        val currentCell\
    \ = grid(0, i)\n                        val nextCell2 = grid(0, i + 2)\n     \
    \                   if (nextCell2 < currentCell) {\n                         \
    \   val temp = currentCell\n                            currentCell = nextCell2\n\
    \                            nextCell2 = temp\n                        }\n   \
    \                     visited.add(i + 2)\n                        val currentCell\
    \ = grid(0, i)\n                        val nextCell3 = grid(0, i + 3)\n     \
    \                   if (nextCell3 < currentCell) {\n                         \
    \   val temp = currentCell\n                            currentCell = nextCell3\n\
    \                            nextCell3 = temp\n                        }\n   \
    \                     visited.add(i + 3)\n                        k += 1\n   \
    \                 }\n                }\n                else {\n             \
    \       visited.add(i + 1)\n                    val currentCell = grid(0, i)\n\
    \                    ", "        val gridMap = grid.map(row => row.map(_.asInstanceOf[Long])).toMap\n\
    \n        def dfs(ix : Int, k : Long, path : List[Long] ) : List[Long] = {\n \
    \           if (k == 0) path\n            else {\n                val nextCell\
    \ = gridMap(ix)\n                val path = dfs(nextCell(0), k-1, path+nextCell(0))\n\
    \                val path = dfs(nextCell(1), k-1, path+nextCell(1))\n        \
    \        val path = dfs(nextCell(2), k-1, path+nextCell(2))\n                val\
    \ path = dfs(nextCell(3), k-1, path+nextCell(3))\n                path\n     \
    \       }\n        }\n\n        val ans = dfs(0, 0, List[Long](0l))\n\n      \
    \  if (ans.isEmpty && gridMap.get(0).size == 0) ans +: gridMap(1).map(_.asInstanceOf[Long]).flatMap(l\
    \ => dfs(l, k-1, List[Long](0l))) \n        else ans", "        val grid = grid.sortBy(_.toLong)\n\
    \        val length = grid.map(_.size.toLong).sum\n        if (length == 0) Nil\n\
    \        else {\n            val visited = mutable.HashSet[Int]()\n          \
    \  var list = Nil\n            for (i <- 1 to length.toLong) {\n             \
    \   val idx = math.max(0, i - 1)\n                val left = if (idx > 0) grid[idx\
    \ - 1] else Nil\n                val right = if (idx + 1 < grid.length) grid[idx\
    \ + 1] else Nil\n                val neighbors = left ::: right :: Nil\n     \
    \           val next = (neighbors filter (v => !visited.contains(v))).sorted\n\
    \                if (next.size == k) list :+ next.head\n                else {\n\
    \                    val newList = (list ++ next.drop(next.size - k).take(k)).filterNot(v\
    \ => visited.contains(v))\n                    if (newList == Nil) Nil\n     \
    \               else {\n                        list = newList\n             \
    \       }\n                }\n            }\n            list\n        }", " \
    \       // Write your code here\n        val ind = grid.map(x => x.indexOf(k)).toSet\n\
    \        val list = grid(ind)\n        list.sortWith(_.compareTo(k))", "     \
    \   val nRow = grid.size\n        val nCol = grid(0).size\n        val vals =\
    \ for (row <- 0 to nRow; col <- 0 to nCol) yield grid((row.toInt - 1)*nRow + col.toInt)\n\
    \        val setVals = vals.toSet\n        val minPath: List[Long] = for (i <-\
    \ 1 to k) {\n            val currentPath: List[Long] = for (val elem <- setVals)\
    \ yield elem\n            val sortedPath: List[Long] = currentPath.sorted\n  \
    \          val previousPath: List[Long] = sortedPath.take(i-1)\n            val\
    \ nextPath: List[Long] = sortedPath.drop(i+1)\n            if (currentPath.toSet\
    \ == setVals && previousPath.toSet == setVals && nextPath.toSet == setVals) {\n\
    \                val minPath = currentPath.mkString(\",\")\n                println(minPath)\n\
    \                println(setVals.mkString(\",\"))\n                println(sortedPath.mkString(\"\
    ,\"))\n                println(previousPath.mkString(\",\"))\n               \
    \ println(nextPath.mkString(\",\"))\n                return sortedPath.mkString(\"\
    ,\")\n            }\n        }\n        minPath", "        // O(N log N) time\
    \ O(N log N) space\n        if (grid.isEmpty) return List()\n        // O(N) time,\
    \ O(N) space\n        val map = scala.collection.mutable.Map[Long,List[Long]]().withDefaultValue(List())\n\
    \        for (row <- 1 to grid.length) {\n            for (cell <- 1 to grid[row].length)\
    \ {\n                // O(1) time, O(1) space\n                val cell = grid[row][cell]\n\
    \                val path = map.get(cell)\n                if (path != null) {\n\
    \                    val lst = path.asInstanceOf[List[Long]]\n               \
    \     lst.take(lst.size - k).foreach(l => map.put(cell, lst :+ l))\n         \
    \       }\n            }\n        }\n        // O(N) time, O(N) space\n      \
    \  val result = map.valuesIterator.map {\n            case path => path.asInstanceOf[List[Long]]\n\
    \        }.flatten.sorted\n        result.toList", "        val maxRows = grid.head._2.length\n\
    \        val maxCols = grid.head._1.length\n        val rowIndex = List.range(0,\
    \ maxRows)\n        val colIndex = List.range(0, maxCols)\n        val paths =\
    \ mutable.ListBuffer[List[Long]]()\n\n        val visited = mutable.ArrayBuffer(rowIndex,\
    \ colIndex)\n        val pathLength = mutable.ArrayBuffer(rowIndex, colIndex)\n\
    \        for (rowIdx <- rowIndex) {\n            for (colIdx <- colIndex) {\n\
    \                if (grid(rowIdx, colIdx) == null) {\n                    continue\n\
    \                }\n                if (visited(rowIdx, colIdx) == 0) {\n    \
    \                var tempPath = List[Long](grid(rowIdx, colIdx))\n           \
    \         visited(rowIdx, colIdx) = 1\n                    for (i <- 1 to k) {\n\
    \                        val tempPath2 = tempPath ::: List(grid(rowIdx + i, colIdx))\n\
    \                        if (tempPath2.size < k) {\n                         \
    \   visited(rowIdx + i, colIdx) = 1\n                            tempPath = tempPath2\n\
    \                        }\n                    }\n                    paths +=\
    \ tempPath\n                    pathLength(rowIdx, colIdx) = tempPath.size\n \
    \               }\n            }\n        }\n        val maxPath = paths.max\n\
    \        if (maxPath.size == maxPath.size) {\n            return maxPath\n   \
    \     }\n        return maxPath.reverse", "        val rowCount = grid.head.length\n\
    \        val colCount = grid.last.length\n        val valueCount = k * (k + 1)\
    \ / 2\n        val cellCount = rowCount * colCount\n        var result: List[Long]\
    \ = Nil\n        for (i <- 1 to valueCount) {\n            val valueSet = HashSet[Long]()\n\
    \            for (row <- 1 to rowCount) {\n                for (col <- 1 to colCount)\
    \ {\n                    if (grid((row - 1).toInt, (col - 1).toInt) != Nil) {\n\
    \                        valueSet.add((grid(row - 1).toInt, grid(col - 1).toInt))\n\
    \                    }\n                }\n            }\n            val valueSetSet\
    \ = HashSet[Long](valueSet)\n            val setSize = valueSetSet.size\n    \
    \        if (setSize == valueSetSet.length) {\n                result = result.filterNot(_\
    \ == i)\n            }\n        }\n        result.sorted.toList", "        val\
    \ m = mutable.HashMap[Long, List[Long]]()\n        var ans = List[Long]()\n  \
    \      grid(0).zipWithIndex.foreach {\n            case(x, i) => m(x.toLong, i)\
    \ = x.toLong\n        }\n        for (x <- grid(1))\n            if (m contains\
    \ x.toLong)\n                m(x.toLong).map(_ + 1).foreach { n =>\n         \
    \           if (n <= k)\n                        ans = ans :+ x.toLong\n     \
    \               m(x.toLong) = n :: m(x.toLong)\n                }\n          \
    \  else {\n                m(x.toLong) = k :: m(x.toLong)\n                ans\
    \ = ans :+ x.toLong\n            }\n        ans", "        // sort the grid to\
    \ find the first cell that can be visited first\n        val sortedGrid = grid.sortBy(_(0))\n\
    \        val currentCell = sortedGrid(0)\n        val resultCells = List.empty[List[Long]]\n\
    \        val resultIndex = 0\n        // The first cell can be visited after k\
    \ steps and the result cell can only be\n        // visited after k + 1 steps.\n\
    \        // We iterate k times to get the first cell, then we iterate k + 1 times\n\
    \        // to get the result cell.\n        for (a <- 1 to k) {\n           \
    \ val visitedCell = sortedGrid(a)\n            val adjacentCells = sortedGrid.filter(_(a).contains(visitedCell))\n\
    \            resultCells ::= visitedCell\n            val adjacentCellsSize =\
    \ adjacentCells.size\n            val resultIndexNew = adjacentCellsSize + a\n\
    \            while (adjacentCellsSize > 0) {\n                resultIndexNew -=\
    \ 1\n                adjacentCells ::= adjacentCells(resultIndexNew)\n       \
    \         resultIndexNew += 1\n            }\n            resultIndex = resultIndexNew\n\
    \        }\n        resultCells.reverse", "        if (grid.isEmpty) {\n     \
    \       Nil\n        } else {\n            def helper(grid: List[List[Long]],\
    \ startIdx: Int, lst_A: List[Long], lst_B: List[Long], lst_C: List[Long], k: Long)\
    \ : List[Long] = {\n                if (lst_A.length == k) {\n               \
    \     lst_A\n                } else if (lst_B.length == k) {\n               \
    \     lst_B\n                } else {\n                    val nextIdx = startIdx\
    \ + 1\n                    var next_A = lst_A\n                    var next_B\
    \ = lst_B\n                    var next_C = lst_C\n                    var next_A_next\
    \ = nextIdx < grid.length\n                    var next_B_next = nextIdx < grid[0].length\n\
    \                    var next_C_next = nextIdx < grid[0].length\n            \
    \        while (true) {\n                        next_A = if (next_A_next) {\n\
    \                            helper(grid, nextIdx, next_A, next_B, next_C, k)\n\
    \                        } else {\n                            next_A\n      \
    \                  }\n                        next_B = if (next_B_next) {\n  \
    \                          helper(grid, nextIdx, next_A, next_B, next_C, k)\n\
    \                        } else {\n                            next_B\n      \
    \                  }\n                        next_C = if (next_C_next) {\n  \
    \                          helper(grid, nextIdx, next_A, next_B, next_C, k)\n\
    \                        } else {\n                            next_C\n      \
    \                  }\n                        next_A_next = nextIdx < grid.length\n\
    \                        next_B_next = nextIdx < grid[0].length\n            \
    \            next_C_next = nextIdx < grid[0].length\n                        if\
    \ (next_A < next_B) {\n                            if (next_A < next_C) {\n  \
    \                              if (next_B < next_C) {\n                      \
    \              next_B\n                                } else {\n            \
    \                        next_C\n                                }\n         \
    \                   } else {\n                                next_A\n       \
    \                     }\n                        } else {\n                  \
    \          if (next_B < next_C) {\n                                if (next_A\
    \ < next_C) {\n                                    next_A\n                  \
    \              } else {\n                                    next_C\n        \
    \                        }\n                            } else {\n           \
    \                     next_B\n                            }\n                \
    \        }\n                    }\n                }\n            }\n        \
    \    val lst_A = new mutable.LinkedList[Long]()\n            val lst_B = new mutable.LinkedList[Long]()\n\
    \            val lst_C = new mutable.LinkedList[Long]()\n            lst_A.append(grid[0](0))\n\
    \            lst_B.append(grid[1](0))\n            lst_C.append(grid[2](0))\n\
    \            val result = helper(grid, 0, lst_A, lst_B, lst_C, k)\n          \
    \  result\n        }", "        var result : List[Long] = List()\n        var\
    \ index = 0\n        var visited : Set[Long] = Set()\n        var currentK : List[Long]\
    \ = List(k)\n        while (index != grid.length) {\n            visited.add(grid[index](0))\n\
    \            val newIndex = grid[index].length - 1\n            val currentValue\
    \ = grid[index](currentK)\n            var minPath : List[Long] = List()\n   \
    \         while (newIndex >= 0) {\n                var currentCell = grid[newIndex]\n\
    \                var currentKCell : List[Long] = currentK\n                while\
    \ (currentCell != currentKCell) {\n                    currentKCell :=  currentCell.tail\n\
    \                    currentCell :=  currentCell.get\n                }\n    \
    \            val newValue = currentKCell.toList.sorted\n                minPath.insert(0,\
    \ newValue)\n                newIndex -= 1\n            }\n            if (minPath.size\
    \ == 0) {\n                result += currentK\n                currentK.clear()\n\
    \                visited.remove(grid[index](0))\n            } else {\n      \
    \          result = minPath.foldLeft(result)(_ ++ _)\n            }\n        \
    \    index += 1\n        }\n        return result", "        val len = grid.size\n\
    \        val visited = mutable.Set.empty[Long]\n        val values = mutable.HashSet[Long]()\n\
    \        val path = new Array[Long](k)\n        var idx = 0\n        while (idx\
    \ < k) {\n            if (visited.contains(path[idx])) {\n                idx\
    \ += 1\n                path[idx] = visited.apply(path[idx])\n            } else\
    \ {\n                visited.add(path[idx])\n                val curr = grid.find(_.toLong\
    \ == path[idx])\n                val numToVisit = numToVisit2(grid, curr, idx,\
    \ visited, values, path)\n                if (numToVisit > len - idx) {\n    \
    \                path[idx] = curr.toLong\n                } else {\n         \
    \           for (x <- 0 until numToVisit) {\n                        path[idx]\
    \ = curr.toLong\n                        val newCurr = grid.find(_.toLong == path[idx])\n\
    \                        numToVisit2(grid, newCurr, idx, visited, values, path)\n\
    \                    }\n                }\n            }\n            idx += 1\n\
    \        }\n        val result = new Array[Long](k)\n        for (x <- 0 until\
    \ k) {\n            result(x) = path(x)\n        }\n        result.sortBy(_.toLong)\n\
    \        result", "        val gridSize = grid.size\n        val maxSize = gridSize\
    \ * gridSize\n        val uniqueValues = Array.ofDim[Long](maxSize)\n        val\
    \ result = Array.ofDim[Long](gridSize)\n        var value = 1\n        var current\
    \ = 0\n        val uniqueList = Array.ofDim[Long](gridSize)\n        uniqueValues(0)\
    \ = 1\n        for (i<-1 to maxSize-1) {\n            val value = gridSize*i\n\
    \            var j = 0\n            while (j < gridSize-1) {\n               \
    \ uniqueList(j) = uniqueValues(j+1)\n                current+=uniqueValues(j+1)\n\
    \                j+=1\n            }\n            uniqueValues(i) = current\n\
    \            val min = current // k\n            for (j <- 1 to gridSize - 1)\
    \ {\n                if (min > uniqueList(j)) {\n                    min = uniqueList(j)\n\
    \                }\n            }\n            val temp = current\n          \
    \  current = 0\n            val j = gridSize - 1\n            while (j >= 0) {\n\
    \                if (min > uniqueList(j)) {\n                    current = temp\n\
    \                } else {\n                    current = uniqueList(j)\n     \
    \           }\n                uniqueList(j) = min\n                j -= 1\n \
    \           }\n            result(i) = current\n        }\n        result", " \
    \       val gridSize = grid.size\n        val visited = new mutable.HashSet[Long]()\n\
    \        val result = new mutable.ArrayBuffer[Long]()\n        val visitedCounter\
    \ = grid.zipWithIndex.filter(_._2 % gridSize == 0).map(_._1).count(_ == k)\n \
    \       if (gridSize == 0 || k == 0)\n            result\n        else if (visitedCounter\
    \ > 0)\n            result\n        else\n            visited.add(k)\n       \
    \     grid\n                .zipWithIndex\n                .filter(_._2 % gridSize\
    \ == 0)\n                .map {\n                    case (cell, index) =>\n \
    \                       val cellPosition = index / gridSize\n                \
    \        val currentCell = cell\n                        val currentCellPosition\
    \ = cellPosition\n                        val neighborCells = grid.map(_.drop(1)).flatten.toSet\n\
    \                        if (visited.contains(currentCellPosition) && neighborCells.nonEmpty)\n\
    \                            result\n                        else if (visited.contains(currentCellPosition)\
    \ && neighborCells.size == gridSize) {\n                            val index\
    \ = neighborCells.find(_ == currentCellPosition).get\n                       \
    \     val index = index + 1\n                            val cellPosition = index\
    \ / gridSize\n                            val currentCell = cell\n           \
    \                 val currentCellPosition = cellPosition\n                   \
    \         val neighborCells = grid.map(_.drop(1)).flatten.toSet\n            \
    \                visited.add(index)\n                            result\n    \
    \                    } else if (visited.contains(currentCellPosition) && neighborCells.size\
    \ == 1) {\n                            val index = neighborCells.find(_ == currentCellPosition).get\n\
    \                            val index = index + 1\n                         \
    \   val cellPosition = index / gridSize\n                            val currentCell\
    \ = cell\n                            val currentCellPosition = cellPosition\n\
    \                            val neighborCells = grid.map(_.drop(1)).flatten.toSet\n\
    \                            visited.add(index)\n                            result\n\
    \                        } else {\n                            val index = neighborCells.find(_\
    \ == currentCellPosition).get\n                            val index = index +\
    \ 1\n                            val cellPosition = index / gridSize\n       \
    \                     val currentCell = cell\n                            val\
    \ currentCellPosition = cellPosition\n                            val neighborCells\
    \ = grid.map(_.drop(1)).flatten.toSet\n                            visited.add(index)\n\
    \                            result\n                        }\n             \
    \   }\n                .toList", "        require(grid.length == grid.head.size,\
    \ \"The grid size is not valid!\")\n        val gridMap = grid.map(_.map(_ =>\
    \ Set[Long]())).toMap\n        gridMap.values.toList match {\n            case\
    \ Nil => Nil\n            case x => gridMap.values.toList.sorted.sliding(2).map\
    \ { x =>\n                val i1 = x(0).toLong\n                val i2 = x(1).toLong\n\
    \                val v1 = gridMap(i1)\n                val v2 = gridMap(i2)\n\
    \                (v1 -- v2).remove(i1)\n            }.collect {\n            \
    \    case x1 :: x2 => x1 ++ x2\n            }.head\n        }", "        val len\
    \ = grid.length\n        val minLen = len - 1\n        var i = 1\n        var\
    \ j = 1\n        var path1 = ListBuffer[Long]()\n        var path2 = ListBuffer[Long]()\n\
    \        var visited = scala.collection.mutable.HashSet[Long]()\n        var visitedIdx\
    \ = 1\n        while(i < len) {\n            visited += grid(i).head\n       \
    \     path1 += grid(i).last\n            i -= 1\n        }\n        while(j <\
    \ len) {\n            visited += grid(j).head\n            path2 += grid(j).last\n\
    \            j += 1\n        }\n        var found = false\n        var foundIdx\
    \ = 1\n        while(i < len && j < len && found == false && foundIdx <= minLen)\
    \ {\n            if(visited.contains(grid(i).last) && visited.contains(grid(j).last))\
    \ {\n                if(visited.size == 1 && (grid(i).last < grid(j).last)) {\n\
    \                    found = true\n                    path1 += grid(i).last\n\
    \                    path2 += grid(j).last\n                }\n              \
    \  else if(visited.size == 2 && (grid(i).last < grid(j).last)) {\n           \
    \         found = true\n                    path1 += grid(i).last\n          \
    \          path2 += grid(j).last\n                    visitedIdx += 1\n      \
    \              visited -= grid(i).last\n                    visited -= grid(j).last\n\
    \                }\n                else if(visited.size == 3 && (grid(i).last\
    \ < grid(j).last)) {\n                    found = true\n                    path1\
    \ += grid(i).last\n                    path2 += grid(j).last\n               \
    \     visitedIdx += 1\n                    visited -= grid(i).last\n         \
    \           visited -= grid(j).last\n                    visited -= grid(i - 1).last\n\
    \                    visited -= grid(j - 1).last\n                }\n        \
    \        else if(visited.size == 4 && (grid(i).last < grid(j).last)) {\n     \
    \               found = true\n                    path1 += grid(i).last\n    \
    \                path2 += grid(j).last\n                    visitedIdx += 1\n\
    \                    visited -= grid(i).last\n                    visited -= grid(j).last\n\
    \                    visited -= grid(i - 1).last\n                    visited\
    \ -= grid(j - 1).last\n                    visited -= grid(i - 2).last\n     \
    \               visited -= grid(j - 2).last\n                }\n             \
    \   else if(visited.size == 5 && (grid(i).last < grid(j).last)) {\n          \
    \          found = true\n                    path1 += grid(i).last\n         \
    \           path2 += grid(j).last\n                    visitedId", "        val\
    \ result: mutable.Buffer[Long] = mutable.Buffer[Long]()\n        var n = grid.size\n\
    \        var m = grid.head\n\n        var index = 0\n        var step = 0\n\n\
    \        while ( index != n ) {\n            if ( index % 2 == 1 ) {\n       \
    \         step = 1\n            } else {\n                step = -1\n        \
    \    }\n\n            var j = 0\n            var k = 0\n\n            while (\
    \ k != n ) {\n                if ( k < n ) {\n                    j = k\n    \
    \                k = n\n                } else {\n                    j = k -\
    \ n + 1\n                    k = -1\n                }\n\n                if (\
    \ grid[index].getOrElse(-1l) < grid[j].getOrElse(-1l) ) {\n                  \
    \  result.add(grid[index].getOrElse(-1l))\n                    index += step\n\
    \                } else {\n                    index += step\n               \
    \ }\n            }\n        }\n\n        if ( result.size == 0 || k != n ) {\n\
    \            minPath(grid, k + 1)\n        } else {\n            result\n    \
    \    }", "        val result = new ArrayList[Long]()\n        // Step 1: build\
    \ ordered lists\n        var index = 0\n        val lst = grid.map(_.toList)\n\
    \        val lstLen = lst.length\n        var i = 0\n        while(index<lstLen\
    \ && !lst.contains(index)){\n            i += 1\n            index += 1\n    \
    \    }\n        lst(i-1) match {\n            case i if i >= k => result.add(lst(i))\n\
    \            case i => result.add(lst(i))\n        }\n        // Step 2: find\
    \ first and last index\n        var firstIndex = index\n        var lastIndex\
    \ = index\n        while(index<lstLen && !lst.contains(index)){\n            index\
    \ += 1\n        }\n        index += 1\n        while(index<lstLen && !lst.contains(index)){\n\
    \            index += 1\n        }\n        // Step 3: recurse\n        if(lastIndex>=firstIndex){\n\
    \            minPath(grid.take(firstIndex+1).concat(grid.drop(lastIndex)), k)\
    \ match {\n                case head :: tail => head :: result.concat(tail)\n\
    \                case _ => result\n            }\n        }\n        else result",
  "        val inc = new mutable.HashMap[List[Long], List[Long]]()\n        val tmp\
    \ = new mutable.ArrayList[Long]()\n        val ans = new mutable.ArrayList[Long]()\n\
    \        inc.putAll(grid)\n        val gm = grid.map { case x => x.toList }\n\
    \        val gmm = gm.transpose\n        val n = gm.size\n        val nk = gm.map(x\
    \ => x.size).max\n        val nkl = gm.map(x => x.map(y => y.size).max).max\n\
    \        val ns = n / k\n        val nssq = ns * (ns - 1)\n        var km = k\
    \ / n\n        var km = km + (km > nkl ? 1 : 0)\n        val kl = km / ns\n  \
    \      val kls = kl + (kls > nkl ? 1 : 0)\n        while (km < n) {\n        \
    \    var kmm = km\n            var kml = kl\n            val nmm = gmm.map(x =>\
    \ x.get(kmm)).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).max\n \
    \           val nml = gmm.map(x => x.get(kml)).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).max\n            val mmk = gmm.map(x => x.get(kmm)).map(x => x.toLong).map(x\
    \ => x.toLong).map(x => x.toLong).sum\n            val mlk = gmm.map(x => x.get(kml)).map(x\
    \ => x.toLong).map(x => x.toLong).map(x => x.toLong).sum\n            val mmks\
    \ = gmm.map(x => x.get(kmm)).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).size\n\
    \            val mlks = gmm.map(x => x.get(kml)).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).size\n            var kmms = kmm + mmk\n            var kmls =\
    \ kml + mlk\n            var kmmns = kmms\n            var kmlns = kmls\n    \
    \        var nmmsq = 0\n            var nmlsq = 0\n            var mmk = gmm.map(x\
    \ => x.get(kmm)).map(x => x.toLong).map(x => x.toLong).map(x => x.toLong).sum\n\
    \            var mlk = ", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val path = new collection.mutable.ListBuffer[Long]()\n        var count\
    \ = 0\n        val grid = grid.sortWith((x, y) => x.sum < y.sum)\n        grid.foreach\
    \ {\n            x =>\n                val temp = x.drop(n).take(k)\n        \
    \        for (i <- temp.indices) {\n                    if (!temp(i).equals(x.last))\
    \ {\n                        path.append(temp(i))\n                        count\
    \ += 1\n                        break\n                    }\n               \
    \ }\n        }\n        path.toList", "        val grid = grid.toMap\n       \
    \ var ans = []\n        var start = 0l\n        while (start < grid.size) {\n\
    \            val end = start + k\n            val start1 = grid\n            var\
    \ end1 = end\n            while ((end1 < grid.size) && (start < end)) {\n    \
    \            if (end1 == end) {\n                    end1 += 1\n             \
    \   } else {\n                    if (start1.get(end1) == start) {\n         \
    \               val newStart = start\n                        val newEnd = end\n\
    \                        val oldEnd = end1\n                        start1 +=\
    \ oldEnd\n                        end1 += 1\n                        ans = List(start).sortWith(_\
    \ < _).reverse + newStart :+ newEnd\n                    }\n                }\n\
    \                end1 += 1\n            }\n            start += 1\n        }\n\
    \        ans", "        val n = grid.size\n        val path = new scala.collection.mutable.LinkedList[List[Long]]\n\
    \        val vals = grid.foldLeft(List[Long]())((x, t) => t.head +: x)\n     \
    \   path += vals.reverse\n        vals.sorted.sliding(1, n).flatMap(x => x.drop(1).map((x(i)\
    \ => x(i + 1))).toList).takeRight(k).reverse", "        val size = grid.size\n\
    \        val count = collection.mutable.ArrayBuffer.empty[Long]\n        var i\
    \ = 1\n        while(i <= size){\n            val newGrid = grid.map(x=>x.filterNot(y.toLong\
    \ => x == y))\n            val sum = grid.foldLeft((0l, 0))( (x, y) => (x._1 +\
    \ y._1, x._2 + y._2) )\n            val min = newGrid.foldLeft((0l, 0))( (x, y)\
    \ => (x._1 < y._1 && x._1 < x._2, x._2 < y._1 && x._2 < x._2) )\n            if(sum._1\
    \ < sum._2 && min._1 < min._2){\n                count += 1\n                i\
    \ <- 1\n            }\n            i += 1\n        }\n        count.toList.sorted",
  "        val N = grid.length\n        var cell: MutableList[Long] = new mutable.MutableList[Long]()\n\
    \        var ans = new mutable.MutableList[Long]()\n\n        cell.add(grid((cell.size\
    \ - 1) / 2).headOption.getOrElse(1L).toLong)\n        for (i <- 1 to N / 2)\n\
    \            cell.add(grid((2 * i - 1) / 2).headOption.getOrElse(1L).toLong)\n\
    \        for (i <- 1 to N / 2)\n            cell.add(grid((2 * i + 1) / 2).headOption.getOrElse(1L).toLong)\n\
    \n        while(cell.size != 0) {\n            var j = cell.length - 1\n     \
    \       var tmp = 0L\n            while(j >= 0) {\n                tmp = grid((cell.length\
    \ - 1 - j) / 2).headOption.getOrElse(1L).toLong\n                if (tmp < cell(i))\n\
    \                    cell.updated(j - 1, cell(i))\n                else\n    \
    \                cell.remove(j)\n                j -= 1\n            }\n     \
    \       cell = cell.tail\n            cell.foreach(tmp => ans += tmp)\n      \
    \  }\n        ans.sortWith((x, y) => x < y)", "        // first sort by row\n\
    \        val rowSort =  grid.map(row => row.sortBy(_.toLong))\n        val sortedGrid\
    \ = rowSort.flatMap(_.toList)\n\n        // sort the grid rows by column\n   \
    \     val columnSort = sortedGrid.map(row => row.sortBy(_.toLong))\n        val\
    \ colSortedGrid = columnSort.flatMap(_.toList)\n\n        // then sort each row\
    \ by column\n        val rowSortByCol = colSortedGrid.map(row => row.sortBy(_.toLong))\n\
    \        val sortedRowByCol = rowSortByCol.flatMap(_.toList)\n\n        // now\
    \ let's compare these sorted lists with each other row by column\n        // and\
    \ find the minimum\n        val rows = sortedRowByCol.zipWithIndex\n        val\
    \ firstPath = rows.drop(1)\n\n        var minPathValues = List[Long]()\n     \
    \   for ((index, row) <- firstPath.zipWithIndex) {\n            val rowVal = row(0).toLong\n\
    \            if (rowVal == k) {\n                minPathValues = row(1).toList.sortBy(_.toLong)\n\
    \                break\n            }\n        }\n        return minPathValues",
  "        var visited : Set[Long] = Set.empty\n        var minPath : List[Long] =\
    \ List.empty\n        var gridCopy : List[List[Long]] = grid -- minPath\n    \
    \    var path : List[List[Long]] = minPath\n        \n        // Step 1: Set up\
    \ a priority queue to hold the cells whose adjacent cells \n        // are going\
    \ to be visited.\n        // Initially all cells visited.\n        var queue =\
    \ new PriorityQueue[(List[Long], Long)]\n        for (i <- 1 to grid.size) {\n\
    \            var cell = gridCopy(i)\n            visited += cell(0)\n        \
    \    queue.enqueue((List(cell(0)), cell))\n        }\n        \n        // Step\
    \ 2: Do while there are cells left in priority queue.\n        while( queue.nonEmpty\
    \ ) {\n            // Get the cell whose adjacent cells will be visited.\n   \
    \         // Pop it from the queue.\n            val (cells, current) = queue.poll()\n\
    \            \n            for( cell <- cells ) {\n                // If the cell\
    \ is visited before and it's adjacent cells are\n                // already in\
    \ the queue, add the cell in the queue to our minPath\n                // list.\n\
    \                if(visited.contains(cell(0)) && visited.isSubsetOf(cells.map(c\
    \ => c(0)))) {\n                    path += List(cell)\n                    visited\
    \ += cell(0)\n                } else if(visited.contains(cell(0)) && !visited.isSubsetOf(cells.map(c\
    \ => c(0)))) {\n                    // If the cell has already been visited, add\
    \ it to our minPath\n                    // list and pop it from the queue.\n\
    \                    path += List(cell)\n                    visited += cell(0)\n\
    \                    queue.enqueue((List(cell(0)), cell))\n                }\n\
    \            }\n        }\n        \n        // Step 3: Return the minPath list.\n\
    \        minPath", "        if(grid.isEmpty) Nil\n        else k == 1 ? List(grid()(0))\n\
    \                : grid.map{case List(x) => x}\n                .groupBy(xs =>\
    \ xs.takeWhile(_ <= k).takeRight(k).distinct)\n                .mapValues(xs =>\
    \ xs.last).values.flatten", "        val N = grid.head.size\n        val m = grid.size\n\
    \        val visited = new collection.mutable.HashSet[Int]\n        var min :\
    \ Long = 0\n        var i : Int = 0\n        visited.add(i)\n\n        var lst_A\
    \ : List[Long] = List[Long]()\n        var lst_B : List[Long] = List[Long]()\n\
    \        for( i <- 1 to k) {\n            val row = i / N\n            val col\
    \ = i % N\n\n            var sum = 0\n            var max = 0\n            val\
    \ cell = grid(row)(col)\n            sum += cell\n            max = math.max(max,\
    \ cell)\n\n            lst_A += cell\n        }\n        for( i <- 0 to m - k)\
    \ {\n            val row = i / N\n            val col = i % N\n\n            val\
    \ cell = grid(row)(col)\n            sum += cell\n            val max = math.max(max,\
    \ cell)\n            max = math.max(max, sum)\n\n            if(visited.contains(col)\
    \ == false) {\n                visited.add(col)\n                lst_B += cell\n\
    \            }\n\n            if(lst_A <= lst_B) {\n                if(lst_A <\
    \ lst_B) {\n                    min = math.min(min, sum)\n                   \
    \ lst_A = lst_A.drop(j)\n                }\n                else {\n         \
    \           min = math.min(min, max)\n                    lst_B = lst_B.drop(j)\n\
    \                }\n            }\n            else {\n                if(lst_A\
    \ > lst_B) {\n                    min = math.min(min, max)\n                 \
    \   lst_A = lst_A.drop(j)\n                }\n                else {\n       \
    \             min = math.min(min, sum)\n                    lst_B = lst_B.drop(j)\n\
    \                }\n            }\n        }\n        visited.remove(i)\n    \
    \    lst_A", "        val path = new scala.collection.mutable.ListBuffer[Long]\n\
    \        val visited = new scala.collection.mutable.Set[Long]\n        val n =\
    \ grid.map(_.size).sum\n        var minPathSize = k\n        for(i<-1 to n-1){\n\
    \            if(!visited(i))\n                visited(i) = true\n            else{\n\
    \                val tempSize = grid(i).size\n                var tempSum = grid(i).sum\n\
    \                for(j <-0 to tempSize - k){\n                    if(!visited(j+i))\n\
    \                        visited(j+i) = true\n                    else{\n    \
    \                    val tempPathSum = tempSum + grid(i)(j)\n                \
    \        if(tempPathSum > minPathSize){\n                            minPathSize\
    \ = tempPathSum\n                            path.clear()\n                  \
    \          path.append(grid(i)(j))\n                        }\n              \
    \          if(tempPathSum == minPathSize)\n                            path.append(grid(i)(j))\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ path", "        val gridList = grid.toList\n        val numRow = gridList.size\n\
    \        val numCol = gridList.head.size\n        var minPathList = List[Long]()\n\
    \        // Create set of visited cells, for each row, column\n        var numVisitedRow\
    \ = 0\n        var numVisitedCol = 0\n        for (i <- 0 to numRow - 1) {\n \
    \           var newRow = i\n            var newCol = 0\n            while (newCol\
    \ < numCol) {\n                if (gridList(newRow) contains gridList(newRow)(newCol))\n\
    \                {\n                    // check if we found new cell\n      \
    \              newCol++\n                }\n                else\n           \
    \     {\n                    // no new cell, remove from existing cell\n     \
    \               if (newCol < numCol)\n                    {\n                \
    \        newRow++\n                    }\n                    else\n         \
    \           {\n                        // we reached a point on which all cells\
    \ are visited\n                        // we found a path, add to list\n     \
    \                   minPathList :+= gridList(newRow)(newCol)\n               \
    \         numVisitedRow++\n                        numVisitedCol++\n         \
    \               // reset for next iteration\n                        newRow =\
    \ newRow + 1\n                        newCol = 0\n                    }\n    \
    \            }\n            }\n        }\n        // create list to hold cells\
    \ that cannot be visited\n        // because we reached a point on which all cells\
    \ are visited\n        val maxVisitedRow = (numRow * numCol) - numVisitedRow\n\
    \        val maxVisitedCol = (numRow * numCol) - numVisitedCol\n        val noVisitedCells\
    \ = List(0 to maxVisitedRow).map(i => List(0 to maxVisitedCol).map(j => 0l)).toList\n\
    \        // add no visited cells to list\n        minPathList :+= noVisitedCells.head.map(c\
    \ => c).flatten\n        // iterate through each row\n        for (i <- 0 to numRow\
    \ - 1)\n        {\n            // iterate through each column\n            for\
    \ (j <- 0 to numCol - 1)\n            {\n                var newRow = i\n    \
    \            var newCol = j\n                while (newRow < numRow && newCol\
    \ < numCol)\n                {\n                    if (gridList(newRow) contains\
    \ gridList(newRow)(newCol))\n                    {\n                        newCol++\n\
    \                    }\n                    else\n                    {\n    \
    \                    newRow++\n                    }\n                }\n    \
    \            // check if we found new cell\n                if (newRow < numRow)\n\
    \                {\n                    newCol = j\n                }\n      \
    \          else\n                {\n                    // we reached a point\
    \ on which all cell", "        def generatePath(grid : List[List[Long]], i : Int,\
    \ j : Int) : List[List[Long]] = {\n            def generatePathHelper(grid : List[List[Long]],\
    \ i : Int, j : Int, path : List[List[Long]]) : List[List[Long]] = {\n        \
    \        if (i == 0 || j == 0 || i == grid.length-1 || j == grid[0].length-1)\
    \ {\n                    path ::: grid\n                } else {\n           \
    \         generatePathHelper(grid, i, j-1, path ++ List(grid[i][j]))\n       \
    \             generatePathHelper(grid, i+1, j-1, path ++ List(grid[i][j]))\n \
    \                   generatePathHelper(grid, i-1, j, path ++ List(grid[i][j]))\n\
    \                    generatePathHelper(grid, i-1, j+1, path ++ List(grid[i][j]))\n\
    \                }\n            }\n            generatePathHelper(grid, i, j,\
    \ List())\n        }\n\n        var lst_A = new scala.collection.mutable.ArrayBuffer[Long]()\n\
    \        var lst_B = new scala.collection.mutable.ArrayBuffer[Long]()\n      \
    \  grid.foreach(t => {\n            lst_A += t._1.toLong\n            lst_B +=\
    \ t._2.toLong\n        })\n        lst_A.sort { l1 => l1 }\n        lst_B.sort\
    \ { l2 => l2 }\n\n        var retList = List[Long]()\n        if (lst_A.size ==\
    \ k) {\n            retList = lst_A.toList\n        } else if (lst_B.size == k)\
    \ {\n            retList = lst_B.toList\n        } else {\n            var i =\
    \ 0\n            var j = 0\n            var start = 0\n            while (i <\
    \ k) {\n                var found = 0\n                if (lst_A.length > 0) {\n\
    \                    found = lst_A.indexOf(lst_B(0))\n                    while\
    \ (found > -1) {\n                        val temp = lst_B(0)\n              \
    \          lst_B(0) = lst_A(found)\n                        lst_A(found) = temp\n\
    \                        found = -1\n                    }\n                }\n\
    \                if (lst_B.length > 0) {\n                    found = lst_B.indexOf(lst_A(0))\n\
    \                    while (found > -1) {\n                        val temp =\
    \ lst_A(0)\n                        lst_A(0) = lst_B(found)\n                \
    \        lst_B(found) = temp\n                        found = -1\n           \
    \         }\n                }\n                if (found == -1) {\n         \
    \           i += 1\n                    j += 1\n                } else {\n   \
    \                 start += 1\n                    i += 1\n                   \
    \ j += 1\n                }\n            }\n            val list = generatePath(grid,\
    \ start, k, retList)\n            list.sort((a, b) => a zip b).map { case (a,\
    \ b) => a }\n        }\n        retList", "        val size = grid.size\n    \
    \    var currentPos : Long = 0\n        var currentVal : Long = 0\n        var\
    \ pathSize : Long = 0\n        var path : List[Long] = Nil\n        while (currentPos\
    \ < size) {\n            if (pathSize < k) {\n                currentVal = grid(currentPos)(0)\n\
    \                val newPath = grid.map {\n                    x => if (x(0) <\
    \ currentVal) List(currentVal) else List(currentVal, x(1))\n                }.toList\n\
    \                pathSize = path.size\n                if (newPath.nonEmpty)\n\
    \                    path = newPath\n            }\n            currentPos +=\
    \ 1\n        }\n        path", "        val lst_A : List[Long] = grid.foldLeft((List[Long](0l.toLong),\
    \ List[Long](0l.toLong))) { case ((lst_A, (lst_B)), (element)) =>\n          \
    \  (lst_A.append(element.take(k)), (lst_B.append(element.drop(k))) ) }\n     \
    \   val lst_B : List[Long] = grid.reverse.foldLeft((List[Long](0l.toLong), List[Long](0l.toLong)))\
    \ { case ((lst_A, (lst_B)), (element)) =>\n            (lst_A.append(element.take(k)),\
    \ (lst_B.append(element.drop(k))) ) }\n        lst_A.takeWhile { element => lst_B.reverse.takeWhile(_\
    \ < element).size < k } ++ lst_B.reverse", "        require(grid.toList.forall(_.toList.forall(_.toLong\
    \ inRange 1L until k.toLong)))\n        val graph = mutable.ArrayBuffer.empty[(List[Long],\
    \ List[Long])]\n        for (row <- grid) {\n            for (cell <- row) {\n\
    \                for (i <- 1 to k) {\n                    graph.+=(List(cell.tail,\
    \ i)::row)\n                    graph.+=(List(i::cell.tail)::row)\n          \
    \      }\n            }\n        }\n        val values = graph.map(x => x.mkString(\"\
    ,\"))\n        values.filter(_ != \"\").distinct", "      val n = grid.length\n\
    \      val m = grid(0).length\n      val set = mutable.HashSet[Long]()\n     \
    \ val list = mutable.ArrayBuffer.empty[Long]\n      grid(0).zip(grid(1)).foreach\
    \ {\n        case (l, r) =>\n          list.clear\n          for (i <- 1 to k)\
    \ {\n            val pos = i * n + i\n            val cur = grid(pos)\n      \
    \      if (cur < l || cur < r) list.add(cur)\n          }\n          set.clear()\n\
    \          list.foreach{ e =>\n            set.add(e)\n          }\n         \
    \ if (set.size == k) list :+ l\n      }\n      list.sort", "        val N = grid.size\n\
    \        val m = grid.head.size\n        var minPath: List[Long] = Nil :: Nil\
    \ :: Nil\n        val m = grid.head.size\n        for (i <- 1 until N) {\n   \
    \         for (j <- 1 until m) {\n                if (grid((i - 1)/m + j) == grid((i)/m\
    \ + j) && j < k) {\n                    val l = min(grid((i - 1)/m + j), grid((i)/m\
    \ + j))\n                    val m = grid((i)/m + j).indexOf(l) + 2\n        \
    \            val newMinPath = grid((i)/m + j).drop(m) ::: minPath\n          \
    \          if (newMinPath.size < minPath.size) {\n                        minPath\
    \ = newMinPath\n                    }\n                }\n            }\n    \
    \    }\n        minPath", "        val gv = grid.map{x=>x.map(x=>x)}\n       \
    \ val paths: List[List[Long]] = new ListBuffer[List[Long]]()\n        var gridx\
    \ = gv(0)\n        var gridy = gv(1)\n        var count = 0\n        while count\
    \ < k {\n            paths.append(gv).sortWith((x,y)=>x>y).take(k).map(x=>xv(x)).toList\n\
    \            count += 1\n            gridx = gv(0)\n            gridy = gv(1)\n\
    \        }\n        paths.sortWith((x,y)=>x>y).take(k).map(x=>xv(x)).toList",
  "        val path = new ArrayList[Long]\n        val edge = new HashMap[Long, HashSet[Long]]()\n\
    \        val resultSet = new HashSet[Long]()\n        for (row <- 0 until grid.length)\n\
    \            for (col <- 0 until grid.length)\n                if (!edge.getOrElse(row,\
    \ Set.empty).contains(col))\n                    edge(row) = edge.getOrElse(row,\
    \ new HashSet[Long]())\n        for (row <- 0 until grid.length) {\n         \
    \   edge.getOrElse(row, new HashSet[Long]).foreach(col => edge(row) += col)\n\
    \        }\n        for (row <- 0 until grid.length)\n            if (edge(row).size\
    \ < k)\n                for (col <- 0 until grid.length)\n                   \
    \ if (edge.getOrElse(row, Set.empty).contains(col))\n                        if\
    \ (grid.get(row).contains(col))\n                            path.add((row, col))\n\
    \        for (row <- 0 until grid.length)\n            if (edge(row).size > k)\n\
    \                for (col <- 0 until grid.length)\n                    if (edge.getOrElse(row,\
    \ Set.empty).contains(col)) {\n                        val path = minPath(grid,\
    \ k - edge(row).size)\n                        path.foreach(x => resultSet.add(x))\n\
    \                    }\n        resultSet", "        // Use a hashmap to check\
    \ if there are any duplicates\n        val hashMap : scala.collection.mutable.HashMap[Long,\
    \ Boolean] =\n            grid.foldLeft(new scala.collection.mutable.HashMap[Long,\
    \ Boolean]())((map, row) => row.foldLeft(map)({\n                m =>\n      \
    \              m._2 match {\n                        case false =>\n         \
    \                   m._1 += row\n                            true\n          \
    \              case true =>\n                            m._1 += row\n       \
    \                     false\n                    }\n            }))\n        //\
    \ Check all cells in order\n        val hashMapValues : Map[Long, Boolean] = hashMap.mapValues({\n\
    \            x => true\n        })\n        // For each hash map entry, iterate\
    \ all possible combinations, find the lowest one\n        val lowestValues = hashMap.mapValues({\n\
    \            x => x._2.foldLeft(new scala.collection.mutable.ListBuffer[Long]())({\n\
    \                val list = x._1\n                list += x._2.toLong\n      \
    \          list\n            }).toList\n        }).filter({\n            x =>\
    \ hashMapValues.contains(x)\n        })\n        // Return the result\n      \
    \  lowestValues.toList.sortWith((x, y) => x < y).toList", "        if (grid.isEmpty)\
    \ List() \n        else k match {\n            case 0 => minPath(grid.tail, k)\n\
    \            case _ => {\n                val firstCell = grid.head\n        \
    \        val allPaths = grid.filter(_ != firstCell)\n                val newCell\
    \ = allPaths.last.head + k\n                val newPaths = allPaths.filter(_ !=\
    \ newCell)\n                val newCells = newPaths.filter(_ != firstCell)\n \
    \               val newPathsWithNewCell = allPaths.filter(_ != newCell).flatMap\
    \ { case (current, cell) =>\n                    val newCellWithCurrentCell =\
    \ cell + current\n                    val newPathsWithNewCellWithCurrentCell =\
    \ newPaths.filter(_ != newCellWithCurrentCell)\n                    newCellWithCurrentCell\
    \ :: newPathsWithNewCellWithCurrentCell\n                }\n                minPath(newPathsWithNewCell,\
    \ k) :: minPath(newCells, k)\n            }\n        }", "        var visited\
    \ = new scala.collection.mutable.HashSet[Long]()\n        val orderedListOfValues\
    \ = grid.flatMap(_.toList)\n        val orderedListOfValuesIndicesArray = \n \
    \           orderedListOfValues.zipWithIndex.map(x => (x._2, x._1)).toArray\n\
    \        val sortedArrayOfValuesIndicesArray = \n            scala.math.Ordering.int().orderingBy[Long](_.swap).toArray(orderedListOfValuesIndicesArray)\n\
    \        var minPath = new scala.collection.mutable.ArrayList[Long]()\n      \
    \  minPath += k\n        visited += k\n        while (sortedArrayOfValuesIndicesArray.length\
    \ > 0) {\n            val currentElement = sortedArrayOfValuesIndicesArray(0)\n\
    \            minPath.clear()\n            minPath += currentElement\n        \
    \    val firstNeighbours = \n                sortedArrayOfValuesIndicesArray.filter(_._1\
    \ == currentElement)\n            val secondNeighbours = \n                sortedArrayOfValuesIndicesArray.filter(_._1\
    \ == currentElement)\n            val thirdNeighbours = \n                sortedArrayOfValuesIndicesArray.filter(_._1\
    \ == currentElement)\n            val fourthNeighbours = \n                sortedArrayOfValuesIndicesArray.filter(_._1\
    \ == currentElement)\n            val firstNeighbourValue = \n               \
    \ firstNeighbours.map(x => x._2).sortBy(_.swap).toList.head\n            val secondNeighbourValue\
    \ = \n                secondNeighbours.map(x => x._2).sortBy(_.swap).toList.head\n\
    \            val thirdNeighbourValue = \n                thirdNeighbours.map(x\
    \ => x._2).sortBy(_.swap).toList.head\n            val fourthNeighbourValue =\
    \ \n                fourthNeighbours.map(x => x._2).sortBy(_.swap).toList.head\n\
    \            if (firstNeighbourValue < secondNeighbourValue && \n            \
    \    firstNeighbourValue < thirdNeighbourValue && \n                firstNeighbourValue\
    \ < fourthNeighbourValue) {\n                sortedArrayOfValuesIndicesArray(0)\
    \ = secondNeighbourValue\n            } else if (secondNeighbourValue < firstNeighbourValue\
    \ && \n                secondNeighbourValue < thirdNeighbourValue && \n      \
    \          secondNeighbourValue < fourthNeighbourValue) {\n                sortedArrayOfValuesIndicesArray(0)\
    \ = thirdNeighbourValue\n            } else if (thirdNeighbourValue < firstNeighbourValue\
    \ && \n                thirdNeighbourValue < secondNeighbourValue && \n      \
    \          thirdNeighbourValue < fourthNeighbourValue) {\n                sortedArrayOf",
  "        val cells: scala.collection.mutable.Set[Long] = scala.collection.mutable.Set()\n\
    \        val graph: mutable.Map[Long, mutable.Set[Long]] = mutable.Map.empty\n\
    \        for (row <- grid) {\n            for (cell <- row) {\n              \
    \  if (cells.contains(cell))\n                    continue\n                if\
    \ (graph.get(cell).isEmpty) {\n                    graph += cell -> scala.collection.mutable.Set.empty\n\
    \                } else {\n                    val newCells = graph.get(cell)\n\
    \                    newCells ++= cells\n                    graph += cell ->\
    \ newCells\n                }\n                cells += cell\n            }\n\
    \        }\n        val result: List[Long] = scala.collection.mutable.ListBuffer.empty\n\
    \        val visited: mutable.Set[Long] = scala.collection.mutable.Set()\n   \
    \     val visitedIndex: mutable.Map[Long, Int] = mutable.Map.empty\n        def\
    \ visit(cell: Long, cells: List[Long]): Boolean = {\n            visited += cell\n\
    \            visitedIndex += cell -> cells.indexOf(cell)\n            val newCells\
    \ = graph.get(cell)\n            if (newCells == null) {\n                return\
    \ false\n            } else {\n                cells ++= newCells\n          \
    \      val visit: Boolean = cells.forall(cell => visit(cell, cells))\n       \
    \         if (!visit) {\n                    val isVisited = visited.contains(cell)\n\
    \                    if (!isVisited) {\n                        val i = visitedIndex.get(cell)\n\
    \                        result.push(cells(i))\n                    }\n      \
    \          }\n            }\n            true\n        }\n        for (cell <-\
    \ cells) {\n            if (visited.contains(cell)) {\n                continue\n\
    \            }\n            val newCells = graph.get(cell)\n            if (newCells\
    \ == null || newCells.isEmpty) {\n                continue\n            } else\
    \ {\n                val visit: Boolean = cells.forall(cell => visit(cell, cells))\n\
    \                if (!visit) {\n                    val isVisited = visited.contains(cell)\n\
    \                    if (!isVisited) {\n                        val i = visitedIndex.get(cell)\n\
    \                        result.push(cells(i))\n                    }\n      \
    \          }\n            }\n        }\n        result.sortWith((l1, l2) => l1\
    \ < l2)", "        var minPathVal = List[Long]()\n        var minPathLen = List[Long]()\n\
    \        val m = grid.head.length\n        if (k > m * m) return minPathVal\n\
    \        for (i<- 1 to m-1) {\n            for (j<- i to m-1) {\n            \
    \    val path = scala.collection.mutable.LinkedHashSet()\n                path.addLast(grid(i)(j).toLong)\n\
    \                if (path.size < k) minPathVal :+= grid(i)(j).toLong\n       \
    \         if (path.size == k) {\n                    minPathVal :+= path.toList\n\
    \                    minPathLen :+= k\n                }\n            }\n    \
    \    }\n        minPathVal.toList", "        var min_path : List[Long] = List[Long]()\n\
    \        var min_path_size : Long = 1\n        var lst_A : List[Long] = List[Long]()\n\
    \        var lst_B : List[Long] = List[Long]()\n        var i : Long = 1\n   \
    \     var j : Long = 1\n        while (i < grid.length && j < grid.length) {\n\
    \            if (grid(i)(j) == grid(i)(j)) {\n                lst_A.append(grid(i)(j))\n\
    \                lst_B.append(grid(i)(j))\n                i += 1\n          \
    \      j += 1\n            } else {\n                if (lst_A.size < lst_B.size)\
    \ {\n                    i += 1\n                } else {\n                  \
    \  j += 1\n                }\n            }\n        }\n        // now lst_A and\
    \ lst_B have the values that A goes through\n        // now we need to compare\
    \ the values of lst_A and lst_B\n        while (i < grid.length) {\n         \
    \   if (lst_A.length > 0) {\n                if (lst_A(lst_A.size - 1) < lst_B(lst_B.size\
    \ - 1)) {\n                    min_path = lst_A.reverse\n                    min_path_size\
    \ = lst_A.size\n                } else {\n                    min_path = lst_B.reverse\n\
    \                    min_path_size = lst_B.size\n                }\n         \
    \       min_path.reverse\n            }\n            lst_A.removeAt(0)\n     \
    \       i += 1\n        }\n        while (j < grid.length) {\n            if (lst_B.length\
    \ > 0) {\n                if (lst_A(lst_A.size - 1) < lst_B(lst_B.size - 1)) {\n\
    \                    min_path = lst_A.reverse\n                    min_path_size\
    \ = lst_A.size\n                } else {\n                    min_path = lst_B.reverse\n\
    \                    min_path_size = lst_B.size\n                }\n         \
    \       min_path.reverse\n            }\n            lst_B.removeAt(0)\n     \
    \       j += 1\n        }\n        min_path", "        val list = grid.toList\
    \ match {\n            case Nil => List()\n            case list => list\n   \
    \     }\n        val len = list.size\n        val lst_A = List[Long](1l.toLong)\n\
    \        val lst_B = List[Long](1l.toLong)\n        for (i <- 1 to len) {\n  \
    \          val curr_ind = i - 1\n            lst_A += list(curr_ind)\n       \
    \     val min_idx = math.min(i, k)\n            lst_B += list(min_idx)\n     \
    \   }\n        lst_A", "        val n = grid.length\n        var count = 0\n \
    \       var currentIndex = n - 1\n        var currentValue = 0L\n        var minPath\
    \ = List[Long](grid.head.head.asInstanceOf[Long])\n\n        while (currentIndex\
    \ > -1) {\n            val currentValue = (grid(currentIndex).head)\n        \
    \    val newIndex = ((currentIndex - 1)%n)\n            val newValue = (grid(newIndex).head)\n\
    \            var newPath : List[Long] = List(currentValue)\n            val maxValue\
    \ = newPath.length\n            while (maxValue > 1) {\n                var maxValue1\
    \ = maxValue - 1\n                var maxIndex1 = newIndex\n                var\
    \ maxValue2 = maxValue\n                var maxIndex2 = newIndex\n           \
    \     var maxValue3 = maxValue\n                var maxIndex3 = newIndex\n   \
    \             while (maxValue2 > 0) {\n                    if (grid(maxIndex2).head\
    \ <= maxValue1) {\n                        maxValue1 -= 1\n                  \
    \      maxIndex2 -= 1\n                    } else if (grid(maxIndex3).head <=\
    \ maxValue2) {\n                        maxValue2 -= 1\n                     \
    \   maxIndex3 -= 1\n                    } else {\n                        maxValue3\
    \ -= 1\n                    }\n                }\n                newPath = (newPath\
    \ + grid(maxIndex3).head + grid(maxIndex2).head + grid(maxIndex1).head)\n    \
    \            maxValue = (maxValue3 + maxValue2 + maxValue1)\n            }\n \
    \           val minValue = (newPath.length)\n            if (minValue <= k) {\n\
    \                count += 1\n                minPath = newPath.asInstanceOf[List[Long]]\n\
    \            }\n            if (minValue > k) {\n                count += 1\n\
    \                minPath = currentPath.asInstanceOf[List[Long]]\n            }\n\
    \            currentIndex = newIndex\n            currentValue = newValue\n  \
    \      }\n        minPath", "        val m = grid.length\n        val n = grid[0].length\n\
    \        var visited = new Array[Boolean](m * n)\n        var visited_temp = new\
    \ Array[Boolean](m * n)\n        var min = List[Long]()\n        var index_min\
    \ = -1\n        var index = -1\n        var visited_index = -1\n        var index_min2\
    \ = -1\n        var index2 = -1\n        var visited_index2 = -1\n        var\
    \ index_min3 = -1\n        var index3 = -1\n        var visited_index3 = -1\n\
    \        var index_min4 = -1\n        var index4 = -1\n        var visited_index4\
    \ = -1\n        var index_min5 = -1\n        var index5 = -1\n        var visited_index5\
    \ = -1\n        var index_min6 = -1\n        var index6 = -1\n        var visited_index6\
    \ = -1\n        var index_min7 = -1\n        var index7 = -1\n        var visited_index7\
    \ = -1\n        var index_min8 = -1\n        var index8 = -1\n        var visited_index8\
    \ = -1\n        var index_min9 = -1\n        var index9 = -1\n        var visited_index9\
    \ = -1\n        var index_min10 = -1\n        var index10 = -1\n        var visited_index10\
    \ = -1\n        var index_min11 = -1\n        var index11 = -1\n        var visited_index11\
    \ = -1\n        var index_min12 = -1\n        var index12 = -1\n        var visited_index12\
    \ = -1\n        var index_min13 = -1\n        var index13 = -1\n        var visited_index13\
    \ = -1\n        var index_min14 = -1\n        var index14 = -1\n        var visited_index14\
    \ = -1\n        var index_min15 = -1\n        var index15 = -1\n        var visited_index15\
    \ = -1\n        var index_min16 = -1\n        var index16 = -1\n        var visited_index16\
    \ = -1\n        var index_min17 = -1\n        var index17 = -1\n        var visited_index17\
    \ = -1\n        var index_min18 = -1\n        var index18 = -1\n        var visited_index18\
    \ = -1\n        var index_min19 = -1\n        var index19 = -1\n        var visited_index19\
    \ = -1\n        var index_min20 = -1\n        var index20 = -1\n        var visited_index20\
    \ = -1\n        var index_min21 = -1\n        var index21 = -1\n        var visited_index21\
    \ = -1\n        var index_min22 = -1\n        var index22 = -1\n        var visited_index22\
    \ = -1\n        var index_min23 = -1\n        var index23 = -1\n        var visited_index23\
    \ = -1\n        var index_min24 = -1\n        var index24 = -1\n        var visited_index24\
    \ = -1\n        var index_min25 = -1\n        var index25 = -1\n        var visited_index25\
    \ = -1\n        var index_min26 = -1\n        var index26 = -1\n        var visited_index26\
    \ = -1", "        val N = grid.length\n        val A = ArrayBuffer.empty[(Int,\
    \ List[Long])]\n        var low = grid.length\n        var high = N * N\n    \
    \    var sum = 0L\n        while (high > 0) {\n            val numCells = high\n\
    \            val list = grid.toList.sortBy(-_._2)\n            val list = list.take(numCells)\n\
    \            val temp = list.flatMap {\n                case List(i, j) => grid((i\
    \ + k) % N, (j + k) % N)\n                case i => List(i -> grid((i + k) % N,\
    \ 0))\n            }.toList\n            var temp = temp.sortBy(-_._1).toList\n\
    \            val temp2 = temp.reverse\n            var temp3 = temp2.filter(_._1\
    \ != 0).toList\n            val l = temp3.reverse.filter(_._1 != 0).toList\n \
    \           val m = temp3.reverse.filter(_._1 == 0).toList\n            val s\
    \ = temp3.reverse.filter(_._1 > 0).toList\n            val temp4 = temp3.filter(_._1\
    \ != 0).toList\n            val temp5 = temp3.reverse.filter(_._1 == 0).toList\n\
    \            val temp6 = temp3.reverse.filter(_._1 > 0).toList\n            val\
    \ temp7 = temp3.filter(_._1 != 0).toList\n            val temp8 = temp3.reverse.filter(_._1\
    \ == 0).toList\n            val temp9 = temp3.reverse.filter(_._1 > 0).toList\n\
    \            val temp10 = temp3.filter(_._1 != 0).toList\n            val temp11\
    \ = temp3.reverse.filter(_._1 == 0).toList\n            val temp12 = temp3.reverse.filter(_._1\
    \ > 0).toList\n            val temp13 = temp3.filter(_._1 != 0).toList\n     \
    \       val temp14 = temp3.reverse.filter(_._1 == 0).toList\n            val temp15\
    \ = temp3.reverse.filter(_._1 > 0).toList\n            val temp16 = temp3.filter(_._1\
    \ != 0).toList\n            val temp17 = temp3.reverse.filter(_._1 == 0).toList\n\
    \            val temp18 = temp3.reverse.filter(_._1 > 0).toList\n            val\
    \ temp19 = temp3.filter(_._1 != 0).toList\n            val temp20 = temp3.reverse.filter(_._1\
    \ == 0).toList\n            val temp21 = temp3.reverse.filter(_._1 > 0).toList\n\
    \            val temp22 = temp3.filter(_._1 != 0).toList\n            val temp23\
    \ = temp3.reverse.filter(_._1 == 0).toList\n            val temp", "        var\
    \ lst = grid.foldLeft(List.empty[Long]) {\n            case (acc, row) => (acc.head\
    \ :: row).sorted }\n        var i = 0\n        while (i < lst.size) {\n      \
    \      var j = 0\n            while (j < lst.size && lst(j) < lst(i) + k) {\n\
    \                j += 1\n            }\n            i += 1\n            lst.updated(j,\
    \ lst(j) - k)\n        }\n        lst.tail", "        var lst = grid\n       \
    \ var lst2 = grid\n        var count = 0\n        var index = 0\n        while(index\
    \ != grid.length){\n            if(lst2(index) == lst(index)){\n             \
    \   lst2(index) = new List[Long]()\n            }\n            else{\n       \
    \         lst2(index) = lst(index)\n                lst2(index) = new List[Long]()\n\
    \            }\n            lst2(index) += lst(index)\n            index += 1\n\
    \        }\n        var ans = ListBuffer[Long]()\n        var count = 0\n    \
    \    while(count != index){\n            ans += lst(count)\n            count\
    \ += 1\n        }\n        ans -= lst(index)\n        ans.toList", "        if\
    \ (grid.size < 2)\n            throw new IllegalArgumentException(\"grid must\
    \ have at least 2 cells\")\n        val nR = grid.head\n        val nC = grid.last\n\
    \        val nR = grid\n        val nC = grid\n        val lst_R = nR.toList\n\
    \        val lst_C = nC.toList\n        var lst_A = new List[Long]\n        var\
    \ lst_B = new List[Long]\n        var j = 0\n        var i = 1\n        val lst_R1\
    \ = lst_R.toList\n        val lst_C1 = lst_C.toList\n        var r = 0\n     \
    \   var c = 0\n        while (i <= nR.size) {\n            while (j <= nC.size)\
    \ {\n                if (lst_R(j) < (lst_C(j - 1) + lst_C1(j))) {\n          \
    \          lst_A = lst_R\n                    lst_B = lst_C\n                \
    \    lst_A.update((i + 1), lst_R(j))\n                    lst_B.update((i + 1),\
    \ lst_C(j - 1))\n                    val ii = i + 1\n                    val jj\
    \ = j - 1\n                    lst_A(ii) = lst_B(ij)\n                }\n    \
    \            else\n                    lst_A = lst_R\n                lst_B =\
    \ lst_C\n                lst_A.update((i + 1), lst_R(j))\n                lst_B.update((i\
    \ + 1), lst_C(j - 1))\n                val ii = i + 1\n                val jj\
    \ = j - 1\n                lst_A(ii) = lst_B(ij)\n                i += 1\n   \
    \             j += 1\n            }\n            i += 1\n            r = 0\n \
    \           c = 1\n        }\n        lst_A", "        if (grid.isEmpty)\n   \
    \         List()\n        else {\n            def dfs(i : Int, visited : Set[Long],\
    \ ans : List[Long], l : Long) : List[Long] = {\n                if (visited.size\
    \ == grid.size)\n                    ans\n                else {\n           \
    \         val newVisited = visited + (grid((i).toLong))\n                    if\
    \ (i == 0)\n                        dfs(1, newVisited, ans +: dfs(0, newVisited,\
    \ ans, l + 1), l)\n                    else\n                        dfs(1, newVisited,\
    \ ans, l)\n                }\n            }\n            val visited = new mutable.HashSet[Long]()\n\
    \            val ans = new mutable.ListBuffer[Long]\n            dfs(0, visited,\
    \ ans, 0L)\n            ans.toList\n        }", "        val visited = mutable.BitSet(grid.size)\n\
    \        val q = Queue[List[Long]]()\n        q.enqueue(grid)\n        while (q.length\
    \ > 0 && visited.length < grid.size) {\n            val cell = q.dequeue()\n \
    \           if (cell.size == k) {\n                visited.set(cell.index)\n \
    \               cell :: q.enqueue(cell.tail)\n            } else {\n         \
    \       for (r <- 1 to cell.length - 1) {\n                    val newCell = cell.take(r).toList\n\
    \                    if (newCell.size == k) {\n                        newCell\
    \ :: q.enqueue(newCell.tail)\n                    } else {\n                 \
    \       val l = newCell.take(cell.size - 1).toList\n                        val\
    \ k = newCell.drop(cell.size - 1).toList\n                        val c = cell.toList.take(cell.size\
    \ - 1).toList\n                        val s = cell.toList.drop(cell.size - 1).toList\n\
    \                        q.enqueue(List(newCell, c))\n                       \
    \ q.enqueue(List(newCell, s))\n                        q.enqueue(List(newCell,\
    \ k))\n                    }\n                }\n            }\n        }\n  \
    \      val ans = visited.filter(_ == false).map(x => x % N).toList\n        if\
    \ (visited.size > grid.size)\n            ans ::: minPath(grid, k - visited.size\
    \ - 1)\n        else\n            ans", "        val m = grid.map(_.size).sum\n\
    \n        if(m == 0){\n            val m = grid.reduce((a, x) => a + x.size)\n\
    \        }\n        val maxLen = grid.map(_.size).max\n\n        var result: List[Long]\
    \ = Nil\n        if(k == 1) result :+= grid(0)(0)\n        else {\n          \
    \  var found = 0\n            var start = grid(0)(0)\n            var end = grid((grid.length\
    \ - 1)(0)).max\n            while (found == 0) {\n                if (maxLen <\
    \ k - 1) {\n                    found = 1\n                } else {\n        \
    \            var j = 0\n                    var i = 0\n                    var\
    \ j = i\n                    var end = 0\n                    while (j < grid.length)\
    \ {\n                        if(grid((j - 1)(0)).max > end){\n               \
    \             end = grid((j - 1)(0)).max\n                        }\n        \
    \                if(grid((j)(0)).max > end){\n                            end\
    \ = grid((j)(0)).max\n                        }\n                        if(grid((j\
    \ + 1)(0)).max > end){\n                            end = grid((j + 1)(0)).max\n\
    \                        }\n                        if(end == grid((j + 1)(0)).max\
    \ && grid((j + 1)(0)).max > grid((j)(0)).max){\n                            end\
    \ = grid((j + 1)(0)).max\n                        }\n                        if(end\
    \ == grid((j + 1)(0)).max && grid((j + 1)(0)).max > grid((j)(0)).max){\n     \
    \                       end = grid((j + 1)(0)).max\n                        }\n\
    \                        if(end == grid((j + 1)(0)).max){\n                  \
    \          end = 0\n                        }\n                        if(end\
    \ == grid((j + 1)(0)).max && grid((j + 1)(0)).max < grid((j)(0)).max){\n     \
    \                       end = grid((j + 1)(0)).max\n                        }\n\
    \                        if(end == grid((j + 1)(0)).max && grid((j + 1)(0)).max\
    \ < grid((j)(0)).max){\n                            end = grid((j + 1)(0)).max\n\
    \                        }\n                        if(end == grid((j + 1)(0)).max){\n\
    \                            end = 0\n                        }\n            \
    \            if(end == grid((j + 1)(0)).max){\n                            end\
    \ = 0\n                        }\n                        i += 1\n           \
    \             j += 1\n                    }\n                    if(end == grid((j)(0)).max)\
    \ {\n                        found = 1\n                    }\n              \
    \  }\n                if (end == 0) {\n                    if (end == grid((grid.length\
    \ - 1)(0)).max) {\n                        found = 1\n                    }\n\
    \                }\n                start = end\n            }\n            if(k\
    \ == maxLen){\n                result = grid((grid.length - 1)(0)).max\n     \
    \       }\n            else{\n                while(found == 0){", "        var\
    \ list = ListBuffer[Long]()\n        for (row <- grid.indices) {\n           \
    \ for (col <- 0 until grid.size) {\n                if (gridRowCol(row, col) ==\
    \ k) {\n                    val index = gridRowCol(row, col) - 1\n           \
    \         if (index >= 0) {\n                        val valueOnCell = gridList(row,\
    \ col)\n                        if (index == 0 || valueOnCell < list.getOrElse(index\
    \ - 1, 0)) {\n                            list += valueOnCell\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n        list.toList", "        def helper(grid : List[List[Long]], i : Long)\
    \ : List[Long] = {\n            if (i >= grid.length) {\n                List(i)\n\
    \            } else {\n                val li = List(grid((i-1) % grid.length).mkString(\"\
    ,\"),grid((i-1) / grid.length).mkString(\",\"))\n                val ll = helper(grid,\
    \ (i-1) / grid.length)\n                l1 +: ll\n            }\n        }\n\n\
    \        val l1 = helper(grid, 1)\n        l1.toList.sortWith((x, y) => x < y)",
  "        var minPath : List[Long] = Nil\n        var minCell = Nil\n        var\
    \ count : Int = 1\n        val cells = grid.flatten\n        val length = cells.length\n\
    \        var index = length - 1\n        for (i <- 0 until cells.length - k) {\n\
    \            val cellSet = cells.filter(_ != cells(i))\n            val cell =\
    \ cells(i)\n            if (cellSet.size < minCell.length) {\n               \
    \ minCell = cellSet.toList\n                minPath = cellSet.toList\n       \
    \         count = 1\n            } else {\n                if (cellSet.size ==\
    \ minCell.length) {\n                    minCell = cellSet.toList\n          \
    \          minPath = cellSet.toList\n                }\n                val cellSet2\
    \ = cells.filter(_ != cell)\n                val cellSet3 = cells.filter(_ !=\
    \ cell)\n                val cellSet4 = cells.filter(_ != cell)\n            \
    \    val cellSet5 = cells.filter(_ != cell)\n                val cellSet6 = cells.filter(_\
    \ != cell)\n                if (cellSet2.size < cellSet3.size) {\n           \
    \         if (cellSet2.size < cellSet4.size) {\n                        if (cellSet2.size\
    \ < cellSet5.size) {\n                            if (cellSet2.size < cellSet6.size)\
    \ {\n                                minCell = cellSet2.toList\n             \
    \                   minPath = cellSet2.toList\n                              \
    \  count = 2\n                            } else {\n                         \
    \       minCell = cellSet2.toList\n                                minPath = cellSet2.toList\n\
    \                                count = 3\n                            }\n  \
    \                      } else {\n                            minCell = cellSet2.toList\n\
    \                            minPath = cellSet2.toList\n                     \
    \       count = 3\n                        }\n                    } else {\n \
    \                       minCell = cellSet2.toList\n                        minPath\
    \ = cellSet2.toList\n                        count = 3\n                    }\n\
    \                } else {\n                    if (cellSet3.size < cellSet4.size)\
    \ {\n                        if (cellSet3.size < cellSet5.size) {\n          \
    \                  if (cellSet3.size < cellSet6.size) {\n                    \
    \            minCell = cellSet3.toList\n                                minPath\
    \ = cellSet3.toList\n                                count = 3\n             \
    \               } else {\n                                minCell = cellSet3.toList\n\
    \                                minPath = cellSet3.toList\n                 \
    \               count = 3\n                            }\n                   \
    \     } else {\n                            minCell = cellSet3.toList\n      \
    \                      minPath = cellSet3.toList\n                           \
    \ count = 3\n                        }\n                    } else {\n       \
    \                 minCell = cellSet3.toList\n                        minPath =\
    \ cellSet3.toList\n                        count = 3\n                    }\n\
    \                }\n            }\n            index -= 1\n        }\n       \
    \ minPath.reverse.head", "        require(grid.size >= 2)\n        require(grid.head.size\
    \ >= 2)\n        require(k > 0)\n        val gridMap = grid.map { row =>\n   \
    \         var rowMap = mutable.Map[Long, Long]()\n            row.foreach { e\
    \ => rowMap +=+= (e.toLong -> 0L) }\n            rowMap\n        }\n        val\
    \ paths = grid.flatMap { row =>\n            var path = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \            row.foreach { e => path += (e.toLong) }\n            path.reverse\n\
    \        }\n        var current = grid(0)(0)\n        val values = paths.map(path\
    \ => gridMap.get(path) match {\n            case None => 0\n            case Some(x)\
    \ => x\n        }).toList.sortWith(_ < _)\n        var index = 0\n        val\
    \ minList = scala.collection.mutable.ListBuffer.empty[Long]\n        while (current\
    \ != -1) {\n            var minIndex = index\n            var minValue = current\n\
    \            var flag = false\n            while (index < values.size && !flag)\
    \ {\n                val val = values(index)\n                if (val == current)\
    \ {\n                    minIndex += 1\n                    minValue += val\n\
    \                    index = minIndex\n                } else if (index < values.size)\
    \ {\n                    val val = values(index)\n                    if (val\
    \ > minValue) {\n                        minIndex += 1\n                     \
    \   minValue += val\n                    }\n                    index += 1 \n\
    \                } else {\n                    flag = true\n                }\n\
    \            }\n            minList += minValue\n            current = values(minIndex)\n\
    \        }\n        require(minList.size == k)\n        minList.toList", "   \
    \     var minPath: List[Long] = null\n        var cells = grid.toSet\n       \
    \ var cells = grid.toSet\n        val result = new mutable.LinkedHashSet[Long]\n\
    \        val visited = new mutable.Set[Long]\n        var index = 0\n        cells.toList\n\
    \          .sortedWith(_._1 < _._1)\n          .foreach(_._2.foreach(_ => visited.add(_)))\n\
    \        while(index < cells.size) {\n            visited.clear()\n          \
    \  val nextCells = cells.toSet\n            nextCells.toList.foreach(cell => {\n\
    \                val newCells = nextCells.filterNot(cell => (visited.contains(cell))).toList\n\
    \                val newCellIndexes = newCells.toSet\n                val nextCellIndexes\
    \ = cells.filterNot(cell => (visited.contains(cell))).toSet\n                if(visited.size\
    \ == 0) {\n                    index = index + 1\n                }\n        \
    \        val minPath = k\n                val minIndex = nextCellIndexes.min\n\
    \                val minPath2 = minPath\n                val minPath3 = minPath2.map(_\
    \ + minIndex)\n                val minPath4 = minPath3.toSet\n               \
    \ if(minPath4.size == minPath3.size) {\n                    minPath = minPath4\n\
    \                }\n              })\n            if(minPath == null || minPath.size\
    \ == minPath2.size) {\n                break\n            }\n            cells\
    \ = minPath\n            result.add(cells.toList.head._2)\n            visited.add(cells.toList.head._2)\n\
    \        }\n        result", "        var ans : List[Long] = Nil\n        val\
    \ n = grid.size\n        for( i <- 1 to n ) {\n            var lst_A : IndexedSeq[Long]\
    \ = grid.head\n            var lst_B : IndexedSeq[Long] = grid.head\n        \
    \    for(j <- 1 to i) {\n                lst_A += grid.tail.map(x => x._1)\n \
    \               lst_B += grid.tail.map(x => x._2)\n            }\n           \
    \ var isP : Boolean = true\n            while( lst_A.nonEmpty && lst_B.nonEmpty\
    \ && isP ) {\n                var i1 : Int = lst_A.indices.min\n             \
    \   var j1 : Int = lst_B.indices.min\n                var v1 : Long = lst_A(i1)\n\
    \                var v2 : Long = lst_B(j1)\n                if( v1 < v2 ) {\n\
    \                    ans = lst_A.filter( x => x < v2 )\n                    isP\
    \ = false\n                } else if( v1 > v2 ) {\n                    ans = lst_B.filter(\
    \ x => x < v2 )\n                    isP = false\n                } else if( v1\
    \ == v2 ) {\n                    var v3 : Long = lst_A(i1)\n                 \
    \   ans = ans :+ v3\n                    isP = false\n                }\n    \
    \            lst_A.removeAt(i1)\n                lst_B.removeAt(j1)\n        \
    \    }\n            if( !isP ) {\n                ans = ans :+ k\n           \
    \ }\n        }\n        ans", "        var ans = List[Long]()\n        var cnt\
    \ = 0\n        var ans1 = 0\n        for(x <- grid.take(grid.length)){\n     \
    \       for(y <- grid.take(grid.length)){\n                ans1 = (x + ans1).toLong\n\
    \                ans = (x + ans + ans1).toLong\n            }\n        }\n   \
    \     ans.reverse", "        var result = new mutable.LinkedList[Long]()\n   \
    \     var current = grid(0).sorted\n        val current = grid(0).sorted\n   \
    \     val result = new mutable.LinkedList[Long]()\n        val startIndex = 0\n\
    \        val endIndex = (grid zip grid(1).zip(grid(2))).zipWithIndex.filter(_._1\
    \ < k).map(_._2).sum\n        result.add(0, current)\n        for (i <- startIndex\
    \ to endIndex) {\n            var found = 0\n            for (j <- 1 to grid.lastIndex)\
    \ {\n                if (grid(i).sorted < grid(j).sorted) {\n                \
    \    found = 1\n                }\n            }\n            if (!found) {\n\
    \                result.add(current)\n            }\n            current = grid(current._1\
    \ + 1).sorted\n        }\n        result.iterator", "        if (grid.size <=\
    \ 1) \n            return grid\n        var ans : List[Long] = Nil\n        var\
    \ lst_a : List[Long] = Nil\n        var lst_b : List[Long] = Nil\n        grid\
    \ foreach { x =>\n            lst_a ::= x.toList\n            lst_b ::= x.toList\n\
    \        }\n        var i : Long = 1\n        var j : Long = 1\n        while(j\
    \ < k ) {\n            i = i + 1\n            if (lst_a.contains(i))\n       \
    \         lst_a -= i\n            else\n                j += 1\n            if\
    \ (lst_b.contains(j))\n                lst_b -= j\n            else\n        \
    \        i += 1\n            ans ::= i\n        }\n        ans", "        val\
    \ n = grid.size\n        val arr = Array.ofDim[Long](n, n)\n        for(i <- 0\
    \ until n) arr(i) = i.toLong\n        \n        val m = grid.head\n        val\
    \ min = m match {\n            case List(a) =>\n                val l = grid.map(l\
    \ => l.toLong)\n                var i = n\n                for(j <- 0 until k)\
    \ i += 1\n                l\n            case _ =>\n                val l = grid.map(l\
    \ => l.toLong)\n                var i = n\n                for(j <- 0 until k)\
    \ i += 1\n                l\n        }\n        var flag = m match {\n       \
    \     case List(a) =>\n                var i = n\n                for(j <- 0 until\
    \ k) i += 1\n                l\n            case _ =>\n                var i =\
    \ n\n                for(j <- 0 until k) i += 1\n                l\n        }\n\
    \        for(i <- 0 until k) {\n            for(j <- 0 until k) arr(arr(i)) =\
    \ arr(arr(arr(i))).toLong\n            arr(min) = 0l\n            var flag = false\n\
    \            for(i <- 0 until n) if(arr(i) > 0) flag = true\n            if(flag)\
    \ arr(min) += 1l\n            else arr(min) += 1l\n            for(j <- 0 until\
    \ k) arr(arr(arr(i))) -= 1l\n            val temp = arr(min)\n            for(j\
    \ <- 0 until k) arr(arr(arr(i))) -= 1l\n            arr(min) = temp\n        }\n\
    \        arr(arr(k))", "        var result : List[Long] = Nil\n        var result\
    \ : List[Long] = Nil\n        var result : List[Long] = Nil\n        var temp:\
    \ Long = 0\n        var temp2 : List[Long] = Nil\n        var temp3 : List[Long]\
    \ = Nil\n        var temp4 : List[Long] = Nil\n        var temp5 : List[Long]\
    \ = Nil\n        var temp6 : List[Long] = Nil\n        var temp7 : List[Long]\
    \ = Nil\n        var temp8 : List[Long] = Nil\n        var temp9 : List[Long]\
    \ = Nil\n        var temp10 : List[Long] = Nil\n        var temp11 : List[Long]\
    \ = Nil\n        var temp12 : List[Long] = Nil\n        var temp13 : List[Long]\
    \ = Nil\n        var temp14 : List[Long] = Nil\n        var temp15 : List[Long]\
    \ = Nil\n        var temp16 : List[Long] = Nil\n        var temp17 : List[Long]\
    \ = Nil\n        var temp18 : List[Long] = Nil\n        var temp19 : List[Long]\
    \ = Nil\n        var temp20 : List[Long] = Nil\n        var temp21 : List[Long]\
    \ = Nil\n        var temp22 : List[Long] = Nil\n        var temp23 : List[Long]\
    \ = Nil\n        var temp24 : List[Long] = Nil\n        var temp25 : List[Long]\
    \ = Nil\n        var temp26 : List[Long] = Nil\n        var temp27 : List[Long]\
    \ = Nil\n        var temp28 : List[Long] = Nil\n        var temp29 : List[Long]\
    \ = Nil\n        var temp30 : List[Long] = Nil\n        var temp31 : List[Long]\
    \ = Nil\n        var temp32 : List[Long] = Nil\n        var temp33 : List[Long]\
    \ = Nil\n        var temp34 : List[Long] = Nil\n        var temp35 : List[Long]\
    \ = Nil\n        var temp36 : List[Long] = Nil\n        var temp37 : List[Long]\
    \ = Nil\n        var temp38 : List[Long] = Nil\n        var temp39 : List[Long]\
    \ = Nil\n        var temp40 : List[Long] = Nil\n        var temp41 : List[Long]\
    \ = Nil\n        var temp42 : List[Long] = Nil\n        var temp43 : List[Long]\
    \ = Nil\n        var temp44 : List[Long] = Nil\n        var temp45 : List[Long]\
    \ = Nil\n        var temp46 : List[Long] = Nil\n        var temp47 : List[Long]\
    \ = Nil\n        var temp48 : List[Long] = Nil\n        var temp49 : List[Long]\
    \ = Nil\n        var temp50 : List[Long] = ", "        val N = grid.size\n   \
    \     val vals = for (row <- grid; rw <- row) yield rw\n        vals.toList.sortWith((x1:\
    \ Long, x2: Long) => x1 < x2).take(k)", "        val N = grid.size\n        val\
    \ N2 = N * N\n        val A = ArrayBuffer.fill(N2)(_(1))\n        val B = ArrayBuffer.fill(N2)(_(1))\n\
    \        val C: scala.collection.mutable.ListBuffer[Long] = scala.collection.mutable.ListBuffer.empty\n\
    \        var i = -1\n        var j = -1\n        val lst_A = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var lst_B = scala.collection.mutable.ListBuffer.empty[Long]\n       \
    \ while(true) {\n            i += 1\n            val l = i.toLong\n          \
    \  if (l == N * (N - 1))\n                break\n            val cell = grid(i)\n\
    \            for(j += 1; j < (N + 1) * N; j += N) {\n                val val =\
    \ grid(j).toLong\n                if (val <= l) {\n                    val a =\
    \ A(l)\n                    val b = B(l)\n                    if (val <= a + b)\
    \ {\n                        A(l) = val\n                        B(l) = val\n\
    \                        val c = lst_A.toList\n                        val d =\
    \ lst_B.toList\n                        c += val\n                        d +=\
    \ val\n                        lst_A += c\n                        lst_B += d\n\
    \                    }\n                }\n            }\n        }\n        lst_A.sortWith((x,\
    \ y) => x < y)\n        lst_B.sortWith((x, y) => x < y)\n        lst_A.take(k)",
  "        var cells = grid.flatMap(_.reverse).distinct\n        var countMap = mutable.HashMap.empty[Long,\
    \ Long]\n        var cur = cells.head\n        var ans = List[Long]()\n      \
    \  var i = k\n        while (i > 0) {\n            countMap += (i -> (cur.toLong,\
    \ i))\n            i -= 1\n            cur = cells.find(_.toLong < cur.toLong).head\n\
    \        }\n        ans = countMap.map { case (k,v) => (k.toLong, v) }\n     \
    \   ans.sortWith(_._1 < _._1)", "        def isSamePathAAndB(a: List[Long], b:\
    \ List[Long]) : Boolean = {\n            if (a.size != b.size) false\n       \
    \     val startIndex : Int = a.head\n            if (a.size < k) true\n      \
    \      val endIndex : Int = b.head\n            if (a.size > k) false\n      \
    \      val listA = a.drop(startIndex)\n            val listB = b.drop(endIndex)\n\
    \            val listAB = listA.sorted ++ listB.sorted\n            val listABListB\
    \ = listAB.tail\n            (listABListB == listB) || listABListB.isEmpty \n\
    \        }\n\n        def getValueFromNextCell(grid : List[List[Long]], current\
    \ : List[Long], i : Int, j : Int) : List[Long] = {\n            val nextCell =\
    \ grid.take(i).drop(j)\n            val nextCellList = nextCell.sorted\n     \
    \       (nextCellList == current) || (nextCellList == nextCellList.head || isSamePathAAndB(nextCellList,\
    \ current)) && getValueFromNextCell(grid, nextCellList, i + 1, j)\n        }\n\
    \        val grid = grid.sorted\n        val result = new mutable.ArrayBuffer[Long]()\n\
    \        val nextCellList = new mutable.ArrayBuffer[List[Long]]()\n        var\
    \ currentIndex = 0\n        for (i <- 0 to grid.size - 1) {\n            nextCellList.add(i)\n\
    \        }\n        while (nextCellList.nonEmpty) {\n            val current =\
    \ nextCellList.head\n            result.add(current.head)\n            nextCellList.clear()\n\
    \            val nextCells = grid.take(currentIndex).drop(currentIndex + 1).sorted\n\
    \            currentIndex += nextCells.size\n            nextCellList += nextCells\n\
    \        }\n        result.toList", "        // Using HashMap to store current\
    \ cell and its neighbor\n        val map = new scala.collection.mutable.HashMap[Long,\
    \ Long]()\n        val queue = new scala.collection.mutable.Queue[Long]()\n  \
    \      // Fill map with current cell and its neighbor\n        for(i <- 1 to grid.length){\n\
    \            for(j <- 1 to grid[i].length){\n                if(map.getOrElse(grid[i][j],\
    \ 0l) != 0l){\n                    map.update(grid[i][j], 1l)\n              \
    \      queue.enqueue(grid[i][j])\n                }\n            }\n        }\n\
    \        // Initialize result list with current cell\n        val result = List(grid[0](0))\n\
    \        // Loop until queue is empty\n        while(queue.nonEmpty){\n      \
    \      // Remove first element of queue\n            val current = queue.dequeue()\n\
    \            // Initialize result list with current cell\n            val resultList\
    \ = List(current)\n            // Find neighbor cell with minimum value\n    \
    \        val min = math.min(map.get(current), 0)\n            // Remove min from\
    \ map\n            map.remove(min)\n            // Loop for all neighbor cell\
    \ until there is no more neighbor cell\n            for(n <- 1 to (map.size -\
    \ 1).toInt){\n                // Remove min from map\n                map.remove(min)\n\
    \                // Insert current cell into map\n                map.update(current,\
    \ n)\n                // Insert neighbor cell into queue\n                queue.enqueue(current)\n\
    \                // Update result list\n                resultList :+= map(n).toLong\n\
    \            }\n            // Add result list to result list\n            result\
    \ :+= resultList\n        }\n        // Return result\n        result", "    \
    \    var index = 0\n        var current = 0\n        var min = grid[index]\n \
    \       var count = 0\n        var total = 0\n        var lst_A = new collection.mutable.ListBuffer[Long]()\n\
    \        var lst_B = new collection.mutable.ListBuffer[Long]()\n        for (\
    \ row <- grid) {\n            total += row.length\n            lst_A += row.toList\n\
    \        }\n        for ( row <- grid) {\n            lst_B += row.toList\n  \
    \      }\n        while ( current < total && index < grid.length) {\n        \
    \    var i = 0\n            while (i < index && grid[i].getOrElse(-1) == -1){\n\
    \                i += 1\n            }\n            var x = index - i\n      \
    \      var y = 0\n            while (y < index && grid[y].getOrElse(-1) == -1){\n\
    \                y += 1\n            }\n            if (x >= 0 && y >= 0) {\n\
    \                if (lst_A.get(x) < lst_B.get(y)) {\n                    min =\
    \ grid[index]\n                    count += 1\n                } else {\n    \
    \                min = grid[index]\n                    count += 1\n         \
    \       }\n            } else {\n                if (lst_A.get(index) < lst_B.get(index))\
    \ {\n                    min = grid[index]\n                    count += 1\n \
    \               } else {\n                    min = grid[index]\n            \
    \        count += 1\n                }\n            }\n            index += 1\n\
    \            current += 1\n        }\n        count = count-1\n        if (count\
    \ > 0) {\n            var lst_final = new collection.mutable.ListBuffer[Long]()\n\
    \            for (i = 1; i <= k; i++) {\n                lst_final = lst_final\
    \ + lst_A.toList\n            }\n            lst_final = lst_final + lst_B.toList\n\
    \            var temp_a = new collection.mutable.ListBuffer[Long]()\n        \
    \    var temp_b = new collection.mutable.ListBuffer[Long]()\n            for (i\
    \ = 0 ; i < k ; i++) {\n                temp_a = temp_a + lst_final.toList\n \
    \               temp_b = temp_b + lst_final.toList\n            }\n          \
    \  lst_final = temp_a + temp_b\n            val temp_final = lst_final.toList\n\
    \            lst_final.clear()\n            lst_final = temp_final\n        }\n\
    \        lst_final", "        val N = (grid.length * grid).floor\n        val\
    \ numCells = grid.map(_.length).sum\n        val lstCells = grid\n        val\
    \ lstVal = grid.map(_.toList).flatten\n        // We maintain the path lst in\
    \ O(1) because it is always less than or equal to lst\n        val lst = scala.collection.mutable.ListBuffer.empty[List[Long]]\n\
    \        // We maintain the minimum path (minPath in O(log N) in each iteration\n\
    \        val minPath: Long = k\n        for (i1 <- 1 to N) {\n            val\
    \ cells = grid(i1).toList\n            cells.sortWith( (a, b) => a.compareTo(b)\
    \ < 0 )\n            val numInRow = cells.count(x => x == cells(0))\n        \
    \    val indexInRow = cells.indexOf(0)\n            val nextCells = cells.tail\n\
    \            if (numInRow < minPath) {\n                val pathInRow = scala.collection.mutable.ListBuffer.empty[List[Long]]\n\
    \                val indexInRow2 = numInRow\n                nextCells.foreach(x\
    \ => pathInRow += x)\n                cells.foreach(x => if (x == pathInRow(indexInRow2))\
    \ pathInRow(indexInRow2) = x)\n                lstVal += pathInRow\n         \
    \       lst += pathInRow\n            }\n            cells.foreach(x => cells.remove(x))\n\
    \        }\n        val list = lst.sortWith( (a, b) => a.compareTo(b) < 0 )\n\
    \        list.filter(x => x.length == minPath).flatMap(x => x).toList", "    \
    \    require(grid.nonEmpty)\n        require(grid.size == grid.last.size)\n  \
    \      require(grid.head.size == grid.last.head.size)\n        require(k >= 2)\n\
    \        require(k <= grid.last.head.size)\n        require(k <= grid.last.last.size)\n\
    \        require(grid.head.head.size == 1)\n        require(grid.last.last.size\
    \ == 1)\n        require(k <= grid.last.last.head.size)\n        require(k <=\
    \ grid.last.last.last.size)\n        require(grid.last.last.head.head.size ==\
    \ 1)\n        require(grid.last.last.last.last.size == 1)\n        require(k <=\
    \ grid.last.last.last.head.size)\n        require(k <= grid.last.last.last.last.size)\n\
    \        require(grid.last.last.last.last.head.size == 1)\n        require(grid.last.last.last.last.last.size\
    \ == 1)\n        require(k <= grid.last.last.last.last.head.size)\n        require(k\
    \ <= grid.last.last.last.last.last.size)\n        require(grid.last.last.last.last.last.last.size\
    \ == 1)\n        require(k <= grid.last.last.last.last.last.last.size)\n     \
    \   require(grid.last.last.last.last.last.last.last.size == 1)\n        require(k\
    \ <= grid.last.last.last.last.last.last.last.size)\n        require(grid.last.last.last.last.last.last.last.last.size\
    \ == 1)\n        require(k <= grid.last.last.last.last.last.last.last.last.size)\n\
    \        require(grid.last.last.last.last.last.last.last.last.last.size == 1)\n\
    \        require(k <= grid.last.last.last.last.last.last.last.last.last.size)\n\
    \        require(grid.last.last.last.last.last.last.last.last.last.last.size ==\
    \ 1)\n        require(k <= grid.last.last.last.last.last.last.last.last.last.last.size)\n\
    \        require(grid.last.last.last.last.last.last.last.last.last.last.size ==\
    \ 1)\n        require(k <= grid.last.last.last.last.last.", "        val n = grid.head.size\n\
    \        val map = mutable.HashMap.empty[(Long, Long), List[Long]]\n        for\
    \ (i <- 1 to n * n) {\n            if (i % n == 0) {\n                map.clear()\n\
    \            }\n            val a = grid((i / n) - 1, i % n)\n            val\
    \ b = grid(((i + 1) / n), i % n)\n            val c = grid(((i + 1) / n) - 1,\
    \ (i + 1) % n)\n            val d = grid((i / n) - 1, (i + 1) % n)\n         \
    \   val e = grid(((i + 1) / n), (i + 1) % n)\n            val f = grid(((i + 1)\
    \ / n) - 1, (i + 2) % n)\n            val g = grid((i / n) - 1, (i + 2) % n)\n\
    \            val h = grid(((i + 1) / n) - 1, (i + 3) % n)\n            if (a <\
    \ k) {\n                if (b < k) {\n                    if (c < k) {\n     \
    \                   if (d < k) {\n                            if (e < k) {\n \
    \                               if (f < k) {\n                               \
    \     if (g < k) {\n                                        if (h < k) {\n   \
    \                                         map.put(a, List(b, c))\n           \
    \                             }\n                                    } else {\n\
    \                                        if (h < k) {\n                      \
    \                      map.put(a, List(b, c, d))\n                           \
    \             }\n                                    }\n                     \
    \           } else {\n                                    if (g < k) {\n     \
    \                                   map.put(a, List(b, c, d, e))\n           \
    \                         }\n                                }\n             \
    \               } else {\n                                if (f < k) {\n     \
    \                               map.put(a, List(b, c, d, e, f))\n            \
    \                    }\n                            }\n                      \
    \  } else {\n                            if (g < k) {\n                      \
    \          map.put(a, List(b, c, d, e, f, g))\n                            }\n\
    \                        }\n                    } else {\n                   \
    \     if (d < k) {\n                            map.put(a, List(b, c, d, e, f,\
    \ g, h))\n                        }\n                    }\n                }\
    \ else {\n                    if (e < k) {\n                        if (f < k)\
    \ {\n                            map.put(a, List(b, c, d, e, f, g, h))\n     \
    \                   }\n                    } else {\n                        if\
    \ (f < k) {\n                            map.put(a, List(b, c, d, e, f, g))\n\
    \                        }\n                    }\n                }\n       \
    \     } else {\n                if (b < k) {\n                    if (c < k) {\n\
    \                        if (d < k) {\n                            if (e < k)\
    \ {\n                                if (f < k) {\n                          \
    \          if (g < k) {\n                                        if (h < k) {\n\
    \                                            map.put(a, List(b, c, d))\n     \
    \                                   }\n                                    } else\
    \ {\n                                        if (h < k) {\n                  \
    \                          map.put(a, List(b, c, d, e))\n                    \
    \                    }\n                                    }\n              \
    \                  } else {\n                                    if (g < k", " \
    \       val grid = grid.toSet\n        val visited = grid.toSeq.flatten\n    \
    \    val cellCount = grid.length\n        val cellSet = grid.toSeq.flatten.toSet\n\
    \        val minCount = cellSet.size * (cellCount - 1)\n        val minPath =\
    \ ListBuffer.empty[Long]\n        def paths(cells: List[Long], path: List[Long],\
    \ count: Long = 0): List[Long] = {\n            val visited = visited.toSet\n\
    \            val cell = cells.head\n            val newPaths = if (visited.contains(cell))\
    \ List()\n            else path :+ cell\n            val newCount = count + 1\n\
    \            if (newCount > minCount) newPaths\n            else minPath ++ paths(cells.tail,\
    \ newPaths, newCount)\n        }\n        paths(cellSet.toList, List())", "  \
    \      // TODO: return an empty list when k == 0, or when grid is empty.\n   \
    \     if (grid.isEmpty) {\n            List[Long]()\n        }\n        else {\n\
    \            // TODO:\n            // For each cell of the grid, store the list\
    \ of values that can reach its value.\n            // Then, for each value on\
    \ that list, find the minimum path that go through that value first.\n       \
    \     val seen = scala.collection.mutable.HashMap[Long, List[List[Long]]]()\n\
    \            // TODO: for each cell of the grid, store the list of values that\
    \ can reach its value.\n            // Then, for each value on that list, find\
    \ the minimum path that go through that value first.\n            val minPath\
    \ = scala.collection.mutable.ListBuffer.empty[Long]\n            var maxValue\
    \ = grid.head\n            var minValue = grid.head\n            seen += maxValue\n\
    \            minPath += minValue\n            while (seen != null) {\n       \
    \         val keys = seen(maxValue).keys\n                if (keys.length == 0)\
    \ {\n                    // this value doesn't have a path of length k\n     \
    \               minPath += maxValue\n                }\n                else {\n\
    \                    // this value has a path of length k\n                  \
    \  var bestPathSize = sys.maxLong\n                    var bestPathIndex = 0\n\
    \                    for (index <- 0 until keys.length) {\n                  \
    \      val path = seen(keys(index)).keys\n                        if (path.length\
    \ < bestPathSize) {\n                            bestPathSize = path.length\n\
    \                            bestPathIndex = index\n                        }\n\
    \                    }\n                    val path = seen(keys(bestPathIndex)).keys\n\
    \                    if (path.length < bestPathSize) {\n                     \
    \   minPath += keys(bestPathIndex)\n                    }\n                  \
    \  else { // path length is greater than bestPathSize\n                      \
    \  minPath += maxValue\n                        seen -= maxValue\n           \
    \         }\n                }\n                seen -= maxValue\n           \
    \     maxValue = keys.last\n                minValue =  keys.last\n          \
    \  }\n            minPath.toList\n        }", "        val m = grid.size\n   \
    \     val n = grid(0).size\n        val lists = grid.zip(grid(1).zipWithIndex.map(v=>List(v._2,\
    \ v._1))).toMap\n        val max = List[Long](1l, 2l)\n        val path = List[Long](1l)\n\
    \        for (i <- 2 until n ) {\n            val minLength = list.filter(_.length\
    \ == i).min.length\n            for(j <- 2 until i ) {\n                val list\
    \ = lists(lists(j).take(j))\n                val lst = list.sorted.reverse\n \
    \               val result = lst.take(minLength)\n                if (j == i &&\
    \ result.length == minLength) {\n                    result foreach { x => path.insert(x,\
    \ i-1) }\n                } else if (result.size < max && result.size < max(i))\
    \ {\n                    max :+ result.last\n                } else if (result.size\
    \ < max(i)) {\n                    max :+ result.last\n                }\n   \
    \         }\n        }\n        path.sorted.reverse", "        val minPath: List[Long]\
    \ = Nil\n        val visited: mutable.Set[Long] = mutable.Set.empty\n        val\
    \ gridCopy: mutable.Set[Long] = grid.toSet\n        val listOfNeighbor: mutable.Set[Long]\
    \ = mutable.Set.empty\n\n        while (gridCopy.isEmpty) {\n            val rand\
    \ = (1 to (grid.length * grid.length)).toList\n            val randIndex = rand.sample\n\
    \            val randCell = grid(randIndex.toInt)\n            listOfNeighbor.clear()\n\
    \            randCell.foreach{v => listOfNeighbor.add(v)}\n            val neighborCell\
    \ = listOfNeighbor.toList\n            visited.clear()\n            neighborCell.foreach{v\
    \ => visited.add(v)}\n            val neighborIndex = neighborCell.toSet\n   \
    \         val neighborCellValue = neighborIndex.toList\n            gridCopy.clear()\n\
    \            neighborCellValue.foreach{v => gridCopy.add(v)}\n            val\
    \ neighborCellValueCopy = gridCopy.toList\n            neighborCellValueCopy.sortWith((a,\
    \ b) => a < b)\n\n            val listOfValue: mutable.List[Long] = neighborCellValueCopy.take(k).distinct\n\
    \            val listOfValueCopy = listOfValue.toList\n            val nextIndex\
    \ = neighborCellValueCopy.take(k)\n            val nextIndexCopy = nextIndex.toList\n\
    \            val nextIndexCopySorted: ListBuffer[Long] = nextIndexCopy.sortWith((a,\
    \ b) => a < b)\n            val nextIndexCopySortedRemoved = nextIndexCopySorted.drop(nextIndexCopySorted.length).distinct\n\
    \            val nextIndexCopySortedRemovedRemovedDuplicate: ListBuffer[Long]\
    \ = nextIndexCopySortedRemoved.distinct\n\n            val listOfValueCopySortedRemoved\
    \ = listOfValueCopySorted.take(nextIndexCopySortedRemovedRemovedDuplicate.length).distinct\n\
    \            val listOfValueCopySortedRemovedRemovedDuplicate = listOfValueCopySortedRemoved.distinct\n\
    \n            if (listOfValueCopySortedRemovedRemovedDuplicate.length == k) {\n\
    \                if (listOfValueCopySortedRemoved.length < k) {\n            \
    \        minPath = listOfValueCopySortedRemoved\n                } else {\n  \
    \                  minPath = listOfValueCopySortedRemovedRemovedDuplicate\n  \
    \              }\n            }\n\n        }\n        return minPath", "     \
    \   val m = grid.reduceLeft((l, r) => l ++ r)\n        val s = m.zipWithIndex.foldLeft(List[Long]())\
    \ {\n            case (acc: List[Long], (idx, l)) => \n                if (idx\
    \ == k) {\n                    acc :+ l\n                }\n                else\
    \ {\n                    acc :+ l\n                    acc :+ m.filter((_, idx)\
    \ => idx == idx % k).min.head\n                }\n        }\n        s.sortWith(_\
    \ < _)", "        // Using an ordered hash map to record the path\n        val\
    \ paths = scala.collection.mutable.LinkedHashMap[Long, List[Long]]()\n       \
    \ for (i <- 1 to k) {\n            for (j <- 1 to k) {\n                paths\
    \ += ((i,j) -> grid.get(i-1,j-1))\n            }\n        }\n        // Using\
    \ an ordered hash map to record the found values\n        val vals = scala.collection.mutable.LinkedHashMap[Long,\
    \ List[Long]]()\n        val min = scala.math.min(k + 1, grid.length)\n      \
    \  for (i <- 1 to min) {\n            for (j <- 1 to min) {\n                //\
    \ if path not existed and new value is less than old value\n                if\
    \ (!paths.contains(i-1+j-1) && grid.get(i-1+j-1) < grid.get(i-1,j-1)) {\n    \
    \                vals += ((i+1,j+1) -> grid.get(i-1,j-1))\n                }\n\
    \            }\n        }\n        // return a list\n        vals.toList.sortWith(_._1\
    \ < _._1).map(_._2).reverse", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val dp = mutable.ArrayBuilder.make[List[Long]](n + 1)\n        dp.set(0,\
    \ List())\n        for (x <- 1 to n) {\n            dp.update(x, List())\n   \
    \     }\n        val minLength = k\n        for (i<-0 until k) {\n           \
    \ for (j<-0 until n) {\n                if (dp(i).contains(grid((i + 1) % m)(j)))\
    \ {\n                    val newDp = dp(i).updated(j, dp(i).remove(grid((i + 1)\
    \ % m)(j)))\n                    val newLength = i - j + newDp.head\n        \
    \            val minPaths = newLength == minLength && newDp.tail.forall(x => minPath(x)\
    \ < newDp.head)\n                    if (!minPaths) {\n                      \
    \  return newDp.toList\n                    }\n                }\n           \
    \ }\n        }\n        dp.toList", "        var stack = scala.collection.mutable.Stack[List[Long]]()\n\
    \        stack += grid\n        while(stack.nonEmpty) {\n            val cell\
    \ = stack.pop()\n            val values = cell.map { case value => value }.toSet\n\
    \            val newValues = values.filter(_ != k)\n            if(newValues.isEmpty)\
    \ {\n                continue\n            }\n            if(newValues.size <\
    \ 1) {\n                stack += newValues.map(_.toList).toList\n            }\
    \ else {\n                val value = newValues.head\n                val neighborCells\
    \ = values.filter(_ != value)\n                val remainingValues = newValues.filter(_\
    \ == value)\n                val newNeighborCells = neighborCells.filter(_ !=\
    \ k).filter(_ != value)\n                if(newNeighborCells.nonEmpty) {\n   \
    \                 stack += neighborCells.map(_.toList).toList + newNeighborCells.map(_.toList).toList\n\
    \                } else {\n                    val sortedValues = remainingValues.sortBy(identity)\n\
    \                    val sortedNeighborValues = sortedValues.filter(_ != k)\n\
    \                    val sortedNeighborCells = sortedValues.filter(_ == k).filter(_\
    \ != value)\n                    stack += sortedNeighborCells.map(_.toList).toList\
    \ + sortedNeighborValues.map(_.toList).toList\n                }\n           \
    \ }\n        }\n        stack.toList.sortBy(identity).reverse.head", "       \
    \ val numCol = grid.map(_.size).max\n        val numRow = grid.map(_.size).min\n\
    \        val visited = new mutable.HashSet[Long]()\n        val ans = new mutable.ArrayList[Long]()\n\
    \        def dfs(i : Int, j : Int) {\n            if (i < 0 || j < 0 || i >= numRow\
    \ || j >= numCol) return\n            if (!visited(i) && !visited(j)) {\n    \
    \            visited(i) = true\n                visited(j) = true\n          \
    \      ans += grid(i).head\n                dfs(i - 1, j)\n                dfs(i\
    \ + 1, j)\n                dfs(i, j - 1)\n                dfs(i, j + 1)\n    \
    \        }\n        }\n        for (i<- 0 until (numRow-1)) {\n            for\
    \ (j<- 0 until (numCol-1)) {\n                dfs(i, j)\n            }\n     \
    \   }\n        ans -= grid.map { x => x.head }.distinct.toList\n        ans.toList",
  "        val N = grid.size\n        if (N == 0 || N == 1) grid\n        else {\n\
    \            def dfs(x : List[Long], acc : List[Long]) : List[Long] = {\n    \
    \            if (x == N * N) acc\n                else {\n                   \
    \ val nextPath : List[Long] = N * N - x \n                    if (nextPath < k)\
    \ dfs(x ++ grid(x).head, x::acc)\n                    else {\n               \
    \         val newAcc = (acc :+ grid(x).head).sortWith(_ < _)\n               \
    \         val nextPathNew = (nextPath :+ grid(grid(x).head).head).sortWith(_ <\
    \ _)\n                        if (nextPathNew < k) dfs(nextPathNew, newAcc)\n\
    \                        else dfs(x ++ grid(x).head ++ newAcc, acc)\n        \
    \            }\n                }\n            }\n            val start = grid(1).head\n\
    \            val acc = (start :: N * N - 1).sortWith(_ < _)\n            dfs(start,\
    \ acc)\n        }", "        val cells: Seq[(Long, Long)] = grid.map(_.toSeq)\n\
    \        val result = new mutable.LinkedHashMap[Long, List[Long]]()\n        val\
    \ visited = new mutable.LinkedHashSet[(Long, Long)]()\n        val queue = new\
    \ mutable.PriorityQueue[(Long, Long)]()\n        var lastVal = -1L\n        for(i\
    \ <- 1 to k) {\n            val value = cells.filter(_._1 == i).map(_._2).max\n\
    \            if(value == -1L) lastVal = -1L\n            else {\n            \
    \    if(result.contains(value)) {\n                    result += (i -> result.get(value))\n\
    \                    result -= value\n                } else {\n             \
    \       val cellsAfter: Seq[(Long, Long)] = result.filter(_._1 > value).map(_._2)\n\
    \                    val nextVal = cellsAfter.filter(_._2 == lastVal).map(_._1).min\n\
    \                    val path = cells.filter(_._2 == nextVal).map(_._1).distinct\n\
    \                    val cellsBefore: Seq[(Long, Long)] = result.filter(_._1 <\
    \ nextVal).map(_._2)\n                    if(path.length == 0) queue.enqueue((value,\
    \ nextVal))\n                    else for(c <- cellsBefore) {\n              \
    \          if(visited.contains(c)) {\n                            queue.enqueue((value,\
    \ nextVal))\n                            break\n                        }\n  \
    \                      if(path.contains(c._1)) {\n                           \
    \ visited.add(c)\n                            queue.enqueue((value, nextVal))\n\
    \                            break\n                        }\n              \
    \      }\n                }\n            }\n        }\n        result.toList",
  "        val rows = grid.map(_.size)\n        val columns = grid.map(_(0).size)\n\
    \        val totalSum = grid.map(_.sum).sum\n        val visited = mutable.HashSet[Long]()\n\
    \        val ordered = mutable.ListBuffer.empty[Long]\n        def dfs(i: Long,\
    \ j: Long): Unit = {\n            if (i == columns) {\n                if (j ==\
    \ rows) {\n                    ordered.toList\n                } else {\n    \
    \                dfs(i, j + 1)\n                }\n            } else if (j ==\
    \ rows) {\n                dfs(i + 1, j)\n            } else {\n             \
    \   val current = grid[i][j]\n                val candidates = grid\n        \
    \            .filter(_(j) != current)\n                    .filter(_(i) != current)\n\
    \                    .map(_(j))\n                    .filter(_ != current)\n \
    \                   .map(_(i))\n                for (candidate <- candidates)\
    \ {\n                    if (visited.contains(candidate)) {\n                \
    \        continue\n                    } else {\n                        visited.add(candidate)\n\
    \                        if (candidate < k) {\n                            ordered.+=\
    \ current\n                            dfs(i, j)\n                        }\n\
    \                    }\n                }\n            }\n        }\n        for\
    \ (iCol <- 0 until columns) {\n            for (iRow <- 0 until rows) {\n    \
    \            dfs(iRow, iCol)\n            }\n        }", "        if (grid.isEmpty)\
    \ Nil\n        else if (grid.head == Nil) Nil\n        else {\n            val\
    \ grid = grid.tail\n            var bestGrid = grid\n            var bestLength\
    \ = 0L\n            var curK = k\n            val lengths = mutable.LinkedHashSet[Long]()\n\
    \            val paths = mutable.LinkedHashSet[List[Long]]()\n            val\
    \ isVisited = mutable.LinkedHashSet[Boolean]()\n            var i : Long = 0\n\
    \            while(bestLength < curK) {\n                lengths += bestLength\n\
    \                paths += bestGrid\n                isVisited += true\n      \
    \          i += 1\n                bestGrid = grid.drop(i).head\n            \
    \    bestLength += bestGrid.last\n                curK -= bestLength\n       \
    \     }\n            bestLength -= curK\n            lengths.filter {_ < k}.foreach\
    \ {x => bestGrid = bestGrid.drop(x)}\n            paths.filter {_ (x.last) ==\
    \ curK}.foreach {x => bestGrid = bestGrid.drop(x)}\n            bestGrid\n   \
    \     }", "        // sort the cells so that we can use binary search\n      \
    \  val grid = grid.sortWith(_.compareTo(_) < 0)\n        val gridWithPaths : List[List[Long]]\
    \ = grid.map(a => a.map(b.toLong => (b, a))).toList\n        val length = gridWithPaths.map(_.length).sum\n\
    \n        if (length <= k) {\n            // we can stop at length 1 since length\
    \ 2 is the only possible length\n            return gridWithPaths.head.map(_.toLong)\n\
    \        }\n\n        // sort by cell index, so we don't need to go through the\
    \ cells twice\n        val gridWithPathsSorted : MutableList[List[Long]] = gridWithPaths.sortWith(_.compareTo(_)\
    \ < 0).map(_.map(_.toLong))\n        // get the first cell, we start from it\n\
    \        val firstCellIndex = gridWithPathsSorted.takeWhile(a => a < k).length\n\
    \n        // binary search\n        def binarySearch(lst : List[Long], i : Long)\
    \ : Long = {\n            val lo = i\n            val hi = i + lo - 1\n      \
    \      if (hi >= lst.size) {\n                // no possible way to go past k,\
    \ so return the last index\n                hi\n            } else {\n       \
    \         // find the smallest index that's still smaller than lo\n          \
    \      val mid = lst.indexOf(hi)\n                if (mid < lo) {\n          \
    \          // binary search the smaller part first\n                    binarySearch(lst,\
    \ lo)\n                } else {\n                    // binary search the larger\
    \ part\n                    binarySearch(lst, mid + 1)\n                }\n  \
    \          }\n        }\n\n        // get the index of the cell with minimum number\
    \ of cells\n        // to go through, let's call this numOfCells\n        val\
    \ firstCellIndex = binarySearch(gridWithPathsSorted.takeWhile(a => a < k).length,\
    \ firstCellIndex)\n\n        val numOfCells = gridWithPathsSorted.takeWhile(a\
    \ => a < k).length - firstCellIndex + 1\n        // go through this number of\
    \ cells, return the first value we get\n        val path : List[Long] = gridWithPathsSorted.take(firstCellIndex).take(numOfCells).map(_.toLong).sortWith(_.compareTo(_)\
    \ < 0)\n        path", "        val m = grid.length\n        var curr = grid (m)\n\
    \        var next: List[Long] = Nil\n        var flag = 0\n        val lst_A =\
    \ new ArrayBuffer[Long]()\n        val lst_B = new ArrayBuffer[Long]()\n     \
    \   for (i<-0 until m){\n            if(i == m){\n                if(curr.length\
    \ == k){\n                    lst_A += curr(0)\n                    lst_B += curr(1)\n\
    \                }\n            }\n            else{\n                if(curr(i)\
    \ > curr(i+1) && next!= Nil){\n                    flag = 1\n                }\n\
    \                if(curr(i) < curr(i+1) && flag == 0){\n                    lst_A\
    \ += curr(i)\n                    lst_B += curr(i+1)\n                    flag\
    \ = 1\n                }\n            }\n        }\n        //print (lst_A)\n\
    \        //print (lst_B)\n        var i = 1\n        while(i < m ){\n        \
    \    val j = i + 1\n            val temp = lst_A\n            lst_A = lst_B\n\
    \            lst_B = temp\n            i += 1\n        }\n        //print (lst_A)\n\
    \        //print (lst_B)\n        return lst_A.toList", "        // Write your\
    \ code here\n        var cur = grid\n        var next = List[List[Long]]()\n \
    \       var visited = mutable.Set.empty[Long]\n        while(cur.length != 0 ||\
    \ cur != empty) {\n            val start = cur.head\n            if(visited.contains(start.toLong))\
    \ {\n                next += cur.tail\n                visited.remove(start.toLong)\n\
    \            } else {\n                if(cur.length == 0) {\n               \
    \     visited += start\n                    next += start\n                } else\
    \ {\n                    visited += start\n                    val newCur = cur.tail.dropWhile(\
    \ x => start.toLong < x.toLong)\n                    cur = newCur\n          \
    \      }\n            }\n        }\n        next.sortWith( x => x.toLong <=> x.toLong)",
  "        val m = new mutable.HashMap[List[Long], List[Long]]()\n        for(i <-\
    \ 1L to k) {\n            val newm = new mutable.HashMap[List[Long], List[Long]]()\n\
    \            val newgrid = grid.map(_.map(x => if (x == i) x else List(x)))\n\
    \            for(v <- newgrid.flatMap(_.toList)) {\n                val newv =\
    \ new mutable.HashMap[List[Long], List[Long]]()\n                newm.put(v, v)\n\
    \                for(x <- newgrid.flatMap(_.toList)) {\n                    val\
    \ newx = x.map(_ + i).distinct\n                    val newxs = newx.toSeq.map(_\
    \ + i).toList\n                    val newxl = newxs.reduceLeft(_.toLong)\n  \
    \                  val newys = newx.toSeq.filter(_ < newxl).map(_ - i).toList\n\
    \                    val newyl = newys.reduceLeft(_.toLong)\n                \
    \    newv += (x -> newyl)\n                }\n                newm.put(v, newv)\n\
    \            }\n            val newgrid2 = newm.map(_.map(_._1))\n           \
    \ val result = newgrid2.reduceLeft(_.flatMap(_.reverse)).distinct\n          \
    \  m.put(i, result)\n        }\n        m.getOrElse(k, List[Long]())", "     \
    \   // O(n^3)\n        val size = grid.length\n        val res = new Array[Long](size)\n\
    \        for (i <- 1 to size) {\n            val min = i\n            val path\
    \ = List[Long]()\n            for (j <- i to size) {\n                if (grid(j).exists(x\
    \ => x == res(i))) {\n                    val k = grid(j).filterNot(x => x ==\
    \ res(i)).size\n                    if (k > min)\n                        min\
    \ = k\n                    path :+= grid(j)\n                } else\n        \
    \            path :+= grid(j).takeWhile(_ == res(i)).last\n            }\n   \
    \         if (res.contains(res(i)))\n                res(i) = res(i) - 1\n   \
    \         else\n                res(i) = min\n        }\n        res", "     \
    \   def findpath(lst_A : List[Long], lst_B : List[Long], i : Long, j : Long):\
    \ List[Long] = {\n            if (i == k) {\n                val result = lst_A.filter(\
    \ x => lst_A.count( y => x == y) <=  lst_B.count( y => x == y))\n            \
    \    result.sorted.mkString(\", \")\n            } else {\n                if\
    \ (lst_A.head == k) findpath(lst_A, lst_B, i + 1, j + 1)\n                else\
    \ if (lst_B.head == k) findpath(lst_B, lst_A, i + 1, j + 1)\n                else\
    \ if (lst_B(lst_A.indexWhere( x => x == lst_B.head)) > lst_A(lst_A.indexWhere(\
    \ x => x == lst_A.head))) findpath(lst_A, lst_B, i + 1, j + 1)\n             \
    \   else findpath(lst_A, lst_B, i + 1, j + 1)\n            }\n        }\n    \
    \    val list2 = grid.flatMap(_.tail)\n        val list1 = grid.flatMap(_.head)\n\
    \        val lst_B = list2.sortWith(_.compareTo(_))\n        val lst_A = list1.sortWith(_.compareTo(_))\n\
    \        findpath(lst_A, lst_B, 0, 0)", "        val graph = new mutable.HashMap[Long,\
    \ List[List[Long]]]()\n        for (i <- 1 to k) {\n            graph.put(i.toLong,\
    \ grid) // We add all the values on the grid\n        }\n        val result =\
    \ new mutable.LinkedList[Long]()\n        var stack = new mutable.Stack[Long]()\n\
    \        for (i <- 0 until graph.size) {\n            val neighbors = graph(i)\n\
    \            val currentNeighbors = neighbors.toList\n            val value =\
    \ grid(i)\n            // We take the value on the cell and add it to the stack\
    \ (the stack is ordered by value already)\n            stack push(i)\n       \
    \     // We add the neighbors values on the stack (we don't have to keep them\
    \ in memory)\n            while (stack.size > 1) {\n                val index\
    \ = stack.peek()\n                val stackValue = stack.pop()\n             \
    \   val currentNeighborsValue = currentNeighbors.toList\n                if (currentNeighborsValue\
    \ == stackValue) {\n                    // We can add the current value to the\
    \ result because it's already in the stack\n                    result push value\n\
    \                    break\n                }\n                stack.push index\n\
    \                currentNeighbors = currentNeighborsValue + stackValue\n     \
    \       }\n            // We put all the values in the result list so we can add\
    \ them to the result\n            while (currentNeighbors.nonEmpty) {\n      \
    \          result push currentNeighbors.head\n                currentNeighbors\
    \ = currentNeighbors.tail\n            }\n        }\n        result.head", " \
    \       val nRows = grid.head._2.length\n        val nCols = grid.head._1.length\n\
    \        val m = mutable.ArrayBuffer(grid).map(_.toList).toList\n        if (m\
    \ == null || m.length < nRows) {\n            return null\n        }\n       \
    \ // build graph\n        val adj = new Array[nRows * nCols](Array.ofDim[List[List[Long]]](k\
    \ + 1))\n        for (iRow <- 0 until nRows) {\n            for (iCol <- 0 until\
    \ nCols) {\n                adj(iRow * nCols + iCol) = m(m.indexWhere(_(iRow,iCol)\
    \ == 1) match {\n                    case x if x == 1l => x.toList\n         \
    \           case x => List(List(x.toLong))\n                })\n            }\n\
    \        }\n        // search\n        var minPath : List[Long] = Nil\n      \
    \  var i : Long = 1\n        while (i * i < k) {\n            var k1 : Long =\
    \ 0\n            while (k1 < i) {\n                val m1 = adj[k1]\n        \
    \        var j : Long = 1\n                while (j * j < k) {\n             \
    \       if (m1.nonEmpty && m1(0) < m1(j)) {\n                        val m2 =\
    \ adj[k1 + j]\n                        if (m2.nonEmpty && m2(0) < m2(j)) {\n \
    \                           m1 ::= m2\n                            j++\n     \
    \                   } else {\n                            m1 ::= List(m2(j))\n\
    \                            k1 += 1\n                        }\n            \
    \        } else {\n                        m1 ::= List(m2(j))\n              \
    \          k1 += 1\n                    }\n                }\n               \
    \ minPath = minPath.headOption match {\n                    case None => m1.toList\n\
    \                    case Some(m1) => if (m1.size == k) {\n                  \
    \      m1.toList\n                    } else {\n                        val m2\
    \ = adj[k1 + i].headOption\n                        if (m2.forall(_.size == k))\
    \ {\n                            m2.toList\n                        } else {\n\
    \                            m1.toList\n                        }\n          \
    \          }\n                }\n                i += 1\n                k1 =\
    \ k\n            }\n        }\n        minPath", "        val size = grid.size\n\
    \        val grid = grid.toIndexedSeq.sortWith(_._1 < _._1)\n        val map =\
    \ new scala.collection.mutable.HashMap[Long, List[Long]]()\n        var j = 0\n\
    \        var start = 1\n        var end = size - 1\n        var current = 0\n\
    \        while (start < end) {\n            current = grid((start + end) / 2)\n\
    \            if (map.contains(current)) {\n                map.remove(current)\n\
    \                map.put((current + current) / 2, map.get((current + current)\
    \ / 2) + current.toLong)\n            } else {\n                map.put(current,\
    \ current.toLong)\n            }\n            start = end\n            end = start\
    \ - 1\n            j++\n        }\n        map.get(current)", "        val grid\
    \ = new mutable.ArrayBuffer(grid)\n        var ind : Long = 0\n        var lst\
    \ : List[Long] = Nil\n        while (ind < grid.length) {\n            val cell\
    \ = grid(ind)\n            val inds = 0 until cell.length\n            var j :\
    \ Long = 0\n            while (j < inds.length) {\n                val cell =\
    \ grid(ind)\n                if (cell(j) > cell) {\n                    j += k\n\
    \                }\n                inds += j\n                j += 1\n      \
    \      }\n            ind += k\n            if (inds.size == cell.length) {\n\
    \                lst += cell\n            }\n        }\n        lst.sort", " \
    \       var ans = List[Long]()\n        var index = 0\n        var visited = mutable.Set.empty[Long]\n\
    \        val nRow = grid.head.length\n        val nCol = grid.last.length\n  \
    \      def addPath(x:List[Long], visited: mutable.Set[Long], ans:List[Long]) :\
    \ Unit = {\n            ans ++= x\n            visited ++= x\n        }\n    \
    \    def getNeighbor(x:List[Long], i:Int) : List[Long] = {\n            var l\
    \ = [Long]()\n            if(i == 0) l ++= grid\n            else l ++= grid\n\
    \            val len = l.length\n            val index = len - i - 1\n       \
    \     if(index < 0) l\n            else l(index)\n        }\n        def bfs(x:List[Long],\
    \ visited: mutable.Set[Long], ans:List[Long]) : Unit = {\n            if(x ==\
    \ k) addPath(ans, visited, ans)\n            for( i <- 0 until x.length) getNeighbor(x,\
    \ i).foreach(x => if(!visited.contains(x)) bfs(x, visited, ans))\n        }\n\
    \        for( i <- 0 until nCol ) bfs(grid(0), visited, ans)\n        ans", " \
    \       val rowN = grid.size\n        val colN = grid(0).size\n\n        val lst_A\
    \ = grid(1).map {x => x.toLong}.toList\n        val lst_B = grid(0).map {x =>\
    \ x.toLong}.toList\n\n        val hashMap = mutable.HashMap[Long, List[Long]]()\n\
    \        for (i <- 1L until rowN * colN) {\n            val hashKey = lst_A(i).toInt\
    \ * rowN + i.toInt\n            hashMap.update(hashKey, i :: lst_B(i))\n     \
    \   }\n        val result = hashMap.map(x => x._2).sorted\n        \n        val\
    \ maxLength = result.reverse.head\n        if (maxLength > k) result.reverse.tail.head\
    \ else result.reverse.tail.tail.head", "        def minPathHelper(grid : List[List[Long]],\
    \ k : Long) : List[Long] = {\n            val sortedGrid =\n                grid.sortBy(x\
    \ => x.toList)\n            val newGrid = grid.map(x => x.toList)\n          \
    \  val size = sortedGrid.size\n            val minGrid = newGrid.foldLeft((List[List[Long]](),\
    \  newGrid))((a, b) => minPathHelper(a._2, a._1.map(x => x.toList) :+ b._1, b._2))\n\
    \            val list = minGrid\n            val index = (list.indexWhere(_ =>\
    \ a._1 < b._1)).getOrElse(list.size - 1)\n            val index2 = (list.size\
    \ - index - 2)\n            if (index2 == k) list.toList\n            else minPathHelper(list.toList,\
    \ index2)._2\n        }\n        minPathHelper(grid, k)", "        val nrows =\
    \ grid.length\n        val ncols = grid(0).length\n        val result = new mutable.LinkedList[Long]\n\
    \        val visited = new mutable.LinkedList[Long]\n        val index = new mutable.HashMap[Long,\
    \ Int]()\n        for (i <- 1 to nrows * ncols) {\n            visited.add(i)\n\
    \        }\n        val paths = new mutable.HashSet[Long]()\n        for (i =\
    \ 1 until nrows * ncols) {\n            if (visited.contains(i)) {\n         \
    \       val cell = grid(i / ncols, i % ncols)\n                if (!paths.contains(cell))\
    \ {\n                    index += (cell -> i)\n                    paths.add (cell)\n\
    \                    result.toList ::= cell\n                }\n            }\n\
    \        }\n        val lst_A = result.map { x => index (x) }\n        val lst_B\
    \ = visited.toList ::: result.map { x => index (x) }\n        lst_A compare lst_B",
  "        // Create a set of visited cells.\n        val visited = mutable.Set[Long]()\n\
    \n        // Create a stack to store the current path.\n        // The stack contains\
    \ cells (List[Long]) whose length is k as we \n        // are currently at cells\
    \ (List[Long]) whose length is k.\n        // Initially, the stack is empty.\n\
    \        val stack = mutable.Stack[List[Long]]()\n\n        // A helper function\
    \ which adds the value to the visited set.\n        def addCell(value: Long) =\
    \ visited.add(value)\n\n        // The helper function which removes cells from\
    \ the stack when k is reached.\n        def removeCellWhenKReached() = if (stack.size\
    \ == k) stack.pop else ()\n\n        // Iterate through the grid and add the cells\
    \ to the visited set and \n        // add their values to the stack.\n       \
    \ grid.foreach(addCell)\n        stack.push(grid.headOption)\n        while (!stack.empty)\
    \ {\n            // Remove cells from the stack if k is reached.\n           \
    \ removeCellWhenKReached()\n\n            // Extract the next cell from the stack\
    \ and add it to a new list\n            // to add to the current path.\n     \
    \       val cell = stack.pop()\n            val cellList = cell.map(_.toLong).toList\n\
    \            stack += cellList\n\n            // Add cell's value to visited set.\n\
    \            visited.add(cellList.headOption.get)\n        }\n        // Convert\
    \ set[Long] to List[Long].\n        visited.toList", "        val map = new mutable.HashMap[(Int,\
    \ Int), Int]()\n        for (row <- 0 until grid.length) map[(row, 0)] = 0\n \
    \       for (col <- 0 until grid.head.length) map((0, col)] = 0\n        map.clear()\n\
    \        val path = new List[Long]()\n        val queue = new mutable.Queue[(Int,\
    \ Int)]()\n        for (row <- 0 until grid.length) {\n            for (col <-\
    \ 0 until grid.head.length) {\n                if (!map.contains((row, col)))\
    \ {\n                    queue.enqueue((row, col))\n                    val min\
    \ = map.get((row, col))\n                    if (min == -1) min = math.min(row,\
    \ col)\n                    if (grid.map(row => row).map(col => col).map(n =>\
    \ math.min(n, k - min)).sum < k) map.put((row, col), min)\n                }\n\
    \            }\n        }\n        for (row <- 0 until queue.size) {\n       \
    \     val cell = queue.dequeue()\n            val row = cell._1\n            val\
    \ col = cell._2\n            if (map.get((row, col)) >= k) path ++= grid(row).map(col\
    \ => col).map(n => math.min(n, k - map.get((row, col)))).sum\n        }\n    \
    \    val answer = new scala.collection.mutable.ArrayBuffer[Long]()\n        for\
    \ (x <- path) answer.add(x)\n        answer.toList", "        val N = grid.size\n\
    \        val n = new Array[Long](N.toInt)\n        for (i <- 0 until N.toInt)\n\
    \            n(i) = grid(i).size\n        val lst_A = new Array[Long](N.toInt)\n\
    \        val lst_B = new Array[Long](N.toInt)\n        for (i <- 0 until N.toInt)\
    \ {\n            val curr = grid(i).head\n            lst_A(i) = curr\n      \
    \      lst_B(i) = curr\n            val next = grid(i)(1)\n            for (j\
    \ <- 0 until N.toInt) {\n                lst_A(j) = Math.max(lst_A(j), curr+grid(i)(j))\n\
    \                lst_B(j) = Math.max(lst_B(j), curr+grid(i)(j))\n            }\n\
    \        }\n        val ans = new Array[Long](N.toInt)\n        val max = Math.max(k,\
    \ N.toInt)\n        for (i <- 0 until N.toInt) {\n            if (lst_A(i) < lst_B(i))\n\
    \                ans(i) = lst_A(i)\n            else if (lst_A(i) == lst_B(i))\n\
    \                ans(i) = lst_A(i)\n            else {\n                ans(i)\
    \ = lst_B(i)\n                val j = N.toInt-1\n                while (j >= 0\
    \ && lst_A(j) > ans(i) && lst_B(j) > ans(i))\n                    j -= 1\n   \
    \             ans(i) = lst_B(j)\n            }\n        }\n        ans", "   \
    \     var ans = grid.head\n        var visited = mutable.Set[Long]()\n       \
    \ var index = 0\n        val n = grid.length\n        while (k > 0) {\n      \
    \      if (visited.contains(ans(index)))\n                ans -= 1\n         \
    \   visited += ans(index)\n            index += 1\n            k -= 1\n      \
    \  }\n        ans", "        var minPath : List[Long] = List()\n        if (grid\
    \ == null || grid.length == 0 || k == 0) return List();\n        var map: mutable.Map[Long,\
    \ List[Long]] = new mutable.HashMap[Long, List[Long]]()\n        var visited:\
    \ mutable.Set[Long] = new mutable.HashSet[Long]()\n        var result: mutable.Set[Long]\
    \ = new mutable.HashSet[Long]()\n        visited.add(grid(0, 0));\n        result.add(grid(0,\
    \ 0));\n        grid(0, 0) = k\n        while (result.nonEmpty) {\n          \
    \  var next = minPath.head\n            minPath = minPath.tail\n            map.remove(next)\n\
    \            visited.remove(next)\n            result.retain {\n             \
    \   case it: Long if it > next => false\n                case it: Long if it ==\
    \ next => true\n                case _ => false\n            }\n            for\
    \ (i <- 0 until grid.length) {\n                val cells = map.getOrElse(grid(i,\
    \ 0), List())\n                cells.foreach {\n                    case it: Long\
    \ if it > next => {\n                        var newPath = List();\n         \
    \               var newV = List(next)\n                        var cells2 = map.getOrElse(grid(i,\
    \ 0), List())\n                        cells2.foreach {\n                    \
    \        case it: Long if it == next => newV = List(it)\n                    \
    \        case it: Long => newV = it :: newV\n                        }\n     \
    \                   newPath = (cells ++ newV)\n                        cells.retain\
    \ {\n                            case it: Long if it > next => false\n       \
    \                     case it: Long if it == next => true\n                  \
    \          case _ => false\n                        }\n                      \
    \  newPath\n                    }\n                    case it: Long if it ==\
    \ next => List(it)\n                }\n            }\n        }\n        result",
  "        val gridMap = gridToMap(grid)\n        val visited = mutable.Set[Long]()\n\
    \        def dfs(x : Long, y : Long) : Unit = {\n            val visitedList =\
    \ visited.getOrElseUpdate(x * x + y * y, 1)\n            if (visitedList == k)\
    \ {\n                println(x * x + y * y)\n                println(visited)\n\
    \                println(visited.map(_ + 1).toList)\n            }\n         \
    \   if (visitedList == k) {\n                return\n            }\n         \
    \   val list = gridMap.get(x)\n            list.foreach(l => {\n             \
    \   if (l == y)\n                    dfs(x, l)\n            })\n        }\n  \
    \      for(x <- 1 to grid.length)\n            for(y <- 1 to grid.length)\n  \
    \              if (gridMap.get(x) == gridMap.get(y))\n                    dfs(x,\
    \ y)\n        return gridMap.values.toList.sortWith((a, b) => a(0).compareTo(b(0)))",
  "        val N: Int = grid.size\n        val grid0 = grid.sortBy(x => x.indexOf(0))\
    \ //1\n        val grid1 = grid0.map(x => (x.indexOf(0).asInstanceOf[Long], x.toList))\
    \ //2\n        val grid = grid1.sortBy(x => x._1) //3\n        val grid2 = grid.map(x\
    \ => x._2) //4\n        val grid3 = grid2.sortBy(x => x.indexOf(0)) //5\n    \
    \    var grid4 = grid3.map(x => x.map(y => grid4(k - y)).toSet).map(x => x.map(y\
    \ => y.map(z => y.indexOf(0).asInstanceOf[Long]).toList).toSet) //6\n        val\
    \ grid5 = grid4.map(x => x.map(y => grid4(k - y)))\n        var result1 = grid5.map(x\
    \ => x.map(y => y.indexOf(1).toLong).toList)\n        var result2 = result1.flatMap(x\
    \ => x.map(y => y.indexOf(1).toLong))\n        result2", "        val result =\
    \ new ListBuffer[Long]()\n        val graph = new mutable.HashMap[Long, mutable.Set[Long]]()\n\
    \        for (row <- 1 to grid.length) \n            for (col <- 1 to grid(0).length)\n\
    \                if (!graph.getOrElse(row-1, col-1).contains(row-1)) {\n     \
    \               val set = new mutable.HashSet[Long]()\n                    set.add((row-1))\n\
    \                    set.add((col-1))\n                    graph.put(row-1, set)\n\
    \                }\n        val startNode = math.min(1l, grid.length.toLong)\n\
    \        val endNode = math.min(1l, grid(0).length.toLong)\n        val startSet\
    \ = graph.get(startNode)\n        val endSet = graph.get(endNode)\n        startSet.foreach\
    \ {\n        case x =>\n            if (endSet.contains(x))\n                result.add(x)\n\
    \        }\n        result.toList", "        // find number of rows and cols\n\
    \        var numRows = grid.length\n        var numCols = grid.head.length\n \
    \       val numCells = numRows * numCols\n        var path : List[Long] = Nil\n\
    \        var cells : List[Long] = Nil\n        var visited : Map[Long, Long] =\
    \ Map.empty[Long, Long]\n\n        // helper function\n        def nextCell(curr\
    \ : Long, l : List[Long], visited : Map[Long, Long]) = {\n            val l =\
    \ l :+ curr\n            val l2 = l.map(x => x * x)\n            val uniques =\
    \ l2.distinct\n            val next = uniques.indexOf(l(l2.size - 1).toLong)\n\
    \            if (next < 0) {\n                next\n            } else {\n   \
    \             val next = uniques(next)\n                visited(curr) = next\n\
    \                nextCell(next, l, visited)\n            }\n        }\n\n    \
    \    // main algorithm\n        for (i <- 1 until numCells) {\n            if\
    \ (visited(i) == i) {\n                cells = cells :+ i\n            } else\
    \ {\n                val l = cells\n                val curr = i\n           \
    \     val next = nextCell(curr, l, visited)\n                cells = cells ++\
    \ List((curr + next) / 2)\n            }\n        }\n\n        // return results\n\
    \        cells", "        val N = grid.size\n        val MN = N * N\n        var\
    \ cur = grid.toIndexedSeq.filter(_ !=k && _ != 0l).toArray\n        val curSet\
    \ = cur.filter(x => x >= 1l.toLong && x <= MN).toSet\n        var lst_A = new\
    \ Array[Long](k)\n        var lst_B = new Array[Long](k)\n        val lst_set\
    \ = new Array[Long](k+1)\n        var j = k\n        var i = 0\n        var cur_num\
    \ = 1\n        lst_A.foreach(x => {lst_A(i) = cur_num})\n        lst_B.foreach(x\
    \ => {lst_B(i) = cur_num})\n        lst_set(k) = k\n        var cur_min = sys.maxLong\n\
    \        while (lst_set.size > 0) {\n            val cur_index = lst_set(lst_set.size)\n\
    \            i = cur_index\n            while (lst_A(i) != k) {\n            \
    \    i += 1\n            }\n            j = lst_A(i)\n            while (lst_B(j)\
    \ != k) {\n                j += 1\n            }\n            cur_num = (cur(i)\
    \ - cur(j)).toLong\n            cur_min = Math.min(cur_min, cur_num)\n       \
    \     cur_num += 1\n            lst_A(i) = j\n            lst_B(j) = i\n     \
    \       lst_set(j) = i\n            if (cur(i) != k) {\n                lst_set.foreach(x\
    \ => {\n                    if (x > cur_num) {\n                        lst_set(x)\
    \ = lst_set(x-1).toLong\n                    }\n                })\n         \
    \   }\n        }\n        lst_A.reverse\n        lst_B.reverse\n        cur",
  "        def minPathHelper(grid : List[List[Long]], i : Int, result : List[Long],\
    \ k : Long) : List[Long] = {\n            if (i >= k) {\n                result.filter(_\
    \ == grid).reverse\n            } else {\n                if (grid.contains(grids(i)))\
    \ {\n                    minPathHelper(grid.filter(x => x.contains(grids(i))),\
    \ i, result :+ grids(i), k)\n                } else {\n                    minPathHelper(grid.filter(x\
    \ => !x.contains(grids(i))), i, result, k)\n                }\n            }\n\
    \        }\n        val grids = grid.map(x => x.map(y.toLong))\n        val result\
    \ = List(grids(0).map(1l.toLong))\n        val minPathMin = minPathHelper(grid,\
    \ 0, result, k)\n        val minPathMax = minPathHelper(grid, grids(0).size, result,\
    \ k)\n        minPathMin min minPathMax", "        var visited : List[List[Long]]\
    \ = Nil\n        var min_path : List[Long] = Nil\n        var max_path : List[Long]\
    \ = Nil\n        var count : Int = 0\n        var i : Int = 0\n        var j :\
    \ Int = 0\n        var k1 : Long = 0\n        var k2 : Long = 0\n        var new_path\
    \ : List[Long] = Nil\n\n        while(i < grid.length) {\n            j = 0\n\
    \            while(j < grid[i].length) {\n                k1 = grid[i][j]\n  \
    \              count = 1\n                while(count < k) {\n               \
    \     i += 1\n                    count += 1\n                    if(i == grid.length)\
    \ {\n                        i = 0\n                        if(count == k) {\n\
    \                            min_path = path\n                            new_path\
    \ = min_path.reverse\n                            break\n                    \
    \    }\n                        continue\n                    }\n            \
    \        k2 = grid[i][j]\n                    if(k1 > k2) {\n                \
    \        count += 1\n                        if((count - k) == k) {\n        \
    \                    if(visited == Nil) {\n                                visited\
    \ = Nil\n                            }\n                            visited ::=\
    \ Nil\n                            visited ::= List[Long]()\n                \
    \            visited ::= List[Long]()\n                            while(i < grid.length)\
    \ {\n                                visited ::= grid[i]\n                   \
    \             i += 1\n                            }\n                        \
    \    if(k2 == k1) {\n                                min_path = visited\n    \
    \                            new_path = min_path.reverse\n                   \
    \             break\n                            }\n                         \
    \   min_path = visited\n                            new_path = min_path.reverse\n\
    \                            break\n                        }\n              \
    \      } else {\n                        count += 1\n                        if((count\
    \ - k) == k) {\n                            if(visited == Nil) {\n           \
    \                     visited = Nil\n                            }\n         \
    \                   visited ::= Nil\n                            visited ::= List[Long]()\n\
    \                            visited ::= List[Long]()\n                      \
    \      while(i < grid.length) {\n                                visited ::= grid[i]\n\
    \                                i += 1\n                            }\n     \
    \                       if(k2 == k1) {\n                                min_path\
    \ = visited\n                                new_path = min_path.reverse\n   \
    \                             break\n                            }\n         \
    \                   min_path = visited\n                            new_path =\
    \ min_path.reverse\n                            break\n                      \
    \  }\n                    }\n                }\n                j += count\n \
    \           }\n            i += count\n        }\n        return new_path", " \
    \       val values = grid.map(row => row.map(_.toLong))\n        val edges = values.zipWithIndex\n\
    \        val lst = edges\n            .filter { case (row, i) => row.nonEmpty\
    \ && i <= k - 1 }\n            .map { case (row, i) => edge(row, i) }\n      \
    \      .toList\n        lst", "        var current = scala.collection.mutable.PriorityQueue[Long](k)\n\
    \        current.enqueue(0l)\n        var list = scala.collection.mutable.PriorityQueue[Long]()\n\
    \        list.enqueue(0l)\n        val newGrid = grid.filterNot{_.headOption.exists(_\
    \ != 0l)}\n        for (_ <- 1 to k) {\n            val x = current.dequeue()\n\
    \            val y = list.dequeue()\n            list.enqueue(newGrid.apply(x).filterNot(_\
    \ == y).max)\n            current.enqueue(newGrid.apply(y).filterNot(_ == x).min)\n\
    \        }\n        if (current.dequeue() = k)\n            list.toList\n    \
    \    else\n            minPath(newGrid, k).toList", "        var cellsVisited\
    \ : mutable.Set[Long] = mutable.Set()\n        var maxVisited = 0\n        var\
    \ path : List[Long] = List[Long]()\n\n        while (cellsVisited.size < maxVisited\
    \ + k) {\n            // Choose the first cell which hasn't been visited\n   \
    \         var currentCell : Long = grid.head.head\n\n            // Update path\
    \ cells\n            path = path :+ currentCell\n\n            cellsVisited =\
    \ cellsVisited.union(currentCell)\n\n            val newCells = for (cell <- grid.tail)\
    \ yield cell.tail\n\n            // Update path cells\n            path = path\
    \ :+ newCells.head\n\n            val newCellsLast = newCells.tail\n\n       \
    \     // Check if the current cell is part of the path\n            if (path !=\
    \ newCellsLast) {\n                // Reverse the path\n                path =\
    \ path.reverse\n\n                // Add new cells onto the path\n           \
    \     path = path ++ newCellsLast\n            }\n\n            // Add a new cell\
    \ to the path\n            path = path ++ newCellsLast\n\n            // Remove\
    \ the chosen cell from the set of visited cells\n            cellsVisited = cellsVisited.subtractAll(currentCell)\n\
    \            maxVisited = cellsVisited.size\n        }\n\n        // Return the\
    \ path cells\n        path", "        val n = grid.size\n        // The minimum\
    \ path length counts the number of cells on the path that are visited.\n     \
    \   // The length of the path is guaranteed to be unique (every path has a length\
    \ distinct).\n        val lst_A = new Array[Long](n)\n        val lst_B = new\
    \ Array[Long](n)\n        for (i <- 0 until n) {\n            lst_A(i) = grid(i)(0)\n\
    \            lst_B(i) = grid(i)(1)\n        }\n        var cnt = 0\n        //\
    \ We keep two counters: one for number of cells on the path from start to current\
    \ cell,\n        // and another for number of cells on the path from current cell\
    \ to the end.\n        // We update the two counters by stepping through each\
    \ row and column separately.\n        val cntA = 0\n        val cntB = 0\n   \
    \     for (row <- 0 until n) {\n            for (col <- 0 until n) {\n       \
    \         val newA = lst_A(i).compareTo(lst_A(col))\n                val newB\
    \ = lst_B(i).compareTo(lst_B(col))\n                if ((newA < 0 && newB > 0)\
    \ || (newA > 0 && newB < 0)) {\n                    // We move from A to B because\
    \ A is smaller than B or A is bigger than B.\n                    val i = newA\
    \ < 0 ? 0 : newA\n                    val j = newB < 0 ? 0 : newB\n          \
    \          if (cntA + 1 == k)\n                        // If we are at the end\
    \ of a path, we add it to the list.\n                        lst_B(i) = lst_B(i)\
    \ + 1\n                    else if (cntB + 1 == k)\n                        //\
    \ If we are at the end of a path, we add it to the list.\n                   \
    \     lst_A(i) = lst_A(i) + 1\n                    else\n                    \
    \    // If we are in the middle of a path, we add both rows and columns to the\
    \ list.\n                        lst_A(i) = lst_A(i) + 1\n                   \
    \     lst_B(i) = lst_B(i) + 1\n                    // Increase the number of cells\
    \ on the path from A to B.\n                    cntB = cntB + 1\n            \
    \        cntA = cntA + 1\n                }\n            }\n        }\n      \
    \  val ans1 = new Array[Long](k)\n        for (i <- 0 until k)\n            ans1(i)\
    \ = lst_A(i) == 1 ? lst_B(i) : lst_A(i)\n        val ans2 = new Array[Long](k)\n\
    \        for (i <- 0 until k)\n            ans2(i) = lst_B(i) == 1 ? lst_A(i)\
    \ : lst_B(i)\n        if (lst_A(n) == k) {\n            // If A equals k, we return\
    \ A and B.\n            val ans = ans1\n            val ans2t = an", "       \
    \ val len = grid.length\n        if (len < 2)\n            return grid\n     \
    \   if (k > len*len)\n            return new ListBuffer[Long]()\n        val hashMap\
    \ = new mutable.HashMap[Long, List[Long]]()\n        for (i <- 1 to len-1) {\n\
    \            for (j <- 1 to len-1) {\n                val pair = (i, j) \n   \
    \             val key = pair._1 * len + pair._2\n                if (!hashMap.contains(key))\
    \ hashMap.put(key, grid[pair])\n            }\n        }\n        val sorted =\
    \ hashMap.keys.sortWith(_ < _)\n        val res = new mutable.ListBuffer[Long]()\n\
    \        for (i <- sorted.reverse) {\n            val pair = i / len\n       \
    \     val key = pair._1 * len + pair._2\n            if (hashMap(key).forall(x\
    \ => x != grid[pair]))\n                res\n                .append(key)\n  \
    \              .append(hashMap(key).sorted)\n                .append(hashMap(key).reverse.sorted)\n\
    \        }\n        res", "        // First we find the length of each path by\
    \ counting the number of cells that share an edge with us and then sorting them.\n\
    \        val pathsMap : Map[Long, List[Long]] = grid.groupBy(x => x.size).map\
    \ {\n            case (key, values) => {\n                // We group each cell\
    \ by its size and count how many cells share an edge\n                val listOfPaths\
    \ = values.map(x => List(x._1)).toList\n                listOfPaths.sortWith(x\
    \ => x.length < y.length)\n            }\n        }.map(x => x._2.toMap).toMap\n\
    \n        // A path A (of length k) is considered less than a path B (of length\
    \ k) if\n        // after making the ordered lists of the values on the cells\
    \ that A and B go\n        // through (let's call them lst_A and lst_B), lst_A\
    \ is lexicographically less\n        // than lst_B, in other words, there exist\
    \ an integer index i (1 <= i <= k)\n        // such that lst_A[i] < lst_B[i] and\
    \ for any j (1 <= j < i) we have\n        // lst_A[j] = lst_B[j].\n        //\
    \ It is guaranteed that the answer is unique.\n        val orderedPaths = pathsMap.map\
    \ {\n            case (size, lst_B) => lst_B.foldLeft(List[Long]()) (_::_)\n \
    \       }.toList.sort\n\n        // Now we go through our ordered lists and find\
    \ how many cells we have visited.\n        // We then append the value at the\
    \ index i to the result list.\n        val result = orderedPaths.foldLeft(List[Long]())\
    \ (_::_)\n        result ::: orderedPaths.map {\n            case i => grid(i)(k)\n\
    \        }", "        val gr = grid.map(_.toSet)\n        val gc = gr.reduceLeft{(acc,\
    \ a) => acc ++ a}\n        val gs = gc[gr(0).headOption]\n        val ls = gr(0).map(_.size)\n\
    \        ls match {\n            case Nil => List.empty\n            case _ =>\n\
    \                val ls = gr(0).map { a =>\n                    val gs = gc[gr(1).headOption]\n\
    \                    val ls = gr(1).map(_.size)\n                    if(gs eq\
    \ ls) a else a.head - 1\n                }\n                val (_, l) = ls match\
    \ {\n                    case (x: Long, y) => if (x < y) x else y\n          \
    \      }\n                val gr = gr(l(l-1))\n                val gc = gr.reduceLeft{(acc,\
    \ a) => acc ++ a}\n                val gs = gc[gr(0).headOption]\n           \
    \     val gt = gr(0).map(_ + 1).map(_.toSet)\n                val lt = gr(0).map(_\
    \ + 1).map(_.size)\n                if (gs eq lt) List(gt.head) else {\n     \
    \               val (_, l) = lt match {\n                        case (x: Long,\
    \ y) => if (x < y) x else y\n                    }\n                    val (_,\
    \ l) = ls match {\n                        case (x: Long, y) => if (x < y) x else\
    \ y\n                    }\n                    val gr = gr(l(l-1))\n        \
    \            val gc = gr.reduceLeft{(acc, a) => acc ++ a}\n                  \
    \  val gs = gc[gr(0).headOption]\n                    val gt = gr(0).map(_ + 1).map(_.toSet)\n\
    \                    val lt = gr(0).map(_ + 1).map(_.size)\n                 \
    \   if (gs eq lt) List(gt.head) else {\n                        val (_, l) = lt\
    \ match {\n                            case (x: Long, y) => if (x < y) x else\
    \ y\n                        }\n                        val (_, l) = ls match\
    \ {\n                            case (x: Long, y) => if (x < y) x else y\n  \
    \                      }\n                        val gr = gr(l(l-1))\n      \
    \                  val gc = gr.reduceLeft{(acc, a) => acc ++ a}\n            \
    \            val gs = gc[gr(0).headOption]\n                        val gt = gr(0).map(_\
    \ + 1).map(_.toSet)\n                        val lt = gr(0).map(_ + 1).map(_.size)\n\
    \                        if (gs eq lt) List(gt.head) else {\n                \
    \            val (_, l) = lt match {\n                                case (x:\
    \ Long, y", "        val ans = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var start = 0\n        var end = grid.length\n        var gridPos = grid.indexWhere(_\
    \ == 0)\n        while (gridPos != -1) {\n            end = grid.indexWhere(_\
    \ == gridPos)\n            val path1 = grid\n                .take(end)\n    \
    \            .zipWithIndex\n                .filter(_.isDefinedAt)\n         \
    \       .map(f => (f(1), f(_))).toList\n            val path2 = grid\n       \
    \         .take(end)\n                .zipWithIndex\n                .filter(_.isDefinedAt)\n\
    \                .map(f => (f(_), f(1))).toList\n            var newPath = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \            var found = false\n            for (x <- path1.takeWhile(f => f(0).toLong\
    \ < k)) {\n                found = false\n                for (y <- path2.takeWhile(f\
    \ => f(1).toLong < k)) {\n                    if (x == y(1) && !found.toBoolean)\
    \ {\n                        newPath += x._1\n                        found =\
    \ true\n                    }\n                }\n            }\n            ans\
    \ += newPath.takeWhile(_.toLong < k).last\n            start = gridPos\n     \
    \       gridPos = gridPos(1)\n            end = grid.length\n        }\n     \
    \   ans", "        var orderedListOfValues : List[Long] = Nil\n        var numOfCellsVisited\
    \ = grid.size\n        var index = 0\n        var value : Long = 0\n        val\
    \ orderedListOfValuesSize = (grid\n            .map{x => x.size}\n           \
    \ .foldLeft(0l){ (sum, elem) => sum + elem})\n        val listOfCellsVisitedByIndex\
    \ : List[Long] = (0 until numOfCellsVisited).map(i => 0)\n        for(i <- 0 until\
    \ orderedListOfValuesSize) {\n            val valueOnCurrentIndex : Long = grid((index\
    \ % grid.size)\n                .get\n                .map{x => x}\n         \
    \       .toList)\n            val cellsVisitedByIndex : List[Long] = listOfCellsVisitedByIndex\n\
    \            val listOfCellsVisitedByIndex : List[Long] = (0 until numOfCellsVisited).map(i\
    \ => 0)\n            var newIndex = 1\n            while(newIndex < grid.size)\
    \ {\n                val newValue = grid((newIndex % grid.size).get\n        \
    \            .map{x => x}\n                    .toList)\n                if(valueOnCurrentIndex\
    \ < newValue) {\n                    val newIndexOnNextLevel : List[Long] = (0\
    \ until numOfCellsVisited).map(i => 0)\n                    val newIndexInCurrentIndex\
    \ : List[Long] = (0 until numOfCellsVisited).map(i => 0)\n                   \
    \ var newIndexWithNewValue : Long = 1\n                    while((newIndexWithNewValue\
    \ < grid.size) && grid((newIndexWithNewValue % grid.size).get\n              \
    \          .map{x => x}\n                        .toList)\n                  \
    \      .contains(newValue)) {\n                        newIndexWithNewValue +=\
    \ 1\n                    }\n                    for(j <- 0 until newIndexWithNewValue)\
    \ {\n                        if(!(cellsVisitedByIndex.contains(j))){\n       \
    \                     listOfCellsVisitedByIndex((j % grid.size).get += 1)\n  \
    \                      }\n                        if(!(listOfCellsVisitedByIndex.contains(j)))\
    \ {\n                            cellsVisitedByIndex((j % grid.size).get += 1)\n\
    \                        }\n                        newIndexOnNextLevel((j % grid.size).get\
    \ += 1)\n                    }\n                    listOfCellsVisitedByIndex\
    \ = listOfCellsVisitedByIndex\n                        .zip(cellsVisitedByIndex)\n\
    \                        .map(x => x._1._1 + x._1._2)", "        var grid = grid\n\
    \        val len = grid.size\n        var minPath = new mutable.LinkedHashMap[Long,\
    \ Long]()\n        var i = 0\n        while(i<len) {\n            minPath.put(grid(i)(0),\
    \ 0l)\n            i += 1\n        }\n        var k = 0\n        var j = 0\n \
    \       while (j < len) {\n            while (k<len) {\n                val k1\
    \ = grid(j)(0)\n                if (k1 == minPath(k1)+1) {\n                 \
    \   k += 1\n                    continue\n                }\n                val\
    \ k2 = grid(j)(1)\n                if (k2 == minPath(k2)+1) {\n              \
    \      k += 1\n                    continue\n                }\n             \
    \   if (k2 < minPath(k2)) {\n                    minPath(k) = k1\n           \
    \         k = k1 + 1\n                }\n                else {\n            \
    \        minPath(k) = k2\n                    k = k2 + 1\n                }\n\
    \            }\n            j += 1\n        }\n        val result = new Array[Long](minPath.size)\n\
    \        minPath.foreach(x => result(x.toInt) = x)\n        result", "       \
    \ val pathSet = new scala.collection.mutable.HashSet[Long]()\n        val minPath\
    \ = grid.get\n        val gridArray = grid.map{ case x => x.map(_.toLong)}\n \
    \       gridArray.foreach { x =>\n            val setOfPaths = pathSet + x\n \
    \           val listOfPaths = setOfPaths.toList.sorted\n            if (listOfPaths.length\
    \ == k) {\n                pathSet += x\n            } else if (listOfPaths.length\
    \ > k) {\n                val listOfPathsToAdd = (listOfPaths.take(k)).sorted\n\
    \                val setOfPathsToAdd = pathSet + listOfPathsToAdd\n          \
    \      val listOfPathsRemaining = (listOfPathsToAdd - pathSet).toList\n      \
    \          if (listOfPathsRemaining.isEmpty) {\n                    pathSet +=\
    \ listOfPathsToAdd\n                } else {\n                    pathSet += listOfPathsRemaining.map(x\
    \ => x)\n                }\n            }\n        }\n        pathSet.toList",
  "        val N = grid.size\n        val visited = mutable.Set[Long]()\n        val\
    \ result = mutable.ListBuffer[Long]()\n        val visitedList = mutable.ListBuffer[List[Long]]()\n\
    \        val cells = grid.map(_.toList)\n\n        def dfs(i : Long, temp : List[Long],\
    \ acc : List[Long]) : Unit = {\n            visited += i\n            val index\
    \ = cells(i).indexOf(i)\n            cells(i).remove(index)\n            visitedList\
    \ += acc\n            acc.reverse.sorted.foreach(temp :+ _)\n            acc\n\
    \            val next = if (visited.size == N) {\n                acc\n      \
    \      } else {\n                for (j <- 0 until N) {\n                    if\
    \ (cells(j).indexOf(i) == -1) {\n                        continue\n          \
    \          }\n                    if (j != i) {\n                        val tempList\
    \ = visitedList.takeRight(visitedList.size - 1)\n                        if (tempList.exists(x\
    \ => cells(j).indexOf(x) < cells(j).indexOf(i))) dfs(j, cells(j).filterNot(visited.contains(_)),\
    \ acc :+ i)\n                    }\n                }\n                acc\n \
    \           }\n            result.addAll(next)\n            visitedList += next\n\
    \        }\n\n        visitedList.foreach { x =>\n            val temp = x.toList\n\
    \            dfs(0, temp, List()).toList\n        }\n        result", "      \
    \  val visited = mutable.HashSet[Long]()\n        val result = new scala.collection.mutable.ArrayBuffer[Long]()\n\
    \        val maxDepth = grid.get.length\n        val maxPath = new scala.collection.mutable.ArrayBuffer[Long]()\n\
    \n        def visitCell(x :Long) {\n            visited += x\n            if(maxDepth\
    \ == 0)\n                result.append(x)\n            else if(visited.contains(x))\n\
    \                return\n            else if(maxPath.get.length < k)\n       \
    \         maxPath += x\n            else if(visited.contains(x))\n           \
    \     return\n            else\n                visitCells(grid map { x =>\n \
    \                   x match {\n                        case List(a) => a\n   \
    \                     case _ =>\n                            val idx = visited.indexOf(x)\n\
    \                            if(idx > -1 && idx < k) {\n                     \
    \           val b = visited(idx + 1)\n                                val c =\
    \ visited(idx + 2)\n                                if(a < b)\n              \
    \                      a :: b\n                                else if(a > b)\n\
    \                                    a :: c\n                                else\
    \ // a == b\n                                    c :: b\n                    \
    \        }\n                            else\n                               \
    \ x\n                    }\n                })\n        }\n\n        visitCells(grid)\n\
    \        result toList", "        // Create mutable map to save all visited cells\n\
    \        val visited = mutable.HashMap.empty[(Int, Int), List[List[Long]]]\n \
    \       // create mutable map to save minimum path\n        val min = mutable.LinkedHashMap.empty[(Int,\
    \ Int), List[List[Long]]]\n        // get all coordinates and save to list\n \
    \       val coordinates = grid.flatMap(x => x).distinct\n\n        // Find shortest\
    \ path\n        val shortest_path = coordinates.foldLeft(List[Long]())((path:\
    \ List[Long], coordinate: Long) => {\n            // Add coordinate to path\n\
    \            path :+ coordinate\n            // Check if coordinate is visited\n\
    \            val pathForCoordinate = visited.getOrElse(coordinate :: Nil, Nil)\n\
    \            // If coordinate is not visited, add its value to pathForCoordinate\n\
    \            if(pathForCoordinate == Nil) {\n                pathForCoordinate\
    \ :+ coordinate\n            }\n            // If coordinate is already visited,\
    \ remove it from visited\n            else {\n                val updatedVisited\
    \ = visited.filter{ case (visitedCoordinate, _) =>\n                    pathForCoordinate.contains(visitedCoordinate)\n\
    \                }.map{ case (visitedCoordinate, _) =>\n                    (visitedCoordinate,\
    \ pathForCoordinate.filter(x => x == visitedCoordinate).head)\n              \
    \  }\n                updatedVisited :+ pathForCoordinate.filter(x => x == coordinate).head\n\
    \            }\n        })\n        // If path is not empty\n        if(!shortest_path.isEmpty)\
    \ {\n            // Add coordinates of first coordinate to path\n            shortest_path\
    \ :+ coordinates.head\n        }\n        // Return path\n        shortest_path.reverse",
  "        // Write your code here\n        \n        // Step 1: Sort the grid based\
    \ on value\n        var sortedGrid = grid.sorted\n        \n        // Step 2:\
    \ Iterate through sorted grid and find out what cells we need to visit next\n\
    \        var visitedCells = mutable.Set.empty[Long]\n        var visitedGridIndex\
    \ = 0\n        var visitedCellIndex = 0\n        \n        var sortedGridSize\
    \ = sortedGrid.size\n        \n        while(visitedGridIndex < sortedGridSize)\
    \ {\n            \n            // Step 3: Add all the cells from our current grid\
    \ to visited cells\n            val cells = grid(visitedGridIndex) \n        \
    \    val cellsSize = cells.size\n            val newVisitedCells = cells.iterator.toBuffer[Long]\n\
    \            visitedCells ++= newVisitedCells\n            \n            // Step\
    \ 4: Increment our visited grid index\n            visitedGridIndex += 1\n   \
    \         \n            // Step 5: Reset visited cell index\n            visitedCellIndex\
    \ = 0\n            \n            // Step 6: Go through all our neighbors and add\
    \ them to visited cells\n            while(visitedCellIndex < cellsSize) {\n \
    \               val cell = cells(visitedCellIndex)\n                val cellSize\
    \ = cell.size\n                val neighbors = grid(visitedGridIndex).filter(_\
    \ != cell)\n                val newCells = neighbors.iterator.toBuffer[Long]\n\
    \                visitedCells ++= newCells\n                visitedCellIndex +=\
    \ 1\n            }\n        }\n        \n        // Step 7: Return our visited\
    \ cells\n        visitedCells.toList", "        val m = grid.length\n        if\
    \ (m > 1){\n            var k = 0\n            var x = 0\n            var y =\
    \ 0\n            var gridx = grid.map(x => x.toList)\n            var gridy =\
    \ grid.map(y => y.toList)\n            var gridxl = gridx.map(x => x.toList)\n\
    \            var gridyl = gridy.map(y => y.toList)\n            var gridxu = gridx.map(x\
    \ => x.toList)\n            var gridyu = gridy.map(y => y.toList)\n          \
    \  var k = 0\n            var newgrid = gridx.map(x => x.toList)\n           \
    \ var gridx = newgrid\n            var gridy = newgrid\n            val startgrid\
    \ = gridx.map(x => x.toList)\n            var startgrid = gridx\n            var\
    \ currentgrid = gridy\n            var currentgrid = gridy\n            var startgridu\
    \ = startgrid.map(x => x.toList)\n            var startgridu = startgrid\n   \
    \         var currentgridu = currentgrid\n            var currentgridu = currentgrid\n\
    \            var k = 0\n            var gridx = gridx\n            var gridy =\
    \ gridy\n            var gridxl = gridxl\n            var gridyl = gridyl\n  \
    \          var gridxu = gridxu\n            var gridyu = gridyu\n            while\
    \ (k != k) {\n                if (gridxl == null) {\n                    k = 0\n\
    \                } else if (k > 0) {\n                    val currentgrid = gridxl.map(x\
    \ => x.toList)\n                    var currentgridu = currentgrid\n         \
    \           var k = 0\n                    var x = 1\n                    var\
    \ y = 1\n                    while (x != m) {\n                        x = 0\n\
    \                        y = 1\n                        while (y != m) {\n   \
    \                         if (gridxu(x, y) == null) {\n                      \
    \          k = 0\n                            } else if (k > 0) {\n          \
    \                      val currentgrid = gridxu.map(x => x.toList)\n         \
    \                       var currentgridu = currentgrid\n                     \
    \           var k = 0\n                                var x = 1\n           \
    \                     var y = 1\n                            } else {\n      \
    \                          if (gridyu(x, y) == null) {\n                     \
    \               k = 0\n                                } else if (k > 0) {\n \
    \                                   val currentgrid = gridyu.map(x => x.toList)\n\
    \                                    var currentgridu = currentgrid\n        \
    \                            var k = 0\n                                    var\
    \ x = 1\n                                    var y = 1\n                     \
    \           } else {\n                                    val currentgrid = gridx.map(x\
    \ => x.toList)\n                                    var currentgridu = currentgrid\n\
    \                                    var k = 0\n                             \
    \       var x = 1\n                                    var y = 1\n           \
    \                     }\n                            }\n                     \
    \       y = y + 1\n                        }\n                        x = x +\
    \ 1\n                    }\n                } else {\n                    val\
    \ currentgrid = gridx.map(x => x.toList)\n                    var current", " \
    \       val size = grid.size\n        val m = Map(0 -> grid(0)).toList\n     \
    \   for (i <- 1 to size-1) {\n            val row = grid(i).toList\n         \
    \   var min = -1\n            var index = 0\n            while (row.length >=\
    \ k) {\n                val value = row(index) + 1\n                if (min >\
    \ value) min = value\n                if (index < row.length) index += row.length\n\
    \            }\n            val next = row.toList\n            next.remove(min)\n\
    \            if (min == -1) next = next:+ 0\n            if (next.length == 0)\
    \ next:+ 0\n            val lst = m + (i -> next)\n            val keys = lst.map(_._1).distinct\n\
    \            val value = lst.filter(_._1 == keys(keys.length-1))._2(0)\n     \
    \       val lst2 = lst.reduceLeft(_ + _)\n            var j = 0\n            val\
    \ jlst : List[(Int, List[Long])] = lst.filter(_._1 < value).sortBy(_._1).reverse\n\
    \            while (j < keys.length) {\n                val key1 = keys(j)\n \
    \               if (lst2 == lst2) lst2 = lst2:+ 0l\n                if (lst2 <\
    \ lst) {\n                    lst =  lst.filter(_._1 < value).filter(_._1 != key1).sortBy(_._1).reverse\n\
    \                    jlst = lst.filter(_._1 < value).sortBy(_._1).reverse\n  \
    \              }\n                j+=1\n            }\n            m(value) =\
    \ lst\n        }\n        m.values.toList", "        var curr = grid map (x =>\
    \ x.head) filter { x => x.isDefined }\n        curr foreach (x => x match { case\
    \ x if k == 0 => (x :: Nil) })\n        if (k > 0) {\n            var ans = Nil\n\
    \            var cur = grid map (x => x.head) filter { x => x.isDefined }\n  \
    \          var nexts = Nil\n            var curs = Nil\n            var nexts2\
    \ = Nil\n            while (cur exists (x => x == Nil)) {\n                ans\
    \ = ans ::: cur\n                cur = grid map (x => x.head) filter { x => x.isDefined\
    \ }\n                nexts = nexts ::: curs\n                curs = nexts\n  \
    \              nexts2 = grid map (x => x.head) filter { x => x.isDefined }\n \
    \           }\n            ans = ans ::: nexts2\n        }\n        return ans.toList",
  "        val N = len(grid)\n        val visited = new Array[Boolean](N * N)\n  \
    \      val curr = scala.collection.mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 1 to N) {\n            for (col <- 1 to N) {\n                if (row\
    \ == col) {\n                    curr += grid(row - 1, col - 1)\n            \
    \        val isVisited = visited(row - 1, col - 1)\n                    if (isVisited)\
    \ continue\n                    visited(row - 1, col - 1) = true\n           \
    \         val lst = curr.toList\n                    if (!(lst.sorted contains\
    \ lst(0))) lst = lst.sorted ::: List(lst(0))\n                    val i = lst.indexWhere(lst\
    \ == lst(0))\n                    if (i == 0) continue\n                    val\
    \ lstB = curr.toList.drop(i)\n                    if (!(lstB.sorted contains lstB(0)))\
    \ lstB = lstB.sorted ::: List(lstB(0))\n                    val j = lstB.indexWhere(lstB\
    \ == lstB(0))\n                    if (j == 0) continue\n                    if\
    \ (lst.sorted < lstB.sorted) lst\n                    else lstB\n            \
    \    } else visited(row - 1, col - 1) = false\n            }\n        }", "  \
    \      if(grid.isEmpty)\n            return List()\n        if(k <= 0)\n     \
    \       return grid\n        val ret = new scala.collection.mutable.ArrayList[Long]()\n\
    \        val grid = grid\n        val start = new scala.collection.mutable.ArrayList[Long]()\n\
    \        val end = new scala.collection.mutable.ArrayList[Long]()\n        val\
    \ queue = new scala.collection.mutable.PriorityQueue[Long](10){\n            def\
    \ compare(x: Long, y: Long) : Int = {\n                x compare y\n         \
    \   }\n        }\n        for(row <- grid.headOption){\n            for(col <-\
    \ grid.tailOption){\n                if(row.isDefined && col.isDefined){\n   \
    \                 queue.add(new Long(row.get.asInstanceOf[Long]*10+col.get.asInstanceOf[Long]+1))\n\
    \                }\n            }\n        }\n        while(queue.size > 0){\n\
    \            val maxQueue = queue.dequeue()\n            val maxItem = maxQueue.asInstanceOf[Long]\n\
    \            val item1 = maxQueue.asInstanceOf[Long]\n            if(maxQueue.size\
    \ > 1){\n                val maxQueue2 = queue.dequeue()\n                val\
    \ maxItem2 = maxQueue2.asInstanceOf[Long]\n                if(item1.compareTo(maxItem2)\
    \ >= 0){\n                    queue.add(new Long(maxItem+1))\n               \
    \     queue.add(new Long(maxItem2+1))\n                }\n            }else{\n\
    \                queue.add(new Long(maxItem+1))\n            }\n        }\n  \
    \      while(queue.size >= k){\n            val maxQueue = queue.dequeue()\n \
    \           val maxItem = maxQueue.asInstanceOf[Long]\n            val item1 =\
    \ maxQueue.asInstanceOf[Long]\n            if(maxQueue.size > 1){\n          \
    \      val maxQueue2 = queue.dequeue()\n                val maxItem2 = maxQueue2.asInstanceOf[Long]\n\
    \                if(item1.compareTo(maxItem2) >= 0){\n                    queue.add(new\
    \ Long(maxItem+1))\n                    queue.add(new Long(maxItem2+1))\n    \
    \            }\n            }\n            val ret = ret::maxItem\n        }\n\
    \        ret", '        // TODO: Implement me', "        val N = grid.size\n \
    \       var ans = List[Long]()\n        val visited = mutable.Set[Long]()\n  \
    \      val map = mutable.Map[Long, List[Long]]()\n\n        for (_ <- 1 to N)\
    \ {\n            map.clear()\n            var temp : List[Long] = grid\n     \
    \       for (_ <- 1 to k) {\n                val v = temp.toList\n           \
    \     temp.remove(v)\n                if (visited.contains(v(0))) ans = ans :+\
    \ v(0)\n                visited += v(0)\n                temp += map (_.tail)\n\
    \                map += (v(0) -> v)\n            }\n            visited.clear()\n\
    \        }\n        ans", "        val res = new mutable.LinkedList[Long]()\n\
    \        def find(grid : List[List[Long]], index : Long, l : List[Long]) : Unit\
    \ = {\n            if (index == l.length) {\n                res.addAll(l.reverse)\n\
    \            } else {\n                if (grid[index].getOrElse(0l) <= k) {\n\
    \                    find(grid, index + 1, l)\n                } else {\n    \
    \                find(grid, index + 1, l.init :+ grid[index].getOrElse(0l))\n\
    \                }\n            }\n        }\n        find(grid, 0, new mutable.ArrayList[Long]())\n\
    \        res.toList", "        if(grid.length < 2)\n            return grid\n\
    \        var result : List[Long] = Nil\n        var lst_A : List[Long] = Nil\n\
    \        var lst_B : List[Long] = Nil\n        var index = 0\n        while(index\
    \ <= k){\n            var newCells = grid.get(x:_*,y)\n            //print(newCells)\n\
    \            lst_A ++= newCells._1.map(x=>x).flatten\n            lst_B ++= newCells._2.map(x=>x).flatten\n\
    \            index += 1\n        }\n        //println(lst_A)\n        //println(lst_B)\n\
    \        val lst_AB = lst_A.zip(lst_B).map(x=>x._1 < x._2)\n        val lst_CB\
    \ = lst_A.zip(lst_B).map(x=>x._2 < x._1)\n        lst_AB.foreach(x=>result+= x._1)\n\
    \        lst_CB.foreach(x=>result+= x._2)\n        result", "        val numRows\
    \ = grid.size\n        val numCols = grid(0).size\n        val gridColToValue:\
    \ mutable.Map[Long, Long] = mutable.Map()\n        for (row <- 0 until numRows)\
    \ {\n            for (col <- 0 until numCols) {\n                val value = grid(row)(col)\n\
    \                val col2 = col + 1\n                val row2 = row + 1\n    \
    \            val col3 = col + 2\n                val row3 = row + 2\n        \
    \        gridColToValue += ((row, col) -> value)\n                gridColToValue\
    \ += ((row, col2) -> value)\n                gridColToValue += ((row, col3) ->\
    \ value)\n                gridColToValue += ((row2, col) -> value)\n         \
    \       gridColToValue += ((row2, col2) -> value)\n                gridColToValue\
    \ += ((row2, col3) -> value)\n                gridColToValue += ((row3, col) ->\
    \ value)\n                gridColToValue += ((row3, col2) -> value)\n        \
    \        gridColToValue += ((row3, col3) -> value)\n            }\n        }\n\
    \        val sortedCols = gridColToValue.toList.sortBy(_._2)\n        val colSums\
    \ = sortedCols.map(_._2).sum\n        val colToValueMap = sortedCols.toMap\n \
    \       val minPath = sortedCols.flatMap { case (row, col) =>\n            val\
    \ value1 = colToValueMap.get((col + 1) + (row + 1))\n            val value2 =\
    \ colToValueMap.get((col + 2) + (row + 1))\n            val value3 = colToValueMap.get((col\
    \ + 3) + (row + 1))\n            if (value1 == value2) {\n                if (value2\
    \ == value3) {\n                    Seq((row, col))\n                } else {\n\
    \                    val v1 = value1\n                    val v3 = value3\n  \
    \                  val v2 = value2\n                    val nextCol = col + 3\n\
    \                    if (v2 < v1) {\n                        Seq((row, col))\n\
    \                    } else if (v1 < v3) {\n                        Seq((row,\
    \ nextCol))\n                    } else {\n                        Seq((row, col))\n\
    \                    }\n                }\n            } else if (value1 == value3)\
    \ {\n                Seq((row, col))\n            } else {\n                val\
    \ v1 = value1\n                val v2 = value2\n                val v3 = value3\n\
    \                if (v2 < v1) {\n                    Seq((row, col))\n       \
    \         } else if (v1 < v2) {\n                    Seq((row, col))\n       \
    \         } else if (v2 < v3) {\n                    Seq((row, col))\n       \
    \         } else {\n                    val nextCol = col + ", "        var result:\
    \ List[Long] = List[Long]()\n        var current: Map[Long, Long] = Map()\n  \
    \      for (i <- 1 to grid.length) {\n            current = map.getOrElse(i, -1l)\n\
    \            if (current < 0 || current == k) {\n                for (j <- i to\
    \ grid.length if j != i) {\n                    if (j - 1 == i)\n            \
    \            result = result :+ grid.apply(i).apply(j)\n                    else\n\
    \                        result = result :+ grid.apply(i).apply(j)\n         \
    \       }\n            }\n            else\n                map.put(i,k)\n   \
    \     }\n        result", "        if (grid.isEmpty) {\n            return List.empty\n\
    \        }\n        val paths = mutable.HashMap[(Long, List[Long]), List[Long]]()\n\
    \        val path = new scala.collection.mutable.ListBuffer[Long]()\n        val\
    \ visited = mutable.HashSet[Long]()\n        visited.add(grid(0).head)\n     \
    \   for (x <- (1 to grid.size)) {\n            val cells = grid(x).filterNot(visited.contains)\n\
    \            val lists = cells.map(x => List(x.head, x.tail))\n            val\
    \ sorted = lists.sortWith((a, b) => a.head < b.head)\n            val path2 =\
    \ sorted.takeWhile(x => path.size < k).sortWith((a, b) => a.head > b.head).take(k).map(x\
    \ => path.append(x.head)).sorted\n            paths.put((cells(0).head, path2))\n\
    \            path.clear()\n            path.append(cells(0).head)\n        }\n\
    \        paths.values.toList.sortWith((a, b) => a.head < b.head).map(x => x.toList).flatten",
  "        def dfs(grid : List[List[Long]], pos : List[Long], i : Long) : List[Long]\
    \ = {\n            // Base case\n            if (i == k) {\n                if\
    \ (pos.size == 0)\n                    return pos\n                else\n    \
    \                return List(pos.head)\n            }\n            // Recursive\
    \ case\n            val neighbors = grid\n                .map(_.get(pos))\n \
    \               .filter(_.nonEmpty)\n                .map(_.toLong)\n        \
    \    if (neighbors.nonEmpty) {\n                // We are on the first cell\n\
    \                val first = neighbors.head\n                // We need to find\
    \ the next cell on the list\n                val nextPos = (\n               \
    \     neighbors.filterNot(_ == first)\n                        .maxBy { x => x.toLong\
    \ } // Find max position\n                )\n                if (nextPos.size\
    \ < k)\n                    dfs(grid, nextPos, i + 1)\n                else {\n\
    \                    val first = neighbors.head\n                    val second\
    \ = neighbors.last\n                    val lst = neighbors.sortBy(_.toLong).reverse\n\
    \                    // Check if this path is lexicographically less than the\
    \ other one\n                    if (lst(first) < lst(second)) {\n           \
    \             // If yes, add the neighbors to the list\n                     \
    \   val newPos = nextPos.take(k - nextPos.size)\n                        val newPos2:\
    \ mutable.Buffer[Long] = mutable.Buffer[Long]()\n                        newPos2\
    \ += first\n                        newPos2 += nextPos.take(k - 1).last\n    \
    \                    val newPos3: mutable.Buffer[Long] = mutable.Buffer[Long]()\n\
    \                        newPos3 += nextPos.last\n                        newPos3\
    \ += first\n                        if (newPos.size == nextPos.size) {\n     \
    \                       newPos.foreach(pos => newPos2.+=(pos))\n             \
    \               newPos2.toList\n                        }\n                  \
    \  }\n                    else {\n                        val newPos = nextPos.take(k\
    \ - nextPos.size)\n                        val newPos2: mutable.Buffer[Long] =\
    \ mutable.Buffer[Long]()\n                        newPos2 += first\n         \
    \               newPos2 += nextPos.last\n                        val newPos3:\
    \ mutable.Buffer[Long] = mutable.Buffer[Long]()\n                        newPos3\
    \ += nextPos.last\n                        newPos3 += first\n                \
    \        if (newPos.size == nextPos.size) {\n                            newPos.foreach(pos\
    \ => newPos2.+=(pos))\n                            newPos2.toList\n          \
    \              }\n                    }\n                }\n            }\n  \
    \          else {\n                // This cell doesn't have any neighbors\n \
    \               dfs(grid, pos, i + 1)\n            }\n        }\n        dfs(grid, ",
  "        if (grid.isEmpty) return Nil\n        val map = mutable.HashMap[Long, List[Long]]()\n\
    \        var list: List[Long] = Nil\n        for (row<-1 to grid.length - 1) {\n\
    \            val row = grid.drop(row).foldLeft(Nil: List[Long]) { case (acc, col:\
    \ List[Long]) =>\n                col match {\n                    case Nil =>\
    \ acc\n                    case head :: tail => head :: acc ++ tail\n        \
    \        }\n            }\n            list :+= row.take(k)\n            map.put(row\
    \ % grid.length, list)\n            list.remove(0)\n        }\n        val result:\
    \ List[Long] = map.values.flatten.toList.sorted\n        result.min", "      \
    \  val visited : mutable.Set[Long] = mutable.HashSet[Long]()\n        val path\
    \ : List[Long] = Nil\n        val index : List[Int] = Nil\n        val queue :\
    \ Queue[Long] = new PriorityQueue[Long](k)\n        val visited : mutable.Set[Long]\
    \ = mutable.HashSet[Long]()\n        val start : Long = 0\n        val end : Int\
    \ = grid.length\n        val index : List[Int] = Nil\n        val queue : Queue[Long]\
    \ = new PriorityQueue[Long](k)\n        visited.add(start)\n        queue.add((start,\
    \ grid.apply(start).toLong))\n        index :+= (start)\n        while (queue.size()\
    \ > 0 && queue.head._2 != end) {\n            val index : List[Int] = Nil\n  \
    \          val path : List[Long] = Nil\n            val value : Long = queue.head._2\n\
    \            index :+= queue.head._1\n            visited.add(value)\n       \
    \     path :+= value\n            for (i <- 0 until index.length && index < end)\
    \ {\n                val i : Int = index(i)\n                val path : List[Long]\
    \ = Nil\n                val value : Long = grid(i)(j)\n                val j\
    \ : Int = index(i + 1)\n                if (visited.contains(value) && grid(i)(j)\
    \ == value) {\n                    path :+= value\n                    index :+=\
    \ List(i, i + 1)\n                    visited.add(value)\n                   \
    \ queue.add((value, value))\n                }\n            }\n            path\
    \ = path.sortWith((a, b) => a < b)\n            if (path.length == k) {\n    \
    \            val newPath : List[Long] = Nil\n                for ((i, j) <- path)\n\
    \                    newPath :+= grid(i)(j)\n                index :+= path.map(x\
    \ => x + 1)\n                path :+= newPath\n                path :+= value\n\
    \            }\n            queue.remove()\n        }\n        index = index.sortWith((a,\
    \ b) => a < b)\n        if (index.size == k) {\n            val newPath : List[Long]\
    \ = Nil\n            for (i <- index)\n                newPath :+= grid(i)(0)\n\
    \            index :+= newPath.map(x => x + 1)\n            index :+= end\n  \
    \      }\n        index = index.sortWith((a, b) => a < b)\n        if (index.size\
    \ == k) {\n            val newPath : List[Long] = Nil\n            for (i <- index)\n\
    \                newPath :+= grid(i)(0)\n            index :+= newPath.map(x =>\
    \ x + 1)\n            index :+= end\n        }\n        index = index.sortWith((a,\
    \ b", "        // use recursion to solve the problem\n        def minPathHelper(grid\
    \ : List[List[Long]], k : Long, path : List[Long] = List(), paths : List[List[Long]]\
    \ = List()) : List[List[Long]] = {\n            // base case: when no path has\
    \ length k, return path\n            if (path.size == k) return paths\n      \
    \      // get the last element of path from lst_B\n            val lastElement\
    \ = paths(path.size - 1)\n            // if last element of path is same as current\
    \ cell, append current cell to path\n            if (lastElement == grid(path.size\
    \ - 1)) path :+ grid(path.size - 1)\n            // else, append current cell\
    \ to path\n            else path :+ grid(path.size - 1)\n        }\n        //\
    \ create an empty list to store results\n        val paths = List.fill(grid.length)(List())\n\
    \        // use recursion to solve the problem\n        grid.foreach{row => \n\
    \            row.foreach{col => \n                // remove current cell from\
    \ the grid\n                val newGrid = grid.filter(_ => !_._1 == col).map(_._2).filter(_\
    \ => !_._1 == col)\n                // get the minimum path\n                val\
    \ path = minPathHelper(newGrid, k) \n                // append the path to paths\
    \ to store the results \n                paths(col) ::: path\n            }\n\
    \        }\n        // return the paths (List[List[Long]])\n        paths", " \
    \       var ret: List[Long] = Nil\n        var i: Int = 0\n        var j: Int\
    \ = 0\n        var temp: Long = grid[i][j]\n        while(i < grid.length && j\
    \ < grid[i].length){\n            if(grid(i).contains(temp) && grid(j).contains(temp)){\n\
    \                ret :+= temp\n                j = 0\n                i += 1\n\
    \                while(i < grid.length && j < grid[i].length){\n             \
    \       grid(j) = grid(j)+grid(i)\n                    if(grid(j).contains(temp)){\n\
    \                        ret :+= temp\n                        j = 0\n       \
    \                 i += 1\n                    } else {\n                     \
    \   j += 1\n                    }\n                }\n            } else {\n \
    \               j+=1\n            }\n            temp = grid[i][j]\n        }\n\
    \        ret :+= temp\n        ret :+= grid[i+1].dropRight(1)\n        ret :+=\
    \ grid[j+1].dropRight(1)\n        if(i < grid.length - 1){\n            ret :+=\
    \ grid[i+2].dropRight(1)\n        }\n        if(j < grid[i].length - 1){\n   \
    \         ret :+= grid[j+2].dropRight(1)\n        }\n        ret", "        val\
    \ gr = grid (0,k)\n        val n = grid.size\n        val d = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        val dr = scala.collection.mutable.ListBuffer.empty[List[Long]]\n    \
    \    var count = 0\n        var min = 0\n        for (i <- 0 until n)\n      \
    \      for (j <- 0 until n)\n                if (gr(j) == gr(i)) { count += 1;\
    \ d+=gr(j); dr+=j::i }\n        if (count < k) minpath(d,dr,n,k)\n        else\
    \ for (i <- 0 until n)\n            for (j <- 0 until n)\n                if (gr(j)\
    \ == gr(i) && d(j) < d(i))\n                    min = j\n        val ans = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 0 until n)\n            if (d(i) == min)\n                ans++=\
    \ dr(i)\n        return ans.toList", "        def checkEdge(i : Int, j : Int)\
    \ : List[Long] = {\n            if (i + 1 < grid.length && j + 1 < grid[i].length)\
    \ {\n                if (grid[i][j] < grid[i + 1][j] && grid[i + 1][j] < grid[i][j\
    \ + 1]) {\n                    lst_A += grid[i][j]\n                    lst_A\
    \ += grid[i + 1][j]\n                    lst_A += grid[i + 1][j + 1]\n       \
    \         }\n            }\n            val ret: List[Long] = if (i + 1 < grid.length\
    \ && j + 1 < grid[i].length) {\n                if (grid[i][j] < grid[i + 1][j]\
    \ && grid[i + 1][j] < grid[i][j + 1]) {\n                    val ret = grid[i\
    \ + 1][j].toLong - grid[i][j].toLong + grid[i + 1][j + 1] - grid[i][j + 1].toLong\n\
    \                    lst_A += ret\n                }\n                ret\n  \
    \          } else {\n                lst_A += grid[i][j].toLong\n            \
    \    ret\n            }\n            val ret2 = if (i + 1 < grid.length && j +\
    \ 1 < grid[i].length) {\n                if (grid[i + 1][j] < grid[i][j + 1])\
    \ {\n                    val ret2 = grid[i + 1][j].toLong - grid[i][j].toLong\
    \ + grid[i + 1][j + 1] - grid[i][j + 1].toLong\n                    lst_B += ret2\n\
    \                }\n                ret2\n            } else {\n             \
    \   lst_B += grid[i][j].toLong\n                ret2\n            }\n        \
    \    val ret3 = if (i + 1 < grid.length && j + 1 < grid[i].length) {\n       \
    \         if (grid[i + 1][j] < grid[i][j + 1]) {\n                    val ret3\
    \ = grid[i + 1][j].toLong - grid[i][j].toLong + grid[i + 1][j + 1] - grid[i][j\
    \ + 1].toLong\n                    lst_A += ret3\n                }\n        \
    \        ret3\n            } else {\n                lst_A += grid[i][j].toLong\n\
    \                ret3\n            }\n            val ret4 = if (i + 1 < grid.length\
    \ && j + 1 < grid[i].length) {\n                if (grid[i + 1][j] < grid[i][j\
    \ + 1]) {\n                    val ret4 = grid[i + 1][j].toLong - grid[i][j].toLong\
    \ + grid[i + 1][j + 1] - grid[i][j + 1].toLong\n                    lst_B += ret4\n\
    \                }\n                ret4\n            } else {\n             \
    \   lst_B += grid[i][j].toLong\n                ret4\n            }\n        \
    \    val ret5 = if (i + 1 < grid.length && j + 1 < grid[i].length) {\n       \
    \         if (grid[i + 1][j] < grid[i][j + 1]) {\n                    val ret5\
    \ = grid[i + 1][j].toLong - grid[i][j].toLong + grid[i + 1][j + 1] - grid[i][j\
    \ + 1].toLong\n                    lst_B += ret5\n                }\n        \
    \        ret5\n            } else {\n                lst_B += grid[i][j].toLong\n",
  "        // If grid is empty, then return empty path\n        if (grid.isEmpty)\
    \ {\n            return Nil\n        }\n        // If grid is of size 1, then\
    \ return k\n        if (grid.head == Nil) {\n            return Nil\n        }\n\
    \        // Create path start from cell with value 1 \n        var pathStartCell\
    \ : Long = 1\n        // Keep a stack of visited cells \n        var visitedCells\
    \ : List[Long] = Nil\n        // While there are cells in grid\n        while\
    \ (grid.head != Nil) {\n            // If there are already k cells visited, then\
    \ break\n            if (visitedCells.length == k) {\n                break\n\
    \            }\n            // Add cell to visited cells \n            visitedCells\
    \ = visitedCells ::: List(grid.head.head.asInstanceOf[Long])\n            // Add\
    \ cell to path \n            pathStartCell = grid.head.head.asInstanceOf[Long]\n\
    \            // Remove cell from grid \n            grid = grid drop 1 \n    \
    \        // Search neighbors of cell \n            for (cell <- grid.head) {\n\
    \                // If cell is not visited, then continue\n                if\
    \ (!visitedCells.contains(cell.asInstanceOf[Long])) {\n                    //\
    \ Add cell to visited cells \n                    visitedCells = visitedCells\
    \ ::: List(cell.asInstanceOf[Long])\n                    // Add cell to path \n\
    \                    pathStartCell = cell.asInstanceOf[Long]\n               \
    \     // Remove cell from grid \n                    grid = grid drop 1\n    \
    \            }\n            }\n        }\n        // Return list of cells visited\
    \ \n        return visitedCells", "        if (grid.isEmpty) Nil\n        else\
    \ findPath(grid, grid.head.last, k)", "        val lst_A = new mutable.PriorityQueue[Long]()\n\
    \        val lst_B = new mutable.PriorityQueue[Long]()\n        for (row <- 0\
    \ until grid.length) {\n            for (column <- 0 until grid[row].length) {\n\
    \                lst_A += grid[row](column)\n                lst_B += grid[row](column)\n\
    \            }\n        }\n        lst_A.dequeue", "        val grid = mutable.ArrayBuffer[List[Long]]()\n\
    \        val grid = mutable.ArrayBuffer[List[Long]]()\n        val grid = mutable.ArrayBuffer[List[Long]]()\n\
    \        for (i <- 1 to k) {\n            grid.push(grid.getOrElse(List(), 0))\n\
    \        }\n        var count = 1\n        var count = 0\n        for (row <-\
    \ grid) {\n            for (cell <- row) {\n                if (cell.toLong >\
    \ 0) {\n                    count += 1\n                    val cell = grid((count-1).toInt)\n\
    \                    for (i <- 1 to count) {\n                        if (cell(i-1)\
    \ < cell(i)) {\n                            val temp = cell.drop(i-1)\n      \
    \                      val cell = cell(i-1) ++ temp\n                        }\n\
    \                    }\n                }\n            }\n        }\n        for\
    \ (x <- grid) {\n            val list = x.get\n            val list = list.toList\n\
    \            grid.set((list.size-1).toInt, list)\n        }\n        return grid.getOrElse(List[Long](),\
    \ 0)", "        def find(grid : List[List[Long]], i : Int, lst : List[Long], path\
    \ : List[Long]) : List[Long] = {\n            if (i == grid.length) {\n      \
    \          if (path.size != k) {\n                    lst.clear\n            \
    \        path.clear\n                }\n                lst ::: path\n       \
    \     } else {\n                def nextPath(i: Int) : List[Long] = {\n      \
    \              def nextPath2(i : Int, j : Int, lst : List[Long], path : List[Long]):\
    \ List[Long] = {\n                        if (i == j) {\n                    \
    \        lst ::: path\n                        } else {\n                    \
    \        def nextPath3(i : Int, j : Int, lst : List[Long], path : List[Long]):\
    \ List[Long] = {\n                                if (i == j) {\n            \
    \                        lst ::: path\n                                } else\
    \ {\n                                    if (lst(j) < lst(i)) {\n            \
    \                            def nextPath4(i : Int, j : Int, lst : List[Long],\
    \ path : List[Long]): List[Long] = {\n                                       \
    \     if (i == j) {\n                                                lst ::: path\n\
    \                                            } else {\n                      \
    \                          if (lst(j) < lst(i)) {\n                          \
    \                          val k = lst(j) + 1\n                              \
    \                      val path = nextPath(i, j+1, lst + k.toLong, lst + path.toLong)\n\
    \                                                    nextPath4(i, j+1, path, path)\n\
    \                                                } else {\n                  \
    \                                  val k = lst(i) + 1\n                      \
    \                              val path = nextPath(i, j+1, lst + k.toLong, lst\
    \ + path.toLong)\n                                                    nextPath4(i,\
    \ j+1, path, path)\n                                                }\n      \
    \                                      }\n                                   \
    \     }\n                                        nextPath3(i, j+1, lst + i, path)\n\
    \                                    } else {\n                              \
    \          val k = lst(i) + 1\n                                        val path\
    \ = nextPath(i, j+1, lst + k.toLong, lst + path.toLong)\n                    \
    \                    nextPath4(i, j+1, path, path)\n                         \
    \           }\n                                }\n                           \
    \ }\n                            nextPath2(i, j+1, lst, path)\n              \
    \          }\n                    }\n                    nextPath2(i+1, i, lst,\
    \ path)\n                }\n                val path = find(grid, i, lst, path)\n\
    \                val nextPath = nextPath(i, path.size, lst, path)\n          \
    \      find(nextPath, path.size, lst, path)\n            }\n        }\n      \
    \  find(grid, 0, 0, List.empty[Long])", "        val n = grid.length\n       \
    \ val m = grid(0).length\n        val grid0 = grid.flatten\n        val grid1\
    \ = grid0.map(x => x.toLong)\n        val grid2 = grid1.map(x => x.toLong)\n \
    \       val grid3 = grid2.map(x => x.toLong)\n        var minPath = List[Long]()\n\
    \        var minPathIndex = k\n        var minPathValue = grid0(k)\n        var\
    \ minPathIndex = k\n        val grid4 = grid3.map(x => x.toLong)\n        while(grid4.nonEmpty)\
    \ {\n            val nextPathIndex = grid4.min\n            val nextPathValue\
    \ = grid4(nextPathIndex)\n            var tempPath = List[Long]()\n          \
    \  var tempPathIndex = k\n            var tempPathValue = grid0(k)\n         \
    \   val tempPathIndex = k\n            val tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            val tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            val tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            val tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            val tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)\n            var tempPathIndex = k\n            var\
    \ tempPathValue = grid0(k)", "        var visitedCells = mutable.Set.empty[Long]\n\
    \        var orderedCells = mutable.List.empty[Long]\n        \n        def visit(i\
    \ : Int) : Unit = visitedCells += grid(i).iterator\n        \n        def minPathUtil(i,\
    \ j : Int, k : Int, r : List[Long]) : List[Long] = {\n            // base case\n\
    \            if (i == grid.length && j == grid.length && k == 0) orderedCells.add(r)\n\
    \            else if ((i != grid.length) || (j != grid.length) || (k != 0)) {\n\
    \                // recursive case\n                var cell = grid(i)\n     \
    \           var nextCell = grid(j).iterator.next\n                var nextCellValue\
    \ = nextCell.toLong\n                var nextCellToAdd = List(nextCellValue)\n\
    \                var nextCellIndex = 0\n                while (nextCellIndex <\
    \ grid.length && nextCellIndex <= k) {\n                    cell = nextCell\n\
    \                    nextCell = grid(nextCellIndex).iterator.next\n          \
    \          nextCellValue = nextCell.toLong\n                    nextCellToAdd.insert(nextCellValue)\n\
    \                    nextCellIndex += 1\n                }\n                minPathUtil(i,\
    \ j, k - 1, r.prepend(cell.iterator.toList).sortBy(_.toLong))\n              \
    \  minPathUtil(i + 1, j, k - 1, r.prepend(nextCellToAdd).sortBy(_.toLong))\n \
    \               minPathUtil(i, j + 1, k - 1, r.prepend(nextCellToAdd).sortBy(_.toLong))\n\
    \            }\n        }\n        \n        minPathUtil(1, 1, 0, List.empty[Long])\n\
    \        visitedCells.toList.sortBy(_.toLong)", "        val paths = mutable.ListBuffer.empty[List[Long]]\n\
    \        val grid = grid.map(_.map(_.toLong)).flatten\n        grid.foreach {\
    \ row =>\n            if (row.length < k) paths += row\n            else for (i\
    \ <- 1 to row.length)\n                if (row(i) == row(i-1))\n             \
    \       paths += row\n        }\n        paths.sorted.reverse", "        val lst_A\
    \ = grid.flatMap(x => x.toList).toList\n        val lst_B = grid.flatMap(x =>\
    \ x.toList).toList\n        val lst_A1 = lst_A.filter(x => x == lst_B(0))\n  \
    \      val lst_B1 = lst_B.filter(x => x == lst_A(0))\n        val res = lst_A1.zipWithIndex.filter{\
    \ case (xx, y) => yx < k }.sortBy(x => x._2).reverse.flatMap(x => x._1)\n    \
    \    res", "        val values = grid.map{c => c.toList}\n        val sortedValues\
    \ = values.sortWith((x, y) => x.asInstanceOf[Long] < y.asInstanceOf[Long])\n \
    \       val result: List[Long] = new ListBuffer[Long]()\n        var currentValue:\
    \ Long = sortedValues.head\n        val currentIndex = values.indexOf(currentValue)\n\
    \        val visited = new mutable.HashSet[Long]()\n        visited.add(currentValue)\n\
    \        val visitedCount = values.count(c => visited.contains(c))\n        while\
    \ (visitedCount < k && currentIndex != -1)\n        {\n            var currentIndex\
    \ = values.indexOf(currentValue)\n            val currentValue = sortedValues(currentIndex).toLong\n\
    \            val nextValues = values - currentIndex\n            val nextValuesSorted\
    \ = nextValues.sortWith((x, y) => x.asInstanceOf[Long] < y.asInstanceOf[Long])\n\
    \            while (nextValuesSorted.length >= k)\n            {\n           \
    \     val nextValue = nextValuesSorted.head\n                val nextIndex: Int\
    \ = nextValues.indexOf(nextValue)\n                if (visited.contains(nextValue)\
    \ || nextIndex == -1)\n                {\n                    continue\n     \
    \           }\n                visited.add(nextValue)\n                val nextValueNextIndex\
    \ = nextValues.indexOf(nextValue, nextIndex + 1)\n                if (nextValueNextIndex\
    \ != -1)\n                {\n                    val nextValueNext = nextValues(nextValueNextIndex).toLong\n\
    \                    val temp = currentValue\n                    currentValue\
    \ = nextValue\n                    currentIndex = nextIndex\n                \
    \    nextValue = nextValueNext\n                    nextIndex = nextValueNextIndex\n\
    \                    nextValueNext = temp\n                }\n               \
    \ else\n                {\n                    val temp = currentValue\n     \
    \               currentValue = nextValue\n                    currentIndex = nextIndex\n\
    \                    nextValue = temp\n                }\n                result.append(nextValue)\n\
    \            }\n        }\n        if (currentIndex == -1)\n        {\n      \
    \      return new ListBuffer[Long]()\n        }\n        else\n        {\n   \
    \         currentValue\n        }", "        if(k <= 0) List(1l)\n        else\
    \ {\n            val rowList: mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \            val colList: mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \            val gridSize: Long = grid.head.size\n            for(i <- 1 to gridSize){\n\
    \                for(j <- 1 to gridSize){\n                    if(gridSize(j)\
    \ == 1){\n                        colList(j-1) = i\n                    }\n  \
    \                  else {\n                        val inColList: mutable.MutableList[Long]\
    \ = colList.map(_ * gridSize(j-1))\n                        val inRowList: mutable.MutableList[Long]\
    \ = rowList.map(_ * gridSize(j-1))\n                        val minPathLength:\
    \ Int = inColList.foldLeft((i, j, 0)){case ((lst_AIndex, lst_BIndex, jIndex),\
    \ element) =>\n                            val newList: List[Long] = inColList.filter(el\
    \ => !(el < element))\n                            val newColList: List[Long]\
    \ = inRowList.filter(el => !(el < element))\n                            (lst_AIndex,\
    \ lst_BIndex, jIndex + newList.size)\n                        }\n            \
    \            if(inRowList(minPathLength) > inColList(minPathLength)){\n      \
    \                      val newRowList: List[Long] = inRowList.filter(el => !(el\
    \ < element))\n                            val newColList: List[Long] = inColList.filter(el\
    \ => !(el < element))\n                            (minPathLength(1), minPathLength(2),\
    \ minPathLength(3))\n                        }\n                        else {\n\
    \                            val newRowList: List[Long] = inRowList.filter(el\
    \ => !(el < element))\n                            val newColList: List[Long]\
    \ = inColList.filter(el => !(el < element))\n                            (minPathLength(1),\
    \ minPathLength(2), minPathLength + newRowList.size)\n                       \
    \ }\n                    }\n                }\n            }\n        }", "  \
    \    val resultSet = mutable.ArrayBuffer.empty[Long]\n      val visitedSet = mutable.Set[Long]()\n\
    \      var minLen = Long.MaxValue\n      var currentLen = 0\n      def dfs(len\
    \ : Long, cur : Long) {\n        if (len <= 0) return\n        if (visitedSet.contains(cur))\
    \ return\n        visitedSet += cur\n        if (minLen > len) return\n      \
    \  minLen = len\n        resultSet += cur\n        grid.foreach {\n          case\
    \ x => dfs(len-1, x)\n        }\n      }\n      dfs(k, 0)\n      resultSet.sort",
  "        val lst_A = grid.map(_.toSeq.sorted).flatten\n        val lst_B = grid.map(_.toSeq.sorted).flatten.reverse\n\
    \        val lst_C = lst_A.zip(lst_B).zipWithIndex.map {\n            case ((_,_),\
    \ i) => if(lst_A(i) > lst_B(i)) (i) else (i + 1)\n        }.toList\n        val\
    \ n = grid.head._2.size\n        def loop(i: Int) : List[Long] = {\n         \
    \   if(i <= k) {\n                val cur = grid(i)(0)\n                val rest\
    \ = lst_C.filter(_._1 == cur)\n                val next = (rest min)._1\n    \
    \            if(next < k) loop(i + 1) else List(cur)\n            } else List()\n\
    \        }\n        loop(1).map(_.toLong)", "        var min_path : List[Long]\
    \ = Nil\n        var next_node : Long = grid.head._1\n        var is_seen : Map[Long,\
    \ Boolean] = Nil\n        var new_grid : List[List[Long]] = Nil\n\n        //\
    \ For each cell in the grid\n        for (current_cell <- grid) {\n          \
    \  is_seen(current_cell._2) = true\n\n            // For each neighbor of the\
    \ current cell\n            for (neighbor <- current_cell._1 diff current_cell)\
    \ {\n                // If the neighbor is unvisited, then add it to the path\n\
    \                if (!is_seen(neighbor))\n                    min_path ::= neighbor\n\
    \            }\n\n            // If the current cell is the last cell in the grid,\
    \ then add it to\n            // the path\n            if (current_cell._1 ==\
    \ grid.last._1)\n                min_path ::= current_cell._1\n        }\n   \
    \     \n        new_grid = grid diff (grid.filter(x => x._1 == min_path diff min_path).map(x\
    \ => x._2))\n\n        val new_min_path = minPath(new_grid, k)\n        new_min_path\
    \ ::= min_path\n\n        new_grid", "        def bfs(grid : List[List[Long]],\
    \ i : Int, l : List[Long]) =\n            if (i < grid.length && grid.exists(_.get(i)\
    \ <:< _.get(grid(i)))) \n                bfs(grid, i + 1, l :+ grid(i)) else l\n\
    \n        def helper(grid : List[List[Long]], k : Long, result : List[Long]):\
    \ List[Long] = {\n            if (k <= 0) \n                result else helper(bfs(grid,\
    \ 1, List.empty[Long]), (k - 1), result :+ grid(1))\n        }\n        helper(grid,\
    \ k, List.empty[Long])", "        // Find the starting cell\n        val first\
    \ = grid.head\n        if (first == k) {\n            val firstIndex = grid.indexOf(0)\n\
    \            val secondIndex = grid.indexOf(1)\n            if (firstIndex !=\
    \ secondIndex) {\n                val firstValue = grid((firstIndex + 1) % grid.length)\n\
    \                val secondValue = grid((secondIndex + 1) % grid.length)\n   \
    \             val values: List[Long] = firstValue :: secondValue\n           \
    \     values\n            }\n        } else {\n            val firstIndex = grid.indexOf(first)\n\
    \            val secondIndex = grid.indexOf(first + 1)\n            val values:\
    \ List[Long] = if (firstIndex != secondIndex) grid((firstIndex + 1) % grid.length)\
    \ :: grid((secondIndex - 1) % grid.length) else grid((firstIndex - 1) % grid.length)\
    \ :: grid((secondIndex + 1) % grid.length)\n            values\n        }", " \
    \       // Sort the list of lists so that each row is sorted by its first value,\
    \ which\n        // is guaranteed to be non-decreasing\n        val grid = grid.sortWith((rowA,\
    \ rowB) => rowA._1 < rowB._1)\n        \n        // The minimum path will be a\
    \ path of length k, and this will be initially\n        // empty. \n        //\
    \ If there are fewer elements than k on the grid, we will have to add \n     \
    \   // the element at the end of every path we find. \n        // If there are\
    \ more elements than k on the grid, we will have to take the\n        // last\
    \ elements from every path we find. \n        // We will do this by creating two\
    \ queues. One for \"going to\" cells, and\n        // one for \"going from\" cells.\n\
    \        val queueA = new mutable.LinkedList[List[Long]]()\n        val queueB\
    \ = new mutable.LinkedList[List[Long]]()\n        \n        // The first element\
    \ of the list will be the value of the first cell in the\n        // grid\n  \
    \      queueA += grid(0)\n        \n        // The first element of the list will\
    \ be the value of the first cell in the\n        // grid\n        queueB += grid(0)\n\
    \        \n        // This will be a list containing as many elements as there\
    \ are cells on the grid\n        // and we will add all of these to the queueA\n\
    \        var minPath = new mutable.LinkedList[Long]()\n        \n        // This\
    \ will increment the size of the minPath list each time we find an\n        //\
    \ item on the queue\n        var currentSize = minPath.size\n        \n      \
    \  // This is a flag to see if we have found all paths. We will find an\n    \
    \    // empty path every k or fewer cells, until we have checked all the\n   \
    \     // cells\n        var foundEmptyPath = false\n        \n        // A flag\
    \ indicating if we have reached the end of the grid\n        var done = false\n\
    \        \n        // For each cell in the grid we can go from either \"going\
    \ to\" or \"going from\"\n        // cells. We'll keep track of the current cell\n\
    \        val currentCell = 0\n        \n        // Loop through the rows in the\
    \ grid\n        while (currentCell < grid.size) {\n            // The current\
    \ row will be the first row in the queue\n            var currentRow = queueA.poll()\n\
    \            \n            // If the row is not empty, then we need to add its\
    \ elements to the queue\n            // of \"going to\" cells\n            if\
    \ (currentRow.nonEmpty) {\n                queueA += currentRow\n            \
    \    currentSize = (minPath.size + 1).toLong\n            }\n            \n  \
    \          // The current row will be the first row in the queue\n           \
    \ currentRow = queueB.poll()\n            \n            // If the row is not ",
  "        // Find a path from any cell in the grid (say from grid [0][0] to grid\
    \ [N - 1][N - 1]),\n        // and return its ordered list of cells (return them\
    \ in lexicographical order).\n        // If no such path exists, return an empty\
    \ list.\n        // The grid is represented by a list of lists: each sub-list\
    \ represents an edge (cell)\n        // from the current cell, and each item in\
    \ a sub-list is a value in the range [1, N * N] inclusive.\n        // The order\
    \ in which the cells are visited does not matter, i.e., any cell can be visited\
    \ more than once.\n        // The k-th path can be visited from any cell (that\
    \ is, any cell can be visited more than once),\n        // so we should always\
    \ have a path whose length is at most k.\n        val N = grid.length\n      \
    \  val visited = new mutable.HashSet[Long]\n        val result = new mutable.ArrayBuffer[Long]()\n\
    \        \n        // The first cell must be visited immediately, so add it into\
    \ the result list\n        result.addAll(List(grid(0).head))\n        visited.add(grid(0).head)\n\
    \        \n        // For each cell that is visited, find its neighbors, and add\
    \ them to the result list\n        // If there are no neighbors, add it into the\
    \ result list\n        // For each cell in the neighboring cell, add it into the\
    \ result list\n        // For each cell in the neighboring cell, add its neighbors\
    \ to the result list\n        for (x <- 0 until N) {\n            for (y <- 0\
    \ until N) {\n                val cell = grid(x).drop(x).take(y).head\n      \
    \          // If the cell is visited, find its neighbors and add them to the result\
    \ list\n                if (visited.contains(cell)) {\n                    val\
    \ neighbors = findNeighbours(grid, cell, x, y)\n                    if (neighbors.nonEmpty)\
    \ {\n                        result.addAll(neighbors)\n                    }\n\
    \                }\n                \n                // If there exist a cell,\
    \ add its neighbors to the result list\n                if (cell.isDefined) {\n\
    \                    val neighbors = findNeighbours(grid, cell, x, y)\n      \
    \              if (neighbors.nonEmpty) {\n                        result.addAll(neighbors)\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ (result.size < k) result.toList\n        else result.take(k).toList", "    \
    \    val m = grid.size\n        def dfs(pos : Int, result : mutable.PriorityQueue[Long],\
    \ k : Long) : Unit = {\n            if (pos == m)\n                result foreach\
    \ println\n            else\n                val n = (pos * pos) % m\n       \
    \         if (grid(n).isEmpty)\n                    result foreach println\n \
    \               else if (grid(n).head.toLong == grid(n).last.toLong) {\n     \
    \               if (result.size == k)\n                        result foreach\
    \ println\n                    else\n                        dfs(n + 1, result,\
    \ k)\n                }\n                else {\n                    val n2 =\
    \ (pos * pos) % m\n                    if (grid(n).head.toLong < grid(n2).head.toLong)\
    \ {\n                        val tmp = grid(n).head\n                        grid(n).head\
    \ = grid(n2).head\n                        grid(n2).head = tmp\n             \
    \           val tmp = result.head\n                        result.head = result.last\n\
    \                        result.last = tmp\n                        dfs(n + 1,\
    \ result, k)\n                    }\n                    else\n              \
    \          dfs(n + 1, result, k)\n                }\n        }\n        var result\
    \ : mutable.PriorityQueue[Long] = mutable.PriorityQueue()\n        result.clear()\n\
    \        dfs(0, result, k)\n        return result.toList", "        if (grid.isEmpty)\
    \ throw new IllegalArgumentException(\"grid is empty!\")\n        if (k > grid.length\
    \ * grid.length) throw new IllegalArgumentException(\"k is too large!\")\n   \
    \     var current = grid\n        var result : MutableList[Long] = collection.mutable.MutableList(current.head).asInstanceOf[MutableList[Long]]\n\
    \        var count : Int = 1\n        while(count < k){\n            current =\
    \ current.tail\n            val tmp = current.map(x => x.toLong).sorted.toList\n\
    \            result = result ++ (tmp).sortWith(_ < _)\n            count = count\
    \ + 1\n        }\n        result", "        val size = grid.length\n        if(size\
    \ < 2) {\n            throw new RuntimeException(\"Error: invalid grid dimensions\"\
    )\n        }\n        val lst_A = grid.getOrElse(Array.fill(k)((0L + k)).toList,\
    \ List(0L + k))\n        val lst_B = grid.getOrElse(Array.fill(k)((0L + k)).toList,\
    \ List(0L + k))\n        val size = lst_A.length\n        var count = 0\n    \
    \    for(i <- 1 to size) {\n            count = count + 1\n            for(j <-\
    \ 1 to i) {\n                lst_A(j) = lst_B(j)\n                lst_B(j) = lst_A(j)\n\
    \            }\n        }\n        lst_A", "        val len = grid.length\n  \
    \      val grid = grid.toSet.toList.sortBy(x => x._2).reverse\n        val n =\
    \ new mutable.ListBuffer[Long]()\n        var next = 0\n        var current =\
    \ grid(0)._2\n        while(current <= grid.last._2) {\n            val neighbor\
    \ = grid((next + current)%len)._2\n            if(!n.contains(neighbor)) {\n \
    \               n.add(neighbor)\n                current += 1\n            } else\
    \ {\n                next += 1\n            }\n        }\n        return n", " \
    \       val (rs, cs) = grid.zipWithIndex.collect {\n            case (row, i)\
    \ if i >= k => (row - 1, i) if row > 0 => row.last\n        }\n        val r1\
    \ = rs.head.min\n        val r2 = rs.last.max\n        val c1 = cs.head.min\n\
    \        val c2 = cs.last.max\n        val arr = grid.map(_.toSet)\n        val\
    \ path = (0 until k).map(idx => if (arr(idx(c1) + idx(r1) - 1)) idx(c2) + idx(r2)\
    \ else idx(c1) + idx(r1))).toSet\n        rs.head.collect {\n            case\
    \ x if arr.contains(x) => arr(x)\n        }.toList + path", "        // Write\
    \ your code here\n        val ins = mutable.Map[List[Long], Long]() \n       \
    \ var min = -1\n        var index = 0\n        var list = grid \n        while(index\
    \ < list.length) {\n            val newPath = list\n            val newIns = ins\n\
    \            val newMin = min\n            val newIndex = index\n            list\
    \ = removeSame(list, index)\n            min = minPath(list, k)\n            val\
    \ newList = list\n            val newIns = ins\n            val newMin = min\n\
    \            val newIndex = index\n            list = removeSame(list, index)\n\
    \            ins = newIns\n            min = newMin\n            index = newIndex\n\
    \            list = newList\n        }\n        return list match {\n        \
    \    case Nil => Nil\n            case x => x match {\n                case Nil\
    \ => Nil\n                case y => y.sort\n            }\n        }", "     \
    \   val m = grid.map(_.size.toLong)\n        val n = grid.map(_.size)\n      \
    \  var max = 0\n        var k = 0l\n        var i : Long = 0\n        var j :\
    \ Long = 0\n        var lst_A : List[Long] = Nil\n        var lst_B : List[Long]\
    \ = Nil\n        var count : Int = 0\n        var ans : List[Long] = Nil\n   \
    \     while (k < n) {\n            if (m(k) > 0) {\n                max = max(max)\n\
    \                lst_A = lst_A.filterNot(lst => lst.contains(k))\n           \
    \     lst_B = lst_B.filterNot(lst => lst.contains(k))\n                k = k +\
    \ max(max - 1, 0)\n            } else {\n                count = count + 1\n \
    \               k = 0\n            }\n        }\n        count = count - 1\n \
    \       while (i < count) {\n            if (i < count) {\n                max\
    \ = max(max)\n                lst_A = lst_A.filterNot(lst => lst.contains(lst_A(i)))\n\
    \                lst_B = lst_B.filterNot(lst => lst.contains(lst_B(i)))\n    \
    \            i = i + 1\n            } else {\n                k = k + 1\n    \
    \        }\n        }\n        count = count - 1\n        if (count > 0) {\n \
    \           while (j < count) {\n                if (j < count) {\n          \
    \          max = max(max)\n                    lst_A = lst_A.filterNot(lst =>\
    \ lst.contains(lst_A(i)))\n                    lst_B = lst_B.filterNot(lst =>\
    \ lst.contains(lst_B(i)))\n                    j = j + 1\n                } else\
    \ {\n                    ans = ans ++ lst_A\n                    k = k + 1\n \
    \               }\n            }\n        }\n        if (count == 0) {\n     \
    \       ans = ans ++ lst_A\n        }\n        if (ans != Nil) {\n           \
    \ ans = ans ++ lst_B\n        }\n        if (ans != Nil) {\n            ans =\
    \ ans ++ lst_A\n        }\n        if (ans != Nil) {\n            ans = ans ++\
    \ lst_B\n        }\n        return ans", "        // Write your code here\n  \
    \      val n = grid.size\n        val m = k\n        if (n < m) {\n          \
    \  throw IllegalArgumentException(\"n must be greater than k\")\n        }\n \
    \       var i = 0\n        var j = 0\n        var min = sys.maxLong\n        while\
    \ (i < n && j < n) {\n            var sum = grid[i][j]\n            if (i < n\
    \ && j < n) {\n                sum <- grid[i][j]\n            }\n            if\
    \ (sum < min) {\n                min = sum\n                i = 0\n          \
    \      j = 0\n            } else {\n                if (sum == min) {\n      \
    \              i += 1\n                    if (i < n) {\n                    \
    \    sum <- grid[i][j]\n                    }\n                    if (sum < min)\
    \ {\n                        min = sum\n                        j = 0\n      \
    \                  i += 1\n                    } else {\n                    \
    \    j += 1\n                    }\n                } else {\n               \
    \     j += 1\n                }\n            }\n        }\n        grid = grid.drop(1).take(1).append(minPath2(grid,\
    \ k - 1))\n        return grid", "        var cur = 0\n        var ans = List[Long]()\n\
    \        val list = grid.toList\n        for(i <- 1 to k) {\n            val curMap\
    \ = list.indexWhere(l => l(0) == cur)\n            val curIndex = curMap(0) +\
    \ 1\n            val next = List(list(curIndex), list(curIndex + 1))\n       \
    \     ans = ans.union(next)\n            cur = nextIndex(0)\n        }\n     \
    \   ans", "        // Create graph to store a path with length as k\n        val\
    \ g = HashMap[Long, List[Long]]()\n        // Create list of all cells (rows and\
    \ columns) (except start and end) on the grid\n        val cells = grid.indices.flatMap\
    \ { row => grid.indices.flatMap { col => col match { case i if (i != 0 && i !=\
    \ grid.length && i != grid.length - 1 && i != grid.length - 2) => List(i) } }\n\
    \        // Traverse graph to find path starting from start cell\n        cells.foreach\
    \ { cell =>\n            if (!g.contains(cell)) {\n                val path =\
    \ new scala.collection.mutable.ArrayList[Long]()\n                path.add(cell)\n\
    \                g.put(cell, path)\n            }\n        }\n        // Traverse\
    \ graph to find minimum path\n        var lowest = List[Long]()\n        for (cell\
    \ <- cells) {\n            val path = g.get(cell)\n            if (path.size ==\
    \ k) {\n                lowest = path.toList\n            }\n            if (path.size\
    \ < k) {\n                val newLowest = path.toList\n                val newPath\
    \ = path :+ cell\n                val indexToRemove = newLowest.indexOf(0)\n \
    \               newLowest.remove(indexToRemove)\n                val newPath =\
    \ newPath :+ newLowest.head\n                g.remove(cell)\n                g.put(cell,\
    \ newPath)\n            }\n        }\n        return lowest", "        val lst_A\
    \  : List[Long] = grid.flatMap { case (row, list) => list }.sortWith(_ < _)\n\
    \        val lst_B  : List[Long] = grid.flatMap { case (row, list) => list }.sortWith(_\
    \ > _)\n\n        if (lst_A.size < k) minPath(grid.reverse, k)\n        else lst_A.take(k).filter(_\
    \ <= lst_B(k)).sorted", "        val N = grid.size\n        val N*N\n        val\
    \ size = grid.headOption.map(_.size).getOrElse(N)\n        val grid = grid.toList\n\
    \        var result = List[Long]()\n        var i = N*N-1\n        var j = N-1\n\
    \        while(i != 0 || j != 0) {\n            if(i != 0 && j != 0 && grid(i).head\
    \ < grid(j).head) {\n                i += 1\n                j -= 1\n        \
    \    } else if(i != 0 && j != 0 && grid(i).head == grid(j).head) {\n         \
    \       i -= 1\n                j -= 1\n            } else {\n               \
    \ i += 1\n                j += 1\n            }\n            result :+= grid(i).head\n\
    \        }\n        result.sortWith(_.compareTo(_) > 0)\n        result", "  \
    \      var ans : List[Long] = Nil\n        var visited = new mutable.HashSet[Long]()\n\
    \        var visitedPath = new mutable.HashMap[Long,List[Long]]()\n        grid\
    \ foreach { c =>\n            if (c.length == 1) {\n                visited.add(c)\n\
    \                ans = ans ::: List(c.head)\n            } else {\n          \
    \      val first = c.head\n                var rest = c.tail\n               \
    \ val length = rest match {\n                    case Nil => k\n             \
    \       case x :: rest => x.length\n                }\n                if (visited.contains(first))\
    \ {\n                    val path = visitedPath(first)\n                    val\
    \ existing = path.zip(rest) match {\n                        case (Nil, Nil) =>\
    \ Nil\n                        case (x :: xs, y :: ys) => if (x < y) x :: xs else\
    \ y :: ys\n                    }\n                    val existing = visitedPath(first)\
    \ match {\n                        case (Nil, Nil) => Nil\n                  \
    \      case (x :: xs, y :: ys) => if (x < y) x :: xs else y :: ys\n          \
    \          }\n                    val existing = visitedPath(first) match {\n\
    \                        case (Nil, Nil) => Nil\n                        case\
    \ (x :: xs, y :: ys) => if (x < y) x :: xs else y :: ys\n                    }\n\
    \                    val existing = visitedPath(first) match {\n             \
    \           case (Nil, Nil) => Nil\n                        case (x :: xs, y ::\
    \ ys) => if (x < y) x :: xs else y :: ys\n                    }\n            \
    \        val existing = visitedPath(first) match {\n                        case\
    \ (Nil, Nil) => Nil\n                        case (x :: xs, y :: ys) => if (x\
    \ < y) x :: xs else y :: ys\n                    }\n                    val existing\
    \ = visitedPath(first) match {\n                        case (Nil, Nil) => Nil\n\
    \                        case (x :: xs, y :: ys) => if (x < y) x :: xs else y\
    \ :: ys\n                    }\n                    val existing = visitedPath(first)\
    \ match {\n                        case (Nil, Nil) => Nil\n                  \
    \      case (x :: xs, y :: ys) => if (x < y) x :: xs else y :: ys\n          \
    \          }\n                    val existing = visitedPath(first) match {\n\
    \                        case (Nil, Nil) => Nil\n                        case\
    \ (x :: xs, y :: ys) => if (x < y) x :: xs else y :: ys\n                    }\n\
    \                    val existing = visitedPath(first) match {\n             \
    \           case (N", "        val sizeN : Int = grid.length\n        val sizeM\
    \ : Int = grid(0).length\n        if (sizeN == 0 || sizeM == 0) return Nil\n \
    \       val size : Int = Math.min(sizeN, sizeM)\n        val grid : List[List[Long]]\
    \ = grid.toList\n        val result : List[Long] = Nil\n        var j = 0\n  \
    \      var i = size\n        while (i < size) {\n            while (grid(i).contains(grid(j)))\
    \ {\n                if (j < i) result ::= grid(i)\n                if (j == i)\
    \ break\n                i += 1\n            }\n            i += 1\n         \
    \   j += 1\n        }\n        result.sort", "        def dfs(grid: List[List[Long]],\
    \ k: Long, visited: List[Long], lst: List[Long], i: Int): List[Long] = {\n   \
    \         if (i >= k) {\n                return lst\n            }\n         \
    \   val lst_A = grid.map(_(i))\n            val lst_B = grid.map(_(i - 1))\n \
    \           val lst_C = grid.map(_(i - 2))\n            if (lst_A.head < lst_B.head\
    \ && lst_A.head < lst_C.head) {\n                lst += lst_A.head\n         \
    \       dfs(lst_A, k, visited + lst_A.head, lst, i + 1)\n            } else {\n\
    \                lst += lst_B.head\n                dfs(lst_B, k, visited + lst_B.head,\
    \ lst, i + 1)\n            }\n        }\n        val visited = new mutable.HashSet[Long]()\n\
    \        val lst = new mutable.ListBuffer[Long]()\n        dfs(grid, k, visited,\
    \ lst, 0)\n        lst.toList", "        val n = grid.size\n        val M = matrix.newBuilder(math.max(grid.map(_.size.toLong).max))\n\
    \        val S = sparse.newBuilder(math.max(grid.map(_.size.toLong).max))\n  \
    \      val A = ArrayBuffer.empty[Long]\n        val B = ArrayBuffer.empty[Long]\n\
    \        val F = ArrayBuffer.empty[Long]\n        for (row <- 1 to n) {\n    \
    \        for (col <- 1 to n) {\n                val cellIndex = col.toLong \xF7\
    \ n + (row - 1).toLong\n                M += cell(grid,row,col).toLong\n     \
    \           S += cell(grid,row,col)\n                A += cellIndex\n        \
    \        B += cellIndex\n            }\n        }\n        val res = A\n     \
    \   val stack = new Array[Long](0)\n        val stack2 = new Array[Long](0)\n\
    \        var j = k\n        var i = 0\n        while (i < A.length) {\n      \
    \      val x = A(i)\n            val cellIndex = x + 1\n            if (cellIndex\
    \ < B.length && cellIndex == B(cellIndex)) {\n                stack2 += cellIndex\n\
    \                stack += cellIndex\n                i += 1\n            } else\
    \ {\n                val cellIndex2 = x + 1\n                val cellIndex3 =\
    \ x + 1\n                val cellIndex4 = x + 1\n                val cellIndex5\
    \ = x + 1\n                val cellIndex6 = x + 1\n                val cellIndex7\
    \ = x + 1\n                val cellIndex8 = x + 1\n                val cellIndex9\
    \ = x + 1\n                val cellIndex10 = x + 1\n                val cellIndex11\
    \ = x + 1\n                val cellIndex12 = x + 1\n                val cellIndex13\
    \ = x + 1\n                val cellIndex14 = x + 1\n                val cellIndex15\
    \ = x + 1\n                val cellIndex16 = x + 1\n                val cellIndex17\
    \ = x + 1\n                val cellIndex18 = x + 1\n                val cellIndex19\
    \ = x + 1\n                val cellIndex20 = x + 1\n                val cellIndex21\
    \ = x + 1\n                val cellIndex22 = x + 1\n                val cellIndex23\
    \ = x + 1\n                val cellIndex24 = x + 1\n                val cellIndex25\
    \ = x + 1\n                val cellIndex26 = x + 1\n                val cellIndex27\
    \ = x + 1\n                val cellIndex28 = x + 1\n                val cellIndex29\
    \ = x + 1\n                val cellIndex30 = x + 1\n                val cellIndex31\
    \ = x + 1\n                val cellIndex32 = x + 1\n                val cellIndex33\
    \ = x + 1\n                val cellIndex34 = x + 1", "        // 1. If the grid\
    \ is empty or if k is 0, return an empty list.\n        val list: List[Long] =\
    \ if (grid.isEmpty) Nil\n        else if (!grid.head.isEmpty) list.asInstanceOf[List[Long]]\n\
    \        else Nil\n        val listOfCells = grid.asInstanceOf[List[List[Long]]]\n\
    \        val visited = new mutable.HashSet[Long]\n        var currentCell = grid\n\
    \        while (currentCell.nonEmpty) {\n            // 2. For each cell (i, j)\
    \ in the grid, add it to the list if the cell is not visited.\n            val\
    \ cellToAdd = (currentCell.head, currentCell.tail).zipped.filter(_._1 > _._1 &&\
    \ _._1 < _._2).map { _._2 }\n            visited.addAll(cellToAdd.map(x => x.toLong))\n\
    \            listOfCells ::= cellToAdd\n            // 3. Set the current cell\
    \ to the cells adjacent to the current cell\n            currentCell = (currentCell.tail,\
    \ currentCell.head).zipped.map { case (i, j) => (i, j)}.filter(_._1 == currentCell._1\
    \ && _._2 == currentCell._2).map(_._2).toList\n        }\n        // 4. If k is\
    \ 0, then return the ordered list you just created.\n        k match {\n     \
    \       case 0 => list\n            case _ => {\n                // 5. For each\
    \ cell, remove it from the list if it is in the list\n                // of values\
    \ from the visited cells, if it is not in the list of\n                // values\
    \ from the visited cells, add it to the list.\n                list.filterNot\
    \ { x => visited.contains(x) }\n                list.unionAll(visited.filter(_\
    \ == true))\n            }\n        }", "      val minX = grid.map(_.head).min\n\
    \      val minY = grid.map(_.last).min\n      val maxX = grid.map(_.head).max\n\
    \      val maxY = grid.map(_.last).max\n      val mapSize = math.max(minX + k,\
    \ minY + k)\n      val map = (0 until mapSize).map(_ * mapSize + _)\n      val\
    \ map2 = map.map(x => x.toInt).zipWithIndex.toMap\n      val map3 = map.map(x\
    \ => x.toLong).zipWithIndex.toMap\n      var lst_A: List[Long] = List.empty\n\
    \      var lst_B: List[Long] = List.empty\n      var j = 0\n      for (x <- 1\
    \ to (mapSize - 1)) {\n        j = 0\n        for (z <- 0 to (mapSize - 1)) {\n\
    \          if (map2(x) == map3(z) && x != z) {\n            lst_A = (lst_A :+\
    \ grid[x - 1](z))\n            j = z\n          }\n        }\n        for (z <-\
    \ 0 to (mapSize - 1)) {\n          if (map2(x) == map3(z) && x != z && z > j)\
    \ {\n            lst_B = (lst_B :+ grid[x - 1](z))\n          }\n        }\n \
    \     }\n      lst_A.sortWith((x, y) => x.toLong < y.toLong)", "        var grid1\
    \ = grid\n        var grid2 = grid1\n        val result = new mutable.ArrayBuffer[Long]()\n\
    \        val index = new mutable.HashMap[Long, Int]()\n        for (rowIndex <-\
    \ 0 to grid1.length - 1) {\n            for (columnIndex <- 0 to grid1.length\
    \ - 1) {\n                val current = grid1(rowIndex, columnIndex)\n       \
    \         if (index.get(current) == None) {\n                    index.put(current,\
    \ (rowIndex * grid1.length) + columnIndex)\n                }\n            }\n\
    \        }\n        index.values.foreach { i =>\n            val cur = index.values.iterator.next()\n\
    \            if (cur == i)\n                continue\n            if (cur < i)\n\
    \                grid1 = grid1.drop(cur).reverse ++ grid1.drop(i).reverse\n  \
    \          else if (cur > i)\n                grid2 = grid2.drop(cur).reverse\
    \ ++ grid2.drop(i).reverse\n            val temp = new mutable.ArrayBuffer[Long]()\n\
    \            grid1.zip(grid2).foreach { x =>\n                val num = (x._1.toLong\
    \ * x.length).toInt\n                val curr = x._2.toLong * x.length\n     \
    \           val temp1 = new mutable.ArrayBuffer[Long]()\n                val temp2\
    \ = new mutable.ArrayBuffer[Long]()\n                for (j <- 0 to x.length -\
    \ 1) {\n                    val k1 = (x._1(j) * x.length).toInt\n            \
    \        val k2 = (x._2(j) * x.length).toInt\n                    if (k1 < k)\
    \ {\n                        temp1 += x._1(j).toLong\n                       \
    \ temp2 += x._2(j).toLong\n                    } else if (k1 == k) {\n       \
    \                 temp1 += x._1(j).toLong\n                        temp2 += x._2(j).toLong\n\
    \                    } else if (k2 < k) {\n                        temp1 += x._1(j).toLong\n\
    \                        temp2 += x._2(j).toLong\n                    } else if\
    \ (k2 == k) {\n                        temp1 += x._1(j).toLong\n             \
    \           temp2 += x._2(j).toLong\n                    }\n                }\n\
    \                temp.concat(temp1).concat(temp2).foreach(x => if (x.length >=\
    \ k) result.append(x.toLong))\n            }\n        }\n        result.toList",
  "        val (result, path) = findPaths(grid, k)\n        result", "        val\
    \ maxPath : List[List[Long]] = [grid]\n        while (maxPath.size > k) maxPath.reverse.filter(_.remove(0)).reverse\n\
    \        return maxPath.take(k)", "        val lst = new mutable.LinkedListBuffer[Long]\n\
    \        val visited = new mutable.HashSet[Long]()\n        val n = grid.size\n\
    \        var i = 0\n        while (i < n) {\n            // start from (i, j)\n\
    \            var j = i\n            while (j + 1 < n && grid(j).head < grid(j\
    \ + 1).head) {\n                j += 1\n            }\n            val start =\
    \ grid(j).head\n            val end = grid(j + 1).head\n            while (end\
    \ - start != 1) {\n                // find the neighbors of current cell\n   \
    \             val left = (j - 1 >= 0) ? grid(j - 1).head : Long.MaxValue\n   \
    \             val right = (j + 1 < n) ? grid(j + 1).head : Long.MinValue\n   \
    \             val up = (i + 1 < n) ? grid(i + 1).head : Long.MaxValue\n      \
    \          val down = (i - 1 >= 0) ? grid(i - 1).head : Long.MinValue\n      \
    \          // if current cell is included in visited set, then it is a path\n\
    \                // and add the current cell to the list\n                if (visited.contains(grid(j).head\
    \ + grid(j + 1).head)) {\n                    lst.addLast(grid(j).head + grid(j\
    \ + 1).head)\n                }\n                // if current cell is included\
    \ in visited set and left < right && up < down, then we found the path\n     \
    \           else if (grid(j).head + grid(j + 1).head < left && grid(j).head +\
    \ grid(j + 1).head < right && grid(i).head + grid(i + 1).head < up && grid(i).head\
    \ + grid(i + 1).head < down) {\n                    lst.addLast(grid(j).head +\
    \ grid(j + 1).head)\n                    visited.add(grid(j).head + grid(j + 1).head)\n\
    \                }\n                // if current cell is not included in visited\
    \ set, then we move to its neighbors\n                else {\n               \
    \     if (grid(j).head < left && grid(j).head < right && grid(i).head < up &&\
    \ grid(i).head < down) {\n                        visited.add(grid(j).head + grid(j\
    \ + 1).head)\n                        lst.addLast(grid(j).head + grid(j + 1).head)\n\
    \                    }\n                    j -= 1\n                }\n      \
    \      }\n            // move to the next cell\n            i += 1\n        }\n\
    \        lst.toList", "        val graph = new mutable.HashMap[Long, List[Long]]()\n\
    \        val visited = new mutable.HashSet[Long]()\n        val path = new mutable.ListBuffer[Long]()\n\
    \        val start = new mutable.HashSet[Long]()\n        var cur = 0\n      \
    \  for (i <- 1 until grid.length) {\n            if (graph(i).isEmpty) {\n   \
    \             graph(i) = List(grid(i)(cur))\n                visited.add(grid(i)(cur))\n\
    \                if (cur == k) {\n                    val res = (start++path)\
    \ match {\n                        case x if x.size <= k => x\n              \
    \          case x => x.tail\n                    }\n                    res.toList\n\
    \                }\n                if (cur != 0 && visited.contains(grid(i)(cur\
    \ - 1)))\n                    graph(i) = graph(i).::(grid(i)(cur - 1))\n     \
    \           start+=grid(i)(cur)\n                cur += 1\n            }\n   \
    \     }", "        val visited = scala.collection.mutable.HashSet.empty[Long]\n\
    \        def dfs(i : Long) : List[Long] = {\n            if (visited(i)) List(grid(i)(i).toLong)\n\
    \            else {\n                val l = dfs(grid()(i)(0).toLong)\n      \
    \          val r = dfs(grid()(i)(1).toLong)\n                if (l.head < r.head)\
    \ l else r\n            }\n        }\n        dfs(grid().size)", "        val\
    \ r = mutable.PriorityQueue[List[Long]]()\n        val l = grid.map{x => x.sortBy(_._2)}.flatten\n\
    \        for ((i, j) <- l.zip(l.reverse)) {\n            if (i == j)\n       \
    \         r.enqueue(List(i, l(i))) \n            else if (i < j)\n           \
    \     r.enqueue(List(i, j))\n        }\n        r.toList.sortWith((x, y) => x.reverse.compareToIgnoreCase(y.reverse)).toList.flatMap(x\
    \ => x.reverse.toList).head(k+1).reverse", "        var min = k - 1\n        var\
    \ current = grid\n        while(current != null) {\n            val newMin = min\n\
    \            val newCurrent = current.sortBy(_.last) filter { case (l, r) => l\
    \ < r }\n            min = newMin\n            current = newCurrent.head\n   \
    \     }\n        if (min == k)\n            grid.toList.sorted\n        else\n\
    \            None", "        val n = grid.size\n        val v = grid\n       \
    \ val r = v.head\n        val c = v.tail\n        var min = Long.MaxValue\n  \
    \      var ans = Nil\n        var i = -1\n        for(i <- 1 to k) {\n       \
    \     ans = updateList(ans, r)\n            ans = updateList(ans, c)\n       \
    \     min = Math.min(min, getMin(ans))\n            i = i - 1\n        }\n   \
    \     ans = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans\
    \ = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans = updateList(ans,\
    \ r)\n        ans = updateList(ans, c)\n        ans = updateList(ans, r)\n   \
    \     ans = updateList(ans, c)\n        ans = updateList(ans, r)\n        ans\
    \ = updateList(ans, c)\n        ans = updateList(ans, r)\n        ans = updateList(ans,\
    \ c)\n        ans = updateList(ans, r)\n        ans = updateList(ans, c)\n   \
    \     ans = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans\
    \ = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans = updateList(ans,\
    \ r)\n        ans = updateList(ans, c)\n        ans = updateList(ans, r)\n   \
    \     ans = updateList(ans, c)\n        ans = updateList(ans, r)\n        ans\
    \ = updateList(ans, c)\n        ans = updateList(ans, r)\n        ans = updateList(ans,\
    \ c)\n        ans = updateList(ans, r)\n        ans = updateList(ans, c)\n   \
    \     ans = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans\
    \ = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans = updateList(ans,\
    \ r)\n        ans = updateList(ans, c)\n        ans = updateList(ans, r)\n   \
    \     ans = updateList(ans, c)\n        ans = updateList(ans, r)\n        ans\
    \ = updateList(ans, c)\n        ans = updateList(ans, r)\n        ans = updateList(ans,\
    \ c)\n        ans = updateList(ans, r)\n        ans = updateList(ans, c)\n   \
    \     ans = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans\
    \ = updateList(ans, r)\n        ans = updateList(ans, c)\n        ans = updateList(ans,\
    \ r)\n        ans = updateList(an", "        val r = grid.map(_.toSet).map(_.size)\n\
    \        val rmax = r.max\n        val rindex = r.index(rmax)\n        val rmax1\
    \ = rmax - 1\n        val rindex1 = rindex - 1\n        val minpath = r.zipWithIndex.map\
    \ {\n            case (idx, _) => idx\n        }.sortWith((a, b) => a._2 < b._1).take(k)\n\
    \        var temp = 0\n        for (i <- minpath) {\n            val ind = i._2\n\
    \            temp = i._1\n            val rind1 = rindex(ind)\n            val\
    \ rmax1 = rmax1\n            val rindex1 = rindex1\n            var temp1 = ind\n\
    \            var min = grid[rind1].toSet.size + grid[rindex1].toSet.size - 1\n\
    \            var max = grid[rind1].toSet.size + grid[rindex1].toSet.size - 1\n\
    \            for (j <- 0 until rmax1) {\n                if (ind == j && grid[j].toSet\
    \ == grid[temp1].toSet) {\n                    min = j + 1\n                }\n\
    \                if (ind != j && grid[j].toSet == grid[temp1].toSet && (grid[j].toSet\
    \ < grid[temp].toSet || (grid[j].toSet == grid[temp].toSet && min < max))) {\n\
    \                    max = j\n                }\n            }\n            if\
    \ (max < min && grid[ind].toSet == grid[temp1].toSet) {\n                minpath\
    \ += (i._1)\n            }\n        }\n        minpath.toList", "        var path\
    \ = List[Long]()\n        val l = grid.length\n        if (l < 2) {\n        \
    \    return path\n        }\n        var m = 0\n        var i = 0\n        while\
    \ (i <= l) {\n            val a = grid(i).head\n            var b = 0\n      \
    \      val c = grid(i).last\n            var d = 1\n            while (d <= (grid(i).length\
    \ * grid(i).length) - 1) {\n                i += 1\n                d += 1\n \
    \           }\n            m += d\n            if (a == c) {\n               \
    \ b += 1\n            }\n            path.append(a)\n            while (i <= l\
    \ && b <= (grid(i).length * grid(i).length) - 1) {\n                val c = grid(i).last\n\
    \                if (a == c) {\n                    b += 1\n                }\n\
    \                i += 1\n                d += 1\n            }\n            m\
    \ += d\n            path.append(c)\n            i += 1\n        }\n        path.reverse",
  "        val n = grid.length\n        if (n < 2) {\n            return grid\n  \
    \      }\n        val m = new mutable.HashMap[Long, (Int, Int)]()\n        for\
    \ (i <- 1 to n) {\n            for (j <- 1 to n) {\n                if (i != j\
    \ && m.getOrElse(grid[i][j], (-1L, -1L)) == -1L) {\n                    m.put(grid[i][j],\
    \ (i, j))\n                }\n            }\n        }\n        val path = m.values.toList.sortWith(_._1\
    \ < _._1).map(_._2)\n        path.takeRight(k).toList.sortWith(_._1 < _._1).map(_._1)",
  "        if (grid.isEmpty)\n            Nil\n        else {\n            val m =\
    \ scala.math.min(grid.head.length, k)\n            val lst_A = grid.head.take(m)\n\
    \            val lst_B = grid.tail.take(m)\n            val ans = lst_A.takeWhile(_\
    \ < lst_B(0)).toList ::: lst_B.takeWhile(_ < lst_B(0)).toList\n            minPath(grid.drop(1),\
    \ k, ans)\n        }", "        if (grid.length == 1) grid\n        else {\n \
    \           val grid = mutable.LinkedHashSet[List[Long]]()\n            val grid\
    \ = mutable.LinkedHashSet[Long]()\n            val grid = mutable.LinkedHashSet[Long]()\n\
    \            val grid = mutable.LinkedHashSet[List[Long]]()\n            val grid\
    \ = mutable.LinkedHashSet[Long]()\n            val grid = mutable.LinkedHashSet[List[Long]]()\n\
    \            var total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            val total = (-1l) :: List[Long]()\n           \
    \ val total = (-1l) :: List[Long]()\n            val total = (-1l) :: List[Long]()\n\
    \            val total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            val total = (-1l) :: List[Long]()\n           \
    \ val total = (-1l) :: List[Long]()\n            val total = (-1l) :: List[Long]()\n\
    \            val total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            val total = (-1l) :: List[Long]()\n           \
    \ val total = (-1l) :: List[Long]()\n            val total = (-1l) :: List[Long]()\n\
    \            val total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            val total = (-1l) :: List[Long]()\n           \
    \ val total = (-1l) :: List[Long]()\n            val total = (-1l) :: List[Long]()\n\
    \            val total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            val total = (-1l) :: List[Long]()\n           \
    \ val total = (-1l) :: List[Long]()\n            val total = (-1l) :: List[Long]()\n\
    \            val total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            val total = (-1l) :: List[Long]()\n           \
    \ val total = (-1l) :: List[Long]()\n            val total = (-1l) :: List[Long]()\n\
    \            val total = (-1l) :: List[Long]()\n            val total = (-1l)\
    \ :: List[Long]()\n            ", "        val N = grid.size\n        val vals\
    \ = grid.flatMap(row => row.map(elem => elem)).toArray\n        val visitedMap\
    \ = new mutable.HashMap[Long, Boolean]\n        val visitedList = mutable.ListBuffer.empty[Long]\n\
    \        for (i<- 1 to N - 1){\n            val start = vals(i)\n            for\
    \ (j <- i + 1 to N) {\n                val end = vals(j)\n                if (!visitedMap.contains(start)\
    \ && visitedMap.contains(end) && !visitedMap.get(start)) {\n                 \
    \   if (visitedList.contains(start) && visitedList.contains(end) && visitedList.toSet\
    \ == visitedMap.toSet) {\n                        visitedMap += (start -> true)\n\
    \                        visitedList += start\n                    } else if (visitedList.contains(start)\
    \ && visitedList.contains(end) && visitedList.toSet == visitedMap.toSet && visitedList.last\
    \ == end) {\n                        visitedMap += (start -> true)\n         \
    \               visitedList += start\n                    } else if (visitedList.contains(start)\
    \ && visitedList.contains(end) && visitedList.toSet == visitedMap.toSet && visitedList.last\
    \ == end && visitedList.last != start) {\n                        visitedMap +=\
    \ (start -> true)\n                        visitedList += end\n              \
    \      } else {\n                        visitedMap += (start -> true)\n     \
    \                   visitedList += end\n                    }\n              \
    \  }\n            }\n        }\n        visitedMap.values.toList.sortWith(_.compareTo(_)\
    \ > 0).flatten", "        val m = mutable.HashMap.empty[List[Long], Long]\n  \
    \      val lst_A = mutable.ArrayBuffer.empty[Long]\n        val lst_B = mutable.ArrayBuffer.empty[Long]\n\
    \        val lst_C = mutable.ArrayBuffer.empty[Long]\n        val lst_D = mutable.ArrayBuffer.empty[Long]\n\
    \        grid.foreach{ t =>\n            lst_A += t._1\n            lst_B += t._2\n\
    \            lst_C += t._3\n            lst_D += t._4\n        }\n        lst_A.sortWith(_\
    \ < _)\n        lst_B.sortWith(_ < _)\n        lst_C.sortWith(_ < _)\n       \
    \ lst_D.sortWith(_ < _)\n        if (lst_A.size == 0) List(1l.toLong)\n      \
    \  else if (lst_A.size == lst_B.size && lst_A.size == lst_C.size && lst_A.size\
    \ == lst_D.size) List(lst_A(0))\n        else if (lst_A.size > lst_B.size && lst_A.size\
    \ > lst_C.size && lst_A.size > lst_D.size) List(lst_A(lst_A.size - 1))\n     \
    \   else if (lst_B.size > lst_C.size && lst_B.size > lst_D.size && lst_B.size\
    \ > lst_A.size) List(lst_B(lst_B.size - 1))\n        else if (lst_C.size > lst_D.size\
    \ && lst_C.size > lst_A.size && lst_C.size > lst_B.size) List(lst_C(lst_C.size\
    \ - 1))\n        else if (lst_D.size > lst_A.size && lst_D.size > lst_B.size &&\
    \ lst_D.size > lst_C.size) List(lst_D(lst_D.size - 1))\n        else if (lst_A.size\
    \ > lst_B.size && lst_A.size > lst_C.size && lst_A.size > lst_D.size) List(lst_A(lst_A.size\
    \ - 1), lst_B(lst_B.size - 1))\n        else if (lst_B.size > lst_C.size && lst_B.size\
    \ > lst_D.size && lst_B.size > lst_A.size) List(lst_B(lst_B.size - 1), lst_C(lst_C.size\
    \ - 1))\n        else if (lst_C.size > lst_D.size && lst_C.size > lst_A.size &&\
    \ lst_C.size > lst_B.size) List(lst_C(lst_C.size - 1), lst_D(lst_D.size - 1))\n\
    \        else if (lst_D.size > lst_A.size && lst_D.size > lst_B.size && lst_D.size\
    \ > lst_C.size"]
stop_tokens:
- "\n    }\n"
