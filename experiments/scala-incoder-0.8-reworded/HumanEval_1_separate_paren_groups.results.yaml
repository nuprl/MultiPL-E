language: scala
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // We start by creating a stack whose\
    \ size is the number of groups in our string.\n        val paren_stack = new mutable.Stack[String]()\n\
    \n        // We start by pushing every element of our string into the stack one\
    \ at a time.\n        for (element <- paren_string.split(\"\")) {\n          \
    \  paren_stack +=+ element\n        }\n\n        // While the stack is not empty:\n\
    \        while (paren_stack.nonEmpty) {\n            // Pop an element off of\
    \ our stack\n            val popped = paren_stack.pop()\n\n            // If the\
    \ popped item equals \")\", then we know we are in a group, so we push a new group\
    \ to the stack\n            if (popped == \")\")\n                paren_stack\
    \ ++= \"(\"\n\n            // If the popped item equals \")\", then we know we\
    \ are in an open group, so we close the group and push a new group to the stack\n\
    \            if (popped == \"(\")\n                paren_stack ++= \"(\"\n\n \
    \           // If the popped item equals \")\", then we know we are in an open\
    \ group, so we close the group and push a new group to the stack\n           \
    \ if (popped == \")\")\n                paren_stack ++= \")\"\n        }\n   \
    \     // Once we leave the loop, we have our final list of groups\n        paren_stack.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps18x_8zz.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def balancedParens(paren_string) : List[String]\
    \ = {\n            var parens : List[String] = Nil\n            var open : List[String]\
    \ = Nil\n            var closed : List[String] = Nil\n            var temp : List[String]\
    \ = Nil\n            paren_string.split(\"\\\\s\").foreach { part =>\n       \
    \         if (part == \"(\") {\n                    if (parens.isEmpty) {\n  \
    \                      open ::= part\n                    } else {\n         \
    \               open ::= part\n                        closed = parens\n     \
    \                   parens = Nil\n                    }\n                } else\
    \ if (part == \")\") {\n                    if (closed == Nil) {\n           \
    \             if (parens.nonEmpty) {\n                            parens = parens\
    \ ::: Nil\n                        } else {\n                            parens\
    \ = closed\n                        }\n                    } else {\n        \
    \                closed = closed ::: part\n                    }\n           \
    \     } else if (part == \" \") {\n                    if (parens.nonEmpty) {\n\
    \                        parens = parens ::: Nil\n                    } else {\n\
    \                        parens = closed\n                    }\n            \
    \    }\n            }\n            if (parens.isEmpty) {\n                temp\
    \ = open\n            } else {\n                temp = open ::: parens\n     \
    \       }\n            temp\n        }\n        val groups = balancedParens(paren_string)\n\
    \        val result = groups.map(_.split(\"\").toList).filter(_.length == 1).flatMap(_.toList)\n\
    \        List(result.toList.mkString(\"\")) //.mkString(\"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcq0_02sl.scala:11:39 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mdef\e[0m \e[36mbalancedParens\e[0m(\e[36mparen_string\e\
    [0m) : \e[35mList\e[0m[\e[35mString\e[0m] = {\n\e[31m\e[31m   |\e[0m         \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                ':' expected, but ')' found\n1 error found\n"
  stdout: ''
  timestamp: 1660013493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val regex = \"\"\"[(]|\\\\(|\\\\[|\\\\\
    {|}\"|}]|\\\\)|\\\\]|\\\\}|[^\\\\(|\\\\[|\\\\{|\\\\]|\"|}]+\"\"\".r\n        var\
    \ output : Seq[String] = Seq.empty\n        var open_brace : Int = paren_string.indexOf('{')\n\
    \        var closed_brace : Int = paren_string.lastIndexOf('}')\n        var open_paren\
    \ : Int = paren_string.indexOf('(')\n        var close_paren : Int = paren_string.lastIndexOf(')')\n\
    \n        while ( open_brace != -1 && closed_brace != -1 ) {\n            if (open_brace\
    \ < closed_brace) {\n                val sub_string = paren_string.substring(open_brace,\
    \ closed_brace)\n                if (regex.findFirstIn(sub_string).isEmpty) throw\
    \ new Exception(\"Invalid input\")\n                output += sub_string\n   \
    \             open_brace = paren_string.indexOf('{', open_brace + 1)\n       \
    \         closed_brace = paren_string.lastIndexOf('}', closed_brace - 1)\n   \
    \         } else if (open_brace > closed_brace) {\n                val sub_string\
    \ = paren_string.substring(closed_brace, open_brace)\n                if (regex.findFirstIn(sub_string).isEmpty)\
    \ throw new Exception(\"Invalid input\")\n                output += sub_string\n\
    \                open_brace = paren_string.indexOf('{', closed_brace + 1)\n  \
    \              closed_brace = paren_string.lastIndexOf('}', open_brace - 1)\n\
    \            } else if (open_paren != -1 && close_paren != -1 ) {\n          \
    \      val sub_string = paren_string.substring(open_paren, close_paren)\n    \
    \            if (regex.findFirstIn(sub_string).isEmpty) throw new Exception(\"\
    Invalid input\")\n                output += sub_string\n                open_paren\
    \ = paren_string.indexOf('(', open_paren + 1)\n                close_paren = paren_string.lastIndexOf(')',\
    \ close_paren - 1)\n            } else {\n                val sub_string = paren_string.substring(open_paren,\
    \ close_paren)\n                if (regex.findFirstIn(sub_string).isEmpty) throw\
    \ new Exception(\"Invalid input\")\n                output += sub_string\n   \
    \             open_paren = paren_string.indexOf('(', open_paren + 1)\n       \
    \         close_paren = paren_string.lastIndexOf(')', open_paren - 1)\n      \
    \      }\n        }\n        return output.filterNot( _.isEmpty)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjk2esr59.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                output += sub_string\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of collection.mutable.Seq[String] - did you mean collection.mutable.Seq[String].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjk2esr59.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                output += sub_string\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of collection.mutable.Seq[String] - did you mean collection.mutable.Seq[String].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjk2esr59.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                output += sub_string\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of collection.mutable.Seq[String] - did you mean collection.mutable.Seq[String].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjk2esr59.scala:40:23 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                output += sub_string\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of collection.mutable.Seq[String] - did you mean collection.mutable.Seq[String].!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjk2esr59.scala:45:31 --------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mreturn\e[0m output.filterNot( _.isEmpty)\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m               Found:    scala.collection.mutable.Seq[String]\n\e[31m\
    \   |\e[0m               Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    (\").filter(x => x.endsWith(\")\")).distinct\n        val open_brace_groups =\
    \ paren_groups.filter(_.replace(\"(\", \"\").replace(\")\", \"\").length > 0).distinct\n\
    \n        open_brace_groups.filter(x => paren_groups.count(_.replace(x + \"(\"\
    , \"\").replace(x, \"\").replace(_ + \")\", \"\").replace(_ + \")\", \"\").length\
    \ > 0).distinct\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4jb91g0v.scala:15:4 ----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4jb91g0v.scala:14:95\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        open_brace_groups.filter(\e\
    [36mx\e[0m => paren_groups.count(_.replace(x + \e[31m\"(\"\e[0m, \e[31m\"\"\e\
    [0m).replace(x, \e[31m\"\"\e[0m).replace(_ + \e[31m\")\"\e[0m, \e[31m\"\"\e[0m).replace(_\
    \ + \e[31m\")\"\e[0m, \e[31m\"\"\e[0m).length > \e[31m0\e[0m).distinct\n\e[31m\e\
    [31m   |\e[0m                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mreplace\e[0m in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m   |\e\
    [0m (x$0: CharSequence, x$1: CharSequence): String\n\e[31m   |\e[0m (x$0: Char,\
    \ x$1: Char): String\n\e[31m   |\e[0mmatch arguments (<?> => <?>, (\e[32m\"\"\e\
    [0m : String))\n2 errors found\n"
  stdout: ''
  timestamp: 1660013495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list_to_return = Nil\n        var\
    \ current_string = \"\"\n        for(c <- paren_string) {\n            if(c ==\
    \ '(') {\n                current_string += c\n                list_to_return\
    \ = list_to_return :+ current_string\n                current_string = \"\"\n\
    \            } else if(c == ')') {\n                list_to_return = list_to_return\
    \ :+ current_string\n                current_string = \"\"\n            } else\
    \ {\n                current_string += c\n            }\n        }\n        if(current_string\
    \ != \"\") {\n            list_to_return = list_to_return :+ current_string\n\
    \        }\n        list_to_return.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuciifj0o.scala:16:33\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                list_to_return\
    \ = list_to_return :+ current_string\n\e[31m\e[31m   |\e[0m                  \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                    Found:    List[String]\n\e[31m   |\e[0m                 \
    \          Required: scala.collection.immutable.Nil.type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuciifj0o.scala:19:33 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                list_to_return = list_to_return :+ current_string\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    List[String]\n\e[31m\
    \   |\e[0m                           Required: scala.collection.immutable.Nil.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuciifj0o.scala:26:29\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            list_to_return =\
    \ list_to_return :+ current_string\n\e[31m\e[31m   |\e[0m                    \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \              Found:    List[String]\n\e[31m   |\e[0m                       \
    \    Required: scala.collection.immutable.Nil.type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def balanced : Boolean = { for( i <- 0\
    \ to paren_string.length - 1 ) if(paren_string(i) != paren_string(i+1)) break;\
    \ paren_string.length > 1 }\n        def open_braces : { (i: Int, j: Int) => Boolean\
    \ } = { (i, j) => ( paren_string(i) == paren_string(j) ) && (paren_string(i) !=\
    \ \" \") }\n        def close_braces : { (i: Int, j: Int) => Boolean } = { (i,\
    \ j) => ( paren_string(i) == paren_string(j) ) && (paren_string(i) == \" \") }\n\
    \        val paren_count = paren_string.length\n        if (paren_count == 0)\
    \ return Nil\n        val groups = mutable.ListBuffer.empty[String]\n        val\
    \ open_brace = mutable.ListBuffer.empty[Int]\n        val close_brace = mutable.ListBuffer.empty[Int]\n\
    \        for( i <- 0 to paren_count - 1 ) {\n            if(open_braces(i, i))\
    \ open_brace += i\n            if(close_braces(i, i)) close_brace += i\n     \
    \   }\n        if(open_brace.isEmpty) Nil\n        else {\n            for(i <-\
    \ 0 to open_brace.length - 1 ) {\n                if(!close_braces(open_brace(i),\
    \ open_brace(i+1))) {\n                    groups += paren_string.substring(open_brace(i),\
    \ open_brace(i+1))\n                    open_brace += i\n                    if(close_brace.isEmpty)\
    \ break\n                }\n            }\n        }\n        return groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E103] Syntax Error: /tmp/tmpzkoki_16.scala:12:28 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mdef\e[0m \e[36mopen_braces\e[0m : { (i:\
    \ Int, j: Int) => Boolean } = { (i, j) => ( paren_string(i) == paren_string(j)\
    \ ) && (paren_string(i) != \e[31m\" \"\e[0m) }\n\e[31m\e[31m   |\e[0m        \
    \                    ^\e[0m\n\e[31m   |\e[0mIllegal start of declaration (possible\
    \ cause: missing `=` in front of current method body)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzkoki_16.scala:11:117 -----------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mdef\e[0m \e[36mbalanced\e[0m : \e[35mBoolean\e\
    [0m = { \e[33mfor\e[0m( i <- \e[31m0\e[0m to paren_string.length - \e[31m1\e[0m\
    \ ) \e[33mif\e[0m(paren_string(i) != paren_string(i+\e[31m1\e[0m)) break; paren_string.length\
    \ > \e[31m1\e[0m }\n\e[31m\e[31m   |\e[0m                                    \
    \                                                                            \
    \     ^^^^^\e[0m\n\e[31m   |\e[0m                                            \
    \            Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E067] Syntax Error:\
    \ /tmp/tmpzkoki_16.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mdef\e[0m \e[36mopen_braces\e[0m : { (i: Int, j: Int) =>\
    \ Boolean } = { (i, j) => ( paren_string(i) == paren_string(j) ) && (paren_string(i)\
    \ != \e[31m\" \"\e[0m) }\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e\
    [0mDeclaration of \e[33mmethod\e[0m \e[35mopen_braces\e[0m not allowed here: only\
    \ classes can have declared but undefined members\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpzkoki_16.scala:12:43 --------------------\e[0m\e[0m\n\
    \e[31m12 |\e[0m        \e[33mdef\e[0m \e[36mopen_braces\e[0m : { (i: Int, j: Int)\
    \ => Boolean } = { (i, j) => ( paren_string(i) == paren_string(j) ) && (paren_string(i)\
    \ != \e[31m\" \"\e[0m) }\n\e[31m\e[31m   |\e[0m                              \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \   Found: "
  stdout: ''
  timestamp: 1660013497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateParenGroupsRecurse(s: String)\
    \ : List[String] = {\n            if (s.length() <= 0) Nil\n            else {\n\
    \                val open_brace = s.charAt(0)\n                if (open_brace\
    \ == ')') {\n                    val open_paren = s.charAt(1)\n              \
    \      if (open_paren == ')') {\n                        val open_paren_2 = s.charAt(2)\n\
    \                        if (open_paren_2 == ')') {\n                        \
    \    val open_paren_3 = s.charAt(3)\n                            if (open_paren_3\
    \ == ')')\n                                Nil\n                            else\n\
    \                                List(open_paren + open_paren_2 + open_paren_3)\n\
    \                        } else {\n                            val open_paren_4\
    \ = s.charAt(3)\n                            if (open_paren_4 == ')')\n      \
    \                          List(open_paren + open_paren_2)\n                 \
    \           else\n                                List(open_paren + open_paren_2\
    \ + open_paren_3 + open_paren_4)\n                        }\n                \
    \    } else {\n                        val open_paren_5 = s.charAt(2)\n      \
    \                  if (open_paren_5 == ')')\n                            List(open_paren\
    \ + open_paren)\n                        else\n                            List(open_paren\
    \ + open_paren_2 + open_paren_5)\n                    }\n                } else\
    \ {\n                    val open_paren_6 = s.charAt(1)\n                    if\
    \ (open_paren_6 == ')')\n                        List(open_paren + open_brace)\n\
    \                    else\n                        List(open_paren + open_brace\
    \ + open_paren_6)\n                }\n            }\n        }\n\n        val\
    \ parens = paren_string.splitToList\n        var list = parens.map(l => separateParenGroupsRecurse(l))\n\
    \        list = list.flatten.distinct\n        list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_rk0igaz.scala:24:65\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                            \
    \    List(open_paren + open_paren_2 + open_paren_3)\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    (open_paren_3\
    \ : Char)\n\e[31m   |\e[0m                                         Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_rk0igaz.scala:28:50\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                            \
    \    List(open_paren + open_paren_2)\n\e[31m\e[31m   |\e[0m                  \
    \                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                               Found:    (open_paren_2 : Char)\n\e[31m   |\e\
    [0m                                         Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_rk0igaz.scala:30:65 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                                List(open_paren + open_paren_2\
    \ + open_paren_3 + open_paren_4)\n\e[31m\e[31m   |\e[0m                      \
    \                                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                 Not found: open_paren_3\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_rk0igaz.scala:35:46\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                            List(open_paren\
    \ + open_paren)\n\e[31m\e[31m   |\e[0m                                       \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \      Found:    (open_paren : Char)\n\e[31m   |\e[0m                        \
    \                   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found "
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \\\\(\").filter(_.matches(\"^\\\\)\")).map(x => x.replaceAll(\"^\\\\)$\", \"\"\
    )).filter(x => !x.equals(\"()\"))\n        if (paren_groups.isEmpty) return List()\n\
    \        val depth = paren_groups.map(x => x.length).toList.max\n        val result\
    \ = new mutable.HashMap[String, mutable.ListBuffer[String]]()\n        for ((idx,\
    \ paren_group) <- paren_groups zip paren_groups.dropRight) {\n            var\
    \ current = mutable.ListBuffer[String]()\n            var opened_braces = 0 //\
    \ Number of open braces in group so far\n            for (character <- paren_group)\
    \ {\n                val closed = paren_group(opened_braces)\n               \
    \ val opened = paren_group(opened_braces + 1)\n                if (opened == \"\
    \") current += character // Open braces count as part of the brace\n         \
    \       else if (character == \"(\") opened_braces += 1\n                else\
    \ if (character == \")\") opened_braces -= 1\n                else if (character\
    \ == \" \") opened_braces = 0\n                else if (character == \")\" &&\
    \ opened_braces == 0) {\n                    val result = current.dropWhile(x\
    \ => !x.equals(\"(\")).toList\n                    if (!result.isEmpty) {\n  \
    \                      if (result.head == \"()\") result += \"()\"\n         \
    \               result.removeAt(0)\n                        result += \"(\" +\
    \ result.mkString(\",\") + \")\"\n                        result.add(\"()\")\n\
    \                    }\n                    current.clear()\n                \
    \    current.addAll(result)\n                }\n                else {\n     \
    \               current.addAll(character :: current)\n                }\n    \
    \        }\n            result += (paren_group(0) -> (mutable.ListBuffer[String]().addAll(current.toList)).toList)\n\
    \        }\n        result.values.map(_.flatMap(_.mkString(\",\")).distinct).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2k0vhj3f.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, mutable.ListBuffer[\e[35mString\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2k0vhj3f.scala:15:52 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mfor\e[0m ((idx, paren_group) <- paren_groups\
    \ zip paren_groups.dropRight) {\n\e[31m\e[31m   |\e[0m                       \
    \                             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                       Found:    Int => Array[String]\n\e[31m\
    \   |\e[0m                                          Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2k0vhj3f.scala:16:26\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mcurrent\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2k0vhj3f.scala:18:30 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m            \e[33mfor\e[0m (character <- paren_group) {\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                   value foreach is not a member of Any\n4 errors found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: Implement this function\n   \
    \     throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: Not yet implemented\n\tat Problem$.separateParenGroups(tmpr6zr820a.scala:12)\n\
    \tat Problem$.main(tmpr6zr820a.scala:15)\n\tat Problem.main(tmpr6zr820a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.trim.split('(').filter(_\
    \ != ')').filter(_ != '(').toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpw_602mwn.scala:11:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        paren_string.trim.split(\e[31m'('\e[0m).filter(_\
    \ != \e[31m')'\e[0m).filter(_ != \e[31m'('\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Values of types String and Char cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpw_602mwn.scala:11:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        paren_string.trim.split(\e[31m'('\e[0m).filter(_\
    \ != \e[31m')'\e[0m).filter(_ != \e[31m'('\e[0m).toList\n\e[31m\e[31m   |\e[0m\
    \                                                             ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Values of types String and Char cannot be compared with ==\
    \ or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create a stack\n        val opening_parens\
    \ = Stack[String]()\n        // Initialize output array\n        var output_array\
    \ = List[String]()\n        // Iterate through each char in the paren_string\n\
    \        for(chr <- paren_string)\n            // if the current char is a (\n\
    \            if(chr == '(') opening_parens.push(chr)\n            // if the current\
    \ char is a )\n            if(chr == ')'){\n                // Get the opening\
    \ brace char\n                val opening_paren = opening_parens.pop()\n     \
    \           // If the opening brace is still an opening brace and the current\
    \ closing brace is a closing brace\n                // then add the opening brace\
    \ to the output array followed by the closing brace\n                if(opening_paren\
    \ == '(' && chr == ')') output_array :+ opening_paren :+ chr\n               \
    \ // If the opening brace is still a closing brace and the current closing brace\
    \ is a closing brace\n                // then remove the opening brace from the\
    \ output array followed by the closing brace\n                if(opening_paren\
    \ == '(' && chr == ')') output_array :- opening_paren :+ chr\n            }\n\
    \        // Convert the array to a list\n        output_array.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps8ciob0x.scala:18:47\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m(chr\
    \ == \e[31m'('\e[0m) opening_parens.push(chr)\n\e[31m\e[31m   |\e[0m         \
    \                                      ^^^\e[0m\n\e[31m   |\e[0m             \
    \                                  Found:    (chr : Char)\n\e[31m   |\e[0m   \
    \                                            Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmps8ciob0x.scala:25:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m(opening_paren == \e[31m'('\e\
    [0m && chr == \e[31m')'\e[0m) output_array :+ opening_paren :+ chr\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Values of types String and Char cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmps8ciob0x.scala:28:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m(opening_paren == \e[31m'('\e\
    [0m && chr == \e[31m')'\e[0m) output_array :- opening_paren :+ chr\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Values of types String and Char cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmps8ciob0x.scala:28:68 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m(opening_paren == \e[31m'('\e\
    [0m && chr == \e[31m')'\e[0m) output_array :- opening_paren :+ chr\n\e[31m\e[31m\
    \   |\e[0m                                                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue :- is not a member of List[String] - did you mean List[String].:+?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\\\\(\").map(x =>\
    \ {\n            val paren_count = paren_string.split(x).length - 1\n        \
    \    paren_string.split(x)(paren_count.toInt)\n        }).filter(_ => !_.getOrElse(\"\
    \").equals(\"\")).map(x => x.get(0))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpn6eamqyw.scala:14:24 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        }).filter(_ => !_.getOrElse(\e[31m\"\"\e[0m).equals(\e\
    [31m\"\"\e[0m)).map(x => x.get(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m         \
    \               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => ! _$2.getOrElse(\e[32m\"\"\e[0m).equals(\e\
    [32m\"\"\e[0m).\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn6eamqyw.scala:14:63\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        }).filter(_ => !_.getOrElse(\e\
    [31m\"\"\e[0m).equals(\e[31m\"\"\e[0m)).map(x => x.get(\e[31m0\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value get is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpn6eamqyw.scala:14:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        }).filter(_ => !_.getOrElse(\e[31m\"\"\e[0m).equals(\e\
    [31m\"\"\e[0m)).map(x => x.get(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m         \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                          No ClassTag available for B\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m                                          where:\
    \    B is a type variable\n3 errors found\n"
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\"\"\\s+\"\"\")\n\
    \            .map(_.split(\"\\\\(\")\n                .map(_.trim())\n       \
    \         .toList\n                .filter(_.nonEmpty)\n                .map(p\
    \ => p.replace(\" \", \"\"))\n                .toList)\n            .flatMap(_.groupBy(_.nonEmpty))\n\
    \            .toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaqlkqe5n.scala:19:13\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.split(\e\
    [31m\"\"\"\\s+\"\"\"\e[0m)\n\e[31m12 |\e[0m            .map(_.split(\e[31m\"\\\
    \\(\"\e[0m)\n\e[31m13 |\e[0m                .map(_.trim())\n\e[31m14 |\e[0m  \
    \              .toList\n\e[31m15 |\e[0m                .filter(_.nonEmpty)\n\e\
    [31m16 |\e[0m                .map(\e[36mp\e[0m => p.replace(\e[31m\" \"\e[0m,\
    \ \e[31m\"\"\e[0m))\n\e[31m17 |\e[0m                .toList)\n\e[31m18 |\e[0m\
    \            .flatMap(_.groupBy(_.nonEmpty))\n\e[31m19 |\e[0m            .toList\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e\
    [1m\e[31m(\e[0m\e[1m\e[31mBoolean\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\e[1m\e[31m)\e[0m]\n\e[31m\
    \   |\e[0m        Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list_of_strings: List[String] = List()\n\
    \        var open_braces : Int = 0\n\n        for (c <- paren_string) {\n    \
    \        if (c == '(') {\n                open_braces += 1\n            } else\
    \ if (c == '{') {\n                open_braces += 2\n            } else if (c\
    \ == '}') {\n                open_braces -= 1\n            }\n            if (open_braces\
    \ == 0) {\n                list_of_strings += c\n            }\n        }\n  \
    \      list_of_strings\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc64ljm40.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                list_of_strings += c\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[String] - did you mean List[String].!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\"\"\\W+\"\"\")\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptq6lw2h9.scala:11:26\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.split(\e\
    [31m\"\"\"\\W+\"\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m  \
    \ |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val list = paren_string.split(' ');\n\
    \        val balanced = new mutable.ArrayBuffer(list.size)\n        list.foreach(l\
    \ => {\n            val tokens = l.split('(');\n            if (tokens.size ==\
    \ 0) return;\n            var open_count : Int = 0\n            tokens.foreach(t\
    \ => {\n                if (open_count > 0) {\n                    balanced(open_count)\
    \ += t\n                    open_count += 1;\n                }\n            \
    \    else {\n                    balanced.prepend(t)\n                }\n    \
    \        })\n        })\n        val groups = new mutable.ArrayBuffer(list.size)\n\
    \        balanced.foreach((open, close) => {\n            if (open != close) {\n\
    \                groups.prepend(list)\n                list = null\n         \
    \   }\n        })\n        groups.map(_.reverse.toList).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2l9bej2d.scala:12:27 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbalanced\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(list.size)\n\e[31m\e[31m   |\e[0m                    \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2l9bej2d.scala:15:34\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (tokens.size\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m;\n\e[31m\e[31m   |\e[0m                 \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \   Found:    Unit\n\e[31m   |\e[0m                                  Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2l9bej2d.scala:27:25\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mgroups\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer(list.size)\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = Nil\n        var open_paren\
    \ = 0\n        var closed_paren = 0\n        var open_brace = 0\n        var closed_brace\
    \ = 0\n        var brace_count = 0\n\n        // for each char in the string,\
    \ add it to result if the char is a valid open paren or brace or close paren\n\
    \        paren_string.foreach {\n            case ' ' => ()\n            case\
    \ c: Character if open_brace == 0 && closed_brace == 0 && open_brace < closed_paren\
    \ && c != ')' && c != '(' =>\n                if (c == ')') {\n              \
    \      result ::= paren_string.drop(open_brace)\n                    open_brace\
    \ = closed_paren\n                    closed_paren = 0\n                }\n  \
    \              result ::= c\n            case c: Character if open_brace > 0 &&\
    \ closed_brace == 0 && open_brace < closed_paren && c != ')' && c != '(' =>\n\
    \                if (c == '(') {\n                    result ::= paren_string.drop(open_brace)\n\
    \                    open_brace = 0\n                    closed_paren = closed_brace\n\
    \                    closed_brace = 0\n                }\n                result\
    \ ::= c\n            case c: Character if open_brace > 0 && closed_brace > 0 &&\
    \ open_brace < closed_paren && c != ')' && c != '(' =>\n                if (c\
    \ == ')' && closed_brace > open_brace) {\n                    result ::= paren_string.drop(open_brace)\n\
    \                    open_brace = closed_paren\n                    closed_paren\
    \ = 0\n                    closed_brace -= 1\n                }\n            \
    \    result ::= c\n            case c: Character if open_brace == 0 && closed_brace\
    \ > 0 && open_brace < closed_paren && c != ')' && c != '(' =>\n              \
    \  if (c == ')' && closed_brace > open_brace) {\n                    result ::=\
    \ paren_string.drop(open_brace)\n                    open_brace = 0\n        \
    \            closed_paren = closed_brace\n                    closed_brace = 0\n\
    \                    closed_brace -= 1\n                }\n                result\
    \ ::= c\n            case c: Character if open_brace == 0 && closed_brace == 0\
    \ && open_brace < closed_paren && c != ')' && c != '(' =>\n                if\
    \ (c == '(') {\n                    result ::= paren_string.drop(open_brace)\n\
    \                    open_brace = 0\n                    closed_paren = closed_brace\n\
    \                    closed_brace = 0\n                }\n                result\
    \ ::= c\n            case c: Character if open_bra\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpme7gvpwu.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpme7gvpwu.scala:71:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpme7gvpwu.scala:23:27 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m                    result ::= paren_string.drop(open_brace)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::=\
    \ is not a member of object scala.collection.immutable.Nil - did you mean Nil.::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpme7gvpwu.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                result ::= c\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not a member of object\
    \ scala.collection.immutable.Nil - did you mean Nil.::?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpme7gvpwu.scala:30:27 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m                    result ::= paren_string.drop(open_brace)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ ::= is not a member of object scala.collection.immutable.Nil - did you mean\
    \ Nil.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpme7gvpwu.scala:35:23\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                result ::=\
    \ c\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ ::= is not a member of object scala.collection.immutable.Nil - did you mean\
    \ Nil.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpme7gvpwu.scala:38:27\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    result\
    \ ::= paren_string.drop(open_brace)\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not a member of object scala.collection.immutable.Nil\
    \ - did you mean Nil.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpme7gvpwu.scala:43:23\
    \ ------------------------\e[0m\e[0m\n\e[31m4"
  stdout: ''
  timestamp: 1660013500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateParenGroups(input : String,\n\
    \                               paren_count : Int,\n                         \
    \      current_depth : Int,\n                               current_string : List[String],\n\
    \                               parens : List[Int]): List[String] = {\n      \
    \      if (paren_count == 0) current_string ::: parens\n            else { \n\
    \                val open_brace =\n                    if (paren_count > current_depth)\
    \ {\n                        paren_count - current_depth\n                   \
    \ } else {\n                        0\n                    }\n               \
    \ val close_brace = open_brace - current_depth\n                if (paren_count\
    \ == current_depth) {\n                    val open = paren_count + current_depth\n\
    \                    val close = open_brace\n                    current_string\
    \ ::: parens.take(close) ::: parens.drop(open)\n                } else {\n   \
    \                 val open = paren_count + current_depth\n                   \
    \ val close = open_brace\n                    if (parens[(open + close)] == (paren_count\
    \ + current_depth)) {\n                        val open_ = open + 1\n        \
    \                val close_ = close\n                        separateParenGroups(input,\
    \ open_, close + 1, current_string ::: parens.take(close) ::: parens.drop(open_),\
    \ parens.drop(open_))\n                    } else {\n                        separateParenGroups(input,\
    \ open, close + 1, current_string ::: parens.take(close) ::: parens.take(open_),\
    \ parens.drop(open_))\n                    }\n                }\n            }\n\
    \        }\n        val result = new mutable.ArrayBuffer[String]\n        val\
    \ paren_groups = paren_string.flatMap(x => x.toList)\n        val open_brace_count\
    \ = paren_groups.flatMap(x => x.countBy(x => x == ('('))).sum\n        val close_brace_count\
    \ = paren_groups.flatMap(x => x.countBy(x => x == (')'))).sum\n        for (i\
    \ <- 0 until open_brace_count) {\n            result.add(\"(\" + paren_groups.take(i).mkString(\"\
    (\", \", \", \")\"))\n        }\n        for (j <- 0 until close_brace_count)\
    \ {\n            result.add(\")\" + paren_groups.drop(j).mkString(\"(\", \", \"\
    , \")\"))\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8_m514uk.scala:16:34\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (paren_count\
    \ == \e[31m0\e[0m) current_string ::: parens\n\e[31m\e[31m   |\e[0m          \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                             Found:    List[Matchable]\n\e[31m   |\e[0m     \
    \                             Required: List[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8_m514uk.scala:28:20 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    current_string ::: parens.take(close)\
    \ ::: parens.drop(open)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    List[Matchable]\n\e[31m   |\e\
    [0m                    Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8_m514uk.scala:32:37 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mif\e[0m (parens[(\e[35mopen\e\
    [0m \e[35m+\e[0m \e[35mclose\e[0m)] == (paren_count + current_depth)) {\n\e[31m\e\
    [31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m    \
    \                                 Not found: type +\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8_m514uk.scala:35:69 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        separateParenGroups(input, open_,\
    \ close + \e[31m1\e[0m, current_string ::: parens.take(close) ::: parens.drop(open_),\
    \ parens.drop(open_))\n\e[31m\e[31m   |\e[0m                                 \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Found:    List[Matchable]\n\
    \e[31m   |\e[0m                                               Required: List[String]\n\
    \e[31m  "
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.grouped(5).map(parens =>\
    \ parens.foldLeft(List.empty[String]){\n            (x, y) => y match {\n    \
    \            case (\")\") => x :+ y\n                case (\"(\") => x :+ y\n\
    \                case _ => x :+ y\n            }\n        }.toList).distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjnmmjk9s.scala:13:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mcase\e[0m (\e[31m\")\"\e[0m) =>\
    \ x :+ y\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjnmmjk9s.scala:13:35 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mcase\e[0m (\e[31m\")\"\e[0m) =>\
    \ x :+ y\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   Found:    (y : Char)\n\e[31m   |\e\
    [0m                                   Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpjnmmjk9s.scala:14:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mcase\e[0m (\e[31m\"(\"\e[0m) =>\
    \ x :+ y\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjnmmjk9s.scala:14:35 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mcase\e[0m (\e[31m\"(\"\e[0m) =>\
    \ x :+ y\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   Found:    (y : Char)\n\e[31m   |\e\
    [0m                                   Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjnmmjk9s.scala:15:31 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                \e[33mcase\e[0m _ => x :+ y\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     Found:    (y : Char)\n\e[31m   |\e[0m                  \
    \             Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val inputStringList = paren_string.trim().split(\"\
    \\\\s+\").map(_.trim())\n\n        // Create a stack to store the string currently\
    \ being processed. Since the stack acts as a LIFO queue, we store strings popped\
    \ from the top of the stack onto the head of the stack.\n        var parenStringStack:\
    \ List[String] = Nil\n        var index = 0\n\n        // Iterate over the string\
    \ and push all the parenthesis strings to the stack\n        for (nextString <-\
    \ inputStringList) {\n            if (nextString.startsWith(\"(\")) {\n      \
    \          parenStringStack += nextString\n            } else {\n            \
    \    if (nextString.startsWith(\")\")) {\n                    val parenthesisString\
    \ = parenStringStack.takeWhile(_.startsWith(\"(\"))\n                    parenStringStack\
    \ = parenStringStack.drop(parenthesisString.length)\n                    parenStringStack\
    \ += nextString\n                }\n            }\n        }\n\n        // Return\
    \ the stack contents\n        parenStringStack.mkString(\"(\", \",\", \")\")\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7ujsz5dh.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                parenStringStack += nextString\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue +=\
    \ is not a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7ujsz5dh.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    parenStringStack += nextString\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ujsz5dh.scala:31:33 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        parenStringStack.mkString(\e[31m\"(\"\e[0m, \e\
    [31m\",\"\e[0m, \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    String\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    (?<=\\\\)))(?=\\\\()\").filterNot(_.isEmpty)\n        val paren_groups_with_outside_parens\
    \ = paren_groups\n            .map(x => paren_groups.filterNot(y => x == y))\n\
    \            .filter(_ => _.nonEmpty)\n        paren_groups_with_outside_parens.map(x\
    \ => paren_groups_with_outside_parens.filterNot(y => x == y))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp8m0h35xv.scala:14:25 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            .filter(_ => _.nonEmpty)\n\e[31m\e[31m  \
    \ |\e[0m                         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => _$3.nonEmpty.\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8m0h35xv.scala:15:8 ---------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        paren_groups_with_outside_parens.map(\e[36mx\e\
    [0m => paren_groups_with_outside_parens.filterNot(\e[36my\e[0m => x == y))\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Array[Array[String]]]\n\e[31m   |\e\
    [0m        Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def helper(paren_strings: List[String],\
    \ group: List[String], paren_count: Int) : List[String] = {\n            // If\
    \ all parens are closed, we have a string where all parens are grouped together\
    \ and return it\n            if (paren_count == 0) {\n                group\n\
    \            }\n            // If one open paren is closed, we have an extra open\
    \ paren and return that\n            else if (paren_count == 1) {\n          \
    \      group += \"(\"\n            }\n            // If there are multiple open\
    \ parens, we must keep adding them until they are balanced\n            else if\
    \ (paren_count > 1) {\n                group += \"(\"\n                group +=\
    \ paren_strings.takeWhile(_.length != paren_count)\n                group += \"\
    )\"\n                val newGroup = paren_strings.dropWhile(_.length != paren_count)\n\
    \                newGroup match {\n                    case List() => helper(paren_strings,\
    \ group, paren_count)\n                    case _ => helper(newGroup, group, paren_count\
    \ - 1)\n                }\n            }\n        }\n        helper(paren_string.split(\"\
    \\\\W+\"), List.empty, paren_string.split(\"\\\\W+\").length)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1xtyfhz.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                group += \e[31m\"(\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is not\
    \ a member of List[String] - did you mean group.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmph1xtyfhz.scala:22:22 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m                group += \e[31m\"(\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is not a member\
    \ of List[String] - did you mean group.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmph1xtyfhz.scala:23:22 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m                group += paren_strings.takeWhile(_.length != paren_count)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value\
    \ += is not a member of List[String] - did you mean group.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmph1xtyfhz.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                group += \e[31m\")\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is not\
    \ a member of List[String] - did you mean group.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmph1xtyfhz.scala:32:33 --------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m        helper(paren_string.split(\e[31m\"\\\\W+\"\e[0m), List.empty,\
    \ paren_string.split(\e[31m\"\\\\W+\"\e[0m).length)\n\e[31m\e[31m   |\e[0m   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    \e[1m\e[31mArray\e[0m[String]\n\e[31m   |\e[0m               Required: \e\
    [1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def unbalancedParensChecker(string: String)\
    \ : Boolean = {\n            val openParen = string.indexWhere(c => c == \"(\"\
    )\n            val closeParen = string.indexWhere(c => c == \")\")\n         \
    \   if (openParen < 0) return false\n            if (closeParen == string.length)\
    \ return false\n            if (closeParen > openParen) unbalancedParensChecker(string.substring(openParen\
    \ + 1, closeParen))\n            else unbalancedParensChecker(string.substring(openParen\
    \ + 1, closeParen - 1))\n        }\n        val stringList = ListBuffer[String]()\n\
    \        stringList.append (\"(\")\n        stringList.append (paren_string)\n\
    \        stringList.append (\")\")\n        var outputString = stringList.mkString\n\
    \        while (true) {\n            if (unbalancedParensChecker(outputString))\
    \ throw new Exception(\"Unbalanced parens found: \" + outputString)\n        \
    \    val open = outputString.indexWhere(c => c == \"(\")\n            val close\
    \ = outputString.indexWhere(c => c == \")\")\n            if (open < 0 || close\
    \ < 0) return outputString.drop(1).dropRight(1)\n            outputString = outputString.substring(open\
    \ + 1, close + 1)\n            stringList.append (outputString)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps_cfca85.scala:12:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mopenParen\e[0m = string.indexWhere(\e\
    [36mc\e[0m => c == \e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmps_cfca85.scala:13:52 -----------------------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mcloseParen\e[0m = string.indexWhere(\e\
    [36mc\e[0m => c == \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmps_cfca85.scala:26:52 -----------------------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mopen\e[0m = outputString.indexWhere(\e\
    [36mc\e[0m => c == \e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmps_cfca85.scala:27:53 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mclose\e[0m = outputString.indexWhere(\e\
    [36mc\e[0m => c == \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmps_cfca85.scala:28:76 --------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (open < \e[31m0\e[0m || close <\
    \ \e[31m0\e[0m) \e[33mreturn\e[0m outputString.drop(\e[31m1\e[0m).dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                            Found:    String\n\e[31m   |\e[0m               \
    \                               Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e\
    ["
  stdout: ''
  timestamp: 1660013499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = new Stack[String]()\n    \
    \    val result = new mutable.ListBuffer[String]()\n        val open_braces =\
    \ paren_string.filter(x => x == '{')\n        val close_braces = paren_string.filter(x\
    \ => x == '}')\n        val open_parentheses = paren_string.filter(x => x == '(')\n\
    \        val close_parentheses = paren_string.filter(x => x == ')')\n\n      \
    \  open_braces.foreach(x => {\n            stack.push(x)\n        })\n\n     \
    \   close_braces.foreach(x => {\n            if (stack.isEmpty) {\n          \
    \      result += x\n            } else {\n                stack.pop\n        \
    \    }\n        })\n\n        open_parentheses.foreach(x => {\n            stack.push(x)\n\
    \        })\n\n        close_parentheses.foreach(x => {\n            if (stack.isEmpty)\
    \ {\n                result += x\n            } else {\n                stack.pop\n\
    \            }\n        })\n\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp9vi21du.scala:12:25 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp9vi21du.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            stack.push(x)\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m            \
    \           Found:    (x : Char)\n\e[31m   |\e[0m                       Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp9vi21du.scala:31:23\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            stack.push(x)\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m            \
    \           Found:    (x : Char)\n\e[31m   |\e[0m                       Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013507
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_count = paren_string.groupCount\n\
    \        var paren_stack = new mutable.Stack[String]()\n        var paren_open\
    \ = paren_stack.empty\n        for (i <- 0 until paren_count) {\n            val\
    \ char = paren_string(i)\n            if (char == '(') {\n                paren_open\
    \ += true\n                paren_stack.push(char)\n            } else if (char\
    \ == ')') {\n                paren_open += false\n                if (paren_open)\
    \ {\n                    val last_char = paren_stack.last\n                  \
    \  val last_count = paren_stack.last.length\n                    val count = paren_stack.size\n\
    \                    if (last_count > count) {\n                        paren_stack.pop()\n\
    \                    } else if (last_count == count && last_char != '(') {\n \
    \                       paren_stack.pop()\n                    } else {\n    \
    \                    paren_stack.pop()\n                    }\n              \
    \  }\n            } else {\n                paren_stack.pop()\n            }\n\
    \        }\n        paren_stack.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwfqglexw.scala:11:39 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_count\e[0m = paren_string.groupCount\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value groupCount is not a member of String\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwfqglexw.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mparen_stack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013506
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\\\\(\")\n      \
    \      .map { inner =>\n                // If no inner parens are found, return\
    \ the outer paren group\n                if (inner.isEmpty) {\n              \
    \      paren_string\n                } else {\n                    // Otherwise,\
    \ get the next open paren, add it to the outer paren group\n                 \
    \   val next_open = inner.indexOf(\"\\\\(\")\n                    if (next_open\
    \ == -1) {\n                        inner.trim match {\n                     \
    \       case \"\\\\)\" => inner.substring(0, next_open)\n                    \
    \        case _ => inner\n                        }\n                    } else\
    \ {\n                        inner.substring(0, next_open)\n                 \
    \   }\n                }\n            }\n            .filterNot { inner =>\n \
    \               // Ignore the inner parens within each other and any spaces outside\
    \ of them\n                !inner.contains(\"\\\\(|\\\\)\")\n                \
    \    && !inner.isEmpty\n                    && !inner.contains(\" \")\n      \
    \      }\n            .toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_weybv_u.scala:38)\n\tat Problem.main(tmp_weybv_u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Iterate over all the parens\n     \
    \   var parens: List[String] = Nil\n        var paren_depth = 0\n        for (c\
    \ <- paren_string) {\n            // If the character is a paren increase the\
    \ depth\n            if (c == '(') {\n                paren_depth += 1\n     \
    \       } else if (c == ')') {\n                // If depth is zero then add paren\
    \ to list\n                if (paren_depth == 0) {\n                    parens\
    \ = parens :+ c\n                } else {\n                    // If depth not\
    \ zero then decrease depth\n                    paren_depth -= 1\n           \
    \     }\n            }\n        }\n        // If depth is zero then add paren\
    \ to list\n        if (paren_depth == 0) {\n            parens = parens :+ paren_string\n\
    \        } else {\n            // If depth not zero then decrease depth\n    \
    \        paren_depth -= 1\n        }\n        // Return the list of parens\n \
    \       return parens\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3gmpylbz.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    parens =\
    \ parens :+ c\n\e[31m\e[31m   |\e[0m                                       ^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    (c : Char)\n\
    \e[31m   |\e[0m                                       Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val groups = mutable.Set[String]()\n \
    \       val parens = mutable.Set[String]()\n        var open_brace_count = 0\n\
    \        val len = paren_string.length\n        val i = 1\n        while (i +\
    \ 2 < len) {\n            if (paren_string(i) == '(') {\n                if (paren_string(i\
    \ + 1) == '(') {\n                    open_brace_count += 1\n                }\
    \ else if (paren_string(i + 1) == ')') {\n                    if (open_brace_count\
    \ == 1) {\n                        open_brace_count = 0\n                    \
    \    parens += paren_string(i)\n                    } else {\n               \
    \         open_brace_count -= 1\n                    }\n                } else\
    \ {\n                    open_brace_count = 0\n                    parens += paren_string(i)\n\
    \                }\n            }\n            i += 2\n        }\n\n        val\
    \ closed_paren_count = parens.size - open_brace_count\n        if (closed_paren_count\
    \ > 0) {\n            val new_paren_string = parens.toSeq.toList.mkString\n  \
    \          groups += new_paren_string\n            separateParenGroups(new_paren_string)\n\
    \        }\n        if (closed_paren_count == 0) {\n            groups.toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4l9zcnk6.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mgroups\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4l9zcnk6.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4l9zcnk6.scala:32:14 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            i += \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean i.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l9zcnk6.scala:41:8\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mif\e[0m (closed_paren_count\
    \ == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    Unit\n\e[31m   |\e[0m        Required: List[String]\n\e[31m  \
    \ |\e[0m        Maybe you are missing an else part for the conditional?\n\e[31m42\
    \ |\e[0m            groups.toList\n\e[31m43 |\e[0m        }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013509
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list_groups : List[String] = Nil\n\
    \        var last_paren_char : Char = ' ' // initialize last paren character to\
    \ be a space\n        var paren_count : Int = 1 // initialize paren count\n  \
    \      var paren_string : List[String] = Nil\n        for(i <- 0 until paren_string.length)\
    \ {\n            paren_count match {\n                case 0 => last_paren_char\
    \ match {\n                    case ' ' =>\n                        list_groups\
    \ = paren_string.filterNot(_.isEmpty)\n                        paren_count match\
    \ {\n                            case 0 => Nil\n                            case\
    \ _ => Nil\n                        }\n                        paren_string =\
    \ Nil\n                    case ')' =>\n                        list_groups =\
    \ paren_string.filterNot(_.isEmpty)\n                        paren_count match\
    \ {\n                            case 0 => Nil\n                            case\
    \ _ => Nil\n                        }\n                        paren_string =\
    \ Nil\n                }\n                case 1 => paren_string.filterNot(_.isEmpty)\n\
    \                case _ => paren_string.filterNot(_.isEmpty)\n            }\n\
    \        }\n        return list_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgje5p_1r.scala:40)\n\tat Problem.main(tmpgje5p_1r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups : Set[String] = paren_string.split(\"\
    \\\\(\").map(_.trim).filter(_.nonEmpty)\n        val open_paren = paren_groups.filter(_\
    \ == \"(\" || _ == \"[\")\n        val close_paren = paren_groups.filter(_ ==\
    \ \")\" || _ == \"]\")\n        val open_paran = open_paren.foldLeft(mutable.Set[String]())\
    \ { (acc, cur) =>\n            if (acc contains cur) {\n                acc\n\
    \            } else {\n                acc ++ cur\n            }\n        }\n\
    \        val close_paran = close_paren.foldLeft(mutable.Set[String]()) { (acc,\
    \ cur) =>\n            if (acc contains cur) {\n                acc\n        \
    \    } else {\n                acc ++ cur\n            }\n        }\n        val\
    \ all_paran = open_paran.union(close_paran)\n        all_paran.filter(!_.startsWith(\"\
    (\") && !_.startsWith(\"[\")) // Remove nested parenthesis\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprny3yt3w.scala:11:85\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e\
    [0m : \e[35mSet\e[0m[\e[35mString\e[0m] = paren_string.split(\e[31m\"\\\\(\"\e\
    [0m).map(_.trim).filter(_.nonEmpty)\n\e[31m\e[31m   |\e[0m                   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Array[String]\n\e\
    [31m   |\e[0m                                Required: collection.mutable.Set[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprny3yt3w.scala:12:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopen_paren\e[0m = paren_groups.filter(_ == \e[31m\"(\"\e[0m || _ == \e\
    [31m\"[\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \     Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmprny3yt3w.scala:13:46 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mclose_paren\e[0m = paren_groups.filter(_\
    \ == \e[31m\")\"\e[0m || _ == \e[31m\"]\"\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Wrong number of parameters, expected: 1\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmprny3yt3w.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mopen_paran\e[0m = open_paren.foldLeft(mutable.Set[\e\
    [35mString\e[0m]()) { (\e[36macc\e[0m, \e[36mcur\e[0m) =>\n\e[31m\e[31m   |\e\
    [0m                                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                             Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprny3yt3w.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (acc contains cur) {\n\e[31m\e\
    [31m  "
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Find all the matches of \"(\" and \"\
    )\" \n        val open_paren = paren_string.r.findAllIn(\"()\").toList\n     \
    \   val close_paren = paren_string.r.findAllIn(\")\").toList\n\n        // For\
    \ each open paren, find its index in the string\n        val open_p_index  = open_paren.zipWithIndex.collect\
    \ { case (open_paren, i) => i }\n\n        // For each close paren, find its index\
    \ in the string\n        val close_p_index = close_paren.zipWithIndex.collect\
    \ { case (close_paren, i) => i }\n\n        // For each pair of indexes, see if\
    \ they are adjacent and add them to the list if they are adjacent\n        (open_paren.zip(open_paren.tail)\
    \ ::\n            close_p_index.zip(close_p_index.tail) ::\n            close_p_index.zip(close_p_index.tail)\
    \ ::\n            close_p_index.zip(close_p_index.tail) ::\n            open_paren.zip(open_paren.tail))\n\
    \            .filterNot(_._1 == _._2)\n            .flatMap(x => List(x, x._1\
    \ - 1))\n            .drop(x._1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp0sls8frd.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            .filterNot(_._1 == _._2)\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp0sls8frd.scala:28:36 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            .flatMap(x => List(x, x._1 - \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                         value _1 is not a member of Object & Equals\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0sls8frd.scala:29:18 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            .drop(x._1)\n\e[31m\e[31m   |\e[0m      \
    \            ^\e[0m\n\e[31m   |\e[0m                  Not found: x\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_list: List[String] = new ListBuffer[String]()\n\
    \        val open_braces_count: Int = 0\n        val nested_parentheses_count:\
    \ Int = 0\n\n        // iterate through each character in the input string one\
    \ at a time\n        for (i <- 1 to paren_string.length) {\n            val c\
    \ = paren_string(i)\n\n            // a character is a new group of parentheses\
    \ encountered\n            if (c == '(') {\n                paren_list += c\n\
    \                open_braces_count += 1\n                nested_parentheses_count\
    \ += 1\n            }\n            // a closing parenthesis is encountered\n \
    \           else if (c == '(') {\n                if (nested_parentheses_count\
    \ == open_braces_count) {\n                    paren_list += c\n             \
    \       open_braces_count -= 1\n                }\n                nested_parentheses_count\
    \ += 1\n            }\n            // an opening parenthesis is encountered\n\
    \            else if (c == ')') {\n                if (nested_parentheses_count\
    \ < open_braces_count) {\n                    paren_list += c\n              \
    \      open_braces_count -= 1\n                }\n                nested_parentheses_count\
    \ += 1\n            }\n            // any other character is ignored and placed\
    \ into the paren_list variable\n            else {\n                paren_list\
    \ += c\n            }\n        }\n        // return the paren_list\n        paren_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsd2vytyr.scala:11:39\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                                    \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:  \
    \  scala.collection.mutable.ListBuffer[String]\n\e[31m   |\e[0m              \
    \     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsd2vytyr.scala:21:27 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m                paren_list += c\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value += is not a member of List[String] - did you mean\
    \ paren_list.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsd2vytyr.scala:22:34\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                open_braces_count\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value += is not a member of Int - did you mean open_braces_count.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsd2vytyr.scala:23:41 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                nested_parentheses_count += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue += is not a member of Int - did you mean nested_parentheses_count.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsd2vytyr.scala:28:31 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    paren_list += c\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value += is not a\
    \ member of List[String] - did you mean paren_list.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsd2vytyr.scala:29:38 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                    open_braces_count -= \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value -= is not a member of Int - did you mean open"
  stdout: ''
  timestamp: 1660013513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def isClosingParenGroup(brace_level :\
    \ Int) : Boolean = brace_level > 0 && paren_string match {\n            case \"\
    \" => true\n            case _ if paren_string contains (\")\")\n            \
    \    || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5lqt4046.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5lqt4046.scala:76:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5lqt4046.scala:11:82 --------------------\e[0m\e[0m\n\
    \e[31m11 |\e[0m        \e[33mdef\e[0m \e[36misClosingParenGroup\e[0m(\e[36mbrace_level\e\
    [0m : \e[35mInt\e[0m) : \e[35mBoolean\e[0m = brace_level > \e[31m0\e[0m && paren_string\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \                                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                       Found:    (paren_string : String)\n\e\
    [31m   |\e[0m                                       Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5lqt4046.scala:12:17 --------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mcase\e[0m \e[31m\"\"\e[0m => \e[31mtrue\e\
    [0m\n\e[31m\e[31m   |\e[0m                 ^^\e[0m\n\e[31m   |\e[0m          \
    \       Found:    (\e[32m\"\"\e[0m : String)\n\e[31m   |\e[0m                \
    \ Required: Boolean\n\e[31m   |\e[0m                 pattern type is incompatible\
    \ with expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5lqt4046.scala:14:16\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mcase\e\
    [0m _ \e[33mif\e[0m paren_string contains (\e[31m\")\"\e[0m)\n\e[31m14 |\e[0m\
    \                || paren_string contains (\e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \     value || is not a member of String.\n\e[31m   |\e[0m            Note that\
    \ `||` is treated as an infix operator in Scala 3.\n\e[31m   |\e[0m          \
    \  If you do not want that, insert a `;` or empty line in fr"
  stdout: ''
  timestamp: 1660013512
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val result = new ListBuffer[String]()\n\
    \        var open_braces = 0 // track open braces\n        var group = \"\"  //\
    \ keep track of brace group\n\n        // Iterate through each character in string\
    \ and keep track of the character type\n        // and number of open braces\n\
    \        for (i <- paren_string.indices) {\n            val c = paren_string(i)\n\
    \            if (c == ')') {\n                result.append((group + c.toString))\n\
    \                open_braces -= 1\n            }\n            else if (c == '(')\
    \ {\n                result.append((group + c.toString))\n                open_braces\
    \ += 1\n            }\n            else if (c == ' ') {\n                result.append((group\
    \ + c.toString))\n            }\n            else {\n                // If this\
    \ is a open brace or space, then accumulate the current group\n              \
    \  // and reset group string to the empty string\n                if ((open_braces\
    \ % 2) == 0) {\n                    group ++= c.toString\n                }\n\
    \                else {\n                    group = c.toString\n            \
    \    }\n            }\n        }\n\n        return result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp07wlwuv.scala:45)\n\tat Problem.main(tmpp07wlwuv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      paren_string.split(\"(?<!\\\\)\\\\s+(?=(?<=\\\
    \\()|\\\\))\").filter(_.nonEmpty).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.regex.PatternSyntaxException: Unclosed group near index 23\n\
    (?<!\\)\\s+(?=(?<=\\()|\\))\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\
    \tat java.base/java.util.regex.Pattern.accept(Pattern.java:1878)\n\tat java.base/java.util.regex.Pattern.group0(Pattern.java:3053)\n\
    \tat java.base/java.util.regex.Pattern.sequence(Pattern.java:2124)\n\tat java.base/java.util.regex.Pattern.expr(Pattern.java:2069)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1783)\n\tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\tat java.base/java.lang.String.split(String.java:3153)\n\
    \tat java.base/java.lang.String.split(String.java:3199)\n\tat Problem$.separateParenGroups(tmpjaqhdoo7.scala:11)\n\
    \tat Problem$.main(tmpjaqhdoo7.scala:14)\n\tat Problem.main(tmpjaqhdoo7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala"
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.isEmpty) return Nil\n\
    \n        var stack = ListBuffer[String]()\n        var paren_groups = mutable.Buffer[String]()\n\
    \n        for (c <- paren_string.chars()) {\n            if (c == '(')\n     \
    \           paren_groups += c\n\n            if (c == '{')\n                stack\
    \ push c\n\n            if (c == '{')\n                paren_groups += c\n\n \
    \           if (c == '}')\n                if (stack.last == '(')\n          \
    \          paren_groups += c\n                else\n                    stack.pop\n\
    \        }\n\n        if (paren_groups.length != stack.length) return Nil\n\n\
    \        stack.toList.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphwus5qmf.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mparen_groups\e[0m = mutable.Buffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphwus5qmf.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (c <- paren_string.chars()) {\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue foreach is not a member of java.util.stream.IntStream - did you mean\
    \ IntStream.forEach?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val strArray = paren_string.split(\"\"\
    \"\\W+\"\"\")\n        var result : List[String] = Nil\n        strArray.filter(_.startsWith(\"\
    (\")).toList.foreach(l => result = result :+ l.substring(1).toLowerCase)\n   \
    \     strArray.filter(_.startsWith(\")\")).toList.foreach(l => result = result\
    \ :+ l.substring(1).toLowerCase)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpffgmkpvf.scala:18)\n\tat Problem.main(tmpffgmkpvf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // This list will be the result strings.\
    \ \n        var result: List[String] = Nil\n\n        // To check whether we are\
    \ done with the current paren_string \n        var done = false\n\n        //\
    \ To keep track of whether we have encountered an opening or closing brace in\
    \ the current paren_string\n        var current_open_brace = 0\n\n        // To\
    \ keep track of whether we have encountered a closing or opening brace in the\
    \ current paren_string\n        var current_close_brace = 0\n\n        // To keep\
    \ track of whether we have encountered a closing or opening brace in the current\
    \ paren_string\n        var current_close_brace = 0\n\n        // To keep track\
    \ of whether we have encountered a closing or opening brace in the current paren_string\n\
    \        var current_close_brace = 0\n\n        // For traversing over the paren_string\
    \ and making sure that we are not having any open braces\n        var open_braces\
    \ = 0\n\n        // For traversing over the paren_string and making sure that\
    \ we are not having any closing braces\n        var close_braces = 0\n\n     \
    \   // For traversing the paren_string and making sure that we are not having\
    \ any nested braces\n        var nested_braces = 0\n\n        // For traversing\
    \ the paren_string and making sure that we are not having any nested braces\n\
    \        var nested_braces = 0\n\n        // For traversing the paren_string and\
    \ making sure that we are not having any nested braces\n        var nested_braces\
    \ = 0\n\n        // Keep a count of how many times the given char appears in the\
    \ paren_string and\n        // the count of how many times the given char appears\
    \ in the paren_string.\n        val paren_count = paren_string.length\n      \
    \  var count_in_paren_string = paren_string.count(_ == '(')\n        var count_in_paren_string2\
    \ = paren_string.count(_ == ')')\n\n        // Iterate over all the characters\
    \ in the paren_string and make sure\n        // that we are not having any nested\
    \ braces \n        while (paren_count > 0) {\n            // If the current character\
    \ is a opening brace, we need to increment its counter\n            if (paren_count\
    \ == count_in_paren_string) {\n                open_braces += 1\n            \
    \    count_in_paren_string = paren_string.count(_ == '(')\n                count_in_paren_string2\
    \ = paren_string.count(_ == ')')\n                // Now update the counter so\
    \ that when we come across another opening brace\n                // we know we\
    \ are done with current paren_string\n                paren_count -= 1\n     \
    \           // Now if we have encountered an opening brace, we need to decrement\
    \ its counter\n                done = open_braces == 0\n            } else if\
    \ (paren_count == count_in_paren_string2) {\n                close_braces += 1\n\
    \                count_in_paren_string = paren_string.count(_ == '(')\n      \
    \          count_in_paren_string2 = paren_string.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn24qlpkq.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpn24qlpkq.scala:76:0 ----------------------------\e[0m\e[0m\n\e[31m76\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn24qlpkq.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mcurrent_close_brace\e[0m\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcurrent_close_brace is already defined as \e[33mvariable\e[0m \e\
    [35mcurrent_close_brace\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn24qlpkq.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mcurrent_close_brace\e[0m\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcurrent_close_brace is already defined as \e[33mvariable\e[0m \e\
    [35mcurrent_close_brace\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn24qlpkq.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mvar\e[0m \e[36mnested_braces\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mnested_braces is already defined as \e[33mvariable\e[0m \e[35mnested_braces\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn24qlpkq.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mvar\e[0m \e[36mnested_braces\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnested_braces\
    \ is already defined as \e[33mvariable\e[0m \e[35mnested_braces\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660013511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups: List[String] = Nil\n     \
    \   var strings: List[String] = Nil\n        var string: String = paren_string.trim\n\
    \n        var paren_count: Int = 0\n        var open_paren_count: Int = 0\n  \
    \      while (string != \"\") {\n            if (string == \"(\") {\n        \
    \        open_paren_count += 1\n            } else if (string == \")\") {\n  \
    \              paren_count += 1\n            }\n            string += string\n\
    \        }\n\n        if (open_paren_count == paren_count) {\n            if (string\
    \ == \"\") {\n                strings += \"()\"\n            } else {\n      \
    \          strings += string\n            }\n        }\n        \n        var\
    \ next_group: List[String] = Nil\n        var next_group_count = 1\n        while\
    \ (open_paren_count != 0) {\n            next_group += \"()\"\n            next_group_count\
    \ += 1\n            open_paren_count -= 1\n        }\n        \n        while\
    \ (next_group_count != 0) {\n            groups += next_group\n            next_group\
    \ = \"\"\n            next_group_count = 1\n            while (open_paren_count\
    \ != 0) {\n                next_group += \"()\"\n                next_group_count\
    \ += 1\n                open_paren_count -= 1\n            }\n        }\n    \
    \    \n        groups = groups.reverse\n        return strings\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp50u3enza.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                strings += \e[31m\"()\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a\
    \ member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp50u3enza.scala:30:24 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m                strings += string\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp50u3enza.scala:37:23\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            next_group +=\
    \ \e[31m\"()\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp50u3enza.scala:43:19 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            groups += next_group\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp50u3enza.scala:44:25 --------------------\e[0m\e[0m\n\e[31m44 |\e[0m\
    \            next_group = \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m             \
    \            ^^\e[0m\n\e[31m   |\e[0m                         Found:    (\e[32m\"\
    \"\e[0m : String)\n\e[31m   |\e[0m                         Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp50u3enza.scala:47:27\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                next_group\
    \ += \e[31m\"()\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    6 errors found\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \\\\((?!\\\\()\")\n        var paren_groups_list: List[String] = Nil\n       \
    \ for(i <- 0 until paren_groups.length){\n            if(paren_groups[i].endsWith(\"\
    \\\\)\")) paren_groups_list = paren_groups.subList(0,i)\n            else paren_groups_list\
    \ = paren_groups.subList(i+1, paren_groups.length)\n        }\n        return\
    \ paren_groups_list.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbtkqtfjp.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m(paren_groups[\e[35mi\e[0m].endsWith(\e\
    [31m\"\\\\)\"\e[0m)) paren_groups_list = paren_groups.subList(\e[31m0\e[0m,i)\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Not found: type i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbtkqtfjp.scala:14:81 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m            \e[33mif\e[0m(paren_groups[\e[35mi\e[0m].endsWith(\e\
    [31m\"\\\\)\"\e[0m)) paren_groups_list = paren_groups.subList(\e[31m0\e[0m,i)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \    value subList is not a member of Array[String]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpbtkqtfjp.scala:15:50 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m            \e[33melse\e[0m paren_groups_list = paren_groups.subList(i+\e\
    [31m1\e[0m, paren_groups.length)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       value subList is not a member of Array[String]\n3 errors found\n"
  stdout: ''
  timestamp: 1660013511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \ \").filterNot(_ == \")\").map(s => {\n            // Add space for each group\
    \ of nested parentheses.\n            val paren_groups_without_parens = s.split(\"\
    \ \").filterNot(_ == \"(\")\n            val parens_within_group = paren_groups_without_parens.filter(s\
    \ => s.contains(\"(\"))\n            parens_within_group.length match {\n    \
    \            // If the group contains at least one paren, add the parentheses\
    \ back to the string\n                case 0 => s\n                // If the group\
    \ doesn't contain parentheses, add it to the list.\n                case 1 =>\n\
    \                    parens_within_group.head\n            }\n        }).filterNot(_.contains(\"\
    (\"))\n        paren_groups.filter(s => s.contains(\"(\"))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb9sz_lu7.scala:23:27\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        paren_groups.filter(\e\
    [36ms\e[0m => s.contains(\e[31m\"(\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m  \
    \ |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateParenGroup(paren_string :\
    \ String) : List[String] = {\n            paren_string.flatMap(c =>\n        \
    \        {\n                    val cur = c.toChar\n                    if(cur\
    \ == '(')\n                        List(cur)\n                    else if(cur\
    \ == ')')\n                        if(paren_string.head == '(')\n            \
    \                List(cur)\n                        else\n                   \
    \         List()\n                    else\n                        List()\n \
    \               }).filter(_ != '(' && _ != ')').filter(c => c != ' ')\n      \
    \  }\n\n        val paren_groups = paren_string.split('(').map( c => c.split(')').filter(_\
    \ != ' '))\n        val result_list = paren_groups.map( c => c.head).flatMap(c\
    \ => c.reverse.map( c => c+c).flatMap(c => c.reverse).map(c => c+c))\n       \
    \ result_list.distinct\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpdx24ltj4.scala:24:26 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                }).filter(_ != \e[31m'('\e[0m && _ !=\
    \ \e[31m')'\e[0m).filter(c => c != \e[31m' '\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Wrong number of parameters, expected: 1\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpdx24ltj4.scala:27:81 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = paren_string.split(\e\
    [31m'('\e[0m).map( \e[36mc\e[0m => c.split(\e[31m')'\e[0m).filter(_ != \e[31m'\
    \ '\e[0m))\n\e[31m\e[31m   |\e[0m                                            \
    \                                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdx24ltj4.scala:28:110 -----------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = paren_groups.map(\
    \ \e[36mc\e[0m => c.head).flatMap(\e[36mc\e[0m => c.reverse.map( \e[36mc\e[0m\
    \ => c+c).flatMap(\e[36mc\e[0m => c.reverse).map(\e[36mc\e[0m => c+c))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                   value reverse is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdx24ltj4.scala:28:129 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = paren_groups.map(\
    \ \e[36mc\e[0m => c.head).flatMap(\e[36mc\e[0m => c.reverse.map( \e[36mc\e[0m\
    \ => c+c).flatMap(\e[36mc\e[0m => c.reverse).map(\e[36mc\e[0m => c+c))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                ^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of Nothing, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m"
  stdout: ''
  timestamp: 1660013514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def parseParenString(paren_string : String)\
    \ : String = {\n            val strings: List[String] = paren_string\n       \
    \         .split(\",\")\n                .flatMap(x => x.split(\"(,())\").toList)\n\
    \                .map(x => x.replace(\")\", \" \"))\n                .toList\n\
    \            return strings\n        }\n        val strings: List[String] = parseParenString(paren_string)\n\
    \        var open_braces : List[Int] = Nil\n        var closed_parens : List[Int]\
    \ = Nil\n        var output : List[String] = Nil\n        var paren_count = 0\n\
    \        for (x <- strings) {\n            if (x startsWith \"(\") {\n       \
    \         if (open_braces.isEmpty) {\n                    paren_count += 1\n \
    \                   open_braces = List(x)\n                } else {\n        \
    \            open_braces = open_braces ::: List(List(x))\n                   \
    \ open_braces.last.last.last.toInt match {\n                        case 0 =>\n\
    \                            paren_count += 1\n                            open_braces\
    \ = open_braces.last\n                        case x => paren_count -= 1\n   \
    \                 }\n                }\n            } else if (x endsWith \"(\"\
    ) {\n                if (closed_parens.isEmpty) {\n                    paren_count\
    \ += 1\n                    closed_parens = List(x)\n                } else {\n\
    \                    closed_parens = closed_parens ::: List(List(x))\n       \
    \             closed_parens.last.last.last.toInt match {\n                   \
    \     case 0 =>\n                            paren_count += 1\n              \
    \              closed_parens = closed_parens.last\n                        case\
    \ x => paren_count -= 1\n                    }\n                }\n          \
    \  } else if (x endsWith \"{\") {\n                open_braces = Nil\n       \
    \         closed_parens = Nil\n            } else if (x endsWith \"}\") {\n  \
    \              closed_parens = Nil\n            } else if (x endsWith \"(\") {\n\
    \                open_braces = Nil\n            } else if (x endsWith \"}\") {\n\
    \                closed_parens = Nil\n            } else if (\"(,()\".indexOf(x)\
    \ >= 0) {\n                paren_count += 1\n            } else if (\"(,()\".indexOf(x)\
    \ < 0) {\n                paren_count -= 1\n            }\n        }\n       \
    \ if (paren_count == 0) {\n            if (open_braces.isEmpty) {\n          \
    \      output = strings\n            } else {\n                output = open_braces\
    \ ::: strings\n            }\n        } else {\n            if (closed_parens.isEmpty)\
    \ {\n                output = strings\n            } else {\n                output\
    \ = strings ::: closed_parens\n            }\n        }\n        output\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplisl3l12.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mreturn\e[0m\
    \ strings\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Found:    (strings : List[String])\n\e[31m   |\e[0m    \
    \               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmplisl3l12.scala:19:52 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mstrings\e[0m: \e[35mList\e[0m[\e[35mString\e\
    [0m] = parseParenString(paren_string)\n\e[31m\e[31m   |\e[0m                 \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                               Found:    String\n\e[31m   |\e[0m            \
    \                        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e\
    [1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplisl3l12.scala:28:39\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    open_braces\
    \ = List(x)\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\
    \e[31m   |\e[0m                                       Found:    (x : String)\n\
    \e[31m   |\e[0m                                       Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplisl3l12.scala:30:34 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    open_braces = open_braces ::: List(List(x))\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    List[Matchable]\n\
    \e[31m   |\e[0m                                  Required: List[Int]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplisl3l12.scala:31:37 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    open_brace"
  stdout: ''
  timestamp: 1660013514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_group_string : String = paren_string.replaceAll(\"\
    \\\\s+\", \" \")\n        val paren_group_string_reverse = paren_group_string.reverse\n\
    \        val paren_group_string_list = paren_group_string_reverse.split(\" \"\
    )\n        val paren_group_string_list: List[String] = paren_group_string_list.map(s\
    \ => paren_group_string_reverse.split(s)).toList\n        paren_group_string_list.map(l\
    \ => l.foldLeft(List[String]())((acc, s) => {\n            if (acc.isEmpty) List(s)\n\
    \            else {\n                if (acc.last == \"\") acc.head :: s\n   \
    \             else acc.last + \", \" + s\n            }\n        }).toList.sorted)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl_at9sk4.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparen_group_string_list\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = paren_group_string_list.map(\e[36ms\e\
    [0m => paren_group_string_reverse.split(s)).toList\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mparen_group_string_list is already defined as \e[33mvalue\e\
    [0m \e[35mparen_group_string_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl_at9sk4.scala:16:34 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (acc.isEmpty) List(s)\n\e[31m\e\
    [31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m       \
    \                           Found:    (s : Char)\n\e[31m   |\e[0m            \
    \                      Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpl_at9sk4.scala:18:45 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m                \e[33mif\e[0m (acc.last == \e[31m\"\"\e[0m)\
    \ acc.head :: s\n\e[31m\e[31m   |\e[0m                                       \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                                        value\
    \ :: is not a member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl_at9sk4.scala:19:21\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33melse\e\
    [0m acc.last + \e[31m\", \"\e[0m + s\n\e[31m\e[31m   |\e[0m                  \
    \   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:    String\n\
    \e[31m   |\e[0m                     Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_chars = paren_string.chars\n\
    \        val open_brace_indexes = mutable.HashSet[Int]()\n        var open_brace_level\
    \ = 0\n        var open_brace_level = paren_chars.takeWhile(_ != '(').length\n\
    \        var close_brace_level = 0\n        var close_brace_level = paren_chars.takeWhile(_\
    \ != ')').length\n\n        paren_chars.foreach {\n            case c if c !=\
    \ '(' && (c == ')' || c == ' ') => {\n                close_brace_level += 1\n\
    \            }\n            case c if c == '(' => {\n                open_brace_indexes\
    \ += open_brace_level\n                open_brace_level += 1\n            }\n\
    \            case c if c == ')' => {\n                close_brace_level -= 1\n\
    \            }\n            case c if c == ' ' => {\n                if (open_brace_level\
    \ == 0 && close_brace_level == 0) {\n                    open_brace_indexes +=\
    \ open_brace_level\n                    open_brace_level += 1\n              \
    \  }\n                close_brace_level += 1\n            }\n        }\n     \
    \   val stringBuilder = StringBuilder()\n        open_brace_indexes.foreach {\n\
    \            open_brace_level => {\n                if (open_brace_level > 0)\
    \ {\n                    stringBuilder.append('(')\n                }\n      \
    \      }\n        }\n        paren_chars.foreach {\n            case c if c !=\
    \ '(' && (c == ')' || c == ' ') => {\n                stringBuilder.append(c)\n\
    \            }\n            case c if c == '(' => {\n                stringBuilder.append('(')\n\
    \            }\n            case c if c == ')' => {\n                if (close_brace_level\
    \ == 0 && stringBuilder.length() > 0) {\n                    stringBuilder.append(')')\n\
    \                }\n                stringBuilder.append(')')\n            }\n\
    \            case c if c == ' ' => {\n                if (stringBuilder.length()\
    \ > 0) {\n                    stringBuilder.append(\" \")\n                }\n\
    \            }\n        }\n        if (stringBuilder.length() > 0) {\n       \
    \     stringBuilder.toString()\n        } else {\n            List()\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzeudzr56.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mopen_brace_level\e[0m =\
    \ paren_chars.takeWhile(_ != \e[31m'('\e[0m).length\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopen_brace_level is already defined as \e[33mvariable\e[0m \e[35mopen_brace_level\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzeudzr56.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mvar\e[0m \e[36mclose_brace_level\e[0m = paren_chars.takeWhile(_\
    \ != \e[31m')'\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclose_brace_level is already defined as \e[33mvariable\e[0m\
    \ \e[35mclose_brace_level\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzeudzr56.scala:12:33 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mopen_brace_indexes\e[0m\
    \ = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzeudzr56.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        paren_chars.foreach\
    \ {\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ foreach is not a member of java.util.stream.IntStream - did you mean paren_chars.forEach?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzeudzr56.scala:45:20 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        paren_chars.foreach {\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member\
    \ of java.util.stream.IntStream - did you mean paren_chars.forEach?\n\e"
  stdout: ''
  timestamp: 1660013513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def toParenGroups(string: List[String],\
    \ acc : List[String]): List[String] = {\n            if(string.isEmpty) acc\n\
    \            else {\n                val head = string.head\n                toParenGroups(string.tail,\
    \ acc :+ head :+ \"(\" + acc :+ \")\")\n            }\n        }\n        val\
    \ open_paren_count = 0\n        val closed_paren_count = 0\n        val paren_string_list\
    \ = paren_string.trim().split(\"\\\\s+\").filter(_.nonEmpty)\n        val open_paren\
    \ = paren_string_list.foldLeft(\"\") {\n            case (acc,element) =>\n  \
    \              element.head match {\n                    case \"(\" => acc :+\
    \ \"(\" + acc :+ \")\"\n                    case \")\" => acc :+ \"(\" + acc :+\
    \ \")\"\n                    case \"{\" => acc :+ \"(\" + acc :+ \"{\" + acc :+\
    \ \"})\"\n                    case \"}\" => acc :+ \"(\" + acc :+ \"{\" + acc\
    \ :+ \"})\"\n                    case _ => acc\n                }\n        }\n\
    \        val closed_paren = paren_string_list.foldLeft(\"\") {\n            case\
    \ (acc, element) =>\n                element.head match {\n                  \
    \  case \")\" => acc :+ \"(\" + acc :+ \"{\" + acc :+ \"})\"\n               \
    \     case \")\" => acc :+ \"(\" + acc :+ \"{\" + acc :+ \"})\"\n            \
    \        case \"}\" => acc :+ \"(\" + acc :+ \"}\" + acc :+ \"})\"\n         \
    \           case \"}\" => acc :+ \"(\" + acc :+ \"}\" + acc :+ \"})\"\n      \
    \              case _ => acc\n                }\n        }\n        toParenGroups(paren_string_list,\
    \ \"\") match {\n            case List(paren_string) => paren_string\n       \
    \     case _ =>\n                val open_paren_count = paren_string.count(_ ==\
    \ \"(\")\n                val closed_paren_count = paren_string.count(_ == \"\
    )\")\n                val result = open_paren_count + closed_paren_count\n   \
    \             if(open_paren_count == 0 && closed_paren_count == 0) result else\
    \ open_paren_count :+ closed_paren_count\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpix46mmp9.scala:24:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    \e[33mcase\e[0m \e[31m\"(\"\e[0m\
    \ => acc :+ \e[31m\"(\"\e[0m + acc :+ \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                         ^^^\e[0m\n\e[31m   |\e[0m        Values of types String\
    \ and Char cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpix46mmp9.scala:24:32 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    \e[33mcase\e[0m \e[31m\"(\"\e[0m => acc :+ \e[31m\"\
    (\"\e[0m + acc :+ \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    IndexedSeq[Matchable]\n\e[31m   |\e[0m               \
    \                 Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpix46mmp9.scala:25:25\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \             \e[33mcase\e[0m \e[31m\")\"\e[0m => acc :+ \e[31m\"(\"\e[0m + acc\
    \ :+ \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpix46mmp9.scala:25:32\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mcase\e\
    [0m \e[31m\")\"\e[0m => acc :+ \e[31m\"(\"\e[0m + acc :+ \e[31m\")\"\e[0m\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                Found:    IndexedSeq[Matchable]\n\
    \e[31m   |\e[0m                                Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpix46mmp9.scala:26:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33mcase\e[0m \e[31m\"{\"\e[0m\
    \ => acc :+ \e[31m\"(\"\e[0m + acc :+ \e[31m\"{\"\e[0m + acc :+ \e[31m\"})\"\e\
    [0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types String and Char cannot be compare"
  stdout: ''
  timestamp: 1660013518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups: List[String] = Nil\n\
    \n        for(i <- 0 to paren_string.length - 1) {\n            val brace_match\
    \ = \"((.))\".r.findAllIn(paren_string(i)).toList\n            val open_match\
    \ = \"(.)\".r.findAllIn(paren_string(i)).toList\n            if(open_match.length\
    \ < brace_match.length) {\n                paren_groups = paren_groups ++ paren_string(i)\
    \ ++ open_match\n            }\n            else if(open_match.length == brace_match.length)\
    \ {\n                paren_groups = paren_groups ++ paren_string(i) ++ brace_match\n\
    \            }\n            else if(open_match.length > brace_match.length) {\n\
    \                paren_groups = paren_groups ++ paren_string(i) ++ brace_match\
    \ ++ open_match\n            }\n        }\n\n        paren_groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7afly69.scala:14:62\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e\
    [36mbrace_match\e[0m = \e[31m\"((.))\"\e[0m.r.findAllIn(paren_string(i)).toList\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Char\n\e[31m   |\e[0m                                                  Required:\
    \ CharSequence\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7afly69.scala:15:59\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e\
    [36mopen_match\e[0m = \e[31m\"(.)\"\e[0m.r.findAllIn(paren_string(i)).toList\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Found:    Char\n\
    \e[31m   |\e[0m                                               Required: CharSequence\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7afly69.scala:17:59\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                paren_groups\
    \ = paren_groups ++ paren_string(i) ++ open_match\n\e[31m\e[31m   |\e[0m     \
    \                                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                          Found:    Char\n\e[31m   |\e[0m \
    \                                         Required: IterableOnce[String]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7afly69.scala:20:59 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                paren_groups = paren_groups ++ paren_string(i)\
    \ ++ brace_match\n\e[31m\e[31m   |\e[0m                                      \
    \         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \            Found:    Char\n\e[31m   |\e[0m                                 \
    \         Required: IterableOnce[String]\n\e[31m"
  stdout: ''
  timestamp: 1660013520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \"\"[\\(\\)]+\"\"\")\n        var paren_group_strings = List[String]()\n     \
    \   paren_groups.foreach{ group =>\n            if(paren_group_strings.isEmpty)\
    \ {\n                paren_group_strings = ListBuffer(group)\n            } else\
    \ {\n                val found_end = paren_group_strings.last.end\n          \
    \      val found_index = paren_group_strings.last.index\n                val start_index\
    \ = paren_group_strings.last.start\n                val final_start = paren_group_strings.last.start\n\
    \                val last_group = paren_group_strings.last\n                val\
    \ final_end = paren_group_strings.last.end\n\n                val is_balanced\
    \ = final_start <= found_index && found_index < final_end\n                if(!is_balanced)\
    \ {\n                    paren_group_strings = paren_group_strings :+ group\n\
    \                } else if(found_index > final_start && found_index < last_group.end)\
    \ {\n                    paren_group_strings = paren_group_strings :+ group\n\
    \                }\n            }\n        }\n        return paren_group_strings.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwe4bhc8n.scala:15:48\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                paren_group_strings\
    \ = ListBuffer(group)\n\e[31m\e[31m   |\e[0m                                 \
    \     ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    scala.collection.mutable.ListBuffer[String]\n\
    \e[31m   |\e[0m                   Required: List[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpwe4bhc8n.scala:17:57 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mval\e[0m \e[36mfound_end\e[0m =\
    \ paren_group_strings.last.end\n\e[31m\e[31m   |\e[0m                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \              value end is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpwe4bhc8n.scala:18:59 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m                \e[33mval\e[0m \e[36mfound_index\e[0m = paren_group_strings.last.index\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     value index is not a member of String - did you mean\
    \ String.indent?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwe4bhc8n.scala:19:59\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e\
    [0m \e[36mstart_index\e[0m = paren_group_strings.last.start\n\e[31m\e[31m   |\e\
    [0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value start is not a member of String - did you mean String.charAt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwe4bhc8n.scala:20:59 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m \e[36mfinal_start\e[0m\
    \ = paren_group_strings.last.start\n\e[31m\e[31m   |\e[0m                    \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value\
    \ start is not a member of String - did you mean String.charAt?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpwe4bhc8n.scala:22:57 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m  "
  stdout: ''
  timestamp: 1660013521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_stack = mutable.Stack[String]()\n\
    \        val result_list = new mutable.ListBuffer[String]()\n        paren_string.split(\"\
    \\\\s\").foreach(x => {\n            val temp_str = x\n            val open_brace_index\
    \ =\n                (temp_str.indexOf(\"(\") + temp_str.indexOf(\")\"))\n\n \
    \           while (open_brace_index != -1) {\n                paren_stack += temp_str.substring(0,\
    \ open_brace_index)\n                val clos_brace_index =\n                \
    \    (temp_str.indexOf(\")\", open_brace_index + 1) + temp_str.indexOf(\"(\",\
    \ open_brace_index + 1))\n                paren_stack += temp_str.substring(clos_brace_index)\n\
    \                temp_str = temp_str.substring(0, clos_brace_index)\n        \
    \        open_brace_index =\n                    (temp_str.indexOf(\"(\") + temp_str.indexOf(\"\
    )\"))\n\n            }\n            if (paren_stack.size == 0) result_list +=\
    \ temp_str\n        })\n        result_list.result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphpelzopb.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmphpelzopb.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphpelzopb.scala:23:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                temp_str\
    \ = temp_str.substring(\e[31m0\e[0m, clos_brace_index)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val temp_str\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmphpelzopb.scala:24:33 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                open_brace_index =\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Reassignment to val\
    \ open_brace_index\n\e[31m25 |\e[0m                    (temp_str.indexOf(\e[31m\"\
    (\"\e[0m) + temp_str.indexOf(\e[31m\")\"\e[0m))\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def isBalanced(s : String) : Boolean =\
    \ \n            if (s.isEmpty) true\n            else { \n                if (s.charAt(0)\
    \ == '(') isBalanced(s.substring(1))\n                else if (s.charAt(s.length-1)\
    \ == ')') isBalanced(s.substring(0, s.length-1))\n                else false\n\
    \            }\n        val parens = paren_string.split(\"\").filter(x => x ==\
    \ '(' || x == ')').map(x => x.toString).filter(x => !x.isEmpty)\n        val groupedParens\
    \ = parens.groupBy(x => x)\n        var balanced : List[String] = Nil\n      \
    \  for (paren in groupedParens.keys) {\n            balanced ::= paren\n     \
    \       for (next <- groupedParens(paren).keys) {\n                if (groupedParens(paren).count(y\
    \ => y == next) == groupedParens(paren).count(y => y == '(')) {\n            \
    \        balanced ::= next\n                }\n            }\n        }\n    \
    \    (balanced.toList ::: groupedParens.values.toList.filter(_.keys.size == 0))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbo4bczno.scala:21:42 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m (paren in groupedParens.keys)\
    \ {\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e\
    [31m   |\e[0m                                          '<-' expected, but '{'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbo4bczno.scala:29:65 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        (balanced.toList ::: groupedParens.values.toList.filter(_.keys.size\
    \ == \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                   \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                      ')' expected, but '.' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpbo4bczno.scala:30:4 ----------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0m    '<-' expected,\
    \ but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpbo4bczno.scala:18:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = paren_string.split(\e\
    [31m\"\"\e[0m).filter(\e[36mx\e[0m => x == \e[31m'('\e[0m || x == \e[31m')'\e\
    [0m).map(\e[36mx\e[0m => x.toString).filter(\e[36mx\e[0m => !x.isEmpty)\n\e[31m\e\
    [31m   |\e[0m                                                        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpbo4bczno.scala:18:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = paren_string.split(\e\
    [31m\"\"\e[0m).filter(\e[36mx\e[0m => x == \e[31m'('\e[0m || x == \e[31m')'\e\
    [0m).map(\e[36mx\e[0m => x.toString).filter(\e[36mx\e[0m => !x.isEmpty)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types String and Char cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbo4bczno.scala:28:9\
    \ -------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter is no"
  stdout: ''
  timestamp: 1660013524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parens = paren_string.split(\"\"\"\
    \\\\(\\)\"\"\")\n        val paren_array = new mutable.Array[String]()\n\n   \
    \     // Use a state machine to determine whether the parentheses are balanced\n\
    \        var paren_is_balanced = 0\n        // Keep track of opening and closing\
    \ parens index\n        var parens_index = 0\n        // Keep track of how many\
    \ times the inner parentheses are opened and closed\n        var parens_open =\
    \ 1\n        for ((index, char) <- parens.zipWithIndex) yield {\n            val\
    \ open_char = parens(parens_index)\n            paren_array += char\n\n      \
    \      if (char == '(') {\n                paren_is_balanced += 1\n          \
    \  } else if (char == ')') {\n                paren_is_balanced -= 1\n       \
    \     }\n\n            parens_index += 1\n\n            if (paren_is_balanced\
    \ == 0) {\n                parens_open = 1\n            }\n\n            if (parens_open\
    \ == 0) {\n                parens_index += 1\n            }\n\n        }\n\n \
    \       if (parens_index != parens.length) {\n            throw new RuntimeException(\"\
    Invalid paren string\")\n        }\n\n        paren_array.dropRight(1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ou54yfw.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_array\e[0m = \e[33mnew\e\
    [0m mutable.Array[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if(paren_string == \"\") return Nil\n\
    \        def find_open_bracket(s : String, index : Int) : Option[(Int, Int)] =\
    \ {\n            if(index == s.length - 1)\n                if (s.charAt(index)\
    \ == '(')\n                    Some((index, index+1))\n                else\n\
    \                    None\n            else if(s.charAt(index) == '(')\n     \
    \           Some((index, index+1))\n            else\n                find_open_bracket(s,\
    \ index+1)\n        }\n        def find_close_bracket(s : String, index : Int)\
    \ : Option[(Int, Int)] = {\n            if(index >= s.length)\n              \
    \  None\n            else if(s.charAt(index) != ')')\n                find_close_bracket(s,\
    \ index+1)\n            else\n                Some((index, index+1))\n       \
    \ }\n        val groups = mutable.ArrayBuffer.empty[String]\n        val index\
    \ = paren_string.length\n        while(index > 0) {\n            val open_pos\
    \ = find_open_bracket(paren_string, index).map(_._1)\n            val close_pos\
    \ = find_close_bracket(paren_string, index).map(_._1)\n            val group_start\
    \ = open_pos.orElse(close_pos)\n            val group_end = close_pos.orElse(open_pos.map(_._1))\n\
    \            val group_content = paren_string.substring(group_start._1, group_end._1+1)\n\
    \            groups.+=(group_content)\n            index = close_pos.map(_._2)\n\
    \        }\n        groups\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj4rq0qwd.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgroups\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpj4rq0qwd.scala:37:60 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mgroup_end\e[0m = close_pos.orElse(open_pos.map(_._1))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                         value _1\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj4rq0qwd.scala:38:67\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m\
    \ \e[36mgroup_content\e[0m = paren_string.substring(group_start._1, group_end._1+\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \     value _1 is not a member of Option[Int]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpj4rq0qwd.scala:38:81 ------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            \e[33mval\e[0m \e[36mgroup_content\e[0m = paren_string.substring(group_start._1,\
    \ group_end._1+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \                                             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 value _1 is not a member of Option[Int]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpj4rq0qwd.scala:40:36 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            index = close_pos.map(_._2)\n\e[31m\e[31m\
    \   |\e[0m                                  ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                           value _2 is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660013523
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_splits = paren_string.split(\"\
    \\\\s+\")\n        val return_list = scala.collection.mutable.ListBuffer[String]()\n\
    \        var next_index = -1\n        for (i <- 0 until paren_splits.length) {\n\
    \            val current_group_size = (paren_splits(i).length / 2) - 2\n     \
    \       if (current_group_size != 0) {\n                return_list.append(paren_splits(i).substring(next_index,\
    \ next_index + current_group_size))\n                return_list.append(paren_splits(i\
    \ + 1).substring(current_group_size, current_group_size + 1))\n            }\n\
    \            next_index += current_group_size\n        }\n        return_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 0, length 6\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.separateParenGroups$$anonfun$1(tmpq1fignr1.scala:17)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.separateParenGroups(tmpq1fignr1.scala:21)\n\
    \tat Problem$.main(tmpq1fignr1.scala:25)\n\tat Problem.main(tmpq1fignr1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // The algorithm implemented below is\
    \ as follows:\n        // 1) Parse the paren_string into a tree\n        // 2)\
    \ Perform inorder traversal on tree, storing strings of groups as they are encountered\
    \ in the tree\n        // 3) Return list of strings of groups\n        val paren_string\
    \ =  paren_string.trim\n        val paren_string =  paren_string.dropWhile(c =>\
    \ c != ' ').drop(1)\n        val paren_string =  paren_string.dropWhile(c => c\
    \ != ' ').dropRight(1)\n        val paren_string =  paren_string.dropWhile(c =>\
    \ c != ' ').dropRight(2)\n        val paren_string =  paren_string.dropWhile(c\
    \ => c != ' ').dropRight(3)\n\n        val tokens = paren_string.split(\"\").map(_.toInt)\n\
    \        val groups = new mutable.HashMap[Int, String]()\n        // Traverse\
    \ the tree and store strings of groups encountered in it\n        def traverse(node\
    \ : TreeNode[Int], group_string : String) : Unit = { \n            val children\
    \ = node.getChildren()\n            if (children.isEmpty) \n                if\
    \ (node.getType() == TreeNodeType.Leaf) \n                    groups += (paren_string.indexOf(node.getLabel())\
    \ -> (group_string+node.getLabel()))\n                else\n                 \
    \   groups += (paren_string.indexOf(node.getLabel()) -> (group_string+node.getLabel()))\n\
    \            else {\n                for (child <- children)\n               \
    \     traverse(child, group_string+node.getLabel())\n            }\n        }\n\
    \        traverse(new TreeNode[Int](tokens.toSeq:_*), \"()\")\n\n        var result\
    \ = new ListBuffer[String]()\n        for (group <- groups.keys) {\n         \
    \   result.append(groups.get(group))\n        }\n        return result.result()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5r4hvht3.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m =  paren_string.dropWhile(\e\
    [36mc\e[0m => c != \e[31m' '\e[0m).drop(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mparen_string is already defined as \e[33mvalue\e[0m \e[35mparen_string\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5r4hvht3.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m =  paren_string.dropWhile(\e\
    [36mc\e[0m => c != \e[31m' '\e[0m).dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mparen_string is already defined as \e[33mvalue\e[0m \e[35mparen_string\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5r4hvht3.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m =  paren_string.dropWhile(\e\
    [36mc\e[0m => c != \e[31m' '\e[0m).dropRight(\e[31m2\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mparen_string is already defined as \e[33mvalue\e[0m \e[35mparen_string\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5r4hvht3.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m =  paren_string.dropWhile(\e\
    [36mc\e[0m => c != \e[31m' '\e[0m).dropRight(\e[31m3\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mparen_string is already defined as \e[33mvalue\e[0m \e[35mparen_string\e\
    [0m\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1660013519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var group_list : List[String] = Nil\n\
    \        var open_braces : mutable.Set[Char] = mutable.Set()\n        for (i <-\
    \ 0 until paren_string.length) {\n            if (paren_string(i) == '(') {\n\
    \                if (open_braces.contains(paren_string(i))) {\n              \
    \      group_list = group_list :+ paren_string(i + 2)\n                } else\
    \ {\n                    open_braces += paren_string(i + 2)\n                }\n\
    \            } else if (paren_string(i) == ')') {\n                open_braces\
    \ -= paren_string(i + 2)\n            } else if (paren_string(i) == ' ') {\n \
    \               // Ignore spaces as part of the group\n            } else {\n\
    \                group_list += paren_string(i)\n            }\n        }\n   \
    \     group_list\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7lh1umln.scala:12:26 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mopen_braces\e[0m : mutable.Set[\e\
    [35mChar\e[0m] = mutable.Set()\n\e[31m\e[31m   |\e[0m                        \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7lh1umln.scala:12:46\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e\
    [36mopen_braces\e[0m : mutable.Set[\e[35mChar\e[0m] = mutable.Set()\n\e[31m\e\
    [31m   |\e[0m                                              ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                              Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7lh1umln.scala:16:59\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                    group_list\
    \ = group_list :+ paren_string(i + \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                               Found:    Char\n\e[31m   |\e\
    [0m                                               Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7lh1umln.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                group_list += paren_string(i)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[String] - did you mean List[String].!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660013524
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        //We are going to count the open and close\
    \ braces of paren_string with each loop\n        var open_paren = 0\n        var\
    \ close_paren = 0\n        var brace_count = 0\n        \n        //The output\
    \ list will be stored here\n        val output = ListBuffer[String]()\n      \
    \  \n        //Iterate over all the characters in the string\n        for (c <-\
    \ paren_string) {\n            //We just increment the brace_count when encounter\
    \ the opening brace\n            if (c == '(') open_paren += 1\n            \n\
    \            //We just decrement the brace_count when encounter the closing brace\n\
    \            else if (c == ')') close_paren += 1\n            \n            //When\
    \ we encounter a space or a line break\n            else if (c == ' ' || c ==\
    \ '\\n') ()\n            \n            //When we encounter an opening brace and\
    \ are within a set of parentheses\n            else if (open_paren > 0 && c ==\
    \ '(') {\n                brace_count += 1\n                \n               \
    \ //If we hit the closing brace too early, we must add the last element of the\
    \ output to the output list\n                if (close_paren == brace_count) output\
    \ += paren_string.substring((open_paren + 1), close_paren)\n            }\n  \
    \          \n            //When we encounter a closing brace and are within a\
    \ set of parentheses\n            else if (open_paren > 0 && c == ')') {\n   \
    \             brace_count -= 1\n                \n                //If we hit\
    \ the opening brace too early, we must add the last element of the output to the\
    \ output list\n                if (open_paren == brace_count) output += paren_string.substring((open_paren\
    \ + 1), close_paren)\n            }\n        }\n        \n        //Finally, return\
    \ output\n        output.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp19_ge70a.scala:51)\n\tat Problem.main(tmp19_ge70a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Your code here\n        val lst_str\
    \ = paren_string.split(\"\\\\s(?=\\\\()|(?<=\\\\))\\\\s)\").toList\n        val\
    \ lst = lst_str.foldLeft((List[String]()))( (acc, elem) => { val lst_str = elem.split(\"\
    \\\\s(?=\\\\()|(?<=\\\\))\\\\s)\").toList; acc.++(lst_str) })\n        val lst_lst\
    \ = lst.foldLeft((List[List[String]]))((acc, elem) => {\n            val (lst_str,\
    \ lst_lst) = elem.split(\"\\\\s(?=\\\\()|(?<=\\\\))\\\\s)\").toList\n        \
    \    val lst = lst_lst.foldLeft((List[List[String]]))((acc, elem) => {\n     \
    \           val lst_str = elem.split(\"\\\\s(?=\\\\()|(?<=\\\\))\\\\s)\").toList\n\
    \                val lst = lst_str.foldLeft((List[String]()))( (acc, elem) =>\
    \ { acc.++(List(elem)) })\n                lst\n            })\n            (lst_str,\
    \ lst)\n        })\n        lst_lst.foldLeft((List[List[String]]))((acc, elem)\
    \ => {\n            val lst_str = elem.split(\"\\\\s(?=\\\\()|(?<=\\\\))\\\\s)\"\
    ).toList\n            val lst = lst_str.foldLeft((List[String]()))( (acc, elem)\
    \ => { acc.++(elem) })\n            lst\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk3549jb7.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mlst\e[0m = lst_lst.foldLeft((List[\e\
    [35mList\e[0m[\e[35mString\e[0m]]))((\e[36macc\e[0m, \e[36melem\e[0m) => {\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      value foldLeft is not a member of Any\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpk3549jb7.scala:21:12 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            (lst_str, lst)\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    ((lst_str : Any),\
    \ Nothing)\n\e[31m   |\e[0m            Required: Seq[List[String]] => List[List[String]]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk3549jb7.scala:23:16\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        lst_lst.foldLeft((List[\e\
    [35mList\e[0m[\e[35mString\e[0m]]))((\e[36macc\e[0m, \e[36melem\e[0m) => {\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue foldLeft\
    \ is not a member of Seq[List[String]] => List[List[String]]\n3 errors found\n"
  stdout: ''
  timestamp: 1660013525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_string = paren_string.toLowerCase\n\
    \        var paren_groups: List[String] = Nil\n        var open_brace = paren_string.indexOf('(')\n\
    \        var open_paren = paren_string.indexOf('(')\n        while (open_brace\
    \ >= 0) {\n            paren_groups = paren_string.substring(open_brace, paren_string.length).split(')')\n\
    \            paren_string = paren_string.substring(paren_groups(0).length + 1,\
    \ paren_string.length)\n            paren_string = paren_groups.reverse.mkString(\"\
    )\") + paren_string\n            paren_groups = Nil\n            open_brace =\
    \ paren_string.indexOf('(')\n        }\n        paren_groups = paren_string.split(')')\n\
    \        paren_groups.reverse.mkString(\")\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz9uodtwl.scala:11:27 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mparen_string\e[0m = paren_string.toLowerCase\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvariable\e[0m \e[35mparen_string\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz9uodtwl.scala:23:37\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        paren_groups.reverse.mkString(\e\
    [31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    String\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def isParenGroup(paren_string : String)\
    \ : Boolean = {\n            paren_string match {\n                case \"(\"\
    \ => true\n                case \")\" => true\n                case _ => false\n\
    \            }\n        }\n\n        def isBraceGroup(paren_string : String) :\
    \ Boolean = {\n            paren_string match {\n                case \"{\" =>\
    \ true\n                case \"}\" => true\n                case _ => false\n\
    \            }\n        }\n\n        def isBalanced(paren_string : String) : Boolean\
    \ = {\n            // check if paren_string contains a closing brace\n       \
    \     paren_string match {\n                case \"{\" => true\n             \
    \   case \"}\" => false\n                case _ => false\n            }\n    \
    \    }\n\n        def isNested(paren_string : String) : Boolean = {\n        \
    \    // check if paren_string contains a closing brace\n            paren_string\
    \ match {\n                case \"{\" => false\n                case \"}\" =>\
    \ true\n                case _ => false\n            }\n        }\n\n        val\
    \ brace_groups = mutable.ListBuffer[String]()\n\n        var paren_string : String\
    \ = \"\"\n\n        for (character <- paren_string) {\n            if (character\
    \ == '(') {\n                if (isParenGroup(paren_string)) {\n             \
    \       paren_string = \"\"\n                    brace_groups += paren_string\n\
    \                } else {\n                    paren_string += \"(\"\n       \
    \         }\n            } else if (character == ')') {\n                if (!isParenGroup(paren_string))\
    \ {\n                    paren_string = \"\"\n                    brace_groups\
    \ += paren_string\n                }\n            } else if (character == '{')\
    \ {\n                if (!isBraceGroup(paren_string)) {\n                    paren_string\
    \ = \"\"\n                    brace_groups += paren_string\n                }\n\
    \            } else if (character == '}') {\n                if (!isBraceGroup(paren_string))\
    \ {\n                    paren_string = \"\"\n                    brace_groups\
    \ += paren_string\n                } else {\n                    if (isBalanced(paren_string))\
    \ {\n                        paren_string = \"\"\n                        brace_groups\
    \ += paren_string\n                    }\n                }\n            }\n\n\
    \            paren_string += character\n        }\n\n        brace_groups += paren_string\n\
    \n        if (paren_string != \"\") {\n            throw new RuntimeException(\"\
    Error: Unbalanced parentheses\")\n        }\n\n        brace_groups.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ilzzj8b.scala:45:27 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mbrace_groups\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.isEmpty) return Nil\n\
    \        var parens_open : Option[Int] = None\n        var parens_close : Option[Int]\
    \ = None\n        var curr_group_string : List[String] = Nil\n        var curr_group_string\
    \ : List[String] = Nil\n        var open_parens_stack : List[Int] = Nil\n    \
    \    var close_parens_stack : List[Int] = Nil\n        var is_closed : Boolean\
    \ = false\n        var curr : Int = -1\n        var i : Int = 0\n        var count\
    \ : Int = 0\n        var group_index = 0\n        for (c <- paren_string.toCharArray)\
    \ {\n            if (c == '(') open_parens_stack ::= parens_open\n           \
    \ if (c == '(') parens_open = Some(parens_open.getOrElse(-1))\n            if\
    \ (c == ')') {\n                is_closed = true\n                if (parens_open.getOrElse(-1)\
    \ != -1) {\n                    open_parens_stack = open_parens_stack.filterNot(_\
    \ == parens_open.getOrElse(-1))\n                    parens_open = None\n    \
    \                parens_close = None\n                }\n            }\n     \
    \       if (c == ')' && parens_open.getOrElse(-1) != -1) {\n                is_closed\
    \ = false\n                open_parens_stack = open_parens_stack.filterNot(_ ==\
    \ parens_open.getOrElse(-1))\n                parens_open = None\n           \
    \     parens_close = None\n            }\n            if (is_closed && parens_close.getOrElse(-1)\
    \ != -1) {\n                close_parens_stack = close_parens_stack :+ parens_close.getOrElse(-1)\n\
    \                parens_close = None\n            }\n            if (!is_closed\
    \ && parens_open.getOrElse(-1) != -1) {\n                close_parens_stack =\
    \ close_parens_stack :+ parens_open.getOrElse(-1)\n                parens_open\
    \ = None\n            }\n            if (c == '(') open_parens_stack = open_parens_stack\
    \ :+ parens_open.getOrElse(-1)\n            if (c == ')') parens_close = parens_close\
    \ :+ parens_close.getOrElse(-1)\n            if (parens_open.getOrElse(-1) ==\
    \ -1 && parens_close.getOrElse(-1) == -1) {\n                if (c == '(') curr_group_string\
    \ = curr_group_string.++'('\n                if (c == ')') curr_group_string =\
    \ curr_group_string.++')'\n            }\n            if (parens_open.getOrElse(-1)\
    \ != -1 || parens_close.getOrElse(-1) != -1) {\n                if (c == '(')\
    \ curr_group_string = curr_group_string.++'('\n                if (c == ')') curr_group_string\
    \ = curr_group_string.\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkv6ez6ny.scala:51:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                \e[33mif\e[0m (c == \e[31m'('\e[0m) curr_group_string\
    \ = curr_group_string.++\e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                   end of statement expected but character literal found\n\e\
    [31m\e[31m-- Error: /tmp/tmpkv6ez6ny.scala:52:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                \e[33mif\e[0m (c == \e[31m')'\e[0m) curr_group_string\
    \ = curr_group_string.++\e[31m')'\e[0m\n\e[31m\e[31m   |\e[0m                \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                   end of statement expected but character literal found\n\e\
    [31m\e[31m-- Error: /tmp/tmpkv6ez6ny.scala:55:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m                \e[33mif\e[0m (c == \e[31m'('\e[0m) curr_group_string\
    \ = curr_group_string.++\e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                   end of statement expected but character literal found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpkv6ez6ny.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpkv6ez6ny.scala:66:0 ----------------------------\e[0m\e[0m\n\e[31m66\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkv6ez6ny.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mcurr_group_string\e[0m :\
    \ \e[35mList\e[0m[\e[35mString\e[0m] = Nil\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurr_group_string is already defined as \e[33mvariable\e[0m\
    \ \e[35mcurr_group_string\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e["
  stdout: ''
  timestamp: 1660013526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def parse(str: String): List[String] =\
    \ {\n            def parseToList(remainingStr: String): List[String] = {\n   \
    \             if (remainingStr.length == 0)\n                    Nil\n       \
    \         else {\n                    val remainderStr = remainingStr.trim\n \
    \                   if (remainderStr.length == 0)\n                        Nil\n\
    \                    else if (remainderStr.charAt(0) == '(') {\n             \
    \           parseToList(remainderStr.substring(1))\n                    }\n  \
    \                  else {\n                        val openBraces = remainingStr.trim('(',\
    \ '[', '{')\n                        val openBrace = openBraces.charAt(0)\n  \
    \                      val closeBrace = openBraces.charAt((openBraces.length -\
    \ 1))\n                        remainingStr.substring(openBraces.length - 1).trim\n\
    \                                .split(\"(\" + openBrace + \")\" + closeBrace\
    \ + \"(\")\n                                .filter(_ != \"\")\n             \
    \                   .map(parseToList)\n                                .flatten.toList\n\
    \                    }\n                }\n            }\n            str.split(\"\
    \\\\(\").filter(_ != \"\").map(parseToList).flatten.toList\n        }\n      \
    \  return parse(paren_string)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxzq1n5k_.scala:23:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                        \e[33mval\e[0m \e[36mopenBraces\e\
    [0m = remainingStr.trim(\e[31m'('\e[0m, \e[31m'['\e[0m, \e[31m'{'\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                           ^^^\e\
    [0m\n\e[31m   |\e[0m          too many arguments for \e[33mmethod\e[0m \e[35mtrim\e\
    [0m in \e[33mclass\e[0m \e[35mString\e[0m: (): String\n1 error found\n"
  stdout: ''
  timestamp: 1660013522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize a List to store the result\n\
    \        val parenGroups = ListBuffer[String]()\n\n        // Iterate through\
    \ the paren_string and add everything in paren_string to the parenGroups ListBuffer\n\
    \        for (i <- 0 until paren_string.length) {\n            parenGroups +=\
    \ paren_string(i) //append paren_string (i) to parenGroups\n        }\n\n    \
    \    // return the parenGroups list\n        return parenGroups.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi7zu014t.scala:16:39\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            parenGroups += paren_string(i)\
    \ \e[34m//append paren_string (i) to parenGroups\e[0m\n\e[31m\e[31m   |\e[0m \
    \                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \              Found:    Char\n\e[31m   |\e[0m                           Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val group_strings = paren_string.split(\"\
    \\\\(\")\n        var current_group = \"\"\n        var group_string = \"\"\n\
    \        var result: List[String] = List()\n        for (group_str <- group_strings)\
    \ {\n            if (group_str.length == 1) {\n                current_group +=\
    \ group_str\n            } else {\n                if (current_group != \"\")\
    \ {\n                    result += current_group\n                }\n        \
    \        current_group = group_str\n            }\n        }\n        if (current_group\
    \ != \"\") {\n            result += current_group\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppkpaf89i.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    result += current_group\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppkpaf89i.scala:26:19 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            result += current_group\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack: List[String] = Nil\n      \
    \  paren_string.foreach {x => if(x.equals(')')) { stack :+ x }\n        else if(\
    \ x.equals('(') ) { stack = stack :+ x }\n        else if( !stack.isEmpty && x.equals('(')\
    \ && stack.isEmpty) { stack.head :+ x }\n        else { stack :+ x }\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc8cpm2b7.scala:13:52\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m( x.equals(\e[31m'('\e[0m) ) { stack = stack :+ x }\n\e[31m\e[31m   |\e[0m\
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   Found:    (x : Char)\n\e[31m\
    \   |\e[0m                                                    Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val paren_groups = paren_string.split(\"\
    \ \").map(x => x.split(\"(\")).map(x => x.map(y => y.trim))\n      paren_groups.foldLeft(List[String]()){\n\
    \        case (acc, elem) =>\n          if(elem.head.length == 1 && elem.last.length\
    \ == 1) acc ::: (elem.last.head)\n          else if(elem.head.length == 1 && !elem.last.length)\
    \ acc ::: (elem.head.last)\n          else if(elem.head.length == elem.last.length)\
    \ acc ::: (elem.last.head) ::: elem.last.last\n          else paren_groups\n \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgald4i3.scala:14:65 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m          \e[33mif\e[0m(elem.head.length == \e[31m1\e\
    [0m && elem.last.length == \e[31m1\e[0m) acc ::: (elem.last.head)\n\e[31m\e[31m\
    \   |\e[0m                                                                 ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       value ::: is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgald4i3.scala:15:43\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m          \e[33melse\e[0m\
    \ \e[33mif\e[0m(elem.head.length == \e[31m1\e[0m && !elem.last.length) acc :::\
    \ (elem.head.last)\n\e[31m\e[31m   |\e[0m                                    \
    \       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value unary_! is not a\
    \ member of Int - did you mean Int.unary_+?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmptgald4i3.scala:15:66 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m          \e[33melse\e[0m \e[33mif\e[0m(elem.head.length == \e[31m1\e[0m &&\
    \ !elem.last.length) acc ::: (elem.head.last)\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       value ::: is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgald4i3.scala:16:81\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m          \e[33melse\e[0m\
    \ \e[33mif\e[0m(elem.head.length == elem.last.length) acc ::: (elem.last.head)\
    \ ::: elem.last.last\n\e[31m\e[31m   |\e[0m                                  \
    \                                               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value ::: is not a member of\
    \ Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptgald4i3.scala:17:15\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m          \e[33melse\e[0m paren_groups\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \        Found:    (paren_groups : Array[Array[String]])\n\e[31m   |\e[0m    \
    \           Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ av"
  stdout: ''
  timestamp: 1660013526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val group_list = mutable.MutableList[String]()\n\
    \        for (i <- 1 to paren_string.length-1) {\n            if (paren_string(i)\
    \ == '(') {\n                if (paren_string(i+1).isLetter) {\n             \
    \       paren_string += paren_string(i+1)\n                    group_list += paren_string(i+1)\n\
    \                    paren_string = paren_string.slice(0,i+1)\n              \
    \  }\n            }\n            if (paren_string(i) == ')') {\n             \
    \   paren_string = paren_string.slice(0,i)\n            }\n        }\n       \
    \ group_list += paren_string\n        val group_string = paren_string.slice(0,paren_string.length-1)\n\
    \        val group_string_rest = paren_string.slice(paren_string.length-1)\n \
    \       group_list.toList.flatMap(_.split(' '))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj38_casq.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mgroup_list\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpj38_casq.scala:15:33 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    paren_string += paren_string(i+\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m      value += is not a member of String - did you mean paren_string.!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpj38_casq.scala:17:33 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                    paren_string = paren_string.slice(\e\
    [31m0\e[0m,i+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val paren_string\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpj38_casq.scala:21:29 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                paren_string = paren_string.slice(\e\
    [31m0\e[0m,i)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val paren_string\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpj38_casq.scala:26:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mgroup_string_rest\e[0m =\
    \ paren_string.slice(paren_string.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmissing argument for parameter until of \e[33mmethod\e[0m \e[35mslice\e\
    [0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (from: Int, until: Int): String\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660013526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var output: List[String] = Nil\n\n   \
    \     val opening_closing_pairs = paren_string.split(\"\\\\(\").map(x => (x.replaceAll(\"\
    \\\\(|\\\\)\", \"\"), x)).groupBy(x => x._1)\n\n        for (opening_closing_pair\
    \ <- opening_closing_pairs) {\n            val open_string = opening_closing_pair._2.replaceAll(\"\
    \\\\(|\\\\)\", \"\").trim\n            val close_string = opening_closing_pair._2.replaceAll(\"\
    \\\\(|\\\\)\", \"\").trim\n            val close = close_string.split(\" \").map(x\
    \ => x.replaceAll(\"\\\\(|\\\\)\", \"\").trim)\n\n            if(open_string.equals(close_string))\
    \ {\n                output += open_string\n            } else {\n           \
    \     output += open_string + close\n            }\n        }\n\n        output\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0_en4sf.scala:16:54 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mopen_string\e[0m = opening_closing_pair._2.replaceAll(\e\
    [31m\"\\\\(|\\\\)\"\e[0m, \e[31m\"\"\e[0m).trim\n\e[31m\e[31m   |\e[0m       \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             value replaceAll is not a member of Array[(String, String)]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0_en4sf.scala:17:55 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mclose_string\e[0m =\
    \ opening_closing_pair._2.replaceAll(\e[31m\"\\\\(|\\\\)\"\e[0m, \e[31m\"\"\e\
    [0m).trim\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             value replaceAll is not a member of Array[(String,\
    \ String)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0_en4sf.scala:21:23\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                output +=\
    \ open_string\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0_en4sf.scala:23:23 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                output += open_string + close\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a\
    \ member of List[String] - did you mean List[String].!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660013527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    [()]\")\n        var paren_group: List[String] = Nil\n        var open_paren =\
    \ 0\n        for (paren_string <- paren_groups)\n        {\n            paren_string.trim()\n\
    \            if (paren_string != \"\")\n            {\n                if (paren_group.isEmpty)\n\
    \                {\n                    paren_group = List(paren_string)\n   \
    \             }\n                else if (open_paren > 0 && paren_group.isEmpty)\n\
    \                {\n                    paren_group = List(paren_group.head)\n\
    \                }\n                else if (paren_group.isEmpty)\n          \
    \      {\n                    open_paren -= 1\n                }\n           \
    \     else if (paren_group.isEmpty && open_paren == 0)\n                {\n  \
    \                  open_paren += 1\n                }\n                else\n\
    \                {\n                    open_paren += 1\n                    paren_group.insert(open_paren,\
    \ paren_string)\n                }\n            }\n        }\n        return paren_group.distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3un2yf0m.scala:38:32 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    paren_group.insert(open_paren, paren_string)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue insert is not a member of List[String] - did you mean List[String].init?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_group_stack = mutable.Stack[String]()\n\
    \        var paren_group_result: List[String] = List()\n        for (paren_group\
    \ <- paren_string.split(' ')) {\n            if (paren_group.startsWith(\"(\"\
    )) {\n                paren_group_result ::= paren_group\n                paren_group_stack.push(paren_group)\n\
    \            } else if (paren_group.endsWith(\")\")) {\n                paren_group_result\
    \ ::= paren_group_stack.pop()\n            }\n        }\n        paren_group_result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphqgalpgi.scala:11:32 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_group_stack\e[0m =\
    \ mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                                Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        //split string by space and keep space\
    \ and bracket\n        val tokens = paren_string.split(\" \").filter(s => s !=\
    \ \"\")\n        val brackets = mutable.ListBuffer[String]()\n        //add parentheses\
    \ to list for left paren\n        for(i <- 0 until tokens.length - 1){\n     \
    \       if(tokens(i) == \"(\"){\n                brackets += \"(\"\n         \
    \   }\n            else{\n                brackets += \"[\"\n            }\n \
    \       }\n        //add brackets to list for right paren\n        for(i <- tokens.length\
    \ - 1 until tokens.length){\n            if(tokens(i) == \")\"){\n           \
    \     brackets += \"]\"\n            }\n            else{\n                brackets\
    \ += \"]\"\n            }\n        }\n        //now we create a list of strings.\
    \ Each string has brackets in it. Now we simply remove braces\n        //from\
    \ each string and concatenate all the strings. We should have a list of string\
    \ that are\n        //separated by parenthesis.\n        val listOfStrings = for\
    \ (t <- tokens) yield \"(\" + brackets.toList.mkString(\"\") + \")\"\n       \
    \ listOfStrings.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_wh_qb2t.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbrackets\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.length == 0)\n      \
    \      return Nil\n        val groups = paren_string.split(\"\\\\)\")\n      \
    \  val res = []\n        for (group <- groups) {\n            if (group.startsWith(\"\
    (\")) {\n                val index = groups.indexOf(group).asInstanceOf[Int]\n\
    \                val open_braces = groups.lastIndex - index\n                if\
    \ (open_braces == 0) {\n                    // This group is a standalone opening\
    \ (\n                    res.append(group)\n                } else {\n       \
    \             // This group is balanced. Move it to the front\n              \
    \      val new_group = groups(index - 1)\n                    val new_groups =\
    \ groups.drop(index - 1)\n                    val new_res = res.reverse.slice(0,\
    \ open_braces + 1).reverse.take(open_braces + 1)\n                    new_res.append(new_group)\n\
    \                    val new_group_string = groups.take(open_braces + 1).mkString(\"\
    (\", \")\") + groups.drop(open_braces + 1)\n                    val new_res_list\
    \ = separateParenGroups(new_group_string)\n                    new_res.append(new_res_list)\n\
    \                }\n            } else {\n                res.append(group)\n\
    \            }\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpethx3gi8.scala:14:19 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpethx3gi8.scala:15:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mfor\e[0m\
    \ (group <- groups) {\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected,\
    \ but 'end of statement' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpethx3gi8.scala:18:41\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e\
    [0m \e[36mopen_braces\e[0m = groups.lastIndex - index\n\e[31m\e[31m   |\e[0m \
    \                                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value lastIndex is not a member of Array[String]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpethx3gi8.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    res.append(group)\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not\
    \ a member of Null, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpethx3gi8.scala:26:38\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    \e[33mval\e\
    [0m \e[36mnew_res\e[0m = res.reverse.slice(\e[31m0\e[0m, open_braces + \e[31m1\e\
    [0m).reverse.take(open_braces + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue reverse is not\
    \ a member of Null, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\
    \e[31m   |\e[0m  import math.Ordering.Im"
  stdout: ''
  timestamp: 1660013532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List.empty[String]\n    \
    \    val paren_chars = paren_string\n        paren_chars.foreach {\n         \
    \   case c: Char =>\n                if( c == '(') {\n                    groups\
    \ = groups ::: List()\n                }\n                else {\n           \
    \         if( groups.length == 0)\n                        groups = List(c.toString)\n\
    \                    else if( groups.length == 1 && groups(0) == \"()\" )\n  \
    \                      groups = List(c.toString)\n                    else if(\
    \ groups.last.startsWith(\"(\") && groups.last.length() > 1 )\n              \
    \          groups = List(groups.last + c.toString)\n                    else if(\
    \ groups.last.startsWith(\"(\") && groups.last.length() < 1 )\n              \
    \          groups = List(c.toString)\n                    else {\n           \
    \             if( groups.last == (\"())\") && groups.last.length() > 1 )\n   \
    \                         groups = List(groups.last + c.toString)\n          \
    \              else if( groups.last == (\"())\") && groups.last.length() < 1 )\n\
    \                            groups = List(groups.last + c.toString)\n       \
    \                 else if( groups.last == (\"())()\") && groups.last.length()\
    \ > 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else if( groups.last == (\"())()\") && groups.last.length()\
    \ < 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else if( groups.last == (\"(())\") && groups.last.length()\
    \ > 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else if( groups.last == (\"(())\") && groups.last.length()\
    \ < 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else\n                            groups = groups :::\
    \ List(c.toString)\n                    }\n                }\n            case\
    \ _ : String =>\n                groups = groups ::: List()\n        }\n     \
    \   groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[33m\e[33m-- [E030] Match case Unreachable Warning: /tmp/tmpm73eubps.scala:44:17\
    \ ---------\e[0m\e[0m\n\e[33m44 |\e[0m            \e[33mcase\e[0m _ : String =>\n\
    \e[33m\e[33m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[33m   |\e[0m       \
    \          Unreachable case\n\e[31m\e[31m-- Error: /tmp/tmpm73eubps.scala:44:17\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m44 |\e[0m       \
    \     \e[33mcase\e[0m _ : String =>\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        cannot test if value of type Char is a reference of\
    \ \e[33mclass\e[0m \e[35mString\e[0m\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660013529
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_stack = ListBuffer[String]()\n\
    \n        for(i <- 1 to paren_string.length){\n            if(paren_string.charAt(i)\
    \ == '('){\n                paren_stack += paren_string.substring(0,i)\n     \
    \       }else if(paren_string.charAt(i) == ')'){\n                paren_stack\
    \ += paren_string.substring(0,i)\n            }\n        }\n        paren_stack.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 27\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat Problem$.separateParenGroups$$anonfun$1(tmpg8kestrl.scala:14)\n\tat Problem$.separateParenGroups$$anonfun$adapted$1(tmpg8kestrl.scala:19)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.separateParenGroups(tmpg8kestrl.scala:19)\n\
    \tat Problem$.main(tmpg8kestrl.scala:23)\n\tat Problem.main(tmpg8kestrl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = Nil\n    \
    \    var open_count : Int = 0\n        var open_parens : List[String] = Nil\n\
    \        var is_close_parens : List[Boolean] = Nil\n        for (i <- 0 to paren_string.length\
    \ - 1) {\n            if (paren_string(i) == paren_string(i+1)) {\n          \
    \      open_count += 1\n            } else {\n                if (open_count >\
    \ 0) {\n                    if (open_parens != Nil) {\n                      \
    \  result += open_parens\n                        open_parens = Nil\n        \
    \            }\n                    result += Nil\n                    open_count\
    \ = 0\n                }\n                open_parens = open_parens :+ paren_string(i)\n\
    \            }\n\n            is_close_parens = is_close_parens :+ paren_string(i+1)\
    \ != paren_string(i)\n        }\n        if (open_count > 0) {\n            if\
    \ (open_parens != Nil) {\n                result += open_parens\n            }\n\
    \        }\n        result :+ paren_string.take(paren_string.length-open_count).filterNot(_\
    \ == \")\").toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxtw_2os.scala:21:31 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                        result += open_parens\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is\
    \ not a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpqxtw_2os.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    result += Nil\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpqxtw_2os.scala:27:57 --------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m                open_parens = open_parens :+ paren_string(i)\n\e\
    [31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Char\n\
    \e[31m   |\e[0m                                             Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpqxtw_2os.scala:30:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            is_close_parens = is_close_parens :+ paren_string(i+\e\
    [31m1\e[0m) != paren_string(i)\n\e[31m\e[31m   |\e[0m                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m  Values of types List[AnyVal] and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxtw_2os.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                result += open_parens\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- Error: /tmp/tmpqxtw_2os.scala:37:78\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \ result :+ paren_string.take(paren_string.length-open_count).filterNot(_ == \e\
    [31m\")\"\e[0m).toList\n\e[31m\e[31m   |\e[0m                                \
    \                     "
  stdout: ''
  timestamp: 1660013534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.flatMap { s =>\n        \
    \    if(s.startsWith(\"(\") && s.endsWith(\")\"))\n                List(s)\n \
    \           else if(s.startsWith(\"(\"))\n                List(s, \"\")\n    \
    \        else if(s.endsWith(\")\"))\n                List(\"\", s)\n         \
    \   else\n                List(\"\", s)\n        }.filter(s => s.nonEmpty).filter(s\
    \ => s.head != \"(\").filter(s => s.head != \")\").filter(s => s.head != \"()\"\
    ).filter(s => s.head != \")()\").filter(s => s.head != \"()()\").filter(s => s.head\
    \ != \"(())\").filter(s => s.head != \")()()\").filter(s => s.head != \"()()()\"\
    ).filter(s => s.head != \"(())()\").filter(s => s.head != \")()()()\").filter(s\
    \ => s.head != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head\
    \ != \")()()()\").filter(s => s.head != \"()()()()\").filter(s => s.head != \"\
    (())()()\").filter(s => s.head != \")()()()()\").filter(s => s.head != \"()()()()\"\
    ).filter(s => s.head != \"(())()()\").filter(s => s.head != \")()()()()\").filter(s\
    \ => s.head != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head\
    \ != \")()()()()\").filter(s => s.head != \"()()()()\").filter(s => s.head !=\
    \ \"(())()()\").filter(s => s.head != \")()()()()\").filter(s => s.head != \"\
    ()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head != \")()()()()\"\
    ).filter(s => s.head != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s\
    \ => s.head != \")()()()()\").filter(s => s.head != \"()()()()\").filter(s =>\
    \ s.head != \"(())()()\").filter(s => s.head != \")()()()()\").filter(s => s.head\
    \ != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head != \"\
    )()()()()\").filter(s => s.head != \"()()()()\").filter(s => s.head != \"(())()()\"\
    ).filter(s => s.head != \")()()()()\").filter(s => s.head != \"()()\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpsyrfx6z5.scala:20:1383 ---------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        }.filter(s => s.nonEmpty).filter(s => s.head\
    \ != \e[31m\"(\"\e[0m).filter(s => s.head != \e[31m\")\"\e[0m).filter(s => s.head\
    \ != \e[31m\"()\"\e[0m).filter(s => s.head != \e[31m\")()\"\e[0m).filter(s =>\
    \ s.head != \e[31m\"()()\"\e[0m).filter(s => s.head != \e[31m\"(())\"\e[0m).filter(s\
    \ => s.head != \e[31m\")()()\"\e[0m).filter(s => s.head != \e[31m\"()()()\"\e\
    [0m).filter(s => s.head != \e[31m\"(())()\"\e[0m).filter(s => s.head != \e[31m\"\
    )()()()\"\e[0m).filter(s => s.head != \e[31m\"()()()()\"\e[0m).filter(s => s.head\
    \ != \e[31m\"(())()()\"\e[0m).filter(s => s.head != \e[31m\")()()()\"\e[0m).filter(s\
    \ => s.head != \e[31m\"()()()()\"\e[0m).filter(s => s.head != \e[31m\"(())()()\"\
    \e[0m).filter(s => s.head != \e[31m\")()()()()\"\e[0m).filter(s => s.head != \e\
    [31m\"()()()()\"\e[0m).filter(s => s.head != \e[31m\"(())()()\"\e[0m).filter(s\
    \ => s.head != \e[31m\")()()()()\"\e[0m).filter(s => s.head != \e[31m\"()()()()\"\
    \e[0m).filter(s => s.head != \e[31m\"(())()()\"\e[0m).filter(s => s.head != \e\
    [31m\")()()()()\"\e[0m).filter(s => s.head != \e[31m\"()()()()\"\e[0m).filter(s\
    \ => s.head != \e[31m\"(())()()\"\e[0m).filter(s => s.head != \e[31m\")()()()()\"\
    \e[0m).filter(s => s.head != \e[31m\"()()()()\"\e[0m).filter(s => s.head != \e\
    [31m\"(())()()\"\e[0m).filter(s => s.head != \e[31m\")()()()()\"\e[0m).filter(s\
    \ => s.head != \e[31m\"()()()()\"\e[0m).filter(s => s.head != \e[31m\"(())()()\"\
    \e[0m).filter(s => s.head != \e[31m\")()()()()\"\e[0m).filter(s => s.head != \e\
    [31m\"()()()()\"\e[0m).filter(s => s.head != \e[31m\"(())()()\"\e[0m).filter(s\
    \ => s.head != \e[31m\")()()()()\"\e[0m).filter(s => s.head != \e[31m\"()()()()\"\
    \e[0m).filter(s => s.head != \e[31m\"(())()()\"\e[0m).filter(s => s.head != \e\
    [31m\")()()()()\"\e[0m).filter(s => s.head != \e[31m\"()()()()\"\e[0m).filter(s\
    \ => s.head != \e[31m\"(())()()\"\e[0m).filter(s => s.head != \e[31m\")()()()()\"\
    \e[0m).filter(s => s.head != \"()()\n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \                                                                          "
  stdout: ''
  timestamp: 1660013538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_groups: List[String] = Nil\n\
    \        paren_string.splitWhile(c => !(\"(\" < c && c <= \"(\"))\n          \
    \  .foreach { str =>\n                if(str.startsWith(\"(\") && str.endsWith(\"\
    )\")) {\n                    paren_groups = paren_groups :+ str\n            \
    \    }\n            }\n        paren_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpolw44w1e.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        paren_string.splitWhile(\e[36mc\e[0m => !(\e\
    [31m\"(\"\e[0m < c && c <= \e[31m\"(\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value splitWhile is not a member of String\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_stack = mutable.Stack[String]()\n\
    \        paren_string match {\n            case \"\" => Nil\n            case\
    \ _ =>\n                for (char <- paren_string.toCharArray) {\n           \
    \         if (char == '(') paren_stack.push(char)\n                    if (char\
    \ == ')') paren_stack match {\n                        case Nil => paren_string\
    \ match {\n                            case \"\" => Nil\n                    \
    \        case _ => Nil\n                        }\n                        case\
    \ _ =>\n                            val newParen = paren_stack.pop()\n       \
    \                     paren_string = newParen + char\n                       \
    \     if (newParen != \"\") paren_stack.push(newParen)\n                    }\n\
    \                }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyp1hy36f.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpyp1hy36f.scala:24:41 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                            paren_string = newParen +\
    \ char\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Reassignment to val paren_string\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpyp1hy36f.scala:19:39\
    \ ----------------\e[0m\e[0m\n\e[33m19 |\e[0m                            \e[33mcase\e\
    [0m \e[31m\"\"\e[0m => Nil\n\e[33m\e[33m   |\e[0m                            \
    \           ^^^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement\
    \ position; you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpyp1hy36f.scala:20:38 ----------------\e\
    [0m\e[0m\n\e[33m20 |\e[0m                            \e[33mcase\e[0m _ => Nil\n\
    \e[33m\e[33m   |\e[0m                                      ^^^\e[0m\n\e[33m  \
    \ |\e[0mA pure expression does nothing in statement position; you may be omitting\
    \ necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 warnings found\n2 errors found\n"
  stdout: ''
  timestamp: 1660013533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val group_stack = mutable.Stack[String]()\n\
    \        val result_list = mutable.ListBuffer[String]()\n        var temp_str\
    \ : String = \" \"\n\n        for (i <- 0 until paren_string.length) {\n     \
    \       // If the next character is an opening paren, add it to the group\n  \
    \          if (paren_string(i) == '(') {\n                group_stack += '('\n\
    \                temp_str = \"\"\n            } else {\n                temp_str\
    \ = temp_str + paren_string(i)\n            }\n\n            // If the next character\
    \ is a closing paren, pop one level\n            if (paren_string(i) == ')') {\n\
    \                val last_char = group_stack.pop()\n                // If the\
    \ last character, a left brace, was not a left brace, then\n                //\
    \ this paren was not a proper group of paren\n                if (last_char !=\
    \ '(') result_list += temp_str + \")\"\n                else {\n             \
    \       // If the last character was a left brace, then\n                    //\
    \ this paren was properly closed, so add it to the result list\n             \
    \       result_list += temp_str\n                }\n                temp_str =\
    \ \" \"\n            }\n        }\n\n        // If there's a left brace on the\
    \ stack, then there were too many close parens.\n        // If the last item on\
    \ the stack is a right brace, then it didn't close enough\n        // parens.\n\
    \        if (group_stack.last == '(') result_list += temp_str + \")\"\n      \
    \  else result_list.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo08xcatv.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mgroup_stack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpo08xcatv.scala:12:26 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Base Case\n        if (paren_string.isEmpty)\
    \ {\n            return Nil\n        }\n        // Check for opening braces and\
    \ closing braces\n        val opening_braces = paren_string.substring(0, paren_string.length-1)\n\
    \            .split(\"(?<=\\\\))\")\n            .map(x => paren_string.substring(0,\
    \ paren_string.length - x.length))\n            .filter(_ != \"\")\n        if\
    \ (opening_braces.size != opening_braces.toList.size) {\n            return Nil\n\
    \        }\n        val closing_braces = paren_string.substring(paren_string.length-1,\
    \ paren_string.length).split(\"(?<=\\\\()\")\n            .filter(x => !x.isEmpty)\n\
    \            .map(x => paren_string.substring(paren_string.length-x.length, paren_string.length))\n\
    \        if (closing_braces.size != closing_braces.toList.size) {\n          \
    \  return Nil\n        }\n        val result = closing_braces.map(x => opening_braces.dropRight(closing_braces.indexOf(x)).mkString(\"\
    \")) ::: opening_braces.filter(_ != \"\").map(x => x)\n        return result.filter(x\
    \ => !x.isEmpty)\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqi4htgoj.scala:29:111 -----------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = closing_braces.map(\e\
    [36mx\e[0m => opening_braces.dropRight(closing_braces.indexOf(x)).mkString(\e\
    [31m\"\"\e[0m)) ::: opening_braces.filter(_ != \e[31m\"\"\e[0m).map(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m                                             \
    \                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value ::: is not a member of\
    \ Array[String]\n1 error found\n"
  stdout: ''
  timestamp: 1660013536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // initialize a list to hold the separate\
    \ groups\n        var groups: List[String] = Nil\n\n        // use some basic\
    \ pattern matching to find the groups\n        paren_string.trim match {\n   \
    \         case \"\" => Nil\n            case \")\" =>\n                groups\
    \ = groups :+ \")\"\n            case \")(\") =>\n                groups = groups\
    \ :+ \")(\"\n            case \")(\") => groups = groups :+ \")(\"\n         \
    \   case \")(\") => groups = groups :+ \")(\"\n            case \")(\") => groups\
    \ = groups :+ \")(\"\n            case _ => // keep matching until the parens\
    \ are closed\n                paren_string.split(\"\"\"[(][)]\"\"\").map(_.trim).toList\
    \ match {\n                    case Nil => Nil\n                    case parens\
    \ => parens.map(_.trim) match {\n                        case Nil => Nil\n   \
    \                     case _ =>\n                            // check if we have\
    \ closed parens on the right side\n                            if ((parens.head.length\
    \ == parens.last.length) &&\n                                (parens.head == parens.last.tail.head))\
    \ {\n                                // if so, add the closing paren to the list\n\
    \                                groups = groups :+ parens.last\n            \
    \                } else {\n                                // otherwise, add a\
    \ new item to the list\n                                groups = groups :+ \"\
    )\"\n                            }\n                    }\n                }\n\
    \        }\n\n        // return the groups\n        return groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpl2sy2g.scala:19:21 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m \e[31m\")(\"\e[0m) =>\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m              \
    \       '=>' expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpl2sy2g.scala:21:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e\
    [0m \e[31m\")(\"\e[0m) => groups = groups :+ \e[31m\")(\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     '=>'\
    \ expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpl2sy2g.scala:22:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e\
    [0m \e[31m\")(\"\e[0m) => groups = groups :+ \e[31m\")(\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     '=>'\
    \ expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpl2sy2g.scala:23:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e\
    [0m \e[31m\")(\"\e[0m) => groups = groups :+ \e[31m\")(\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     '=>'\
    \ expected, but ')' found\n\e[31m\e[31m-- Error: /tmp/tmpnpl2sy2g.scala:32:33\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \                         (parens.head == parens.last.tail.head)) {\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n5 errors found\n"
  stdout: ''
  timestamp: 1660013536
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack: Stack[String] = new Stack[String]()\n\
    \        val strings: List[String] = paren_string.split(\"\"\"\\s+\"\"\").toList\n\
    \        strings.foreach{ s =>\n            val new_string: List[String] = s.split(\"\
    \"\"\\(|\\)\"\"\").toList\n            val paren_open: List[String] = new_string.takeWhile(_\
    \ != \"(\")\n            val paren_close: List[String] = new_string.dropWhile(_\
    \ != \")\")\n            if (paren_close.isEmpty) stack += \"(\" + s + \"()\"\n\
    \            else {\n                val paren_open_without_close = paren_open.takeRight(1)\n\
    \                val close_brace = paren_close.last\n                val open_paren\
    \ = paren_open.last\n                stack += \"(\" + open_paren + \")\"\n   \
    \             stack += close_brace\n            }\n        }\n        strings.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp_ym7bca.scala:29)\n\tat Problem.main(tmpp_ym7bca.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_open = mutable.ListBuffer[String]()\n\
    \        val paren_close = mutable.ListBuffer[String]()\n\n        paren_string.split(\"\
    [()]\").foreach(s => {\n            val new_s = if (s.startsWith(\"(\"))\n   \
    \             paren_open += s\n            else if (s.endsWith(\")\"))\n     \
    \           paren_close += s\n            else if (paren_open.nonEmpty && paren_close.nonEmpty)\n\
    \                paren_open += s.stripPrefix(\"(\").stripSuffix(\")\")\n     \
    \   })\n\n        paren_open.distinct\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr6eg2lej.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_open\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpr6eg2lej.scala:12:26 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_close\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def paren_stack = new Stack[String]()\n\
    \        def paren_levels = new mutable.Stack[Int]()\n\n        paren_string.split(\"\
    \"\"\\s+\"\"\").map(x => {\n            if(x.equals(\"\"))\n                return\
    \ List()\n            if(paren_stack.isEmpty)\n                paren_levels.push(0)\n\
    \            if(paren_stack.isEmpty)\n                paren_stack.push(x.charAt(0))\n\
    \            if(paren_levels.isEmpty)\n                paren_levels.push(0)\n\
    \            if(x.equals(paren_stack.pop()))\n                paren_levels -=\
    \ 1\n            if(paren_levels.isEmpty)\n                paren_stack.push(x.charAt(0))\n\
    \            else\n                paren_levels.push(paren_levels.pop() + 1)\n\
    \        })\n            .filter(x => x != \"\")\n            .map(x => paren_stack.pop())\n\
    \            .filter(x => x != \"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9lx0b_l4.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mdef\e[0m \e[36mparen_levels\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9lx0b_l4.scala:20:41\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                paren_stack.push(x.charAt(\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    Char\n\e[31m  \
    \ |\e[0m                                 Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9lx0b_l4.scala:26:41 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                paren_stack.push(x.charAt(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    Char\n\e[31m   |\e[0m   \
    \                              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp9lx0b_l4.scala:30:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            .filter(x => x != \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ scala.collection.mutable.Stack[String] and String cannot be compared with ==\
    \ or !=\n4 errors found\n"
  stdout: ''
  timestamp: 1660013537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_array = paren_string.split(\"\
    \\\\)\\\\(\")\n        val result_list : List[String] = Nil\n        val open_braces_array\
    \ : List[Array[Int]] = paren_array.toArray.map(_ => {\n            val open_brace\
    \ = paren_array.length\n            val close_brace = open_brace - 1\n       \
    \     (open_brace, close_brace)\n        })\n        val open_braces : List[Int]\
    \ = open_braces_array.toList\n\n        // Find any left open braces in the array\
    \ (indicated by -1 value in array). For every open brace that is\n        // left\
    \ open, add all remaining close_braces to the result list.\n        for (open_count\
    \ <- open_braces.indices) {\n            val open_brace : Int = open_braces(open_count)\n\
    \            if (open_brace > -1) {\n                val close_brace : Int = open_braces(open_count\
    \ + 1)\n                result_list ++= paren_array.slice(1, close_brace).map(s\
    \ => s.trim).filter(!_.isEmpty)\n            }\n        }\n        return result_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt21fy4vb.scala:13:51\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mopen_braces_array\e\
    [0m : \e[35mList\e[0m[\e[35mArray\e[0m[\e[35mInt\e[0m]] = paren_array.toArray.map(_\
    \ => {\n\e[31m\e[31m   |\e[0m                                                \
    \   ^\e[0m\n\e[31m   |\e[0m                                             Found:\
    \    Array[(Int, Int)]\n\e[31m   |\e[0m                                      \
    \       Required: List[Array[Int]]\n\e[31m14 |\e[0m            \e[33mval\e[0m\
    \ \e[36mopen_brace\e[0m = paren_array.length\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36mclose_brace\e[0m = open_brace - \e[31m1\e[0m\n\e[31m16 |\e[0m      \
    \      (open_brace, close_brace)\n\e[31m17 |\e[0m        })\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt21fy4vb.scala:18:56 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen_braces\e[0m : \e[35mList\e\
    [0m[\e[35mInt\e[0m] = open_braces_array.toList\n\e[31m\e[31m   |\e[0m        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    List[\e[1m\e[31mArray\e[0m\e\
    [1m\e[31m[\e[0mInt\e[1m\e[31m]\e[0m]\n\e[31m   |\e[0m                        \
    \              Required: List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpt21fy4vb.scala:26:28 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m                result_list ++= paren_array.slice(\e[31m1\e[0m, close_brace).map(\e\
    [36ms\e[0m => s.trim).filter(!_.isEmpty)\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ++= is not a member of List[String]\
    \ - did you mean result_list.++?\n3 errors found\n"
  stdout: ''
  timestamp: 1660013539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def groupList(n: Int, paren_string : String)\
    \ : List[String] = {\n            val l = paren_string.length\n            val\
    \ groups = List.fill(n)(\"()\")\n            for (i<- 0 until paren_string.length)\
    \ {\n                if (paren_string(i) == '(') {\n                    if (paren_string(i+1).equals('('))\
    \ {\n                        groups(i) = paren_string(i+1)\n                 \
    \   }\n                    else {\n                        groups(i) = \"(\"\n\
    \                        groupList(i + 1, paren_string)\n                    }\n\
    \                }\n                else {\n                    if (paren_string(i).equals(')'))\
    \ {\n                        groups(i) = \")\"\n                        if (groups(i-1)\
    \ == \"(\") {\n                            groupList(i-1, paren_string)\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n            groups\n        }\n        groupList(0, paren_string)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc39h4eyb.scala:17:24 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                        groups(i) = paren_string(i+\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue update is not a member of List[String] - did you mean groups.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc39h4eyb.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                        groups(i) = \e[31m\"(\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[String] - did you mean groups.updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpc39h4eyb.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        groups(i) = \e[31m\")\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[String] - did you mean groups.updated?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var group_list : List[String] = Nil\n\
    \        var open_count = paren_string.count(\"(\")\n        var close_count =\
    \ paren_string.count(\")\")\n        var open_balance = 0\n        var close_balance\
    \ = 0\n\n        for ( _ <- 0 until close_count ) {\n            if ( paren_string.charAt(close_count\
    \ - _) == '(' ) {\n                close_balance += 1\n            } else if (\
    \ paren_string.charAt(close_count - _) == ')' ) {\n                close_balance\
    \ -= 1\n            }\n        }\n\n        for ( _ <- 0 until open_count ) {\n\
    \            if ( paren_string.charAt(open_count - _) == '(' ) {\n           \
    \     open_balance += 1\n            } else if ( paren_string.charAt(open_count\
    \ - _) == ')' ) {\n                open_balance -= 1\n            }\n        }\n\
    \n        open_count -= close_count\n\n        for( i <- 0 to open_count ) {\n\
    \            if ( open_balance >= 0 ) {\n                group_list.append ( paren_string.charAt(open_count\
    \ + i) ) \n            } else {\n                group_list.append ( paren_string.charAt(open_count\
    \ + i) ) \n            }\n        }\n\n        if ( open_balance >= 0 ) {\n  \
    \          for ( _ <- 0 until close_count ) {\n                if ( paren_string.charAt(close_count\
    \ - _) == '(' ) {\n                    close_balance += 1\n                } else\
    \ if ( paren_string.charAt(close_count - _) == ')' ) {\n                    close_balance\
    \ -= 1\n                }\n            }\n        }\n\n        group_list.\n \
    \           map( x => paren_string.substring(close_count + x+1, close_count +\
    \ x + open_count + 1) ).\n            filter( x => !x.equals(\"\") ).\n      \
    \      toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxj5fqlqb.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mopen_count\e\
    [0m = paren_string.count(\e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                                ^^^\e[0m\n\e[31m   |\e[0m                   \
    \                         Found:    (\e[32m\"(\"\e[0m : String)\n\e[31m   |\e\
    [0m                                            Required: Char => Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxj5fqlqb.scala:13:45 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mclose_count\e[0m = paren_string.count(\e\
    [31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \      ^^^\e[0m\n\e[31m   |\e[0m                                             Found:\
    \    (\e[32m\")\"\e[0m : String)\n\e[31m   |\e[0m                            \
    \                 Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmpxj5fqlqb.scala:18:51 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m ( paren_string.charAt(close_count\
    \ - _) == \e[31m'('\e[0m ) {\n\e[31m\e[31m   |\e[0m                          \
    \                         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1\
    \ of expanded function:\n\e[31m   |\e[0m   _$1 => close_count - _$1.\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpxj5fqlqb.scala:20:58 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m ( paren_string.charAt(close_count\
    \ - _) == \e[31m')'\e[0m ) {\n\e[31m\e[31m   |\e[0m                          \
    \                                ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => close_count - _$2.\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpxj5fqlqb.scala:26:50 ------------------"
  stdout: ''
  timestamp: 1660013540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Use a stack to store the parens\n \
    \       val parens = new mutable.Stack[String]\n        // Push each paren in\
    \ the parens stack\n        for (c <- paren_string) {\n            if (c == '(')\n\
    \                parens.push(c)\n            else if (c == ')') {\n          \
    \      // Pop the stack until '(' is found\n                while (!parens.isEmpty\
    \ && parens.head != '(')\n                    parens.pop\n            }\n    \
    \    }\n        // Add the first paren at the top of the stack\n        parens.push('(')\n\
    \        val result = ListBuffer[String]()\n        // Add the first paren at\
    \ the top of the result list\n        result += '('\n        // Iterate through\
    \ all remaining parens\n        while (parens.nonEmpty) {\n            // Get\
    \ the current paren from the stack\n            val current_paren = parens.pop\n\
    \            // If this is the last paren encountered, add the paren at the end\
    \ of the result\n            if (parens.isEmpty)\n                result += current_paren\n\
    \            // Else if this is an open paren, then add it at the start of the\
    \ result list\n            else if (current_paren == '(')\n                result\
    \ += current_paren\n            // Otherwise, add the paren to the result list\n\
    \            else {\n                // If the current paren is not an open paren,\
    \ then close the paren in the result list and open a new one\n               \
    \ if (current_paren != ')')\n                    result += current_paren\n   \
    \             result += '('\n            }\n        }\n        // Return the result\
    \ list\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq50bh_h4.scala:12:25 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq50bh_h4.scala:27:18\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        result += \e[31m'('\e\
    [0m\n\e[31m\e[31m   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m        \
    \          Found:    (\e[31m'('\e[0m : Char)\n\e[31m   |\e[0m                \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq50bh_h4.scala:43:26\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                result += \e\
    [31m'('\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    (\e[31m'('\e[0m : Char)\n\e[31m\
    \   |\e[0m                          Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize empty list\n        var\
    \ paren_groups: List[String] = Nil\n\n        // Loop through all the characters\
    \ in the input string\n        for(c: String <- paren_string) {\n            switch(c)\
    \ {\n                // If c is a left parenthesis, then append it to paren_groups\n\
    \                case '(': paren_groups = paren_groups ::: List(c)\n         \
    \       // If c is a right parenthesis, then add c to paren_groups if it isn't\
    \ already there\n                case ')': paren_groups = if (paren_groups.contains(c))\
    \ paren_groups ::: List(c) else paren_groups\n                // If c is not a\
    \ left or right parenthesis, add it to paren_groups\n                default:\
    \ paren_groups = paren_groups ::: List(c)\n            }\n        }\n\n      \
    \  // Return the resulting list of paren_groups\n        paren_groups\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptjqoe5mj.scala:18:39 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m'('\e[0m: paren_groups\
    \ = paren_groups ::: List(c)\n\e[31m\e[31m   |\e[0m                          \
    \             ^\e[0m\n\e[31m   |\e[0m                                       '=>'\
    \ expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptjqoe5mj.scala:20:39\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e\
    [0m \e[31m')'\e[0m: paren_groups = \e[33mif\e[0m (paren_groups.contains(c)) paren_groups\
    \ ::: List(c) \e[33melse\e[0m paren_groups\n\e[31m\e[31m   |\e[0m            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             '=>' expected, but '=' found\n\e[31m\e[31m-- Error: /tmp/tmptjqoe5mj.scala:22:38\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \         default: \e[35mparen_groups\e[0m = paren_groups ::: List(c)\n\e[31m\e\
    [31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m   \
    \                              end of statement expected but '=' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptjqoe5mj.scala:16:12 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            switch(c) {\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: switch\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // If input string is empty, return empty\
    \ list\n        if (paren_string == \"\")\n            return Nil\n        //\
    \ If input string is only one open paren, return empty list\n        if (paren_string.length\
    \ == 1 && !(paren_string.head == '('))\n            return Nil\n        // Create\
    \ empty mutable list of strings for result\n        var result : List[String]\
    \ = Nil\n        // Add first paren string to result list, since first paren is\
    \ already in the result list\n        result ::= paren_string.head\n        //\
    \ If the first open paren is also the first close paren, then add all the contents\
    \ of the string to the result\n        // list\n        if (paren_string.head\
    \ == '(') {\n            var currentPosition = 0\n            while (currentPosition\
    \ < paren_string.length) {\n                if (paren_string.charAt(currentPosition)\
    \ == '(') {\n                    // If current position is also the first close\
    \ paren, add all the contents of the string to the result\n                  \
    \  if (currentPosition == paren_string.length - 1)\n                        result\
    \ ::= paren_string.substring(currentPosition + 2)\n                    currentPosition\
    \ = currentPosition + 1\n                } else {\n                    // If the\
    \ current position is not the first close paren, add all the contents of the string\
    \ to the result\n                    result ::= paren_string.substring(currentPosition)\n\
    \                    // If the current position was the first close paren, add\
    \ the current character to the result list\n                    if (currentPosition\
    \ == 0)\n                        result ::= paren_string.charAt(currentPosition)\n\
    \                    currentPosition = currentPosition + 1\n                }\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc375sp6.scala:20:15 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        result ::= paren_string.head\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not a member of List[String]\
    \ - did you mean List[String].::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprc375sp6.scala:36:31\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                        result\
    \ ::= paren_string.charAt(currentPosition)\n\e[31m\e[31m   |\e[0m            \
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not a member of List[String]\
    \ - did you mean List[String].::?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create a stack\n        val stack:\
    \ List[String] = Nil\n        // Keep track of braces we encounter\n        var\
    \ braces: Int = 0\n        for (i <- 0 until paren_string.length) {\n        \
    \    if(i == paren_string.length - 1) {\n                if (paren_string(i) ==\
    \ '(') stack += '('\n                else stack += paren_string(i)\n         \
    \       braces += 1\n            } else if (paren_string(i) == ')') {\n      \
    \          if (braces > 0) {\n                    stack += paren_string(i)\n \
    \                   braces -= 1\n                } else {\n                  \
    \  stack += paren_string(i)\n                }\n            } else if (paren_string(i)\
    \ == '(') {\n                if (braces > 0) stack += paren_string(i)\n      \
    \          else stack += '('\n                braces += 1\n            }\n   \
    \     }\n        return stack.reverse.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7qiar34e.scala:17:50 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mif\e[0m (paren_string(i) == \e\
    [31m'('\e[0m) stack += \e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is not\
    \ a member of List[String] - did you mean stack.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp7qiar34e.scala:18:27 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m                \e[33melse\e[0m stack += paren_string(i)\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value +=\
    \ is not a member of List[String] - did you mean stack.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7qiar34e.scala:22:26 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                    stack += paren_string(i)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is\
    \ not a member of List[String] - did you mean stack.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7qiar34e.scala:25:26 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                    stack += paren_string(i)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is\
    \ not a member of List[String] - did you mean stack.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7qiar34e.scala:28:38 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (braces > \e[31m0\e[0m) stack\
    \ += paren_string(i)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       value += is not a member of List[String] - did you\
    \ mean stack.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7qiar34e.scala:29:27\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33melse\e\
    [0m stack += \e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       value += is not a member of List[String] - did you\
    \ mean stack.!=?\n6 errors found\n"
  stdout: ''
  timestamp: 1660013540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val inputString = paren_string.trim.replaceAll(\"\
    \\\\s\", \"\")\n        // Step 1 is to keep track of balanced parenthesis.\n\
    \        // To do this, we'll maintain a stack of open parenthesis. \n       \
    \ var parenstack = Stack[String]()\n        val outputList = new mutable.LinkedList[String]()\n\
    \        for (paren \u2190 inputString) {\n            if (paren eq \")\") {\n\
    \                // If the current paren has a balanced pair, we need to pop it\
    \ from the stack\n                if (parenstack.isEmpty)\n                  \
    \  throw new IllegalArgumentException(\"Unbalanced Parenthesis\")\n          \
    \      val nextParen = parenstack.pop()\n                // If the current paren\
    \ doesn't have a balanced pair, we add it to the stack\n                if (!nextParen\
    \ eq \"(\")\n                    parenstack.push(nextParen)\n            } else\
    \ if(paren eq \"(\") {\n                // If the current paren doesn't have a\
    \ balanced pair, we add it to the stack\n                if (!parenstack.isEmpty)\n\
    \                    throw new IllegalArgumentException(\"Unbalanced Parenthesis\"\
    )\n                parenstack.push(paren)\n            } else {\n            \
    \    // If the current paren doesn't have a balanced pair, we add it to the stack\n\
    \                if (!parenstack.isEmpty)\n                    throw new IllegalArgumentException(\"\
    Unbalanced Parenthesis\")\n                outputList.push(paren)\n          \
    \  }\n        }\n        // Step 2 is to separate each group of balanced parenthesis,\
    \ by putting each balanced parenthesis\n        // into a separate list\n    \
    \    // For each group of balanced parenthesis encountered, \n        // add all\
    \ non-parenthesis to outputList\n        // For each group of balanced parenthesis\
    \ encountered, \n        // add all non-parenthesis to the parenstack \n     \
    \   // Then recursively call this function on each of the groups encountered.\n\
    \        for (paren \u2190 outputList) {\n            // If current parenthesis\
    \ is encountered, add it to parenstack\n            if (paren eq \"(\")\n    \
    \            parenstack.push(paren)\n            // If current parenthesis is\
    \ not encountered, add it to outputList\n            else {\n                outputList.push(paren)\n\
    \            }\n        }\n        // Step 3 is to recursively call this function\
    \ to separate each group of balanced parenthesis\n        // If no group is left,\
    \ return an empty list because there are no more parenthesis to be separated\n\
    \        if (parenstack.isEmpty)\n            List()\n        else {\n       \
    \     val groups = parenstack.pop()\n            val returnValue = separateParenGroups(groups)\n\
    \            for (paren \u2190 returnValue) {\n                if (paren eq \"\
    (\")\n                    parenstack.push(paren)\n                else {\n   \
    \                 outputList.push(paren\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8awsm2qv.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8awsm2qv.scala:74:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp8awsm2qv.scala:15:29 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36moutputList\e[0m = \e[33mnew\e[0m mutable.LinkedList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8awsm2qv.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (!nextParen eq \e[31m\"\
    (\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value unary_! is not a member of String\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8awsm2qv.scala:29:32 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                parenstack.push(paren)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                        Found:    (paren : Char)\n\e[31m   |\e[0m           \
    \                     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp8awsm2qv.scala:66:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\nthere were 9 deprecation\
    \ warnings; re-run with -deprecation for details\n2 warnings found\n5 errors found\n"
  stdout: ''
  timestamp: 1660013540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var group_strs: List[String] = Nil\n \
    \       var bracket_count = 0\n\n        val group_start = \"(\"\n        val\
    \ group_end = \")\"\n\n        var inside_brackets = false\n        paren_string.foreach\
    \ { c =>\n            if(c == group_start && !inside_brackets) {\n           \
    \     inside_brackets = true\n                group_strs = Nil\n             \
    \   bracket_count = 0\n            } else if(c == group_end && inside_brackets)\
    \ {\n                inside_brackets = false\n                group_strs = group_strs\
    \ :+ group_strs.last\n            } else if(!inside_brackets) {\n            \
    \    group_strs = group_strs :+ c\n                bracket_count += 1\n      \
    \      }\n        }\n\n        group_strs\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpx95d9lu2.scala:19:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(c == group_start && !inside_brackets)\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpx95d9lu2.scala:23:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(c == group_end\
    \ && inside_brackets) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx95d9lu2.scala:27:43\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                group_strs =\
    \ group_strs :+ c\n\e[31m\e[31m   |\e[0m                                     \
    \      ^\e[0m\n\e[31m   |\e[0m                                           Found:\
    \    (c : Char)\n\e[31m   |\e[0m                                           Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_groups = mutable.LinkedHashSet[String]()\n\
    \n        // Look at each character of the input string\n        // If it's a\
    \ left paren, add it to the paren_groups Set\n        // If it's a right paren,\
    \ remove it from the paren_groups Set\n        for ( char : String <- paren_string.toList)\
    \ match {\n            case _ if (char == \"(\") =>\n                paren_groups\
    \ += char\n            case _ if (char == \")\") =>\n                paren_groups\
    \ -= char\n            case _ =>\n        }\n\n        // If the paren_groups\
    \ is still empty, it means that we have nested brackets\n        // The correct\
    \ way is to have nested brackets, so remove the outer brackets\n        if (paren_groups.isEmpty)\
    \ paren_string.substring(1)\n        // Otherwise, we have no nested brackets,\
    \ just return paren_string\n        else paren_string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7ffj0csw.scala:16:52 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m ( char : \e[35mString\e[0m <-\
    \ paren_string.toList) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m             \
    \                                       ^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                           expression expected but \e[31mmatch\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ffj0csw.scala:11:27\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e\
    [36mparen_groups\e[0m = mutable.LinkedHashSet[\e[35mString\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7ffj0csw.scala:26:56 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mif\e[0m (paren_groups.isEmpty) paren_string.substring(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    String\n\e[31m\
    \   |\e[0m                                  Required: \e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7ffj0csw.scala:28:13 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33melse\e[0m paren_string\n\e[31m\e[31m   |\e[0m          \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (paren_string : String)\n\
    \e[31m   |\e[0m             Required: List[String]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Use stack to solve this problem\n \
    \       // In each level of parenthesis, if an opening brace is encountered, push\
    \ it on the stack, and if a\n        // closing brace is encountered, pop it off\
    \ the stack until you reach the top level.\n        // When you reach the top\
    \ level, you have separated all nested brackets.\n        val paren_string_list\
    \ = paren_string.split(\"( )\").toList\n        val open_brace_stack = mutable.Stack[String]()\n\
    \        var output: List[String] = Nil\n        for(paren_string <- paren_string_list)\
    \ {\n            val open_brace_index = paren_string_list.indexOf(paren_string)\n\
    \            val close_brace_index = paren_string_list.lastIndexOf(paren_string)\n\
    \            val open_brace_count = open_brace_index + 1\n            val close_brace_count\
    \ = close_brace_index - open_brace_index - 1\n            for(open_brace <- 0\
    \ until open_brace_count) {\n                paren_string match {\n          \
    \          case \" \" => // Ignore spaces in parenthesis\n                   \
    \ case open_brace :: _ =>\n                        open_brace_stack push (paren_string.substring\
    \ (open_brace_index, open_brace + 1))\n                    case _ =>\n       \
    \                 val open_brace_string = paren_string substring (0, open_brace)\n\
    \                        val close_brace_string = paren_string substring (open_brace\
    \ + 1, close_brace)\n                        val next_paren_string = paren_string\
    \ substring (close_brace + 1)\n                        if(open_brace_stack.isEmpty\
    \ || open_brace_stack.last.contains(open_brace_string)) {\n                  \
    \          output += next_paren_string\n                        } else {\n   \
    \                         open_brace_stack push open_brace_string\n          \
    \                  output += next_paren_string\n                        }\n  \
    \              }\n            }\n            for(close_brace <- 0 until close_brace_count)\
    \ {\n                paren_string match {\n                    case \" \" => //\
    \ Ignore spaces in parenthesis\n                    case close_brace :: _ =>\n\
    \                        close_brace_stack pop\n                    case _ =>\n\
    \                        if(close_brace_stack.isEmpty) {\n                   \
    \         output += paren_string\n                        } else {\n         \
    \                   val open_brace_string = paren_string substring (0, close_brace)\n\
    \                            val close_brace_string = paren_string substring (close_brace\
    \ + 1, close_string)\n                            val next_paren_string = paren_string\
    \ substring (close_brace + 1)\n                            if(open_brace_stack.isEmpty)\
    \ {\n                                output += \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7_e6ok29.scala:44:45 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                        close_brace_stack pop\n\e[31m\e\
    [31m   |\e[0m                                             ^\e[0m\n\e[31m   |\e\
    [0m                                  expression expected but \e[31munindent\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7_e6ok29.scala:53:41\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m                     \
    \           output += \n\e[31m\e[31m   |\e[0m                                \
    \         ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp7_e6ok29.scala:63:0 ----------------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7_e6ok29.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen_brace_stack\e[0m =\
    \ mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7_e6ok29.scala:30:89\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                        \e\
    [33mval\e[0m \e[36mclose_brace_string\e[0m = paren_string substring (open_brace\
    \ + \e[31m1\e[0m, close_brace)\n\e[31m\e[31m   |\e[0m                        \
    \                                                                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Not found:\
    \ close_brace\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7_e6ok29.scala:31:72\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m "
  stdout: ''
  timestamp: 1660013543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_group_string : List[String]\
    \ = Nil\n        var paren_group : List[String] = Nil\n        var paren_count\
    \ : Int = 0\n        var paren_open_braces : List[Char] = Nil\n        var paren_close_braces\
    \ : List[Char] = Nil\n        var paren_brace_count : Int = 0\n        var paren_closed_paren_brace_count\
    \ : Int = 0\n\n        var paren_group_open_braces : List[Char] = Nil\n      \
    \  var paren_group_brace_count : Int = 0\n\n        var paren_group_open_brace_count\
    \ : Int = 0\n        var paren_group_close_brace_count : Int = 0\n\n        paren_string.foreach\
    \ {\n            c => {\n                if (c == '(') {\n                   \
    \ paren_group_string = Nil\n                    paren_group = Nil\n          \
    \          paren_group_string ::= Nil\n                    paren_group ::= Nil\n\
    \                    paren_group_open_braces ::= Nil\n                    paren_group_open_brace_count\
    \ ::= 0\n                    paren_group_close_brace_count ::= 0\n           \
    \         paren_group_brace_count ::= 0\n                }\n                else\
    \ if (c == ')') {\n                    if (paren_group_brace_count == 0) {\n \
    \                       paren_group_string ::= paren_group\n                 \
    \       paren_group ::= Nil\n                        paren_group_open_braces ::=\
    \ paren_group_open_braces\n                        paren_group_open_brace_count\
    \ ::= paren_group_open_brace_count\n                        paren_group_close_brace_count\
    \ ::= paren_group_close_brace_count\n                    }\n                 \
    \   else {\n                        paren_group_brace_count -= 1\n           \
    \         }\n                }\n                else if (paren_group_brace_count\
    \ > 0) {\n                    if (paren_group_brace_count == 1) {\n          \
    \              paren_group_string = paren_group\n                        paren_group\
    \ ::= Nil\n                        paren_group_open_braces ::= paren_group_open_braces\n\
    \                        paren_group_open_brace_count ::= paren_group_open_brace_count\n\
    \                        paren_group_close_brace_count ::= paren_group_close_brace_count\n\
    \                    }\n                    else {\n                        paren_group_brace_count\
    \ -= 1\n                        paren_group_string ::= paren_group\n         \
    \               paren_group ::= Nil\n                        paren_group_open_braces\
    \ ::= paren_group_open_braces\n                        paren_group_open_brace_count\
    \ ::\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf64fshax.scala:62:55 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m                        paren_group_open_brace_count\
    \ ::\n\e[31m\e[31m   |\e[0m                                                  \
    \     ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpf64fshax.scala:72:0 ----------------------------\e[0m\e[0m\n\e[31m72\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf64fshax.scala:30:39 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    paren_group_string ::= Nil\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ ::= is not a member of List[String] - did you mean List[String].::?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpf64fshax.scala:31:32 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    paren_group ::= Nil\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is\
    \ not a member of List[String] - did you mean List[String].::?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpf64fshax.scala:32:44 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    paren_group_open_braces ::= Nil\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m   value ::= is not a member of List[Char] - did you mean List[Char].::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf64fshax.scala:33:49 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    paren_group_open_brace_count ::=\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value ::= is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpf64fshax.scala:34:50 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    paren_group_close_brace_count ::=\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = new mutable.ListBuffer[String]()\n\
    \        var depth = 0\n        // Iterate through each paren group\n        for(c\
    \ <- paren_string) {\n            // If current character is a space, ignore it\n\
    \            if(c == ' ')\n                continue\n            // If current\
    \ character is a close brace, increase depth\n            if(c == '(') {\n   \
    \             depth += 1\n            }\n            // If current character is\
    \ a close brace, decrease depth\n            if(c == ')') {\n                depth\
    \ -= 1\n                // If current depth is zero, add the current group to\
    \ our list\n                if(depth == 0)\n                    paren_groups +=\
    \ c\n            }\n        }\n        // Return our list\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpamczl3d6.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpamczl3d6.scala:17:16\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                continue\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // This function will take a single string\
    \ and return a list of the strings separated by any nested\n        // parentheses.\n\
    \        // The nested parentheses are returned in a list, with each string containing\
    \ the nested parentheses\n        // that surround it.\n        // The function\
    \ will ignore any spaces in the input string and return the list of strings\n\
    \        // (List[String]) containing the strings separated by any nested parentheses.\n\
    \        def separateParenGroups_rec(string : String, paren_list : List[String])\
    \ : List[String] = {\n            // The function should return a list of strings\
    \ containing any nested parentheses if there is any\n            // surrounding\
    \ parentheses.\n            // The list is empty if there are no nested parentheses\
    \ in the input string\n            \n            if (paren_string.length == 0)\
    \ {\n                return paren_list\n            } else {\n               \
    \ val first_char = string.charAt(0)\n                val next_chars = string.substring(1)\n\
    \                val next_string = next_chars.trim\n                \n       \
    \         if (first_char == \"(\") {\n                    paren_list += string\n\
    \                    separateParenGroups_rec(next_string, paren_list)\n      \
    \          } else if (first_char == \")\") {\n                    paren_list =\
    \ separateParenGroups_rec(next_string, paren_list)\n                    paren_list\
    \ += string\n                } else {\n                    paren_list = separateParenGroups_rec(next_string,\
    \ paren_list)\n                }\n            }\n        }\n        \n       \
    \ // The return value will be a List[String]\n        separateParenGroups_rec(paren_string,\
    \ List())\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpri8ci3v1.scala:29:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (first_char == \e[31m\"\
    (\"\e[0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpri8ci3v1.scala:30:31\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    paren_list\
    \ += string\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m  value += is not a member of List[String] - did you mean paren_list.!=?\n\
    \e[31m\e[31m-- Error: /tmp/tmpri8ci3v1.scala:32:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (first_char\
    \ == \e[31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpri8ci3v1.scala:33:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                   \
    \ paren_list = separateParenGroups_rec(next_string, paren_list)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val paren_list\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpri8ci3v1.scala:34:31 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    paren_list += string\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value += is\
    \ not a member of List[String] - did you mean paren_list.!=?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpri8ci3v1.scala:36:31 -----------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                    paren_list = separateParenGroups_rec(next_string,\
    \ paren_list)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val "
  stdout: ''
  timestamp: 1660013547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Your code here\n        val paren_group\
    \ = paren_string.split(\"\\\\(\").toList\n        val paren_groups = paren_group.groupBy(p\
    \ => p(0).equals(p(0).trim))\n        val result = paren_groups.map(p => (p._1,\
    \ p._2.map(i => i.trim).filterNot(_ == \"\")).toList).toList\n        println(result)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxxz9o8so.scala:13:69 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = paren_group.groupBy(\e\
    [36mp\e[0m => p(\e[31m0\e[0m).equals(p(\e[31m0\e[0m).trim))\n\e[31m\e[31m   |\e\
    [0m                                                                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value trim is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxxz9o8so.scala:15:15\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        println(result)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_array = paren_string.split(\"\
    \\\\W+\").toList\n        val open_brace_array = (paren_array.toSet) - (paren_array.toList.map(_.contains(\"\
    {\")).filter(_.isDefined))\n        val closed_brace_array = (paren_array.toSet)\
    \ - (paren_array.toList.map(_.contains(\"}\")).filter(_.isDefined))\n        val\
    \ resulting_list = List[String]()\n        val open_brace_count = open_brace_array.size\n\
    \        val closed_brace_count = closed_brace_array.size\n        var paren_count\
    \ = 0\n        var open_brace_pos = 0\n        var closed_brace_pos = 0\n    \
    \    open_brace_array.foreach { item =>\n            closed_brace_array.foreach\
    \ { close =>\n                if (paren_count >= open_brace_count) {\n       \
    \             open_brace_pos = paren_array.toSet.size - closed_brace_array.size\
    \ + (open_brace_count - 1)\n                }\n                closed_brace_pos\
    \ = closed_brace_array.size + paren_count + 1\n                if (item.contains(\"\
    {\") && item.contains(\"}\")) {\n                    if (closed_brace_array.contains(close)\
    \ && paren_count < closed_brace_count) {\n                        paren_count\
    \ += 1\n                    } else {\n                        paren_pos = closed_brace_pos\n\
    \                        resulting_list :+= paren_array.take(open_brace_pos).toString\
    \ + \"(\" + paren_array.drop(paren_pos + 1).toString + \")\"\n               \
    \         paren_count = 0\n                        open_brace_count = 0\n    \
    \                    closed_brace_count = 0\n                    }\n         \
    \       } else if (item.contains(\"{\")) {\n                    if (paren_count\
    \ < closed_brace_count) {\n                        paren_count += 1\n        \
    \            } else {\n                        paren_pos = closed_brace_pos\n\
    \                        resulting_list :+= paren_array.take(open_brace_pos).toString\
    \ + \"(\" + paren_array.drop(paren_pos + 1).toString + \")\"\n               \
    \         paren_count = 0\n                        open_brace_count = 0\n    \
    \                    closed_brace_count = 0\n                    }\n         \
    \       } else if (item.contains(\"}\")) {\n                    if (paren_count\
    \ > open_brace_count) {\n                        open_brace_count += 1\n     \
    \               } else {\n                        open_brace_pos = paren_array.toSet.size\
    \ - closed_brace_array.size + (open_brace_count - 1)\n                       \
    \ resulting_list :+= paren_array.take(open_brace_pos).toString + \"(\" + paren_array.drop(paren_pos\
    \ + 1).toString \n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpolwcsn9r.scala:61:0 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpolwcsn9r.scala:12:103\
    \ -----------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mopen_brace_array\e[0m = (paren_array.toSet) - (paren_array.toList.map(_.contains(\e\
    [31m\"{\"\e[0m)).filter(_.isDefined))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              value\
    \ isDefined is not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpolwcsn9r.scala:13:105 -----------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mclosed_brace_array\e[0m = (paren_array.toSet)\
    \ - (paren_array.toList.map(_.contains(\e[31m\"}\"\e[0m)).filter(_.isDefined))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                               ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              value isDefined is not a member of Boolean\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpolwcsn9r.scala:26:25 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (item.contains(\e[31m\"\
    {\"\e[0m) && item.contains(\e[31m\"}\"\e[0m)) {\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value contains\
    \ is not a member of Object\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpolwcsn9r.scala:30:24\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                        paren_pos\
    \ = closed_brace_pos\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Not found: paren_pos\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpolwcsn9r.scala:31:39 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                        resulting_list :+= paren_array.take(open_brace_pos).toString\
    \ + \e[31m\"(\"\e[0m + pa"
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val regex = \"\"\"\\s*\\(\\s*\\(([^\\\
    (\\)]+)\\)\\s*\\)\\s*\"\"\".r\n        val paren_groups: List[String] = paren_string.findAll(regex).toList\n\
    \        val result_groups: List[String] = paren_groups.filter(group => isBalanced(group)).map(group\
    \ => group.trim)\n        result_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5mrkn9xq.scala:12:54 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = paren_string.findAll(regex).toList\n\e[31m\e[31m   |\e\
    [0m                                         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 value findAll is not a member of String\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5mrkn9xq.scala:13:71 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mresult_groups\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = paren_groups.filter(\e[36mgroup\e[0m => isBalanced(group)).map(\e\
    [36mgroup\e[0m => group.trim)\n\e[31m\e[31m   |\e[0m                         \
    \                                              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                   Not found: isBalanced\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // We need mutable list of paren groups\
    \ here, because we will add new group when encounter a matching\n        // closing\
    \ brace\n        var paren_groups = mutable.ListBuffer[String]()\n        for(i\
    \ <- 0 until paren_string.length) {\n            // We will add new group if current\
    \ character is not a closing brace or opening brace\n            if((paren_string(i)\
    \ != \")\") && (paren_string(i) != \"(\")) {\n                paren_groups +=\
    \ paren_string(i)\n            } else {\n                // Encountered matching\
    \ closing brace, we will add new group if this closing brace has not been\n  \
    \              // matched already, otherwise we will discard this closing brace\n\
    \                if(paren_groups.nonEmpty) {\n                    paren_groups\
    \ += \")\"\n                } else {\n                    paren_groups += \"()\"\
    \n                }\n            }\n        }\n        paren_groups.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpprx5ccq9.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mparen_groups\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpprx5ccq9.scala:16:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m((paren_string(i) != \e[31m\"\
    )\"\e[0m) && (paren_string(i) != \e[31m\"(\"\e[0m)) {\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpprx5ccq9.scala:16:44 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mif\e[0m((paren_string(i) != \e[31m\")\"\e\
    [0m) && (paren_string(i) != \e[31m\"(\"\e[0m)) {\n\e[31m\e[31m   |\e[0m      \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups: List[String] = Nil\n     \
    \   for (paren \u2190 paren_string.toList) match {\n            case \" \" \u2190\
    \ Nil\n            case \")\" \u2190 Nil\n            case _ \u2190 {\n      \
    \          var open_brace_count = paren_string indexOfFirst paren\n          \
    \      val closed_paren_count = paren_string indexOfLast paren\n             \
    \   for (open_paren \u2190 paren_string.subList(open_brace_count + 1, closed_paren_count))\
    \ \u2190 paren.toList {\n                    val open_paren_count = paren_string\
    \ indexOfFirst open_paren\n                    val close_paren_count = paren_string\
    \ indexOfLast open_paren\n                    if (open_paren_count != close_paren_count\
    \ && open_paren_count > close_paren_count) {\n                        val open_brace_start_index\
    \ = paren_string indexOfFirst paren\n                        val open_brace_end_index\
    \ = paren_string lastIndexOf paren\n                        val open_paren_start_index\
    \ = paren_string indexOfFirst open_paren\n                        val open_paren_end_index\
    \ = paren_string lastIndexOf open_paren\n                        val close_paren_start_index\
    \ = paren_string indexOfFirst close_paren\n                        val close_paren_end_index\
    \ = paren_string lastIndexOf close_paren\n                        val open_brace_count_diff\
    \ = closed_paren_count - open_paren_count\n                        val open_paren_count_diff\
    \ = closed_paren_count - open_paren_count\n                        val close_paren_count_diff\
    \ = closed_paren_count - close_paren_count\n                        val open_brace_start_index_diff\
    \ = open_brace_end_index - open_brace_start_index\n                        val\
    \ open_paren_start_index_diff = open_paren_end_index - open_paren_start_index\n\
    \                        val close_paren_start_index_diff = close_paren_end_index\
    \ - close_paren_start_index\n                        val open_brace_end_index_diff\
    \ = open_brace_start_index - open_brace_end_index\n                        val\
    \ open_paren_end_index_diff = open_paren_start_index - open_paren_end_index\n\
    \                        val close_paren_end_index_diff = close_paren_start_index\
    \ - close_paren_end_index\n                        val open_brace_count_diff_plus_1\
    \ = open_brace_count_diff + 1\n                        val open_paren_count_diff_plus_1\
    \ = open_paren_count_diff + 1\n                        val close_paren_count_diff_plus_1\
    \ = close_paren_count_diff + 1\n                        val open_brace_start_index_diff_plus_1\
    \ = open_brace_end_index_diff + 1\n                        val open_paren_start_index_diff_plus_1\
    \ = open_paren_end_index_diff + 1\n                        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8rcrlzfy.scala:12:42 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m (paren \u2190 paren_string.toList)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                                     expression\
    \ expected but \e[31mmatch\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\nthere were 8 deprecation\
    \ warnings; re-run with -deprecation for details\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660013543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    (?<=\\\\))(?=\\\\()\")\n        var paren_group: List[String] = Nil\n        for\
    \ ((index, value) <- paren_groups.zipWithIndex) {\n            if (index > 0)\
    \ {\n                paren_group += value\n            }\n        }\n        return\
    \ paren_group\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5b8i4c0_.scala:14:24\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (index\
    \ > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m\
    \   |\e[0m                        Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e\
    [0m                        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5b8i4c0_.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                paren_group += value\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a\
    \ member of List[String] - did you mean List[String].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Write your code here.\n        def\
    \ checkGroup(group : String) : Boolean = {\n            var open_count = 0\n \
    \           for (c <- group) {\n                if (c == ')')\n              \
    \      open_count -= 1\n                if (c == '(')\n                    open_count\
    \ += 1\n                if (open_count < 0)\n                    return false\n\
    \            }\n            return true\n        }\n        def separateGroups(group\
    \ : String) : List[String] = {\n            var groups: List[String] = Nil\n \
    \           val paren_count = paren_string.length\n            val group_length\
    \ = group.length\n            if (paren_count == 0)\n                groups =\
    \ group\n            else {\n                // For the first time the open parens\
    \ are encountered, the count will be greater than 0\n                // and we'll\
    \ need to recur till the count is zero.\n                var open_index = group_length\n\
    \                while (open_count > 0) {\n                    var open_index\
    \ = group_length\n                    while (open_index > 0 && checkGroup(group.substring(open_index\
    \ - 1, open_index))) {\n                        open_index -= 1\n            \
    \        }\n                    // If there are unclosed parens, we need to recur\
    \ till we reach the end of the string.\n                    if (open_index ==\
    \ 0)\n                        break\n                    groups = groups ::: group.substring(0,\
    \ open_index)\n                    group = group.substring(open_index)\n     \
    \               open_index -= 1\n                    open_count -= 1\n       \
    \         }\n                groups = groups ::: group\n                groups\
    \ = separateGroups(groups)\n            }\n            return groups\n       \
    \ }\n        var groups: List[String] = Nil\n        groups = separateGroups(paren_string)\n\
    \        return groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsl6jpzpl.scala:29:25\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                groups = group\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Found:    (group : String)\n\e[31m   |\e[0m            \
    \             Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpsl6jpzpl.scala:34:23 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                \e[33mwhile\e[0m (open_count > \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       Not found: open_count\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsl6jpzpl.scala:41:24 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsl6jpzpl.scala:42:36\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                    groups\
    \ = groups ::: group.substring(\e[31m0\e[0m, open_index)\n\e[31m\e[31m   |\e[0m\
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                    value ::: is not a member of\
    \ String\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpsl6jpzpl.scala:43:26 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    group = group.substring(open_index)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val group\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsl6jpzpl.scala:45:20 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    open_count -= \e[31m1\e[0m\n\e[31m\e\
    [31"
  stdout: ''
  timestamp: 1660013551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_regex = \"\"\"\\((?!\\()\"\"\
    \".r\n        paren_string match {\n            case paren_regex(_, \"\") => List(\"\
    \")\n            case paren_regex(_, s) => separate_paren_strings(s)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppb5ovkt4.scala:14:38 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mcase\e[0m paren_regex(_, s) => separate_paren_strings(s)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: separate_paren_strings\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string == null) List(\"\")\n\
    \        else {\n            var cur = List[String]()\n            var next =\
    \ 0\n            for (i <- 0 until paren_string.length) {\n                if\
    \ (paren_string(i) == '(') {\n                    next += 1\n                \
    \    if (paren_string(i + 1) == '(') next += 1\n                    if (paren_string(i\
    \ + 2) == '(') next += 1\n                    if (paren_string(i + 3) == '(')\
    \ next += 1\n                    if (paren_string(i + 4) == '(') next += 1\n \
    \                   if (paren_string(i + 5) == '(') next += 1\n              \
    \      if (paren_string(i + 6) == '(') next += 1\n                    if (paren_string(i\
    \ + 7) == '(') next += 1\n                    if (paren_string(i + 8) == '(')\
    \ next += 1\n                    if (paren_string(i + 9) == '(') next += 1\n \
    \                   if (paren_string(i + 10) == '(') next += 1\n             \
    \       if (paren_string(i + 11) == '(') next += 1\n                    if (paren_string(i\
    \ + 12) == '(') next += 1\n                    if (paren_string(i + 13) == '(')\
    \ next += 1\n                    if (paren_string(i + 14) == '(') next += 1\n\
    \                    if (paren_string(i + 15) == '(') next += 1\n            \
    \        if (paren_string(i + 16) == '(') next += 1\n                }\n     \
    \           else if (paren_string(i) == ')') {\n                    next -= 1\n\
    \                    if (next == 0) cur = cur + (paren_string(i + 1))\n      \
    \          }\n            }\n            cur\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa3uuu594.scala:37:45 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    \e[33mif\e[0m (next == \e[31m0\e\
    [0m) cur = cur + (paren_string(i + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m     \
    \                                    ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[String], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val open_parens : List[String] = ListBuffer[String]()\n\
    \        val open_parens_count : Int = paren_string.count(_ == '(')\n        val\
    \ close_parens_count : Int = paren_string.count(_ == ')')\n\n        // iterate\
    \ over all parenthesis\n        for (i <- 0 until close_parens_count) {\n    \
    \        for (j <- 0 until open_parens_count) {\n                // if current\
    \ open parenthesis matches with next close parenthesis, add current open parenthesis\n\
    \                // to open_parens list\n                if (paren_string(i) ==\
    \ '(' && paren_string(i + j + 1) == paren_string(i + j)) {\n                 \
    \   open_parens ::= paren_string(i)\n                }\n                // if\
    \ current open parenthesis matches with previous close parenthesis, add current\
    \ close parenthesis\n                // to open_parens list\n                else\
    \ if (paren_string(i) == '(' && paren_string(i + j) == paren_string(i + j + 1))\
    \ {\n                    open_parens ::= paren_string(i + 1)\n               \
    \ }\n                // if current close parenthesis matches with next open parenthesis,\
    \ add current close parenthesis\n                // to open_parens list\n    \
    \            else if (paren_string(i) == ')' && paren_string(i + j + 1) == paren_string(i\
    \ + j)) {\n                    open_parens ::= paren_string(i + 1)\n         \
    \       }\n                // if current close parenthesis matches with previous\
    \ open parenthesis, add current open parenthesis\n                // to open_parens\
    \ list\n                else if (paren_string(i) == ')' && paren_string(i + j)\
    \ == paren_string(i + j + 1)) {\n                    open_parens ::= paren_string(i)\n\
    \                }\n            }\n        }\n\n        // traverse over the open_parens\
    \ list and add opening parenthesis strings to close_parens list\n        var close_parens\
    \ : List[String] = List()\n        for (i <- open_parens) {\n            close_parens\
    \ ::= i\n        }\n\n        // traverse over the close_parens list and add closing\
    \ parenthesis strings to open_parens list\n        var open_parens : List[String]\
    \ = List()\n        for (i <- close_parens) {\n            open_parens ::= i\n\
    \        }\n\n        open_parens.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppr_4of09.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m \e[36mopen_parens\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = List()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopen_parens is already defined as \e[33mvalue\e[0m \e[35mopen_parens\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmppr_4of09.scala:11:59 --------------------\e[0m\e[0m\n\
    \e[31m11 |\e[0m        \e[33mval\e[0m \e[36mopen_parens\e[0m : \e[35mList\e[0m[\e\
    [35mString\e[0m] = ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                                     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Found:    scala.collection.mutable.ListBuffer[String]\n\e\
    [31m   |\e[0m                   Required: List[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppr_4of09.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    open_parens ::= paren_string(i)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ ::= is not a member of List[String] - did you mean open_parens.::?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppr_4of09.scala:26:32 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    open_parens ::= paren_string(i +\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue ::= is not a member of List[String] - did you mean open_parens.::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppr_4of09.scala:31:32 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    open_parens ::= paren_string(i +\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue ::= is not a member of List[String] - did you mean open_parens.::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppr_4of09.scala:36:32 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1660013553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_string = paren_string.trim\n\
    \        if (paren_string.isEmpty) {\n            Nil\n        }\n        else\
    \ {\n            val open_groups = mutable.ListBuffer[String]()\n            val\
    \ close_groups = mutable.ListBuffer[String]()\n            val open_parens = mutable.Map[String,\
    \ Int]()\n            paren_string.foreach(char => {\n                char match\
    \ {\n                    case \"{\" => {\n                        open_groups\
    \ += char\n                        open_parens(char) = open_parens(char).b + 1\n\
    \                    }\n                    case \"}\" => {\n                \
    \        close_groups += char\n                    }\n                    case\
    \ _ => {\n                        close_groups += char\n                    }\n\
    \                }\n            })\n            for (open_group <- open_groups)\
    \ {\n                if (open_parens(open_group) == open_parens(open_group).b)\
    \ {\n                    if (open_parens(open_group).b <= close_groups.indexOf(open_group))\
    \ {\n                        close_groups -= open_group\n                    }\n\
    \                }\n            }\n            close_groups.toList.sortWith((open_group_one,\
    \ open_group_two) =>\n                open_parens(open_group_one) < open_parens(open_group_two))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv0o1a8xo.scala:11:27 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m = paren_string.trim\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mparen_string\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv0o1a8xo.scala:16:30\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m\
    \ \e[36mopen_groups\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpv0o1a8xo.scala:17:31 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mclose_groups\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv0o1a8xo.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mopen_parens\e[0m = mutable.Map[\e\
    [35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \\\\(|\\\\)\")\n        var current_string = \"\"\n        val result = paren_groups.filter(x\
    \ => x.trim.nonEmpty).flatMap(x => { if (x.nonEmpty) current_string + x.trim else\
    \ \"\"\n                                                                     \
    \    current_string = x \n                                                   \
    \                      Some(current_string) })\n        result.filterNot(x =>\
    \ x.equals(\"()\"))\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsw9u__zx.scala:16:24\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        result.filterNot(\e[36mx\e\
    [0m => x.equals(\e[31m\"()\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m  \
    \ |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parentheses = paren_string.split(\"\
    \")\n        // Iterate through all the parenthesis\n        parentheses.filter(_\
    \ != ')').filter(_ != '{').filter(_ != '(').filter(_ != ')}').filter(_ != '}(').filter(_\
    \ != '{')\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnd357o5d.scala:13:83 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        parentheses.filter(_ != \e[31m')'\e[0m).filter(_\
    \ != \e[31m'{'\e[0m).filter(_ != \e[31m'('\e[0m).filter(_ != ')}').filter(_ !=\
    \ '}(').filter(_ != \e[31m'{'\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                              unclosed character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpnd357o5d.scala:13:86 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        parentheses.filter(_ != \e[31m')'\e[0m).filter(_\
    \ != \e[31m'{'\e[0m).filter(_ != \e[31m'('\e[0m).filter(_ != ')}').filter(_ !=\
    \ '}(').filter(_ != \e[31m'{'\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpnd357o5d.scala:13:101 ----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        parentheses.filter(_ != \e[31m')'\e[0m).filter(_\
    \ != \e[31m'{'\e[0m).filter(_ != \e[31m'('\e[0m).filter(_ != ')}').filter(_ !=\
    \ '}(').filter(_ != \e[31m'{'\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \      ^\e[0m\n\e[31m   |\e[0m                                              unclosed\
    \ character literal\n\e[31m\e[31m-- Error: /tmp/tmpnd357o5d.scala:13:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        parentheses.filter(_ != \e[31m')'\e[0m).filter(_\
    \ != \e[31m'{'\e[0m).filter(_ != \e[31m'('\e[0m).filter(_ != ')}').filter(_ !=\
    \ '}(').filter(_ != \e[31m'{'\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpnd357o5d.scala:13:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m13 |\e[0m       \
    \ parentheses.filter(_ != \e["
  stdout: ''
  timestamp: 1660013552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val paren_group_list: List[String] = ListBuffer.empty[String]\n\
    \n      // Use Stack to keep track of how many open braces are in the string\n\
    \      val stack = new Stack[String]\n      stack.push(\"(\")\n\n      // While\
    \ there are still braces left in the stack\n      while (!stack.isEmpty) {\n \
    \       val curr = stack.pop()\n\n        // Only interested in opening braces.\n\
    \        if (curr == \"(\") {\n          // If there are still open braces in\
    \ the string\n          if (paren_string.forall(c => c == \"(\")) {\n        \
    \    // We have found an opening brace. Add to our stack\n            paren_group_list.clear()\n\
    \            paren_group_list.push(curr)\n          }\n        } else {\n    \
    \      // If the stack is empty we are at a closing brace. Remove the top element\n\
    \          if (paren_string.forall(c => c == curr)) {\n            paren_group_list.append(\"\
    )\")\n          }\n        }\n      }\n\n      // Return our list of groups\n\
    \      paren_group_list.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppyy23f_3.scala:11:59\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m      \e[33mval\e[0m \e[36mparen_group_list\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = ListBuffer.empty[\e[35mString\e[0m]\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    scala.collection.mutable.ListBuffer[String]\n\
    \e[31m   |\e[0m                   Required: List[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmppyy23f_3.scala:24:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m          \e[33mif\e[0m (paren_string.forall(\e[36mc\e\
    [0m => c == \e[31m\"(\"\e[0m)) {\n\e[31m\e[31m   |\e[0m                      \
    \                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and\
    \ String cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmppyy23f_3.scala:26:29 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            paren_group_list.clear()\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue clear is not a member of List[String], but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e\
    [0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppyy23f_3.scala:27:29\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            paren_group_list.push(curr)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ push is not a member of List[String] - did you mean paren_group_list.last?\n\
    \e[31m\e[31m-- Error: /tmp/tmppyy23f_3.scala:31:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e["
  stdout: ''
  timestamp: 1660013554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups: List[String] = mutable.ListBuffer.empty[String]\n\
    \        paren_string.foreach {\n            c =>\n                if (c == '(')\
    \ {\n                    paren_groups.append(\"\")\n                } else {\n\
    \                    val open_count = getOpenCount(paren_groups)\n           \
    \         if (open_count > 0) {\n                        val curr_str = paren_groups.take(open_count).mkString\n\
    \                        paren_groups.append(curr_str + c)\n                 \
    \   } else {\n                        paren_groups.append(c)\n               \
    \     }\n                }\n        }\n        paren_groups.size\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd6egq_6b.scala:11:41 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpd6egq_6b.scala:15:33 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    paren_groups.append(\e[31m\"\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue append is not a member of List[String] - did you mean paren_groups.appended?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd6egq_6b.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                    \e[33mval\e[0m \e[36mopen_count\e\
    [0m = getOpenCount(paren_groups)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \          Not found: getOpenCount\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpd6egq_6b.scala:20:37 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m                        paren_groups.append(curr_str + c)\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append\
    \ is not a member of List[String] - did you mean paren_groups.appended?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpd6egq_6b.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                        paren_groups.append(c)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ append is not a member of List[String] - did you mean paren_groups.appended?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd6egq_6b.scala:26:21 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        paren_groups.size\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parens = paren_string.stripPrefix(\"\
    (\")\n        val nonParens = paren_string.stripSuffix(\")\")\n        val nonParensArray\
    \ = nonParens.toString.split(\"\\\\)\")\n        val parensArray = parens.toString.split(\"\
    \\\\(\")\n        parensArray.zipWithIndex.flatMap { case(parens, i) =>\n    \
    \        if (parens.isEmpty) List()\n            else (parens :: nonParensArray(i)\
    \ :: nonParensArray.take(i+1))\n        }.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1s30ju0x.scala:17:46 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33melse\e[0m (parens :: nonParensArray(i)\
    \ :: nonParensArray.take(i+\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m             \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value :: is not a member of Array[String]\n\e\
    [31m\e[31m-- Error: /tmp/tmp1s30ju0x.scala:18:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        }.toList\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\
    \e[31m   |\e[0m         No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m         where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660013554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        //Initialize result list, we will add\
    \ strings to it when encountering opening parens\n        var result : List[String]\
    \ = List()\n        //Loop through characters in string\n        for (i <- 0 to\
    \ paren_string.length - 1) {\n            //Check if the current character is\
    \ a '('\n            if (paren_string(i) == '(') {\n                //If it is,\
    \ add it to the result list\n                result ::= paren_string(i)\n    \
    \            //Now check if that next character is ')'\n                //If it\
    \ is, add it to the result list\n                if (paren_string(i + 1) == ')')\
    \ {\n                    result ::= paren_string(i)\n                    //Finally,\
    \ check if that next character is ')'\n                    //If it is, add it\
    \ to the result list\n                    if (paren_string(i + 2) == ')') {\n\
    \                        result ::= paren_string(i)\n                    }\n \
    \               }\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpru8ukocd.scala:18:23 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                result ::= paren_string(i)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not\
    \ a member of List[String] - did you mean List[String].::?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpru8ukocd.scala:22:27 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                    result ::= paren_string(i)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not\
    \ a member of List[String] - did you mean List[String].::?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpru8ukocd.scala:26:31 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                        result ::= paren_string(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::=\
    \ is not a member of List[String] - did you mean List[String].::?\n3 errors found\n"
  stdout: ''
  timestamp: 1660013553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_string_list = paren_string.trim().replaceAll(\"\
    \ \", \"\").split(\",\")\n        val paren_stack = new mutable.Stack[String]()\n\
    \        val paren_groups = new mutable.ArrayBuffer[String]()\n        for(i <-\
    \ 0 until paren_string_list.length) {\n            val current_string = (paren_stack.lastOption\
    \ match {\n                case None => paren_string_list(i)\n               \
    \ case Some(current_string) => current_string + paren_string_list(i)\n       \
    \     })\n            paren_stack += current_string\n            if(current_string.matches(\"\
    \\\\)\")) {\n                val closed_string = current_string.substring(0,current_string.length-1)\n\
    \                if(closed_string != \"\" && paren_stack.lastOption.exists(closed_string.matches(\"\
    \\\\(\"))) {\n                    paren_groups += closed_string\n            \
    \    } else {\n                    paren_groups += current_string\n          \
    \      }\n                paren_stack.pop\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmd_k6m78.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_stack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmd_k6m78.scala:13:31\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_groups\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mString\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpmd_k6m78.scala:17:45 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m Some(current_string)\
    \ => current_string + paren_string_list(i)\n\e[31m\e[31m   |\e[0m            \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \           Recursive \e[33mvalue\e[0m \e[35mcurrent_string\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \\\\(|\\\\)\").toList\n        val strings_stack = Stack[String]()\n        val\
    \ strings = mutable.ListBuffer[String]()\n        var strings_to_add = paren_groups.reverse.foldLeft(mutable.Stack[String]())((string_stack,\
    \ paren_group) => {\n            if (paren_group.length <= 0) {\n            \
    \    strings_stack push string\n                string\n            } else if\
    \ (\"\\\\(\" == paren_group) {\n                strings_stack push paren_group\n\
    \            } else if (\"\\\\)\" == paren_group) {\n                strings_stack\
    \ push string\n                strings_stack push paren_group\n            } else\
    \ {\n                strings_stack push string\n                string\n     \
    \       }\n        })\n        while (!strings_to_add.isEmpty) {\n           \
    \ strings push strings_to_add take strings_to_add length\n        }\n        strings.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp52ipkhig.scala:29:66 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            strings push strings_to_add take strings_to_add\
    \ length\n\e[31m\e[31m   |\e[0m                                              \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp52ipkhig.scala:13:22 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mstrings\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp52ipkhig.scala:14:59 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mstrings_to_add\e[0m = paren_groups.reverse.foldLeft(mutable.Stack[\e\
    [35mString\e[0m]())((\e[36mstring_stack\e[0m, \e[36mparen_group\e[0m) => {\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                                              \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp52ipkhig.scala:16:35 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m                strings_stack push string\n\e[31m\e[31m   |\e[0m          \
    \                         ^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \            Not found: string\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp52ipkhig.scala:17:16 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m                string\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: string\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with"
  stdout: ''
  timestamp: 1660013553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def closeParen(group_str : String) : Boolean\
    \ = {\n            val closeParen_index = paren_string.indexOf(group_str)\n  \
    \          group_str.contains(\" \") && closeParen_index == -1\n        }\n\n\
    \        val group_strs = paren_string.split(\"\\\\()\")\n        val group_sizes\
    \ = group_strs.map(paren_string => paren_string.length)\n\n        val open_counts\
    \ = group_sizes.scanLeft(0)(_ + 1).filter(_ > 0)\n        val group_to_close =\
    \ open_counts.scanLeft(0)(_ + 1)\n\n        val closing = group_sizes.zip(group_to_close)\n\
    \        val opening = open_counts.zip(group_to_close)\n\n        val final_closing\
    \ = closing.filter(_._2 > 0)\n        val final_opening = opening.filter(_._2\
    \ > 0)\n\n        val closed = final_closing.filter(_._2 > 0)\n        val opening\
    \ = final_opening.filter(_._2 > 0)\n\n        closed.map(str => paren_string.split(str._1).head).distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjerf8ql.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopening\e[0m = final_opening.filter(_._2\
    \ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopening is already defined as \e[33mvalue\e[0m \e[35mopening\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpkjerf8ql.scala:19:50 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mopen_counts\e[0m = group_sizes.scanLeft(\e\
    [31m0\e[0m)(_ + \e[31m1\e[0m).filter(_ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                  ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                 Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E086] Syntax Error: /tmp/tmpkjerf8ql.scala:20:53 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgroup_to_close\e[0m = open_counts.scanLeft(\e\
    [31m0\e[0m)(_ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \            Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpkjerf8ql.scala:31:49 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        closed.map(\e[36mstr\e[0m => paren_string.split(str._1).head).distinct\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                             Found:    Int\n\e\
    [31m   |\e[0m                                             Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list_of_strings = List[String]()\n\
    \        var current_string = \"\"\n        var open_braces : Int = paren_string.count('(')\n\
    \        var close_braces : Int = paren_string.count(')')\n        var current_string\
    \ = \"\"\n        var new_string_list : List[String] = List[String]()\n\n    \
    \    for (i <- 0 until paren_string.length){\n            // If the character\
    \ is an open bracket\n            if (paren_string(i) == '('){\n             \
    \   // If the current string is empty, add it to the list of strings\n       \
    \         if (current_string.isEmpty){\n                    current_string +=\
    \ \"(\"\n                }\n                // Otherwise, add it to the list of\
    \ strings if the previous string has just one element\n                else {\n\
    \                    if (new_string_list.length == 0){\n                     \
    \   list_of_strings ::= current_string\n                    }\n              \
    \      else {\n                        list_of_strings ::= current_string\n  \
    \                  }\n                    new_string_list ::= \"\"\n         \
    \           current_string = \"\"\n                }\n            }\n        \
    \    \n            // If the character is a closing bracket\n            if (paren_string(i)\
    \ == ')'){\n                // If the current string is empty, add it to the list\
    \ of strings\n                if (current_string.isEmpty){\n                 \
    \   current_string += \")\"\n                }\n                // Otherwise,\
    \ add it to the list of strings if the previous string has just one element\n\
    \                else {\n                    if (new_string_list.length == 0){\n\
    \                        list_of_strings ::= current_string\n                \
    \    }\n                    else {\n                        list_of_strings ::=\
    \ current_string\n                    }\n                    new_string_list ::=\
    \ \"\"\n                    current_string = \"\"\n                }\n       \
    \     }\n            \n            // If the character is a space\n          \
    \  if (paren_string(i) == ' '){\n                // If the current string is empty,\
    \ add it to the list of strings\n                if (current_string.isEmpty){\n\
    \                    current_string += \" \"\n                }\n            \
    \    // Otherwise, add it to the list of strings if the previous string has just\
    \ one element\n                else {\n                    if (new_string_list.length\
    \ == 0){\n                        list_of_strings ::= current_string\n       \
    \             }\n                    else {\n                        list_of_strings\
    \ ::= current_string\n                    }\n                    new_string_list\
    \ ::= \"\"\n                    current_string = \"\"\n                }\n   \
    \         }\n        }\n\n        // If an open brace is left over, add it to\
    \ the list of strings\n        if (new_string_list.length > 0){\n            if\
    \ (new_string_list.length == 1){\n                list_of_strings ::= new_string_list\n\
    \            }\n            else {\n                list_of_strings ::= new_string_list\n\
    \            }\n        }\n\n        // If there are still open braces left over,\
    \ add those to the list of strings\n        if (open_braces > close_braces){\n\
    \            for (i <- 0 until open_braces - close_braces){\n                list_of_strings\
    \ ::= \"\"\n            }\n        }\n\n        // If the parenthesis groups are\
    \ balanced, remove \n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ninqd41.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mcurrent_string\e[0m = \e\
    [31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcurrent_string is already defined as \e[33mvariable\e[0m \e[35mcurrent_string\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7ninqd41.scala:13:51 --------------------\e[0m\e[0m\n\
    \e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mopen_braces\e[0m : \e[35mInt\e[0m\
    \ = paren_string.count(\e[31m'('\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                                   ^^^\e[0m\n\e[31m   |\e[0m                \
    \                               Found:    (\e[31m'('\e[0m : Char)\n\e[31m   |\e\
    [0m                                               Required: Char => Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ninqd41.scala:14:52\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mclose_braces\e\
    [0m : \e[35mInt\e[0m = paren_string.count(\e[31m')'\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                    ^^^\e[0m\n\e[31m   |\e\
    [0m                                               Found:    (\e[31m')'\e[0m :\
    \ Char)\n\e[31m   |\e[0m                                               Required:\
    \ Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7ninqd41.scala:80:32\
    \ ------------------------\e[0m\e[0m\n\e[31m80 |\e[0m                list_of_strings\
    \ ::= new_string_list\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7ninqd41.scala:83:32 ------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m                list_of_strings ::= new_string_list\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val open_braces = mutable.ListBuffer.empty[String]\n\
    \        val closed_braces = mutable.ListBuffer.empty[String]\n\n        val stack\
    \ = mutable.Stack[String]()\n\n        for (c <- paren_string) {\n           \
    \ if (c == '(') {\n                stack += '('\n                open_braces +=\
    \ c\n            } else if (c == '[') {\n                stack += '['\n      \
    \      } else if (c == '{') {\n                stack += '{'\n            } else\
    \ if (c == '[' || c == '{') {\n                stack += c\n            } else\
    \ if (c == '(') {\n                if (stack.isEmpty)\n                    throw\
    \ new Exception(\"Mismatched brackets\")\n                else {\n           \
    \         val top = stack.pop()\n                    if (top == '(')\n       \
    \                 closed_braces += top\n                    else if (top == '{')\n\
    \                        closed_braces += top\n                    else if (top\
    \ == '[')\n                        closed_braces += top\n                    else\
    \ if (top == ')')\n                        open_braces += top\n              \
    \  }\n            }\n        }\n\n        // Check to make sure that the stack\
    \ only contains parens\n        if (!stack.isEmpty && !stack.head == ')')\n  \
    \          throw new Exception(\"Mismatched brackets\")\n\n        stack.foreach\
    \ { _ => }\n\n        // Make sure that every brace has been closed\n        if\
    \ (closed_braces.nonEmpty)\n            throw new Exception(\"Mismatched closing\
    \ braces\")\n\n        open_braces.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvupvt3qa.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mopen_braces\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvupvt3qa.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mclosed_braces\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvupvt3qa.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateGroups(paren_string: String)\
    \ : List[String] = {\n            def getOpenParens() : List[String] = paren_string.trim().split(\"\
    \\\\(\").toList\n            def closeParens = getOpenParens().map(s => { if (s.endsWith(\"\
    )\")) s + \"}\" else s + \"}\" })\n            def closeParensGroups: List[String]\
    \ = closeParens.map(s => { if (s.endsWith(\"(\")) s + \"(\" else s + \"(\") })\n\
    \            def isBalanced(str: List[String]) : Boolean = str.map(b => { if (b.endsWith(\"\
    )\")) true else false }).sum == 1\n            def getRemainingParantheses(str:\
    \ List[String]) : List[String] = str.filterNot( s => { if (s.endsWith(\")\"))\
    \ true else false }).reverse\n            def getRemainingGroups(str: List[String])\
    \ : List[String] = getRemainingParantheses(getOpenParens()).reverse.map(s => {\
    \ if (s.endsWith(\")\")) s + \"(\" else s + \"(\" })\n\n            val remainingParantheses\
    \ = getRemainingParantheses(getOpenParens())\n            val remainingGroups\
    \ = getRemainingGroups(remainingParantheses)\n            val remainingGroupsList\
    \ = remainingGroups.map(s => \"(\" + s + \")\").filter(s => s.endsWith(\")\")).reverse\n\
    \            val remainingParanthesesList = remainingParantheses.map(s => \"(\"\
    \ + s + \")\").filter(s => s.endsWith(\")\")).reverse\n            val openGroups\
    \ = getOpenParens().map(s => { if (s.endsWith(\")\")) s + \"(\" else s + \"(\"\
    \ })\n            val openGroupsList = openGroups.map(s => \"(\" + s + \")\").filter(s\
    \ => s.endsWith(\")\")).reverse\n            val remainingParanthesesList: List[String]\
    \ = remainingParantheses.filter(s => s.endsWith(\")\")).reverse\n            if\
    \ (remainingGroupsList.size == remainingParanthesesList.size) {\n            \
    \    remainingGroupsList\n            } else if (remainingGroupsList.size == (openGroupsList.size\
    \ + remainingParanthesesList.size)) {\n                remainingGroupsList.zip(openGroupsList).filter(_._1.endsWith(\"\
    )\")).map(_._1).reverse\n            } else if (remainingGroupsList.size == remainingParanthesesList.size\
    \ + 1) {\n                remainingGroupsList.zip(remainingParantheses).filter(_._1.endsWith(\"\
    )\")).map(_._1).reverse\n            } else {\n                println(\"Group\
    \ count mismatch with parantheses count\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8ugc8md4.scala:14:114 --------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mdef\e[0m \e[36mcloseParensGroups\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = closeParens.map(\e[36ms\e[0m => { \e\
    [33mif\e[0m (s.endsWith(\e[31m\"(\"\e[0m)) s + \e[31m\"(\"\e[0m \e[33melse\e[0m\
    \ s + \e[31m\"(\"\e[0m) })\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \          ^\e[0m\n\e[31m   |\e[0m                                           \
    \  '}' expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8ugc8md4.scala:14:117\
    \ --------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mdef\e\
    [0m \e[36mcloseParensGroups\e[0m: \e[35mList\e[0m[\e[35mString\e[0m] = closeParens.map(\e\
    [36ms\e[0m => { \e[33mif\e[0m (s.endsWith(\e[31m\"(\"\e[0m)) s + \e[31m\"(\"\e\
    [0m \e[33melse\e[0m s + \e[31m\"(\"\e[0m) })\n\e[31m\e[31m   |\e[0m          \
    \                                                                            \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                       '}' expected, but ')' found\n2 errors found\n"
  stdout: ''
  timestamp: 1660013555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var cur_string = \"\"\n        var group_stack\
    \ : Stack[String] = new Stack[String]()\n        var group_list : List[String]\
    \ = Nil\n        var cur_group_str = \"\"\n\n        for(c <- paren_string)\n\
    \        {\n            cur_group_str += c\n            if(c == '(')\n       \
    \     {\n                group_stack.push(cur_group_str)\n                cur_group_str\
    \ = \"\"\n            }\n            else if(c == ')')\n            {\n      \
    \          cur_group_str = group_stack.pop()\n                group_list ::= cur_group_str\n\
    \            }\n        }\n\n        cur_group_str\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdfkln9m2.scala:31:8\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m        cur_group_str\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (cur_group_str\
    \ : String)\n\e[31m   |\e[0m        Required: List[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \\\\(|\\\\)\").filter(x => x.trim().length > 0)\n        val open_parens = paren_groups.map(x\
    \ => x.count(\"\\\\(\") + x.count(\"\\\\)\")).toArray\n        val closed_parens\
    \ = paren_groups.map(x => x.count(\"\\\\)\") - x.count(\"\\\\(\")).toArray\n \
    \       val final_parens = open_parens.zip(closed_parens).toList.map(x => (x._1,\
    \ x._2))\n        final_parens.toList.flatten.filter(x => !x._1.contains(\"(\"\
    ) && !x._1.contains(\")\")).map(x => x._2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8339ftyb.scala:12:56\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mopen_parens\e\
    [0m = paren_groups.map(\e[36mx\e[0m => x.count(\e[31m\"\\\\(\"\e[0m) + x.count(\e\
    [31m\"\\\\)\"\e[0m)).toArray\n\e[31m\e[31m   |\e[0m                          \
    \                              ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                           Found:    (\e[32m\"\\\\(\"\e[0m : String)\n\e[31m\
    \   |\e[0m                                              Required: Char => Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8339ftyb.scala:12:73\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mopen_parens\e\
    [0m = paren_groups.map(\e[36mx\e[0m => x.count(\e[31m\"\\\\(\"\e[0m) + x.count(\e\
    [31m\"\\\\)\"\e[0m)).toArray\n\e[31m\e[31m   |\e[0m                          \
    \                                               ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                            Found:    (\e[32m\"\\\\)\"\e[0m :\
    \ String)\n\e[31m   |\e[0m                                              Required:\
    \ Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8339ftyb.scala:13:58\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mclosed_parens\e\
    [0m = paren_groups.map(\e[36mx\e[0m => x.count(\e[31m\"\\\\)\"\e[0m) - x.count(\e\
    [31m\"\\\\(\"\e[0m)).toArray\n\e[31m\e[31m   |\e[0m                          \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                             Found:    (\e[32m\"\\\\)\"\e[0m : String)\n\e[31m\
    \   |\e[0m                                              Required: Char => Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8339ftyb.scala:13:75\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mclosed_parens\e\
    [0m = paren_groups.map(\e[36mx\e[0m => x.count(\e[31m\"\\\\)\"\e[0m) - x.count(\e\
    [31m\"\\\\(\""
  stdout: ''
  timestamp: 1660013561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var parentheses = mutable.Set[Char]()\n\
    \        var paren_groups = mutable.Set[String]()\n        paren_string.foreach(c\
    \ => {\n            if (c == '(' || c == '[' || c == '{') {\n                parentheses\
    \ += c\n            } else if (c == '}') {\n                if (parentheses.size\
    \ == 0) {\n                    throw new Exception(\"Unexpected closing brace:\
    \ \" + c)\n                }\n                paren_groups += parenthesis.head\
    \ + c\n                parentheses.clear\n            } else if (c == ')' && parentheses.nonEmpty)\
    \ {\n                if (parentheses.size == 0) {\n                    throw new\
    \ Exception(\"Unexpected closing parenthesis: \" + c)\n                }\n   \
    \             paren_groups += parenthesis.head + c\n                parentheses.clear\n\
    \            } else {\n                parentheses.clear\n            }\n    \
    \    })\n        paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpezbf66r1.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mparentheses\e[0m = mutable.Set[\e\
    [35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpezbf66r1.scala:12:27 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mparen_groups\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // This list will hold all the separate\
    \ groups of parentheses\n        var groups: List[String] = Nil\n        // This\
    \ list will hold all the unpaired opening brackets\n        var unpaired_groups:\
    \ List[String] = Nil\n        // This counter will help us know when a closing\
    \ bracket is found\n        var brace_count = 0\n        // Loop through every\
    \ character in the string\n        for(c <- paren_string) {\n            // Ignore\
    \ space\n            if(c == ' ') continue\n            // If the current character\
    \ is a left parenthesis\n            if(c == '(') {\n                // If there\
    \ are unpaired groups of parenthesis\n                if(unpaired_groups.length\
    \ > 0) {\n                    // If all unpaired groups are closed right after\
    \ a left parenthesis\n                    if(brace_count == unpaired_groups.length)\
    \ {\n                        // Add the unpaired groups to the groups list\n \
    \                       groups = unpaired_groups.::groups\n                  \
    \      // Empty the unpaired groups as we found the closing right parenthesis\n\
    \                        unpaired_groups = Nil\n                    }\n      \
    \              // Else, add all the unpaired groups to the unpaired groups list\n\
    \                    else unpaired_groups = unpaired_groups.::groups\n       \
    \         }\n                // Else, add that left parenthesis to the unpaired\
    \ groups list\n                unpaired_groups = Nil\n                // Increment\
    \ the brace count\n                brace_count += 1\n            }\n         \
    \   // Else, check if it is an opening bracket\n            else if(c == '[')\
    \ {\n                // If there are unpaired groups of brackets\n           \
    \     if(unpaired_groups.length > 0) {\n                    // If all unpaired\
    \ groups are closed right before a left bracket\n                    if(brace_count\
    \ == unpaired_groups.length) {\n                        // Add the unpaired groups\
    \ to the groups list\n                        groups = unpaired_groups.::groups\n\
    \                        // Empty the unpaired groups as we found the closing\
    \ right bracket\n                        unpaired_groups = Nil\n             \
    \       }\n                    // Else, add all the unpaired groups to the unpaired\
    \ groups list\n                    else unpaired_groups = unpaired_groups.::groups\n\
    \                }\n                // Else, add that left bracket to the unpaired\
    \ groups list\n                unpaired_groups = Nil\n                // Increment\
    \ the brace count\n                brace_count += 1\n            }\n         \
    \   // Else, add the character to the groups list\n            groups = groups.::c\n\
    \        }\n        // Add the unpaired groups to the groups list\n        groups\
    \ = groups.::unpaired_groups\n        // Return all the groups\n        return\
    \ groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmple6wgrcn.scala:30:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                        unpaired_groups = Nil\n\e[31m\e\
    [31m   |\e[0m                                        ^\e[0m\n\e[31m   |\e[0m \
    \                                end of statement expected but '=' found\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmple6wgrcn.scala:33:67 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    \e[33melse\e[0m unpaired_groups =\
    \ unpaired_groups.::groups\n\e[31m\e[31m   |\e[0m                            \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmple6wgrcn.scala:49:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                        unpaired_groups = Nil\n\e[31m\e\
    [31m   |\e[0m                                        ^\e[0m\n\e[31m   |\e[0m \
    \                                end of statement expected but '=' found\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmple6wgrcn.scala:52:67 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                    \e[33melse\e[0m unpaired_groups =\
    \ unpaired_groups.::groups\n\e[31m\e[31m   |\e[0m                            \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmple6wgrcn.scala:60:31 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m            groups = groups.::c\n\e[31m\e[31m   |\e[0m\
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmple6wgrcn.scala:63:41 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        groups = gro"
  stdout: ''
  timestamp: 1660013559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_groups = ListBuffer[String]()\n\
    \        var in_paren_group : Boolean = false\n        var open_paren = 0\n  \
    \      paren_string.foreach{ c =>\n            if(in_paren_group) paren_groups\
    \ += c\n            if(c == ')' && !in_paren_group) {\n                open_paren\
    \ -= 1\n                in_paren_group = false\n            } else if(c == '('\
    \ && !in_paren_group) {\n                open_paren += 1\n                in_paren_group\
    \ = true\n            } else if(open_paren > 0 && c == '(') {\n              \
    \  open_paren -= 1\n            }\n        }\n        paren_groups.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuhwnbm07.scala:15:47\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m(in_paren_group)\
    \ paren_groups += c\n\e[31m\e[31m   |\e[0m                                   \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \      Found:    (c : Char)\n\e[31m   |\e[0m                                 \
    \              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val paren_groups = paren_string.chars.toList\n\
    \      val pairs = paren_groups .grouped(2)\n        .filter(group => group.head\
    \ == paren_groups.head) &&\n          group.tail.zipWithIndex.flatMap(_ => {\n\
    \            val group_index = group.tail.indexWhere(_ == pair.head) + 1\n   \
    \         val group_size = (group.length - group_index) // -1 for head index\n\
    \            val is_pair = (pair.tail.head == paren_groups.tail(group_size)) &&\n\
    \              (pair.tail.tail.size == paren_groups.size - group_size)\n     \
    \       val is_paired = pair.tail.head == pair.head &&\n              (pair.tail.tail.size\
    \ == (paren_groups.length - 1))\n            val is_open = pair.tail.head == pair.head\
    \ &&\n              (pair.tail.tail.size == 1)\n            if (is_pair && is_paired\
    \ && is_open)\n              (group_index, group_size)\n            else\n   \
    \           Nil\n          }).toList\n      paren_groups.flatMap(group => pairs.find(pair\
    \ => pair.indexOf { x =>\n        pair._1 == group.size\n      }).map(pair =>\
    \ group.substring(pair._1, pair._2))).distinct\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2ztbqz3e.scala:11:44 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m      \e[33mval\e[0m \e[36mparen_groups\e[0m = paren_string.chars.toList\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m              value toList is not a member of java.util.stream.IntStream\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Use a regex to match groups of nested\
    \ parentheses\n        val nestedParens = \"\"\"[(]([^)]*[)]*)\"\"\".r\n\n   \
    \     // Create a mutable buffer of results to return\n        var results: List[String]\
    \ = Nil\n\n        // Iterate through the string character-by-character, updating\
    \ the mutable buffer as the string changes.\n        // When a closing paren is\
    \ found, add it to the list of results and clear the buffer\n        val group\
    \ = new mutable.StringBuilder\n        for (ch <- paren_string.toCharArray) {\n\
    \            group append ch\n            if (ch == '(') {\n                group\
    \ append ch\n            } else if (ch == '[') {\n                group append\
    \ ch\n            } else if (ch == '{') {\n                group append ch\n \
    \           } else if (ch == ')') {\n                results = results :+ group.toString\n\
    \                group.clear()\n            } else {\n                // If anything\
    \ else is found, just add the ch to the buffer and clear it\n                group\
    \ append ch\n                group.clear()\n            }\n        }\n       \
    \ // Finally, add the final part of the buffer (if it exists)\n        results\
    \ = results :+ group.toString\n\n        // Return the list of results\n     \
    \   results\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp31ka3n0t.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mgroup\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013558
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"((\\\\(|\\\\s))+\"\
    ).filter(x => x.startsWith(\"(\") && x.endsWith(\")\")).map(x => x.substring(1,x.length-1)).filter(x\
    \ => !x.startsWith(\"(\") && !x.endsWith(\")\")).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi6qvovka.scala:14)\n\tat Problem.main(tmpi6qvovka.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var parens : List[String] = Nil\n    \
    \    var open_braces : List[String] = Nil\n        var closed_braces : List[String]\
    \ = Nil\n        var in_parens : List[String] = Nil\n        var output : List[String]\
    \ = Nil\n        paren_string.foreach {\n            case c if c == '(' => open_braces\
    \ = open_braces :+ c\n            case c if c == '{' => closed_braces = closed_braces\
    \ :+ c\n            case c if c == '}' => if (closed_braces.isEmpty) in_parens\
    \ = in_parens :+ c\n                                  else parens = parens :+\
    \ c\n            case c if in_parens.isEmpty  => parens = parens :+ c\n      \
    \      case c if in_parens.contains(c) => in_parens = in_parens :+ c\n       \
    \     case c if parens.isEmpty  => in_parens = in_parens :+ c\n            case\
    \ c if parens.contains(c) => parens = parens :+ c\n            case c if open_braces.isEmpty\
    \  => in_parens = in_parens :+ c\n            case c if open_braces.contains(c)\
    \ => open_braces = open_braces :+ c\n            case c if closed_braces.isEmpty\
    \  => in_parens = in_parens :+ c\n            case c if closed_braces.contains(c)\
    \ => closed_braces = closed_braces :+ c\n            case c if c == ')' && open_braces.isEmpty\
    \  => in_parens = in_parens :+ c\n            case c if c == ')' && open_braces.contains(c)\
    \ => open_braces = open_braces :+ c\n            case c if c == '}' && closed_braces.isEmpty\
    \  => in_parens = in_parens :+ c\n            case c if c == '}' && closed_braces.contains(c)\
    \ => closed_braces = closed_braces :+ c\n            case c => output = output\
    \ :+ c\n        }\n        parens\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpndb69t6x.scala:17:63\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m c\
    \ \e[33mif\e[0m c == \e[31m'('\e[0m => open_braces = open_braces :+ c\n\e[31m\e\
    [31m   |\e[0m                                                               ^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    (c : Char)\n\e[31m   |\e[0m                                             \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpndb69t6x.scala:18:67 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m            \e[33mcase\e[0m c \e[33mif\e[0m c == \e[31m'{'\e[0m => closed_braces\
    \ = closed_braces :+ c\n\e[31m\e[31m   |\e[0m                                \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                                  Found:    (c : Char)\n\e[31m   |\e[0m     \
    \                                               Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpndb69t6x.scala:19:86 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m c \e[33mif\e[0m c == \e[31m'}'\e\
    [0m => \e[33mif\e[0m (closed_braces.isEmpty) in_parens = in_parens :+ c\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \                     Found:    (c : Char)\n\e[31m   |\e[0m                  \
    \                                  Required: String\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpndb69t6x.scala:20:58 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                                  \e[33melse\e[0m parens\
    \ = parens :+ c\n\e[31m\e[31m   |\e[0m                                       \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \                  Found:    (c : C"
  stdout: ''
  timestamp: 1660013565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create a list of characters in the\
    \ input string\n        val input_string  = paren_string.filterNot(_.isWhitespace).toList\n\
    \        // Create a list of stacked paren characters (i.e. ()())\n        val\
    \ paren_list   = mutable.Stack[Char]()\n        // Create a list for the final\
    \ result (a stacked list of the above stacked paren characters)\n        val result_list\
    \ = mutable.Stack[String]()\n        // Create an empty list to hold the results\
    \ of any recursion call\n        var result_stack: List[String] = Nil\n      \
    \  // The actual recursion function. Takes a single character from the input string,\
    \ checks it for\n        // a valid paren character, and pushes that character\
    \ onto the appropriate stack\n        def recurse(character : Char) : Unit = {\n\
    \            val open_paren = if (paren_list.nonEmpty) paren_list.head else character\n\
    \            val close_paren = if (paren_list.nonEmpty) paren_list.head else character\n\
    \            if (open_paren == '(' && close_paren == ')') paren_list.push(')')\n\
    \            else paren_list.push(open_paren)\n        }\n        // Iterate over\
    \ the characters in the input string\n        for (ii <- input_string.indices)\
    \ {\n            val current_character = input_string(ii)\n            recurse(current_character)\n\
    \            result_list += current_character\n            if (paren_list.nonEmpty)\
    \ {\n                val stacked_paren = paren_list.mkString\n               \
    \ if (stacked_paren.length == 1) {\n                    result_stack += stacked_paren\n\
    \                } else {\n                    result_stack += (paren_list.mkString)\n\
    \                }\n                paren_list.clear()\n            }\n      \
    \  }\n        result_stack\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7evw6j7n.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e[0m   = mutable.Stack[\e\
    [35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp7evw6j7n.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp7evw6j7n.scala:35:33 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    result_stack += stacked_paren\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ += is not a member of List[String] - did you mean List[String].!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp7evw6j7n.scala:37:33 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    result_stack += (paren_list.mkString)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ += is not a member of List[String] - did you mean List[String].!=?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val groups: List[String] = ListBuffer[String]()\n\
    \n        for (c <- paren_string.dropRight(1)) {\n            val char = c\n \
    \           val isGroup = char == \")\"\n            if (isGroup) {\n        \
    \        groups += c\n            } else {\n                groups.reverse.toList\
    \ match {\n                    case head :: tail => if (tail.length == 0) List(head)\
    \ else head :: tail\n                    case Nil => List(head)\n            \
    \    }\n            }\n        }\n        groups.reverse.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5p2k4nbz.scala:11:53\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mgroups\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = ListBuffer[\e[35mString\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   Found:    scala.collection.mutable.ListBuffer[String]\n\
    \e[31m   |\e[0m                   Required: List[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp5p2k4nbz.scala:15:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36misGroup\e[0m = char\
    \ == \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5p2k4nbz.scala:17:23\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                groups +=\
    \ c\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \  value += is not a member of List[String] - did you mean groups.!=?\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5p2k4nbz.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    \e[33mcase\e[0m Nil => List(head)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                     Not found: head\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: Your code goes here\n       \
    \ val paren_str = paren_string.trim\n        val groups = new mutable.Stack[String]\n\
    \        var curr = new mutable.Stack[String]\n        for(i <- 0 until paren_str.length)\
    \ {\n            if(paren_str(i) == '(') groups.push('(')\n            else if(paren_str(i)\
    \ == ')') {\n                curr.toList.reverse.foreach(x => {\n            \
    \        groups.push(curr.toList.toList)\n                    groups.toList.reverse.foreach\
    \ { y => \n                        if(y == '(') groups.remove(x)\n           \
    \             if(y == ')') {\n                            groups.remove(x)\n \
    \                           if(groups.size == 0) groups.push(')')\n          \
    \              }\n                    }\n                })\n            }\n \
    \           else {\n                curr.push(paren_str(i))\n            }\n \
    \       }\n        val output = groups.toList.reverse.foreach(x => if(x.toString.length\
    \ == 1 || x.toString.length == 2) x else x + \"+\")\n        output\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_vmguu62.scala:13:25 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mgroups\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_vmguu62.scala:14:23\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e\
    [36mcurr\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mString\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val ps = paren_string.split(\"\\\\s+\"\
    )\n        var ret_string = List[String]()\n        var level = 0\n        ps.foreach(\
    \ x => {\n            if(x.equals(\"(\")) {\n                level += 1\n    \
    \        }\n            if(x.equals(\")\")) {\n                level -= 1\n  \
    \          }\n            if(level == 0) {\n                ret_string ::= x\n\
    \            }\n        })\n        ret_string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvft3vmff.scala:28)\n\tat Problem.main(tmpvft3vmff.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if(paren_string.length == 0) return Nil\n\
    \        if(paren_string.indexOf(\"(\") != -1 && paren_string.indexOf(\")\") !=\
    \ -1) return List(paren_string)\n        val open_parens = mutable.HashSet[Char]()\n\
    \        var new_paren_string = paren_string\n        for(i <- 0 until new_paren_string.length)\
    \ {\n            val c = new_paren_string(i)\n            if(!open_parens.contains(c))\
    \ {\n                if(!(c == '(' && open_parens.contains('('))) open_parens\
    \ += c\n                new_paren_string = new_paren_string.substring(0, i) +\
    \ \")\" + new_paren_string.substring(i + 1)\n            }\n        }\n      \
    \  val close_parens = mutable.HashSet[Char]()\n        open_parens.foreach { c\
    \ =>\n            if(!close_parens.contains(c)) {\n                if(!(c == ')'\
    \ && close_parens.contains('('))) close_parens += c\n            }\n        }\n\
    \        close_parens.foreach { c =>\n            if(!new_paren_string.contains(c))\
    \ {\n                new_paren_string = new_paren_string.substring(0, new_paren_string.length\
    \ - 1) + \"(\" + new_paren_string.substring(new_paren_string.length - 1)\n   \
    \         }\n        }\n        close_parens.reverse.map(c => new_paren_string.substring(0,\
    \ new_paren_string.length - 1) + \"(\" + new_paren_string.substring(new_paren_string.length\
    \ - 1)\n                + \")\" + c).distinct\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy0bz77zc.scala:13:26 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mopen_parens\e[0m = mutable.HashSet[\e\
    [35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpy0bz77zc.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclose_parens\e[0m = mutable.HashSet[\e\
    [35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups: List[String] = new mutable.MutableList[String]()\n\
    \        var open_braces : Int = 0\n\n        // Iterate over string\n       \
    \ for (i <- 0 until paren_string.length) {\n            // If character is (\n\
    \            if (paren_string(i) == '(') {\n                // Add open brace\
    \ and increment the count of open braces\n                paren_groups.add(paren_string(i))\n\
    \                open_braces += 1\n            }\n            // Else if character\
    \ is )\n            else if (paren_string(i) == ')') {\n                // Remove\
    \ 1 from the count of open braces\n                open_braces -= 1\n        \
    \    }\n            // If open brace count is 0\n            if (open_braces ==\
    \ 0) {\n                // Add element to the list\n                paren_groups.add(paren_string(i))\n\
    \            }\n        }\n\n        // Return the list of strings\n        return\
    \ paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9lcl9tar.scala:11:45 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = \e[33mnew\e[0m mutable.MutableList[\e[35mString\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                             Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9lcl9tar.scala:19:29\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                paren_groups.add(paren_string(i))\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \              value add is not a member of List[String]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9lcl9tar.scala:30:29 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m                paren_groups.add(paren_string(i))\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is\
    \ not a member of List[String], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = mutable.ArrayBuffer.empty[String]\n\
    \        paren_string.split(\"\"\"\\s+\"\"\").foreach { paren_string =>\n    \
    \        if(paren_string.length > 1) {\n                paren_groups += paren_string.slice(1,\
    \ paren_string.length - 1)\n            } else {\n                paren_groups\
    \ += paren_string\n            }\n        }\n        paren_groups.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqna8xrd6.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.trim\n            .split(\"\
    \\\\s+\".r) //split on whitespace\n            .map(s => if (s.startsWith(\"(\"\
    )) s.drop(1) else s) //drop the paren char at the beginning of the string if it\
    \ exists\n            .filter(!paren_string.startsWith(\"(\")) //filter out all\
    \ paren strings starting with paren\n            .filter(!paren_string.endsWith(\"\
    )\")) //filter out all paren strings ending with paren\n            .filter(!paren_string.contains(\"\
    (\") || !paren_string.contains(\")\"))  //filter out nested paren strings\n  \
    \          .distinct\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_czhyhq7.scala:12:26\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            .split(\e[31m\"\\\
    \\s+\"\e[0m.r) \e[34m//split on whitespace\e[0m\n\e[31m\e[31m   |\e[0m       \
    \            ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    scala.util.matching.Regex\n\
    \e[31m   |\e[0m                   Required: String\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_czhyhq7.scala:14:20 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            .filter(!paren_string.startsWith(\e[31m\"\
    (\"\e[0m)) \e[34m//filter out all paren strings starting with paren\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Found:    Boolean\n\e[31m   |\e[0m               \
    \     Required: \e[1m\e[32mString\e[0m\e[1m\e[32m \e[0m\e[1m\e[32m=\e[0m\e[1m\e\
    [32m>\e[0m\e[1m\e[32m \e[0mBoolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_czhyhq7.scala:15:20 --------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m            .filter(!paren_string.endsWith(\e[31m\")\"\e[0m)) \e[34m//filter\
    \ out all paren strings ending with paren\e[0m\n\e[31m\e[31m   |\e[0m        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \     Found:    Boolean\n\e[31m   |\e[0m                    Required: \e[1m\e\
    [32mString\e[0m\e[1m\e[32m \e[0m\e[1m\e[32m=\e[0m\e[1m\e[32m>\e[0m\e[1m\e[32m\
    \ \e[0mBoolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_czhyhq7.scala:16:20\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            .filter(!paren_string.contains(\e\
    [31m\"(\"\e[0m) || !paren_string.contains(\e[31m\")\"\e[0m))  \e[34m//filter out\
    \ nested paren strings\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    Boolean\n\e[31m   |\e[0m   \
    \                 Required: \e[1m\e[32mString\e[0m\e[1m\e[32m \e["
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_array = new mutable.ArrayBuilder[String]\n\
    \        def paren_collector(paren_string : String) : Unit = {\n            paren_array\
    \ += paren_string\n        }\n        def brace_collector(paren_string : String)\
    \ : Unit = {\n            if(paren_string.startsWith(\"{\")) paren_collector(paren_string)\n\
    \            else if(!paren_string.startsWith(\"}\"))\n                paren_collector(paren_string)\n\
    \            else\n                brace_collector(paren_string.substring(0,paren_string.length-1))\n\
    \        }\n        for(i <- 0 until paren_string.length) {\n            if(paren_string(i)\
    \ == \")\") brace_collector(paren_string(i+1))\n        }\n        paren_array.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw39e2p7i.scala:11:30 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_array\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuilder[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpw39e2p7i.scala:23:15\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \     \e[33mif\e[0m(paren_string(i) == \e[31m\")\"\e[0m) brace_collector(paren_string(i+\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw39e2p7i.scala:23:67\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(paren_string(i)\
    \ == \e[31m\")\"\e[0m) brace_collector(paren_string(i+\e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                       ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Char\n\e[31m   |\e[0m                                                   \
    \    Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Step 1: Build a stack that stores the\
    \ position of every open brace encountered\n        val stack = mutable.Stack.empty[Int]\n\
    \        // Step 2: Push the start index of the parentheses, this will be the\
    \ top of the stack\n        paren_string.indexOf('(')\n        paren_string.indexOf(')')\
    \ match {\n            case -1 => paren_string\n            case index => paren_string.substring(0,\
    \ index) + paren_string.substring(index + 1)\n        }\n        // Step 3: Push\
    \ the length of every opened brace\n        paren_string.indexOf('(') match {\n\
    \            case -1 => paren_string\n            case index => paren_string.length\n\
    \        }\n        // Step 4: Push zero to indicate a closed brace\n        paren_string.indexOf('(')\
    \ match {\n            case -1 => paren_string\n            case index => paren_string.length\n\
    \        }\n        // Step 5: Keep going while there are unmatched opening braces\n\
    \        while(!stack.isEmpty) {\n            // Step 6: Pop the length of the\
    \ previously open brace\n            val length = stack.pop()\n            //\
    \ Step 7: Pop out the last opened brace\n            val lastOpenedBrace = paren_string.length\
    \ - length\n            // Step 8: Remove that last opened brace\n           \
    \ paren_string = paren_string.substring(0, lastOpenedBrace) + paren_string.substring(lastOpenedBrace\
    \ + 1)\n            // Step 9: Push the length of the new opened brace\n     \
    \       paren_string.indexOf('(') match {\n                case -1 => paren_string\n\
    \                case index => paren_string.length\n            }\n        }\n\
    \        // Step 10: If the parentheses are not balanced, return an empty list\n\
    \        if(paren_string.length != paren_string.indexOf('(')) {\n            return\
    \ Nil\n        } else {\n            // Step 11: Return any extra parentheses\n\
    \            paren_string.indexOf('(')\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp37dozm9u.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp37dozm9u.scala:36:25 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            paren_string = paren_string.substring(\e\
    [31m0\e[0m, lastOpenedBrace) + paren_string.substring(lastOpenedBrace + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val paren_string\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp37dozm9u.scala:48:32 --------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            paren_string.indexOf(\e[31m'('\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    Int\n\e[31m   |\e[0m            Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp37dozm9u.scala:39:27\
    \ ----------------\e[0m\e[0m\n\e[33m39 |\e[0m                \e[33mcase\e[0m -\e\
    [31m1\e[0m => paren_string\n\e[33m\e[33m   |\e[0m                           ^^^^^^^^^^^^\e\
    [0m\n\e[33m   |\e[0mA pure expression does nothing in statement position; you\
    \ may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 warning found\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string == \"\") List(\"\")\n\
    \        else paren_string.groupBy(x => x).mapValues(_.map(_._1).mkString).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqh4k8lg9.scala:12:60 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33melse\e[0m paren_string.groupBy(x => x).mapValues(_.map(_._1).mkString).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                        value _1\
    \ is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_paren_groups = mutable.ListBuffer[String]()\n\
    \        paren_string.split(\"\\\\s+\".r).foreach {\n            group => {\n\
    \                // If open paren is encountered and it is already in the list,\
    \ add it to the list\n                if (group === \"(\") {\n               \
    \     paren_paren_groups synchronized { paren_paren_groups += group }\n      \
    \          }\n                // If closing paren is encountered and it is already\
    \ in the list, remove it from the list\n                else if (group === \"\
    )\") {\n                    val current_paren_group = paren_paren_groups.takeWhile(_\
    \ != \"(\")\n                    paren_paren_groups synchronized { paren_paren_groups\
    \ -= current_paren_group }\n                }\n                // If open paren\
    \ is encountered and it is NOT already in the list, add it to the list\n     \
    \           else if (group === \"(\") {\n                    paren_paren_groups\
    \ synchronized { paren_paren_groups += group }\n                }\n          \
    \      // If closing paren is encountered and it is NOT already in the list, add\
    \ it to the list\n                else if (group === \")\") {\n              \
    \      val current_paren_group = paren_paren_groups.takeWhile(_ != \"(\")\n  \
    \                  paren_paren_groups synchronized { paren_paren_groups += current_paren_group\
    \ + \"(\" + group + \")\" }\n                }\n            }\n        }\n   \
    \     paren_paren_groups.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp31x766xl.scala:11:33 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_paren_groups\e[0m\
    \ = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp31x766xl.scala:12:34 --------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        paren_string.split(\e[31m\"\\\\s+\"\e[0m.r).foreach {\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                    Found:    scala.util.matching.Regex\n\e[31m   |\e[0m    \
    \                       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp31x766xl.scala:15:26 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m                \e[33mif\e[0m (group === \e[31m\"(\"\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value === is not a member of String - did you mean group.==?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp31x766xl.scala:19:31 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (group\
    \ === \e[31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value === is not a member of String - did you\
    \ mean group.==?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp31x766xl.scala:24:31\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (group === \e[31m\"(\"\e[0m) {\n\e[31m\e[31m   |\e[0m      \
    \                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value === is not\
    \ a member of String - did you mean group.==?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp31x766xl.scala:28:31 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (group === \e[31m\")\"\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val paren_splits = paren_string.split(\"\
    \\(\")\n      val groups = paren_splits.flatMap(_.split(\"\\)\")).groupBy(x =>\
    \ if (x.trim().isEmpty) \"\" else x.trim())\n      groups.map(_._2).map(_.replaceAll(\"\
    \\(.*\\)\",\"\")).distinct\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4ao8a38e.scala:11:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m      \e[33mval\e[0m \e[36mparen_splits\e[0m = paren_string.split(\e\
    [31m\"\\(\"\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  invalid escape character\n\e[31m\e[31m-- Error: /tmp/tmp4ao8a38e.scala:12:50\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m12 |\e[0m      \e\
    [33mval\e[0m \e[36mgroups\e[0m = paren_splits.flatMap(_.split(\e[31m\"\\)\"\e\
    [0m)).groupBy(\e[36mx\e[0m => \e[33mif\e[0m (x.trim().isEmpty) \e[31m\"\"\e[0m\
    \ \e[33melse\e[0m x.trim())\n\e[31m\e[31m   |\e[0m                           \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \                  invalid escape character\n\e[31m\e[31m-- Error: /tmp/tmp4ao8a38e.scala:13:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m13 |\e[0m      groups.map(_._2).map(_.replaceAll(\e\
    [31m\"\\(.*\\)\"\e[0m,\e[31m\"\"\e[0m)).distinct\n\e[31m\e[31m   |\e[0m      \
    \                                    ^\e[0m\n\e[31m   |\e[0m                 \
    \                         invalid escape character\n\e[31m\e[31m-- Error: /tmp/tmp4ao8a38e.scala:13:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m13 |\e[0m      groups.map(_._2).map(_.replaceAll(\e\
    [31m\"\\(.*\\)\"\e[0m,\e[31m\"\"\e[0m)).distinct\n\e[31m\e[31m   |\e[0m      \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                 invalid escape character\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4ao8a38e.scala:13:29 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m      groups.map(_._2).map(_.replaceAll(\e[31m\"\\(.*\\)\"\
    \e[0m,\e[31m\"\"\e[0m)).distinct\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value replaceAll\
    \ is not a member of Array[String]\n5 errors found\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize the list of empty strings\n\
    \        var listOfParens = List[String]()\n\n        // Iterate over the input\
    \ string and check for matching open/close paren brackets\n        var open_brace_counter\
    \ = 0\n        paren_string.foreach { c =>\n            if (c == \" \") {\n  \
    \              // A space is encountered. Ignore it.\n            } else if (c\
    \ == \"(\") {\n                // Found a new parenthesis. Increase its counter.\n\
    \                open_brace_counter += 1\n            } else if (c == \"[\") {\n\
    \                // Found a bracket (a square bracket). Decrease its counter.\n\
    \                open_brace_counter -= 1\n            } else if (c == \")\") {\n\
    \                // Found a closing parenthesis. Check if the counter is still\
    \ positive. If not, it means\n                // that there are no more open/close\
    \ parenthesis.\n                if (open_brace_counter < 0) {\n              \
    \      // Close the parenthesis without increasing the counter since they are\
    \ balanced\n                    listOfParens = listOfParens.filterNot(c => c ==\
    \ \")\")\n                } else {\n                    // Increase the counter\n\
    \                    open_brace_counter += 1\n                }\n            }\
    \ else if (c == \"]\") {\n                // Found a closing square bracket. Check\
    \ if the counter is still positive. If not, it means\n                // that\
    \ there are no more open/close parenthesis.\n                if (open_brace_counter\
    \ < 0) {\n                    // Close the parenthesis without increasing the\
    \ counter since they are balanced\n                    listOfParens = listOfParens.filterNot(c\
    \ => c == \"]\")\n                } else {\n                    // Decrease the\
    \ counter\n                    open_brace_counter -= 1\n                }\n  \
    \          } else {\n                // A character other than space, open/close\
    \ parenthesis or a bracket is encountered. Ignore\n                // it.\n  \
    \          }\n        }\n        return listOfParens\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqjy1ckya.scala:17:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (c == \e[31m\" \"\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqjy1ckya.scala:19:23 -----------------------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m\"\
    (\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types Char and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpqjy1ckya.scala:22:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e\
    [31m\"[\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpqjy1ckya.scala:25:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e\
    [31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpqjy1ckya.scala:35:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e\
    [31m\"]\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n5 errors found\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\" +\").filterNot(\
    \ _.isEmpty).map {\n          string => string.substring(1, string.length-1)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp03hzc74q.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.split(\e\
    [31m\" +\"\e[0m).filterNot( _.isEmpty).map {\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m  \
    \ |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e[31m12 |\e[0m      \
    \    \e[36mstring\e[0m => string.substring(\e[31m1\e[0m, string.length-\e[31m1\e\
    [0m)\n\e[31m13 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parenGroups: List[String] = new mutable.ListBuffer[String]()\n\
    \        def separateGroup(parenGroup: List[String], curString : String, currentIndex\
    \ : Int, totalIndex : Int) : String = {\n            if (totalIndex == currentIndex\
    \ || parenGroup.isEmpty) curString\n            else if (parenGroups(currentIndex).equals(\"\
    ()\") || parenGroups(currentIndex).equals(\"()()\")) \"\"\n            else parenGroups(currentIndex)\
    \ + curString\n        }\n\n        def separateParenGroup(parenGroup: List[String],\
    \ curString : String, currentIndex : Int) : Unit = {\n            val totalIndex\
    \ = parenGroup.length\n            if (totalIndex > currentIndex) {\n        \
    \        val nextParenIndex = parenGroups(currentIndex + 1).equals(\"()\")\n \
    \               if (nextParenIndex) {\n                    parenGroups += separateGroup(parenGroup,\
    \ \"\", currentIndex + 1, totalIndex)\n                    separateParenGroup(parenGroup,\
    \ \"\", currentIndex + 1)\n                }\n                else {\n       \
    \             parenGroups += separateGroup(parenGroup, curString, currentIndex,\
    \ totalIndex)\n                }\n            }\n        }\n\n        var currentIndex\
    \ = 0\n        for (currentChar <- paren_string) {\n            if (currentChar\
    \ == '(') {\n                parenGroups += \"\"\n                separateParenGroup(parenGroups,\
    \ \"\", currentIndex)\n            }\n            else if (currentChar == ')')\
    \ {\n                if (parenGroups(currentIndex).equals(\"()\") || parenGroups(currentIndex).equals(\"\
    ()()\")) separateParenGroups(parenGroups.toList.toString)\n                else\
    \ separateParenGroups(parenGroups.toList.toString + parenGroups(currentIndex))\n\
    \            }\n            else {\n                parenGroups += currentChar\n\
    \            }\n            currentIndex += 1\n        }\n        separateParenGroups(parenGroups.toList.toString)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbaxhoq05.scala:11:44 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparenGroups\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbaxhoq05.scala:23:32\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    parenGroups\
    \ += separateGroup(parenGroup, \e[31m\"\"\e[0m, currentIndex + \e[31m1\e[0m, totalIndex)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \ value += is not a member of List[String] - did you mean parenGroups.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpbaxhoq05.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    parenGroups += separateGroup(parenGroup,\
    \ curString, currentIndex, totalIndex)\n\e[31m\e[31m   |\e[0m                \
    \    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value += is not a member of List[String]\
    \ - did you mean parenGroups.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbaxhoq05.scala:35:28\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                parenGroups\
    \ += \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m value += is not a member of List[String] - did you mean parenGroups.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbaxhoq05.scala:43:28 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                parenGroups += currentChar\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value += is\
    \ not a member of List[String] - did you mean parenGroups.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660013571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separate_paren_groups(paren_strings:\
    \ List[String]) : List[String] = {\n            // If the input string is empty\n\
    \            if (paren_strings.isEmpty) {\n                return Nil\n      \
    \      }\n            // If the input string consists of one string (not nested)\n\
    \            if (paren_strings.size == 1) {\n                return Nil\n    \
    \        }\n            // If the input string consists of multiple strings (nested)\n\
    \            if (paren_strings.size > 1) {\n                // Create a list of\
    \ strings from every group\n                val list_of_group_strings = paren_strings.map(\
    \ s => s.substring(1, s.length-2))\n                // Separate every group into\
    \ list of strings\n                val list_of_separated_group_strings = list_of_group_strings.flatMap(separate_paren_groups)\n\
    \                // Combine every group into one string\n                val final_string\
    \ = list_of_separated_group_strings.reduceLeft(_ + \"(\" + _ + \")\")\n      \
    \          // Return the list of strings (separated by nested strings)\n     \
    \           list_of_separated_group_strings.toList\n            }\n        }\n\
    \        // Separate the input string into list of strings\n        val list_of_strings\
    \ = paren_string.substring(1, paren_string.length-1).split(\"\\\\s+\").map( s\
    \ => s.trim() ).toList\n        // Separate every string into list of strings\n\
    \        val list_of_separated_strings = list_of_strings.flatMap(separate_paren_groups)\n\
    \        // Combine every string into one string\n        val final_string = list_of_separated_strings.reduceLeft(_\
    \ + \"(\" + _ + \")\")\n        // Return the list of strings (separated by nested\
    \ strings)\n        list_of_separated_strings.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoujx43zp.scala:25:84\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m\
    \ \e[36mlist_of_separated_group_strings\e[0m = list_of_group_strings.flatMap(separate_paren_groups)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                     Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mString\e\
    [1m\e[31m]\e[0m => IterableOnce[String]\n\e[31m   |\e[0m                     \
    \     Required: String => IterableOnce[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpoujx43zp.scala:35:64 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mlist_of_separated_strings\e\
    [0m = list_of_strings.flatMap(separate_paren_groups)\n\e[31m\e[31m   |\e[0m  \
    \                                                              ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m => IterableOnce[String]\n\e[31m   |\e[0m\
    \                          Required: String => IterableOnce[String]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create an empty list of strings that\
    \ will be returned\n        val result = mutable.MutableList[String]()\n     \
    \   // We will use mutable.MutableList instead of List for easier removal from\
    \ the list\n        val open_braces = mutable.MutableList[String]()\n        //\
    \ We will use mutable.MutableList instead of List for easier removal from the\
    \ list\n        val closed_braces = mutable.MutableList[String]()\n\n        for\
    \ (c <- paren_string) {\n            // Check if the character is a parenthesis\n\
    \            val currentChar = c.toInt\n            if (currentChar == 1) {\n\
    \                // If it is a single parenthesis add it to the open_braces list\n\
    \                open_braces += c\n            } else if (currentChar == 0) {\n\
    \                // If it is an empty brace (which means it's closed) add it to\
    \ the closed_braces list\n                closed_braces += c\n            } else\
    \ if (currentChar < 0) {\n                // If it's not a single brace or the\
    \ character is not a parenthesis throw an error\n                throw new RuntimeException(\"\
    String not properly formatted\")\n            }\n        }\n\n        // Iterate\
    \ over the open braces\n        for (i <- 0 until open_braces.size) {\n      \
    \      // For each brace check whether the brace is closed or not\n          \
    \  val open_brace = open_braces(i)\n            val closed_brace = closed_braces(i)\n\
    \n            // If the brace is not closed, add it to the result list\n     \
    \       if (open_brace != closed_brace) {\n                result += open_brace\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg10cj86d.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpg10cj86d.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mopen_braces\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpg10cj86d.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mclosed_braces\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Your code goes here.\n        val paren_string\
    \ = paren_string.replace(\"( \", \"(\").replace(\")\", \")\")\n        val brace_counts\
    \ = paren_string.groupCount(\"()\")\n        // print out all groups of balanced\
    \ parentheses.\n        val groups = mutable.Stack.empty[String]\n        for(i<-\
    \ 1 to brace_counts.size)\n        {\n            val open_count = paren_string.substring(1,i).count(\"\
    (\")\n            val close_count = paren_string.substring(i, brace_counts(i)).count(\"\
    )\")\n            if(!open_count.equals(close_count))\n            {\n       \
    \         val group_string = paren_string.substring(1,i-1) + (open_count - close_count)\
    \ +  paren_string.substring(i, brace_counts(i))\n                groups.push(group_string)\n\
    \            }\n        }\n        // print out all groups of unbalanced parentheses.\n\
    \        var unbalanced_groups = List[String]()\n        for(i <- 1 to brace_counts.size)\n\
    \        {\n            val open_count = paren_string.substring(1,i).count(\"\
    (\")\n            val close_count = paren_string.substring(i, brace_counts(i)).count(\"\
    )\")\n            if(open_count.equals(close_count))\n            {\n        \
    \        val group_string = paren_string.substring(1,i-1) + (open_count - close_count)\
    \ +  paren_string.substring(i, brace_counts(i))\n                groups.push(group_string)\n\
    \            }\n            else\n            {\n                unbalanced_groups\
    \ = unbalanced_groups :+ paren_string.substring(1,i-1)\n            }\n      \
    \  }\n        unbalanced_groups\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoa6ny3re.scala:12:27 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_string\e[0m = paren_string.replace(\e\
    [31m\"( \"\e[0m, \e[31m\"(\"\e[0m).replace(\e[31m\")\"\e[0m, \e[31m\")\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mparen_string\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoa6ny3re.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mgroups\e[0m = mutable.Stack.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val inputSet = paren_string.trim\n   \
    \     val paren_stringArray = inputSet.split(\"\\\\(\")\n        paren_stringArray.map(x\
    \ => x.replace(\")\", \"\"))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1imggq3u.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_stringArray.map(\e\
    [36mx\e[0m => x.replace(\e[31m\")\"\e[0m, \e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val pat = Pattern.compile(\"\\\\(|\\\\\
    )\").r\n        paren_string.split(pat)\n            .flatMap(_.grouped(2))\n\
    \            .filter(_.size == 2) //remove groups of length 1\n            .map(_.mkString(\"\
    (\",\",\",\")\") ) //add parens to each pair\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcagra_pe.scala:11:18 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpat\e[0m = Pattern.compile(\e\
    [31m\"\\\\(|\\\\)\"\e[0m).r\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: Pattern\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcagra_pe.scala:12:8 ---------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        paren_string.split(pat)\n\e[31m\e[31m   |\e[0m\
    \        ^\e[0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[String]\n\
    \e[31m   |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e[31m13 |\e[0m\
    \            .flatMap(_.grouped(\e[31m2\e[0m))\n\e[31m14 |\e[0m            .filter(_.size\
    \ == \e[31m2\e[0m) \e[34m//remove groups of length 1\e[0m\n\e[31m15 |\e[0m   \
    \         .map(_.mkString(\e[31m\"(\"\e[0m,\e[31m\",\"\e[0m,\e[31m\")\"\e[0m)\
    \ ) \e[34m//add parens to each pair\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def isParenthesisNesting(paren_string\
    \ : String) : Boolean = paren_string contains \"(\" || paren_string contains \"\
    [\"\n        def isNestingDepth(paren_string : String) : Int = paren_string.count(\"\
    (\") - paren_string.count(\"[\")\n\n        if (paren_string.length <= 1) List(paren_string)\n\
    \        else for {\n            open_count <- 0 to paren_string.lastIndexOf(\"\
    (\")\n            close_count <- 0 to paren_string.lastIndexOf(\")\")\n\n    \
    \        if (open_count < close_count && open_count != -1) open_count <- close_count\
    \ // If the open parens are nested in each other, ignore it\n            else\
    \ {\n                val depth_check = (open_count - close_count + 1) / 2\n  \
    \              if (depth_check != 0) depth_check else depth_check <- 0 // If the\
    \ open parens are nested in each other, ignore it\n                val nest_count\
    \ = (close_count - open_count + 1) / 2\n                if (nest_count != 0) nest_count\
    \ else nest_count <- 0 // If the open parens are nested in each other, ignore\
    \ it\n                if (((open_count - close_count + 1) % 2) == 0) depth_check\
    \ + nest_count else nest_count + depth_check\n            }\n        } yield {\n\
    \            val open_index = open_count + 1\n            val close_index = close_count\
    \ + 1\n            val nest_index = open_count + close_count + 1\n           \
    \ val groups: List[String] = ListBuffer.empty[String]\n            val current_group:\
    \ String = paren_string.substring(0, open_index)\n            val current_group_nest_level:\
    \ Int = isParenthesisNesting(current_group) ? 0 : isNestingDepth(current_group)\
    \ ? 1 : 2\n            val next_group: String = paren_string.substring(open_index,\
    \ close_index)\n            val next_group_nest_level: Int = isParenthesisNesting(next_group)\
    \ ? 0 : isNestingDepth(next_group) ? 1 : 2\n            if (current_group_nest_level\
    \ == next_group_nest_level) {\n                if (current_group_nest_level ==\
    \ 0) {\n                    val current_group_nest_opens = paren_string.substring(open_index,\
    \ open_count + 1).replace(\"(\", \"\").replace(\")\", \"\")\n                \
    \    val current_group_nest_closes = paren_string.substring(close_count + 1, close_count\
    \ + 2).replace(\"(\", \"\").replace(\")\", \"\")\n                    val group_nest_opens\
    \ = current_group_nest_opens + paren_string.substring(open_index, open_count +\
    \ 1).replace(\"(\", \"\").replace(\")\", \"\")\n                    val group_nest_closes\
    \ = current_group_nest_closes + paren_string.substring(close_count + 1, close_count\
    \ + 2).replace(\"(\", \"\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_kv0012b.scala:19:73 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (open_count < close_count &&\
    \ open_count != -\e[31m1\e[0m) open_count <- close_count \e[34m// If the open\
    \ parens are nested in each other, ignore it\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                                                                    ^^\e[0m\n\
    \e[31m   |\e[0m                                        expression expected but\
    \ \e[31m<-\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp_kv0012b.scala:33:104\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \
    \    \e[33mval\e[0m \e[36mcurrent_group_nest_level\e[0m: \e[35mInt\e[0m = isParenthesisNesting(current_group)\
    \ ? \e[31m0\e[0m : \e[35misNestingDepth\e[0m(current_group) ? \e[31m1\e[0m : \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0m                                 end of statement expected but '(' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_kv0012b.scala:11:94 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mdef\e[0m \e[36misParenthesisNesting\e[0m(\e\
    [36mparen_string\e[0m : \e[35mString\e[0m) : \e[35mBoolean\e[0m = paren_string\
    \ contains \e[31m\"(\"\e[0m || paren_string contains \e[31m\"[\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                          ^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                value || is not a member of String\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp_kv0012b.scala:12:77 --------------------\e[0m\e[0m\n\
    \e[31m12 |\e[0m        \e[33mdef\e[0m \e[36misNestingDepth\e[0m(\e[36mparen_string\e\
    [0m : \e[35mString\e[0m) : \e[35mInt\e[0m = paren_string.count(\e[31m\"(\"\e[0m)\
    \ - paren_string.count(\e[31m\"[\"\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                                                               ^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Found:    (\e[32m"
  stdout: ''
  timestamp: 1660013574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Iterate over all groups of parentheses\n\
    \        val allParenGroups = paren_string.split(\"\\\\(\")\n        // Create\
    \ an accumulator\n        var groups: List[String] = Nil\n        var opening_paren_count:\
    \ Int = 0\n        // Iterate over all groups of parentheses.\n        for(paren_string\
    \ <- allParenGroups) {\n            // If the opening brace is closed, then add\
    \ a new group to the list and increase the opening brace counter\n           \
    \ if(paren_string.endsWith(\")\")) {\n                groups = groups ++ List(paren_string.substring(0,\
    \ paren_string.length-1))\n                opening_paren_count = opening_paren_count\
    \ + 1\n            }\n            // If the opening brace is not closed, then\
    \ check if the opening brace is still open. If not, then add a space\n       \
    \     // to the end of the group and increase the opening_paren_count by 1.\n\
    \            else {\n                // If the opening brace is still open, then\
    \ add a comma to the end of the group and increase the opening_paren_count\n \
    \               // by 1.\n                if(opening_paren_count != 0) {\n   \
    \                 groups = groups ++ List(\",\")\n                    opening_paren_count\
    \ = opening_paren_count + 1\n                }\n                // If the opening\
    \ brace is not open, then add the group to the groups and increase the opening_paren_count\n\
    \                // by 1.\n                else {\n                    groups\
    \ = groups ++ List(paren_string)\n                    opening_paren_count = opening_paren_count\
    \ + 1\n                }\n            }\n        }\n        return groups\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzjqsn2vu.scala:43)\n\tat Problem.main(tmpzjqsn2vu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013576
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\\\\(\").map(_.replaceAll(\"\
    \\\\s\", \"\")) match {\n            case Array(p1, p2) => List(p1 + p2)\n   \
    \         case _ => Nil\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkoy_g1o4.scala:17)\n\tat Problem.main(tmpkoy_g1o4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack : List[String] = Nil\n     \
    \   paren_string.flatMap(c => {\n            c match {\n                case '('\
    \ =>\n                    stack:::List()\n                case ')' =>\n      \
    \              if(stack.length > 0) stack:::List()\n                    else Nil\n\
    \                case _ =>\n                    if(stack.length > 0 && stack.last\
    \ == c) stack:::List()\n                    else Nil\n            }\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpcmgz0b7y.scala:20:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    \e[33mif\e[0m(stack.length > \e[31m0\e\
    [0m && stack.last == c) stack:::List()\n\e[31m\e[31m   |\e[0m                \
    \                           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660013576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_list = List[String]()\n    \
    \    var open_braces = List[Int]()\n        var open_parens = List[Int]()\n  \
    \      var closed_parens = List[Int]()\n        var closing_braces = List[Int]()\n\
    \        var open_parens_stack = List[Int]()\n        paren_string.split(\"((\\\
    \\(|\\\\))+\").foreach{\n            par =>\n                val braces = par.count(_\
    \ == '(')\n                val parens = par.count(_ == '(')\n                if\
    \ (braces > parens) {\n                    paren_list ::= par\n              \
    \      open_parens = par.count(_ == '(')\n                    closed_parens =\
    \ par.count(_ == '(')\n                    closing_braces = par.count(_ == '(')\n\
    \                } else {\n                    open_parens_stack ::= par.count(_\
    \ == '(')\n                    if (parens == closing_braces &&  open_parens ==\
    \ closed_parens) {\n                        paren_list ::= par\n             \
    \           open_parens = open_parens_stack\n                        closed_parens\
    \ = closed_parens.take(open_parens_stack.size)\n                        closing_braces\
    \ = 0\n                    } else if (parens == open_parens &&  open_parens ==\
    \ closed_parens) {\n                        paren_list ::= par\n             \
    \           open_braces = open_braces.take(open_parens_stack.size)\n         \
    \               open_parens = open_parens_stack\n                        closed_parens\
    \ = closed_parens.take(open_parens_stack.size)\n                        closing_braces\
    \ = 0\n                    }\n                }\n        }\n        paren_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0hndpayv.scala:23:43\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    open_parens\
    \ = par.count(_ == \e[31m'('\e[0m)\n\e[31m\e[31m   |\e[0m                    \
    \              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \             Found:    Int\n\e[31m   |\e[0m                                 \
    \ Required: List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0hndpayv.scala:24:45\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    closed_parens\
    \ = par.count(_ == \e[31m'('\e[0m)\n\e[31m\e[31m   |\e[0m                    \
    \                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                 Found:    Int\n\e[31m   |\e[0m                             \
    \       Required: List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0hndpayv.scala:25:46 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    closing_braces = par.count(_ == \e[31m'('\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    Int\n\e[31m\
    \   |\e[0m                                     Required: List[Int]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp0hndpayv.scala:28:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    \e[33mif\e[0m (parens == closing_braces\
    \ &&  open_parens == closed_parens) {\n\e[31m\e[31m   |\e[0m                 \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      Values of types Int\
    \ and List[Int] cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0hndpayv.scala:32:41 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                        closing_braces = \e[31m0\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                                         ^\e[0m\n\e[31m   |\e[0m     \
    \                 "
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parenGroups = paren_string.split(\"\
    (?<=\\\\()|(?=\\\\))\").filter(_.nonEmpty)\n        parenGroups.map(_.split(\"\
    \\\\s\"+1).map(_.trim))\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ontecdj.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        parenGroups.map(_.split(\e\
    [31m\"\\\\s\"\e[0m+\e[31m1\e[0m).map(_.trim))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Array[String]]\n\e[31m   |\e[0m  \
    \      Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_list : List[String] = new mutable.ListBuffer[String]()\n\
    \        var open_brace : Boolean = true\n        for (i <- 0 until paren_string.length){\n\
    \            paren_string match {\n                case _ if paren_string(i) ==\
    \ '(' && paren_string(i+1) != '(' && paren_string(i+1) != ')' && paren_string(i+1)\
    \ != ' ' => open_brace = false\n                case _ if paren_string(i) == '('\
    \ && paren_string(i+1 == ')' && paren_string(i+3) != '(' && paren_string(i+3)\
    \ != ')' && paren_string(i+3) != ' ' => open_brace = false\n                case\
    \ _ if paren_string(i) == ')' && paren_string(i+1 != ')' && paren_string(i+2 !=\
    \ '(' && paren_string(i+2 != ')' && paren_string(i+2 != ' ')) => open_brace =\
    \ false\n                case _ if paren_string(i) == ')' && paren_string(i+1\
    \ == ')' && paren_string(i+2 != '(' && paren_string(i+2 != ')' && paren_string(i+2\
    \ != ' ')) => open_brace = false\n                case _ if paren_string(i) ==\
    \ ' ' => open_brace = false\n                case _ if paren_string(i) != ' '\
    \ && paren_string(i) != ')' && !open_brace => paren_list += paren_string(i).toString\
    \ + \"\\n\"\n            }\n        }\n        paren_list.filter(!_.isEmpty)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp67gbn6ka.scala:16:132 ----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m _ \e[33mif\e[0m paren_string(i)\
    \ == \e[31m'('\e[0m && paren_string(i+\e[31m1\e[0m == \e[31m')'\e[0m && paren_string(i+\e\
    [31m3\e[0m) != \e[31m'('\e[0m && paren_string(i+\e[31m3\e[0m) != \e[31m')'\e[0m\
    \ && paren_string(i+\e[31m3\e[0m) != \e[31m' '\e[0m => open_brace = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            not a legal formal\
    \ parameter\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp67gbn6ka.scala:17:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e\
    [0m _ \e[33mif\e[0m paren_string(i) == \e[31m')'\e[0m && paren_string(i+\e[31m1\e\
    [0m != \e[31m')'\e[0m && paren_string(i+\e[31m2\e[0m != \e[31m'('\e[0m && paren_string(i+\e\
    [31m2\e[0m != \e[31m')'\e[0m && paren_string(i+\e[31m2\e[0m != \e[31m' '\e[0m))\
    \ => open_brace = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^\e\
    [0m\n\e[31m   |\e[0m                ')' expected, but 'case' found\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp67gbn6ka.scala:11:44 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize our output list\n      \
    \  val output = ListBuffer[String]()\n        \n        // Iterate over each character\
    \ in the input string\n        for (i <- 0 to paren_string.length - 1) {\n   \
    \         // If it's a space, add an open brace to our output list\n         \
    \   if (paren_string(i) == \" \") {\n                output += (\"(\")\n     \
    \       }\n            // If it's not a space, add it to the output list if it\
    \ is within parens\n            if (paren_string(i) !=  \" \" && paren_string(i)\
    \ !=  \")\") {\n                output += paren_string(i)\n            }\n   \
    \         \n            // If it's a space, add an close brace to our output list\n\
    \            if (paren_string(i) == \" \") {\n                output += (\")\"\
    )\n            }\n        }\n        \n        // Return the output list\n   \
    \     output.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8_ae_m0a.scala:17:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (paren_string(i) == \e[31m\"\
    \ \"\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp8_ae_m0a.scala:21:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (paren_string(i) !=  \e[31m\"\
    \ \"\e[0m && paren_string(i) !=  \e[31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp8_ae_m0a.scala:21:43 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (paren_string(i) !=  \e[31m\" \"\
    \e[0m && paren_string(i) !=  \e[31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m      \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8_ae_m0a.scala:22:38 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                output += paren_string(i)\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                      Found:    Char\n\e[31m   |\e[0m                       \
    \   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8_ae_m0a.scala:26:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \     \e[33mif\e[0m (paren_string(i) == \e[31m\" \"\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n5 errors found\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separate(aString : String) : String\
    \ = {\n            var outString : String = \"\"\n            var open_brace :\
    \ Int = 0\n            var close_brace : Int = 0\n            for(c <- aString)\
    \ {\n                if(c == '(') {\n                    open_brace = open_brace\
    \ + 1\n                } else if(c == ')') {\n                    close_brace\
    \ = close_brace + 1\n                    if(open_brace == close_brace) {\n   \
    \                     outString = outString + c + \" \" \n                   \
    \     open_brace = 0\n                        close_brace = 0\n              \
    \      }\n                }\n            }\n            outString\n        }\n\
    \        val outList = mutable.ListBuffer[String]()\n        var brace_count =\
    \ 0\n        var open_count = 0\n        for(i <- 0 until paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if(c == '(') {\n       \
    \         brace_count = brace_count + 1\n            } else if(c == ')') {\n \
    \               brace_count = brace_count - 1\n                if(open_count ==\
    \ brace_count) {\n                    outList += separate(paren_string.substring(0,i))\n\
    \                    open_count = 0\n                    brace_count = 0\n   \
    \             } else {\n                    open_count = open_count + 1\n    \
    \            }\n            }\n        }\n        return outList.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaqxbanbu.scala:29:22 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36moutList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n        paren_string.split(\"\
    \\\\(\").foreach(group => {\n            val inner = group.split(\"\\\\)\");\n\
    \            val lastGroup = inner.last;\n            if(groups.length == 0 ||\
    \ lastGroup != groups(groups.length-1)) {\n                groups += lastGroup;\n\
    \            }\n            else {\n                println(lastGroup);\n    \
    \            println(groups(groups.length-1));\n                println(groups);\n\
    \                println(groups.length);\n                println(groups.length-1);\n\
    \                println(groups(groups.length-1)+\"*\"+groups(groups.length));\n\
    \                println(groups.length);\n                println(groups.length-1);\n\
    \                println(groups(groups.length-1)+\"*\"+groups(groups.length-1));\n\
    \                println(\"last\");\n                println(\"*\"+groups(groups.length-1));\n\
    \                println(\"*\"+groups(groups.length-1)+\"*\"+groups(groups.length));\n\
    \                println(\"*\"+groups(groups.length-1)+\"*\"+groups(groups.length-1));\n\
    \                println(\"inner\"+inner.length);\n            }\n        })\n\
    \        return groups;\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxrbr1kyr.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                groups += lastGroup;\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[String] - did you mean List[String].!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if(paren_string.isEmpty){\n          \
    \  return []\n        }\n        var groups: List[String] = Nil\n        var in_paren_group\
    \ : Boolean = false\n        for(i <- 0 until paren_string.length){\n        \
    \    val c = paren_string(i)\n            if(in_paren_group){\n              \
    \  if(c == '('){\n                    in_paren_group = false\n               \
    \ } else if(c == ')'){\n                    if(in_paren_group){\n            \
    \            in_paren_group = false\n                        groups = groups :::\
    \ (groups.reverse)\n                    } else {\n                        groups\
    \ = groups ::: List(groups.reverse)\n                    }\n                }\
    \ else if(c == ' ' || c == '\\n' || c == '\\t' || c == '\\r'){\n             \
    \       in_paren_group = false\n                } else {\n                   \
    \ groups = groups ::: List(groups.reverse)\n                }\n            } else\
    \ {\n                if(c == ' ' || c == '\\n' || c == '\\t' || c == '\\r'){\n\
    \                    in_paren_group = true\n                } else {\n       \
    \             in_paren_group = true\n                }\n            }\n      \
    \  }\n        return groups\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1f4wgbmm.scala:12:20 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1f4wgbmm.scala:13:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1f4wgbmm.scala:26:33 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        groups = groups ::: List(groups.reverse)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    List[Object]\n\e\
    [31m   |\e[0m                                 Required: List[String]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1f4wgbmm.scala:31:29 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    groups = groups ::: List(groups.reverse)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    List[Object]\n\e[31m\
    \   |\e[0m                             Required: List[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\"\"(?<=\\()(?!\\\
    ))|(?<=\\))(?!\\()|(?<=\\))(?=\\()|(?<=\\))(?=\\))|(?<=\\()(?=\\))\"\"\".r)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigatok79.scala:11:103\
    \ -------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.split(\e\
    [31m\"\"\"(?<=\\()(?!\\))|(?<=\\))(?!\\()|(?<=\\))(?=\\()|(?<=\\))(?=\\))|(?<=\\\
    ()(?=\\))\"\"\"\e[0m.r)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    scala.util.matching.Regex\n\
    \e[31m   |\e[0m                           Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_str = paren_string.trim\n  \
    \      if (paren_str.length <= 0) List()\n        else {\n            var open_paren_level\
    \ = 0\n            var open_paren_count = 0\n            var close_paren_level\
    \ = 0\n            var close_paren_count = 0\n            var paren_list: List[String]\
    \ = List()\n            for (char <- paren_str.toCharArray) {\n              \
    \  val ch = (char)\n                if (open_paren_level == 0) {\n           \
    \         if (ch == '(') {\n                        open_paren_count += 1\n  \
    \                  }\n                    if (ch == ')') {\n                 \
    \       close_paren_count += 1\n                    }\n                    else\
    \ if (ch == '(') {\n                        open_paren_level += 1\n          \
    \          }\n                    else if (ch == ')') {\n                    \
    \    close_paren_level += 1\n                    }\n                } else {\n\
    \                    if (ch == '(') {\n                        open_paren_count\
    \ -= 1\n                    }\n                    if (ch == ')') {\n        \
    \                close_paren_count -= 1\n                    }\n             \
    \       else if (ch == '(') {\n                        open_paren_level -= 1\n\
    \                    }\n                    else if (ch == ')') {\n          \
    \              close_paren_level -= 1\n                    }\n               \
    \ }\n                if (open_paren_count == 0 && close_paren_count == 0) {\n\
    \                    paren_list ::= paren_str\n                    paren_str =\
    \ ListBuffer()\n                }\n            }\n            paren_list.tail\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpte_0ezdg.scala:50:42\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m                    paren_str\
    \ = ListBuffer()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    scala.collection.mutable.ListBuffer[A]\n\
    \e[31m   |\e[0m                        Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                        where:    A is a type variable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val groups = paren_string.split(\"\\\\(|\\\
    \\)\").toList\n      val separated = groups.foldLeft(List[String]()){ case (acc,\
    \ currGroup) => if (acc.isEmpty) List(currGroup) else acc }\n      separated\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4t3_2ev5.scala:16)\n\tat Problem.main(tmp4t3_2ev5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      paren_string.split(\"[()]\").filter(_ !=\
    \ \" \").map(_.trim).foldLeft(List[String]())((acc, cur) => acc match {\n    \
    \    case Nil => acc :+ cur\n        case x :: xs if xs.isEmpty => acc :+ cur\n\
    \        case x :: xs if xs.head.isEmpty => acc :+ cur\n        case x :: xs if\
    \ !x.contains(\" \") => x :: acc\n        case x :: xs if x.contains(\"(\") &&\
    \ x.contains(\")\") && x.contains(\"(\") && !x.contains(\"()\") =>\n         \
    \   separateParenGroups(xs.head) ++ List(cur)\n        case x :: xs if x.contains(\"\
    (\") && x.contains(\")\") && x.contains(\"()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"(\") && x.contains(\")\"\
    ) =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case x ::\
    \ xs if x.contains(\"(\") && !x.contains(\")\") => \n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()\") && x.contains(\"(\"\
    ) =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case x ::\
    \ xs if x.contains(\"()\") && x.contains(\"()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()()\") && x.contains(\"\
    (\") =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case x\
    \ :: xs if x.contains(\"()()\") && x.contains(\"()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()()()\") =>\n          \
    \  separateParenGroups(xs.head) ++ List(cur)\n        case x :: xs if x.contains(\"\
    ()()()\") && x.contains(\"(\") =>\n            separateParenGroups(xs.head) ++\
    \ List(cur)\n        case x :: xs if x.contains(\"()()()\") && x.contains(\"()\"\
    ) =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case x ::\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7fw_cg14.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7fw_cg14.scala:44:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m44 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp7fw_cg14.scala:52:0 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E005] Naming Error: /tmp/tmp7fw_cg14.scala:42:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mcase\e[0m\
    \ x :: x\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m     \
    \             duplicate pattern variable: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val list = mutable.ListBuffer[String]()\n\
    \        var in_paren = false\n        for(c <- paren_string){\n            if(c\
    \ == '('){\n                in_paren = true\n                list += c\n     \
    \       }else if(c == ')'){\n                in_paren = false\n              \
    \  list += c\n            }else if(!in_paren){\n                list += c\n  \
    \          }\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphy07nhx7.scala:11:19 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_groups: List[List[String]] =\
    \ Nil\n        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                val temp: List[String] = Nil\n                paren_groups\
    \ ::= temp\n            } else if (paren_string(i) == ')') {\n               \
    \ val temp = paren_groups(paren_groups.length - 1)\n                paren_groups\
    \ = temp\n            } else {\n                paren_groups = paren_groups :::\
    \ List(i.toString.toInt)\n            }\n        }\n        paren_groups.reverse.flatMap\
    \ {\n            x => if (x.size < 2) List(x) else x :: (x.tail -1)\n        }.filter(x\
    \ => x.length == x.tail.length)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf420hqk1.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                paren_groups\
    \ = temp\n\e[31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mtemp\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[String]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                               Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mList[String]\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpf420hqk1.scala:20:31 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                paren_groups = paren_groups ::: List(i.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    List[Matchable]\n\
    \e[31m   |\e[0m                               Required: List[List[String]]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf420hqk1.scala:24:59\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[36mx\e[0m\
    \ => \e[33mif\e[0m (x.size < \e[31m2\e[0m) List(x) \e[33melse\e[0m x :: (x.tail\
    \ -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                      \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of List[String\
    \ @uncheckedVariance], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Write your code here.\n        val\
    \ stack = mutable.Stack[String]()\n        var list = new mutable.ListBuffer[String]()\n\
    \        for (i <- 0 until paren_string.length) {\n            val cur = paren_string(i)\n\
    \            if (cur == '(') {\n                stack += '('\n            } else\
    \ if (cur == ')') {\n                val curr = stack.pop()\n                if\
    \ (curr == '(') {\n                    list += curr\n                } else if\
    \ (curr != '') {\n                    list += curr\n                }\n      \
    \      } else if (cur != ' ') {\n                list += cur\n            }\n\
    \        }\n        list.mkString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjqd3faw_.scala:22:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (curr\
    \ != '') {\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e\
    [31m   |\e[0m                                   empty character literal\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjqd3faw_.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjqd3faw_.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjqd3faw_.scala:23:20\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    list\
    \ += curr\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: 'list\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = mutable.Stack[String]()\n\
    \        paren_string.grouped(4).foreach { x =>\n            val a = x.dropRight(1)\n\
    \            val b = x.dropLeft(1)\n            if (stack.isEmpty || !a.equals(stack.peek))\
    \ {\n                stack.append(a)\n            } else {\n                stack.peek.append(b)\n\
    \            }\n        }\n        stack.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj0i8rfqm.scala:11:20 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj0i8rfqm.scala:14:22 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mb\e[0m = x.dropLeft(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    value dropLeft is not a member of String\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize list\n        val groups:\
    \ List[String] = Nil\n        // Keep a stack\n        val open_braces : mutable.Stack[String]\
    \ = mutable.Stack[String]()\n        // Process each character in the string\n\
    \        for (c <- paren_string) {\n            // If c == '{', add it to the\
    \ stack\n            if (c == '{') {\n                open_braces.push(c)\n  \
    \          // If c == '}', remove it\n            } else if (c == '}') {\n   \
    \             open_braces.pop()\n            // Else, check if it is ')' or ')()'\n\
    \            } else if (c == ')' || c == ')(') {\n                // If it is,\
    \ add it to lists\n                if (c == '(') {\n                    groups\
    \ ::= open_braces.reverse.toList.reverse\n                }\n                //\
    \ Else, check if there is a stack of '()'\n                else if (open_braces.isEmpty)\
    \ {\n                    groups ::= List(c)\n                } else {\n      \
    \              // If so, reverse it and add it to the list\n                 \
    \   groups ::= open_braces.reverse.toList.reverse\n                }\n       \
    \     }\n        }\n        return groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpoks1e11a.scala:24:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e\
    [31m')'\e[0m || c == ')(') {\n\e[31m\e[31m   |\e[0m                          \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \ unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpoks1e11a.scala:24:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \     } \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m')'\e[0m || c == ')(') {\n\e\
    [31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m \
    \  |\e[0m                                           unclosed character literal\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoks1e11a.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mopen_braces\e[0m : mutable.Stack[\e\
    [35mString\e[0m] = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoks1e11a.scala:14:50\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mopen_braces\e[0m : mutable.Stack[\e[35mString\e[0m] = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                                \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmpoks1e11a.scala:48:0 -----------------\e[0m\e[0m\n\e[33m48 |\e\
    [0m}\n\e[33m\e[33m   |\e[0m ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660013580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Base case: if paren_string is empty\
    \ then return the empty list\n        if (paren_string.length == 0)\n        \
    \    Nil\n        // Base case: if there is one open paren, then\n        else\
    \ if (paren_string.length == 1 && paren_string.charAt(0) == '(')\n           \
    \ Nil\n        // Base case: split the string based on first non-space char\n\
    \        else {\n            val first_non_space_char = paren_string.split(\"\
    \ \").map(_.head).filterNot(_ == ')').head\n            val splits = paren_string.split(first_non_space_char)\n\
    \            val groups = splits.grouped(splits.length)\n            groups.map(group\
    \ => group.mkString(first_non_space_char)).flatMap(group => separateParenGroups(group))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk5hyrreh.scala:22:47\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            groups.map(\e[36mgroup\e\
    [0m => group.mkString(first_non_space_char)).flatMap(\e[36mgroup\e[0m => separateParenGroups(group))\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    (first_non_space_char\
    \ : Char)\n\e[31m   |\e[0m                                 Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def isParensOpen (s : String) : Boolean\
    \ = s.contains(\"(\")\n        def isParensClose (s : String) : Boolean = s.contains(\"\
    )\")\n        def isNesting (s : String) : Boolean = s.contains(\")\")\n     \
    \   val parens = mutable.ListBuffer[String]()\n        val opens = mutable.ListBuffer[String]()\n\
    \        val closes = mutable.ListBuffer[String]()\n        val isOpen = mutable.ListBuffer[String]()\n\
    \        var depth = paren_string.length()\n        var i = paren_string.length()\
    \ - 1\n        while ( i >= 0 ) {\n            val c = paren_string(i)\n     \
    \       val s = paren_string.substring(0,i)\n            if ( isParensOpen(s)\
    \ ) {\n                if ( isOpen.contains(s) ) {\n                    closes\
    \ += c\n                    isOpen -= s\n                    isParensOpen -= s\n\
    \                    parens += c\n                } else {\n                 \
    \   opens += c\n                    isOpen += s\n                    isParensOpen\
    \ += s\n                    parens += c\n                }\n            } else\
    \ if ( isParensClose(s) ) {\n                if ( isClose.contains(s) ) {\n  \
    \                  opens -= c\n                    isClose -= s\n            \
    \        isParensClose -= s\n                    parens -= c\n               \
    \ } else {\n                    closes += c\n                    isClose += s\n\
    \                    isParensClose += s\n                    parens -= c\n   \
    \             }\n            } else if ( isNesting(s) ) {\n                depth--\n\
    \                if ( depth <= 0 ) {\n                    if ( depth == 0 ) {\n\
    \                        parens += c\n                    } else {\n         \
    \               parens -= c\n                    }\n                }\n      \
    \      }\n            i--\n        }\n        parens.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3zcag7jt.scala:48:23 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                depth--\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp3zcag7jt.scala:57:15 ---------------------------\e[0m\e[0m\n\e[31m57\
    \ |\e[0m            i--\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3zcag7jt.scala:14:21 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparens\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3zcag7jt.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mopens\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3zcag7jt.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mcloses\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3zcag7jt.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36misOpen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Split the paren_string into separate\
    \ groups\n        val parens = paren_string.split(\"\\\\)\")\n        // Keep\
    \ track of the number of open braces encountered\n        var open_braces = 0\n\
    \        // Build a queue to hold the groups. Each item will be a string, with\
    \ one \"(\" at the front\n        // and a \")\" at the end.\n        var groups\
    \ = mutable.Queue[String]()\n        // For each paren\n        for (paren <-\
    \ parens) {\n            // If we've already encountered an open brace\n     \
    \       if (paren == \"(\") {\n                open_braces += 1\n            }\
    \ else {\n                open_braces -= 1\n                // If we've encountered\
    \ an open brace and there are still open braces\n                if (open_braces\
    \ == 0) {\n                    val new_group = parens.filter(x => x != \"(\").mkString(\"\
    (\", \")\")\n                    groups += new_group\n                }\n    \
    \        }\n        }\n        // Build the list of groups as a List\n       \
    \ return groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdk0_m4op.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mgroups\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdk0_m4op.scala:27:74 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    \e[33mval\e[0m \e[36mnew_group\e\
    [0m = parens.filter(\e[36mx\e[0m => x != \e[31m\"(\"\e[0m).mkString(\e[31m\"(\"\
    \e[0m, \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                              \
    \                                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                            Found:    (String, String)\n\e[31m\
    \   |\e[0m                                              Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.stripPrefix(\"(\").stripSuffix(\"\
    )\").split(\"\"\"\\s(?=\\()\"\"\").map(_.trim)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21urnnbh.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.stripPrefix(\e\
    [31m\"(\"\e[0m).stripSuffix(\e[31m\")\"\e[0m).split(\e[31m\"\"\"\\s(?=\\()\"\"\
    \"\e[0m).map(_.trim)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m  \
    \ |\e[0m        Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parens = paren_string.split(\"\"\"\
    [\\(\\)]+\"\"\")\n        val parens_with_brackets = parens.map( x => if (x.contains(\"\
    (\") || x.contains(\")\")) {\n            var result = x\n            while (result.contains(\"\
    (\")) {\n                result = result.replace(\"(\",\"\").replace(\")\",\"\"\
    )\n            }\n            result += \")\"\n            result\n        }\n\
    \        else\n            x)\n        val open_brackets = parens_with_brackets.filter(x\
    \ => x.contains(\"(\"))\n        val closed_brackets = parens_with_brackets.filter(x\
    \ => x.contains(\")\"))\n\n        // Filter out any parenthesis that are already\
    \ inside the string\n        val filtered = parens_with_brackets.filter{ x =>\n\
    \            if (x.contains(\"(\") || x.contains(\")\")) {\n                var\
    \ result = x\n                while (result.contains(\"(\")) {\n             \
    \       result = result.replace(\"(\",\"\").replace(\")\",\"\")\n            \
    \    }\n                result = result.replace(\")\",\"\")\n                result\
    \ = result + \")\"\n                result\n            }\n            else\n\
    \                x\n        }\n\n        val groups = filtered.toList.zip(open_brackets,\
    \ closed_brackets)\n        val final_groups = groups.map{ case (group, rest_parens)\
    \ => group + rest_parens}\n        final_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_nxwpajv.scala:34:16\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                result\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:\
    \    (result : String)\n\e[31m   |\e[0m                Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_nxwpajv.scala:37:16 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                x\n\e[31m\e[31m   |\e[0m            \
    \    ^\e[0m\n\e[31m   |\e[0m                Found:    (x : String)\n\e[31m   |\e\
    [0m                Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_nxwpajv.scala:40:41 --------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mgroups\e[0m = filtered.toList.zip(open_brackets,\
    \ closed_brackets)\n\e[31m\e[31m   |\e[0m                                    \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    (Array[String], Array[String])\n\e[31m   |\e[0m      \
    \                          Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize some variables\n       \
    \ var result_list: List[String] = Nil\n        var open_brace_count : Int = 0\n\
    \        var closed_brace_count : Int = 0\n        var open_paren_count = 0\n\
    \        var close_paren_count = 0\n\n        // Create a stack of parentheses\n\
    \        val paren_stack = new mutable.Stack[String]()\n\n        // Iterate through\
    \ each character in the input string\n        for (c <- paren_string) {\n\n  \
    \          // If it is an open parenthesis character\n            if (c == '(')\
    \ {\n                // Increase the paren count for this opening parenthesis\n\
    \                open_paren_count += 1\n\n                // If the stack of parenthesis\
    \ is not empty\n                if (paren_stack.nonEmpty) {\n                \
    \    // Pop the stack of parenthesis\n                    val last_open_brace\
    \ = paren_stack.pop()\n\n                    // If the last opening brace was\
    \ a close parenthesis\n                    if (last_open_brace == '(') {\n   \
    \                     // Increase the closed brace count for this opening parenthesis\n\
    \                        close_paren_count += 1\n                    }\n     \
    \           }\n            }\n\n            // If it is an close parenthesis character\n\
    \            else if (c == ')') {\n                // Decrease the closing paren\
    \ count for the opening parenthesis\n                close_paren_count -= 1\n\n\
    \                // If the stack of parenthesis is not empty\n               \
    \ if (paren_stack.nonEmpty) {\n                    // Pop the stack of parenthesis\n\
    \                    val last_closed_brace = paren_stack.pop()\n\n           \
    \         // If the last closing brace was an open parenthesis\n             \
    \       if (last_closed_brace == '(') {\n                        // Increase the\
    \ open brace count for this closing parenthesis\n                        open_brace_count\
    \ += 1\n                    }\n                }\n            }\n\n          \
    \  // If it is a closing brace character\n            else if (c == ')') {\n \
    \               // If the stack of parenthesis is not empty\n                if\
    \ (paren_stack.nonEmpty) {\n                    // Pop the stack of parenthesis\n\
    \                    val last_closed_brace = paren_stack.pop()\n\n           \
    \         // If the last closing brace was an open parenthesis\n             \
    \       if (last_closed_brace == '(') {\n                        // Decrease the\
    \ open brace count for this closing parenthesis\n                        open_brace_count\
    \ -= 1\n                    }\n                }\n            }\n\n          \
    \  // If it is a opening brace character\n            else if (c == '(') {\n \
    \               // If the stack of parenthesis is not empty\n                if\
    \ (paren_stack.nonEmpty) {\n                    // Pop the stack of parenthesis\n\
    \                    val last_open_brace = paren_stack.pop()\n\n             \
    \       // If the last opening brace was a close parenthesis\n               \
    \     if (last_open_brace == '(') {\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf_mubdyf.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf_mubdyf.scala:19:30\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mparen_stack\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpf_mubdyf.scala:22:8 ---------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (c <- paren_string) {\n\e[31m\e\
    [31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e\
    [0m        Required: List[String]\n\e[31m23 |\e[0m            \e[34m// If it is\
    \ an open parenthesis character\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m\
    \ (c == \e[31m'('\e[0m) {\n\e[31m25 |\e[0m                \e[34m// Increase the\
    \ paren count for this opening parenthesis\e[0m\n\e[31m26 |\e[0m             \
    \   open_paren_count += \e[31m1\e[0m\n\e[31m27 |\e[0m                \e[34m//\
    \ If the stack of parenthesis is not empty\e[0m\n\e[31m28 |\e[0m             \
    \   \e[33mif\e[0m (paren_stack.nonEmpty) {\n\e[31m29 |\e[0m                  \
    \  \e[34m// Pop the stack of parenthesis\e[0m\n\e[31m30 |\e[0m               \
    \     \e[33mval\e[0m \e[36mlast_open_brace\e[0m = paren_stack.pop()\n\e[31m31\
    \ |\e[0m                    \e[34m// If the last opening brace was a close parenthesis\e\
    [0m\n\e[31m32 |\e[0m                    \e[33mif\e[0m (last_open_brace == \e[31m'('\e\
    [0m) {\n\e[31m33 |\e[0m                        \e[34m// Increase the closed brace\
    \ count for this opening parenthesis\e[0m\n\e[31m34 |\e[0m                   \
    \     close_paren_count += \e[31m1\e[0m\n\e[31m35 |\e[0m                    }\n\
    \e[31m36 |\e[0m                }\n\e[31m37 |\e[0m            }\n\e[31m38 |\e[0m\
    \            \e[34m// If it is an close parenthesis character\e[0m\n\e[31m39 |\e\
    [0m            \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m'"
  stdout: ''
  timestamp: 1660013587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = mutable.MutableList[String]()\n\
    \        paren_string.foreach{char =>\n            if (char == \"(\") paren_groups\
    \ += char\n            if (char == \")\") paren_groups -= char\n            if\
    \ (paren_groups.contains(char)) paren_groups += char\n        }\n        paren_groups.size\n\
    \        paren_groups.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl9dr82rv.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpl9dr82rv.scala:13:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m (char == \e[31m\"(\"\e[0m)\
    \ paren_groups += char\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpl9dr82rv.scala:14:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (char == \e[31m\")\"\e[0m)\
    \ paren_groups -= char\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1660013588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create a stack for brackets\n     \
    \   val stack = mutable.Stack[Int]()\n        val result = mutable.ListBuffer[String]()\n\
    \n        // For each character in the string\n        for (c <- paren_string.toCharArray)\
    \ {\n            // If the character is a left paren, push it to the stack\n \
    \           if (c == '(') stack.push(c) //push left paren\n\n            // If\
    \ the character is a right paren, pop the stack and append it to the result list\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) {\n    \
    \                result += c.toString\n                } else {\n            \
    \        stack.pop() //pop left paren\n                    result += c.toString\n\
    \                }\n            }\n\n            // If the character is a space,\
    \ ignore it\n            else if (c == ' ') {\n            }\n\n            //\
    \ If the stack is not empty, the stack is not closed\n            else if (stack.nonEmpty)\
    \ {\n            }\n\n            // If the stack is empty, unclosed paren, append\
    \ it to the result list\n            else if (stack.empty) {\n               \
    \ result += c.toString\n            }\n\n            // If the stack is open,\
    \ but we see a left paren when it is not closed, throw an error.\n           \
    \ else if (stack.head == '(') {\n                throw new IllegalArgumentException(\"\
    unmatched opening brace\")\n            }\n\n            // If the stack is closed\
    \ but we see a right paren when it is not open, throw an error.\n            else\
    \ {\n                throw new IllegalArgumentException(\"unmatched closing brace\"\
    )\n            }\n        }\n\n        // The last item of the list is the result\
    \ list, append it to the result list\n        result += (paren_string - 1)\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3od5715.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp_3od5715.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var brackets = mutable.Set[Char]()\n \
    \       var paren_stack = mutable.Stack[Char]()\n        var groups = mutable.ListBuffer[String]()\n\
    \        var i = 0\n        val len = paren_string.length\n        paren_string.chars.toList\
    \ foreach { c =>\n            val i = paren_string.indexAt(i)\n            paren_stack\
    \ push c\n            if (brackets.contains(c) || c =='(' || c == ')'){\n    \
    \            brackets += c\n            } else if( c == '(') {\n             \
    \   paren_stack push c\n            } else if (c == ')') {\n                brackets\
    \ -= c\n                groups.append (paren_stack.pop())\n            }\n   \
    \         i += 1\n        }\n        return groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1qysskmr.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mbrackets\e[0m = mutable.Set[\e\
    [35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1qysskmr.scala:12:26 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mparen_stack\e[0m = mutable.Stack[\e\
    [35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1qysskmr.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mgroups\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1qysskmr.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        paren_string.chars.toList foreach { \e[36mc\e\
    [0m =>\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m        value toList is not a member of java.util.stream.IntStream\n4\
    \ errors found\n"
  stdout: ''
  timestamp: 1660013587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_array = paren_string.split(\"\
    \\\\(\")\n        val paren_list_string = paren_array.drop(1).map(_ replaceAll(\"\
    \\\\)\", \"\"))\n        val paren_list_array = new mutable.ArrayList[String]()\n\
    \        paren_list_array.add(paren_list_string)\n        val paren_list_array_string\
    \ = paren_list_array.mkString(\"(\", \")\", \", \")\")\n        val paren_list_array_array\
    \ = paren_list_array_string.split(\"\\\\)\")\n        paren_list_array_array.filter(s\
    \ => s.contains(\"(\")).drop(1).map(s => s replaceAll(\"\\\\(\", \"\")).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7q7tlhy4.scala:15:79 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mparen_list_array_string\e\
    [0m = paren_list_array.mkString(\e[31m\"(\"\e[0m, \e[31m\")\"\e[0m, \e[31m\",\
    \ \"\e[0m)\")\n\e[31m\e[31m   |\e[0m                                         \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                                  unclosed string literal\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp7q7tlhy4.scala:13:35 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mparen_list_array\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp7q7tlhy4.scala:17:8 -------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        paren_list_array_array.filter(\e[36ms\e[0m => s.contains(\e[31m\"(\"\
    \e[0m)).drop(\e[31m1\e[0m).map(\e[36ms\e[0m => s replaceAll(\e[31m\"\\\\(\"\e\
    [0m, \e[31m\"\"\e[0m)).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: paren_list_array_array\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if(paren_string.length == 0) List(\"\"\
    )\n        else {\n            val bracket = paren_string.charAt(0)\n        \
    \    val group_start = paren_string.indexOf(paren_string splitBy bracket)\n  \
    \          val group_end = group_start + paren_string.indexOf(paren_string dropRight\
    \ group_start)\n            val group_startString = paren_string.subSequence(group_start,\
    \ group_end).toString\n            val group_endString = paren_string.subSequence(group_start\
    \ + paren_string.length, paren_string.length).toString\n            val result:\
    \ List[String] = List(group_startString) +\n                (paren_string.subSequence(group_start+1,\
    \ group_end).takeWhile(c => c != bracket).map( paren_string.subSequence(group_start,\
    \ group_end).toString).toList)\n            result ++ List(group_endString)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphwv1_o9r.scala:14:64 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mgroup_start\e[0m = paren_string.indexOf(paren_string\
    \ splitBy bracket)\n\e[31m\e[31m   |\e[0m                                    \
    \               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue splitBy is not\
    \ a member of String - did you mean paren_string.split?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphwv1_o9r.scala:18:63 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mString\e[0m] = List(group_startString) +\n\e[31m\e[31m   |\e[0m    \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of List[String], but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphwv1_o9r.scala:19:68\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                (paren_string.subSequence(group_start+\e\
    [31m1\e[0m, group_end).takeWhile(\e[36mc\e[0m => c != bracket).map( paren_string.subSequence(group_start,\
    \ group_end).toString).toList)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value takeWhile is not a member of CharSequence\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: Create a stack to hold the list\
    \ of strings to return and push one level of parens\n        val paren_list =\
    \ mutable.ListBuffer[String]()\n        paren_string match {\n            case\
    \ \"\" => paren_list\n            case _ => paren_string foreach { char =>\n \
    \               if (char == '(') paren_list += char\n                if (char\
    \ == ')') paren_list.last += char\n            }\n        }\n        paren_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt79fat6z.scala:12:25 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mparen_list\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\\\\(\")\n      \
    \      .filterNot(_.isEmpty)\n            .filter(_.nonEmpty)\n            .map(x\
    \ => x.replace(\" \", \"\"))\n            .filter(x => x.length>0)\n         \
    \   .flatMap(x => x.split(\"\\\\)\").filter(_.nonEmpty))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkkwu5cdb.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.split(\e\
    [31m\"\\\\(\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m[String]\n\e[31m12 |\e[0m            .filterNot(_.isEmpty)\n\
    \e[31m13 |\e[0m            .filter(_.nonEmpty)\n\e[31m14 |\e[0m            .map(\e\
    [36mx\e[0m => x.replace(\e[31m\" \"\e[0m, \e[31m\"\"\e[0m))\n\e[31m15 |\e[0m \
    \           .filter(\e[36mx\e[0m => x.length>\e[31m0\e[0m)\n\e[31m16 |\e[0m  \
    \          .flatMap(\e[36mx\e[0m => x.split(\e[31m\"\\\\)\"\e[0m).filter(_.nonEmpty))\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var open_braces : List[Int] = Nil\n  \
    \      var open_brace_count : Int = 0\n        var closed_braces : List[Int] =\
    \ Nil\n        var closed_brace_count : Int = 0\n        var strings : List[String]\
    \ = Nil\n        var string_count : Int = 0\n        var paren_count = 0\n   \
    \     val paren_groups = paren_string.trim().split(\"\\\\(\")\n        for (paren_group\
    \ <- paren_groups) {\n            val strings = paren_group.trim().split(\"\\\\\
    )\")\n            for (string <- strings) {\n                if (string.trim().equals(\"\
    \")) continue\n                if (string.startsWith(\"(\")) {\n             \
    \       string_count += 1\n                    strings += string\n           \
    \     } else if (string.startsWith(\")\")) {\n                    string_count\
    \ -= 1\n                    paren_count += 1\n                    paren_count\
    \ += (string.startsWith(\"(\") ? 1 : -1)\n                    if (string.startsWith(\"\
    (\")) {\n                        if (paren_count < 0) {\n                    \
    \        open_braces = List(-paren_count)\n                            open_brace_count\
    \ = (open_braces.foldLeft(0) { (acc, next) => acc + next })\n                \
    \        }\n                    } else if (string.startsWith(\")\")) {\n     \
    \                   if (paren_count == 0) {\n                            closed_braces\
    \ = List(string_count)\n                            closed_brace_count = (closed_braces.foldLeft(0)\
    \ { (acc, next) => acc + next })\n                        }\n                \
    \    }\n                }\n            }\n            if (strings.size > 0) strings\
    \ += strings\n        }\n        if (string_count == 0 && paren_count == 0) strings\
    \ else strings.head\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp44m3wmz5.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m (string.trim().equals(\e\
    [31m\"\"\e[0m)) continue\n\e[31m\e[31m   |\e[0m                              \
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \                Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp44m3wmz5.scala:25:28 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                    strings += string\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of Array[String] - did you mean strings.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp44m3wmz5.scala:29:32 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                    paren_count += (string.startsWith(\e[31m\"(\"\e[0m)\
    \ ? \e[31m1\e[0m : -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value += is not a member of Int - did you\
    \ mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp44m3wmz5.scala:29:59\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    paren_count\
    \ += (string.startsWith(\e[31m\"(\"\e[0m) ? \e[31m1\e[0m : -\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value ? is not a member\
    \ of Boolean\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp44m3wmz5.scala:43:42\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mif\e[0m\
    \ (strings.size > \e[31m0\e[0m) strings += strings\n\e[31m\e[31m   |\e[0m    \
    \                              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of Array[String] - did you mean strings.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp44m3wmz5.scala:45:72 --------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        \e[33mif\e[0m (string_count == \e[31m0\e[0m && paren_count\
    \ == \e[31m0\e[0m) strings \e[33melse\e[0m strings.head\n\e[31m\e[31m   |\e[0m\
    \                         "
  stdout: ''
  timestamp: 1660013591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = paren_string.split(\"\
    \"\"[\\(\\)]+\"\"\").toList\n        var brace_open = 0\n        var brace_close\
    \ = 0\n        var string_list : List[String] = Nil\n        \n        for (paren_group\
    \ <- paren_groups) {\n            if(paren_group.length == 1) {\n            \
    \    string_list = string_list :+ paren_group\n                continue\n    \
    \        }\n\n            if(paren_group == paren_group.substring(1)) {\n    \
    \            brace_open += 1\n            }\n            else {\n            \
    \    brace_close += 1\n            }\n\n            if(brace_open > 0 && brace_close\
    \ > 0) {\n                string_list = string_list :+ paren_group\n         \
    \   }\n\n            if(paren_group == paren_group.substring(0, 1)) {\n      \
    \          brace_open -= 1\n            }\n            else {\n              \
    \  brace_close -= 1\n            }\n        }\n        \n        string_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprl54uyfi.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = Nil\n    \
    \    val paren_groups = paren_string.substring(1,paren_string.length).split(\"\
    \"\"\\s(?=\\s)\"\"\")\n        for (i <- 0 until paren_groups.length) {\n    \
    \        val cur_paren_group = paren_groups(i)\n            var j = 0\n      \
    \      var paren_balance = 0\n            var open_parens = 0\n            var\
    \ prev_closed_parens = 0\n            while (j < cur_paren_group.length) {\n \
    \               val cur_char = cur_paren_group(j)\n                val next_char\
    \ = paren_groups(j + 1)\n                cur_char.equals(next_char) match {\n\
    \                    case true => {\n                        j += 1\n        \
    \            }\n                    case false => {\n                        if\
    \ (cur_char == '(') {\n                            open_parens += 1\n        \
    \                } else if (cur_char == ')') {\n                            paren_balance\
    \ -= 1\n                        }\n                    }\n                }\n\
    \                j += 1\n            }\n            if (open_parens == paren_balance)\
    \ {\n                result += paren_groups(i).split(\"\"\"\\s(?=\\s)\"\"\").toList\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgukm3imd.scala:37:23 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                result += paren_groups(i).split(\e[31m\"\
    \"\"\\s(?=\\s)\"\"\"\e[0m).toList\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Step 1: Split input string into list\
    \ of nested strings\n        val nestedString = paren_string.flatMap(x => x.toString.split(\"\
    \\\\s+\")).toList\n        nestedString.foldLeft(List[String]())((x, y) => {\n\
    \            // Step 2: If current item is an open brace, append all items until\
    \ it closes up until the\n            // next open brace or end of string. If\
    \ it's an open brace, check if it can be closed up\n            // (meaning it\
    \ has no unclosed parens) and if so, add it to the list.\n            if (x.get(0).equals(\"\
    (\")) {\n                val itemList = x.tail.flatMap(y => y.toString.split(\"\
    \\\\s+\"))\n                // If it can be closed up, add it\n              \
    \  if (itemList.forall(y => y.equals(\"(\") || y.equals(\")\")))\n           \
    \         y :: x\n                else\n                    x :+ y\n         \
    \   } else // If current item is a closing bracket, check if it can be closed\
    \ up (meaning it no\n                    // unclosed parens) and if so, remove\
    \ it and add it to result list.\n                if (x.get(0).equals(\")\")) {\n\
    \                    val itemList = x.tail.flatMap(y => y.toString.split(\"\\\\\
    s+\"))\n                    // If it can be closed up, remove it\n           \
    \         if (itemList.forall(y => y.equals(\"(\") || y.equals(\")\")))\n    \
    \                    y :: x.tail\n                    else\n                 \
    \       x :+ y.tail\n                } else\n                    x :+ x\n    \
    \    })\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpa0yohdh1.scala:12:40 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mnestedString\e[0m = paren_string.flatMap(\e\
    [36mx\e[0m => x.toString.split(\e[31m\"\\\\s+\"\e[0m)).toList\n\e[31m\e[31m  \
    \ |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mflatMap\e[0m in \e\
    [33mclass\e[0m \e[35mStringOps\e[0m with types\n\e[31m   |\e[0m (f: Char => String):\
    \ String\n\e[31m   |\e[0m [B](f: Char => IterableOnce[B]): IndexedSeq[B]\n\e[31m\
    \   |\e[0mmatch arguments (Char => Array[String])\n1 error found\n"
  stdout: ''
  timestamp: 1660013587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // The set of paren group indices we currently\
    \ have are stored here.\n        // Each time we see a paren group, we add it\
    \ to the list of paren group indices.\n        // Each time we see a closing paren\
    \ group, we remove it from the list of paren group indices.\n        // When we\
    \ see a closing paren group, we remove all indices from the set of paren group\
    \ indices\n        // that were added since the last time we saw a closing paren\
    \ group.\n        val paren_group_indices = Set[Int]()\n        // The list of\
    \ paren groups to return\n        var returned_groups: List[String] = Nil\n\n\
    \        // For each character in the paren string and each paren group index\
    \ in the set of paren group indices\n        for (c <- paren_string.charAt(0);\
    \ i <- paren_group_indices) {\n            // If the character is a left paren,\
    \ or the current set of paren group indices contain no left paren\n          \
    \  if (c == '(' || paren_group_indices.isEmpty) {\n                // If we're\
    \ currently adding paren groups to the list\n                if (paren_group_indices.contains(i))\
    \ {\n                    // Then we add the character to the current paren group\n\
    \                    returned_groups = returned_groups :+ (c :: Nil)\n       \
    \         } else {\n                    // Otherwise, we're removing the paren\
    \ group from the set of paren group indices\n                    paren_group_indices\
    \ -= i\n                }\n            } else {\n                // If the character\
    \ is a right paren, or the current set of paren group indices contain no right\
    \ paren\n                if (c == ')' || paren_group_indices.isEmpty) {\n    \
    \                // If we're currently removing paren groups from the list\n \
    \                   if (paren_group_indices.contains(i)) {\n                 \
    \       // Then we remove that character from the current paren group\n      \
    \                  returned_groups = returned_groups :+ (Nil:::(c))\n        \
    \            } else {\n                        // Otherwise, we're removing the\
    \ paren group from the set of paren group indices\n                        paren_group_indices\
    \ -= i\n                    }\n                } else {\n                    //\
    \ If we're currently adding paren groups to the list\n                    if (paren_group_indices.contains(i))\
    \ {\n                        // Then we add the character to the current paren\
    \ group\n                        returned_groups = returned_groups :+ (c :: Nil)\n\
    \                    } else {\n                        // Otherwise, we're removing\
    \ the paren group from the set of paren group indices\n                      \
    \  paren_group_indices -= i\n                    }\n                }\n      \
    \      }\n        }\n\n        // Return the list of paren groups\n        returned_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7qx12n9c.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m (c <- paren_string.charAt(\e[31m0\e\
    [0m); i <- paren_group_indices) {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value foreach is not a member of Char\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"{\").map(s => s.trim).filter(_.nonEmpty).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.regex.PatternSyntaxException: Illegal repetition near index 1\n\
    {\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\tat java.base/java.util.regex.Pattern.closure(Pattern.java:3309)\n\
    \tat java.base/java.util.regex.Pattern.sequence(Pattern.java:2214)\n\tat java.base/java.util.regex.Pattern.expr(Pattern.java:2069)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1783)\n\tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\tat java.base/java.lang.String.split(String.java:3153)\n\
    \tat java.base/java.lang.String.split(String.java:3199)\n\tat Problem$.separateParenGroups(tmpokitz_9a.scala:11)\n\
    \tat Problem$.main(tmpokitz_9a.scala:14)\n\tat Problem.main(tmpokitz_9a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dot"
  stdout: ''
  timestamp: 1660013592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val open_paren_counts = mutable.ArrayBuffer.fill(paren_string.length)(0)\n\
    \        var curr_index = 0\n        while (curr_index < paren_string.length)\
    \ {\n            if (paren_string(curr_index) == '(') {\n                open_paren_counts(curr_index)\
    \ += 1\n            } else {\n                open_paren_counts(curr_index) -=\
    \ 1\n            }\n            curr_index += 1\n        }\n        val open_paren_counts_sum\
    \ = open_paren_counts.sum\n        val result_list = mutable.ListBuffer[String]()\n\
    \        var curr_index = 0\n        while (curr_index < paren_string.length)\
    \ {\n            if (open_paren_counts(curr_index) == 0) {\n                curr_index\
    \ += 1\n                continue\n            }\n            val open_paren_counts_element\
    \ = open_paren_counts(curr_index)\n            if (open_paren_counts_element >\
    \ 0) {\n                result_list += paren_string.substring(curr_index, curr_index\
    \ + open_paren_counts_element)\n                curr_index += open_paren_counts_element\n\
    \            } else {\n                val left_paren_length = paren_string.length\
    \ - curr_index\n                val right_paren_length = open_paren_counts_sum\
    \ - open_paren_counts(curr_index)\n                if (left_paren_length > right_paren_length)\
    \ {\n                    val left_paren_start_index = curr_index\n           \
    \         val right_paren_end_index = curr_index + open_paren_counts_sum\n   \
    \                 result_list += paren_string.substring(left_paren_start_index,\
    \ right_paren_end_index)\n                }\n                curr_index += open_paren_counts(curr_index)\n\
    \            }\n        }\n        result_list.trim\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjnbcg7mc.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mcurr_index\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurr_index\
    \ is already defined as \e[33mvariable\e[0m \e[35mcurr_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjnbcg7mc.scala:11:32\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mopen_paren_counts\e[0m = mutable.ArrayBuffer.fill(paren_string.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjnbcg7mc.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mresult_list\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjnbcg7mc.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val bracket_openers : List[(Int, Int)]\
    \ = paren_string.zipWithIndex\n        val bracket_closers : List[(Int, Int)]\
    \ = paren_string.zipWithIndex.filter( _._2 != paren_string.size - 1 )\n      \
    \  val bracket_pairs : List[(Int, Int)] = paren_string.zipWithIndex.filter( _._2\
    \ == paren_string.size - 1 )\n        val unbalanced : List[(Int, Int)] = paren_string.zipWithIndex.filter(\
    \ _._2 < paren_string.size - 1 )\n        val unbalanced_pairs : List[(Int, Int)]\
    \ = unbalanced.filter( _._2 == unbalanced.size - 1 )\n\n        def matchUnbalanced(start\
    \ : Int, end : Int) : Option[((Int, Int), (Int, Int))] = {\n            if (end\
    \ < 0 || end >= paren_string.size) None\n            else (paren_openers(start),\
    \ paren_closers(end)).filter( _._1 != _._2 )\n        }\n\n        def matchPair(start\
    \ : Int, end : Int) : Option[((Int, Int), (Int, Int))] = {\n            if (end\
    \ < 0 || end >= paren_string.size) None\n            else (paren_openers(start),\
    \ paren_closers(end)).filter( _._1 == _._2 )\n        }\n\n        // Check for\
    \ unbalanced pairs\n        val unbalanced_start : Option[Int] = unbalanced_pairs.find\
    \ { case ((_, start), (_, end)) => start < end }\n        val unbalanced_end :\
    \ Option[Int] = unbalanced_pairs.find { case ((_, start), (_, end)) => start <\
    \ end }\n        val unbalanced_pair : Option[((Int, Int), (Int, Int))] = matchUnbalanced(unbalanced_start.get._2,\
    \ unbalanced_end.get._2)\n\n        // Check for unbalanced pairs\n        val\
    \ pair_start : Option[Int] = unbalanced_pair.find { case ((_, start), (_, end))\
    \ => start < end }\n        val pair_end : Option[Int] = unbalanced_pair.find\
    \ { case ((_, start), (_, end)) => start < end }\n        val pair_pair : Option[((Int,\
    \ Int), (Int, Int))] = matchPair(pair_start.get._2, pair_end.get._2)\n\n     \
    \   // Check for unbalanced pairs\n        val unbalanced_start : Option[Int]\
    \ = unbalanced_pairs.find { case ((_, start), (_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyqnfh3sr.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyqnfh3sr.scala:48:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m48 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpyqnfh3sr.scala:11:62 --------------------\e[0m\e[0m\n\
    \e[31m11 |\e[0m        \e[33mval\e[0m \e[36mbracket_openers\e[0m : \e[35mList\e\
    [0m[(\e[35mInt\e[0m, \e[35mInt\e[0m)] = paren_string.zipWithIndex\n\e[31m\e[31m\
    \   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    IndexedSeq[(Char @uncheckedVariance,\
    \ Int)]\n\e[31m   |\e[0m                    Required: List[(Int, Int)]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyqnfh3sr.scala:12:81 --------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbracket_closers\e[0m : \e\
    [35mList\e[0m[(\e[35mInt\e[0m, \e[35mInt\e[0m)] = paren_string.zipWithIndex.filter(\
    \ _._2 != paren_string.size - \e[31m1\e[0m )\n\e[31m\e[31m   |\e[0m          \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    IndexedSeq[(Char,\
    \ Int)]\n\e[31m   |\e[0m                                       Required: List[(Int,\
    \ Int)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyqnfh3sr.scala:13:79\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbracket_pairs\e\
    [0m : \e[35mList\e[0m[(\e[35mInt\e[0m, \e[35mInt\e[0m)] = paren_string.zipWithIndex.filter(\
    \ _._2 == paren_string.size - \e[31m1\e[0m )\n\e[31m\e[31m   |\e[0m          \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  "
  stdout: ''
  timestamp: 1660013594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Split string into words\n        val\
    \ word_list = paren_string.trim().split(' ').filter(_.nonEmpty).toList\n     \
    \   var balanced_list: List[String] = Nil\n        var open_list_stack: List[String]\
    \ = Nil\n        \n        // Iterate through words and remove empty ones\n  \
    \      for(word <- word_list) {\n            if (word == \"\") continue\n    \
    \        \n            // If the word is not empty, add it to open_list_stack\n\
    \            if (word != \")\") {\n                open_list_stack ::= word\n\
    \            } else {\n                // If the word is \")\", we remove the\
    \ last element from open_list_stack\n                if (open_list_stack.length\
    \ > 0) open_list_stack = open_list_stack.dropRight(1)\n                \n    \
    \            // If the stack is empty, that means the whole parentheses are balanced\n\
    \                if (open_list_stack.length == 0) balanced_list ::= open_list_stack\n\
    \                \n                // If the stack has at least 1 element in it,\
    \ that means the parentheses are not nested\n                else {\n        \
    \            val open_paren_len = open_list_stack.length\n                   \
    \ if (open_paren_len == 1) {\n                        open_list_stack = open_list_stack.tail\n\
    \                        balanced_list ::= open_list_stack\n                 \
    \   } else {\n                        // Iterate through the open_list_stack\n\
    \                        for(open_paren_word <- open_list_stack) {\n         \
    \                   if (open_paren_word == \"(\") open_list_stack ::= open_list_stack.dropRight(1)\n\
    \                            else if (open_paren_word == \")\") open_list_stack\
    \ ::= open_list_stack.dropRight(1)\n                        }\n              \
    \          balanced_list ::= open_list_stack\n                    }\n        \
    \        }\n            }\n        }\n        \n        // Return balanced_list\n\
    \        balanced_list\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpujgh5d72.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (word == \e[31m\"\"\e[0m) continue\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpujgh5d72.scala:28:63 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (open_list_stack.length\
    \ == \e[31m0\e[0m) balanced_list ::= open_list_stack\n\e[31m\e[31m   |\e[0m  \
    \                                               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujgh5d72.scala:35:38 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        balanced_list ::= open_list_stack\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujgh5d72.scala:39:72 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                            \e[33mif\e[0m (open_paren_word\
    \ == \e[31m\"(\"\e[0m) open_list_stack ::= open_list_stack.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::= is not a member of List[String]\
    \ - did you mean List[String].::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujgh5d72.scala:40:77\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                        \
    \    \e[33melse\e[0m \e[33mif\e[0m (open_paren_word == \e[31m\")\"\e[0m) open_list_stack\
    \ ::= open_list_stack.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                                                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue ::= is not a member of List[String] - did you mean List[String].::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujgh5d72.scala:42:38 --------------------"
  stdout: ''
  timestamp: 1660013593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // The current stack represents the current\
    \ group of parenthesis\n        val stack = new Stack[String]()\n        // The\
    \ current group of parenthesis represent the current string\n        val group\
    \ = \"\"\n        // Iterate through all the characters in the paren_string\n\
    \        for (char <- paren_string.toCharArray) {\n            // If the character\
    \ is a '('\n            if (char == '(') {\n                // Push the current\
    \ group of parenthesis onto the stack\n                stack.push(group)\n   \
    \             group = \"\"\n            }\n            // If the character is\
    \ a ')'\n            if (char == ')') {\n                // If the current stack\
    \ is empty we reached the end of the current group of parenthesis\n          \
    \      if (stack.isEmpty) {\n                    // If this was the last group\
    \ of parenthesis\n                    if (group.length > 0) {\n              \
    \          // We add the group of parenthesis to the list\n                  \
    \      val list = List(group)\n                        // Return the list\n  \
    \                      list\n                    } else {\n                  \
    \      // We return an empty list\n                        Nil\n             \
    \       }\n                } else {\n                    // Pop the current group\
    \ of parenthesis from the stack\n                    val current_group = stack.pop()\n\
    \                    // Update the current group\n                    group =\
    \ current_group + \")\"\n                }\n            }\n            // If the\
    \ character is a space\n            if (char == ' ') {\n                // Do\
    \ nothing\n            }\n            // If the character is not a space\n   \
    \         else {\n                // Add the character to the current group of\
    \ parenthesis\n                group = group + char\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk6emf67v.scala:21:22 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                group = \e[31m\"\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val group\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk6emf67v.scala:41:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                   \
    \ group = current_group + \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \ Reassignment to val group\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpk6emf67v.scala:51:22 -----------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m                group = group + char\n\e[31m\e[31m   |\e[0m          \
    \      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val group\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning:\
    \ /tmp/tmpk6emf67v.scala:32:24 ----------------\e[0m\e[0m\n\e[33m32 |\e[0m   \
    \                     list\n\e[33m\e[33m   |\e[0m                        ^^^^\e\
    [0m\n\e[33m   |\e[0mA pure expression does nothing in statement position; you\
    \ may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmpk6emf67v.scala:35:24 ----------------\e[0m\e\
    [0m\n\e[33m35 |\e[0m                        Nil\n\e[33m\e[33m   |\e[0m       \
    \                 ^^^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement\
    \ position; you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 warnings\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660013591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val result = mutable.ListBuffer[String]()\n\
    \        var paren_count = 1\n        paren_string.split(\"\"\"\\s*(?:\\(\\)|\\\
    {[^{}]*\\})\\s*\"\"\").foreach(x => {\n            if( x.matches(\"\\\\(\\\\)\"\
    ) ) paren_count = paren_count + 1\n            if( x.matches(\"\\\\{[^{}]*\\\\\
    }\") ) paren_count = paren_count - 1\n            if( paren_count == 0 ) result\
    \ += x\n        })\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpooxd1lao.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create a map to store opening paren\
    \ groups\n        var groups : mutable.Map[String, List[String]] = mutable.Map[String,\
    \ List[String]]()\n        // Keep track of last closing paren group\n       \
    \ var last_closing_paren_group : Option[String] = None\n        // Iterate over\
    \ each char in the string\n        for (c <- paren_string) {\n            // If\
    \ current char is a left paren then create a new list of opening paren group\n\
    \            if (c == \"(\") {\n                groups.getOrElseUpdate(\"()\"\
    , new ListBuffer[String]()) += c\n            }\n            // If current char\
    \ is a right paren then create a new list of closing paren group\n           \
    \ else if (c == \"(\") {\n                // Add new closing paren group to list\
    \ of closing paren groups\n                val curr_group_str : List[String] =\
    \ groups.get(\"()\")\n                curr_group_str match {\n               \
    \     case Nil => last_closing_paren_group = None\n                    case curr_group_str\
    \ => last_closing_paren_group = curr_group_str\n                }\n          \
    \      groups.update(\"()\", new ListBuffer[String]()) += c\n            }\n \
    \           // If current char is a space then skip it\n            else if (c\
    \ == \" \") {\n                // Do nothing\n            }\n            // If\
    \ current char is an opening left paren group then check that it closes properly\
    \ (either by a\n            // closing right paren or by another left paren)\n\
    \            else if (c == \"(\") {\n                // If last closing paren\
    \ group exists then add this group to the list of groups and ignore it\n     \
    \           if (last_closing_paren_group.isDefined) {\n                    groups.getOrElseUpdate(last_closing_paren_group.get,\
    \ new ListBuffer[String]()) += c\n                }\n            }\n         \
    \   // If current char is a closing left paren group then check that it opens\
    \ properly (either by a\n            // closing right paren or by another left\
    \ paren)\n            else if (c == \")\") {\n                // If last opening\
    \ paren group exists then add this group to the list of groups and ignore it\n\
    \                if (groups.containsKey(last_closing_paren_group.get)) {\n   \
    \                 groups.getOrElse(last_closing_paren_group.get) match {\n   \
    \                     // If there are open right parens then close them\n    \
    \                    case Nil => groups.remove(last_closing_paren_group.get)\n\
    \                        // If there are no open right parens then close the group\n\
    \                        case curr_group_str => curr_group_str match {\n     \
    \                       case Nil => groups.remove(last_closing_paren_group.get)\n\
    \                            case _ => curr_group_str.clear()\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n        // Return list of \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q1ig6o0.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mgroups\e[0m : mutable.Map[\e\
    [35mString\e[0m, \e[35mList\e[0m[\e[35mString\e[0m]] = mutable.Map[\e[35mString\e\
    [0m, \e[35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m            \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q1ig6o0.scala:12:57\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e\
    [36mgroups\e[0m : mutable.Map[\e[35mString\e[0m, \e[35mList\e[0m[\e[35mString\e\
    [0m]] = mutable.Map[\e[35mString\e[0m, \e[35mList\e[0m[\e[35mString\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                                              \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp5q1ig6o0.scala:18:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \     \e[33mif\e[0m (c == \e[31m\"(\"\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp5q1ig6o0.scala:22:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m\"(\"\e[0m) {\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5q1ig6o0.scala:27:70 --------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m                    \e[33mcase\e[0m curr_group_str => last_closing_paren_group\
    \ = curr_group_str\n\e[31m\e[31m   |\e[0m                                    \
    \                                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                         Found:    (curr_group_str : List[String])\n\e[31m  \
    \ |\e[0m                            "
  stdout: ''
  timestamp: 1660013594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n\n      \
    \  for(chr <- paren_string.toList) {\n            if(chr.equals(\"(\")) {\n  \
    \              groups.append(chr)\n            } else if(chr.equals(\")\")) {\n\
    \                if(groups.nonEmpty) {\n                    val last_group = groups.pop\n\
    \                    if(last_group.equals(\"(\")) {\n                        groups.append(last_group)\n\
    \                    } else {\n                        groups.append(last_group)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp8qgrdil.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                groups.append(chr)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a member\
    \ of List[String] - did you mean List[String].appended?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp8qgrdil.scala:18:44 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m                    \e[33mval\e[0m \e[36mlast_group\e[0m =\
    \ groups.pop\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pop is not a member of List[String] - did you mean List[String].drop?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp8qgrdil.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                        groups.append(last_group)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ append is not a member of List[String] - did you mean List[String].appended?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp8qgrdil.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                        groups.append(last_group)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ append is not a member of List[String] - did you mean List[String].appended?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if(paren_string.isEmpty) List() else {\n\
    \            var groups = mutable.ListBuffer[String]()\n            var opening_braces\
    \ : Int = paren_string.count('(')\n            var closing_braces : Int = paren_string.count(')')\n\
    \            paren_string.grouped(paren_string.length).foreach(c => {\n      \
    \          val index = c.toInt\n                if(c.char == '(') {\n        \
    \            opening_braces += 1\n                } else if(c.char == ')') {\n\
    \                    closing_braces -= 1\n                }\n                if(!opening_braces\
    \ && !closing_braces) {\n                    groups += c.drop(index)\n       \
    \         }\n            })\n            groups.toList\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpupy1axe9.scala:12:25 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mvar\e[0m \e[36mgroups\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpupy1axe9.scala:13:58 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mopening_braces\e[0m\
    \ : \e[35mInt\e[0m = paren_string.count(\e[31m'('\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0m                                               Found:    (\e[31m'('\e\
    [0m : Char)\n\e[31m   |\e[0m                                               Required:\
    \ Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpupy1axe9.scala:14:58\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mvar\e[0m \e\
    [36mclosing_braces\e[0m : \e[35mInt\e[0m = paren_string.count(\e[31m')'\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^\e[0m\n\e[31m   |\e[0m                                               Found:\
    \    (\e[31m')'\e[0m : Char)\n\e[31m   |\e[0m                                \
    \               Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpupy1axe9.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                \e[33mif\e[0m(c.char == \e[31m'('\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   value char is not a member of String - did you mean c.chars?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpupy1axe9.scala:19:28 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m(c.char\
    \ == \e[31m')'\e[0m) {\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e"
  stdout: ''
  timestamp: 1660013594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def unbalanced(paren_string : String)\
    \ : Boolean = {\n            paren_string.matches(\".*[^()]+.*\")\n        }\n\
    \n        def balanced(paren_string : String) : Boolean = {\n            paren_string.matches(\"\
    .*[(].*[)]\")\n        }\n\n        def isBalanced(paren_string : String) : Boolean\
    \ = {\n            unbalanced(paren_string) && balanced(paren_string)\n      \
    \  }\n\n        def balancedParenGroups(paren_string : String) : List[String]\
    \ = {\n            paren_string.substring(1).split(\"\\\\(\").map(x => x.substring(0,1))\n\
    \        }\n\n        val paren_strings = paren_string.split(\"\\\\(\")\n\n  \
    \      var result: List[String] = Nil\n\n        val counter = paren_strings.length\n\
    \n        for(i <- 0 until counter) {\n            var paren_string = paren_strings(i)\n\
    \            val newParens = if (!balancedParenGroups(paren_string)) {\n     \
    \           result :+ paren_string\n            } else {\n                val\
    \ nextParens = paren_string.substring(1).split(\"\\\\)\")\n                paren_string\
    \ = paren_string.substring(0,1)\n                nextParens.map(balancedParenGroups)\n\
    \            }\n\n            if (unbalanced(paren_string) || !isBalanced(paren_string)\
    \ || paren_string == \"\") {\n                result :+ paren_string\n       \
    \     }\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxrxbe8hd.scala:24:12\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            paren_string.substring(\e\
    [31m1\e[0m).split(\e[31m\"\\\\(\"\e[0m).map(\e[36mx\e[0m => x.substring(\e[31m0\e\
    [0m,\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m\
    \   |\e[0m            Required: \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxrxbe8hd.scala:35:32 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mnewParens\e[0m = \e\
    [33mif\e[0m (!balancedParenGroups(paren_string)) {\n\e[31m\e[31m   |\e[0m    \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                           value unary_! is not a member of List[String]\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def stack: List[String] = Nil\n      \
    \  def popStack: List[String] = Nil\n\n        val parens = paren_string.split(\"\
    \\\\)|\\\\(|)\")\n        val output: List[String] = Nil\n        var paren_stack:\
    \ List[String] = Nil\n        var paren_output = Nil\n        var paren_output_len\
    \ = 0\n        parens.foreach { x =>\n            paren_stack.push(x)\n      \
    \      if (x.equals(\"(\")) {\n                paren_output += x\n           \
    \     paren_output_len += 1\n            } else if ((x.equals(\")\")) || (x.equals(\"\
    ))\"))) {\n                paren_output_len -= 1\n                paren_output\
    \ += paren_stack.pop()\n            }\n            if (paren_stack.isEmpty) {\n\
    \                paren_output += x\n                paren_output_len += 1\n  \
    \          }\n        }\n        if (paren_stack.isEmpty) {\n            paren_output\
    \ += paren_stack.pop()\n        }\n        paren_stack.foreach(x => output +=\
    \ x)\n        output\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxowqv32.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            paren_stack.push(x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member\
    \ of List[String] - did you mean List[String].last?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpzxowqv32.scala:22:29 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m                paren_output += x\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of object\
    \ scala.collection.immutable.Nil - did you mean Nil.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpzxowqv32.scala:26:29 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                paren_output += paren_stack.pop()\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is\
    \ not a member of object scala.collection.immutable.Nil - did you mean Nil.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxowqv32.scala:26:44 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                paren_output += paren_stack.pop()\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue pop is not a member of List[String] - did you mean List[String].drop?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxowqv32.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                paren_output += x\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of object scala.collection.immutable.Nil - did you mean Nil.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpzxowqv32.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            paren_output += paren_stack.pop()\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of object scala.collection.immutable.Nil - did you mean Nil.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxowqv32.scala:34:40 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            paren_output += paren_stack.pop()\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^"
  stdout: ''
  timestamp: 1660013595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create a stack representing the paren_string\
    \ in reverse order.\n        // While the stack is not empty and there is something\
    \ at the top of the stack.\n        // Add whatever is at the top of the stack\
    \ into the new list we return at the end.\n        // The new list will be reverse\
    \ sorted at the end.\n        // When we reach the end of the string, we have\
    \ the final result in the list we return.\n        val paren_stringReverse = paren_string.reverse\n\
    \        var paren_stack = Stack[String]()\n        paren_stringReverse.foreach(x\
    \ => if(x != \")\") paren_stack push x)\n        var new_strings = List[String]()\n\
    \        var paren_stack_size = paren_stack.size\n        var new_strings_size\
    \ = new_strings.size\n        while(paren_stack_size > 0 && new_strings_size <\
    \ paren_stringReverse.size) {\n            if(paren_stack.peek() == \"(\") {\n\
    \                paren_stack = paren_stack.pop()\n                paren_stack_size\
    \ -= 1\n            } else if(paren_stack.peek() == \")\") {\n               \
    \ paren_stack.push(\")\")\n                paren_stack_size -= 1\n           \
    \     new_strings = new_strings :+ paren_stack.pop()\n            } else {\n \
    \               paren_stack.push(\")\")\n                paren_stack_size -= 1\n\
    \                new_strings = new_strings :+ paren_stack.pop()\n            }\n\
    \            new_strings_size += 1\n        }\n        new_strings.reverse\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_ek9ggg1.scala:18:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        paren_stringReverse.foreach(\e[36mx\e[0m => \e\
    [33mif\e[0m(x != \e[31m\")\"\e[0m) paren_stack push x)\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Values of types Char and String cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_ek9ggg1.scala:18:71 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        paren_stringReverse.foreach(\e[36mx\e[0m => \e\
    [33mif\e[0m(x != \e[31m\")\"\e[0m) paren_stack push x)\n\e[31m\e[31m   |\e[0m\
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0m                                                    Found:    (x\
    \ : Char)\n\e[31m   |\e[0m                                                   \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ek9ggg1.scala:23:27\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(paren_stack.peek()\
    \ == \e[31m\"(\"\e[0m) {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue peek is not a member of scala.collection.mutable.Stack[String]\
    \ - did you mean scala.collection.mutable.Stack[String].head?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_ek9ggg1.scala:24:45 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                paren_stack = paren_stack.pop()\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    String\n\e[31m   |\e[0m                 \
    \       Required: scala.collection.mutable.Stack[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ek9ggg1.scala:26:34 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(paren_stack.peek()\
    \ == \e[31m\")\"\e[0m) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue peek is not "
  stdout: ''
  timestamp: 1660013595
