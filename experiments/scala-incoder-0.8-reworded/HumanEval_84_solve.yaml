name: HumanEval_84_solve
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer N, return the total sum of its digits in binary.\n\
  \    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>> solve((150l))\n\
  \    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\")\n    // Variables:\n\
  \    // @N integer\n    // Constraints: 0 \u2264 N \u2264 10000.\n    // Output:\n\
  \    // a string of binary number\n    def solve(N : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
  1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
  1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
  10010\")));\n    }\n\n}\n"
completions: ["        val digits = new mutable.StringBuilder\n        while(N.nonZero)\
    \ {\n            val temp = N % 10\n            digits += if (temp == 0) \"\"\
    \ else temp.toString\n            N /= 10\n        }\n        digits.reverse",
  "        val bits: mutable.Map[Int, Int] = mutable.HashMap()\n        def numBits(n\
    \ : Long) : Int = {\n            var result = bits(n)\n            if(n == 0)\
    \ 1\n            else if(n == -1) result - 1\n            else if(n%2 == 1) 3*result\
    \ + numBits(n/2)\n            else 3*result + numBits(n/2) + 1\n        }\n  \
    \      while(numBits(N) > 1) {\n            val nextBits = numBits(N/2)\n    \
    \        val bit = nextBits - 1\n            bits.putIfAbsent(bit, 0l) += N %\
    \ 2\n            N /= 2\n        }\n        val result = bits(0)\n        if(N\
    \ > 0) result + \"\" + solve(N - 1)\n        else result", "        // The final\
    \ answer\n        var ans = \"\"\n        // The current sum\n        var sum\
    \ = 0\n        // The current digit\n        var digit = 0\n        // While the\
    \ number is greater than zero\n        while(N > 0) {\n            // Add the\
    \ number to the total\n            sum += N % 2\n            N /= 2\n        }\n\
    \        // Calculate the final answer\n        while (sum > 0) {\n          \
    \  // Calculate the next digit\n            digit = sum % 2\n            // Put\
    \ the digit into the answer\n            ans = ans.concat(digit.toString)\n  \
    \          // And remove it from the total sum\n            sum /= 2\n       \
    \ }\n        // Return the answer\n        return ans", "        def sum(n: Long):\
    \ String = n.toStringBinary\n        val result = mutable.StringBuilder(\"\")\n\
    \        val remainders = scala.math.pow(2, N)\n        remainders.foreach { remainder\
    \ =>\n            val nextValue = sum((remainder + N))\n            result +=\
    \ nextValue\n        }\n        result.toString", "        val digits = N.toString.reverse.grouped(2).map({\
    \ case (left, right) => left + right })\n        val answer = digits.foldLeft(0)(_\
    \ + _)\n        answer match {\n            case x if (x < 10) => (\"0\" * x).reverse\n\
    \            case x if (x < 100) => (\"1\" * x).reverse\n            case _ =>\
    \ \"\"\n        }", "        var sum = 0\n        for(i <- 0 until N) {\n    \
    \        sum += math.pow(2, i)\n        }\n        sum.toString", "        def\
    \ convert(N : Long) : Long = {\n            var sum = 0\n            var base\
    \ = 0\n            while (N > 0) {\n                sum += (N % 2l) * base\n \
    \               base = N / 2l\n                N = (N - 1l) / 2l\n           \
    \ }\n            sum\n        }\n        val result = new mutable.StringBuilder\n\
    \        var Ns = N toString\n        var Nd = Ns.length\n        var power =\
    \ Nd.toLong\n        var i = 0\n        while (power.toInt > 0) {\n          \
    \  val j = power.toInt - i\n            if (j > 0) {\n                Ns = Ns.substring(0,\
    \ i) + Ns.substring(i)\n                Nd = j\n                power = 0\n  \
    \          } else {\n                val res = convert(power).toChar\n       \
    \         result.append(res)\n                power = power * 2\n            \
    \    i = 0\n            }\n        }\n        result.append(Ns)\n        result.toString()",
  "      require(N >= 0L, \"N must be a positive integer\")\n      var sum = 0L\n\
    \      val digits = mutable.ArrayBuffer.empty[String]\n      val n = N.toInt\n\
    \      for {\n        i <- 0 until n\n          d <- N - i\n          if d > 1\n\
    \      } sum += i * d\n\n      digits += ((0 + sum).asBinaryString).reverse\n\
    \      digits.toList.reverse.foldLeft(\"\"){ case (acc, x) => acc + (\"0\" + x).asBinaryString}",
  "        def getBinary(N : Long, sum : Long) : String = {\n            val remainder\
    \ = new BigDecimal(N).divide(BigDecimal.ONE).toBigInteger\n            var str\
    \ = remainder.toString\n            while(str.length < 8){\n                str\
    \ = \"0\" + str\n            }\n            sum += remainder\n            str\n\
    \        }\n        var result = \"\"\n        var sum = 0\n        for(i <- 0\
    \ to N.toInt){\n            val bin = getBinary(i, sum)\n            result +=\
    \ bin\n        }\n        result", "        val result = new collection.mutable.ArrayList[String]()\n\
    \        val temp = N.toBinaryString\n\n        // The result string will be\n\
    \        // \"1\" + \"0\"*N +\"1\"*N\n        // where N is len of the result\
    \ string\n        for( i <- 0 until temp.length() ) result += \"1\" + \"0\"*(temp.length()-i)\n\
    \        result += \"1\"\n        return result.toString()", "        // write\
    \ your code here\n        val digits = N.toString.reverse.grouped(2).map(_ + \"\
    \").map(_.reverse).map(_.toInt).map(_.toString(2))\n        val sum = digits.foldLeft(0)(_\
    \ + _)\n        digits.map(_.reverse).map(_.toInt).map(_.toString(2)).map((x)\
    \ => x + sum).reverse.map((x) => x.reverse).map(String.reverse).mkString", " \
    \       // Convert N to binary\n        val binary = N.toBinaryString\n      \
    \  val s = mutable.Buffer.empty[String]\n        val m = binary.length\n     \
    \   // Populate buffer s\n        var i = m - 1\n        while (i >= 0) {\n  \
    \          val d = binary(i).toLong\n            s ++= if (d > 0) \"1\" + s else\
    \ \"\"\n            i -= 1\n        }\n        // Remove trailing 0s\n       \
    \ val r = s.reverse\n        val retval = r.takeWhile(_ != \"0\").reverse.toString\
    \ + r.dropWhile(_ != \"0\").mkString\n        return retval", "        var sum\
    \ = 0\n        var bits = N.toBinaryString\n        for(i <- 0 until bits.length)\n\
    \            sum = sum + (Integer.valueOf(bits(i).asInstanceOf[String])*2)\n \
    \       val result = Integer.toBinaryString(sum).reverse.asInstanceOf[String]\n\
    \        while(result(0) == '1') result = result.substring(1)\n        result",
  "        val b1 = BigInt(N.toString.substring(0,N.toString.length-1)).toBinaryString\n\
    \        val b2 = BigInt(N.toString).toBinaryString\n        val res = \"0\"\n\
    \        for( i <- b1 ) res += \"1\"\n        for( i <- b2 ) res += \"0\"\n  \
    \      res.reverse", "        // Write your code here.\n        val str = new\
    \ StringBuilder\n        if(N%2==0) str +=\"1\"\n        else {\n            val\
    \ digits = N.toString.reverse\n            val counts = mutable.Map[Int,Int]()\n\
    \            for (i <- 0 until digits.length) counts(digits(i))+=1\n         \
    \   for ((k,v) <- counts) str+=k\n        }\n        str", "        // write your\
    \ code in here\n        val res = new collection.mutable.StringBuffer\n      \
    \  res.appendAll(\n            Stream.iterate(N)(_ / 10).map(_.toString).map {\n\
    \                x => (x % 2).toString\n            }.scanLeft(0){case (n,c) =>\
    \ n + c}.takeWhile(_ => N > 0).foldLeft(0)(_ + _)\n        ).dropWhile(_ < N).takeWhile(_\
    \ <= N).foldLeft((0,\"\"))(_ + _ + _)._1\n        return res", "        var sum\
    \ = 0l\n        var last = 0\n        var remainder = 0\n        var i = N\n \
    \       var j = 0\n        while ( i != 0l ) {\n            val remain = i rem\
    \ 2\n            val last = i % 2\n            val newSum = sum + last\n     \
    \       if ( remain != 0 ) {\n                sum = newSum\n                remainder\
    \ += remain\n                i = i / 2\n            }\n            else {\n  \
    \              sum = last\n                i = i / 2\n            }\n        }\n\
    \        if ( (sum + remainder) == N) {\n            val ret = \"1\"\n       \
    \     while (sum != 0l) {\n                ret += sum % 2\n                sum\
    \ = sum / 2\n            }\n            ret += remainder\n            return ret\n\
    \        }\n        else return \"1\"", "        def binary(n: Long): String =\
    \ {\n            var sum = \"\"\n            var tmp = 0\n            while(n\
    \ > 0) {\n                tmp = n % 10\n                sum = sum + tmp.toString\
    \ + sum\n                n /= 10\n            }\n            sum\n        }\n\
    \        var binary = \"\"\n        for(i <- 0 to N-1) {\n            binary +=\
    \ binary(i)\n        }\n        binary", "        if (N < 0) return \"-1\"\n \
    \       val s = N.toBinaryString\n        val arr = s.toIntArray\n        val\
    \ ans = \"\"\n        arr foreach (x => {\n            if (x < 10) {\n       \
    \         ans += x.toString + \" \"\n            }\n            else {\n     \
    \           val c = x - 10\n                ans += Integer.toBinaryString(c) +\
    \ \" \"\n            }\n        })\n        ans", "        if(N<0)\n         \
    \   throw new Exception(\"N should be positive integer\")\n        val b1 = N.toBinaryString\n\
    \        val b2 = b1.reverse\n        val r = b2.charAt(0).toInt\n        val\
    \ r = r.toString\n        val x = b2.charAt(1).toInt\n        val x = x.toString\n\
    \        val N = (N.toString.length).toInt\n        if(N>1) {\n            val\
    \ res = solve(N.toString.substring(1))\n            val res = res + res +res;\n\
    \            return res\n        }\n        if(N==0) {\n            return r\n\
    \        }\n        if(x==1) {\n            return r + res\n        }\n      \
    \  if(x==0) {\n            if(r.length==1)\n                return r + r\n   \
    \         else\n                return r.substring(0, 1) + r\n        }\n    \
    \    return r.substring(0, x-1) + r + res", "      var sum = 0l\n      var binarySum\
    \ : String = \"\"\n      // Iterate over the decimal digits in binary\n      //\
    \ starting with the least significant digit (leftmost).\n      while (N > 0l)\
    \ {\n        sum = (sum * 10) + N % 10\n        N = N / 10\n      }\n      //\
    \ Sum the digits in the binary string.\n      while (sum != 0l) {\n        binarySum\
    \ = binarySum + sum % 2\n        sum = sum / 2\n      }\n      return binarySum.toString",
  "        // Write your code here\n        val binary = N.toBinaryString\n      \
    \  var i = binary.length - 1\n        val answer = new mutable.StringBuilder\n\
    \        var sum = 0\n        while (i >= 0) {\n            if (binary.charAt(i)\
    \ == '1') {\n                sum += 1 \n                answer.append(1)\n   \
    \         } else if (binary.charAt(i) == '0') {\n                answer.append(0)\n\
    \            } else {\n                val temp = sum * 2\n                sum\
    \ += temp % 10\n                answer.append(temp / 10)\n            }\n    \
    \        i -= 1\n        }\n        answer.toString", "        var n = 0\n   \
    \     var digits = Array[Char](0)\n        var result : String = \"\"\n      \
    \  while (n <= N) {\n            if (n % 2 == 0) digits += \"1\"\n           \
    \ else digits += \"0\"\n            n /= 2\n        }\n        digits.reverse\n\
    \        for (i <- 0 until digits.length) result += (digits.charAt(i).toInt &\
    \ 1).toChar + \" \"\n        result", "        val N = N.toInt\n        var result\
    \ : String = \"\"\n        var digit : Int = 0\n\n        if (N > 0) {\n     \
    \       result += N % 2\n            N /= 2\n\n            while (N > 0) {\n \
    \               digit += 1\n                N = (N - 1) * (10 + (N % 2))\n   \
    \         }\n            result = result + digit.toString\n        }\n       \
    \ return result", "      val res = mutable.Set.empty[String]\n      def f(n: Long,\
    \ cur : String) : Unit = {\n        if(n < 0) { res.clear(); return }\n      \
    \  if(n < 10) { res ++= cur + n.toString() }\n        if(n % 2 == 0) { f(n/2,\
    \ cur + n.toString()) }\n        if(n % 2 == 1) { f(n/2, cur + \"+\") }\n    \
    \  }\n      f(N, \"0\")\n      if(res.size == 0)\n        \"0\"\n      else\n\
    \        val result = res.mkString\n        result.substring(0, result.length-1)",
  "        var ans = \"\"\n        var m = N\n        var digits = \"\"\n        while\
    \ (m>0) {\n            digits += \"0\"\n            m -= (m rem 2)\n        }\n\
    \        ans = digits\n        return ans", "        val bin = List(\"\", \"0\"\
    , \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\");\n        val ans\
    \ = bin(N.toInt % 10000)", "        val result = scala.collection.mutable.StringBuilder\n\
    \        for {\n            i <- N\n            k <- scala.math.pow(2,i).toInt\n\
    \            if (k % 2 == 0)\n                result.append((i).toString)\n  \
    \          else\n                result.append((k).toString)\n        }\n    \
    \    result.toString", "        def solveUtil(N: Long): String = {\n         \
    \   // base case\n            if (N == 0)\n                return \"0\"\n\n  \
    \          val binary = scala.collection.mutable.ListBuffer[String]()\n      \
    \      var Nremainder = N\n            while(Nremainder > 0){\n              \
    \  val Nmod = Nremainder % 2\n                Nremainder = Nrem / 2\n        \
    \        val remainder = Nrem % 2\n                val binaryString = if (remainder\
    \ == 0) \"1\" else (\"0\" + remainder)\n                binary += binaryString\n\
    \            }\n\n            binary.reverse.mkString(\"\")\n        }\n\n   \
    \     solveUtil(N)", "        val ret = \"0\"\n        var sum : Long = 0\n  \
    \      var tmp : Long = 0\n        while (sum <= N) {\n            tmp = sum %\
    \ 10\n            sum = sum / 10\n            ret = ret + tmp.toString\n     \
    \   }\n        if (sum > 0)\n            ret = ret + sum.toString\n        return\
    \ ret", "        val bits = N.toBinaryString\n        var s = \"\"\n        for(\
    \ i <- 0 until bits.length){\n            if(bits(i) == '1'){\n              \
    \  s += '1'\n            }else{\n                s += '0'\n            }\n   \
    \     }\n        return s", "        val ans = 0.toByte.split('').map(_.toInt).reverse.foldLeft(0)((total,\
    \ n) => {\n            val i = n.toInt\n            total += i\n            total.toBinaryString\n\
    \        })\n        if (N == 0) \"\" else ans.reverse", "        val digits =\
    \ N.toString.toInt\n        val binary = digits.foldLeft(\"\"){\n            (s,x)\
    \ => s + \"1\" * (x % 2 == 0 ? 1 : 0) + \" \" + (x%2 == 0 ? \"0\" : \"1\")\n \
    \       }\n        // Remove redundant spaces\n        binary = binary.replace(\"\
    \ \", \"\")\n        binary.substring(0, binary.length-1)", "        val binary\
    \ = N.toBinaryString\n        val sum = 0\n        for (i <- 1 to binary.length)\
    \ {\n            val index = binary take i\n            sum += index.toInt\n \
    \           binary = binary drop (i)\n        }\n        (sum mod 2).toBinaryString",
  "        val N = N.toLong\n        val digits = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        val remainders = scala.collection.mutable.ListBuffer.empty[Long]\n  \
    \      var sum = 0\n        var current = 0\n\n        while(N /= 10) {\n    \
    \        digits += current\n            current *= 10\n            sum += current\n\
    \            current /= 10\n            remainders += 1\n        }\n\n       \
    \ if(N > 0) {\n            digits += current\n            sum += current\n   \
    \     }\n        var output = \"\"\n        while(sum /= 2) {\n            output\
    \ += digits.reverse.dropWhile(digit.lt(0)).takeWhile(digit.lt(0)).mkString(\"\"\
    )\n            sum += remainders.head\n            remainders = remainders.tail\n\
    \        }\n        output += digits.reverse.dropWhile(digit.lt(0)).takeWhile(digit.lt(0)).mkString(\"\
    \")\n        output", "        val nums = N.digits.reverse\n        val zeros\
    \ = nums.takeWhile(_ > 0)\n        val ones = nums.filter(_ <= 0)\n\n        val\
    \ sum = zeros.zip(ones).foldLeft(0)((a, b) => a + b)\n        val leftSum = zeros.zip(ones).map(x\
    \ => if (x._2 > 0) x._1 + 1 else 0).sum\n        val rightSum = zeros.zip(ones).map(x\
    \ => if (x._2 < 0) x._1 - 1 else 0).sum\n\n        if (sum == 0 && leftSum ==\
    \ 0 && rightSum == 0)\n            return \"0\"\n        else if (sum == 0 &&\
    \ leftSum == 0 && rightSum != 0)\n            return \"1\"\n        else if (sum\
    \ != 0 && leftSum == 0 && rightSum == 0)\n            return s\"${sum.toBinaryString}1\"\
    \n        else if (sum != 0 && leftSum != 0 && rightSum == 0)\n            return\
    \ s\"${sum.toBinaryString}0\"\n        else if (sum != 0 && leftSum == 0 && rightSum\
    \ != 0)\n            return s\"${sum.toBinaryString}${rightSum.toBinaryString}1\"\
    \n        else if (sum == 0 && leftSum != 0 && rightSum != 0)\n            return\
    \ s\"${leftSum.toBinaryString}${rightSum.toBinaryString}0\"\n        else if (sum\
    \ == 0 && leftSum == 0 && rightSum == 0)\n            return s\"${leftSum.toBinaryString}0\"\
    \n        else\n            return s\"${leftSum.toBinaryString}${rightSum.toBinaryString}0\"",
  "        val N = N.abs match {\n            case n if n > 0 => n\n            case\
    \ n if n < 0 => -(n + 10000)\n        }\n\n        val s = BigInt(N).toString(2)\n\
    \        val res = s.foldLeft(\"\")((acc: String, v: Int) => acc + (if (v == 0)\
    \ \"\" else (v.toChar + \"\")))\n\n        val res = res.reverse.foldRight(res)((acc:\
    \ String, v: Int) => acc + (if (v == 0) \"\" else (v.toChar + \"\")))\n      \
    \  res", "        // Find the number of binary digits in N:\n        var digitsN:\
    \ Int = math.floor(math.log(N) / math.log(2))\n        while (digitsN < 4) {\n\
    \            digitsN = digitsN + 1\n        }\n        // Calculate the sum of\
    \ all digits in N in binary number:\n        var sumN: Long = N.toBinaryString\n\
    \        while (sumN.length > digitsN) {\n            sumN.removeFirst\n     \
    \   }\n        // Add the \"0\" character if sumN is less than 10:\n        sumN\
    \ = sumN + if (sumN.length < 10) {\n            \"0\"\n        } else {\n    \
    \        None\n        }\n        // Find the sum of all digits in sumN in binary\
    \ number:\n        var sumN2: Long = sumN.toBinaryString\n        while (sumN2.length\
    \ > digitsN) {\n            sumN2.removeFirst\n        }\n        // Find the\
    \ sum of digits from 1 to digits in sumN2 in binary number:\n        var sumN3:\
    \ Long = sumN2.toBinaryString\n        var sumN4: Long = sumN3.toBinaryString\n\
    \        while (sumN4.length > digitsN) {\n            sumN4.removeFirst\n   \
    \     }\n        // Find the sum of digits from 2 to digits in sumN4 in binary\
    \ number:\n        var sumN5: Long = sumN4.toBinaryString\n        var sumN6:\
    \ Long = sumN5.toBinaryString\n        while (sumN6.length > digitsN) {\n    \
    \        sumN6.removeFirst\n        }\n        // Find the sum of digits from\
    \ 3 to digits in sumN6 in binary number:\n        var sumN7: Long = sumN6.toBinaryString\n\
    \        var sumN8: Long = sumN7.toBinaryString\n        while (sumN8.length >\
    \ digitsN) {\n            sumN8.removeFirst\n        }\n        // Find the sum\
    \ of digits from 4 to digits in sumN8 in binary number:\n        var sumN9: Long\
    \ = sumN8.toBinaryString\n        var sumN10: Long = sumN9.toBinaryString\n  \
    \      while (sumN10.length > digitsN) {\n            sumN10.removeFirst\n   \
    \     }\n        // Add the \"0\" character if sumN10 is less than 10:\n     \
    \   sumN10 = sumN10 + if (sumN10.length < 10) {\n            \"0\"\n        }\
    \ else {\n            None\n        }\n        // Find the sum of digits from\
    \ 5 to digits in sumN10 in binary number:\n        var sumN11: Long = sumN10.toBinaryString\n\
    \        var sumN12: Long = sumN11.toBinaryString\n        while (sumN12.length\
    \ > digitsN) {\n            sumN12.removeFirst\n        }\n        // Find the\
    \ sum of digits from 6 to digit", "        val s = mutable.StringBuilder(\"\"\
    )\n        if (N == 0) s.append \"0\"\n        else if (N == 1) s.append \"1\"\
    \n        else solve(N/10l, N % 10l, s.toString, \"\")", "        val ones = N.toBinaryString.reverse.grouped(2).map(_.mkString).\n\
    \                    toSeq.\n                    map{s => List(s\"1\",s).map(x\
    \ => BigInt(x))}\n                    .toList.\n                    flatten.\n\
    \                    sortBy(x => x).\n                    map{x => x.padToLen(BigInt(2).pow(x.toInt))}\n\
    \                    .toList\n\n        val tens = ones.takeWhile(x => x < 10)\n\
    \        if (tens.isEmpty) ones else tens.mkString(\"\") + ones", "        val\
    \ n = N.toInt\n        val sum = n.toString.reverse.grouped(2).map(_.map(_.toByte).sum).toInt\n\
    \        val binary = if (sum == 0) \"0\" else (n.toString + binary(sum - 1))\n\
    \        binary.reverse", "        val ans = \"\"\n        // Loop N times. Keep\
    \ track of the binary sums\n        // of the digits. When the sum of digits hits\
    \ 10\n        // then add a \"0\" to the string.\n        for (i <- 0 until N)\
    \ {\n            val binarySum = i.toString(2)\n            ans += binarySum\n\
    \        }\n        // If the binary sum is 1, add a \"0\"\n        if (ans.last\
    \ == '1') ans += \"0\"\n        ans", "        def digits(n: Long) : List[Long]\
    \ = {\n            val ans: List[Long] = new Array[Long](n + 1)\n            var\
    \ i = 0\n            var j = 0\n            while(i < n) {\n                ans(j)\
    \ = n%2\n                i = i + 1\n                j = j + 1\n            }\n\
    \            ans\n        }\n\n        def bits(n: Long) : List[String] = {\n\
    \            val ans: List[String] = new Array[String](n)\n            var i =\
    \ 0\n            var j = 0\n            while(i < n) {\n                ans(j)\
    \ = i.toString.toBinaryString\n                i = i + 1\n                j =\
    \ j + 1\n            }\n            ans\n        }\n\n        def binary(ns: Long)\
    \ : String = {\n            ns match {\n                case 0 => \"\"\n     \
    \           case 1 => binary(0n)\n                case x => {\n              \
    \      val ans: List[String] = digits(x)\n                    val ans2: List[String]\
    \ = bits(x)\n                    ans.zip(ans2) match {\n                     \
    \   case (\"\", \"\") => ans\n                        case (\"\", ans) => ans\n\
    \                        case (ans, \"\") => ans\n                        case\
    \ (ans, ans2) => {\n                            var x = 0\n                  \
    \          ans.zip(ans2) match {\n                                case (\"\",\
    \ \"\") => ans\n                                case (\"\", \"1\") => ans\n  \
    \                              case (ans, \"\") => ans\n                     \
    \           case (ans, \"0\") => ans\n                                case (ans,\
    \ \"1\") => ans\n                                case (ans, ans) => {\n      \
    \                              val a = ans.toLong\n                          \
    \          val b = ans2.toLong\n                                    val sum =\
    \ a + b\n                                    val ans3 = \"1\" + \"0\" * sum\n\
    \                                    val ans3a = \"0\" + \"1\" * sum\n       \
    \                             val ans3b = \"1\" + \"0\" * (sum + 1)\n        \
    \                            ans3a :: ans3b :: ans3\n                        \
    \        }\n                            }\n                        }\n       \
    \             }\n                }\n            }\n        }\n\n        binary(N)",
  "        val num = math.pow(10, math.ceil(math.log10(N)) + 1)\n        var sum =\
    \ 0\n        var result = \"1\"\n        val binary = List(num / 2)\n        val\
    \ length = math.ceil(math.log10(N))\n        binary.foreach { n =>\n         \
    \   if (n % 2 == 0){\n                sum = sum + n\n            }\n        }\n\
    \        for (i <- 1 to length){\n            if (num % 2 == 0){\n           \
    \     num = (num / 2).toInt\n                sum = sum + num\n            }\n\
    \        }\n        val str = (sum.toBinaryString).reverse\n        var j = 0\n\
    \        val stringArray = Array.ofDim[Char](string.length)\n        while (j\
    \ < string.length){\n            stringArray(j) = str(j)\n            j+=1\n \
    \       }\n        result = stringArray.reverse\n        result", "        val\
    \ n = N.toString.toInt\n        val sum = 0\n        var result: String = \"\"\
    \n        for(i <- 1 to n) {\n            val tmp = n % 2\n            sum = sum\
    \ + (tmp * i)\n            n = (n - tmp) / 2\n        }\n        result = sum.toString\
    \ + result\n        return result", "        val bitCount = N.bitLength\n    \
    \    val n = N / (2l*bitCount)\n        var s = \"\"\n        for(i <- 0 until\
    \ bitCount)\n            s = s+ (if (n & (1l*i)) \"1\" else \"0\") \n        return\
    \ s", "        def bin(x : Long, acc : String) : String = {\n            if ((x\
    \ & 1) == 0) {\n                acc += \"0\"\n            } else {\n         \
    \       acc += \"1\"\n            }\n            bin(x >> 1, acc)\n        }\n\
    \        if (N <= 0) {\n            \"0\"\n        } else if (N >= 10000l) {\n\
    \            \"0\"\n        } else {\n            bin(N, \"0\")\n        }", " \
    \      val list = scala.collection.mutable.ListBuffer.empty[Long]\n       list.push(N.toBinaryString)\n\
    \       val maxPower = 0\n       while(list.nonEmpty) {\n           val current\
    \ = list.head\n           list.remove(list.head)\n           val power = 0\n \
    \          while(current > 0) {\n               if(current % 2 == 1) {\n     \
    \              power += 1\n               }\n               current >>>= 1\n \
    \          }\n           val powerString = power.toString\n           if(powerString.length\
    \ > maxPower.toString) {\n               maxPower = powerString\n           }\n\
    \           if(maxPower == 0) {\n               list.clear()\n           }\n \
    \          if(maxPower == powerString) {\n               list.push(current)\n\
    \           }\n       }\n       list.last", "        if (N < 0 || N > 10000) {\n\
    \            return \"\"\n        }\n        val bin = List[String]()\n      \
    \  for (i <- 0 to N / 2L) {\n            val n = N - i * 2\n            val m\
    \ = 2L * i\n            if (n / 2L > m) {\n                bin.insert(0, s\"0${n\
    \ / 2L}\")\n            } else {\n                bin.insert(0, s\"1${n % 2L}\"\
    )\n            }\n        }\n        bin.foldLeft(\"\")(_ + _)", "        var\
    \ sum = 0\n        var last = 0\n        var ret = \"\"\n        for (i <- 1 to\
    \ N.toInt){\n            val temp = last.toInt + i // get the last digit sum +\
    \ i as int\n            sum += temp // add i to sum\n            last = temp //\
    \ store last\n            if (sum >= 1000000000){ // if sum is greater than 1000000000,\
    \ then output binary\n                ret += last.toString(2)\n              \
    \  sum -= 1000000000\n            }\n        }\n        ret", "      // Write\
    \ your code here\n      val arr = Array.ofDim[String](10000)\n      for(i <- 0\
    \ until arr.length) {\n        arr(i) = String.format(\"%10d\", i)\n      }\n\
    \      val sum = arr(0).length\n      for(h <- arr.toList)\n        sum += h.length\n\
    \      val ret = arr(arr.length - 1).reverse.mkString(\"\") + arr.last.substring(sum)\n\
    \      ret.reverse", "        var res = \"\"\n        var binary = N.toBinaryString\n\
    \        // Find out the prefix length\n        var prefix = binary.length\n \
    \       binary = binary.toCharArray\n        // Find the first non-zero digit\n\
    \        var digit = 0\n        var zeroCount = 0\n        while ((binary.length\
    \ >0) && (binary(digit) != '0')) {\n            digit = digit + 1\n          \
    \  zeroCount = zeroCount + 1\n        }\n        // Check if there is enough digits\
    \ in the string\n        if ((binary.length >0) && (zeroCount >= (binary.length\
    \ - prefix))) {\n            for (i <- 0 until binary.length - 1) {\n        \
    \        var currentValue = binary(i)\n                if (currentValue == '0')\
    \ {\n                    currentValue = binary.apply(digit)\n                \
    \    digit = digit + 1\n                    zeroCount = zeroCount + 1\n      \
    \          }\n                res = res + currentValue\n            }\n      \
    \  }\n        return res", "        val arr = new Array[Int]((N.toInt / 2).toInt)\n\
    \        val sum = new mutable.MutableList[Int]()\n        for(i <- 0 until N.toInt)\
    \ {\n            val n = N % 2\n            if(n > 0) arr(i) = n\n           \
    \ val c = new Integer(arr.toString .reverse).sum\n            sum.append(c) \n\
    \            N = (N - c) / 2\n        }\n        if(arr.isEmpty) sum.foreach(println)\n\
    \        else sum.mkString", "        val bitArray = Array[String](\"\")\n   \
    \     var i = 0\n        var currentBitString = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        while (N > 0) {\n            currentBitString = (currentBitString * 2)\
    \ + N % 2\n            bitArray(i) = Integer.toString(currentBitString, 2)\n \
    \           N = N / 2\n            i += 1\n        }\n        result.reverse.foreach(bitString\
    \ => {\n            while (bitString.length < i) {\n                bitString\
    \ = bitString + \"0\"\n            }\n            result.add(\"1\" * bitString.length\
    \ + bitString)\n        })\n        result.foldLeft(\"\")((a, b) => a + b)", " \
    \       def sum(n: Int): Int = {\n            if (n == 0) 1\n            else\
    \ n * sum(n-1)\n        }\n        def binary(num: Int): String = {\n        \
    \    var result: String = \"\"\n            var i = 0\n            while (num\
    \ > 0) {\n                val remainder = num % 2\n                result = remainder\
    \ + result\n                num /= 2\n                i += 1\n            }\n\
    \            i.toString() + result\n        }\n\n        val binary = binary(sum((N.toInt).toInt))\n\
    \        binary.length == 2 ? binary.substring(0,1) + binary.substring(1).toString\
    \ : binary", "        val remainder = N % 2\n        val sum = 0\n        var\
    \ power = 1\n        while (N /= 2){\n            if (N %2 == 1){\n          \
    \      sum += 1\n                N -= 2\n            } else {\n              \
    \  sum += (remainder * power).asInstanceOf[Int]\n                power = power\
    \ * 2\n                N -= 1\n            }\n        }\n        val binaryString\
    \ = scala.util.StringBuilder.newBuilder\n        while (power != 1){\n       \
    \     if (power % 2 != 0){\n                binaryString.append(power).append(\"\
    \ \").append(\"0\")\n            } else {\n                binaryString.append(power).append(\"\
    \ \")\n            }\n            power = power * 2\n        }\n        binaryString.append(sum).append(remainder).toString()",
  "        val result = N.toString(2)\n        val binary = result.length / 2\n  \
    \      val remainders = result.length % 2\n        val resultString = result.substring(0,\
    \ binary)\n        val result = binary.toString.reverse\n        val resultString\
    \ = resultString.reverse\n        val resultString = resultString + result.substring(0,\
    \ remainders)\n        resultString", "        val bitSet = scala.collection.mutable.BitSet(N.toInt)\n\
    \        // find all number with 1 as its first digit, start with the next digit\n\
    \        // loop until reaching the end of bits set\n        var i = 2\n     \
    \   while (i < bitSet.size) {\n            if (bitSet.nextSetBit(i)) {\n     \
    \           val d = (i-1).toInt\n                val total = d(0) * (N % d).toInt\n\
    \                bitSet.clear(d)\n                i += 1\n                bitSet.set\
    \ (d)\n                bitSet.set (N % d)\n                val remain = N - total\n\
    \                if (remain < 0) {\n                    val num = remain.toInt\n\
    \                    val temp = bitSet.nextSetBit(num)\n                    val\
    \ remain = remain - temp.toInt\n                    bitSet.clear(temp)\n     \
    \               bitSet.clear(num)\n                }\n                else {\n\
    \                    bitSet.clear(total)\n                    bitSet.clear(remain)\n\
    \                }\n            }\n        }\n        val sum = (bitSet.getBitSet.toList.toList.sum).toString.trim\n\
    \        if (sum.length == 0) {\n            sum = \"0\"\n        }\n        sum",
  "        // Set variables\n        val s = N.toBinaryString\n        var n = 0\n\
    \        // Iterate over the string\n        for (i <- 0 until s.length()) {\n\
    \            // Calculate the sum of digits and add the binary number\n      \
    \      n += (s(i).asDigit)\n            n += 2 * BigInt(1).pow(s.length() - i\
    \ - 1)\n        }\n        // Return the binary number\n        n.toBinaryString",
  "      var sum = 0\n      var binary = \"\"\n      while (N > 0) {\n        val\
    \ remainder = N % 2\n        N = N/2 // integer division\n        sum = sum +\
    \ remainder\n        binary = binary + remainder\n      }\n      binary = binary.reverse\n\
    \      binary = binary.mkString\n      binary", "        if (N < 0 || N > 10000l)\
    \ throw new IllegalArgumentException(\"N out of range\")\n        val binaryList\
    \ = Vector.empty[String]\n        def buildBinaryString(binaryList : mutable.MutableList[String],\
    \ num : Long) : String = {\n            if (num == 0) {\n                binaryList\
    \ += \"\"\n                return \"\"\n            }\n            val num = num\
    \ % (10 + 1)\n            val numString = if(num < 10) \"0\" + num.toString else\
    \ num.toString\n            val binaryString = buildBinaryString(binaryList, num\
    \ / 10)\n            binaryList += numString\n            binaryString\n     \
    \   }\n        if (N < 10) return buildBinaryString(binaryList, N)\n        val\
    \ result = buildBinaryString(binaryList, (N - 10) % 10)\n        if(N % 10 > 0)\
    \ result += \"0\"\n        result", "        // Solves Problem 4\n        if (N\
    \ < 0) return \"N < 0\"\n        if (N >= 10000) return \"N > 10000\"\n      \
    \  val binary = solve(N.toInt, N.toInt - 1, N.toInt - 2, N.toInt - 4, N.toInt\
    \ - 8, N.toInt - 16, N.toInt - 32, N.toInt - 64, N.toInt - 128, N.toInt - 256,\
    \ N.toInt - 512, N.toInt - 1024, N.toInt - 2048, N.toInt - 4096, N.toInt - 8192,\
    \ N.toInt - 16384, N.toInt - 32768, N.toInt - 65536)\n        val resultStr =\
    \ binary.map(i => if(i % 2 == 0) \"0\" + i else i).mkString\n        return resultStr",
  "        val nStr = new StringBuilder\n        for (i<- N; i>= 1; i-= 10){\n   \
    \         val m = i.toBinaryString\n            val n = m.length\n           \
    \ if (nStr.length == n){\n                nStr.append(\"1\")\n            }\n\
    \            else {\n                nStr.append(m)\n            }\n        }\n\
    \        nStr.toString()", "        def bin(num : Long) : String = {\n       \
    \     val num = num.toBinaryString()\n            num.substring(0, num.length\
    \ - 1)\n        }\n        val bins = mutable.Stack[String]()\n        def sumDigits(n\
    \ : Long) : Long = {\n            val num = n.toInt\n            val res = num\
    \ * Math.pow(10, num.toString.length - 1)\n            return res\n        }\n\
    \        // The binary digit count is 0\n        bins.push(\"0\")\n        for(i\
    \ <- N - 1 until nums.size) {\n            val next = sumDigits(i)\n         \
    \   if(bins.size > 0) bins.peek =  bins.peek + bins.pop + next.toString\n    \
    \        else bins.push(next.toString)\n        }\n        bins.reverse.mkString",
  "        var result = \"\"\n        var temp = N\n        var tempString = \"\"\n\
    \        while (temp > 0) {\n            tempString += Integer.toBinaryString(temp\
    \ % 2) + \"\"\n            temp /= 2\n        }\n        result = tempString\n\
    \        tempString = \"\"\n        result += \"0\"\n        while (result.length\
    \ < 8) {\n            result += tempString\n            result += \"\"\n     \
    \   }\n        return result", "        var S = 0\n        var i = 2\n       \
    \ var j = 0\n        while (i > 0) {\n            if (N & (1l << i)) {\n     \
    \           S += i\n            }\n            i += 1\n        }\n        if (S\
    \ == 0) {\n            S = 1\n        }\n        val bits = S.toBitString\n  \
    \      // print out the binary number\n        val result = (for (x <- bits.reverse.toList)\
    \ yield {\n            if (x == 1) 1 else 0\n        }).mkString\n        return\
    \ result", "        if(N < 0) return \"NO\"\n        if(N == 0) return \"0\"\n\
    \        if(N == 1) return \"1\"\n        if(N > 1) solve(N/2) + solve(N%2)*10",
  "        var sum = 0L\n        var n = 0L\n        while(n != N) {\n           \
    \ sum += n % 2\n            n = (n / 2)\n        }\n        sum.toString", " \
    \       val bin = scala.collection.mutable.ArrayBuffer.empty[String]\n       \
    \ (N / 2) match {\n            case 0 => bin.append(\"0\")\n            case n\
    \ => \n                if(n % 2 == 0) {\n                    val s = solve(N/2)\
    \ + solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2)\
    \ + solve(N/2)\n                    bin.append(s.reverse)\n                } else\
    \ if(n % 2 == 1) {\n                    val s = solve(N/2) + solve(N/2) + solve(N/2)\
    \ + solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2)\n         \
    \           bin.append(s)\n                } else if(n % 2 == 0) {\n         \
    \           val s = solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2) + solve(N/2)\
    \ + solve(N/2) + solve(N/2) + solve(N/2)\n                    bin.append(s.reverse)\n\
    \                }\n                bin.append(solve(N/2))\n        }\n      \
    \  bin.toString", "        val digitSum = N.toString.length\n        val maxNum\
    \ = math.pow(10, digitSum)\n        var sum = 0l\n        var temp = \"\"\n  \
    \      while (temp.length < digitSum){\n            sum += N % 2\n           \
    \ N /= 2\n        }\n        while (sum >= maxNum) {\n            temp = temp.dropRight(1)\n\
    \            sum += sum % 10\n        }\n        temp = temp + sum.toString\n\
    \        temp = temp.reverse\n        temp = temp.reverse.dropRight(1)\n     \
    \   temp", "        val sol: mutable.Set[Long] = mutable.Set[Long]()\n       \
    \ var num = 0\n        while(num < N) {\n            num = num << 1\n        \
    \    sol.add(num)\n        }\n        val result = \"\"\n        for((index, value)\
    \ <- sol.iterator) {\n            var temp = 0\n            while(index > 0) {\n\
    \                temp = temp >> 1\n                temp = value & temp\n     \
    \           value = value >> 1\n                if(value == 0) break\n       \
    \         index = index - 1\n            }\n            result = result + temp.toBinaryString\n\
    \        }\n        result", "        var result : String = \"\"\n        var\
    \ sum = 0\n        var bit = 0\n        var temp = 0\n        while (bit = N /\
    \ 2 > 0) {\n            temp = N % 2;\n            sum = sum + temp;\n       \
    \     N = N / 2;\n        }\n        result = sum + \"\"\n        if (sum != 0)\
    \ {\n            result = result + solve(sum)\n        }\n        return result",
  "        val binary = List(1l,10l,100l,1000l,10000l).filter(i => N % i == 0l).map(i\
    \ => i.toString(2l)).toList\n        val result = binary.foldLeft(\"0\"){ (result,\
    \ n) => n + result + n}\n        return result", "        var sum : Long = 0\n\
    \        var binStr = \"\"\n        while(N >  0) {\n            sum += N % 2\n\
    \            N /= 2\n        }\n        // if sum is 0, then there are only zeros\
    \ in binStr\n        if(sum == 0) {\n            return \"0\"\n        }\n   \
    \     while(sum > 0) {\n            binStr += sum % 2 == 0 ? \"1\" : \"0\"\n \
    \           sum /= 2\n        }\n        binStr.reverse", "        // Variable\
    \ declaration\n        var sum = 0L\n        var res: List[Char] = List()\n\n\
    \        // Base case\n        if (N == 0) return res\n\n        // Recursive\
    \ case\n        // We have already taken the digit of N\n        sum = (sum +\
    \ N % 10).toLong\n        // And take the last digit\n        N = (N / 10).ceil\n\
    \n        solve(N.toInt)\n", "        val stringBuffer = new StringBuffer\n  \
    \      val num = new mutable.Array[Int](N)\n        var index = 0\n        for(n\
    \ <- num) {\n            n := n % 2\n            stringBuffer.append(n.toString)\n\
    \            n := n / 2\n        }\n        num.clear()\n        stringBuffer.reverse()\n\
    \        stringBuffer.mkString", "        var sum = 0\n        var temp : List[Int]\
    \ = List(0)\n        var output : String = \"\"\n        var i : Int = 0\n   \
    \     for (j <- N.toString.reverse) {\n            var binary : Long = 0\n   \
    \         val temp = j.toInt.reverse\n            while (temp.length > 0) {\n\
    \                val x = temp.head\n                if (x > 0) {\n           \
    \         binary += (1 until x).map(x => temp.pop).sum * x\n                }\
    \ else {\n                    binary += x.map(x => temp.pop).sum\n           \
    \     }\n            }\n            output += (sum + binary)\n            sum\
    \ += binary\n        }\n        output", "        val NBin = (N.to_s drop 1).length\n\
    \        val s = \"\"\n        var i = 1\n        var j = 0\n        var sum =\
    \ 0\n        for (i <- 1L until (NBin)) {\n            val bit = N.toInt\n   \
    \         val rem = bit rem 2\n            if (rem == 0) sum += bit\n        \
    \    else {\n                sum += bit\n                if (j < NBin) s += \"\
    0\"\n                j++\n            }\n        }\n        if (sum > 0) s ++\
    \ s\"1$sum\"\n        else s", "        val res = new mutable.ListBuffer[String]()\n\
    \        val num = N.toInt % 2l\n        val N = N.toInt\n\n        var sum :\
    \ Long = 0\n        var i = 2l\n        while(i < N) {\n            sum += (i.toLong)%2\n\
    \            i += 1\n        }\n        res += if (sum == 0) \"0\" else (sum.toBinaryString).substring(0,\
    \ 1)\n\n        if(N > 1) {\n            var last = (N - 1l).toInt % 2l\n    \
    \        var left = N - 2l\n            while(left > 0) {\n                if(last\
    \ == 1l) {\n                    res.append(\"1\")\n                } else {\n\
    \                    res.append((last.toBinaryString).substring(0, 1))\n     \
    \           }\n                last = if (left == 1) 1l else 0l\n            \
    \    left -= 1\n            }\n        }\n\n        res.toString()", "       \
    \ if (N < 0) throw new Exception(\"Not a positive integer\")\n        if (N <=\
    \ 10000) (N.toString.reverse.map(x => (x % 2 != 0) ? \"0\" : \"1\")).mkString\n\
    \        else {\n            val N = N.toString.reverse.map(x => (x % 2 != 0)\
    \ ? \"0\" : \"1\").foldLeft(0)(_ + _)\n            (N / 10).round.toInt.round.toString.reverse.map(x\
    \ => (x % 2 != 0) ? \"0\" : \"1\").mkString\n        }", "        var res = \"\
    0\"\n        var carry = 0\n        for(i <- 0 until N / 2){\n            val\
    \ x = carry + N / 2 * i.toLong % 2\n            if(x == 1){\n                res\
    \ += \"1\"\n                carry = 1\n            }\n            else{\n    \
    \            res += \"0\"\n                carry = 0\n            }\n        }\n\
    \        if(carry > 0){\n            res += \"1\"\n        }\n        res", " \
    \       var sum = 0L\n        var nums = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        var temp = 0L\n        for (i <- N.toInt.until(1)) {\n            temp\
    \ = i / 2\n            nums = nums :+ (temp % 2)\n            sum += temp\n  \
    \      }\n        if (sum < 10) {\n            s\"0\"\n        } else {\n    \
    \        nums.toString.reverse\n        }", "      // Variables\n      var n =\
    \ N.toInt\n      var sum: Int = 0\n      var binary = new Array[Int](8) {0}\n\
    \      var binSum: Int = 0\n      var binSumString = \"\"\n      var binaryString\
    \ = new Array[String](8)\n      var binSumString: String = \"\"\n      var binSumInt\
    \ = new Array[Int](8)\n      var binSumIntString = \"\"\n\n      // Constraints\n\
    \      if ((n = 0) || n < 1) {\n          sum = 0\n      }\n      else {\n   \
    \       // Loop over binary array\n          for (i = binary.length - 1; i > 0;\
    \ i -= 1) {\n              binary[binary.length - 1 - i] = n\n              sum\
    \ += binary[binary.length - 1 - i]\n          }\n          binSum = sum\n    \
    \      binSumInt = Array(0)\n          binSumIntString = Array(0)\n          binSumString\
    \ = binary.map((x: Int) => x.toString).mkString\n          binary = binary.map((x:\
    \ Int) => x.toString).mkString\n          binSumInt = binSumInt.zip(binary.map(x\
    \ => x.toString.toInt)).map(x=> (x(0).toInt + x(1).toInt))\n          binSumIntString\
    \ = binSumInt.map(x=> x.toString).mkString\n          binSumString = \"0\" * (8\
    \ - binSumString.length) + binSumString\n      }\n\n      // Output\n      var\
    \ output: String = if (binary.length == 8) {\n          binSumString\n      }\
    \ else if (binary.length == 7) {\n          binSumIntString\n      }\n\n     \
    \ return output", "        var sum = 0\n        while(N !=0){\n            sum\
    \ = sum + (N % 2l).toInt\n            N = N/2l\n        }\n        if (sum < 10){\n\
    \            return sum.toString()\n        } else {\n            val binary =\
    \ sum.toString\n            val len = binary.length\n            for (i <- 0 until\
    \ len - 1){\n                val bit = binary.charAt(i).toInt\n              \
    \  val bitNext = binary.charAt(i + 1).toInt\n                val bitPrevious =\
    \ binary.charAt(len - i - 1).toInt\n                val bitLast = binary.charAt(len\
    \ - i).toInt\n                val bitNextPrevious = binary.charAt(len - i - 2).toInt\n\
    \                val result = if (bit == 1) if (bitPrevious == 0 && bitNext ==\
    \ 0 && bitLast == 0) 1 else if (bitPrevious == 1 && bitNext == 0 && bitLast ==\
    \ 0) 2 else 0\n                if (result == 0) return binary.substring(0, i)\n\
    \                else if (result == 1) return binary.substring(0, i + 1) ++ \"\
    1\"\n                else return binary.substring(0, i + 1)\n            }\n \
    \       }", "        // initialize binary number\n        var result = \"\"\n\
    \        // convert number to a String\n        val sN = N.toBinaryString()\n\
    \        // reverse the string\n        val rS = sN.reverse\n        // calculate\
    \ each digit sum\n        for (i <- 1 to sN.size){\n            result += (if\
    \ (rS.charAt(i) == \"1\") \"1\" + \"0\"\n            else rS.charAt(i) + \"0\"\
    )\n        }\n        result", "        val n = N.toInt\n        val binary =\
    \ \"\"\n        var sum : Long = 0\n        var i = 2\n        while (i < n) {\n\
    \            sum += i.toLong rem\n            binary = binary + i.toString + \"\
    \ \"\n            i += 2\n        }\n        // print binary number\n        binary\
    \ += sum\n        binary", "        // Code here\n        val x = N.divide(Math.pow(10,10))\n\
    \        var nStr = \"\"\n        for (i <- 1 to Math.pow(10,x)) {\n         \
    \   nStr += (if (N.mod(i) == 0) \"0\" else \"1\")\n        }\n        val result\
    \ = nStr.substring(0, nStr.length-1)\n        return result;", "        val s\
    \ = if (N < 10000) N.toBinary(10) else N.toBinary(20).toList.reverse.takeWhile(x\
    \ => x <= N).reverse\n        val res = if (s.length < 10) s.reverse else s.take(10).reverse.toString.concat(s\"\
    0$s\").substring(0,10)\n        val sum = res.foldLeft(0L)((a, b) => b + a).asInstanceOf[Long]\n\
    \        val str = if (sum < 10) sum.toBinary(10) else sum.toBinary(20).take(10).reverse.toString.concat(s\"\
    0$sum\").substring(0,10)\n        str(0)", "        val x = math.max(N, 0)\n \
    \       val y = math.floor(x / 10)\n        val z = (x - y * 10).toInt // z is\
    \ in [0, 9]\n        val s = Array.ofDim[String](z + 1)\n        s(0) = \"1\"\n\
    \        var i = z\n        while (i > 0) {\n            s(z) = (s(z - 1) + s(z\
    \ - 1)).substring(z - 1) + s(z)\n            i -= 1\n        }\n        s.reverse.mkString",
  "        val l = scala.math.Pow(2, math.ceil(math.log(N,2))).ceil\n        val sum\
    \ = List.fill(l/2)(0).reduce(_ + _)\n        (N % 2l).map(_ / 2l).map(i => i%2).map(s\
    \ => (sum - s).toChar).mkString(\"\")", "        val result = N.map(digit => digit\
    \ %2 != 0 ? \"1\" : \"0\").mkString\n        (0 until N).map(i => s\"${i}:${result(i)}\"\
    ).mkString(\" \")", "        if( N < 0 )\n            return N.toString\n    \
    \    if( N == 0 )\n            return \"0\"\n        if( N == 1)\n           \
    \ return \"1\"\n        val m = N % 100\n        val n = N / 100\n        val\
    \ result = solve( m ) + solve( n )\n        if( (m >= 1 && m <= 9) && (n >= 1\
    \ && n <= 9) )\n            result + result\n        else if( m >= 1 && m <= 9\
    \ )\n            result + result + m\n        else\n            result + result\
    \ + m.toString() + n.toString()", "        val N = N.toInt\n        val list =\
    \ mutable.ListBuffer[String]()\n        def sum(N : Long) : Long = {\n       \
    \     val list = mutable.ListBuffer[Long]()\n            for(i <- 0 until N) {\n\
    \                list.++= (math.pow(2, i)).toLong\n            }\n           \
    \ list.sum\n        }\n        while(N <= 10000) {\n            list.++= binary(N).reverse\n\
    \            N += sum(N)\n        }\n        list.toList.reverse.mkString(\"|\"\
    )", "        if (N >= 0 && N < 10000) {\n            var sum = 0\n           \
    \ var remain = N\n            var digit = 0\n            var binary = \"\"\n \
    \           var remainder = N\n\n            while(remainder > 0) {\n        \
    \        digit = remainder % 2\n                sum = sum + digit\n          \
    \      remainder = (remainder - digit) / 2\n            }\n            binary\
    \ = (0 until sum).toString\n            if (sum > 0) {\n                binary\
    \ = binary + sum.toString\n            }\n            return binary\n        }\n\
    \        throw new IllegalArgumentException(\"Invalid N: \" + N)", "        //\
    \ initialize binary number counter\n        var count = 0\n        // compute\
    \ binary number\n        var num = N.toBinaryString\n        // iterate through\
    \ binary string\n        for (i <- 1 to num.length)\n            // if number\
    \ less than 10\n            if (num.charAt(i) > '9')\n                // decrease\
    \ count by one\n                count -= 1\n            // if number greater than\
    \ 9\n            else if (num.charAt(i) >= '0')\n                // increase count\
    \ by one\n                count += 1\n            // else\n            else {\n\
    \                // if count is zero\n                if (count == 0)\n      \
    \              // return string\n                    return num\n            \
    \    // if count is greater than zero\n                else if (count > 0)\n \
    \                   // decrease count by one\n                    count -= 1\n\
    \                // else\n            }\n        // return \"0\"\n        return\
    \ \"0\"", "        var i = 0\n        var sum = 0\n        var temp = 0\n    \
    \    var str = N.toString\n        val res = new mutable.StringBuilder()\n   \
    \     for (i <- 0 until str.length){\n            temp = str.charAt(i).toInt\n\
    \            sum = sum + temp\n            if (sum == 2){\n                res.insert(i,\
    \ \"1\")\n                sum = temp\n            }\n            else if (sum\
    \ != 0){\n                res.insert(i, \"0\")\n                sum = 0\n    \
    \        }\n        }\n        res.toString", "        val a = scala.math.pow(2,\
    \ N);\n        val b = N.toInt;\n        var result = 0\n        var bin = \"\
    0\";\n        while (a > 0) {\n            val next = a%2;\n            result\
    \ += next*(b-1);\n            a = a/2;\n            bin = next.toString+bin;\n\
    \        }\n        result.toString+bin;", "        val s = math.pow(2, math.ceil(math.log(N)/math.log(2))).toInt\n\
    \        val sumOfDigits = N.asString.reverse.map(_.toInt).sum\n        val binary\
    \ = Array.fill(s.length)(\"0\")\n        binary.zip(s\"${sumOfDigits}\").foreach\
    \ {\n            case (index, value) => binary(index) = value.toChar\n       \
    \ }\n        binary.reverse.toString.reverse", "        // Variables:\n      \
    \  // @A array of strings representing binary numbers in their decimal form.\n\
    \        // @D the sum of digits in binary of the number represented by @A\n \
    \       // @T the binary number represented by @A\n        // @result the string\
    \ returned from solving the problem\n        // Constraint 1:\n        // @N \u2264\
    \ 10000\n        // Constraint 2:\n        // No duplicate entries exist in @A\
    \ (i.e., no entries of binary number @A[i] appear twice in @A).\n        val A\
    \ = Array.fill(10000)(\"\")\n        var D : Long = 0\n        var T : String\
    \ = \"\"\n        if (N >= 10000l){\n            val nums = BigInt(N).toArray\n\
    \            for(i <- 0 until nums.length){\n                A(i) = if(nums(i)\
    \ < 10) \"0\"+nums(i) else \"1\"+nums(i)\n            }\n            D = nums.sum\n\
    \            T =  A(0)\n            for(i <- 0 until A.length-1){\n          \
    \      T +=  A(i)\n                T = T.reverse\n            }\n        }\n \
    \       else return \"Invalid Input\"\n        // Constraint 3:\n        // @T\
    \ \u2264 10000\n        // Constraint 4:\n        // No duplicate entries exist\
    \ in @A (i.e., no entries of binary number @A[i] appear twice in @A).\n      \
    \  val result = (T.reverse.reverse)\n        if(result.length < 21) return \"\
    Invalid Input\"\n        return result", "        var sum = 0\n        var result:\
    \ String = \"\"\n        val NInt: Int = N.toInt\n        if(NInt > 0) {\n   \
    \         result = NInt % 2\n            N = NInt / 2\n        }\n\n        while(N\
    \ /= 2) {\n            sum += 1\n            N /= 2\n        }\n        while(sum\
    \ > 0) {\n            result += if (sum % 2 == 0) \"0\" else \"1\"\n         \
    \   sum /= 2\n        }\n        result", "        var sum: Int = N.toInt\n  \
    \      var ans = \"\"\n\n        if (N < 0) \n            ans = \"-\" + solve(-N).toString\n\
    \        else if (N == 0) \n            ans = \"0\"\n        else {\n        \
    \    var count = 1\n            var remaining = N\n            while (true) {\n\
    \                if (remaining < 1) {\n                    ans = ans + \"0\"\n\
    \                    break\n                }\n\n                var digit = remaining\
    \ % 2\n                var remaining = remaining / 2\n\n                if (digit\
    \ != 0) {\n                    ans = ans + \"1\" + digit\n                   \
    \ count += 1\n                }\n            }\n        }\n        ans = ans +\
    \ \".\" + sum.toString\n        ans", "        if(N < 0)\n            throw \"\
    N must be positive\"\n        val str = N.toBinaryString\n        val a = str.indexOf(\"\
    1\")\n        val b = str.lastIndexOf(\"1\")\n        val str = str.substring(a+1,\
    \ b)\n        return str", "        val binary = List(0 until N).map(i => (i /\
    \ 10).map(j=> ('0' + j)).map(String.fromCharCode).mkString).flatten.toList\n \
    \       binary.foldLeft(\"\")((acc, binary) => {\n        acc + (binary.length\
    \ * binary)\n    })", "        val nums = N.asString.toList.map(x => x % 2).toList\n\
    \        val res = []\n        while(nums.nonEmpty) {\n            res.push(nums.head.toBinaryString)\n\
    \            nums = nums.tail\n        }\n        (res reverse).takeWhile(_ ==\
    \ 0).reverse.toString", "        // 1- Calculate the power of 2\n        val power\
    \ = math.pow(2,math.ceil(math.log(N,2)).toInt)\n        // 2- Start with an empty\
    \ string \"result\"\n        var result: String = \"\"\n        // 3- Keep dividing\
    \ N by each power of 2 until N is 1, then add it to the result string.\n     \
    \   for(i <- 0 to power-1) {\n            val N2 = N / math.pow(2,i)\n       \
    \     result += N2.toString.reverse.takeWhile(_ != '0').reverse\n        }\n \
    \       result", "        var sum = 0L\n        var digits = \"\"\n        var\
    \ carry = 0\n        while (N > 0) {\n            sum += N % 10\n            digits\
    \ += N % 2\n            N /= 2\n        }\n        for (i = digits.length - 1;\
    \ i >= 0; i--) {\n            val temp = digits(i) * carry\n            carry\
    \ = (temp / 10).toLong\n            digits(i) = temp % 10\n        }\n       \
    \ return digits(0) + carry + sum.toString", "      val totalDigits = N.toString.reverse.length\n\
    \      val powers = mutable.Stack[Int]()\n      val numbers = mutable.Stack[String]()\n\
    \      val output = new StringBuilder(totalDigits)\n\n      // Add binary digits\
    \ left to right\n      N.toString take totalDigits foreach {\n        digit =>\
    \ powers push (digit.toInt)\n      }\n\n      // Add digits from powers and numbers\
    \ in order\n      powers.reverse.foreach { power => {\n        numbers.push (N.toString.reverse\
    \ take power mkString \"\")\n        powers pop\n      }}\n      numbers.push(N.toString)\n\
    \n      // Pad output with 0s if necessary\n      val len = numbers.size - 1\n\
    \      if (len < totalDigits) {\n        for (i <- 0 until totalDigits - len)\
    \ output += zero\n      }\n\n      numbers.reverse.foreach {number => output +=\
    \ number}\n\n      // Add leading zeros if necessary\n      val totalZeros = totalDigits\
    \ - output.length\n      if (totalZeros > 0) output += repeat(totalZeros, zero)\n\
    \n      output.toString", "        if (N < 0 || N > 10000) throw new IllegalArgumentException(\"\
    N is out of range: \" + N);\n        val result = mutable.Buffer.empty[String]\n\
    \        val factorsN = new mutable.Buffer[Int]\n        for {\n            x\
    \ <- 1 to N.toInt\n            divisor = N - x\n            if divisor < 0 then\
    \ throw new IllegalArgumentException(\"N is not a power of 2\");\n           \
    \ factorsN += divisor\n        } yield {\n            if (divisor*divisor == N)\
    \ result += x + (divisor*(x % divisor == 0 ? \"\" : divisor + \"\"))\n       \
    \     else result += x + (divisor*(x % divisor))\n        }\n\n        factorsN.foreach\
    \ { x => result += s\"${x % 2 == 0 ? \"1\" : \"0\"}\"}\n        val result = result.toString.replaceAll(\"\
    \\\\s\", \"\")\n        result", "      val num = convert(N)\n      val bits =\
    \ num.length\n      val result = mutable.ListBuffer.empty[String]\n      var sum\
    \ = 0\n      var i = 0\n      while (i < bits) {\n        sum += num(i).toInt\
    \ * (2 ^ (i-1)).asInstanceOf[Int]\n        result += num(i).toInt.toString(2).padToWidth(bits,\
    \ '0')\n        i += 1\n      }\n      result.toString", "        // O(1) time\
    \ complexity to solve this problem\n        val binary = for (i <- 0 to Math.log10(N).toInt)\
    \ yield {\n            (N / Math.pow(10, i) % 2).asInstanceOf[Int]\n        }\n\
    \        val count = binary.toList.distinct\n        // O(n) time complexity to\
    \ solve this problem\n        val output = for (i <- 0 to N - 1) yield {\n   \
    \         (binary(i) + binary(i+1)).asInstanceOf[String]\n        }.toList.mkString\n\
    \        output + count.mkString(\"\")", "        var ans = \"\"\n        var\
    \ i = 0\n        var j = 0\n        val len = N.toInt\n        while (i < len)\
    \ {\n            var x = N % 2\n            N = N / 2\n            while (N !=\
    \ 0) {\n                ans = ans + x.toString()\n                N = N / 2\n\
    \                x = x * 2\n            }\n            i = i + 1\n        }\n\
    \        if (ans.isEmpty) ans = \"0\"\n        ans = ans.reverse\n        return\
    \ ans", "        // We start by setting our running sum\n        var runningSum\
    \ = 0\n        // We also set our initial total sum\n        var totalSum = 0\n\
    \        // We want to keep track of how many bits we've added in our sum\n  \
    \      var bitsInSum = 0\n        // Keep track of how many times a number has\
    \ occurred\n        var numOfBits = 0\n        // Keep a copy of the last digit\
    \ as we will only add it to this sum once \n        var lastDigit = 0\n      \
    \  // We want to keep track of the number of digits we've added to our running\
    \ sum\n        var totalDigits = 0\n\n        for(i <- 0 until N.toInt) {\n  \
    \          val d = N % 2l\n            val sumOfDigits = d * 2l\n\n          \
    \  runningSum = runningSum + sumOfDigits\n            numOfBits += d\n       \
    \     lastDigit = sumOfDigits % 2l\n            bitsInSum += d\n            totalDigits\
    \ += 1\n            // We want to make sure we have enough space\n           \
    \ if((runningSum + sumOfDigits + lastDigit).toInt > 10000) {\n               \
    \ totalSum = runningSum\n                runningSum = 0\n                bitsInSum\
    \ = lastDigit\n                numOfBits = d\n                lastDigit = 0\n\
    \                totalDigits = 1 \n            }\n        }\n        val str =\
    \ if(totalDigits < 2) {\n            if(totalDigits == 1) \"0\" else \"\"\n  \
    \      } else {\n            val res = if(totalDigits == 1) {\n              \
    \  val result = runningSum.toString.reverse\n                if(result.last ==\
    \ \"1\") result.reverse\n                else result + \"0\"\n            } else\
    \ if(numOfBits == 1) {\n                val result = runningSum.toString.reverse\n\
    \                val lastBit = lastDigit.toString\n                if(result.last\
    \ == lastBit || result.last == lastBit + \"0\") result.reverse\n             \
    \   else result + lastBit\n            } else {\n                val result =\
    \ runningSum.toString.reverse\n                val lastBit = lastDigit.toString\
    \ + lastDigit.toString\n                if(result.last == lastBit || result.last\
    \ == lastBit + \"0\") result.reverse\n                else result + lastBit\n\
    \            }\n            if(totalDigits == 2) res.reverse\n            else\
    \ res\n        }\n        if(numOfBits == 1) {\n            val result = runningSum.toString.reverse\n\
    \            if(result.last == lastDigit.toString) result.reverse\n          \
    \  else result + lastDigit.toString\n        } else result", "        val s =\
    \ mutable.ArrayBuffer.empty[String]\n        for (i <- 0 to (N / 2)) {\n     \
    \       val b = N % 2\n            s += \"1\" + b\n            N -= b\n      \
    \  }\n        if (N > 0) {\n            s += \"0\"\n        }\n        s.mkString",
  "        val numbers = Vector.fill(N.toInt)(0l).mkString(\"0\") // Vector<String>\n\
    \        val sum = (N.toLong rem 2).toString // String (\"110000\")\n        val\
    \ left = N.toLong / 2 // Long (452)\n        if (left > 0) solve(N - left, left,\
    \ sum, numbers) else sum", "        val binary = N.toBinaryString\n        val\
    \ sum = 0\n        for (i <- binary.reverse.split(' ')) {\n            sum +=\
    \ i.toLong.toBinaryString\n        }\n        sum.toString", "        val N1 =\
    \ N.toInt\n        val m = N1 / (10l) * 2\n        val b = N1 - (m * 10l)\n  \
    \      val s = \"\"\n        val bits = List(m % 2)\n        for (i <- 0 until\
    \ m) {\n            s += if (i < m) \"1\" + \"0\"\n             else bits.map(\"\
    0\" + \"1\").mkString\n            bits = bits drop 1\n        }\n        if (b\
    \ > 0) s += if (b < m) \"1\" + \"0\"\n         else bits.map(\"0\" + \"1\").mkString\n\
    \        s", "        val s = N.toBinaryString()\n        val v = s.tail\n   \
    \     var total = 0\n        for (c <- v.reverse.map(c => c.toInt).toArray.reverse)\
    \ {\n            total += c\n        }\n        v.map(_ % 2L).toArray.mkString(\"\
    \")", "        if (N < 0l) throw new IllegalArgumentException(\"Negative numbers\
    \ are not allowed!\")\n        if (N == 0l) throw new IllegalArgumentException(\"\
    0 is not allowed!\")\n        val digits = N.toString.reverse.grouped(2).toList\n\
    \        val totalSum = digits.map(_.toInt).reduce((a, b) => a + b).div(2).toInt\n\
    \        val result = digits.map(_.toString).reduce((a, b) => a + b).div(2).toInt\n\
    \        val totalSumString = totalSum.toString.reverse.grouped(2).toList\n  \
    \      val resultString = result.toString.reverse.grouped(2).toList\n        val\
    \ resultStringWithZero = resultString.zipWithIndex.map(s => if (s._2 == 0) s.head\
    \ else s.head + s.head.toChar).mkString(\"\")\n        val resultStringWithOne\
    \ = resultString.zipWithIndex.map(s => if (s._2 == 0) s.head else s.head.head\
    \ + s.head.head.toChar).mkString(\"\")\n        resultStringWithZero +\n     \
    \       resultStringWithOne +\n            totalSumString.reverse.mkString", " \
    \       def binaryToInt(n: String): Int = {\n            var ret = 0\n       \
    \     for(i <- 0 until n.length) ret += n.charAt(i) - '0'\n            ret\n \
    \       }\n        def printBinary(n: Int) = {\n            for(i <- 0 until 32)\
    \ print(n%2==0 ? \"1\" : \"0\")\n        }\n\n        val digits = math.pow(2,\
    \ N)\n        val binary = digits.length.toString.reverse.foldLeft(\"\")((acc,n)\
    \ => acc + binaryToInt(n.toString.reverse))\n\n        val ans = binaryToInt(binary)\n\
    \        val ret = (ans * digits).asInstanceOf[String]\n        printBinary(ans)\n\
    \        return ret", "        val s = N.toString\n        if (s.charAt(0) ==\
    \ '0') \"0\"\n        else s.substring(1)", "        val digits = ArrayBuffer(\"\
    \", \"\") + ArrayBuffer(\"\", \"\")\n        var currentSum = 0\n        var currentDigit\
    \ = 0\n        var currentSumStr = \"\"\n        var currentDigitStr = \"\"\n\
    \        while(true){\n            // Get the next digit to sum\n            currentDigit\
    \ = N % 2\n            // Append the digit to the digit string in base-10\n  \
    \          digits += currentDigitStr\n            currentDigitStr = \"0\" + currentDigitStr\n\
    \            N /= 2\n            // Sum up the digit and prepend the sum to the\
    \ sum string\n            currentSum += currentDigit\n            currentSumStr\
    \ += currentSumStr + currentDigit\n            \n            if(N == 0)\n    \
    \            break\n        }\n        // Remove the leading zero\n        digits\
    \ -= currentSumStr.dropWhile(_ != '0')\n        // Convert the digits into a string\n\
    \        digits.reverse.mkString(\"\")", "        var sum = 0\n        var cur\
    \ = 0\n        var prev = 0\n        var n = 0\n        for (i<- N.toString.toList)\
    \ {\n            if (i == \"0\") {\n                sum += cur\n             \
    \   cur = 0\n                prev = 1\n            } else {\n                cur\
    \ = (cur * 2) + i.toLong\n                sum += prev\n                prev =\
    \ cur\n            }\n        }\n        sum", "        val binary = getBinary(N.toInt)\n\
    \        if (binary.length < 2) {\n            \"\"\n        } else {\n      \
    \      binary + solve(binary.dropRight(binary.length - 1))\n        }", "    \
    \    val xs = 0.to(N.toInt).filter(_ != 0).map(x => (Math.pow(2,x) % N).toInt)\n\
    \        val xx = xs.toSeq.sortBy(_._1)\n        val xy = xx.map(_._2).sum\n \
    \       (xy.toString(2) + xs.last.toString(2))", "        val arr = new Array[Long](N.bitLength)\n\
    \        val total = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array[Long](N.bitLength)\n        val arr = new Array[Long](N.bitLength)\n\
    \        val arr = new Array", "        def digitSum(n: Long): Int = { // O(1)\n\
    \            var sum = 0\n            while(n > 0) {\n                sum = sum\
    \ + n % 2\n                n /= 2\n            }\n            sum\n        }\n\
    \        // O(log(N))\n        def logSum(base: Int, i: Int): Int = {\n      \
    \      var sum = 0\n            while(i >= 0) {\n                sum = sum + digitSum(i\
    \ * base)\n                i -= 1\n            }\n            sum\n        }\n\
    \        // O(log(N))\n        def bitSum(base: Int, i: Int): Int = {\n      \
    \      var sum = 0\n            while(i >= 0) {\n                sum = sum + digitSum(i\
    \ * base)\n                i -= 1\n            }\n            sum\n        }\n\
    \        // O(log(N))\n        def logSums(base: Int, n: Int): Int = {\n     \
    \       var sum = 0\n            while(n > 0) {\n                sum = sum + logSum(base,\
    \ n)\n                n -= 1\n            }\n            sum\n        }\n    \
    \    // O(N)\n        def sumDigits(n: Long): Int = { // O(N)\n            var\
    \ sum = 0\n            while(n > 0) {\n                sum = sum + digitSum(n)\n\
    \                n -= 1\n            }\n            sum\n        }\n        val\
    \ bits = (1l).toInt\n        val digits = logSums(2, N).asInstanceOf[Int]\n  \
    \      var result = \"0\"\n        val bitString = bits - 1 + 1\n        val bitsInDigit\
    \ = bitString / digits\n        var bitsInDigitToAdd = bitsInDigit * digits\n\
    \        var bitsInDigitToAddRemainder = 0\n        val digitBits = sumDigits(N)\n\
    \        val digitBitsInDigit = digitBits / digits\n        val digitBitsInDigitToAdd\
    \ = digitBitsInDigit * digits\n        var digitsToAdd = (digitBitsInDigitToAdd\
    \ - digitBitsInDigitToAddRemainder) / bitsInDigit\n        val digitsToAddString\
    \ = digitsToAdd.toString\n        if (digitsToAddString.startsWith(\"1\")) digitsToAddString\
    \ = digitsToAddString.substring(1) // Remove leading 1\n        result += digitsToAddString\n\
    \        val digitsToAddReversed = digitsToAdd.reverse.asInstanceOf[Int]\n   \
    \     val bitsToAdd = (digitsToAddReversed - digitsToAdd) % bitsToAdd\n      \
    \  val bitsToAddString = bitsToAdd.toString\n        if (bitsToAddString.startsWith(\"\
    1\")) bitsToAddString = bitsToAddString.substring(1) // Remove leading 1\n   \
    \     result += bit", "        val digits = BigDecimal(N).toByteArray\n      \
    \  val count = new mutable.HashMap[Char, Int]()\n        digits.foreach(d => {\n\
    \            if(count.contains(d.asInstanceOf[Char])) {\n                count(d.asInstanceOf[Char])\
    \ = count(d.asInstanceOf[Char]) + 1\n            } else {\n                count(d.asInstanceOf[Char])\
    \ = 1\n            }\n        })\n        var result = \"\"\n        val maxCount\
    \ = count.max.toInt\n        for(d <- count.keys) {\n            if(maxCount %\
    \ 2 == 0) {\n                if(count(d) == maxCount) {\n                    result\
    \ += (d + \"0\")\n                } else {\n                    result += (d +\
    \ \"1\")\n                }\n            } else {\n                if(count(d)\
    \ == maxCount) {\n                    result += (d + \"1\")\n                }\
    \ else {\n                    result += (d + \"0\")\n                }\n     \
    \       }\n        }\n        result", "        def helper(i : Int) : String =\
    \ {\n            if(i > 9){\n                if(N % i == 0){\n               \
    \     helper(i + 1)\n                }\n                else{\n              \
    \      helper(i / 10) + i.toString(2)\n                }\n            }\n    \
    \        else N.toString()\n        }\n        helper(0)", "      def solveInternal(n\
    \ : Long, acc : List[String], acc : List[String]) : List[String] = {\n       \
    \ if(n > 9) {\n          solveInternal(n % 10, acc, acc :+ n.toString) :: acc\n\
    \        }\n        else {\n          acc :+ n.toString\n        }\n      }\n\
    \      solveInternal(N, List[String](), List[String]())", "        val bits =\
    \ java.lang.Long.toBinaryString(N)\n        val n = bits.length\n        var s\
    \ = 0L\n        var bit = 0\n        for(i <- 0 to n-1){\n            bit <- bits(i).toInt\n\
    \            s += bit\n        }\n        java.lang.Long.toBinaryString(s).substring(0,\
    \ n)", "        if(N < 0 || N > 10000) throw new IllegalArgumentException(\"N\
    \ must be between 0 and 10000\")\n        var result = \"\"\n        var i = N\
    \ / 10\n        var digit = 0\n        var n = N\n        while(n > 0) {\n   \
    \         if(i % 2 == 0) {\n                digit = digit * 2 + n % 10\n     \
    \       }\n            i = i / 2\n            n = n / 10\n        }\n        if(digit\
    \ > 0) result = result + Integer.toBinaryString(digit)\n        result", "   \
    \     if (N == 0) return \"0\"\n        var num = 1\n        var total = 0\n \
    \       var result = new ListBuffer[String]()\n        while (N > 0) {\n     \
    \       total += (num % 2) * N % 10\n            num /= 2\n            N /= 10\n\
    \        }\n        result.push(\"\" + total)\n        return result.mkString(\"\
    ,\")", "        var res = \"\"\n        var remain = N\n        while (remain\
    \ > 0){\n            res += scala.math.Integer.toBinaryString(remain).reverse\n\
    \            remain = remain.dropRight(1)\n        }\n        res", "        val\
    \ ans = N.toString\n        // For each digit, append \"1\" or \"0\" to ans, if\
    \ the number is > 0.\n        // If an even number of digits, append the result\
    \ of the multiplication of the 2 last digits of the number.\n        ans.map(x\
    \ => if (x != \"0\") { if (x % 2 == 0) { x + \"1\" } else { x + \"0\" } } ).takeWhile(_.nonEmpty).reduceLeft((x,\
    \ y) => if (x.isEmpty) y else (x * y))", "        val nums = N.toIntArray\n  \
    \      val answer = nums.foldLeft(0){ (res, val) =>\n            res = res + val.toString\n\
    \            res\n        }\n        val ans = answer.toString\n        val ans\
    \ = ans.reverse.takeWhile(_ != '0').mkString\n        return ans", "        val\
    \ digits = N.toString.reverse.map(_ => \"1\".toByte)\n        val sum = digits.foldLeft(0L)(_\
    \ + _)\n        return sum.toString(2).reverse", "        var sum = 0\n      \
    \  var res = []\n        var i = 0\n        while(i < N) {\n            sum +=\
    \ i / 2\n            res = res.reverse.dropRight(1).map(x => x + sum % 2).reverse\n\
    \            i /=2\n        }\n        res.mkString(\"1\")", "        var current\
    \ = 0l\n        var sum = 0\n\n        for (x <- 0 until N) {\n            current\
    \ = x * 10 + current\n            sum += current\n        }\n\n        sum.toString",
  "        // Write your code in Scala here\n        var result: String = \"\"\n \
    \       var sumOfDigit = 0\n\n        while(sumOfDigit < N) {\n            sumOfDigit\
    \ += (N % 10)\n            N /= 10\n        }\n        result += (sumOfDigit *\
    \ 2).toString \n        return result", "        val binaryArray = Array.fill(N\
    \ / 2).map((_,\"0\").toString + (_,\"1\").toString).toArray\n        val sumArray\
    \ = binaryArray.map((_, 0l)).filter(_._2 > N / 2).map(_._2).sum\n        val binarySum\
    \ = new String(binaryArray.zip(sumArray).toSeq.sortBy(_._1).map(x => x._2.toString))\n\
    \        binarySum", "        def buildBinary(num: Long, output: String): String\
    \ = {\n            if (num < 0 || num >= 10000) {\n                \"\"\n    \
    \        }\n            else {\n                val oneDigit = num.toString.charAt(0)\n\
    \                val twoDigit = num.toString.charAt(1)\n                buildBinary(num/10,\
    \ output + oneDigit)\n                buildBinary(num%10, output + twoDigit)\n\
    \            }\n        }\n        buildBinary(N, \"0\")", "        // 110 010\
    \ 010 110\n        val s = mutable.Stack[String]()\n        val sum = 0\n    \
    \    // 101 110 100\n        val carry = 0\n        // 101 011 100\n        var\
    \ digit = 0\n\n        for (i <- 0 until N) {\n            digit += i / 2\n  \
    \          i %= 2\n            sum += digit\n            if (sum > 10) {\n   \
    \             s += carry.toString\n                digit = sum % 10\n        \
    \        sum += digit\n                carry = 0\n            } else {\n     \
    \           s += digit.toString\n                carry = 0\n                digit\
    \ = 0\n            }\n        }\n        s match {\n            case Nil => \"\
    \"\n            case x :: Nil => x.reverse\n            case _ => s.reverse\n\
    \        }", "        val result = mutable.StringBuffer(\"0\")\n        def count(x:\
    \ Long) : Int = {\n            if(x == 0) result.append('0') else result.append((x\
    \ % 2).toChar.toString)\n            x /=  2\n        }\n        for(i <- N.toInt)(count(i))\n\
    \        result.toString", "        val maxN = (2l*N).toInt\n        if (N < 0\
    \ || N >= maxN) throw new IllegalArgumentException(\"N is out of range\")\n  \
    \      val binary = (1l << N).toInt\n        val sum = 0\n        while (N > 0)\
    \ {\n            val rem = N % 2\n            sum += rem\n            N = N /\
    \ 2\n        }\n        binary.toString() + sum.toString", "        val s = N.toString\n\
    \        val result = \"\"\n        for (i <- s.indices) {\n            if (s.charAt(i)\
    \ == '1') {\n                result += \"0\"\n            } else {\n         \
    \       result += s.charAt(i)\n            }\n        }\n        return result",
  "        val binary = List(N.toString(2).length).map (_ => \"0\")\n        binary.foreach\
    \ {\n            x => N % 2 == 0\n            x => binary(x) = 1\n           \
    \ x => binary(x+1) = 1\n        }\n        binary.reverse.mkString(\"\")", " \
    \       val n  = N.toInt\n        val arr = mutable.ArrayBuffer.empty[Int]\n \
    \       val sum = 0\n        for (i: Int <- n until (n div 2)) arr ::= i\n   \
    \     if (n <= 1) arr.mkString else solve(n/2) ++ solve((n div 2)) ++ sum.toBinary()\
    \ + solve(n/2)", "        val binary = N.toString.reverse\n        val res = mutable.ListBuffer[String]()\n\
    \        var sum = 0L\n        for (i <- 0 until binary.length) {\n          \
    \  val digit = binary(i)\n            val newSum = sum + digit\n            if\
    \ (newSum > 0 && newSum % 2 == 1) newSum /= 2\n            res.append(newSum)\n\
    \            sum = newSum\n        }\n        return res.mkString(\"\")", "  \
    \      var sum = \"\"\n        var i = 0\n        while (i <N) {\n           \
    \ sum = sum + BigInt(N.toString(2)(i)) + \"\"\n            i = i + 1\n       \
    \ }\n        sum.toString()", "        if( N > 10000 ){\n            return \"\
    \"\n        }\n\n        val bits = N.toString.reverse.groupBy(_ == 0).mapValues(_.length).keys\n\
    \        val bins = bits.map(x => x.toString).filter(_ != \"\")\n\n        bins.sum.toString",
  "        // Initialize a mutable array to store binary numbers\n        var binaryNums\
    \ = mutable.ArrayBuffer(0l)\n\n        // Divide N into two parts: left half is\
    \ N - remainder, and right half is N - remainder / 2\n        var remainder =\
    \ N / 2\n        var left = N - remainder\n\n        // The two parts we divided\
    \ are now stored in left, right\n        // We are going to convert them into\
    \ binary numbers\n        while(left > 0) {\n            // Convert left half\
    \ into binary numbers\n            var binaryLeft = 0\n            while(left\
    \ > 0) {\n                binaryLeft = binaryLeft << 1\n                left -=\
    \ 1\n            }\n            binaryNums = binaryNums + binaryLeft\n       \
    \     // Convert right half into binary numbers\n            var binaryRight =\
    \ 0\n            while(remainder > 0) {\n                binaryRight = binaryRight\
    \ << 1\n                remainder -= 1\n            }\n            binaryNums\
    \ = binaryNums + binaryRight\n        }\n\n        // Convert the binary numbers\
    \ to string\n        var numStr = \"\"\n        for(num <- binaryNums) {\n   \
    \         if(num == 0) {\n                numStr = \"\"\n                break\n\
    \            }\n            else\n                numStr = numStr + \"1\"\n  \
    \      }\n\n        return numStr", "      // Your code goes here\n      val digits\
    \ = N.toInt.toString.reverse.map(_.toBinaryString)\n      val totalSum = digits.foldLeft(0.asInstanceOf[String])\
    \ { (sum, digit) =>\n        sum.toInt + (digit.toInt * Math.pow(2,digits.length\
    \ - 1))\n      }\n      totalSum.toString", "        val d = scala.math.log10(N)\n\
    \        val m = scala.math.pow(10, d)\n        val r = scala.math.pow(10, d)-1\n\
    \        val x = math.ceil(N / m)\n        val y = math.ceil(N / r)\n        val\
    \ z = math.ceil(N / x)\n        if (z == 0) 1 else x + solve(z) + y", "      //\
    \ 1st: create an empty list for storing our result\n      val result: List[Int]\
    \ = N.toString.grouped(2).map {\n        // 2nd: go through every possible combination\n\
    \        _.combinations(2).map (_ map {\n          // 3rd: split the binary number\
    \ into its digits\n          _.toString.toInt\n        }).sum\n      }\n     \
    \ // 4th: convert the list of numbers to binary string\n      result.toString.reverse.map(x\
    \ => (x % 2).toString).toString.reverse", "        val l = N.toInt\n        val\
    \ s = \"\"\n        var t = 0\n        for(i <- 0 until l) {\n            if(l(i)\
    \ == 1)\n                s = s + \"1\"\n            else {\n                t\
    \ = t + l(i).toInt\n                s = s + \"0\"\n            }\n        }\n\
    \        if(t == 1) \"1\" + s else \"0\" + s", "        var sum = 0\n        var\
    \ result = \"\"\n        val len = N.toString.length()\n\n        for(_ <- 0 to\
    \ len){\n            val i = N / 2l\n            sum = sum + i\n            N\
    \ = N - i\n        }\n\n        val result = sum.toString(2)\n        while(result.length\
    \ < len){\n            result = (\"0\") + result\n        }\n\n        result",
  "        if (N <= 0) throw new Exception(\"Incorrect input.\")\n        val temp\
    \ = N.toInt\n        // We know that N is positive, so that means temp > 0\n \
    \       // From here, we know that temp < 2^(10^N)\n        // We assume that\
    \ N is already given, so we will ignore it\n        // Now we know that N <= 10^N,\
    \ so we can assume that N > 0, so we should now check that N > 0.\n        //\
    \ We know that temp >= 0\n        if (temp < 0) throw new Exception(\"Incorrect\
    \ input.\")\n        // We know that N < 10^N, because temp >= 0\n        // We\
    \ know that temp < 2^(10^N), because N is positive\n        // We know that N\
    \ >= 10^N, so we can assume that N > 0\n        // We know that temp < 10^N, because\
    \ temp >= 0\n        // We know that temp >= 2^(10^N), because N is positive\n\
    \        // Now we know the answer, so we can return it\n        val bin = N.toBinaryString\n\
    \        bin", "        var sum : Long = 0\n        var currentBinary : String\
    \ = \"\"\n        for( i <- N.toInt) sum += i\n        while(sum >0 ) {\n    \
    \        val tmp = sum.toBinaryString\n            if( tmp.length < 2) {\n   \
    \             currentBinary += tmp.charAt(0)\n            }else {\n          \
    \      currentBinary += tmp.charAt(1)\n            }\n            sum -= tmp.charAt(0)\n\
    \        }\n        return currentBinary", "        val digits = N.toString.map(_.toInt)\n\
    \        val n = digits.length\n\n        if (n == 0) {\n            \"0\"\n \
    \       } else if (n == 1) {\n            digits.head.toString\n        } else\
    \ {\n            val base = 2\n            var sum : Long = 0\n            var\
    \ j : Int = 0\n\n            while (j < n) {\n                sum += digits(j)\
    \ * base\n                j += 1\n                base /= 2\n            }\n \
    \           sum.toString\n        }", "        var n = (N.toInt.pow(2)).toString.length\n\
    \        var sum = 0\n        var i = N.toInt.toInt\n        var binary = \"\"\
    \n        while (i>0) {\n            if (i % 2 == 0) {\n                binary\
    \ += \"1\"\n                sum+=i\n                i /= 2\n            } else\
    \ {\n                binary += \"0\"\n                sum-=i\n               \
    \ i /= 2\n            }\n        }\n        if (sum>0) {\n            var res\
    \ = binary.reverse\n            for (i <- 0 until res) {\n                res\
    \ = res.replaceAt(res(i),\"1\")\n            }\n            return res.reverse\n\
    \        } else {\n            return \"0\"\n        }", "        val binary =\
    \ Binary.fromInt(N).toArray\n        val digits = (N.toInt >>> 0).toInt\n    \
    \    var sum = 0\n        var remainder = 0\n        for (digit <- binary) {\n\
    \            sum += digit\n            remainder = sum\n            sum -= digit\n\
    \            sum = sum.toInt\n        }\n        val result = remainder + BinaryDigit(sum)\n\
    \        result.toString.reverse", "        if (N > 1000000L) throw new java.lang.RuntimeException(\"\
    Too big\")\n        var ans : List[Char] = N.toInt().toString()\n        var acc\
    \ : Long = 0\n        var sum : Long = 0\n        ans.reverse.foreach(ch => {\n\
    \            sum += (ch - 48) * Math.pow(2,ans.size - 1)\n            acc = acc\
    \ + sum\n        })\n        val result = acc.toString.reverse\n        ans =\
    \ result.take(ans.size).toList\n        ans.mkString(\"\") + result.drop(ans.size-1)",
  "        val totalDigits = N.toString.length\n        val binary = N.toString.reverse.grouped(2).map(x\
    \ => x.mkString(\"\"))\n        val str = binary map { x => x.mkString(\"\") }\n\
    \        val result = if (totalDigits == str.length) str\n        else str map\
    \ (x => x.padTo(totalDigits, '0'))\n        val returnValue = result map { x =>\
    \ x.mkString(\"\") } mkString (\"\") reverse\n        returnValue", "      val\
    \ bits = N.toBitString\n      var curSum = 0l\n      var ret = \"\"\n      var\
    \ lastBitIndex = 0\n      var lastDigit = 0\n      while((lastBitIndex = bits.indexOf(1,\
    \ lastBitIndex + 1)) != -1) {\n        curSum += lastDigit\n        ret += (lastDigit\
    \ + bits(lastBitIndex - 1) + bits(lastBitIndex))\n        lastBitIndex = lastBitIndex\
    \ + 1\n        lastDigit = lastDigit + 1\n      }\n      ret += bits.dropRight(1)\n\
    \      ret", "        var sum = 0\n        var count = 0\n        var binary =\
    \ \"\"\n        while (N /= 10)\n            sum = (sum + (N % 10)) % 10\n   \
    \         N = N / 10\n        binary = binary + new String(new Array[Char]((count\
    \ + 7) * 3), \"0\")\n        sum = sum + 7\n        while (sum > 0) {\n      \
    \      binary = binary + new String(new Array[Char]((sum >> 3) * 3), \"0\")\n\
    \            sum = sum - 3\n            count = count + 1\n        }\n       \
    \ binary = binary + new String(new Array[Char]((count + 1) * 3), \"0\")\n    \
    \    binary = binary.substring(0, binary.length - 1)\n        binary", "     \
    \   // Initialize an array to hold the binary number\n        var result = Array.fill(8)(0)\n\
    \        // Create a variable and set its value to N\n        var currentNum =\
    \ N\n\n        // Start while loop\n        while(currentNum != 0){\n        \
    \    // Get the last 5 digits of currentNum and add them to the result array\n\
    \            val lastFive = Math.ceil(currentNum % 10000000) / 10000000 % 1000\n\
    \            val firstFive = Math.floor(currentNum % 10000000 / 1000) % 1000\n\
    \            result(0) + lastFive + firstFive.toString.toChar\n            //\
    \ Divide currentNum by 10\n            currentNum = currentNum / 10\n        }\n\
    \        // Return a string of result\n        result.mkString(\"\")", "     \
    \   val b  = N.toString(2)\n        var ans = \"\"\n        for (i <- 0 until\
    \ b.length) {\n            val tmp = b.charAt(i) + ans\n            if (tmp.length\
    \ > 4) {\n                ans = tmp\n            } else {\n                ans\
    \ += tmp\n            }\n        }\n        ans", "        var nStr = \"\"\n \
    \       var n = N.toInt\n        while (n>0) {\n            n %= 2\n         \
    \   nStr += \"1\"\n            n = n / 2\n        }\n        if (nStr.length >\
    \ 1)\n            nStr = \"1\" + nStr\n        return nStr", "        var binary\
    \ = \"\"\n        var sum = 0\n        var temp : Long = N\n        while(temp\
    \ > 0) {\n            sum = (sum + (temp mod 2)).toInt\n            temp = temp\
    \ / 2\n        }\n        binary = Integer.toString(sum)\n        return binary",
  "        // @N is between 1 and 10000\n        if (N < 0 || N > 10000) {\n     \
    \       throw new IllegalArgumentException\n        }\n        // @N is odd, so\
    \ it's possible to get the binary digits of N\n        else if (N % 2 == 1) {\n\
    \            var lastDigit = 0\n            var result = \"0\"\n            var\
    \ i = 2\n            while (i <= N) {\n                lastDigit = lastDigit +\
    \ i // get last digit of i\n                i = 2 * i\n            }\n       \
    \     result = lastDigit // get the last digit of N\n            return result\n\
    \        }\n        // @N is even, so the binary digits of N can be calculated\
    \ directly\n        else {\n            var result = \"\"\n            var i =\
    \ 2\n            while (i <= N) {\n                result = result + i.toString(2)\n\
    \                i = 2 * i\n            }\n            result\n        }", " \
    \       val sum = N.toString.toInt\n        val result = sum.toString\n      \
    \  val res = sum.toCharArray\n        var j = 0\n        var resultString = \"\
    \"\n        while (j < res.length) {\n            resultString += (if (res(j)\
    \ == 1) \"1\" else \"0\") + resultString(j)\n            j += 2\n        }\n \
    \       return resultString", "        val Nbin = N.toBinaryString\n        //\
    \ Find the position of first and last 1 in the binary string.\n        val first1index\
    \ = Nbin.indexOf(\"1\")\n        val last1index = Nbin.lastIndexOf(\"1\")\n  \
    \      // Calculate the sum in binary from right to left.\n        var result\
    \ = \"\"\n        for (i <- Nbin.length -1 downTo 0 ) {\n            result +=\
    \ Nbin(i)\n        }\n        // Return the result string with a leading 1.\n\
    \        result = \"1\" + result\n        \n        // Handle the special case\n\
    \        if (first1index == last1index) {\n            // Return the string with\
    \ leading 1.\n            result = \"1\" + result\n        }\n        \n     \
    \   // return the result string\n        result", "        val res = new mutable.Stack[Long]()\n\
    \        val a = scala.math.abs(N).toInt\n        while(a > 0) {\n           \
    \ if(a % 2 == 0) {\n                if(a.toString.length == 1) {\n           \
    \         res.append(0)\n                }\n                else {\n         \
    \           res.append(a.toString.charAt(0))\n                }\n            }\n\
    \            else {\n                res.append((a%2).toString.charAt(0))\n  \
    \              a /= 2\n            }\n        }\n        res.reverse.mkString",
  "        // Find the binary representation of the number in binary\n        val\
    \ bin = N.toBinaryString\n        // Find the number of 0's in binary representation\n\
    \        val zeros = bin.indexOf(\"0\")\n        // Find the number of 1's in\
    \ binary representation\n        val ones = bin.indexOf(\"1\")\n        // Create\
    \ a list for the answer where each element is the total of its\n        // digits\
    \ in binary representation\n        var ans = List[Int]()\n        // Iterate\
    \ through the digits in the binary representation of the number\n        for(i\
    \ <- 0 to bin.length-1) ans = ans :+ (bin(i).toInt * (2^i))\n        // Add the\
    \ number of 0's in the number\n        ans = ans :+ zeros + 1\n        // Add\
    \ the number of 1's in the number\n        ans = ans :+ ones\n        // Return\
    \ a string of all the digits in binary number in reverse order\n        ans.toList.map(x=>Integer.toString(x)).mkString",
  "        val numString = N.toBinaryString\n        var currentNum = 0\n        var\
    \ sum = 0\n        var output = new StringBuilder\n        while(true){\n    \
    \        if(numString.length == 0){\n                output.append(\" \")\n  \
    \              output.append(sum)\n                return output.toString()\n\
    \            }\n            val currentDigit = numString.charAt(0)\n         \
    \   currentNum = currentNum*2 + currentDigit.toLong\n            numString = numString.substring(1).toString.toBinaryString\n\
    \            if(currentNum > N.toLong){\n                currentNum = 0\n    \
    \            sum = sum + currentNum\n            } else {\n                sum\
    \ = sum + currentNum\n            }\n        }", "        var num = (N / 1000000000l).floor\n\
    \        var sum = 0\n        while (sum < num) {\n            sum = (sum * 2)\
    \ + num % 2\n            num = num >> 1\n        }\n        val answer = sum.toString\
    \ + num.toString\n        return answer", "        var sum = 0\n        for(i\
    \ <- N to 1) {\n            sum += i.toBinaryString\n        }\n        sum.toString",
  "        val s = List(\"0000\")\n        while(N !=0){\n            s.insert(0,((\"\
    1\" * N.toInt)).length)\n            N=N.toInt - ((\"1\" * N.toInt)).length\n\
    \        }\n        s.reverse", "        // write your code here\n        var\
    \ sum = 0L\n        var tmp = \"\"\n        while (N > 0) {\n            tmp =\
    \ N.toString.reverse\n            sum = sum + tmp.charAt(0)\n            N = N\
    \ / 2\n        }\n        tmp = sum.toString\n        tmp = \"1\" + tmp\n    \
    \    tmp = tmp.reverse\n        tmp = tmp.dropWhile(_ < '0').dropWhile(_ > '0')\n\
    \        tmp.toString", "        val binarySum = N.toString.reverse.foldRight(List[String]())\
    \ {\n            case (\"1\", x) => (x :: N.toString)\n            case (\"0\"\
    , x) => (x :: N.toString.reverse)\n            case (x, y) =>\n              \
    \  val (left, right) = y.split(\"\\\\\" + x)\n                left.head :: (x\
    \ + right.last)\n        }\n        val binarySums = binarySum.foldRight(List[String]())\
    \ {\n            case (\"\", x) => (x :: N.toString.reverse)\n            case\
    \ (x, y) =>\n                val (left, right) = y.split(\"\\\\\" + x)\n     \
    \           left.head :: (x + right)\n        }\n        val binarySumsLength\
    \ = binarySums.last.indexOf(\"1\")\n        binarySums.last.substring(0, binarySumsLength)\
    \ + binarySums.last.substring(binarySumsLength)", "        if (N < 0) \"-1\"\n\
    \        else {\n            var ans = \"\"\n            var sum : Int = 0\n \
    \           var cnt : Int = 0\n            var prev : Int = 0\n            while\
    \ (N >= 10) {\n                sum = sum + N % 10\n                N = N / 10\n\
    \                cnt = cnt + 1\n            }\n            if (cnt == 0)\n   \
    \             ans = ans\n            else if (sum == 0)\n                ans =\
    \ \"0\"\n            else {\n                var flag : Boolean = true\n     \
    \           var temp : Int = 0\n                while (N >= 10) {\n          \
    \          temp = temp + N % 10\n                    N = N / 10\n            \
    \        if (temp == prev)\n                        ans = ans + \"1\"\n      \
    \              else\n                        ans = ans + \"0\"\n             \
    \       prev += 1\n                    flag = flag && cnt == temp\n          \
    \      }\n                if (flag)\n                    ans = ans + \"1\"\n \
    \           }\n            ans\n        }", "        val digits = math.ceil(math.log10(N))\
    \ // the digits of the given number\n        val remainder = N % 10 // the remaining\
    \ digits in the number\n        val result = N.toString\n\n        // if the length\
    \ of the result is the same as the number of digits of the given number,\n   \
    \     // then it is a valid binary number that we can return\n        if (result.length\
    \ == digits) result else \"\"", "        val ans = BigInt(N.toString(2).padLeft(\"\
    0\", 9))\n        ans.toString(2).padLeft(\"0\", 6).split(' ').foldLeft(\"\")((x,y)\
    \ =>\n            if(x == \"0\") y else x + y)", "        val a = scala.math.pow(10,\
    \ math.ceil(math.log10(N)))\n        val b = scala.math.floor(N / a)\n       \
    \ val result = b * a.toInt\n        result + \"\"", "        val num = new collection.mutable.MutableList[String]()\n\
    \        val total = new collection.mutable.MutableList[String]()\n\n        while(N\
    \ !=0){\n            val remain = N % 2l\n            num ::= remain.toString\n\
    \            total ::= remain.toString\n            N = (N - remain).toLong\n\
    \        }\n\n        var index = 0\n        for(i <- total){\n            if(num(i)\
    \ ==\"1\"){\n                index += 1\n            }\n        }\n        val\
    \ answer = num.toString.substring(0,index)\n\n        return answer", "      val\
    \ res = mutable.Stack[String]()\n      val sum : Long = 0\n      val mask : Long\
    \ = 1L << N\n      val bits = 0 until N\n      val digit = scala.math.pow(10,\
    \ N.toInt)\n\n      for (bits <- bits) {\n        sum += digit(bits & mask)\n\
    \        if (sum >= 10) {\n          res.append(sum.toString.reverse.substring(0,\
    \ 1))\n          sum -= 10\n        } else {\n          res.append(sum.toString)\n\
    \          sum = 0\n        }\n      }\n      if (sum > 0) {\n        res.append(sum.toString)\n\
    \      }\n      res.reverse.mkString", "        // Initialization\n        var\
    \ sum : Long = 0\n        var binary = \"\"\n        var N1 : Long = N\n\n   \
    \     // While loop\n        while(N1 > 0){\n            sum += N1 % 10 // Add\
    \ last digit to sum\n            N1 = N1 / 10 // Divide by 10 to get last digit\n\
    \        }\n\n        // Add leading zero to sum\n        sum = sum.toString +\
    \ sum.dropWhile(_ < '0').mkString\n\n        // Add decimal places to sum so decimals\
    \ can be removed after conversion\n        while(sum.lastIndexOf(\".\") > sum.lastIndexOf(String(N).toCharArray(0)(0))\
    \ && sum.length < (8*N)){\n            sum = sum + \".\"\n        }\n\n      \
    \  // Convert sum to binary string\n        while(sum.length > 0){\n         \
    \   binary = binary + sum.last\n            sum = sum.dropRight(1)\n        }\n\
    \n        // Remove leading zeros from binary string\n        while(binary.length\
    \ > 1){\n            binary = binary.dropWhile(_ == '0')\n        }\n\n      \
    \  binary", "        val n = N.toInt\n        // first sort the binary numbers\n\
    \        val sortedNums = sortNums(n)\n        val nums = List(0) ++ sortedNums\n\
    \        val result = mutable.MutableList(\"\")\n        // calculate binary digits\
    \ in result\n        def binary(i : Int) : String = {\n            val res = \"\
    \"\n            var n = i\n            while (n > 0) {\n                if (n\
    \ % 2 == 1) {\n                    res = res + 1\n                }\n        \
    \        n = n / 2\n            }\n            res\n        }\n        for (i<-0\
    \ until nums.length) {\n            val currNum = nums(i)\n            val next\
    \ = nums(i + 1)\n            // check if current number has two higher binary\
    \ digits\n            val binaryDigitsOfNext = binary(next)\n            val binaryDigitsOfCurr\
    \ = binary(currNum)\n            if (binaryDigitsOfCurr.length < binaryDigitsOfNext.length)\
    \ {\n                // if there are two higher digits, add them to result\n \
    \               result.append((currNum + next).toString)\n            } else {\n\
    \                // if the binary digits of the next number are higher than the\
    \ digits of the\n                // current number, add the current number to\
    \ the result\n                result.append((currNum + next).toString)\n     \
    \       }\n        }\n        result.head", "        val binary = Integer.toBinaryString(N).padLeft(8,\
    \ '0')\n        binary.split(\"\").map(_.toInt).sum", "        val rem = N % 10\n\
    \        val ns = N / 10\n        val n = ns % 2\n        val sums = ns /2 //\
    \ Total sum must be even\n        var binary = \"\"\n        val totalSum = (rem*2\
    \ + sums).toInt\n        val a = Array(0 until totalSum)\n        a.foreach(x\
    \ => binary += if(x % 2 == 0) \"1\" else \"0\")\n        binary", "        var\
    \ nums : String = \"\"\n        var digits = N.toString.reverse.foldLeft(0){ (c,\
    \ _) => c + (if (_ < 10) 1 else 0) * _ }\n        nums = Integer.toBinaryString(digits)\n\
    \        while (nums.length < 8) {\n            nums = \"0\" + nums\n        }\n\
    \        nums.reverse", "        val binary = solveBinary(N)\n        binary.toList.mkString",
  "        val numBins = math.floor(math.log(N)/math.log(2))\n        var sum = 0\n\
    \        var bins = \"\"\n        for(b <- 0 until numBins) {\n            val\
    \ mask = 1 << (numBins - b)\n            val bit = (N % mask) match {\n      \
    \          case 0 => false\n                case _ => true\n            }\n  \
    \          val result = if (bit) 1 else 0\n            sum += result\n       \
    \     if (sum > 1) {\n                bins += bins\n                sum = 1\n\
    \            }\n        }\n        bins += bins\n        if (sum > 1) bins +=\
    \ \"1\"\n        bins", "        val result = new mutable.MutableList[Int]\n \
    \       val sum = 0\n        for(i <- 0 until N) {\n            val value = i\
    \ / 2\n            val remainder = i % 2\n            sum += value.toInt\n   \
    \         if(remainder == 0) result.add(sum)\n        }\n        val reverse =\
    \ result.reverse\n        val reverseSum = reverse.sum\n        val reverseString\
    \ = (reverseSum).map(i => i.toString.toBinaryString).mkString\n        val reverseString\
    \ = reverseString.reverse\n        result match {\n            case x => reverseString\n\
    \        }", "        def isBinary: Boolean = N.toString.length == 2 * S.length\n\
    \        def digit(x : Long) : Int = {\n            if(x < 10) return x\n    \
    \        x - (x % 10) + 10\n        }\n        def binary(x : Long): String =\
    \ { \n            val s = \"\"\n            while(x > 0) {\n                s\
    \ += digit(x % 2)\n                x /= 2\n            }\n            s.reverse\n\
    \        }\n        def s(n: Long): String = n.toString.padRight(S, '0')\n   \
    \     def solve(n: Long): String = {\n            if(n < 0) \n               \
    \ s(-n).reverse\n            else\n                binary(n).replaceAll(\"1\"\
    , \"1\" + \"0\".repeat(S.length)).\n                replaceAll(\"0\", \"0\" +\
    \ \"1\".repeat(S.length))\n        }\n        if(N < 0) \n            solve(-N)\n\
    \        else\n            if(isBinary)\n                solve(N)\n          \
    \  else\n                if(N < 10L)\n                    solve(N.toInt)\n   \
    \             else\n                    if(N < 100L)\n                       \
    \ solve(N / 100L).toInt\n                    else\n                        solve(N\
    \ / 10L)\n        }", "        var sum = 0L\n        var x = scala.math.pow(2,\
    \ N.toInt)\n        while (x>=1) {\n            sum += x\n            x /= 2\n\
    \        }\n        return sum.toString", "        val s = N.toBinaryString\n\
    \        val l = s.length\n        val binary = new scala.collection.mutable.ListBuffer[String]()\n\
    \        if (l == 0) {\n            binary.append(0)\n            return binary.mkString\n\
    \        }\n        val n = math.pow(2, l-1).toInt\n        var sum = 0\n    \
    \    for (i <- 0 until n) {\n            val bit = s.charAt(i).toInt\n       \
    \     if (bit > 1) {\n                sum += bit\n                binary.append(binary.last)\n\
    \            }\n            else {\n                sum += bit - 1\n         \
    \       binary.append(bit)\n            }\n        }\n        binary.append(sum)\n\
    \        return binary.mkString", "      if(N <= 0) {\n        return \"0\"\n\
    \      }\n\n      val totalSum = N.toString.reverse.foldLeft(0l){\n        case\
    \ (sum, digit) => sum + digit.toLong\n      }\n\n      val reverse = totalSum.reverse.foldLeft(0l){\n\
    \        case (sum, digit) => sum + digit.toLong\n      }\n\n      val reconstructed\
    \ = reverse.toString(2)\n\n      if(totalSum == 0){\n        \"0\"\n      }else\
    \ if(reverse == 0){\n        \"1\"\n      }else if(reconstructed == \"0\"){\n\
    \        reconstructed\n      }else{\n        reconstructed + solve(totalSum -\
    \ reverse)\n      }", "        var result = \"\"\n        // Use binary operations\
    \ to find the sum of the digits of each power of 10 in the original number\n \
    \       // Example:\n        // n = 1000: result = 10 + 1 = 11\n        // n =\
    \ 150:  result = 10 + 1 + 1 = 11 10 + 1 = 21 10 + 1 = 211\n        val ns = N.toString(2)\n\
    \        val len = ns.length\n        var i = 0\n        while(i < len) {\n  \
    \          result += ns.charAt(i) * i.toInt\n            i += 1\n        }\n \
    \       // Iterate through each digit and add that digit to the sum\n        //\
    \ Example:\n        // n = 1110:  result = 1 + 2 + 1 = 4 1 + 2 + 1 = 5 11 + 1\
    \ + 1 + 1 = 1 111 + 1 + 1 = 11\n        while(i < len) {\n            result +=\
    \ ns(i).toString.toInt * i\n            i += 1\n        }\n        return result",
  "        def solveLoop(N :Long) : String = {\n            var sum : Long = 0\n \
    \           while (N > 0) {\n                sum += N % 2l\n                N\
    \ /= 2l\n            }\n            sum.toBinaryString.reverse\n        }\n\n\
    \        var N0 = N\n        var result : String = \"\"\n        val N1 = N0 /\
    \ 2l\n        val N2 = N1 // Keep a copy of the original N2\n        while (N0\
    \ > 0) {\n            result += solveLoop(N0)\n            N0 = (N1 % 2l) / 2l\n\
    \            N1 = N0\n        }\n        result = result.concat(solveLoop(N2))\n\
    \n        result"]
stop_tokens:
- "\n    }\n"
