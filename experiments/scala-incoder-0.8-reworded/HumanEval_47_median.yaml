name: HumanEval_47_median
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return median of elements in the list l.\n    // >>> median((List[Long](3l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n    // 3l\n    // >>> median((List[Long](-10l.toLong,\
  \ 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))\n    // (15.0f)\n\
  \    def median(l : List[Long]) : Float = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(median((List[Long](3l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);\n    assert(median((List[Long](-10l.toLong,\
  \ 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));\n  \
  \  assert(median((List[Long](5l.toLong))) == 5l);\n    assert(median((List[Long](6l.toLong,\
  \ 5l.toLong))) == (5.5f));\n    assert(median((List[Long](8l.toLong, 1l.toLong,\
  \ 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);\n    }\n\n}\n"
completions: ["        import scala.math._\n        val numElements = l.length\n \
    \       if(numElements == 0) 0 else l.sorted[Float](math.abs(math.log10(numElements))).mid",
  "        var med = 0.0f\n        var m = l.length.toFloat\n        for (i <- 0 until\
    \ l) {\n            if (i < l / 2.0) med = med + l(i)\n            else med =\
    \ (med + l(i)) / (m - 1)\n        }\n        med.toFloat", "        val sortedList\
    \ = l.sort\n        if (sortedList.length % 2 == 1) {\n            val middle\
    \ = (sortedList.length / 2).floor.toInt\n            if (sortedList(middle) <\
    \ sortedList(middle - 1)) {\n                sortedList(middle - 1)\n        \
    \    } else {\n                sortedList(middle)\n            }\n        } else\
    \ {\n            sortedList(sortedList.length / 2)\n        }", "        // If\
    \ list is empty, return 0.\n        if (l.isEmpty)\n            return 0\n\n \
    \       // Sort list in descending order.\n        val r = l.sorted\n        val\
    \ mid = (r.length / 2).toInt\n        (r(mid), r(mid-1))", "        val n = l.size\n\
    \        if (n < 2) 0f\n        else (l.last + l.dropRight(1).last)/2f", "   \
    \     def partition(l: List[Long], r: Long) : List[Long] =\n            if (r\
    \ <= l.head) l :: Nil else Nil :: partition(l.tail, r)\n        val sorted = l.toList.sort\n\
    \        val (left, right) = partition(sorted, sorted.last)\n        val m = (left.head\
    \ + right).div(2)\n        if (m == 0.0) 0f else m", "        val l = l.sorted\n\
    \        val n = (l + l).length\n        val mid = n / 2\n        (mid.toDouble\
    \ * 0.5) + l.slice(mid).sum.toDouble", "        val sorted = l.sorted\n      \
    \  if(l.length < 2) l.head\n        else {\n            val half = sorted.length\
    \ >>> 1\n            val low = sorted.head\n            val high = sorted.last\n\
    \            sorted.init:{ \n                val l = (low + high) >>> 1\n    \
    \            if(l == high) high + 1.toLong\n                else if(l == low)\
    \ low + 1\n                else {\n                    val x = ((low + high) >>>\
    \ 1) + 1\n                    if(x <= half) low\n                    else high\n\
    \                }\n            }.takeWhile(l => (l < low) || (l > high)).last\
    \ + 1.toLong\n        }", "        val N = l.length\n        if (N==0) 0f\n  \
    \      else if (N==1) l.head\n        else\n            math.abs(l.sum/N) + l.last/N",
  "        val l = l match  {\n            case Nil => 0.0f\n            case x ::\
    \ Nil => x.toFloat\n            case x :: xs => if (xs.isEmpty) xs.toFloat\n \
    \                         else if (x < xs.head) xs.head.toFloat\n            \
    \              else median(xs.tail)\n        }\n        l.toFloat + (l.toFloat\
    \ - l.toFloat / 2).toFloat", "        val mid = (l.length / 2).toDouble\n    \
    \    if(l.length % 2 != 0) (l.last + l.first) / 2\n        else {\n          \
    \  var low = l.head\n            var high = l.last\n            low match {\n\
    \                case x if x < mid => (l.head + l.last) / 2\n                case\
    \ x if x > mid => (low + high) / 2\n                case _ => (low + high) / 2\n\
    \            }\n        }", "        val l1 = l.sortWith(_ < _)\n        if(l1.length\
    \ == 1) l1.head\n        else (l1.head+l1.last)/2", "        // Sort by length\
    \ before using binary search.\n        val sorted = l.sorted\n        val l =\
    \ sorted.length\n        val m = sorted.last\n        val l2 = l.last - m\n  \
    \      if (l2 == 0) m\n        else if (l2 == 1) (m+sorted[(l-1)/2]).floatValue\n\
    \        else (sorted[(l-1)/2].floatValue + sorted[l/2]).floatValue", "      \
    \  if(l.length==0) throw new IllegalArgumentException(\"List was empty\")\n  \
    \      val list = l.toSeq.toList\n        val sortedList = list.sortWith((x, y)\
    \ => x._1 < y._1)\n        val halfLen = (sortedList.size - 1) / 2\n        val\
    \ middle = sortedList(halfLen)\n        val low = sortedList(halfLen - 1)\n  \
    \      val high = sortedList(halfLen + 1) // O(n^2) but only ~50x the comparisons\n\
    \        if(list.isEmpty) throw new IllegalArgumentException(\"List was empty\"\
    )\n        if(list.size == 1) return list(0)\n        val midIndex = (low(0) +high(list.length-1))\
    \ / 2\n        if(low(0) > middle(0)) return low(0)\n        if(high(list.length-1)\
    \ > middle(list.length-1)) return high(list.length-1)\n        if(low(0) == middle(0))\
    \ return low(0)\n        if(high(list.length-1) == middle(list.length-1)) return\
    \ high(list.length-1)\n        if(low(0) > high(0)) return low(0)\n        else\
    \ if(low(0) == high(0)) return low(0)\n        else if(high(list.length-1) < low(0))\
    \ return high(0)\n        else return low(0)", "        def medianOfTwo(n1: Long,\
    \ n2: Long) =\n            (n1 + n2) / 2\n\n        if (l.length == 0)\n     \
    \       throw new RuntimeException(\"List can't be empty\")\n\n        if (l.length\
    \ == 1)\n            return l.head\n\n        val sorted = l.toArray\n       \
    \ val even = sorted.filter(_ % 2 == 0)\n        val odd = sorted.filter(_ % 2\
    \ == 1)\n\n        if (even.length < odd.length) {\n            val l1 = medianOfTwo(even(0),\
    \ even(even.length))\n            val l2 = medianOfTwo(odd(0), odd(odd.length))\n\
    \            medianOfTwo(l1, l2)\n        } else {\n            val l1 = medianOfTwo(even(0),\
    \ odd(0))\n            val l2 = medianOfTwo(even(0), odd(odd.length))\n      \
    \      medianOfTwo(l1, l2)\n        }", "        val h1 = (l.size / 2).toInt\n\
    \        val h2 = l.size - h1\n        if (h1 < 0) h1 = 0\n        if (h2 < 0)\
    \ h2 = 0\n        if (h1 == h2) l.last + 0.5f\n        else (l.first+l.last)/2.0f",
  "        val mid = l.length / 2\n        if (l.isEmpty) 0f\n        else (l(mid\
    \ - 1) + l(mid + 1)).toFloat / 2", "        val sorted = l.sorted\n        val\
    \ lLen = sorted.length\n        if (lLen < 2) {\n            throw new IllegalArgumentException(\"\
    List length must be greater than 1\")\n        }\n        // Find median\n   \
    \     val halfLength = (lLen / 2).toInt\n        val mid = (lLen - 1) / 2\n  \
    \      val median = if (half > lLen - 1) {\n            val midValue = sorted[mid]\n\
    \            val leftValue = sorted((mid + halfLength).toInt)\n            val\
    \ rightValue = sorted((mid - halfLength).toInt)\n            val medianValue =\
    \ (leftValue + rightValue) / 2\n            medianValue\n        } else {\n  \
    \          sorted[mid]\n        }\n        val size = l.size\n        if (size\
    \ < 2) {\n            throw new IllegalArgumentException(\"List length must be\
    \ greater than 1\")\n        }\n        val m = (size - 1) / halfLength\n    \
    \    val halfElements = l.slice(m, m+halfLength)\n        val medianElements =\
    \ l.slice(m, m+halfLength)\n        val halfMedianElements = halfElements.zip(medianElements)\n\
    \        val halfMedian = halfMedianElements.map(_._1).sum / halfMedianElements.length\n\
    \        val median = halfMedianElements.map(_._2).sum / halfMedianElements.length\n\
    \        if (size == halfLength) {\n            halfMedian\n        } else {\n\
    \            median\n        }", "        val sortedList = l.toList\n        sortedList.sortWith((a,\
    \ b) => a < b)\n        val middle = sortedList.length / 2\n        if (sortedList.length\
    \ % 2 == 0) {\n            sortedList(middle)\n        } else {\n            (sortedList(middle\
    \ - 1) + sortedList(middle)) / 2f\n        }", "      val s = l.sorted\n     \
    \ val m = s(l.size / 2)\n      if (l.length % 2 == 1) {\n        m.toFloat\n \
    \     } else {\n        (m - s(l.size / 2)).toFloat\n      }", "        val n\
    \ = l.length\n        val sorted = l.sortBy(_._1)\n        (sorted.length % 2)\
    \ == 0 ? (sorted.last + sorted.head + sorted.last / 2.0 / n).toFloat : sorted.last\
    \ / 2.0 / n", "        if (l.isEmpty) 0f\n        else {\n            val l =\
    \ l.sortBy(_.toDouble).take(l.length / 2)\n            l.last + l.drop(1).last\
    \ * 0.5\n        }", "        val n = l.length\n        var m = -1l\n        var\
    \ d = 0.0f\n        var x = 0\n        var i = 0\n        var j = 0\n        for\
    \ (i<-n;i+=1)\n        {\n            d = ((i+1) * ((i+1)/2)) + ((i) * i)\n  \
    \          if (m == -1)\n                m = d\n            else if (m != -1 &&\
    \ d > m)\n                m = d\n        }\n        if (m == -1)\n           \
    \ m = -1\n        else\n            for (j<-n;j+=1)\n            {\n         \
    \       if (j != i && j != n-i)\n                {\n                    d = ((j+1)\
    \ * ((j+1)/2)) + ((j) * j)\n                    if (m != -1 && d > m)\n      \
    \                  m = d\n                }\n            }\n        val z = m\
    \ - 1.0l\n        var q = (z * z) / 2.0\n        var c = 0.0f\n        for (i<-n;i+=1)\n\
    \        {\n            c = ((i+1) * c) + ((i - 1) * z) + l(i).toFloat\n     \
    \       if (c >= q)\n                q = c\n        }\n        c", '        l.reduce(l
    => (l.sorted with Ordering.Long.reverse).init.length / 2)', "        var res =\
    \ 0.0f\n        val minSize = l.length\n        l.sortWith(_ < _)\n        for\
    \ (i <- 0 until minSize) {\n            if (i == 0) res = l(i) // first element\n\
    \            else if (l(i) > res) res = l(i) // greater element\n        }\n \
    \       res.toFloat", "        // Use quicksort to find median of sub-lists with\
    \ length 2\n        val array = l.toArray\n        val pivot = array.length /\
    \ 2\n        val left = array filter (x => x < pivot)\n        val right = array\
    \ filter (x => x > pivot)\n        val l = left.length\n        val r = right.length\n\
    \        if (l == 0 || r == 0) {\n            throw new IllegalArgumentException(\"\
    Cannot have one or less elements of list\")\n        }\n        if (l < r) {\n\
    \            val median = left[l.toInt]\n            if (l == r) {\n         \
    \       return median\n            }\n            else {\n                return\
    \ median + (median + right[r.toInt] - left[l.toInt]) / 2\n            }\n    \
    \    }\n        else {\n            val median = right[r.toInt]\n            if\
    \ (l == r) {\n                return median\n            }\n            else {\n\
    \                return median + (median + left[l.toInt] - right[r.toInt]) / 2\n\
    \            }\n        }", "        val mid = l splitAt l.length / 2\n      \
    \  val smaller = m take l.length / 2\n        val larger = m drop l.length / 2\n\
    \        val median = (smaller + larger) / 2\n        median.toFloat", "     \
    \   def merge(dat : Array[Float], x : Float) : Array[Float] = {\n            var\
    \ i = 0\n            var j = 0\n            var n = 0\n            while (i <\
    \ dat.length && j < dat.length) {\n                if (dat(i) < dat(j)) {\n  \
    \                  n = new Array[Float](j + 1, dat(j + 1))\n                 \
    \   for (k <- 0 until j + 1) {\n                        n(k) = dat(k)\n      \
    \              }\n                    j++ // j is index of element to be replaced\n\
    \                }\n                else {\n                    n = new Array[Float](i,\
    \ dat(i))\n                    for (k <- 0 until i + 1) {\n                  \
    \      n(k) = dat(k)\n                    }\n                    i++ // i is index\
    \ of element to be replaced\n                }\n            }\n            if\
    \ (i == dat.length) {\n                n = new Array[Float](j, dat(j))\n     \
    \           for (k <- 0 until j + 1) {\n                    n(k) = dat(k)\n  \
    \              }\n            }\n            else if (j == dat.length) {\n   \
    \             n = new Array[Float](i, dat(i))\n                for (k <- 0 until\
    \ i + 1) {\n                    n(k) = dat(k)\n                }\n           \
    \ }\n            else {\n                n = new Array[Float](dat.length)\n  \
    \              for (i<- 0 until dat.length) {\n                    n(i) = dat(i)\n\
    \                }\n            }\n            return n\n        }\n\n       \
    \ val m = l.length\n        if (m % 2 == 1) {\n            var x = l.head\n  \
    \          var y = l.tail.head\n            var l = new Array[Float](m)\n    \
    \        var r = new Array[Float](m)\n            var r2 = new Array[Float](m)\n\
    \            for (i <- 0 until m) {\n                if (i < m-1) {\n        \
    \            r(i) = x\n                    x = y\n                    y = r.head\n\
    \                }\n                l(i) = (x + y)/2\n                r(i+1) =\
    \ (x - y)/2\n                r2(i) = r(i)\n                x = r(i)\n        \
    \        y = r2(i+1)\n            }\n            return l.last\n        }\n  \
    \      val even = l.takeRight(m/2)\n        val odd = l.drop(m/2)\n        val\
    \ rt = merge(od.toArray, even.last)\n        return rt(0)", "        val m = l.sortWith(_\
    \ < _).length / 2.0\n        val median = (l min l).sortWith(_ < _).length / 2.0\n\
    \        if (median == 0) 0.0f\n        else l.sortWith(_ < _).length match {\n\
    \            case x if x < m => l.sortWith(_ < _).head\n            case x if\
    \ x > m => l.sortWith(_ < _).last\n            case _ => l.sortWith(_ < _).last\n\
    \        }", "        val n = l.length\n        if (n < 2) 2\n        else (l.sum\
    \ / n).toFloat", "      val (lo, hi) =  l.splitAt(l.size/2)\n      (hi - lo)/2l",
  "        val n = l.length\n        val mid = n / 2\n        val left = l(0)\n  \
    \      val right = l(n)\n        val middle = (left + right) / 2\n        if (n\
    \ == 1 || n == 0)\n            return middle\n        val median1 = if (middle\
    \ <= left) left else middle\n        val median2 = if (middle >= right) right\
    \ else middle\n        (median1 + median2) / 2", "        // use unsorted data\
    \ structure to solve the problem\n        val m = l.getOrElse(0)\n        val\
    \ length = l.length\n        val even = length / 2\n        val median = (m +\
    \ l.getOrElse(even)) + (l.getOrElse(even) - 1)\n        val negative = length\
    \ / 2 - 1\n        val negativeMedian = (m - l.getOrElse(negative)) + (l.getOrElse(negative)\
    \ - 1)\n        val evenMedian = (m / 2.0) + (l.getOrElse(even - 1.0))\n     \
    \   val negativeEvenMedian = (m / 2.0) - (l.getOrElse(negative - 1.0))\n     \
    \   if (median == 0.0f) {\n            if (length < 2) 1.0f\n            else\
    \ -1.0f\n        } else if (median < 0.0f) {\n            if (length < 2) 1.0f\n\
    \            else -1.0f\n        } else if (median == 1.0f) {\n            if\
    \ (length < 2) 0.0f\n            else 1.0f\n        } else if (median > 1.0f)\
    \ {\n            if (length < 2) 0.0f\n            else 1.0f\n        } else {\n\
    \            if (length < 2) median\n            else negativeMedian\n       \
    \ }", "        val m1 = l.take(l.length / 2).toList\n        val m2 = l.drop(l.length\
    \ / 2).toList\n        val p1 = m1.sorted map {_ / 2}.get\n        val p2 = m2.sorted\
    \ map {_ / 2}.get\n        (p1 + p2) / 2", "        l.sortBy(math.abs)\n     \
    \   val length = l.length\n        if (length == 0) 0.0f\n        else (length\
    \ + 1) / 2.0f * (l(0) + l(length - 1)).toFloat", "        if (l.length == 0) throw\
    \ new IllegalArgumentException(\"l cannot be empty\")\n        val m = l.head\n\
    \        val n = l.tail.sortBy(-_.toFloat)\n        var hd = n(0)\n        var\
    \ hn = n(1)\n        var d = (m + hn) / 2\n        while (hd < hn) {\n       \
    \     d = ((hd + hn) / 2)\n            hd = n( d.toInt )\n            hn = n(\
    \ (d.toInt + 1).toInt )\n        }\n        (d).toFloat", "        val n = l.length\n\
    \        if (n == 0)\n            return 0.0f\n        else if (n % 2 == 0)\n\
    \            l.toArray.sorted(math.Ordering.Int.reverse).last._2 / 2\n       \
    \ else\n            l.toArray.sorted(math.Ordering.Int.reverse).last._2 / 2 +\
    \ l.toArray.sorted(math.Ordering.Int.reverse).last._2 / 2", "        var sum =\
    \ 0\n        var count = (l.length / 2.0).toInt\n        for(i <- 0 until count)\
    \ {\n            sum = sum + l(i).toFloat\n        }\n        val average = sum\
    \ / count\n        val min: Float = l.min\n        val max: Float = l.max\n  \
    \      (average + (max - average) / 2).toFloat", "        l.size match {\n   \
    \         case n if n % 2 != 0 =>\n                val (low, high) = l.splitAt(n\
    \ / 2)\n                low match {\n                    case head :: tail =>\n\
    \                        val median = head + median(tail)\n                  \
    \      if (median == low) low else median\n                    case Nil => 0l\n\
    \                }\n            case n if n % 2 == 0 =>\n                l.head\
    \ + median(l.tail)\n            case _ => 0f\n        }", "        val sorted\
    \ = l.sortWith(_ < _)\n        if(sorted.isEmpty) {\n            0.0f\n      \
    \  } else {\n            (sorted.head + sorted.last / 2).asInstanceOf[Float]\n\
    \        }", "        val medians = l.sortBy(-_).take(l.length/2) : Array[Float]\n\
    \        if(medians.length == 0) 0f else medians.last / l.length", "        val\
    \ n = l.length\n        var mid : Long = (n.toFloat / 2).toLong\n        while(n\
    \ >= 2) {\n            mid -= 1.0;\n            if(l(mid) > l(mid + 1.0))\n  \
    \              mid += 1\n        }\n        mid.toFloat", "        if (l.isEmpty)\n\
    \            l.head\n        else if ((l.length == 1))\n            l.head\n \
    \       else\n            (l.take(l.length/2).sum/2).toFloat", "        val set\
    \ = l.toSet\n        if (set.isEmpty) 0.0\n        else set.toSeq.sortBy(_.toFloat).length\
    \ / 2", "      val (mid, size) = l.span(_ <= l.length)\n      if(size % 2 != 0)\
    \ {\n        if(size < 2) {\n          l.toFloat\n        } else {\n         \
    \ l.splitAt(mid).toList.toList.sortBy(_._2).last._1\n        }\n      } else {\n\
    \        val median = (size.toFloat / 2).toFloat\n        l.splitAt(mid).toList.sortBy(_._2).last._1\n\
    \      }", "        val sortedL: List[Long] = l.sorted\n        val midIndex:\
    \ Int = sortedL.size / 2\n        val sortedMid: Long = sortedL(midIndex)\n  \
    \      if(sortedL.size % 2 == 1) {\n            sortedMid.toFloat\n        } else\
    \ {\n            val lowerMedian: Float = sortedL(midIndex-1)\n            val\
    \ upperMedian: Float = sortedL(midIndex+1)\n            math.abs(upperMedian-lowerMedian).toFloat\n\
    \        }", "        val numElements = l.length\n        if (numElements % 2\
    \ == 0) l.sortedRight(1).head / 2 else\n            l.sortedRight(1).last.getOrElse(l.sortedRight(1).size\
    \ / 2) - 1", "        import scala.math._\n        val n = l.length\n        if\
    \ (n % 2 == 0) \n            l.drop(n/2).reduceLeft(_ + _)/n \n        else\n\
    \            l.take(n/2).reduceRight(_ + _)/n", "        val m = l.length / 2\n\
    \        if(l.length%2 == 0) (l.sortWith(_ < _).take(m).last + l.sortWith(_ <\
    \ _).drop(m).last) / 2\n        else l.sortWith(_ < _).take(m).last / 2", "  \
    \      val n = l.size\n        val sorted = l.sorted\n        val half = n/2\n\
    \        if (n < 2L) sorted((0.toFloat, sorted.head))\n        else (sorted((n-1).toFloat,\
    \ sorted.take(half))._1.toFloat+sorted((n-1).toFloat, sorted.drop(half).head))/2",
  "        val (first, second) = l.splitAt(l.size / 2)\n        val average = first\
    \ reduce { (x, y) => x + y } / 2\n        val difference = second - average\n\
    \        average", "        l.sortBy(_.toFloat)\n        l.size match {\n    \
    \        case 0 => 0f\n            case n => l.head + n.toFloat / 2\n        }",
  "      val m = l.size / 2\n      if(l == null || l.isEmpty)\n        throw new Exception(\"\
    list cannot be empty or null\")\n      if(l.size % 2 == 1)\n        l.sorted.drop(m).last.toFloat\n\
    \      else\n        l.sorted.drop(m).last.toFloat + (l.sorted.take(m).head -\
    \ l.sorted.take(m-1)last).toFloat", "        val numElements = l.length\n    \
    \    val sortedList = l.sorted\n        val len = sortedList.length\n        val\
    \ mid = len / 2\n        (sortedList(mid) - sortedList(len - 1)) / 2.0", "   \
    \     val size = l.size\n        if (size < 2) 0f\n        else {\n          \
    \  val first  = l.get(0)\n            val last   = l.get(size - 1)\n         \
    \   val median = (first + last) / 2\n            median.toFloat\n        }", " \
    \       var temp = 0\n        var temp2 = 0\n        var temp3 = 1\n        var\
    \ temp4 = 0\n        val n = l.length\n        while (n > 1) {\n            if\
    \ (l(n-1) < l(n)) {\n                temp = l(n)\n                temp2 = l(n-1)\n\
    \                n = n - 1\n            } else if (l(n-1) > l(n)) {\n        \
    \        temp3 = l(n)\n                temp4 = l(n-1)\n                n = n -\
    \ 1\n            }\n        }\n        return (temp + temp2 + temp3 + temp4)/4.0",
  "        var list = l.toArray\n        if (list.size < 2) return list.head\n   \
    \     var mid = list.size / 2\n        val first = list.drop(mid)\n        val\
    \ second = list.take(mid)\n        val leftMedian = median(first)\n        val\
    \ rightMedian = median(second)\n        val leftMedianDouble = (leftMedian + rightMedian)\
    \ / 2\n        val rightMedianDouble = (leftMedian + rightMedian) / 2\n      \
    \  val medianDouble = (leftMedianDouble + rightMedianDouble) / 2\n        return\
    \ medianDouble", "      val s = l.sortWith(_ < _)\n      s(math.ceil.length(l\
    \ / 2)) / 2.toFloat", "        val lSize = l.size\n        val firstMedian = l.min\n\
    \        val secondMedian = l.min\n        val middleMedian = (lSize - 1) * (l.min\
    \ + l.max)\n        val median = (firstMedian + secondMedian) / 2.0\n        val\
    \ firstHalf = l diff (0 until lSize)\n        val secondHalf = l diff (1 until\
    \ lSize)\n        val median = (firstMedian.abs + secondMedian.abs + middleMedian.abs)\
    \ / 2.0\n        val thirdHalf = l diff (2 until lSize)\n        val median =\
    \ (firstHalf(1) + secondHalf(1) + middleMedian.abs + thirdHalf(1)) / 2.0\n   \
    \     val fourthHalf = l diff (3 until lSize)\n        val median = (firstHalf(2)\
    \ + secondHalf(2) + middleMedian.abs + thirdHalf(2) + fourthHalf(2)) / 3.0\n \
    \       val fifthHalf = l diff (4 until lSize)\n        val median = (firstHalf(3)\
    \ + secondHalf(3) + middleMedian.abs + thirdHalf(3) + fourthHalf(3) + fifthHalf(3))\
    \ / 4.0\n        val sixthHalf = l diff (5 until lSize)\n        val median =\
    \ (firstHalf(4) + secondHalf(4) + middleMedian.abs + thirdHalf(4) + fourthHalf(4)\
    \ + fifthHalf(4) + sixthHalf(4)) / 5.0\n        val seventhHalf = l diff (6 until\
    \ lSize)\n        val median = (firstHalf(5) + secondHalf(5) + middleMedian.abs\
    \ + thirdHalf(5) + fourthHalf(5) + fifthHalf(5) + sixthHalf(5) + seventhHalf(5))\
    \ / 6.0\n        val eighthHalf = l diff (7 until lSize)\n        val median =\
    \ (firstHalf(6) + secondHalf(6) + middleMedian.abs + thirdHalf(6) + fourthHalf(6)\
    \ + fifthHalf(6) + sixthHalf(6) + seventhHalf(6) + eighthHalf(6)) / 7.0\n    \
    \    val ninthHalf = l diff (8 until lSize)\n        val median = (firstHalf(7)\
    \ + secondHalf(7) + middleMedian.abs + thirdHalf(7) + fourthHalf(7) + fifthHalf(7)\
    \ + sixthHalf(7) + seventhHalf(7) + e", "        // Get size of list\n       \
    \ val length = l.length\n        val pivot = length / 2\n        val low = pivot\
    \ - 1\n        val high = pivot + 1\n        var sum = 0\n        for (i<- low\
    \ until high)\n            sum += l(i)\n        val median = sum / length\n  \
    \      median", "        val n = l.length\n        if (n <= 0) 0.0f\n        else\
    \ {\n            val half = n / 2\n            val lo = l.take(half)\n       \
    \     val hi = l.drop(half)\n            val hsum = hi.sum\n            val losum\
    \ = lo.sum\n            val m = (hsum + losum) / 2.0f\n            if( losum >\
    \ hsum ) m\n            else m\n        }", "        val n = l.size\n        val\
    \ r = n / 2\n        val x = l.sortWith(_ < _).take(r).toList\n        val m =\
    \ (x.last + x.head) / 2\n        x(r.toInt - 1) + x(r.toInt)", "        // Calculate\
    \ number of elements in the list l.\n        var n = 0\n        for (x <- l) n\
    \ += 1.0\n        // Calculate number of elements less than or equal to the median\
    \ of list l.\n        var i = 0\n        for (x <- l)\n            if (x < l(n/2.0))\n\
    \                i += 1\n        // Calculate number of elements greater than\
    \ or equal to the median of list l.\n        var j = 0\n        for (x <- l)\n\
    \            if (x > l(n/2.0))\n                j += 1\n        if (i == 0)\n\
    \            0.0\n        else if (i == j)\n            l(n/2.0)\n        else\
    \ if (j > 0)\n            l((n+1)/2.0).toFloat\n        else\n            l((n-1)/2.0).toFloat",
  "        val sorted = l.sorted\n        if (sorted.isEmpty) 0.0f\n        else {\n\
    \            val middle = sorted.length / 2\n            val even = sorted.take(middle)\n\
    \            val odd = sorted.drop(middle)\n            val median = (even.toFloat\
    \ + odd.toFloat) / 2\n            median\n        }", "        l\n           \
    \ .sortBy(x => x)\n            .drop(l.length / 2)\n            .toList\n    \
    \        .median", "        val sorted = l.sorted\n        if (sorted.length ==\
    \ 1)\n            sorted[0]\n        else if (sorted.length == 0)\n          \
    \  throw new IllegalArgumentException\n        else\n            sorted.length\
    \ match {\n                case x if x > 0 => sorted.last\n                case\
    \ x if x < 0 => sorted.last * (-1).toFloat\n                case _ => throw new\
    \ IllegalArgumentException\n            }", "        val sorted = l.toList.sorted\n\
    \        val median = sorted.head + if (sorted.size > 1) sorted.last / 2 else\
    \ sorted.last\n        median", "        val counts: mutable.Map[Long, Int] =\
    \ mutable.Map.empty[Long, Int]\n        l.foreach { e => counts(e) = counts.getOrElse(e,\
    \ 0) + 1 }\n        counts.size\n            .times(1.0 / counts.size) *\n   \
    \         counts.getOrElse(l(0), 0) +\n            l.size / 2", "        val sortedList\
    \ = l.sortWith(_ > _)\n        val midPoint = (sortedList.size / 2).floor.toFloat\n\
    \        val midPointFloat = midPoint * 1\n        if (sortedList.size == 1) midPointFloat\n\
    \        else {\n            if (midPointFloat == sortedList(0)) sortedList(0)\n\
    \            else sortedList(sortedList.size - 1)\n        }", "        val evens\
    \ = l.filter(_ % 2 == 0)\n        val odds = l.filter(_ % 2 == 1)\n\n        if\
    \ (evens.isEmpty) 0f\n        else if (evens.size == 1)\n            evens(0)\n\
    \        else {\n            val first = (evens.head / 2).toFloat\n          \
    \  val second = (evens.last / 2).toFloat\n            if (second > first) first\n\
    \            else second\n        }", "        val sortedList : scala.collection.mutable.List[Long]\
    \ = l.toList.sortWith(math.Ordering.Long.<)\n        if (sortedList.size < 2)\
    \ { sortedList.head }\n        else { \n            val halfList = l.toList.take(sortedList.size\
    \ / 2)\n            val leftMedian = median(halfList.head.toList)\n          \
    \  val rightMedian = median(halfList.tail.toList)\n            (leftMedian + rightMedian)\
    \ / 2\n        }", "        var min = 0l\n        var max = -1l\n        val median\
    \ = l.toSet.toList.sortWith((x: Long, y: Long) => x.toFloat < y.toFloat).last\n\
    \n        while (max < l.toSet.toList.maxByOrdered(_.toFloat)) {\n           \
    \ max = l.toSet.toList.maxByOrdered(_.toFloat)\n        }\n\n        while (min.lessThanOrEqualTo(l.toSet.toList.minByOrdered(_.toFloat)))\
    \ {\n            min = l.toSet.toList.minByOrdered(_.toFloat)\n        }\n\n \
    \       (min + max) / 2", "        val m = l.map(_.toFloat).sortWith(_ < _).last\n\
    \        if (l.size % 2 == 0) (l.size / 2).toFloat + m else m", "        if (l.isEmpty)\
    \ {\n            throw Left(List(\"No median in empty list\"))\n        }\n  \
    \      val mid = l.size / 2\n        val midval = l.lift(mid)\n        val leftMedian\
    \ = l.lift(mid - 1)\n        val rightMedian = l.lift(mid + 1)\n        math.max(leftMedian,\
    \ rightMedian).toFloat", "        val n = l.length\n        val half = n / 2\n\
    \        if (n % 2 != 0) (l.head + l.last) / 2\n        else if (n == 1) l.head\n\
    \        else {\n            val m = l.partition(_ > l.last)\n            val\
    \ m1 = m._1.take(half)\n            val m2 = m._2.take(half)\n            val\
    \ m = m1.zip(m2).map(_._2).reduceLeft((a, b) => a + b) / half\n            if\
    \ (m == l.last) l.last\n            else m\n        }", "        val sortedList\
    \ = l.toSeq.sorted\n        val listSize = sortedList.length\n        val halfSize\
    \ = listSize / 2\n        val median = sortedList(halfSize)\n        val isEven\
    \ = halfSize % 2 == 0\n        val medianIsNegative = median.isNegative\n    \
    \    val medianIsEven = median.isEven && medianIsNegative\n        val medianIsOdd\
    \ = median.isOdd && !medianIsEven\n        if (medianIsOdd) if (isEven) median.asInstanceOf[Float]\
    \ else median.asInstanceOf[Float] - 0.5f\n        else median.asInstanceOf[Float]\
    \ + 0.5f", "        l.foldLeft(0l) {\n            case (m, n) => if (m >= n) m\
    \ else n\n        }.floor / 2", "        l.sortWith(_.toDouble < _.toDouble) match\
    \ {\n            case Nil => l.head\n            case x :: Nil => x.toFloat\n\
    \            case x :: xs => 0.5 * (x.toFloat + median(xs))\n        }", "   \
    \     val sorted = l.sorted\n        val mid = sorted.length / 2\n        val\
    \ half = Math.round(sorted[mid].toDouble * 0.5).asInstanceOf[Float]\n        sorted[mid].toFloat\
    \ - half", "        var high = l.last\n        var low = l.head\n        var mid\
    \ = l.head\n        for ( x <- l.tail) {\n            if (x < low || x > high)\
    \ throw new IllegalArgumentException(\"List is not sorted correctly.\")\n    \
    \        if (x < low) low = x\n            if (x > high) high = x\n          \
    \  mid = x\n        }\n        return (high + low) / 2", "        val l = l.getOrElse(List[Long]())\n\
    \        val n = l.size\n        if (n < 2) return(l.last)\n        val mid =\
    \ n / 2\n        val lo = l.take(mid)\n        val hi = l.drop(mid)\n        val\
    \ i = lo.indices\n        if (i.size > 1) (lo.sorted.take(i(i).last).last + lo.sorted)\n\
    \        else if(hi.size < 2) hi.last\n        else (lo.last + hi)", "       \
    \ def sort(l : List[Long], lo : Long = 0, hi : Long = 0) : List[Long] = {\n  \
    \          if (lo < hi) {\n                val i = (lo + hi) >>> 1\n         \
    \       val val = l(i)\n                var llo = lo\n                while (llo\
    \ < hi) {\n                    val llo = llo + 1\n                    val hi =\
    \ i\n                    var hi = hi\n                    val val = l(i)\n   \
    \                 var llo = lo\n                    while (llo < hi) {\n     \
    \                   if (llo < hi && llo < i) \n                            llo\
    \ = llo + 1\n                        if (llo > hi && llo < i) \n             \
    \               hi = hi - 1\n                        if (llo < hi && llo > i)\
    \ \n                            llo = llo + 1\n                        if (llo\
    \ > hi && llo > i) \n                            hi = hi - 1\n               \
    \         val tmp = l(i)\n                        val tmp2 = llo\n           \
    \             val tmp3 = hi\n                        val tmp4 = lo\n         \
    \               l(i) = val\n                        llo = tmp\n              \
    \          hi = tmp2\n                        lo = tmp3\n                    \
    \    i = tmp4\n                    }\n                }\n                sort(l,\
    \ lo, i)\n            } else {\n                l\n            }\n        }\n\
    \        val n = l.length\n        if (n % 2 == 0)\n            (l.last() + l.head)\
    \ / 2l\n        else\n            sort(l)", "        if (l.isEmpty) 0\n      \
    \  else {\n            val mid = (l.length + 1) >> 1\n            if (l.length\
    \ % 2 == 1) l.sorted.apply(mid)\n            else l.sorted.apply(mid + 1)\n  \
    \      }", "        val l2 = l sorted\n        val mid = l2.size / 2.0\n     \
    \   l2.size / 2.0 + l2(mid - 1).toFloat", "        val counts = l.toSet.toList\n\
    \            .groupBy( x => x / 1e12 )\n            .map { case (k, v) => (k,\
    \ v.size.toDouble) }\n        val max = counts.maxBy( x => x._2 )\n        val\
    \ min = counts.minBy( x => x._2 )\n        val median = (max._2 + min._2) / 2.0\n\
    \        val sumOfCounts = counts.sum\n\n        val scaled = List.range(1, sumOfCounts)\n\
    \            .map { x => (x - 1l.toLong) / 1e12 }\n            .zipWithIndex.map\
    \ { case (x, i) => (i.toLong, x)}\n            .filter { case (i, _) => counts(i)\
    \ >= median }\n            .map( x => (x._1, x._2))\n            .sortBy( x =>\
    \ x._1 )\n            .reverse\n            .head._1\n\n        median.toFloat",
  "       var sorted = l.sorted\n       val mid = sorted.length/2\n       sorted.init\n\
    \       if (sorted.length%2==0) {\n          val even = sorted.drop(mid)\n   \
    \       val odd = sorted.take(mid)\n          (even.sum.toFloat/odd.sum.toFloat).ceil.toFloat\n\
    \       }\n       else {\n          val even = sorted.take(mid)\n          val\
    \ odd = sorted.drop(mid)\n          (odd.sum.toFloat/even.sum.toFloat).ceil.toFloat\n\
    \       }", "        // Find middle element.\n        val mid = l.size / 2\n \
    \       val a = l splitAt mid\n        // Find median of elements around middle\
    \ element.\n        val med1 = a.take(mid)\n        val med2 = a.drop(mid)\n \
    \       // Find median of elements around middle element.\n        val med3 =\
    \ a.takeRight(mid)\n        val med = (med1 + med2 + med3) / 3\n        val min\
    \ = (min(med.toDouble, l.head.toDouble), med.toDouble)\n        val max = (max(med.toDouble,\
    \ l.head.toDouble), med.toDouble)\n        val median = if(min < max) min else\
    \ max\n        median", "        val sortedList : List[Long] = l.sortWith(_ <\
    \ _)\n        val length = sortedList.length\n\n        val midPoint = (length\
    \ - 1) / 2.0\n        val left = sortedList.slice(0, midPoint)\n        val right\
    \ = sortedList.slice(midPoint, length)\n\n        if (sortedList.length % 2 ==\
    \ 0) {\n            (left + right) / 2\n        } else {\n            ((left.last\
    \ + right.last) / 2.0).toFloat\n        }", "        val sortedList = l.sortWith(_\
    \ < _)\n        val median = if (sortedList.length % 2 == 0) sortedList(sortedList.length\
    \ / 2 - 1) else (sortedList(sortedList.length / 2) - sortedList.length / 2)\n\
    \        median.toFloat", "        var nums : List[Long] = l.toList\n        val\
    \ sorted = nums.sortWith(_ < _)\n        if(nums.isEmpty) 0.0f\n        else if(nums.size\
    \ == 1 || nums.size == 2 ) nums.head.toFloat\n        else {\n            val\
    \ mid = nums.size / 2\n            val median = nums(mid)\n            val left\
    \ = nums.take(mid)\n            val right = nums.drop(mid)\n            val result\
    \ = left + median + right\n            if( result.toInt <= 0) 0.0f else result.toFloat\n\
    \        }", '        if (l.length == 1) l.head else (l.length/2).toFloat + l.last.toFloat/2
    + l.init.toFloat/2', "        def half(n: Int) : Float = n / 2.0\n        def\
    \ medianOf3(n: Int) : Float = {\n            var x = 0f\n            var y = 0f\n\
    \            var i = 0\n            var j = 0\n            var mid = half(n)\n\
    \            while (i < n && j < n) {\n                if (i < n && j < n) {\n\
    \                    if (l(i) < l(j)) {\n                        x = l(i); y =\
    \ l(j)\n                    }\n                    else {\n                  \
    \      x = l(j); y = l(i)\n                    }\n                }\n        \
    \        else {\n                    if (l(i) < mid) {\n                     \
    \   x = l(i); y = mid\n                    }\n                    else {\n   \
    \                     x = mid; y = l(j)\n                    }\n             \
    \   }\n                i += 1\n                j += 1\n            }\n       \
    \     if (i < n) {\n                x = l(i); y = l(j)\n            }\n      \
    \      else {\n                x = mid; y = mid\n            }\n            return\
    \ x\n        }\n        def medianOf3(n: Int, l: List[Long]) : Float = {\n   \
    \         var x = 0f\n            var y = 0f\n            var i = 0\n        \
    \    var j = 0\n            var mid = half(n)\n            var mid2 = half(l)\n\
    \            while (i < n && j < l) {\n                if (i < n && j < l) {\n\
    \                    if (l(i) < l(j)) {\n                        x = l(i); y =\
    \ l(j)\n                    }\n                    else {\n                  \
    \      x = l(j); y = l(i)\n                    }\n                }\n        \
    \        else {\n                    if (l(i) < mid) {\n                     \
    \   x = l(i); y = mid\n                    }\n                    else {\n   \
    \                     x = mid; y = l(j)\n                    }\n             \
    \   }\n                i += 1\n                j += 1\n            }\n       \
    \     if (i < n) {\n                x = l(i); y = l(j)\n            }\n      \
    \      else {\n                x = mid; y = mid\n            }\n            return\
    \ x\n        }\n        def medianOf3(n: Int, l: List[Long], p: Int) : Float =\
    \ {\n            var x = 0f\n            var y = 0f\n            var i = 0\n \
    \           var j = 0\n            var mid = half(n)\n            var mid2 = half(l)\n\
    \            var pmid = half(p)\n            while (i < n && j < l && p > 0) {\n\
    \                if (i < n && j < l && p > 0) {\n                    if (l(i)\
    \ < l(j) && p > 0) {\n                        x = l(i); y = l(j)\n           \
    \         }\n                    else {\n                        x = l(j); y =\
    \ l(i)\n                    }\n                }\n                else {\n   \
    \                 if (l(i) < mid) {\n                        x = l(i); y = mid\n\
    \                    }\n                    else {\n                        x\
    \ = mid; y = l(j)\n                    }\n                }\n                i\
    \ += 1\n                j += 1\n                p -= 1\n            }\n      \
    \      if (i < n) {\n                x = l(i); y = l(j)\n            }", "   \
    \     val n = l.length\n        val l = l.reverse\n        val h = (l.head.toDouble\
    \ + l.last.toDouble) / 2\n        val lo = l.slice(0,l.length-(n-1))\n       \
    \ val hi = l.slice(0,n)\n        val m = (lo.head + lo.last) / 2.0\n        if\
    \ (hi min h) m else h", "        val list = l.toList.sortWith(_ < _)\n       \
    \ (list.last+list.head)/2", "        val hd = l.head\n        val rt = l.tail\n\
    \        val n = rt.length\n        if (rt.isEmpty) hd\n        else {\n     \
    \       val m = (hd + rt.min) / 2\n            val rthd = rt.filter(_ > m).length\n\
    \            if (rthd == n) m\n            else if (rthd == 0) hd\n          \
    \  else if (rthd == n-1) rt.filter(_ > m).max\n            else m\n        }",
  "        val length = l.size\n        // Return null if the list has zero length\n\
    \        if (length == 0)\n            return null\n        // Find the middle\
    \ index\n        val mid = length >>> 1\n        // Compute the median\n     \
    \   val half = length / 2\n        if (half == 0) return l.get(0)\n        val\
    \ halfMedian = (l(mid - half) + l(mid + half)) / 2.0\n        return halfMedian",
  "        val sorted = l.toList\n        sorted.sortWith(_ < _)\n        val mid\
    \ = (sorted.length / 2).round\n        val median = (sorted(mid) + sorted(mid\
    \ - 1)).toFloat\n        median", "        l.groupBy(x => x.toFloat).values.toSeq.map(_.sortBy(x\
    \ => x)).map(_.reverse).flatten match {\n            case x if x.size == 1 =>\
    \ x.head\n            case x if x.size % 2 == 0 => x.size / 2\n            case\
    \ x if x.size % 2 == 1 => (x.size / 2).toFloat * 1.0\n            case _ => x.size\
    \ / 2\n        }", "        val n = l.length\n        val k = n/2\n        if\
    \ (k < 1)\n            return l.head\n        val m = math.ceil(n/2)\n       \
    \ return l.lift(m).sum / m", "        val sortedList = l.sorted\n        if (sortedList.length\
    \ % 2 == 0) sortedList.get(sortedList.length / 2)\n        else sortedList.get(sortedList.length\
    \ / 2 - 1) + sortedList.get(sortedList.length / 2)", "        val count = l.length\n\
    \        if (count % 2 == 0) (l.head + l.last) / 2\n        else (l.last + l.head\
    \ - count / 2) / 2.0", "        val sortedList = l.sorted\n        val midIndex\
    \ = sortedList.length / 2\n        val lower = if (sortedList.length % 2 == 0)\
    \ sortedList((midIndex - 1) + midIndex) / 2.0\n        else sortedList((midIndex\
    \ - 1) + midIndex)\n        val upper = if (sortedList.length % 2 == 0) sortedList(midIndex\
    \ + midIndex + 1) / 2.0\n        else sortedList(midIndex + midIndex)\n      \
    \  val middle = (lower + upper) / 2.0\n        val median = (lower + middle +\
    \ upper) / 3.0\n        median.asInstanceOf[Float]", "        val n = l.size\n\
    \        if (n <= 0) 0f\n        else if (n >= 1) l(0)\n        else (n - 1) +\
    \ (0.5f * median(l.drop(1)))", "        val m = l.toArray\n        val len = m.length\n\
    \        if (len < 2) 0.0f\n        else {\n            val mid = len/2\n    \
    \        (mid % 2 == 0) ? (mid + (mid / 2)) :\n                   (mid - (mid\
    \ / 2))\n        }", "        if (l.length == 0) 0.0f\n        val mid = l.length\
    \ / 2.0\n        var a = l(0), b = l(0)\n        for(x <- l.init) {\n        \
    \    if((x < b) || (x == b)) {\n                a += x\n            } else {\n\
    \                b += x\n            }\n        }\n        (b - a) / 2", "   \
    \     if(l.isEmpty) throw new IndexOutOfBoundsException(\"Empty list\")\n    \
    \    val n = l.length\n        val mid = math.ceil(n/2)\n        val left = l.take(mid)\n\
    \        val right = l.drop(mid)\n        val median = if (n.isEven) left.length\
    \ else right.length\n        val m = (l + right) match {\n            case Nil\
    \ => (0l).toFloat\n            case x :: xs => if (x.toFloat.isFinite) x.toFloat\
    \ else x.toDouble\n        }\n        math.min(m, median.toFloat)", "        //\
    \ Initialize list to store list of medians.\n        var lMedians = List.empty[Long]\n\
    \        // Sort list l on descending order.\n        l.sortBy(-_)\n        //\
    \ Get the length of list l.\n        var lLength = l.length\n        // If list\
    \ l length is odd, return mid element.\n        if(lLength % 2 == 0) {\n     \
    \       return l(lLength/2)\n        }\n        // If list l length is even, divide\
    \ list l into 2 halves.\n        else {\n            var lHalf1 = l.take(lLength/2)\
    \ // Keep first half.\n            var lHalf2 = l.drop(lLength/2) // Keep second\
    \ half.\n            // Find median of first half.\n            var lMedian1 =\
    \ median(lHalf1)\n            // Find median of second half.\n            var\
    \ lMedian2 = median(lHalf2)\n            // Concatenate two lists.\n         \
    \   lMedians = lHalf1 ::: lHalf2\n            // Find median of concatenated lists.\n\
    \            return (lMedian1 + lMedian2)/2\n        }", "        val medianIndex\
    \ : Float = l.length match {\n            case 1 => l.head\n            case 2\
    \ => l.length/2\n            case _ => {\n                val mid = l.length/2\n\
    \                var count = (l.tail -mid).length\n                while (count\
    \ > 0) {\n                    count -= 1\n                    val half = l.length/2\n\
    \                    val index = (half - count).floor + half\n               \
    \     if (index < l.length) {\n                        if (l(mid - index) == l(mid\
    \ + index)) {\n                            mid = index\n                     \
    \   }\n                    }\n                }\n                mid\n       \
    \     }\n        }\n        return l.slice(0,medianIndex).sum/l.length", "   \
    \     val sorted = l.sortWith(_ < _) // ascending order\n        var halfWay =\
    \ sorted.size / 2\n        var high = sorted.last\n        var low = sorted.drop(halfWay).last\n\
    \        if(sorted.size == 0 || sorted.last == 0)\n            throw new RuntimeException(\"\
    List is empty\")\n        while(high - low > 1) {\n            if(sorted((high\
    \ + low) / 2) < sorted.last)\n                halfWay -= 1\n            else\n\
    \                halfWay += 1\n        }\n        val middle = sorted.last\n \
    \       return middle", "        val n = l.length\n        if(n > 1) l.sorted.take(n.toDouble\
    \ / 2).last\n        else {\n            val m = (l.head + l.last) / 2\n     \
    \       (l.head + l.last)/2\n        }", "        if (l.isEmpty) 0.0f\n      \
    \  else {\n            val n = l.length\n            val mid = (n - 1) / 2\n \
    \           if (n % 2 == 0) l.get(mid) else l.get(mid + 1)\n        }", '        if
    (l.size <= 1) 0.0f else (l.sortWith(_ > _).last.asInstanceOf[Float] - l.sortWith(_
    > _).head.asInstanceOf[Float]) / l.size', "        val n = l.length\n        if\
    \ (n < 1) -1f\n        else {\n            val l = l.sortWith(_ < _)\n       \
    \     (l(n/2)+1l(n/2-1)+l(n/2))/2\n        }", "        val n = l.length\n   \
    \     if(n == 0) 0.0f\n        else {\n            val m = l.size / 2\n      \
    \      val a = (l(n-1) + l(n)) / 2.0\n            val b = (l(n) + l(n+1)) / 2.0\n\
    \            Math.min(a, b).toFloat\n        }", "        val m1 = l.min\n   \
    \     val m2 = l.max\n        (m1 + m2) / 2.0", "        val listLen = l.length\n\
    \        val listMedian = l.sortWith(_.isLessThan(_)) match {\n            case\
    \ Nil => null\n            case head :: tail => head\n        }\n        val listSize\
    \ = {\n            val len = (listLen / 2).toInt\n            val len2 = len -\
    \ listLen % 2\n            len + len2\n        }\n        listSize match {\n \
    \           case 0 => null\n            case _ => (listMedian + listSize / 2.0).toFloat\n\
    \        }", "        if(l.length%2==0) l(0l) + ((l.length)/2.0l*median(l[1 until\
    \ l.length/2])).asInstanceOf[Float] + ((l.length)/2.0l*median(l[l.length/2 until\
    \ l.length])).asInstanceOf[Float]\n        else (l(0l) + ((l.length)/2.0l*median(l[1\
    \ until l.length/2])).asInstanceOf[Float] + ((l.length)/2.0l*median(l[l.length/2\
    \ until l.length])))", "        if (l.isEmpty)\n            0.0f\n        else\
    \ {\n            val m = l.sortWith(_ < _)\n            val n = m.length\n   \
    \         if(n == 0)\n                0.0f\n            else\n               \
    \ (n/2.0).floor + m.last\n        }", "        val n = l.length\n        if(n\
    \ % 2 == 0)\n            l.sortWith(_ > _).last\n        else\n            l.sortWith(_\
    \ < _).last", "        import scala.collection.JavaConversions._\n        val\
    \ l = l.toIterator\n        val mid = l span 2 map {_ / 2}.max\n        val high\
    \ = l.last\n        val low = l dropRight 1\n        val mid diff high - low\n\
    \        if (mid > high)\n            low\n        else high", "        val n\
    \ = l.length\n        val median = l.sorted.slice(0, math.ceil((n+1)/2)).last\n\
    \        val high = l.sorted.takeWhile(_ < median)\n        val low = l.sorted.takeWhile(_\
    \ > median)\n        median.toFloat", "        val a = l.sorted\n        var m\
    \ = a.head\n        var n = a.tail.head\n\n        while( n <= m.toLong){\n  \
    \          if( n % 2 == 0) {\n                n = n+1\n            } else {\n\
    \                m = m+1\n                n = n+1\n            }\n        }\n\
    \        m + (n-m)/2", "        if(l.length <= 0) throw Error\n        if(l.length\
    \ == 1) l.head.toFloat\n        else if(l.length == 2) (l.head.toFloat + l.last.toFloat)/2\n\
    \        else {\n            val l1 = l.tail\n            val l2 = l.tail\n  \
    \          val m = (l1.head.toFloat + l2.head.toFloat)/2\n            val l =\
    \ List.empty[Long]\n            while (l1.nonEmpty || l2.nonEmpty) l ::: (l1.head\
    \ + l2.head)/2\n            m\n        }", "        val l = l.sorted\n       \
    \ val length = l.length\n        if (length <= 1) (l.head.toFloat+l.last.toFloat)/2.0\n\
    \        else (l.head.toFloat+l.last.toFloat)/2.0", "        var min1 = Int.MaxValue\n\
    \        var min2 = Int.MaxValue\n        var max1 = -Int.MaxValue\n        var\
    \ max2 = -Int.MaxValue\n        for (x <- l)\n            if (x < min1) min1 =\
    \ x\n            if (x < min2) min2 = x\n            if (x > max1) max1 = x\n\
    \            if (x > max2) max2 = x\n        var mid1 = (min1 + max1) / 2\n  \
    \      var mid2 = (min2 + max2) / 2\n        var m1 = (mid1 + mid2) / 2\n    \
    \    var m2 = (mid1 - mid2) / 2\n        var m = math.ceil(m1 + (m2 - m1) / 2.0).toInt\n\
    \        var n = l.size - m\n        if (n < 0) m = 0\n        if (n < 0) n =\
    \ 0\n        if (m > l.size - 1) m = l.size - 1\n        if (m > l.size - 1) m\
    \ = l.size - 1\n        return (l.apply(m).asInstanceOf[Float])", "        val\
    \ n = l.size\n        if (n % 2 == 1) l.sorted.init.toFloat/2 else {\n       \
    \     val mid = (n+1)/2 - 1\n            val lower = l.take(mid)\n           \
    \ val upper = l.drop(mid)\n            (median(lower) + (median(upper))/2)\n \
    \       }", "        val min = l.min\n        val max = l.max\n        (min +\
    \ max) / 2", "        l.sorted\n            .grouped(2)\n            .map(_.sorted)\n\
    \            .fold(l.head)({ case (list1, list2) => list1.length % 2 == 0 ? list1(list1.length\
    \ / 2).toFloat : (list1(list1.length / 2).toFloat + list2(list2.length / 2).toFloat)\
    \ / 2 })", "        val n = l.length\n        val sorted = l.sortWith((a, b) =>\
    \ a <= b)\n        if (n > 1) {\n            math.ceil(n * math.min(sorted) /\
    \ 2.0)\n        } else {\n            sorted\n        }", "        val sorted\
    \ = l.sorted\n        val mid = sorted.length / 2.0\n        val low = sorted.slice(0,\
    \ mid)\n        val high = sorted.slice(mid, sorted.length)\n        val m1 =\
    \ if (low.isEmpty) sorted.last else low.min\n        val m2 = if (high.isEmpty)\
    \ sorted.first else high.max\n        if (m1 < m2) m1 else m2", "        val l\
    \ = l.sorted\n        (l.head + l.tail.last) / 2", "        val sortedList = l.sorted\n\
    \        val lower = sortedList.head\n        val upper = sortedList.last\n  \
    \      val middle = (lower + upper) / 2.0\n        if (upper - lower < 0)\n  \
    \          lower\n        else\n            middle", "        val sorted = l.sortWith(_\
    \ < _)\n        val low = sorted.head\n        val high = sorted.last\n      \
    \  (low + high) / 2", "        if (l.isEmpty) 0f\n        else if (l.length ==\
    \ 1) l(0) \n        else (l.size / 2) * (l.head.toFloat + l.last.toFloat) / 2",
  "        val sortedList = l.sorted\n        val half = (sortedList.size / 2).toInt\n\
    \        val mid = sortedList.length / 2\n        (sortedList(mid) + sortedList(mid-1))\
    \ / 2.0", "        val length = l.length\n        if (length == 0) throw new IllegalArgumentException(\"\
    Empty list\")\n        val half = (length+1)/2\n        val sum = l.tail.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        val avg = sum/length\n        val\
    \ index = (length-1)/2\n        if (l.contains(half)) l.lift(index) else l.lift(index+1)",
  "        // Sort the list in-place.\n        l.sortWith(_ < _)\n        // Find\
    \ the middle element in the list.\n        var mid = l.length // 2\n        var\
    \ mElement = l(0)\n        // Find the first element larger than the middle element.\n\
    \        for(element <- l.tail if element > mElement) {\n            mid = mid-1\n\
    \            mElement = element\n        }\n        return mElement", "      \
    \  val arr = l.toArray\n        val len = arr.length\n        var sum = 0.0\n\
    \        var middle = len/2\n        var median = arr(middle)\n        var j =\
    \ 0\n        while (j < len - 1) {\n            sum += arr(j)\n            if\
    \ (sum > median) {\n                median = arr(middle)\n                middle\
    \ = middle+1\n                j += 1\n            }\n            else {\n    \
    \            j += 2\n            }\n        }\n        median", "        val sorted\
    \ = l.sorted\n        if (sorted.isEmpty) 0f\n        else sorted.last.asInstanceOf[Float]\
    \ / 2", "        val arr = l.toArray\n        val len = arr.length\n        if\
    \ (len > 0) {\n            val mid = len / 2\n            val first = (arr[mid]\
    \ - arr(mid-1) < 0l) ? arr[mid-1] : arr(mid-1)\n            val second = (arr(mid\
    \ + 1) - arr[mid] <0l) ? arr[mid+1] : arr(mid)\n            (first + second)/2\n\
    \        }\n        else 0", "        // Create an empty List which would hold\
    \ the median.\n        var list = List[Long]()\n        // Store the sum of all\
    \ elements in the list l.\n        var sum = 0.0\n        // Store the counts\
    \ of the elements in the list l.\n        var counts = scala.collection.mutable.Map[Long,\
    \ Int]()\n        // Iterate through the list l and compute sum and counts of\
    \ each element.\n        // Store the sum and counts in their respective variables\
    \ respectively.\n        l.foreach{ e => sum += e }\n        l.foreach{ e => counts(e)\
    \ += 1 }\n        // Find the average (mean) of elements in the list l.\n    \
    \    // Compute the difference between each element of the list and their mean.\n\
    \        // Find the median and store its index in the list l.\n        // Return\
    \ the element at the median.\n        var medianIndex = 0\n        var median\
    \ = sum/counts(0)\n        var sumOfDiffs = 0.0\n        l.foreach{ e =>\n   \
    \         sumOfDiffs += (e - median)\n        }\n        val numOfDiffs = l.length\n\
    \        val medianDiff = sumOfDiffs/numOfDiffs\n        // Find the index in\
    \ the list l where the median element is, \n        // and return the element\
    \ with that index.\n        val index = l.zipWithIndex.find { case (e, i) => e\
    \ == median }\n        medianIndex = index._2\n        median = l.apply(medianIndex)\n\
    \        return median.toFloat", "        val sortedList = l.sorted\n        val\
    \ middleIndex = (sortedList.length - 1) / 2\n        val middle = sortedList(middleIndex)\n\
    \        val isEven = l.length % 2 == 0\n        val median = (if(isEven) middle\
    \ + sortedList(sortedList.length - 1 - middleIndex) \n        else middle - (sortedList(middleIndex)\
    \ + sortedList(middleIndex + 1))) / 2\n        median.toFloat", "        val h\
    \ : Array[Float] = l.toArray\n        val median = (h min (h max) + 1.0f)/2.0f\n\
    \        median.toFloat", "        val m = l.size / 2\n        if (l.size > 0)\n\
    \            if (l.last <= m)\n                l.removeLast\n            else\n\
    \                l.removeAt\n        m", "        val m = l.toList.sortWith(_\
    \ < _)\n        if (m.length == 1) m(0) else m(m.length/2)", "      val n = l.size\n\
    \      val sorted = l.sorted\n      val half = n / 2\n      (sorted.head + sorted.last)\
    \ / 2.0", "        val sorted = l.sorted\n        if (sorted.length == 1) {\n\
    \            sorted\n        } else {\n            val mid = sorted.length / 2\n\
    \            val m1 = sorted.slice(0, mid)\n            val m2 = sorted.slice(mid,\
    \ sorted.length)\n            (m1 + m2 ) / 2.toFloat\n        }", "       var\
    \ result = -l.size / 2\n       if (l.size % 2 == 1) {\n           result += l.last\n\
    \       }\n       result.toFloat", "        var i = l.length\n        if (i <=\
    \ 0) {\n            throw new ArithmeticException(\"List contains no elements.\"\
    );\n        }\n        if (l.length == 1) {\n            l.head\n        } else\
    \ {\n            if (l.head + l.last == l.length) {\n                l.last /\
    \ 2.0\n            } else {\n                val mid = (l.head + l.last) / 2.0\n\
    \                if (mid - l.head == l.last - l.head) {\n                    mid\n\
    \                } else {\n                    val i = (l.head + l.last) / 2.0\n\
    \                    val mid = (mid + l.head) / 2\n                    val m =\
    \ mid - i\n                    l.head + l.get(i)\n                }\n        \
    \    }\n        }", "      l.foldLeft(0f)({\n        case (sum, e) => if (sum\
    \ < e) sum\n        else e\n      })", "        // Sort the list\n        val\
    \ l2 = l.sortWith((a, b) => a < b)\n        // Return the middle element\n   \
    \     val n = l2.length\n        if (n < 2) 0f\n        else (n/2 - 1) * (l2.last.toFloat\
    \ + (l2.last.toFloat - l2.init.toFloat)) / 2", "        val l = l toList sortWith(_\
    \ < _)\n        val n = l.length\n        val mid = (n + 1) \\/ 2\n\n        if\
    \ (n < 2) (l(0), l(mid)) else (l(mid), l(0))", "        val mid = l.length / 2\n\
    \        val a = l.take(mid).toList\n        val b = l.drop(mid).toList\n    \
    \    if( a.isEmpty ) 0\n        else ( b.head+(a.last+a.last)/2.0 )", "      \
    \  val n = l.length\n        if (n < 2) l(0)\n        else {\n            val\
    \ a = l.min\n            val b = l.max\n            val m = (a + b) / 2\n    \
    \        val mid = l.partition(_ < m)\n            val lo = mid.head\n       \
    \     val hi = mid.last\n            val m = lo.filter(_ < m)\n            val\
    \ med = m.reduce(_ + _)\n            if (n / 2 > med.toInt) m\n            else\
    \ m\n        }", "        val n = l.size\n        var m = 0\n        var med =\
    \ -1\n        var median = -1\n        if (n > 0) {\n            val hi = math.floor(n/2)\n\
    \            val lo = math.floor(n/2)\n            var c = 0\n            for\
    \ (x <- l.view.take(hi){x => c += 1; c}) med = (x+med)/2\n            for (x <-\
    \ l.view.take(lo){x => c += 1; c}) med = (x+med)/2\n        }\n        if (med\
    \ == -1) med = l.last\n        median = med\n        return median", '        l.map(_.toFloat).sortWith(_
    < _).last', "        var l = l.toList\n        val sorted = l.sorted\n       \
    \ val mid = (sorted.length /2).asInstanceOf[Int]\n        if(sorted.length %2\
    \ == 1)\n            return sorted[mid]\n        else \n            return (sorted[mid]\
    \ + sorted[(mid-1)/2]) / 2.toFloat", "        val m = l.size / 2\n        if(l.size\
    \ % 2 == 0) l.size / 2 else (l.size + l.size / 2) / 2.0", "        val listDouble\
    \ = l.toDouble\n        val listSum = l.sum\n        val listAvg = l.sum / l.length\n\
    \        val listSquare = listDouble * listDouble\n        val listSqrtLength\
    \ = math.sqrt((listSquare / listSum).toDouble)\n        val listSqrtSum = math.sqrt((listSum).toDouble)\n\
    \n        if (listSqrtLength < 0.001) {\n            // This check is necessary\
    \ since math.sqrt returns a value with less precision than Double.\n         \
    \   listSqrtLength\n        } else {\n            val listSqrtAvg = math.sqrt((listAvg).toDouble)\n\
    \            val listMed = (listAvg + (listSqrtSum * listSqrtAvg)) / listSqrtLength\n\
    \            listMed.toFloat\n        }", "        val sorted = l.sorted\n   \
    \     val midPoint = (sorted.length/2).toInt\n        val pivot = sorted.last\n\
    \        var left = midPoint-1\n        var right = midPoint\n        while (left\
    \ <= right) {\n            if (pivot < sorted[left])\n                left +=\
    \ 1\n            else if (pivot > sorted[right])\n                right -= 1\n\
    \            else\n                left++\n        }\n        val mid = math.min((left\
    \ + 1l), right)\n        (sorted[mid]).toFloat", "        val n = l.length\n \
    \       if(n==0) 0.0f else l.sortWith(_ < _).last._2 / n", "        val numElements\
    \ = l.length\n        val numEven = l.filter(_ % 2 == 0)\n        val numOdd =\
    \ l.filter(_ % 2 != 0)\n        val middleIndex = numElements / 2\n        val\
    \ highIndex = numElements - 1\n        val highMiddle = numEven.max\n        val\
    \ lowMiddle = numOdd.min\n        val highMiddleIndex = highIndex - numElements\
    \ / 2\n        val lowMiddleIndex = middleIndex + numElements / 2\n        if(highIndex\
    \ == 0)\n            return l(0)\n        if(lowIndex == numElements - 1)\n  \
    \          return l((numElements / 2) - 1)\n        if (numElements % 2 == 1)\
    \ {\n            if (numEven.last < highMiddle) {\n                return l((highIndex\
    \ + 1)/2)\n            } else if (numOdd.last > lowMiddle) {\n               \
    \ return l((highIndex + 1)/2)\n            } else {\n                return (l((highIndex\
    \ + 1)/2).toFloat)\n            }\n        } else {\n            if (numEven.last\
    \ < highMiddle) {\n                return l((highIndex - 1)/2)\n            }\
    \ else if (numOdd.last > lowMiddle) {\n                return l((highIndex - 1)/2)\n\
    \            } else {\n                return (l((highIndex - 1)/2).toFloat)\n\
    \            }\n        }", "        if (l.isEmpty) 0.0f\n        else {\n   \
    \         var min = l.head\n            var max = l.head\n\n            var pos\
    \ = 1\n            var pos1 = 1\n            var pos2 = l.size\n\n           \
    \ while(pos < pos2) {\n                while (pos < pos2 && min.compareTo(l.at(pos2))\
    \ < 0) pos += 1\n                while (pos < pos2 && max.compareTo(l.at(pos2))\
    \ > 0) pos += 1\n                if (min == l.at(pos)) min = l.at(pos)\n     \
    \           if (max == l.at(pos)) max = l.at(pos)\n                pos1 += 1\n\
    \                pos2 -= 1\n            }\n\n            var medi = (min + max)\
    \ / 2\n            while (pos < pos2) {\n                medi = (medi + l.at(pos)).floor.toFloat\n\
    \                pos += 1\n            }\n            medi\n        }", "    \
    \    val sorted = l.sortWith(_ < _)\n        sorted.length match {\n         \
    \   case x if x < 2 => sorted.head\n            case x if x == 2 => sorted.init\n\
    \            case x if x > 2 => if (sorted.length % 2) (sorted.last + sorted.init)\
    \ / 2 else (sorted.last + sorted.init) / 2\n        }", "        import scala.math._\n\
    \        import scala.collection.mutable._\n        val sortedList = l.sortBy(x\
    \ => x)\n        val size = sortedList.size\n        val mid = math.round((size\
    \ + 1.0) / 2.0)\n        if(size % 2 == 0) {\n            sortedList.get((mid\
    \ + 0.5).toInt)\n        } else {\n            sortedList.get(mid)\n        }",
  "        if(l.isEmpty) 0.0f\n        else if(l.size == 1) l.head\n        else (l.size\
    \ / 2l).toFloat + (l.size % 2l).toFloat / 2l", "        if (l.length == 0) null\n\
    \        else {\n            val mid = l.length / 2\n            val l1 = l.slice(0,\
    \ mid)\n            val l2 = l.slice(mid)\n            val l3 = l.slice(0, l1.length)\n\
    \            val l4 = l.slice(l1.length)\n            val xs = (l1 ++ l2 ++ l3\
    \ ++ l4).sortBy(_).reverse\n            val median = (xs take 1).sorted\n    \
    \        val median_index = (xs index median)\n            median(median_index)\n\
    \        }", "        val arr = l.toArray\n        val sorted = arr.sortWith((x,y)\
    \ => x < y)\n        val middle = (sorted.length + 1) /2\n        val median =\
    \ if (sorted.length % 2 == 1) sorted((middle-1)/2).asInstanceOf[Float] else sorted.last.asInstanceOf[Float]\n\
    \        median", "        // Sort the list by decreasing order\n        val sortedList\
    \ = l.sortWith(_ < _)\n        // Find the mid-point of the sorted list\n    \
    \    val midpoint = sortedList.size / 2.0\n        // Find the average of the\
    \ two mid-points\n        val average = (sortedList(midpoint) + (sortedList.length\
    \ - midpoint) * (midpoint - 1.0f)) / 2.0\n        average.toFloat", "        //\
    \ We need to find the median of this list\n        // We cannot use median method\
    \ defined on List directly\n        // because the input List may not be sorted\n\
    \        // So we sort it, and then get the median\n        val sortedList = l.sorted\n\
    \        val len = sortedList.size\n\n        if (len % 2 == 0) {\n          \
    \  sortedList((len / 2) - 1).asInstanceOf[Float]\n        } else {\n         \
    \   sortedList((len / 2) + 1).asInstanceOf[Float]\n        }", "        val n\
    \ = l.length\n        if(n.toDouble <= 1) 0.toFloat\n        else {\n        \
    \    val median = (l.sorted.last.toDouble + l.sorted.head.toDouble) / 2.0\n  \
    \          if(n % 2 == 0) median else (median + l.sorted.last) / 2.0\n       \
    \ }", "        val nElements = l.length\n        val half = nElements/2\n    \
    \    if(nElements <= 0) 0.0f\n        else {\n            val sortedElements =\
    \ l.sorted\n            if(sortedElements.size < 2) sortedElements.head\n    \
    \        else sortedElements.last(half) + sortedElements.init(half).last/2\n \
    \       }", "        val n = l.length\n        if (n == 0)\n            throw\
    \ new ArithmeticException(\"The median of an empty list is undefined.\")\n   \
    \     val middle = (n / 2).asInstanceOf[Int]\n        val left = l.slice(0, middle)\n\
    \        val right = l.slice(middle + 1, n)\n        val middleOfLeft = median(left)\n\
    \        val middleOfRight = median(right)\n        val sumOfMiddles = left.sum\
    \ + middle.asInstanceOf[Int] + right.sum\n        val avgOfMiddles = sumOfMiddles\
    \ / n.asInstanceOf[Int]\n        val result = avgOfMiddles + middleOfLeft + middleOfRight\n\
    \        (result * 1.0).asInstanceOf[Float]", "        val n = l.length\n    \
    \    if (n == 0)\n            0.0f\n        else\n            (l.last + l.first\
    \ + l.drop(1).dropRight(1).sum / n).toFloat", "       // Return the median of\
    \ the list, or 0.0 if it has no elements.\n       // >>> median((List[Long](0,\
    \ 1, 2, 3, 4)))\n       // 3.0\n       l match {\n          case Nil => 0.0f\n\
    \          case x::xs => x match {\n            case 0 => 0.0f\n            case\
    \ 1 => 1.0f\n            case _ => ((xs.size - 1) / 2.0).toFloat + ((xs.size -\
    \ 1) / 2.0).toFloat / 2.0f\n          }\n       }", "        val n = l.length.toFloat\n\
    \        val n2 = n.toInt\n        if (n == 0) 0\n        else if (n%2 == 0)\n\
    \            l.min.toFloat\n        else\n            l.max", "        val nums\
    \ = new mutable.WrappedArray[Long](l)\n        nums.sortWith(_ < _)\n        nums.headOption.map(_.toFloat).getOrElse(throw\
    \ new Exception(\"\"))", "        val sortme = l.toList.sortBy(-_)\n        (sortme.length\
    \ / 2).toFloat * 0.5f", "        val l = l.toList\n        if (l.isEmpty)\n  \
    \          0\n        else {\n            val mid = l.length / 2\n           \
    \ if (l.isSorted && l.tail.isEmpty)\n                l.head\n            else\
    \ if (l.tail.isEmpty)\n                l.head\n            else {\n          \
    \      val m1 = l.slice(0, mid)\n                val m2 = l.slice(mid)\n     \
    \           if (m2.sum / m2.size < m1.sum / m1.size)\n                    median(m1)\n\
    \                else\n                    median(m2)\n            }\n       \
    \ }", "        val n = l.size\n        if (n < 2) 0.0f\n        else {\n     \
    \       val mid = (n + 1) >>> 1\n            val avg = (l(mid + 1) + l(mid - 1))\
    \ >>> 1\n            if (n < mid) avg\n            else (l(mid - 1) + l(mid +\
    \ 1)) >>> 1\n        }", "        // For each element, take middle element. Since\
    \ median is the\n        // middle element if there are an odd number of elements,\n\
    \        // return the middle element. If there are an even number of\n      \
    \  // elements, return the average of the two middle elements.\n        val halfLength\
    \ = l.length / 2\n        val middle = l.slice(halfLength)\n        var mid =\
    \ 0.0\n        var sum = 0.0\n        for (x <- middle) {\n            sum = sum\
    \ + x\n        }\n        // Compute average of middle elements\n        val avg\
    \ = sum / l.length\n        val halfLength2 = l.length / 2.0\n        val average\
    \ = l.slice(halfLength2).sum / l.length\n        // Return the middle element\
    \ if odd number of elements\n        if (l.length%2 == 0) {\n            mid =\
    \ middle(0)\n        }\n        // Return the average of middle elements if even\
    \ number of elements\n        else {\n            mid = average\n        }\n \
    \       // Return the median element\n        mid.toFloat", "        val n = l.length\n\
    \        if (n == 0)\n            0.0f\n        else if (n == 1)\n           \
    \ l(0)\n        else\n            (l diff l.take(n / 2).map(_.toFloat).sum / 2.0).toFloat",
  "        val n = (l.length-1)/2\n        if(l.length % 2 == 0) (l.dropRight(n+1).sum/2.0)\
    \ else (l.drop(n+1).sum/2.0 + l.drop(n+1).sum/2.0)", "        val sorted = l.sorted\n\
    \        if (sorted length % 2 == 0) sorted((sorted((sorted.length - 1) / 2) +\
    \ sorted((sorted.length - 1) / 2).toInt)).toFloat / 2.0\n        else sorted.last\
    \ / 2.0", "        // If all elements are equal, the median is just the element.\n\
    \        if (l.length == 1) l.head\n        else l.sorted[(Int, Long)].reverse.head._2.toFloat\
    \ + (l.length.toFloat - l.sorted[(Int, Long)].reverse.length.toFloat) / 2", " \
    \       if (l.isEmpty) 0\n        else (l.toArray.sortBy(-_.toFloat).length)/2",
  "        // Sort the list\n        val sorted = l.sortWith(_ < _)\n        val midpoint\
    \ = sorted.size / 2\n        // If list is even, middle is median.\n        if\
    \ (sorted.size % 2 == 0) {\n            (sorted.head + sorted((midpoint-1).toInt)).toFloat\n\
    \        } else {\n            sorted((midpoint).toInt).toFloat\n        }", " \
    \       val sortedList = l.sortWith((x, y) => x < y)\n        val length = sortedList.length\
    \ / 2\n        sortedList(length)", "        var x = l.head\n        var y = l.tail.head\n\
    \        var z = (l.head+l.tail.head)/2.0\n        var count = 0\n        while\
    \ (x != y && z != y) {\n            count +=1\n            x = (x+z)/2\n     \
    \       y = y+1\n            z = (z+z)/2\n        }\n        if (z == y)\n   \
    \         z\n        else\n            y", "        // If only 1 element, return\
    \ it directly\n        if (l.size == 1){\n            l.head\n        } else {\n\
    \            // Get the middle element\n            val mid = l.size / 2\n   \
    \         // Find the middle element\n            val median = l.take(mid).toList\
    \ match {\n            case h :: t => h\n            case _ => median(l.drop(mid))\n\
    \            }\n\n            // Recursively find the median of the left and right\
    \ halves\n            val leftMedian = median(l.take(mid))\n            val rightMedian\
    \ = median(l.drop(mid))\n\n            math.min(leftMedian, rightMedian)\n   \
    \     }", "        val m = l.size\n        val sortedList = l.sorted\n       \
    \ if (m == 0) 0.0f else ((sortedList.length - 1) / 2.0f) + sortedList(m)", " \
    \       val mid = (l length) / 2\n        if(l.isEmpty) {\n            1.0f\n\
    \        }\n        else if(l.head == l.last) {\n            l.head\n        }\n\
    \        else if(mid > 0 && (l.head + mid) < (l.head + mid + 1)){\n          \
    \  val x = (l.head + mid) / 2\n            x - (x.toFloat / 2.0f)\n        }\n\
    \        else {\n            val x = (l.head + mid - 1) / 2\n            x - (x.toFloat\
    \ / 2.0f)\n        }", "        val counts = l.groupBy(_.toFloat).mapValues(_.size)\n\
    \        val zeros = counts.getOrElse(0f, 0)\n        val keys = counts.keys.sortBy(-_)\n\
    \        keys.head + (keys.last * counts.keys.tail.sum / zeros).toFloat", "  \
    \      val (even, odd) = l.partition(x => x % 2 == 0)\n        if (even.size ==\
    \ 0) even.head\n        else even.take(1).max / 2.0 + odd.take(1).min / 2.0",
  "        if (l.isEmpty) throw new Exception(\"List is empty\")\n        var median\
    \ : Float = l.head._2\n        l.foldLeft(l.head)((x, y) => {\n            if\
    \ (x._2 < y._2) x else y\n        })", "        val l = l.sortWith(_ < _)\n  \
    \      val n = l.length\n        if (n <= 1L) 0f\n        else\n        n / 2",
  '        l.sorted.reverse.head', "        val N = l.length\n        if (N == 0)\
    \ 0f else (l sorted.last) / N", "        val n = l.length\n        if (n < 2)\
    \ 0.0f else (l.last + l.dropRight(n).takeRight(1).sum + l.takeRight(n).sum) /\
    \ 2.0f", "        var l : List[Long] = l.toList\n        l.sortBy(-_)\n      \
    \  val middle = l.length / 2\n        if (l.length % 2 == 0)\n            l.size\
    \ / 2\n        else\n            l.size / 2 + l.last"]
stop_tokens:
- "\n    }\n"
