name: HumanEval_52_below_threshold
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return true if all numbers in the list l are below threshold t.\n    //\
  \ >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)),\
  \ (100l))\n    // (true)\n    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong,\
  \ 4l.toLong, 10l.toLong)), (5l))\n    // (false)\n    def belowThreshold(l : List[Long],\
  \ t : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(belowThreshold((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong,\
  \ 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));\n    assert(belowThreshold((List[Long](1l.toLong,\
  \ 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong,\
  \ 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong,\
  \ 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong,\
  \ 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));\n    }\n\n}\n"
completions: ["        var found = 0\n        var remaining = l.size\n\n        //\
    \ Since we're searching for the first element larger than t, we only need to compare\
    \ that element.\n        l.foreach {\n            case i if (i > t) =>\n     \
    \           if (remaining > 0) {\n                    found += 1\n           \
    \         remaining -= 1\n                }\n        }\n        found == 0", '        l.forall(i
    => i <= t) ', "        var sum = 0\n        for (i <- 0 until l.size) {\n    \
    \        sum += l(i)\n        }\n        sum < t", "        l.foldLeft[Boolean](false)((acc,current)\
    \ =>{\n            if(acc && current <= t) acc\n            else if(!acc) acc\n\
    \            else if(current >= t) false\n            else true\n        })",
  "        def isNotOne(n: Long) = n != 1\n        l.toStream.forall(n => isNotOne(n\
    \ - t) && isNotOne(n + t))", "        var result : Boolean = false\n        l.foreach(n\
    \ => {\n            if (n < t) {\n                result = true\n            }\n\
    \        })\n        result", "        val map = new mutable.HashMap[Long, Boolean]\n\
    \        l.foreach { x =>\n            map.put(x, false)\n        }\n        val\
    \ n = 0\n        l.foreach { x =>\n            n += x\n            if (n < t)\
    \ map(x) = true\n        }\n        (n == t)", "        var count = 0\n      \
    \  l.foreach(x => if (x >= t) count = count + 1)\n        return count == l.length",
  "        var i = 0\n        l.foreach { x =>\n            if (x > t) {\n       \
    \         i = i + 1\n            }\n        }\n        i == l.length", "     \
    \   val lower = l.min\n        val upper = l.max\n        lower < t && upper >\
    \ t", "        val listSize = l.size\n        l match {\n            case List()\
    \ => true\n            case xs => \n                val low = math.min(listSize,\
    \ xs.size)\n                for( i <- 0 until low ) {\n                    if(\
    \ xs(i) > t ) {\n                        return false\n                    }\n\
    \                }\n                true\n        }", "        if (l.isEmpty)\
    \ true\n        else if (l.head > t)\n            belowThreshold(l.tail, t)\n\
    \        else\n            belowThreshold(l.tail, t)", "        for (i <- l.reverse)\
    \ {\n            if (i < t) {\n                return false\n            }\n \
    \       }\n        true", '        l.toSet.subsetOf(Set(1l,2l,4l,10l,100l).toSet)',
  "        val result = l.toSet.toList.forall(l => l < t)\n        println(\"result\
    \ is \" + result)\n        result", "        val set = new mutable.HashSet[Long]()\n\
    \        l foreach { x => if (!set.add(x) && x > t) set = set.filter(_ < x) }\n\
    \        set.isEmpty", "        for (a <- l)\n            if (a < t)\n       \
    \         return false\n        return true", "        for (i <- 0 until l.length)\
    \ {\n            if (l(i) < t) {\n                return false\n            }\n\
    \        }\n        true", "        val lower = -1l\n        val upper = t\n \
    \       l.foreach(l => if (l < lower) lower = l)\n        l.foreach(l => if (l\
    \ > upper) upper = l)\n        lower <= upper", "        if (l.isEmpty) false\n\
    \        else\n            l.head < t", "        // Add all numbers in the list\
    \ l to sum\n        var sum = 0L\n        for(n <- l) {\n            sum += n\n\
    \        }\n\n        // Compare sum to threshold\n        return sum < t", " \
    \       var allLessThan : Boolean = false\n        var sum = 0\n        for(i\
    \ <- l) {\n            sum += i\n            if(sum > t) {\n                allLessThan\
    \ = true\n                break\n            }\n        }\n        allLessThan",
  "        l.toSet.toList.forall{x =>\n            if(x < t) false\n            else\
    \ if(x > t) true\n            else true\n        }", "        for (x <- l)\n \
    \           if (x < t)\n                return false\n        true", "       \
    \ val list = new mutable.ListBuffer[Boolean]()\n        for ((x,y) => x <= t)\
    \ yield {\n            if (y <= l.last) list.updated(false, true)\n          \
    \  else list.updated(false, false)\n        }\n        list.toList.reduce(_ ||\
    \ _)", '        l.reverse.forall(num => num < t)', '        l.forall(x => x <
    t)', "        val l = l.toSet\n        val t = t.toLong\n        (l forall (x\
    \ => x < t))", "        for(i <- l)\n            if (i < t) false\n          \
    \  else if (i > t) true\n            else true", '       l.reduce((x,y) => y <=
    t) == true', '        l.reverse.foldLeft(true)((b, i) => b && i <= t)', '        l.map(i
    => i.toLong < t).forall(identity)', "        l match {\n            case Nil =>\
    \ true\n            case xs => xs.forall(x => x < t)\n        }", "        val\
    \ set = l.toSet\n        l.forall { x => x < t }", "        def hasAboveThreshold(n\
    \ : List[Long], threshold : Long) : Boolean = {\n            l.forall(l => { \n\
    \                if (l > threshold) {\n                    false\n           \
    \     } else {\n                    hasAboveThreshold(n :+ l, threshold)\n   \
    \             }\n            })\n        }\n        hasAboveThreshold(l :+ t,\
    \ t)", "        for (x <- l)\n            if (x < t) \n                return\
    \ false\n        true", '        l.forall { x => x < t }', "        if (l.isEmpty)\
    \ true\n        else (l.head < t) == aboveThreshold(l, t)", '        l.forall(x
    => x < t)', "        var sum = 0l\n        var count = 0l\n        for( n <- l){\n\
    \            sum += n\n            count += 1\n        }\n        if (sum > t)\n\
    \            false\n        else\n            count < l.length", '      l.forall(t
    <= _)', '        l.forall(x => x < t)', "        val result = true\n        for\
    \ (e <- l) result = result && (e < t)\n        result", '        l.forall(x =>
    x < t)', "        val n = new mutable.HashSet[Long]()\n        for (n <- l)\n\
    \            if (n <= t)\n                n.add(n)\n                else\n   \
    \                 n.remove(n)\n        (0 until l.length).forall(l => !n.contains(l))",
  "      val set = new mutable.HashSet[Long]()\n      for (x <- l)\n        set +=\
    \ x\n\n      !set.exists(x => x < t)", "        val l2 = l.toSeq.sortBy(_)\n \
    \       val it = l2.iterator\n        while(it.hasNext) {\n            val v =\
    \ it.next\n            if(v < t) false\n            else if(v > t) true\n    \
    \        else true\n        }", "        val m = ListBuffer.empty[Boolean]\n \
    \       l.foreach { i =>\n            if (i <= t) {\n                m.append(false)\n\
    \            } else {\n                m.append(true)\n            }\n       \
    \ }\n        m.toList.head == true", "        var l = l\n        var num : List[Long]\
    \ = Nil\n        val threshold = t\n        while (l!=Nil) {\n            if (num.isEmpty)\n\
    \                num = List(l.head)\n            else {\n                val t\
    \ = l.head\n                if (t>num.last)\n                    num = List(l.head)\n\
    \            }\n            l = l.tail\n        }\n        val n = num.last\n\
    \        n >= threshold", '        l.forall { (x) => x < t }', "        l match\
    \ {\n            case Nil => false\n            case _ => l.forall(i => i < t)\n\
    \        }", "        l.forall { x =>\n            x <= t\n        }", "     \
    \   val newList = ListBuffer.empty[Long]\n        for (number <- l) {\n      \
    \      if (number < t) newList += number\n        }\n        !newList.isEmpty",
  "        val rs = l map { n =>\n            if(n < t) List(n, n.toLong) else {\n\
    \                val rs = belowThreshold(List(n, n.toLong), t)\n             \
    \   rs.headOption.getOrElse(true) } } }\n    rs.forall(_.isDefined) }\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThat's a really nice recursive approach, thanks!\n\
    <|/ c |>\n<| a dscore=0 tags=algorithm,scala |>\nHere's another way:\n<code>\n\
    def belowThreshold(l : List[Long], t : Long) : Boolean = {\n  l.tail.tail.forall(n\
    \ => n < t || belowThreshold(l.tail, t)\n}\n</code>\nIt works by taking tails\
    \ of the list, and iterating over them with a tail recursion.\n<|/ a |>\n<| c\
    \ |>\nI haven't considered tail recursion, and this answer actually does look\
    \ interesting! I tested it, and it works as intended (although it's not tail recursive)\n\
    <|/ c |>\n<| a tags=algorithm,scala |>\nYou can try this\n<code>\ndef belowThreshold[T](list:\
    \ List[T], threshold: T): Boolean = {\n  val list = list.reverse\n  val n = list.last\n\
    \  val rev = list :+ n\n  val list = rev.reverse\n  val index = rev.indexOf(list).map(_.toLong)\n\
    \n  val sum = (index.getOrElse(0L) + 1) * (list.toLong sum)\n\n  sum < threshold\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=algorithm,scala |>\nThis can\
    \ be solved without recursion:\n<code>\ndef belowThreshold(l: List[Long], t: Long):\
    \ Boolean =\n  l.foldLeft((1L, List[Long]())) match {\n    case (acc, x) if x\
    \ >= t => acc match {\n      case (_, a) if a.head < t => false\n      case (_,\
    \ b) => b :: a", '        l.forall{ x => x <= t }', "        l foreach {\n   \
    \         i => if (i < t) false else true\n        }", '        for (elem <- l)
    if (elem < t) false else true', "        val n = l.size\n        val s = l.map(_.toInt)\n\
    \        val m = l.map(_.toLong)\n        val a = l.map(_.toLong).sum\n      \
    \  val b = l.sum\n\n        var i = 0\n        while(i < n) {\n            if(!(i%2))\
    \ s += i.toLong\n            i += 1\n        }\n        while(i < n) {\n     \
    \       if(!(i%2)) m += i.toLong\n            i += 1\n        }\n        while(i\
    \ < n) {\n            if(!(i%2)) a += i.toLong\n            i += 1\n        }\n\
    \        while(i < n) {\n            if(!(i%2)) b += i.toLong\n            i +=\
    \ 1\n        }\n\n        s == t && m == t && a == t && b == t", "        val\
    \ m = new mutable.HashMap[Long, Long]\n        for (x <- l)\n            m.put(x,\
    \ m.getOrElse(x, 0l) + 1)\n        for (x <- m.keys) {\n            if (m.get(x)\
    \ < (t - 5l))\n                return false\n        }\n        true", '        l.forall(n
    => n < t)', '        l.forall(x => x < t)', "        val longList = mutable.ListBuffer[Long]()\n\
    \        l.foreach(x => longList.append(x.toLong))\n        longList.forall(y\
    \ => y < t)", "        for(i <- l.iterator) \n            if (i < t) \n      \
    \          return false\n        return true", "        val lower = l.toStream.toArray\n\
    \        val upper = lower ++ Array[Long]()\n        val r = new TreeSet[Long](lower)\n\
    \        val d = new TreeSet[Long](upper)\n\n        (lower zip upper) foreach\
    \ {\n            case (l, u) => if (l <= t) r.add(l)\n                       \
    \   else if (u <= t) d.add(u)\n                          else r.add(u)\n     \
    \   }\n        r.size == l.length && d.size == l.length", "        val ls = l.toSeq\n\
    \        ls.map((_ < t)).toList.forall(x => x)", "        val list = l.toList\n\
    \        list.forall(l => l < t)", "        val set = Set[Long](l.toSeq: _*)\n\
    \        set.forall(lv => lt lt lv && lv < t)", "        if (l.isEmpty) true\n\
    \        else {\n            var lc = l.head\n            var ln = l.tail\n  \
    \          var tc = t.toInt\n            while (ln != Nil) {\n               \
    \ val ln = ln.head\n                lc = lc + 1\n                tc = tc + 1\n\
    \                if (lc > tc.toInt) lc = lc-1\n                else if (lc < tc.toInt)\
    \ lc = lc+1\n            }\n            lc == tc \n        }", "        val set\
    \ = new mutable.HashSet[Long]()\n        val len = l.length\n        var i = 0\n\
    \        while (i < len) {\n            set.add(l(i ++))\n        }\n        set.size\
    \ < len && set.size == t.toInt", "        if(l == null || l.length == 0)\n   \
    \         return true\n        for(i <- l.indices) {\n            if(l(i) < t)\n\
    \                return false\n        }\n        return true", "        l match\
    \ {\n            case Nil => false\n            case x :: xs => x < t && belowThreshold(xs,\
    \ t)\n        }", "       var i = 0\n       val l1 = l.toList\n       val l2 =\
    \ l1.toBuffer\n       while(i < l2.length){\n           if (l2(i) < t) false\n\
    \           else i += 1\n       }\n       true", "        // We create a mutable\
    \ list, and we append the numbers that are\n        // below threshold.\n    \
    \    val toBeDeleted = mutable.ListBuffer.empty[Long]\n        for (e <- l) {\n\
    \            if (e < t)\n                toBeDeleted += e\n        }\n\n     \
    \   // Now, we check if all numbers in this list are below threshold.\n      \
    \  toBeDeleted.isEmpty", "        l.foreach {\n            x => if (x < t) false\n\
    \            else true\n        }", "        var sum : Long = 0\n        for (i\
    \ <- l) {\n            sum += i\n        }\n        return sum < t", '        l.reverse.forall(l
    => l < t)', "        val minSize = l.foldLeft(0)( (acc, n) => if (n >= t) acc\
    \ else acc + 1 )\n        l.length == minSize", "        val n = l.length\n  \
    \      var i = 0\n        while (i < n) {\n            val left = l(i)\n     \
    \       val right = l(i + 1)\n            if (left > t) {\n                i =\
    \ i + 2\n            } else if (right < t) {\n                i = i + 1\n    \
    \        } else {\n                return true\n            }\n        }\n   \
    \     return false", "        var isTrue = true\n        l.foreach { e =>\n  \
    \          if(!(e<t))\n                isTrue = false\n        }\n        isTrue",
  "        val ln = l.size\n        for( i <- 0 until ln ) {\n            if( l(i)\
    \ < t ) false\n        }\n        true", "        l foreach {\n            x =>\
    \ if (x < t) false else true\n        }", '        l.forall(_.lessThan(t))', " \
    \       val list = l.toList\n        val size = list.size\n        var i = 0\n\
    \        val threshold = list.last\n        var found = false\n        for(i <-\
    \ 0 until size) {\n            if(list(i) < threshold && list(i + 1) > threshold)\
    \ {\n                found = true\n                break\n            }\n    \
    \    }\n        found", "        for (i <- l)\n            if (i < t)\n      \
    \          return false\n        true", "        l.forall { v =>\n           \
    \ if (v <= t)\n                false\n            else\n                true\n\
    \        }", '        l.toStream.map(_.toLong).takeWhile(_ < t).forall(_ > 0)',
  "        if (l.isEmpty) false\n        else {\n            val iter = l.iterator\n\
    \            var result = false\n            while (iter.hasNext && result ==\
    \ false)\n                result = iter.next() <= t\n            result\n    \
    \    }", "        val set = new mutable.HashSet[Long]()\n        for(number <-\
    \ l)\n            if(number < t)\n                set += number\n        set.size\
    \ == l.size", "        var trueCount = 0\n        var falseCount = 0\n       \
    \ for (x <- l) {\n            if (x < t) {\n                trueCount += 1\n \
    \           } else {\n                falseCount += 1\n            }\n       \
    \ }\n        return trueCount == l.length", "        val size = l.size\n     \
    \   val list = l.toList\n        val iter = list.iterator\n        while (iter.hasNext)\
    \ {\n            if (iter.next.toLong < t) {\n                return false\n \
    \           }\n        }\n        true", '        l.forall(x => x < t)', "   \
    \     val list = l.toList\n        list.forall(i => i.toDouble < t)", "      \
    \  val newList  = l.toSeq\n        val counter = mutable.Map[(Long, Long), Long]()\n\
    \n        for (x <- l) {\n            counter.put((x, x), 1)\n        }\n\n  \
    \      for (y <- newList) {\n            if (counter.contains((y,y))) {\n    \
    \            counter.put((y,y), counter.get((y,y))-1)\n            } else {\n\
    \                counter.put((y, y), 0)\n            }\n        }\n\n        if\
    \ (counter.contains((t, t)))\n            return true\n        else\n        \
    \    return false", "        val m = l.toSet // this might not be necessary since\
    \ order won't matter\n        val mSet = m.toSet\n        mSet.size == 1 &&\n\
    \            mSet.toList.head._1 < t", "        // Sort list in descending order\n\
    \        l.sortWith(_ < _)\n        // First element is the one that holds the\
    \ remaining numbers (the one with value less than t)\n        // We use this element\
    \ to see if we have all elements below t\n        val lastElement = l.last\n \
    \       // We will hold true if all numbers in the list are below t\n        var\
    \ checkAllBelowTResult = true\n        // Loop through all elements in the list\n\
    \        for (i <- 0 until l.size) {\n            // If any elements above t remain\
    \ then we return false\n            if (l(i) > t) {\n                checkAllBelowTResult\
    \ = false\n                // We break the loop because we only need to check\
    \ one element\n                break\n            }\n        }\n        // If\
    \ checkAllBelowTResult is true then we have all the numbers below t\n        checkAllBelowTResult",
  '        l.forall(x => x <= t) ', "        val counts = l.reduceLeft { (x, y) =>\
    \ x + y }\n        (counts <= t) && l.forall(n => n < t)", '       return l.forall(n
    => n < t)', "        val m = l.head\n        val n = l.tail\n        // If m >=\
    \ t, then there is at least one number in l below threshold t.\n        if (m\
    \ >= t) {\n            // If n = 0, then l contains no numbers below threshold\
    \ t.\n            if (n.length == 0) {\n                true\n            // Otherwise\
    \ n = 1, m >= t, so we know that m < t for all numbers in l.\n            } else\
    \ {\n                belowThreshold(n.tail, t)\n            }\n        // Else\
    \ if n is not empty, then l contains at least one number below threshold t.\n\
    \        } else {\n            belowThreshold(n, t)\n        }", "        val\
    \ ls = l.toStream.toList\n        ls.exists(_ < t)", "        val sorted = l.sortWith((x,\
    \ y) => x < y)\n        val n = sorted.length\n        var i = 0\n        while\
    \ (i < n) {\n            if (sorted.take(i).sum < t)\n                return false\n\
    \            i += 1\n        }\n        true", "        l == null ||\n       \
    \ l.size == 0 ||\n        l.forall(_.toLong <> t) }\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=scala,collections |>\nUsing scala's for comprehension, this is quite\
    \ straightforward:\n<code>\nval list = List((3,2), 4,(5,6), 7)\nfor (i <- list\n\
    \       if (i._1 < list.length\n           && list(i._1)._1 < i)\n       ) yield\
    \ i._1\n</code>\nor using foldLeft:\n<code>\nlist.foldLeft(List[Int]()){ \n  case\
    \ (acc, _) => acc ++ List(i._1); if (i._1 < list.length && list(i._1)._1 < i)\
    \ } \n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nI'm late to this party but I'm sure\
    \ this can be solved without the use of recursion:\n<code>\ndef belowThreshold[T](list\
    \ : List[T], threshold : T) =\n  list.foldLeft[List[T]](List[T]())((accum, elem)\
    \ =>\n    if(elem._1 < list.length && list(i._1)._1 < elem) accum :+ elem\n  \
    \  else accum\n  )\n</code>\n<|/ a tags=scala,collections dscore=2 |>\n<| a dscore=1\
    \ |>\nNot exactly what you asked for but still interesting solution:\n<code>\n\
    scala> val l = List((3, 2), (4,1), (5,6), 7)\nl: List[(Int, Int)] = List((3,2),\
    \ (4,1), (5,6), 7)\n\nscala> val sorted = l.sortBy(_._1).reverse\nsorted: List[(Int,\
    \ Int)] = List((7,6), (6,5), (5,4), (4,3), (3,2), (2,1))\n\nscala> l.map(p =>\
    \ p._1).diff( sorted.map(p => p._1) )\nres1: List[Int] = List(1, 3, 2, 4)\n</code>\n\
    <|/ a tags=scala,collections |>\n<| a dscore=1 |>\nNot a big fan of recursion,\
    \ so here is an alternative that doesn't use it:\n<code>\ndef belowThreshold[T](list\
    \ : List[T], threshold : T) =\n  list.foldLeft(List[Int]())((accum, elem) =>\n\
    \    if(elem._1 < list.length && list(i._1)._1 < elem) accum :+ elem._1\n    else\
    \ accum\n  )\n</code>\n<|/ a tags=scala,collections |>\n<| a dscore=1 tags=scala,collections ",
  "        val x = l.toSet\n        x < t", "        for (elem <- l) {\n         \
    \   if (elem < t) \n                return false\n        }\n        true", '        for((l,
    t2) <- l zip (t until (t / 2))) yield l < t2', "        val set = l\n        \
    \    .toSet\n            .foldLeft(new mutable.HashSet[Long]())((set, e) => if\
    \ (set.contains(e)) set.add(e) else set.addAll(e))\n        val res = t.toSet.contains(set)\n\
    \        res", '        l.forall(x => x < t)', "        for(x <- l) {\n      \
    \      if(!(x<t)) return false\n        }\n        true", "        val lows =\
    \ l.map(_ < t)\n        lows.reduce((a, b) => a && b) == true", '        l.forall(x
    => x <= t)', "        val m = l.foldLeft(0L){\n            case(acc, x) => acc\
    \ + x\n        }\n        m <= t", '        l.foldLeft(true)(_ && _)', "     \
    \   l.foldLeft[Boolean](true) {\n            case (true, x) => x < t\n       \
    \     case (false, x) => false\n        }", "        var result=false\n      \
    \  var i=0\n        val n=l.length\n        while (i<n) {\n            if (l(i)\
    \ < t)\n                return false\n            i+=1\n        }\n        return\
    \ true", '        l.toSet.filter(x => x < t).isEmpty', '        l.forall { i =>
    i < (t + 1l) }', "        val tThreshold = t - l.min\n        l.forall(x => x\
    \ < tThreshold)", "        val listOfNumbers = l.toArray\n        val length =\
    \ listOfNumbers.last\n        val newList = listOfNumbers.filter (a => a < t)\n\
    \        val newLength = newList.last\n        (length == newLength)", '        l.forall(_
    < t)', "        for(x <- l) if(x < t) break\n        l.size == 0", "        val\
    \ ls = l.toSet\n        val ts = t.toSet\n        ls.forall(l => ts contains l)",
  "        val result = l.foldLeft(false)((b, a) => b || (a < t))\n        result",
  "        // Okay, we have an easy case - we know that l is sorted and we are looking\
    \ for a number below threshold\n        if (l.isEmpty) false\n        else {\n\
    \            val x = l(0)\n            var found = false\n            for (var\
    \ i <- 1 until l.length) {\n                if (l(i) < x) found = true\n     \
    \           else if (!found) false\n                else { x = l(i); found = false}\n\
    \            }\n            !found\n        }", '        l.forall(x => x < t) ',
  "        l.forall {\n            case x if x < t => false\n            case x =>\
    \ true\n        }", '        l.foldLeft(true)((b, x) => b && x < t)', "      \
    \  // Sort the list so we know where to stop the checking\n        l.sortWith((x,\
    \ y) => x < y)\n        val lastNum = l.last\n        // If l doesn't contain\
    \ lastNum then it is smaller than t\n        l.contains(lastNum) match {\n   \
    \         case true =>\n                // If lastNum is less than t, then it\
    \ is smaller than t too\n                if (lastNum < t) {\n                \
    \    return false\n                }\n            case false =>\n            \
    \    // If lastNum is equal to t then it's bigger than t too\n               \
    \ if (lastNum == t) {\n                    return true\n                }\n  \
    \              // If lastNum is greater than t then all numbers in l are smaller\
    \ than t\n                else {\n                    // Return false if any number\
    \ is bigger than t\n                    l.find(x => x > t) == lastNum\n      \
    \          }\n        }", "        val result = l.foldLeft(true){\n          \
    \  (res, x) => res && x < t\n        }\n        result", "        val l = l.toList\n\
    \        if (l.isEmpty) false\n        else {\n            var count = 0\n   \
    \         var i = 0\n            while (i < l.length) {\n                val currentValue\
    \ = l(i)\n                count += 1\n                if (count > 100) {\n   \
    \                 return true\n                }\n                if (currentValue\
    \ < t) {\n                    count = count\n                } else {\n      \
    \              count = 0\n                }\n                i += 1\n        \
    \    }\n            if (count < 100) {\n                return true\n        \
    \    }\n            if (count == 100) {\n                return true\n       \
    \     }\n            if (count == 101) {\n                return true\n      \
    \      }\n            return false\n        }", "        l match {\n         \
    \   case Nil => false\n            case x :: tail if x < t => false\n        \
    \    case x :: tail if x == t => true\n            case x :: tail if x > t =>\
    \ belowThreshold(tail, t)\n            case _ => belowThreshold(tail, t)\n   \
    \     }", '        l.foldLeft(false)((acc, x) => acc && x > t)', '        l.forall
    { x => x < t }', "      val arr = l.map(i => i.toLong).toArray\n      if(arr.length\
    \ == 0) false\n      else if(arr.length <= 1) true\n      else if(t < arr.tail.head)\
    \ belowThreshold(arr.tail, t)\n      else belowThreshold(arr.init, t)", '        l.forall(x
    => x < t)', "        val m = l.size\n        var i = 0\n        while (i < m)\
    \ {\n            if (l(i) < t) {\n                i += 1\n            } else {\n\
    \                return false\n            }\n        }\n        true", "    \
    \    l.foldLeft(false) {\n            case (true, i) => i >= t\n            case\
    \ (false, i) => true\n        }", '        l.forall(i => i < t)', "        def\
    \ sum(xs: List[Long]) : Long = xs.reduce((x, y) => x + y)\n        val sums =\
    \ l.map((x) => sum(x))\n        if (sums.toDouble < t) true\n        else false",
  "        val lows = l filter (_ < t).toList\n        lows.length == 0 || (lows.size\
    \ == l.length && lows.forall(_ > t))", "        val nums = l.toSet\n        nums.forall(n\
    \ => n > t)", "        val set = Set(l)\n        val sum = 0L\n        for (a\
    \ <- set) {\n            sum = sum + a\n        }\n        sum < t", "       \
    \ var result : Boolean = true\n        var current : Long = l.head\n\n       \
    \ while(current < t) {\n            result &= current < t\n            current\
    \ += 1\n        }\n        result", "        if (l.isEmpty)\n            return\
    \ true\n        else if (l.size == 1)\n            return l(0) > t\n        else\n\
    \            belowThreshold(l.tail, t)", "        val n = l.size\n        val\
    \ r = l.map(_ < t).sum\n        (0 until n).forall(_ => r == 0)", "        val\
    \ n = l.length\n        if (n > 1) {\n            val t = n - 1\n            var\
    \ x = List[Long]()\n            var y = List[Long]()\n            var z = 0\n\n\
    \            while (n > 0) {\n                if (n <= 1) {\n                \
    \    z = 1\n                } else if (z <= t - 1) {\n                    z =\
    \ z * 2\n                } else {\n                    z = z / 2\n           \
    \     }\n                x :+= l(z + 1)\n                y :+= l(z - 1)\n    \
    \            n -= 1\n            }\n\n            x diff y && (x >= t)\n     \
    \   }\n        false", "        val nums = l.toList\n        nums.foldLeft(true)((acc,\
    \ i) => acc && (i < t))", "        val l2 = l.toList\n        val listSize = l2.size\n\
    \        val l3 = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 20l, 40l, 50l,\
    \ 60l, 70l, 80l, 90l, 100l)\n        val listSize2 = l3.size\n        var testCases\
    \ = 0\n        for(i <- 0 until listSize) {\n            for(j <- 0 until listSize2)\
    \ {\n                if(l3(i) == l2(j)) {\n                    testCases += 1\n\
    \                }\n            }\n        }\n        if(testCases > listSize)\
    \ {\n            true\n        } else {\n            false\n        }", '        l.toSeq.forall
    { x => x < t }', "        val mx = l.max\n        val mn = l.min\n        var\
    \ bt = false\n        val u = (mx - mn)/2\n        l.foreach{x =>\n          \
    \  val u1 = (x-mx)/2\n            if (u > u1 ) {\n                u = mx\n   \
    \             bt = true\n            }\n            else if (x < mn) {\n     \
    \           b = true\n            }\n        }\n        bt", "        val rs =\
    \ l.view.zipWithIndex.filter{ case (x, idx) => x < t}.toList\n        rs.forall{\
    \ case (x, idx) => idx < l.length-1}", "        var trueCount = 0\n        var\
    \ falseCount = 0\n        var i = 0\n        var l = l.toList\n        while (i\
    \ < l.length) {\n            if (l(i) < t) {\n                trueCount += 1\n\
    \            } else {\n                falseCount += 1\n            }\n      \
    \      i += 1\n        }\n        trueCount >= l.length", "        l.forall {\
    \ i =>\n            i < t\n        }", "        val l = l.toList\n        val\
    \ x = l.foldLeft(false)(_ || _)\n        val y = l.filter(_ < t).length == l.length\n\
    \        x == y", "        l match {\n        case Nil => false\n        case\
    \ head :: tail => {\n            val current = head\n            if (current <\
    \ t)\n                false\n            else\n                belowThreshold(tail,\
    \ t)\n        }\n        }", '        l.toSet.forall(x => x < t)', '        l.forall(x
    => x < t)', "        l.foreach {\n            i => if(i < t) false\n         \
    \   else  true\n        }", "        val size = l.size\n        for( i <- 0 until\
    \ size ) {\n            if( l(i) < t )\n                return false\n       \
    \ }\n        true", '        l.forall { x => x < t }', '        l.isEmpty', " \
    \       val countMap: Map[Long, Int] = l.groupBy(x => x).mapValues(_.size)\n \
    \       val totalCount = countMap.values.sum\n        val countMapWithoutZero\
    \ = countMap.filter { case (count, number) => number != 0 }\n        // if any\
    \ number in the list has the count as 0 or less than 1\n        if(totalCount\
    \ == 0 || countMapWithoutZero.size < 1) return false\n        countMapWithoutZero.map(_\
    \ / totalCount).max <= t", "        var result : Boolean = l.forall(_.<=t)\n \
    \       return result", "        val m = l.length\n        if (m < 1) true\n \
    \       else { \n            var x = l(0)\n            var c = 1\n           \
    \ for (var i = 1; i < m; i++) {\n                x += c * l(i)\n             \
    \   if (x > t) c = -1\n                else if (x < t) c = 1\n               \
    \ else {\n                    return false\n                }\n            }\n\
    \        }", "        val result = l.forall(_ < t)\n        result", "       \
    \ val sorted = l.sortWith(_.compareTo(t) < 0)\n        val head = sorted.head\n\
    \        val tail = sorted.tail\n        if (tail.isEmpty) head < t\n        else\
    \ head < t && aboveThreshold(tail, t)", "        l.forall {i =>\n            i\
    \ >= t\n        }", "        def count(l : List[Long], t : Long) : Long = {\n\
    \            val res = 0;\n            l.foreach { x =>\n                if (x\
    \ < t) res += 1\n            }\n            res\n        }\n        return count(l,\
    \ t) == 0", "        for (n <- l)\n          if (n < t)\n            return false\n\
    \        true", "        val nums = l.toSeq.sort\n        nums.forall(l => l <=\
    \ t)", "        l.foreach { x =>\n            if ((x > t)) {\n               \
    \ false\n            } else {\n                true\n            }\n        }",
  "        val m = l.size\n        var i = 0\n        while (i < m) {\n          \
    \  if (l(i) <= t) false\n            else i -= 1\n        }\n        true", " \
    \       // Initialize the counts variable to be a mutable counter.\n        var\
    \ counts = mutable.HashMap[Long, Int]()\n        for (i <- l)\n        {\n   \
    \         counts.put(i, counts.getOrElse(i, 0) + 1)\n        }\n\n        // Check\
    \ if the list has one number less than the threshold.\n        if (l.reduce(_\
    \ + _) <= t)\n            return true\n\n        // If there are more than one\
    \ number less than the threshold, then\n        // there will be at least one\
    \ number greater than the threshold, so\n        // we need to check for the threshold\
    \ being above the list.\n        else\n            for (i <- counts.keySet)\n\
    \            {\n                if (counts.get (i) < t)\n                {\n \
    \                   // If there is one number more than the threshold, return\
    \ false.\n                    if (counts.get(i) > 1)\n                       \
    \ return false\n                    // If there are no numbers more than the threshold,\
    \ return true.\n                    else\n                        return true\n\
    \                }\n            }", '        l.forall(i => { if (i < t) false
    else true})', "        var isAllFalse = l == Nil\n        for (x <- l)\n     \
    \       isAllFalse &= x < t\n        isAllFalse", "        var i = 0\n       \
    \ while(i < l.length) if (l(i) < t) i = i + 1\n        i == l.length", '        l.toSet.toList.forall(i
    => i < t)', '        l.forall { i => if(i > t) false; else true}', "        def\
    \ allLessThan(l : List[Long], threshold : Long, acc : Boolean, current : Long)\
    \ : Boolean = {\n            if (l.isEmpty) acc\n            else {\n        \
    \        val currentValue = l(0)\n                val compareTo = threshold\n\
    \                val l = l.tail\n                if (l == Nil) acc\n         \
    \       else {\n                    if (currentValue < compareTo && allLessThan(l,\
    \ threshold, !acc, currentValue)) allLessThan(l, threshold, !acc, currentValue)\n\
    \                    else {\n                        if (allLessThan(l, threshold,\
    \ acc, currentValue)) allLessThan(l, threshold, acc, currentValue)\n         \
    \               else {\n                            allLessThan(l, threshold,\
    \ !acc, currentValue)\n                        }\n                    }\n    \
    \            }\n            }\n        }\n        allLessThan(l, t, true, 0l)",
  '        l.toSet == t.toSet', "        var allBelow = true // true if all numbers\
    \ in l are below t\n        for (i <- l) {\n            if (i > t) allBelow =\
    \ false\n        }\n        allBelow", "        val list = l \n        val sortedList\
    \ = list.sorted\n        val sumOfElements = list.sum\n        val difference\
    \ = sumOfElements - t\n        val isNegative = sortedList.forall(x => x < t)\
    \ \n        isNegative || (list.length <= 1 && sumOfElements == 0l && sortedList.last()\
    \ == t && ((sortedList.length <= 1) || sortedList(list.length-1) == t))", "  \
    \      var sum = 0L\n        var isAbove = true // is l above t?\n        for((n,v)\
    \ <- l.zip(l.tail)){\n            if(v > t) isAbove = false\n            sum +=\
    \ v\n        }\n        !isAbove && sum < t", "        for( x <- l ) if( x < t\
    \ ) \n            false\n        else\n            true", "        var isTrue\
    \ = true\n        for (x <- l) {\n            if (x < t) {\n                isTrue\
    \ = false\n                break\n            }\n        }\n        isTrue", " \
    \       var sum = 0\n        l.foreach {\n            x => sum += x\n        }\n\
    \        if (sum < t) true else false", '        l.forall(_ < t)', "        //\
    \ Use a mutable collection to hold the numbers that are below the threshold\n\
    \        val belowThreshold = mutable.HashSet[Long]()\n\n        // Iterate through\
    \ the numbers in the list\n        for (i <- l)\n            // If this number\
    \ is below the threshold, add the number to belowThreshold\n            if (i\
    \ < t)\n                belowThreshold.add(i)\n\n        // Return true if the\
    \ list has all numbers below the threshold\n        belowThreshold.isEmpty", " \
    \       val m = l.foldLeft(0) { (c, i) => if (i <= t) c + 1 else c }\n       \
    \ m = 0 == m", "        val res = l.reduceLeft{ (res, elem) => elem > t && res}\n\
    \        res == true", "        l.forall {\n            x => x < t\n        }",
  '        l.forall { x => x < t }', "        val n = l.size\n        l match {\n\
    \            case Nil => false\n            case x::xs => \n                for\
    \ (i <- 0 until n) {\n                    if (l(i) < t && l(i) > (-l(i) * t))\
    \ false\n                }\n            case _ => throw new RuntimeException(\"\
    Only works for List[Long]\")\n        }", '        for (i <- l.toStream) if (i
    < t) false else true', "        if (l.isEmpty) true\n        else if (l.head <\
    \ t) false\n        else belowThreshold(l.tail, t)", "        if (l == null ||\
    \ l.isEmpty) return false\n        val lower = l.min\n        val upper = l.max\n\
    \        (lower <= t) && (upper >= t)", "        def lt(n : Long, nt : Long):\
    \ Boolean = nt < n\n        l.forall { n =>\n            if ((n > t) && (nt >\
    \ t)) {\n                false\n            } else {\n                lt(n, t)\n\
    \            }\n        }", '        l exists { x => x < t }', "        val n\
    \ = l.length\n        for (i<- 0 until n) if (!l(i) lt t) \n            return\
    \ false\n        true", "        def sum(l: List[Long]): Long = l match {\n  \
    \          case Nil => 0\n            case h :: t => h + sum(t)\n        }\n \
    \       val n = sum(l)\n        (n < t)", "        val set = l.toSet\n       \
    \ l exists { x => x < t }"]
stop_tokens:
- "\n    }\n"
