name: HumanEval_119_match_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of two strings, both strings consist of open\n    //\
  \ parentheses '(' or close parentheses ')' only.\n    // Your job is to check if\
  \ it is possible to concatenate the two strings in\n    // some order, that the\
  \ resulting string will be good.\n    // A string S is considered to be good if\
  \ and only if all parentheses in S\n    // are balanced. For example: the string\
  \ '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n\
  \    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    //\
  \ >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst\
  \ : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
  ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
  , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
  , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
  , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
  , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\"\
  , \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\",\
  \ \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
  , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
  , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \"\
  )(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"\
  Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\"\
  )));\n    }\n\n}\n"
completions: ["        if (lst.length == 1) {\n            \"No\"\n        } else\
    \ if (lst.length == 2) {\n            \"Yes\"\n        } else {\n            val\
    \ rec : Boolean = lst.sliding(2).forall(x => x.contains(\"(\") && x.contains(\"\
    )\"))\n            if (rec) {\n                \"Yes\"\n            } else {\n\
    \                \"No\"\n            }\n        }", "        val (good, bad) =\
    \ lst.partition(i => i.contains(\"(\"))\n        if (good.isEmpty) \"No\" else\
    \ \"Yes\"", "      val count = new mutable.HashMap[String, Int]()\n      val pair\
    \ = new mutable.HashMap[String, Int]()\n      pair += (\"(\" -> 1)\n      pair\
    \ += (\")\" -> 1)\n      lst.foreach {\n        case str =>\n          val n =\
    \ count(str)\n          if(n == 0) \"No\" else \"Yes\"\n      }", "        val\
    \ list = lst.filter(_.toString.contains(\"(\")).toSet\n        val set = lst.filter(_.toString.contains(\"\
    )\")).toSet\n        val len = list.size\n        if (len == 0) \"No\"\n     \
    \   else {\n            val setLen = set.size\n            if (setLen < len) {\n\
    \                val newSet = set.map(i => i.replace(\"(\", \"()\"))\n       \
    \         val newList = list.map(i => i.replace(\")\", \"()\"))\n            \
    \    if (newSet.toSet.size == newList.size) \"Yes\"\n                else \"No\"\
    \n            }\n            else if (setLen > len) {\n                if (lst.head\
    \ == list) \"Yes\"\n                else \"No\"\n            }\n            else\
    \ {\n                if (list.toSet.size == set.size) \"Yes\"\n              \
    \  else \"No\"\n            }\n        }", "        val stack = mutable.Stack[List[String]]()\n\
    \        val stackString = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        for (i <- 0 until lst.length-1) {\n            if (lst(i) == '(') {\n\
    \                stack push (lst(i))\n                queue enqueue (lst(i))\n\
    \            }\n            if (lst(i) == ')') {\n                while (!stack.isEmpty\
    \ && !(stackString.isEmpty) && stackString(stackString.length-1) == '(') {\n \
    \                   stackString push (stack.pop())\n                }\n      \
    \          if (!stack.isEmpty) {\n                    stack pop\n            \
    \    }\n            }\n        }\n        if (stackString.isEmpty) {\n       \
    \     \"No\"\n        } else {\n            \"Yes\"\n        }", "        val\
    \ p = lst.size\n        if(p < 2) {\n            \"No\"\n        }\n        if(p\
    \ > 2) {\n            \"Yes\"\n        }\n        val s = lst.head\n        def\
    \ incl(s: String, l: Seq[String]): Seq[String] = {\n            l match {\n  \
    \              case Nil => Seq(s)\n                case x :: xs => x :: incl(s,\
    \ xs)\n            }\n        }\n        val lst2 = incl(s, lst)\n        val\
    \ l2 = lst2.size\n        if(l2 < p) {\n            \"Yes\"\n        }\n     \
    \   else {\n            if(lst2.contains(s.reverse.head)) {\n                val\
    \ newS = s.reverse.head +: lst2.tail\n                val lst3 = incl(newS, lst2)\n\
    \                if(lst3.size == p) {\n                    \"Yes\"\n         \
    \       }\n                else {\n                    \"No\"\n              \
    \  }\n            }\n            else {\n                \"No\"\n            }\n\
    \        }", "        lst.foldLeft(List[String](\"No\")){\n            (acc, s)\
    \ =>\n                acc.foldLeft(List[String](\"Yes\")){\n                 \
    \   (acc, s) =>\n                        acc.foldLeft(List[String](\"No\")){\n\
    \                            (acc, s) =>\n                                acc.foldLeft(List[String](\"\
    Yes\")){\n                                    (acc, s) =>\n                  \
    \                      acc.foldLeft(List[String](\"No\")){\n                 \
    \                           (acc, s) =>\n                                    \
    \            acc.foldLeft(List[String](\"Yes\")){\n                          \
    \                          (acc, s) =>\n                                     \
    \                   acc.foldLeft(List[String](\"No\")){\n                    \
    \                                        (acc, s) =>\n                       \
    \                                         acc.foldLeft(List[String](\"Yes\")){\n\
    \                                                                    (acc, s)\
    \ =>\n                                                                       \
    \ acc.foldLeft(List[String](\"No\")){\n                                      \
    \                                      (acc, s) =>\n                         \
    \                                                       acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \                 (acc, s) =>\n                                              \
    \                                          acc.foldLeft(List[String](\"No\")){\n\
    \                                                                            \
    \                (acc, s) =>\n                                               \
    \                                                 acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \                                 (acc, s) =>\n                              \
    \                                                                          acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                        (acc, s) =>\n                       \
    \                                                                            \
    \             acc.foldLeft(List[String](\"Yes\")){\n                         \
    \                                                                            \
    \               (acc, s) =>\n                                                \
    \                                                                        acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                                        (acc, s) =>\n       \
    \                                                                            \
    \                                             acc.foldLeft(List[String](\"Yes\"\
    )){\n                                                                        \
    \                                                            (acc, s) =>\n   \
    \                                                                            \
    \                                                         acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                                                        (acc,\
    \ s) =>\n                                                                    \
    \                                                                            acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \                                                                            \
    \     (acc, s) =>\n                                                          \
    \                                                                            \
    \                  acc.foldLeft(List[String](\"No\")){\n                     \
    \                                                                            \
    \                                                           (acc, s) =>\n    \
    \                                                                            \
    \                                                                            \
    \    acc.foldLeft(List[String](\"Yes\")){\n                                  \
    \                                                                            \
    \                                                      (acc, s) =>\n         \
    \                                                                            \
    \                                                                            \
    \       acc.foldLeft(List[String](\"No\")){\n                                \
    \                                                                            \
    \                                                                (acc, s) =>\n\
    \                                                                            \
    \                                                                            \
    \                        acc.foldLeft(List[String](\"Yes\")){\n              \
    \                                                                            \
    \                                                                            \
    \              (acc, s) =>\n                                                 \
    \                                                                            \
    \                                                           acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                                                            \
    \                                            (acc, s) =>\n                   \
    \                                                                            \
    \                                                                            \
    \                     acc.foldLeft(List[String](\"", "      val stack = mutable.Stack[String]()\n\
    \      var isGood = lst.forall(s => s == \"(\") || s == \"(\") // if any string\
    \ in lst = \"(\"\n      if(!isGood) return \"No\" // if no string in lst is good,\
    \ return \"No\"\n      for(s <- lst) stack push s // stack is a stack of string\n\
    \      while(stack.size > 0) yield {\n        val s = stack.pop\n        if(s\
    \ == \"(\") stack.push s\n        else if(s == \"(\") stack.push s\n        else\
    \ stack.pop\n      }.toString()", "        if(lst.size < 2) \"No\" else lst.foldLeft(List[String]())((acc,\
    \ item) =>\n            if(acc.isEmpty) acc.prepend(item)\n            if(acc.head.endsWith(item.head))\
    \ acc :+ item\n            else if(acc.head.startsWith(item.head)) acc :+ item\n\
    \            else \"No\"\n        )", "        val len = lst.size\n        if\
    \ (len == 0) \"No\"\n        else {\n            val first = lst(0)\n        \
    \    val last = lst(len - 1)\n            val first1 = first.count('(')\n    \
    \        val last1 = last.count(')')\n            if (first1 == last1) \"Yes\"\
    \n            else matchParens(lst.drop(1).head :: lst)\n        }", "       \
    \ def hasOpen(lst: Seq[String]): Boolean = lst.exists { x => x == \"(\" }\n  \
    \      def hasClose(lst: Seq[String]): Boolean = lst.exists { x => x == \")\"\
    \ }\n        def makeGood(lst: Seq[String], index : Int) : Seq[String] = {\n \
    \           val subList = lst.drop(index).reverse.mkString(\"(\", \"|\", \")\"\
    )\n            if (hasOpen(lst) && hasClose(lst) && lst.size == index + 1) {\n\
    \                val newList = lst.reverse.mkString(\"(\", \"|\", \")\")\n   \
    \             val nextList = lst(index + 1)\n                if (newList == nextList)\
    \ {\n                    List(subList)\n                }\n                else\
    \ {\n                    List()\n                }\n            }\n          \
    \  else {\n                List()\n            }\n        }\n        val list\
    \ = lst.sortBy(x => x).reverse.mkString(\"(\", \"|\", \")\")\n        if (list.contains(\"\
    |\")) {\n            val newList = list.split(\"\\\\|\").map(_.trim)\n       \
    \     if (hasOpen(newList) && hasClose(newList) && newList.size == 2) {\n    \
    \            if (newList(1) == newList(2)) {\n                    makeGood(newList,\
    \ 2)\n                }\n                else {\n                    makeGood(newList,\
    \ 1)\n                }\n            }\n            else {\n                List()\n\
    \            }\n        }\n        else {\n            List()\n        }", " \
    \       // Create an empty stack data structure.\n        val stack = mutable.Stack[List[String]]()\n\
    \        var index = 0\n        var isGoodString = true\n        val result: String\
    \ = \"\"\n\n        while(index <= lst.size - 1){\n            val currParen =\
    \ lst(index)\n            index += 1\n            val nextParen = lst(index)\n\
    \n            if(currParen.equals(\"(\") && nextParen.equals(\")\")){\n      \
    \          result += \"(\"\n                isGoodString = false\n           \
    \     stack.push(List(currParen))\n                index += 1\n            }\n\
    \            else if(currParen.equals(\")\") && nextParen.equals(\"(\")){\n  \
    \              result += \")\"\n                isGoodString = false\n       \
    \         val pop = stack.pop()\n                if(pop.size == 1 && pop(0) ==\
    \ \")\"){\n                    result += \"(\"\n                }\n          \
    \      else{\n                    isGoodString = true\n                }\n   \
    \             index += 1\n            }\n            else if(currParen.equals(\"\
    (\")){\n                stack.push(List(currParen))\n                index +=\
    \ 1\n            }\n            else if(currParen.equals(\")\")){\n          \
    \      val pop = stack.pop()\n                if(pop.size == 1 && pop(0) == \"\
    (\"){\n                    result += \"(\"\n                }\n              \
    \  else{\n                    isGoodString = true\n                }\n       \
    \         index += 1\n            }\n        }\n        if(isGoodString){\n  \
    \          result\n        }\n        else{\n            \"No\"\n        }", " \
    \       val counts = lst.foldLeft(Map(\"()\" -> 1, \"(\" -> 1, \"[\" -> 1))((x,\
    \ y) =>\n          x + (y.toDouble -> (y._1 + y._2))).toMap\n        (if (counts.get(\"\
    ()\") > counts.get(\"(\") && counts.get(\"(\") < counts.get(\"[\")) \n       \
    \     \"Yes\" else \"No\")", "        val result = new mutable.ListBuffer[String]()\n\
    \        val counts = lst.foldLeft(Map[String, Int]())((counts, s) => {\n    \
    \        val chars = s.toCharArray\n            if (chars.size == 1) counts.put(s,\
    \ chars.size)\n            else if (chars(0) != '(') counts.put(s, chars.size)\n\
    \            else counts + (s + (chars(0) - '(') + (if (chars(1) == '(') 1 else\
    \ 0)))\n        })\n        counts.get(\"()\").toString.length == lst.length.toString\
    \ match {\n            case true => \"Yes\"\n            case false => \"No\"\n\
    \        }", "        var list1 = lst.head\n        var list2 = lst.tail.head\n\
    \        var cnt = 0\n        var str = \"\"\n        while (list1 != null) {\n\
    \            if (list1.equals(\"(\")) {\n                cnt += 1\n          \
    \  }\n            else {\n                cnt -= 1\n            }\n          \
    \  list1 = list1(0)\n        }\n        cnt += 1\n        while (list2 != null)\
    \ {\n            if (list2.equals(\"(\")) {\n                cnt += 1\n      \
    \      }\n            else {\n                cnt -= 1\n            }\n      \
    \      list2 = list2(0)\n        }\n        // If all parentheses are balanced\
    \ return \"Yes\" else \"No\"\n        if (cnt == 0) {\n            return \"Yes\"\
    \n        }\n        str = lst.head.head + \"(\" + lst.tail.head + \")\"\n   \
    \     return str", "        val res = \"\"\n        val stack = Stack(lst)\n \
    \       while(!stack.empty) {\n            val str = stack.pop()\n           \
    \ if(!str.startsWith(\"(\"))\n                res += str\n            else if(!str.endsWith(\"\
    )\"))\n                res += str\n            else if(str.endsWith(\")\")) {\n\
    \                val str = str.substring(0, str.length - 1)\n                if(!stack.contains(str))\n\
    \                    res += str\n            }\n            else if(str.startsWith(\"\
    (\")) {\n                val str = str.substring(1,str.length - 1)\n         \
    \       if(!stack.contains(str))\n                    res += str\n           \
    \ }\n        }\n        res", "        var res: String = \"No\"\n        var cnt\
    \ = 0\n        var firstParens = 0\n        var lastParens = 0\n        for (str\
    \ <- lst) {\n            val len = str.length\n            if (str == \")\")\n\
    \                lastParens = 0\n            else if (str == \"(\")\n        \
    \        firstParens += 1\n            else if (str == \")(\")\n             \
    \   lastParens += 1\n            else if (str == \"()\")\n                cnt\
    \ += 1\n        }\n        val isGood = firstParens == lastParens && cnt == len\n\
    \        res = if (isGood) \"Yes\" else \"No\"\n        res", "        // Convert\
    \ string to List\n        // Remove parentheses\n        // Sort list\n      \
    \  // If two elements are same, return \"Yes\"\n        // Else, return \"No\"",
  "        val str = lst.head.head\n        val lst1 = lst.head.tail\n        val\
    \ lst2 = lst.tail.head\n        val lst3 = lst.tail.tail\n        val len = lst.length\n\
    \        val goodStr = lst1.length == lst2.length && lst2.length == lst3.length\n\
    \        val goodLen = lst1.length == lst2.length && lst1.length == lst3.length\n\
    \        var i = 0\n        var j = 0\n        var res = \"\"\n        while (i\
    \ < len && j < len) {\n            if (str == lst1(i)) {\n                i +=\
    \ 1\n                j += 1\n                val j = lst2.length\n           \
    \     while (i < len && j < len) {\n                    if (str == lst2(i)) {\n\
    \                        i += 1\n                        j += 1\n            \
    \        } else if (str == lst3(i)) {\n                        i += 1\n      \
    \                  j += 1\n                    } else {\n                    \
    \    res = res + \"(\"\n                        i += 1\n                     \
    \   j += 1\n                    }\n                }\n            } else {\n \
    \               res = res + \"(\"\n                i += 1\n            }\n   \
    \     }\n        res + \"(\"\n        if (!goodStr) {\n            res = \"No\"\
    \n        }\n        if (!goodLen) {\n            res = \"No\"\n        }\n  \
    \      res", "        // We need to keep track of the current and previous chars,\
    \ since there are\n        // two types of opening character ( or ')\n       \
    \ val current = \"(\"\n        var prev = \"\"\n        var string = \"\"\n  \
    \      for (item <- lst) {\n            if(item == current) {\n              \
    \  prev += current\n                string += current\n            } else if(item\
    \ == prev) {\n                prev += item\n            } else {\n           \
    \     string += prev + item\n            }\n            prev = \"\"\n        }\n\
    \        string += prev\n        return string", "        val list1 = lst(0)\n\
    \        val list2 = lst(1)\n        val list3 = list1 ::: list2\n        val\
    \ list4 = list3 ++ list2\n        if (list4.nonEmpty) {\n            val list5\
    \ = list4 ::: list1\n            val list6 = list1 ::: list5\n            if (list6.nonEmpty)\
    \ {\n                val list7 = list6 ::: list3\n                val list8 =\
    \ list3 ::: list7\n                if (list8.nonEmpty) {\n                   \
    \ val list9 = list8 ::: list2\n                    if (list9.nonEmpty) {\n   \
    \                     if (list1.nonEmpty && list2.nonEmpty) {\n              \
    \              val list10 = list9 ::: list1\n                            val list11\
    \ = list9 ::: list10\n                            if (list11.nonEmpty) {\n   \
    \                             return \"Yes\"\n                            } else\
    \ {\n                                return \"No\"\n                         \
    \   }\n                        } else {\n                            return \"\
    No\"\n                        }\n                    } else {\n              \
    \          return \"No\"\n                    }\n                } else {\n  \
    \                  return \"No\"\n                }\n            } else {\n  \
    \              return \"No\"\n            }\n        } else {\n            return\
    \ \"No\"\n        }", "        val stack = new mutable.Stack[Int](2)\n       \
    \ val lst2 = lst.map { x => { x -> 1 }; x -> 0 }.toMap\n        val lst3 = lst.map\
    \ { x => { x -> -1 }; x -> 0 }.toMap\n        for (x <- 0 until lst.size) {\n\
    \            if (lst(x) == -1) stack += x\n            else if (!lst2.contains(x)\
    \ || !lst3.contains(x)) stack += x\n        }\n        if (stack.size > 0) \"\
    No\" else \"Yes\"", "        var stack = lst.head\n        var isTrue = true\n\
    \        var i = 0\n        while (i < lst.length) {\n            if (lst(i).startsWith(\"\
    (\")) {\n                if (lst(i).startsWith(\"(\"))\n                    stack\
    \ += \"(\"\n                else\n                    stack += \")\"\n       \
    \     } else {\n                if (lst(i).startsWith(\")\"))\n              \
    \      stack += \")\"\n                else {\n                    if (!stack.startsWith(\"\
    (\"))\n                        isTrue = false\n                    else\n    \
    \                    stack = \"\"\n                }\n            }\n        \
    \    i += 1\n        }\n        if (isTrue)\n            \"Yes\"\n        else\n\
    \            \"No\"", "        val rem = lst\n        var stack = new Stack[String]\n\
    \        var count = 0\n        val good = mutable.ListBuffer.empty[String]\n\
    \        rem.foreach(s => if (s.startsWith(\"(\") || s.startsWith(\")\")) stack\
    \ += s)\n        while (stack.nonEmpty) {\n            val s = stack.pop\n   \
    \         if (s.endsWith(\"(\")) count += 1\n            if (s.endsWith(\")\"\
    )) count -= 1\n            if (count < 0) good.append(\"No\")\n            else\
    \ if (count == 0) good.append(\"Yes\")\n            else good.append(s)\n    \
    \    }\n        good.mkString", '        // TODO', '        //your code', "  \
    \      //  TODO\n        var res: String = \"No\"\n        val lst1: mutable.List[String]\
    \ = lst._1.asInstanceOf[mutable.List[String]]\n        val lst2: mutable.List[String]\
    \ = lst._2.asInstanceOf[mutable.List[String]]\n        if (lst1.size != lst2.size)\
    \ {\n            res = \"No\"\n        }\n        else {\n            for (i <-\
    \ 0 until lst1.size) {\n                if ((lst1(i).charAt(0) == '(') && (lst2(i).charAt(0)\
    \ == ')')) {\n                    if (lst1(i).charAt(lst1(i).length - 1) == ')')\
    \ {\n                        val tempStr: String = \"()\" + lst1(i).substring(1)\n\
    \                        val resStr: String = \"Yes\"\n                      \
    \  val resArr: List[String] = resStr.split(\"\\\\W+\").toList.filter(s => s.nonEmpty)\n\
    \                        if (resArr.size == 2) {\n                           \
    \ val tempArr: List[String] = tempStr.split(\"\\\\W+\").toList.filter(s => s.nonEmpty)\n\
    \                            val list: List[String] = lst2.asInstanceOf[List[String]]\n\
    \                            val lst: mutable.List[String] = lst2.asInstanceOf[mutable.List[String]]\n\
    \                            for (b <- 0 until list.size) {\n                \
    \                if (lst(b).charAt(0) == '(' && tempArr(b).charAt(0) == ')') {\n\
    \                                    if (lst(b).charAt(lst(b).length - 1) == ')'\
    \ && lst(b).substring(1) == list(b)) {\n                                     \
    \   resStr = \"Yes\"\n                                        resArr(0) = tempStr\n\
    \                                    }\n                                }\n  \
    \                          }\n                            res = resStr\n     \
    \                   }\n                    }\n                }\n            }\n\
    \        }\n        res", "        // Write your code here\n        val stack\
    \ = Stack[String]()\n        val str = lst(0) \n        for(x <- str){\n     \
    \       if(x ==\"(\") stack += \"(\"\n            else if(x==\")\") stack += \"\
    )\"\n            else\n            if(!stack.isEmpty){\n                val check\
    \ = stack.pop()\n                if(check != \"(\") \n                if(check\
    \ != \")\"){\n                    return \"No\"\n                }\n         \
    \   }\n        }\n        if(stack.isEmpty) \n            return \"Yes\"\n   \
    \     else \n            return \"No\"", "        //Using Regular expressions\n\
    \        val open = \"\\\\(|\\\\)|\\\\|\"\n        val close = \"\\\\(|\\\\)\"\
    \n        val balance = \"[\" + open + close.r.replaceAllIn(open, \"\") + \"]\"\
    \n        val regexp = s\"\"\"^$balance+$balance+$balance+$balance$\"\"\"\n  \
    \      val str = lst(0) + lst(1)\n        if (!str.matches(regexp)) {\n      \
    \      \"No\"\n        }\n        else if (!lst.size == 2) {\n            \"No\"\
    \n        }\n        else {\n            \"Yes\"\n        }", "        val parensStack\
    \ = new Stack[Int]()\n        var result = \"No\"\n        lst.foreach(x => {\n\
    \            if (x.toString.contains(\"(\")) {\n                parensStack.push(1)\n\
    \            }\n            else if (x.toString.contains(\")\")) {\n         \
    \       val poppedCount = parensStack.pop()\n                if (poppedCount >\
    \ 1) {\n                    result == \"Yes\"\n                }\n           \
    \     else {\n                    result == \"No\"\n                }\n      \
    \      }\n        })\n        return result", "        if(lst.size > 2) false\n\
    \        else if(lst.size == 2) true\n        else lst.foldLeft(true) { (res,\
    \ elem) =>\n            if(elem == \"(\")\n            res = res && matchParens(lst.take(2)\
    \ ++ lst.takeRight(2).reverse)\n            else\n            res = res && matchParens(lst.drop(1)\
    \ ++ lst.takeRight(2).reverse)\n            res\n        }", "        val countParens\
    \ = lst.count(_.matches(\"\\\\(.*\\\\)\")) / lst.count\n        val string = \"\
    Yes\"\n        val string2 = \"No\"\n        \n        if(countParens == 1)\n\
    \        {\n            if(lst(0)(0) == \"(\" || lst(0)(lst(0).length-1) == \"\
    (\")\n                string2 = \"Yes\"\n            else\n                string\
    \ = \"Yes\"\n        }\n        else if(countParens == 0)\n            string\
    \ = \"No\"\n        else\n            string = \"Yes\"\n            \n       \
    \ return string", "      val stack = mutable.Stack[String]()\n      val str =\
    \ lst.head\n      if (str == \"()\") {\n        stack += \"(\"\n      } else if\
    \ (str == \")\") {\n        val current = stack.pop()\n        if (current ==\
    \ \"\") {\n          return \"No\"\n        } else {\n          stack += \")\"\
    \n        }\n      } else if (str.startsWith(\"(\")) {\n        stack += str\n\
    \      } else if (str.endsWith(\")\")) {\n        val current = stack.pop()\n\
    \        if (current == \"\") {\n          return \"No\"\n        } else {\n \
    \         stack += str\n        }\n      }\n      return \"Yes\"", "        val\
    \ set = new mutable.HashSet[String]()\n        lst.foreach(x => x.split(\"\\\\\
    (\").foreach(x => set.add(x)))\n        if(set.size == 2) {\n            val lst1\
    \ = lst(0).get.split(\"\\\\)\")\n            val lst2 = lst(1).get.split(\"\\\\\
    )\")\n            if(lst1.length == lst2.length) {\n                if(lst1(0)\
    \ == \"(\" && lst1(1) == \"(\" && lst2(0) == \")\" && lst2(1) == \")\") {\n  \
    \                  return \"Yes\"\n                }\n            }\n        }\n\
    \        \"No\"", "        val stack = mutable.Stack[String]()\n        lst.foreach(x\
    \ => {\n            if (x == \"(\") stack += x\n            else if (!stack.isEmpty\
    \ && stack.head == x) stack.pop()\n            else if (!stack.isEmpty && stack.head\
    \ == \"(\") stack.pop()\n            else stack\n        })\n        val str =\
    \ stack.mkString\n        val newStack = if (str.startsWith(\"()\") && !stack.isEmpty\
    \ && stack.head == \"(\") stack.pop else stack\n        val newStr = stack.mkString\n\
    \        if (newStr.length < str.length && newStr.isEmpty || newStr.length ==\
    \ str.length && !newStack.isEmpty && newStack.head == \"(\") newStack.pop()\n\
    \        else if (!newStr.isEmpty && newStr.head != \"(\") newStack\n        else\
    \ newStr", "        if(lst.size == 0) \"No\"\n        else if(lst.head.length\
    \ == 1 && !lst.head.contains(\"(\") && !lst.head.contains(\")\")) lst.head + lst.head\n\
    \        else lst.head + matchParens(lst.tail)", "        val res = (lst.foldLeft(false)((acc,\
    \ x) => acc || balance(acc, x)) && acc )\n        res  match {\n            case\
    \ true => \"Yes\"\n            case false => \"No\"\n        }", "        // Use\
    \ Stack to store the state of the current parentheses\n        var stack = Stack.empty[List[String]]\n\
    \        var result = \"\"\n        lst.foreach(x => {\n            if (x == \"\
    (\") {\n                if (stack.isEmpty) {\n                    stack.push Nil\n\
    \                } else {\n                    stack.head::stack.last\n      \
    \          }\n            } else if (x == \")\") {\n                if (stack.isEmpty)\
    \ {\n                    result += x\n                } else {\n             \
    \       stack.pop\n                }\n            } else {\n                stack\
    \ += x\n            }\n        })\n        if (stack.isEmpty) {\n            result\n\
    \        } else {\n            \"No\"\n        }", "        var index = 0\n  \
    \      while (index < lst.length) {\n            val stringStart = lst(index).length\n\
    \            var stringEnd = stringStart + 1\n            var leftCount = 0\n\
    \            var rightCount = 0\n            var nextLeft = 0\n            var\
    \ nextRight = 0\n            var nextStringStart = 0\n            while (nextRight\
    \ < stringEnd) {\n                nextRight = nextRight + 1\n                rightCount\
    \ = rightCount + 1\n                if (nextRight < stringEnd) {\n           \
    \         nextRight = nextRight + 1\n                }\n            }\n      \
    \      while (nextLeft < stringEnd) {\n                nextLeft = nextLeft + 1\n\
    \                leftCount = leftCount + 1\n                if (nextLeft < stringEnd)\
    \ {\n                    nextLeft = nextLeft + 1\n                }\n        \
    \    }\n            if (leftCount == rightCount) {\n                var nextStringEnd\
    \ = 0\n                while (nextStringStart < stringEnd) {\n               \
    \     nextStringEnd = nextStringEnd + 1\n                    nextStringStart =\
    \ nextStringStart + 1\n                }\n                nextStringEnd = nextStringEnd\
    \ + 1\n                if (nextStringStart < stringEnd) {\n                  \
    \  if (nextStringStart < nextRight) {\n                        if ((nextLeft <\
    \ stringEnd) && (nextRight < stringEnd)) {\n                            if (lst(index).charAt(nextStringStart)\
    \ == '(') {\n                                nextLeft = nextLeft + 1\n       \
    \                     } else {\n                                nextRight = nextRight\
    \ + 1\n                            }\n                        } else {\n     \
    \                       if (nextLeft < stringEnd) {\n                        \
    \        nextRight = nextRight + 1\n                            }\n          \
    \              }\n                    }\n                } else {\n          \
    \          if (nextRight < stringEnd) {\n                        nextLeft = nextLeft\
    \ + 1\n                    }\n                }\n                if (nextLeft\
    \ < stringEnd) {\n                    return \"Yes\"\n                } else {\n\
    \                    return \"No\"\n                }\n            }\n       \
    \     index = index + 1\n        }\n        return \"No\"", "        val l = new\
    \ mutable.HashSet[String](lst.head)\n        val r = new mutable.HashSet[String](lst.tail.head)\n\
    \        l.foreach { x => r.add (x) }\n        if (l.size == r.size) {\n     \
    \       return \"Yes\"\n        } else {\n            return \"No\"\n        }",
  "        val stack = new mutable.Stack[String]()\n        val res = \"Yes\"\n  \
    \      for (str <- lst) {\n            if (str.contains(\"(\") && stack.nonEmpty)\
    \ {\n                stack.push(str)\n            } else if (str.contains(\")\"\
    ) && stack.nonEmpty) {\n                if (!stack.isEmpty) {\n              \
    \      stack.peek match {\n                        case \"(\" =>\n           \
    \                 stack.push(str)\n                        case \")\" =>\n   \
    \                         if (stack.pop() == \"(\") {\n                      \
    \          res = \"No\"\n                            } else {\n              \
    \                  res = \"Yes\"\n                            }\n            \
    \        }\n                }\n            }\n        }\n        res", "     \
    \   if (lst.isEmpty) List(\"No\")\n        else {\n            val first = lst(0)\n\
    \            val rest = lst.drop(1)\n            var stack = new Stack[(Int, List[String])]\n\
    \            stack.push((0, List()))\n            while (stack.size > 0 && !stack.isEmpty)\
    \ {\n                val index = stack.pop()\n                val sub = sublist(index,\
    \ first, rest)\n                if (sub.size() > 0) {\n                    val\
    \ newIndex = index + 1\n                    val subSub = sublist(newIndex, first,\
    \ rest)\n                    val newStack = stack.map{\n                     \
    \   case (index, _) => if (index == newIndex) sub.head else (_, _) }\n       \
    \             val newSub = subSub ++ sub.tail\n                    stack.push((newIndex,\
    \ newSub))\n                } else {\n                    if (index == newIndex)\
    \ sub.head else \"No\"\n                }\n            }\n        }", "      \
    \  val strList = lst.flatten.toList\n        var open = 0\n        var close =\
    \ 0\n        var sum = 0\n        for (str <- strList) {\n            if (str\
    \ == \")\")\n                close += 1\n            if (str == \"(\")\n     \
    \           open += 1\n            sum += open\n            sum += close\n   \
    \     }\n        if (sum == strList.size)\n            return \"Yes\"\n      \
    \  return \"No\"", "        val stack = new mutable.Stack[String]()\n        var\
    \ curr : String = \"\"\n        for (aString <- lst) {\n            if (aString.contains(\"\
    (\")) {\n                stack.push(aString)\n            }\n            if (aString.contains(\"\
    )\")) {\n                curr = stack.pop()\n                if (curr.length !=\
    \ (aString.length + 1))\n                    return \"No\"\n            }\n  \
    \      }\n        if (stack.isEmpty)\n            return \"Yes\"\n        return\
    \ \"No\"", "        lst.foldLeft(\"\"){(str, s) =>\n            val (count, i)\
    \ = str.length match {\n                case 0 => (0, s)\n                case\
    \ count => count + (s.charAt(i) == ')')\n            }\n            if (count\
    \ > 0) str + s.subList(0, i) + \"Yes\"\n            else \"No\"\n        }", " \
    \       // (1) create two empty lists to store open and close parens\n       \
    \ var openParens = ListBuffer.empty[String]\n        var closeParens = ListBuffer.empty[String]\n\
    \        for (elem <- lst) {\n            // (2) append opening parens to the\
    \ open list\n            openParens append elem\n            // (3) append closing\
    \ parens to the close list\n            closeParens append elem\n        }\n \
    \       // (4) check the parentheses match\n        var flag = true\n        for\
    \ (elem <- closeParens) {\n            if ((closeParens contains elem)) {\n  \
    \              flag = flag && ((openParens contains elem))\n            }\n  \
    \      }\n        if (closeParens.length != openParens.length) {\n           \
    \ flag = false\n        }\n        if (closeParens.size != openParens.size) {\n\
    \            flag = false\n        }\n        if (flag) {\n            return\
    \ \"Yes\"\n        } else {\n            return \"No\"\n        }", "        val\
    \ s = lst.foldLeft(\"(\", \"(\") {\n            (acc, curr) =>\n             \
    \   curr.head == \"(\" ? acc + \" \" + curr : curr\n        }\n        (s.endsWith(\"\
    \ \")) ? s\"${s}.\" : s", "        if (lst.isEmpty) \"\"\n        val newList\
    \ = new mutable.Stack[String]\n        newList.toList foreach { x =>\n       \
    \     if (lst(0) != x) (newList.push(x): Unit)\n        }\n        if (newList.isEmpty)\
    \ \"\"\n        else {\n            val lst2 = newList.toList mkString \"(\"\n\
    \            val lst3 = lst.filterNot(x => x == lst2).mkString(\"(\", \"(\", \"\
    )\", \")\")\n            val lst4 = lst2.reverse.mkString(\"(\", \")\")\n    \
    \        lst4 match{\n                case x if x != \"\" => lst3\n          \
    \      case x => \"No\"\n            }\n        }", "        // Convert '()' into\
    \ '(', and convert '()()' into '(())'\n        val ls = lst.map( s => if(s ==\
    \ '(') '(' else '(' else ')'))\n        // Find the '(()' pair\n        val pair\
    \ = ls.find( s => s == '(()')\n        // If there's no pair, return No\n    \
    \    if(pair == None) return \"No\"\n        // If there's a pair, find the matching\
    \ ')' by index\n        val p = pair.index match {\n            case 0 => \"(()\"\
    \n            case 1 => \")\"\n            case _ => ls(pair.length - 1) // or\
    \ ls(pair.length - 2)\n        }\n        // If there's no matching ')', return\
    \ No\n        if(p != \"(\") return \"No\"\n        // If there's a matching ')',\
    \ find matching '(()' by index\n        val pair1 = ls.find( s => s == \")\")\n\
    \        val p1 = pair1.index match {\n            case 0 => \"(())\"\n      \
    \      case 1 => \")\"\n            case _ => ls(pair1.length - 1)\n        }\n\
    \        // If there's no '(())', return 'No'\n        if(p1 != p) return \"No\"\
    \n        // Otherwise, return 'Yes'\n        return \"Yes\"", "        val stack\
    \ = new mutable.Stack[String]\n        val result = \"No\"\n        lst.foreach\
    \ {\n            case x => (x match {\n                case \")\" => stack.push(x)\n\
    \                case \"))\" => stack.push(x)\n                case \")(\" =>\
    \ stack.push(x)\n                case \")()\" => stack.pop()\n               \
    \ case \")(\" => stack.pop()\n                case \"))\" => stack.pop()\n   \
    \             case _ => stack.pop()\n            })\n        }\n        if (stack.size\
    \ == 0) \"Yes\" else \"No\"", "        val stack = mutable.Stack[String]()\n \
    \       val map = mutable.Map[String, Boolean]()\n        lst.foreach(x => {\n\
    \            if (x.startsWith(\"(\") || x.startsWith(\")\")){\n              \
    \  if (!map.contains(x)){\n                    map.put(x.substring(1), true)\n\
    \                }\n                if (!map.contains(x.substring(1))){\n    \
    \                stack.push(x)\n                }\n            }\n        })\n\
    \        stack.foreach(x => {\n            map.put(x, false)\n        })\n   \
    \     val answer = stack.foldRight(true){ (x, y) =>\n            if (y && !x)\n\
    \                y\n            else\n                x\n        }\n        if\
    \ (answer){\n            \"Yes\"\n        }\n        else{\n            \"No\"\
    \n        }", "      def infixToPostfix(infixList : List[String]) =\n        infixList.foldLeft(\"\
    \") { (result, x) => result + x.reverse.mkString(\"(\") + \")\" }.trim\n\n   \
    \   def matching(curr : String, nextList : List[String], result : String) : String\
    \ = {\n        if (next == \"\") {\n          result\n        } else if (next\
    \ == curr) {\n          matching(infixToPostfix(nextList), nextList.tail, result\
    \ + curr)\n        } else {\n          matching(infixToPostfix(nextList), nextList.tail,\
    \ result)\n        }\n      }\n\n      def matching(infixList : List[String],\
    \ result : String) : String = {\n        if (infixList.isEmpty) {\n          result\n\
    \        } else {\n          matching(infixList.head, infixList.tail, result)\n\
    \        }\n      }\n\n      infixToPostfix(lst.head)\n      matching(\"\", lst.tail,\
    \ \"Yes\")", "      val newlst = lst.map(x => if (x == \"(\") 1 else 0)\n    \
    \  val n = newlst.head\n      val m = newlst.last\n      if (n != m)\n       \
    \ \"No\"\n      else if (n == 0)\n        \"Yes\"\n      else if (n == 1)\n  \
    \      \"Yes\"\n      else\n        matchParens(newlst.tail)", "        val arr\
    \ = lst.map(x => x.toChar)\n        val lefts = arr.takeWhile(x => x == '(').length\n\
    \        val rights = arr.dropWhile(x => x == '(').length\n        val balanced\
    \ = (lefts == rights)\n        if(balanced){\n            val arr = lst.map(x\
    \ => x.toChar)\n            val lefts = arr.takeWhile(x => x == '(').length\n\
    \            val rights = arr.dropWhile(x => x == '(').length\n            if(lefts\
    \ == rights){\n                val str = \"()\" + lst(0) + \"()\"\n          \
    \      if( arr.map(_.toInt).toSet.subsetOf(str.toSet) ){\n                   \
    \ \"Yes\"\n                }else{\n                    \"No\"\n              \
    \  }\n            }else{\n                \"No\"\n            }\n        }else{\n\
    \            \"No\"\n        }", "        // Iterate over the list\n        val\
    \ set = mutable.Set[String]()\n        for(i <- lst.indices) {\n            val\
    \ str = lst(i + 1)\n            if(!set.isEmpty) {\n                // We can't\
    \ concatenate if it's not empty\n                return \"No\"\n            }\n\
    \            if(!str.contains(\"(\")) {\n                // String doesn't contain\
    \ open\n                return \"No\"\n            }\n            if(!str.contains(\"\
    )\")) {\n                // String doesn't contain close\n                return\
    \ \"No\"\n            }\n            if(str == \"()\") {\n                // String\
    \ contains open and close\n                set.add(lst(i))\n            }\n  \
    \      }\n\n        // If we reach here, then string concatenation can be done.\n\
    \        val result = \"Yes\"\n        for(i <- 0 until set.size) {\n        \
    \    result += \"(\" + set.apply(i) + \")\"\n        }\n        result", "   \
    \     val stack = mutable.Stack[String]()\n        stack.push(\"(\")\n       \
    \ val result = \"\"\n        for(i <- 0 until lst.length) {\n            if(lst(i)\
    \ == \"(\") {\n                stack.push(\"(\")\n            }\n            else\
    \ if(lst(i) == \")\") {\n                if(stack.nonEmpty) {\n              \
    \      val tmp = \"\"\n                    for(j <- 0 until stack.size) {\n  \
    \                      tmp += stack.pop(j)\n                    }\n          \
    \          result += tmp\n                }\n                stack.pop()\n   \
    \         }\n            else if(stack.nonEmpty) {\n                stack.push(lst(i))\n\
    \            }\n            else if(lst(i) != \")\") {\n                return\
    \ \"No\"\n            }\n        }\n        stack.clear\n        result == \"\
    (\" + result + \")\"", "        // get all parentheses in lst\n        val (opens,\
    \ closes) = lst.map(_ match {\n            case '('  => 1\n            case ')'\
    \  => 1\n            case _    => 0\n        }).toList\n\n        // get the left\
    \ side of every paranthesis, if the list is balanced\n        val lefts = lst.map\
    \ {\n            case s if opens > closes => \"()\"\n            case s => \"\
    ()\" + s\n        }\n\n        // check the right side of every paranthesis, if\
    \ the list is balanced\n        val rights = lst.map {\n            case s if\
    \ closes > opens => \"()\"\n            case s => \"(\" + s\n        }\n\n   \
    \     // if the left and right side of the list are balanced, return \"Yes\"\n\
    \        if(lefts.toSet.size == rights.toSet.size) \"Yes\"\n        else \"No\"",
  "        // find all openings and closings\n        var openings : List[String]\
    \ = Nil\n        var closings : List[String] = Nil\n        var opening_count\
    \ : Int = 0\n        var closing_count : Int = 0\n        for (l<-lst) {\n   \
    \         val chars : List[Char] = l.toList\n            for (c<-chars) {\n  \
    \              if (c == '(') openings = openings :+ c\n                else if\
    \ (c == ')') closings = closings :+ c\n            }\n            opening_count\
    \ = openings.size\n            closing_count = closings.size\n        }\n    \
    \    // get all combination\n        var com = for (l<-0 to openings.size-1) yield\
    \ {\n            for (c<-0 to closings.size-1) yield {\n                for (o<-0\
    \ to openings.size()-1) yield {\n                    for (c<-0 to closings.size()-1)\
    \ yield {\n                        // check if it is possible to make all openings\
    \ and closings\n                        val opening_pos = openings(o) + c\n  \
    \                      val closing_pos = closings(c)+o\n                     \
    \   val pos1 = o*closings.size+c*openings.size+l*openings.size\n             \
    \           val pos2 = o*closings.size+c*openings.size+l*openings.size+openings.size()\n\
    \                        val pos3 = o*closings.size+c*openings.size+openings.size()*openings.size+closing_pos\n\
    \                        val pos4 = o*closings.size+openings.size()*openings.size+closing_pos+closings.size\n\
    \                        if ((pos1 == pos2) || (pos1 == pos3) || (pos1 == pos4)\
    \ || (pos2 == pos3) || (pos2 == pos4) || (pos3 == pos4) || (pos1 == pos2) && (pos2\
    \ == pos3) && (pos3 == pos4))\n                        yield (o,c,l)\n       \
    \             }\n                }\n            }\n        }\n        // check\
    \ if all combinations are valid\n        for (x <- com) if (x._2 == opening_count+closing_count)\n\
    \            yield \"Yes\"\n        else\n            yield \"No\"", "       \
    \ val leftParens = lst.count(lst contains \"(\")\n        val rightParens = lst.count(lst\
    \ contains \")\")\n\n        if (leftParens == 0 || rightParens == 0)\n      \
    \      \"No\"\n        else {\n            val s = lst.mkString(\"\")\n      \
    \      val start = s.lastIndexOf(\"(\")\n            val end = s.lastIndexOf(\"\
    )\")\n            if (start < end) {\n                val str = s.substring(start\
    \ + 1, end).replaceAll(\"\\\\\", \"\").toInt\n                if (str % 2 == 0)\n\
    \                    \"Yes\"\n                else\n                    \"No\"\
    \n            }\n            else {\n                \"No\"\n            }\n \
    \       }", "        val len = lst.size\n        if(len == 0) \"No\"\n       \
    \ else {\n            val stack = mutable.Stack[String]()\n            val isgood\
    \ = lst.foldLeft(true)((x,y) => x && matchParens_helper(stack,0,x,y))\n      \
    \      val result = if (isgood) \"Yes\" else \"No\"\n            stack.toList.reverse.mkString(\"\
    \")\n        }", "        val arr = lst.map(x => x.indexOf(\"(\") + 1, x.indexOf(\"\
    )\")).toArray\n        val l = arr.foldLeft(0)((x, y) =>\n            if (x >\
    \ y) 1 else 0)\n        if (l == 0) \"Yes\" else \"No\"", "        val stack =\
    \ mutable.Stack[String]()\n        val strings = mutable.ListBuffer[String]()\n\
    \        val lst_stack = mutable.Stack[List[String]]()\n        for (a <- lst){\n\
    \            strings += a\n            lst_stack += a :: stack\n            stack.push(a)\n\
    \        }\n        val lst_stack2 = lst_stack.toList\n        val stack_size\
    \ = lst_stack2.size\n        val strings2= strings.toList\n        val stack_size2\
    \ = strings2.size\n        val count = stack_size2 - stack_size\n        for (i\
    \ <- 0 until count){\n            val a = lst_stack2.pop()\n            val b\
    \ = strings2.pop()\n            val stack_size_new=stack.size\n            val\
    \ strings_new=strings.toList\n            val stack_size_new2 = strings_new.size\n\
    \            if (stack_size_new2<stack_size_new){\n                return \"No\"\
    \n            }\n            stack+=b\n            strings+=a\n            lst_stack2+=stack\n\
    \            strings2+=b\n        }\n        val stack_size_final=stack.size\n\
    \        val strings_final=strings.toList\n        if (stack_size_final<stack_size){\n\
    \            return \"No\"\n        }\n        val stack_string = stack.toList\n\
    \        val stack_string_final = stack_string.mkString\n        val strings_final2\
    \ = strings_final.mkString\n        if (stack_string_final!=strings_final2){\n\
    \            return \"No\"\n        }\n        return \"Yes\"", "        val l2\
    \ = lst.size\n        val set1 = new HashSet[Int]()\n        val set2 = new HashSet[Int]()\n\
    \        for (str <- lst) {\n            val index = str.indexOf(\"(\")\n    \
    \        if (index < 0)\n                throw new IllegalArgumentException(\"\
    String \" + str + \" has no opening \")\n            for (x <- 0 until str.lastIndexOf(\"\
    )\", index)) {\n                val count = str.length - (x + 1)\n           \
    \     if (set1(count) && set2(count) && set1(count) == set2(count)) {\n      \
    \              return \"No\"\n                }\n                set1(count)\n\
    \                set2(count)\n            }\n        }\n        return \"Yes\"",
  "        // Write your code here\n        var l: Option[String] = None\n       \
    \ var r: Option[String] = None\n        for(str <- lst.head :: lst.tail){\n  \
    \          if(str == \"(\"){\n                l =  Some(str + lst.head)\n    \
    \        }\n            if(str == \")\"){\n                r = Some(str + lst.tail)\n\
    \            }\n        }\n        if(l.isEmpty || r.isEmpty){\n            return\
    \ \"No\"\n        }\n        return \"Yes\"", "        val pList = lst.map(lst\
    \ => (lst, lst.length)).toMap\n        def validParens(lst: List[String]): Boolean\
    \ = {\n            if (lst.length < 2) false\n            else {\n           \
    \     val l1 = lst.head\n                val l2 = lst.last\n                val\
    \ l1 = l1.toChar\n                val l2 = l2.toChar\n                (pList.get(l1)(l2))\
    \ match {\n                    case Some(x) => x._1\n                    case\
    \ None => false\n                }\n            }\n        }\n        validParens(lst)\
    \ match {\n            case true => \"Yes\"\n            case false => \"No\"\n\
    \        }", "        def isValid(lst: List[String], i : Int): String = {\n  \
    \          if (lst(i).charAt(lst(i).length - 1) != '(') List(\"No\")\n       \
    \     else {\n                val cur = lst(i).charAt(0)\n                val\
    \ left = isValid(lst, (i - 1))\n                val right = isValid(lst, (i -\
    \ 2))\n                if (left != right) left\n                else {\n     \
    \               if (cur == '(') right\n                    else left\n       \
    \         }\n            }\n        }\n        val len = lst.size\n        if\
    \ (len == 1) lst(0)\n        else if (len == 2) lst(1)\n        else isValid(lst,\
    \ 0)", "        // Use recursion to solve the problem\n        val lst2= lst.map(x\
    \ => if (x == \"(\") 1 else 0).reverse\n        val lst3= lst2.foldLeft(0)(_ +\
    \ _)\n        if (lst3 < lst) s\"Yes\" else s\"No\"", "      var res = \"No\"\n\
    \      val open = lst(0)\n      val close = lst(1)\n      var stack = List[String]()\n\
    \      stack :+= open\n      while (open.length > 0 || close.length > 0) {\n \
    \       if (open.length == 0) {\n          res = \"Yes\"\n          break\n  \
    \      }\n        if (close.length == 0) {\n          res = \"No\"\n         \
    \ break\n        }\n        val x = open(0)\n        val y = close(0)\n      \
    \  val newOpen = open.drop(1)\n        val newClose = close.drop(1)\n        if\
    \ (y == \"(\") {\n          if (stack.isEmpty) {\n            res = \"No\"\n \
    \           break\n          }\n          if (stack == newOpen) {\n          \
    \  stack :+= y\n          }\n          if (stack == newClose) {\n            stack\
    \ :+= y\n          }\n          if (stack == newOpen || stack == newClose) {\n\
    \            res = \"No\"\n            break\n          }\n        } else {\n\
    \          if (stack.isEmpty) {\n            res = \"No\"\n            break\n\
    \          }\n          if (stack == newClose) {\n            stack :+= y\n  \
    \        }\n          if (stack == newOpen || stack == newClose) {\n         \
    \   res = \"No\"\n            break\n          }\n        }\n        open += x\n\
    \        close += y\n      }\n      res", "        val openings = lst.map( _.length\
    \ )\n        val closings = lst.map( _.length )\n        val openingMap = mutable.Map.empty[Int,\
    \ Int]\n        val closingMap = mutable.Map.empty[Int, Int]\n        lst.foreach(\
    \ x => {\n            if( (openings(x) != 0) || (closings(x) != 0) ) {\n     \
    \           openingMap += (openings(x) -> (x + 1))\n                closingMap\
    \ += (closings(x) -> (x + 1))\n            }\n        })\n        if( (openingMap\
    \ == closingMap) && (openings == closings) ) {\n            return \"Yes\"\n \
    \       } else {\n            return \"No\"\n        }", "       val stack = new\
    \ mutable.Stack[Int]()\n       lst.foreach(x => stack += x.length)\n       if(stack.last\
    \ < 0)\n         return \"No\"\n       while(stack.last > 0) {\n          if(stack.last\
    \ > 1) {\n             stack -= 2\n             stack += 2\n          }\n    \
    \      val len = stack.pop()\n          if(len < 0)\n             return \"No\"\
    \n          else if(len > 0)\n             stack.push(stack.last - len)\n    \
    \   }\n       if(stack.last == 0)\n        return \"Yes\"", "        def stackCounts(s\
    \ : List[String], r : List[String], i : Int) : Int = {\n            val stk =\
    \ ArrayBuffer(s.head).init\n\n            var count : Int = 0\n            var\
    \ stack : List[String] = stk\n\n            while(i < l.length){\n           \
    \     if(l(i) == \"(\"){\n                    count += stackCounts(stack.pop,\
    \ l(i + 1), 1)\n                    stack += l(i + 1)\n                }\n   \
    \             i += 1\n            }\n\n            count\n        }\n\n      \
    \  val l = lst.head\n        val stk = ArrayBuffer(l).init\n\n        var count\
    \ : Int = 0\n        var stack : List[String] = stk\n\n        while(stack.length\
    \ > 0){\n            count += stackCounts(stack.pop, lst.last, 1)\n        }\n\
    \n        if(count == l.length)\n            return \"Yes\"\n        else\n  \
    \          return \"No\"", "        def matchParen(st: List[String], acc : List[String],\
    \ acc2: (List[String], List[String], Int)): (List[String], List[String], Int)\
    \ = {\n            if (st.head == \"()\") {\n                matchParen(st.tail,\
    \ acc.reverse, acc2)\n            } else if (st.head == \"[]\") {\n          \
    \      matchParen(st.tail, acc, acc2)\n            } else if (st.head == \"{}\"\
    ) {\n                matchParen(st.tail, acc.reverse, acc2)\n            } else\
    \ if (st.head == \")\") {\n                if (acc.head == \"()\") {\n       \
    \             if (acc.last == \"()\") {\n                        acc\n       \
    \             } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else if (acc.head == \"[]\") {\n   \
    \                 if (acc.last == \"[]\") {\n                        acc\n   \
    \                 } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else if (acc.head == \"{}\") {\n   \
    \                 if (acc.last == \"{}\") {\n                        acc\n   \
    \                 } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else if (acc.head == \"]\") {\n    \
    \                if (acc.last == \"[]\") {\n                        acc\n    \
    \                } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else if (acc.head == \"}\") {\n    \
    \                if (acc.last == \"{}\") {\n                        acc\n    \
    \                } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else {\n                    if (acc.last\
    \ == st.head) {\n                        matchParen(st.tail, acc, acc2)\n    \
    \                } else {\n                        matchParen(st.tail, acc.reverse\
    \ ++ List(\"()\"), acc2)\n                    }\n                }\n         \
    \   } else if (st.head == \"[\") {\n                if (acc.head == \"()\") {\n\
    \                    if (acc.last == \"()\") {\n                        acc\n\
    \                    } else {\n                        matchParen(st.tail, acc,\
    \ acc2)\n                    }\n                } else if (acc.head == \"[]\"\
    ) {\n                    if (acc.last == \"[]\") {\n                        acc\n\
    \                    } else {\n                        matchParen(st.tail, acc,\
    \ acc2)\n                    }\n                } else if (acc.head == \"{}\"\
    ) {\n                    if (acc.last == \"{}\") {\n                        acc\n\
    \                    } else {\n                        matchParen(st.tail, acc,\
    \ acc2)\n                    }\n                } else if (acc.head == \"]\")\
    \ {\n                    if (acc.last == \"[]\") {\n                        acc\n\
    \                    } else {\n                        matchParen(st.tail, acc,\
    \ acc2)\n                    }\n                } else if (acc.head == \"}\")\
    \ {\n                    if (acc.last == \"{}\") {\n                        acc\n\
    \                    } else {\n                        matchParen(st.tail, acc,\
    \ acc2)\n                    }\n                } else {\n                   \
    \ if (acc.last == st.head) {\n                        matchParen(st.tail, acc,\
    \ acc2)\n                    } else {", "        val stack = mutable.Stack[String]()\n\
    \        val stackList = mutable.ListBuffer[String]()\n\n        for(x<-lst){\n\
    \            if(x==\"(\")\n            stack += x\n            if(x==\")\"){\n\
    \                stackList += stack.toList\n                stack.clear()\n  \
    \          }\n        }\n        stackList match {\n            case x if(x ==\
    \ stack.toList) => \"Yes\"\n            case x if(x!=stack.toList) => \"No\"\n\
    \        }", "      val (_, _, s1) = lst\n      val (_, _, s2) = lst.reverse\n\
    \      val p1 = s1.map(c => if (c == '(') '!' else '!').toChar\n      val p2 =\
    \ s2.map(c => if (c == '(') '!' else '!').toChar\n      val a = p1 ++ p2\n   \
    \   val b = a.zipWithIndex.map { case (l, i) => if (l == '!') i.toString else\
    \ l}\n      val index = b.indexOf(0)\n      (index != -1) && (\"Yes\")", "   \
    \     val str = lst.mkString(\"(\", \"\", \")\")\n        val set = sc.parallelize(str.split(\"\
    \\\\(\")).distinct\n        val map = set.map(r => (r, 1)).reduceByKey(_ + _).map{\
    \ case (r, (i, j)) => (i, j, r) }.toMap\n        val len = lst.size\n        def\
    \ checker(i : Int) : Boolean = {\n            if (i > len - 1) false else if (map(i)\
    \ > (map.size - len)) false else if (map(i) < map(len - 1)) checker(i + 1)\n \
    \           else check(i, map.size - 1) || checker(i + 1)\n        }\n       \
    \ val res = checker(0)\n        if (res) \"Yes\" else \"No\"", "        var lst1\
    \ = lst.tail\n        val lst2 = lst.head\n        if (lst1 == lst2) {\n     \
    \       \"Yes\"\n        } else {\n            val lst3 = lst1 -- lst2\n     \
    \       val lst4 = lst2 -- lst3\n            lst4.foldLeft(\"\"){ (s, x) => s\
    \ ++ x }\n        }", "        def isValidParenthesis(s  : String) : Boolean =\
    \ {\n            val l = s.toList\n            l.size < 2 || l.last != \"(\" &&\
    \ l.first != \")\"\n        }\n        val map = new scala.collection.mutable.HashMap[String,String]()\n\
    \        for(x <- lst ) map(x) += \"*\"\n        val ls = map.toSeq\n        ls.sortBy(_._1).reverse\
    \ // sort by key then reverse\n        val result = ls.find(_._2 == \"*\").map(_._1)\n\
    \        if(!result.get.isEmpty) result else \"No\"", "        var final = lst(0)\n\
    \        val stack = new mutable.Stack[String]()\n        for(a <- lst) {\n  \
    \          if(!stack.isEmpty) {\n                if(stack.toList.last == (a))\
    \ {\n                    stack.poll()\n                } else {\n            \
    \        return \"No\"\n                }\n            }\n            stack +=\
    \ a\n        }\n        if(stack.size == 0) {\n            return \"Yes\"\n  \
    \      } else {\n            return \"No\"\n        }", "        var flag = 0\n\
    \        val stack = new mutable.Stack[String]()\n        val stack2 = new mutable.Stack[String]()\n\
    \        val stack3 = new mutable.Stack[String]()\n\n        for(i <- 0 until\
    \ lst.size) {\n            if((lst(i) == \"(\" && stack.nonEmpty) || (lst(i) ==\
    \ \")\" && stack.nonEmpty)) {\n                stack3 += lst(i).substring(stack3.size,\
    \ stack3.size + 1)\n                flag += 1 // stack flag\n            }\n \
    \           else if(lst(i) == \"(\" && stack.isEmpty) {\n                stack\
    \ += lst(i)\n                flag += 1 // stack flag\n            }\n        \
    \    else if(lst(i) == \")\" && stack.isEmpty) {\n                stack2 += lst(i)\n\
    \                flag += 1 // stack flag\n            }\n            else if(lst(i)\
    \ == \")\" && stack2.nonEmpty && stack3.nonEmpty) {\n                val s = stack2.pop\
    \ + stack3.pop\n                stack2 += s\n                stack3 += s\n   \
    \             flag += 2 // stack flag\n            }\n            else if(lst(i)\
    \ == \"(\" && stack2.nonEmpty) {\n                val s = stack2.pop + lst(i)\n\
    \                stack2 += s\n                flag += 2 // stack flag\n      \
    \      }\n            else if(lst(i) == \")\" && stack2.nonEmpty && stack.nonEmpty)\
    \ {\n                val s = stack2.pop + stack.pop\n                stack2 +=\
    \ s\n                flag += 2 // stack flag\n            }\n            else\
    \ if(lst(i) == \"(\" && stack.nonEmpty && stack3.nonEmpty) {\n               \
    \ val s = stack.pop + stack3.pop\n                stack += s\n               \
    \ flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\"\
    \ && stack.nonEmpty && stack3.nonEmpty) {\n                val s = stack.pop +\
    \ stack3.pop\n                stack += s\n                flag += 2 // stack flag\n\
    \            }\n            else if(lst(i) == \"(\" && stack2.nonEmpty && stack.nonEmpty)\
    \ {\n                val s = stack2.pop + stack.pop\n                stack2 +=\
    \ s\n                flag += 2 // stack flag\n            }\n            else\
    \ if(lst(i) == \")\" && stack2.nonEmpty && stack.nonEmpty) {\n               \
    \ val s = stack2.pop + stack.pop\n                stack2 += s\n              \
    \  flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\"\
    \ && stack.nonEmpty && stack2.nonEmpty) {\n                val s = stack.pop +\
    \ stack2.pop\n                stack += s\n                flag += 2 // stack flag\n\
    \            }\n            else if(lst(i) == \"(\" && stack2.non", "        var\
    \ a: List[String] = lst\n        var temp: List[String] = Nil\n        while(!a.isEmpty)\
    \ {\n            if(a.head == \")\") {\n                temp = a :: temp\n   \
    \             a = a.tail\n                if(!a.isEmpty) {\n                 \
    \   a.remove(0)\n                }\n            }\n            else {\n      \
    \          temp = a :: temp\n                a = a.tail\n                if(!a.isEmpty)\
    \ {\n                    a.remove(0)\n                }\n            }\n     \
    \   }\n        if(temp.isEmpty) {\n            return \"Yes\"\n        }\n   \
    \     else {\n            return \"No\"\n        }", "        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        for (i <- 0 until lst.length)\
    \ {\n            if (lst(i) == \"(\" && stack.nonEmpty) {\n                val\
    \ top = stack.pop()\n                if (top != \"(\") {\n                   \
    \ queue += top\n                }\n            } else if (lst(i) == \")\" && stack.nonEmpty\
    \ && queue.isEmpty) {\n                stack += \")\"\n            } else if (lst(i)\
    \ == \")\") {\n                stack += \")\"\n            } else if (lst(i) ==\
    \ \"(\") {\n                queue += \"(\"\n            }\n        }\n       \
    \ if (stack.nonEmpty && stack.last.equals(\"(\")) {\n            return \"Yes\"\
    \n        }\n        return \"No\"", "        val openParens = Set(\"(\")\n  \
    \      val closeParens = Set(\")\") \n        val lst = lst.sorted\n        if\
    \ (lst.head != lst.tail.head) (\"No\") \n        else if (openParens.isEmpty ||\
    \ closeParens.isEmpty) { (\"No\") }\n        else (findMatch(lst.head)) match\
    \ {\n            case (Some(findMatch(lst.head)) if findMatch(lst.head) == lst.head\
    \ && lst.head.head == lst.head.tail ) => \"Yes\"\n            case _ => \"No\"\
    \n        }", "        val p = lst.filter(_.toList.length == 1).head\n       \
    \ val q = lst.filter(_.toList.length == 0).head\n        if(lst.contains(p) &&\
    \ lst.contains(q)){\n            val n = new Stack[String]()\n            for(i\
    \ <- 0 until lst.size){\n                if(i == p.toString.length){\n       \
    \             n.push(\"(\")\n                }else if(lst.contains(p.toString.substring(0,i))){\n\
    \                    n.push(p.toString.substring(0,i))\n                }else{\n\
    \                    n.push(p.toString.substring(0,i) + n.pop())\n           \
    \     }\n            }\n            if(n.toString.equals(\"(\")){\n          \
    \      \"Yes\"\n            }else{\n                \"No\"\n            }\n  \
    \      }else{\n            \"No\"\n        }", "        def rec(stack: List[String],\
    \ currStack: List[String], i : Int) : List[String] = {\n            if (i == lst.size)\
    \ {\n                if (currStack == lst.head) {\n                    return\
    \ stack\n                }\n            }\n            if (i == 0) {\n       \
    \         if (currStack.size != lst.head.size) {\n                    return \"\
    No\"\n                }\n                else {\n                    val stackCopy\
    \ = stack.clone()\n                    val currStackCopy = currStack.clone()\n\
    \                    while (stackCopy.nonEmpty && currStackCopy.nonEmpty && stackCopy.head\
    \ == currStackCopy.head) {\n                        stackCopy = stackCopy.tail\n\
    \                        currStackCopy = currStackCopy.tail\n                \
    \    }\n                    if (stackCopy.nonEmpty || currStackCopy.nonEmpty)\
    \ {\n                        val stackCopyStr = stackCopy.mkString(\"\")\n   \
    \                     val currStackCopyStr = currStackCopy.mkString(\"\")\n  \
    \                      if (currStackCopyStr == stackCopyStr) {\n             \
    \               return \"Yes\"\n                        }\n                  \
    \  }\n                }\n            }\n            val nextOpen = lst.head(i)\
    \ match {\n                case '(' => true\n                case ')' => true\n\
    \                case _ => false\n            }\n            if (nextOpen && stack.size\
    \ < lst.head.size) {\n                currStack.push(lst.head(i))\n          \
    \      val newStack = stack.tail +: currStack.tail\n                rec(newStack,\
    \ lst, i + 1)\n                currStack = currStack.tail\n            }\n   \
    \         else {\n                rec(stack, currStack, i + 1)\n            }\n\
    \        }\n        rec(new ListBuffer[String](), new ListBuffer[String](), 0)",
  "        var good = True\n        val left  = lst.head\n        val right = lst(1\
    \ until lst.size)\n        val leftList = lst.take(left.length)\n        val rightList\
    \ = lst.drop(right.length)\n        var i = leftList.size\n        while (i <\
    \ leftList.size) {\n            if (right(i) != left(i)) {\n                good\
    \ = False\n                break\n            }\n            i += 1\n        }\n\
    \        if (good)\n            \"Yes\"\n        else\n            \"No\"", " \
    \       // TODO:\n        // Write your code here\n        var str = lst(0).mkString(\"\
    \")\n        var flag = true\n        for(i <- 1L to lst.size) {\n           \
    \ str += lst(i)\n            if(str.charAt(str.length-1) != '(' || str.charAt(0)\
    \ == '(') {\n                flag = false\n            }\n            str += lst(i)\n\
    \        }\n        if(flag) return \"Yes\"\n        return \"No\"", "       \
    \ val n = lst.size\n        if (n == 0) {\n          \"No\"\n        } else if\
    \ (n == 1) {\n          val p1 = lst(0) match {\n            case \"(\" : true\n\
    \            case \")\" : true\n            case _ : false\n          }\n    \
    \      if (p1) {\n            \"Yes\"\n          } else {\n            \"No\"\n\
    \          }\n        } else {\n          val m = lst.foldLeft(0)((m, n) => if\
    \ (n <= m) n + 1 else n)\n          val goodStrings = (1 to m).map { x =>\n  \
    \          (1 to n).map { y =>\n              if (x != y && lst.exists(y => lst(y)\
    \ == \"(\" && lst(y - 1) == \"(\" && lst(y - 2) == \")\")) return true\n     \
    \         else false\n            }\n          }.flatten.filter(x => x).mkString(\"\
    ,\")\n          if (goodStrings == \"false\") \"No\" else \"Yes\"\n        }",
  "        val str = lst.last\n        val lst1 = lst.init drop 1\n        var isGood\
    \ = True\n        val stack = new Stack[String]\n        val lst2 = lst1.map(x\
    \ => x.toChar).map(x => x.toInt)\n        val lst3 = lst.map(x => x.toChar).map(x\
    \ => x.toInt)\n        for(i <- lst3) stack.push(\"\" + i)\n        for(i <- lst2)\
    \ stack.push(i.toString + stack.pop())\n        val goodStr = stack.pop()\n  \
    \      if(goodStr == str) isGood\n        else isGood.toString", "        val\
    \ set1 = lst.map(x => if (x == \"(\") 1 else 0)\n        val set2 = lst.map(x\
    \ => if (x == \"()\") 0 else 1)\n        val set3 = set1 ++ set2\n        val\
    \ set4 = lst.map(x => if (x == \"(()\") 0 else 1)\n        val set5 = set4 ++\
    \ set3\n        val set6 = lst.map(x => if (x == \")\") 0 else 1)\n        val\
    \ set7 = set5 ++ set6\n        if (set7.distinct.size == lst.size && set7.distinct.size\
    \ == set1.size + set2.size && set7.distinct.size == set4.size + set3.size + set6.size\
    \ && set7.distinct.size == set5.size + set6.size) {\n            val result =\
    \ set7.distinct\n            val str = result.mkString(\"(\", \", \", \")\")\n\
    \            if (str.length == lst.size && str.size == set1.size + set2.size +\
    \ set4.size + set3.size + set5.size + set6.size) {\n                return \"\
    Yes\"\n            }\n        }\n        return \"No\"", "        val stack =\
    \ Stack[String]()\n        val leftmost = Stack[String]()\n        lst.foreach(elem\
    \ => {\n            val open = elem.substring(0, elem.indexOf(\"(\"))\n      \
    \      val close = elem.substring(elem.indexOf(\"(\"))\n            if (stack.isEmpty\
    \ && (elem.indexOf(\"(\") <= elem.indexOf(\")\"))) stack.append(open)\n      \
    \      if (stack.isEmpty && (elem.indexOf(\"(\") < elem.indexOf(\")\")) && (close.length\
    \ == 0)) stack.append(close)\n            if (open != \"\") leftmost.append(open)\n\
    \            if (close != \"\") leftmost.append(close)\n        })\n        if\
    \ (leftmost.size == 2) \"Yes\" else \"No\"", "        val stack = mutable.Stack[String]()\n\
    \        val res = new collection.mutable.StringBuilder\n        for (x <- lst)\
    \ {\n            if (x match {\n                \"(\" =>\n                   \
    \ stack.push(x)\n                case \")\" =>\n                    while (!stack.isEmpty)\
    \ {\n                        if (stack.peek() match {\n                      \
    \      \"(\" =>\n                                stack.pop()\n               \
    \             case \")\" =>\n                                res.append(\"(\"\
    )\n                                res.append(\")\")\n                       \
    \     case _ =>\n                                res.append(stack.pop())\n   \
    \                     }) else\n                            res.append(stack.pop())\n\
    \                    }\n                case \"(\" =>\n                    stack.push(x)\n\
    \                case \")\" =>\n                    res.append(\"(\")\n      \
    \          }) else\n                    res.append(x)\n        }\n        res.toString()",
  "        if (lst.size < 2)\n            throw new RuntimeException(\"Error! The\
    \ list must contain two elements.\");\n        val opening = lst.head;\n     \
    \   val closing = lst.last;\n        var counter = 0;\n        var result = \"\
    \";\n        for(i <- 0 until opening.length()) {\n            if (opening(i)\
    \ == '(') {\n                if (closing != '(') {\n                    result\
    \ += closing(i);\n                    counter++;\n                }\n        \
    \    } else { // closing != '('\n                if (opening != '(' && counter\
    \ == 0) // if opening == '('\n                    result += \"()\"\n         \
    \       else if (opening != '(' && counter == 1) // if opening != (')\n      \
    \              result += \"()\"\n            }\n        }\n        if (counter\
    \ != 0)\n            result = \"No\"\n        else\n            result = \"Yes\"",
  "        var result = \"No\"\n        var stack = Nil\n        var openStack = Nil\n\
    \        lst.foreach(x => {\n            stack :+ x\n            if (x.equals(\"\
    )\")) {\n                openStack = stack.filter(_ != x)\n                result\
    \ +=  (openStack == stack && openStack.length == 1)\n            }\n         \
    \   if (x.equals(\"(\")) {\n                openStack = stack.filter(_ != x)\n\
    \                result +=  (openStack.length == 0 && stack.forall(_.equals(\"\
    )\")))\n            }\n        })\n        result", "        val parenStack =\
    \ mutable.Stack[Boolean]()\n        val res = \"Yes\"\n\n        // TODO: Complete\
    \ this function\n        for (str <- lst) {\n            // if open and close\
    \ matches push true to parenStack\n            if (str.contains(\"(\") && str.contains(\"\
    )\")) {\n                parenStack.push(true)\n            }\n            //\
    \ if closing and open matches pop false to parenStack\n            if (str.contains(\"\
    )\") && str.contains(\"(\")) {\n                parenStack.pop()\n           \
    \ }\n            // if closing and open doesn't match push false to parenStack\n\
    \            else if (!str.contains(\")\") && !str.contains(\"(\")) {\n      \
    \          parenStack.push(false)\n            }\n            // if open and close\
    \ doesn't match push true to parenStack\n            else {\n                parenStack.push(true)\n\
    \            }\n        }\n\n        // if all parenthesis are balanced return\
    \ Yes\n        if (parenStack.size == lst.length) {\n            res = s\"Yes\"\
    \n        }\n        // if parenthesis are not balanced return No\n        else\
    \ {\n            res = s\"No\"\n        }\n        res", "        def isGood(s:\
    \ String) : Boolean = {\n            val opened = Set(('(',')'))\n           \
    \ val closed = Set((')',')'))\n            val re = opened.union(closed).union(closed.toSet)\n\
    \            val closeParen = if (s == '(') ')' else ')'\n            val openParen\
    \ = if (s == '(' '(') '(' else ')'\n            re(lst) contains closeParen\n\
    \        }\n        if (isGood(lst(0))) {\n            if (isGood(lst(1))) {\n\
    \                \"Yes\"\n            } else {\n                \"No\"\n     \
    \       }\n        } else {\n            \"No\"\n        }", "        val newlst\
    \ = lst.filter(_ != \"\")\n        var newlstStr = String.join(\"\", newlst)\n\
    \        var open = 0\n        var close = 0\n        val newlstStr = newlstStr.grouped(2).map\
    \ { list =>\n            if(list.length == 0)\n                list\n        \
    \    else\n                if(list(0) == '(')\n                    open += 1\n\
    \                else\n                    close += 1\n        }\n\n        while(open\
    \ > 0 && close > 0) {\n            if(newlstStr.take(newlstStr.length - open).length\
    \ <= newlstStr.length - close + 1) {\n                newlstStr = newlstStr.drop(newlstStr.length\
    \ - open)\n                open -= 1\n                close -= 1\n           \
    \ }\n            else {\n                open -= 1\n                close -= 1\n\
    \            }\n        }\n        val newlstStr2 = newlstStr.grouped(2).map {\
    \ list =>\n            if(list.length == 0)\n                list\n          \
    \  else\n                if(list(0) == '(')\n                    list\n      \
    \          else\n                    list.reverse\n        }\n        if(newlstStr2.toSeq.isEmpty)\n\
    \            \"No\"\n        else\n            \"Yes\"", "        val stack =\
    \ mutable.Stack[String]()\n        stack.push(\"(\")\n        stack.push(\")\"\
    )\n\n        while(!stack.isEmpty) {\n            val s = stack.pop()\n      \
    \      val len = lst(0).length\n            val idx = s.length - len\n       \
    \     if(idx <= 0) return \"No\"\n            if(s.equals(lst(idx))) return \"\
    Yes\"\n            stack.push(s)\n        }\n        return \"No\"", "       \
    \ val open = Set.empty[String]\n        val close = Set.empty[String]\n      \
    \  lst.foreach(x => open += x.toLowerCase)\n        lst.foreach(x => close +=\
    \ x.toLowerCase)\n        open.size == close.size\n        val stack = ListBuffer.empty[String]\n\
    \        val result = \"Yes\"\n        val stackSize = lst.size + 1\n        for\
    \ (i <- 0 until stackSize) {\n            val currentChar = lst(i).toLowerCase\n\
    \            if (currentChar == '(') stack += currentChar\n            if (currentChar\
    \ == ')') stack -= currentChar\n            if (stack.size == 0) result += \"\
    Yes\"\n        }\n        result", "        def isValidParens(st: String): Boolean\
    \ = st.contains(\"(\") && st.contains(\")\")\n        val stack = mutable.Stack[String]()\n\
    \        for (i <- 0 to lst.size - 1) {\n            if (isValidParens(lst(i)))\
    \ {\n                stack += lst(i)\n                while (isValidParens(stack.last))\
    \ {\n                    stack += stack.last\n                }\n            }\n\
    \        }\n        if (stack.toList.size > 0) {\n            return \"Yes\"\n\
    \        } else {\n            return \"No\"\n        }", "        val stack =\
    \ mutable.Stack[String]()\n        val output = mutable.ListBuffer.empty[String]\n\
    \        val bracketCounts = mutable.Map[(String, Int), Int]()\n\n        lst.foreach\
    \ {\n            str =>\n                if(str == \"(\") stack.push str\n   \
    \             else if(str == \")\") if(stack.isEmpty) output.append(str) else\
    \ bracketCounts.getOrElse((stack.last, stack.last.length - 1), 1).foreach {\n\
    \                    count =>\n                        stack.pop\n           \
    \             output.append(stack.last + str)\n                }\n           \
    \     else if(stack.last.length > 0 && bracketCounts.getOrElse((stack.last, stack.last.length\
    \ - 1), 1) <= 0) stack.pop\n                else stack.push(str)\n        }\n\
    \        if(stack.nonEmpty) output.toString\n        else \"No\"", "        def\
    \ go(i : Int, acc : List[String]) : List[String] = \n            if(i <= 0) acc\
    \ else go(i - 1, acc + lst(i))\n        go(lst.size, lst(0))", "        val stack\
    \ = mutable.Stack[String]()\n        for (item <- lst) {\n            item match\
    \ {\n                case \"(\" =>\n                    stack.push(item)\n   \
    \             case \"(\" =>\n                    stack.push(item)\n          \
    \      case \")\" =>\n                    val temp = stack.pop()\n           \
    \         if (stack.empty) {\n                        //print(\"stack: \" + stack\
    \ + \", item: \" + item)\n                        if (temp == item) {\n      \
    \                      return \"Yes\"\n                        }\n           \
    \         }\n            }\n        }\n        \"No\"", "        // Your code\
    \ here\n        val stack = mutable.Stack[String]()\n        val queue = new mutable.Queue[String]()\n\
    \        val res = mutable.ListBuffer.empty[String]\n        for(i <- 0 until\
    \ lst.size){\n            if(lst(i).contains(\"(\")){\n                stack push\
    \ lst(i)\n            }\n            if(lst(i).contains(\")\")){\n           \
    \     queue.append(lst(i))\n            }\n        }\n        if(stack.size ==\
    \ 0){\n            res.append(\"No\")\n        }\n        else if(queue.size ==\
    \ 0){\n            res.append(\"Yes\")\n        }\n        else if(stack.size\
    \ == 1){\n            if(queue.peek().contains(\")\")){\n                res.append(\"\
    Yes\")\n            }\n            else{\n                res.append(\"No\")\n\
    \            }\n        }\n        else{\n            while(!stack.empty){\n \
    \               val temp = stack.pop()\n                val temp2 = queue.dequeue()\n\
    \                if(temp.contains(\"(\") && temp.contains(\")\") && temp2.contains(\"\
    (\") && temp2.contains(\")\")){\n                    res.append(\"Yes\")\n   \
    \             }\n                else{\n                    res.append(\"No\"\
    )\n                }\n            }\n        }\n        res.mkString", "     \
    \   val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val goodString = ListBuffer[String]()\n        val badString = ListBuffer[String]()\n\
    \n        def matchParens(st: List[String], st1 : String) : List[String] = {\n\
    \            st match {\n                case Nil => st1\n                case\
    \ h :: t => {\n                    st match {\n                        case Nil\
    \ => List(h)\n                        case h :: t1 =>\n                      \
    \      if (st1 == h) {\n                                if (stack.isEmpty)\n \
    \                                   List(stack.toList :+ st1)\n              \
    \                  else {\n                                    val st2 = stack.toList\n\
    \                                    if (st2.head == h) {\n                  \
    \                      stack.toList = st2 :: st1\n                           \
    \             st1\n                                    } else {\n            \
    \                            st2 :+ st1\n                                    }\n\
    \                                }\n                            } else {\n   \
    \                             if (stack.isEmpty) {\n                         \
    \           List(h)\n                                } else if (stack.head ==\
    \ h) {\n                                    stack.toList :+ st1\n            \
    \                        stack.toList\n                                } else\
    \ {\n                                    stack.head :: stack.toList :+ st1\n \
    \                                   stack.toList\n                           \
    \     }\n                            }\n                    }\n              \
    \  }\n            }\n        }\n\n        for ((a, b) <- lst, c <- stack) {\n\
    \            matchParens(b :: a, b)\n        }\n\n        good ++= goodString\n\
    \        bad ++= badString\n        goodString.forall(s => good contains s)",
  "        var flag = mutable.HashMap[String, Boolean]()\n        for(elem <- lst.head)\
    \ {\n            flag(elem) <- false\n        }\n        for((i, j <- 0 until\
    \ lst.size) <- 0 until lst.size by -1) {\n            flag(lst.head(i)) <- false\n\
    \            for(k <- 1 until lst.size) {\n                if(flag(lst.head(i).drop(lst.head(i).length()\
    \ + 1))) {\n                    flag(lst.head(k)) <- false\n                }\n\
    \            }\n        }\n        if(flag(\"(\")) {\n            \"Yes\"\n  \
    \      } else {\n            \"No\"\n        }", "        var s  : List[String]\
    \ = lst\n        val rev = s.reverse\n        val stack = mutable.Stack[String]()\n\
    \        var temp = \"\"\n        for( a <- 0 until s.size) {\n            if(\
    \ (s(a).equals('(')) )\n                stack += '('\n            else if( (s(a).equals(')'))\
    \ )\n                stack += ')'\n            else if( (s(a).equals('(')) &&\
    \ (stack.isEmpty) ) {\n                temp = s(a)\n                s += temp\n\
    \                stack += '('\n            }\n            else if( (s(a).equals(')'))\
    \ && (stack.nonEmpty) ) {\n                temp = s(a)\n                s += temp\n\
    \                stack += ')'\n            }\n            else {\n           \
    \     if(stack.nonEmpty)\n                    s += temp\n                s +=\
    \ temp\n                stack += (s(a))\n            }\n        }\n        if(stack.nonEmpty)\n\
    \            s += temp\n        s += temp\n        s = s.reverse\n        if(s.indexOf('(')\
    \ == s.lastIndexOf(')') && s.indexOf(')') < s.size) {\n            if(s.indexOf('(')\
    \ > s.lastIndexOf(')'))\n                return \"Yes\"\n            else\n  \
    \              return \"No\"\n        }\n        else\n            return \"No\"",
  "        val l = lst.map(x => if (x == \"(\") 1 else 0).sum\n        val r = lst.map(x\
    \ => if (x == \")\") 1 else 0).sum\n        if (l+r == 0)\n            \"Yes\"\
    \n        else\n            \"No\"", "        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.Set[String]()\n\n        lst.foreach { e => \n \
    \           if (e==\"(\") stack.push(\"(\")\n            else if (e==\")\") stack.push(\"\
    )\")\n            else stack += e\n        }\n\n        if (stack.size!=1){\n\
    \            return(\"No\")\n        }\n\n        val topElement = stack.pop()\n\
    \        if (topElement==\")\"){\n            result.add(topElement)\n       \
    \ }\n\n        if (stack.size==1){\n            if (result.size == lst.size){\n\
    \                return(\"Yes\")\n            }\n            return(\"No\")\n\
    \        }\n\n        while (stack.size!=0){\n            val nextElement = stack.pop()\n\
    \            val nextResult = result.pop()\n\n            if (nextElement==\"\
    (\"){\n                stack.push(nextElement)\n            }\n\n            if\
    \ (nextElement==\")\"){\n                if (nextResult!=topElement){\n      \
    \              return(\"No\")\n                }\n            }\n            else\
    \ if (nextResult!=topElement){\n                return(\"No\")\n            }\n\
    \n            if (nextResult==topElement){\n                if (result.size ==\
    \ lst.size){\n                    return(\"Yes\")\n                }\n       \
    \     }\n        }\n\n        return(\"No\")", "        val allParens = lst._2.flatMap\
    \ { x =>\n            if (x.contains(\")\")) Some(x.dropRight(1))\n          \
    \  else Some(x.takeRight(1))\n        }\n        if (allParens.size % 2 != 0)\
    \ \"No\"\n        else if (allParens.head == allParens.tail) \"Yes\"\n       \
    \ else matchParens(allParens.init)", "        //var stack = List[List[String]]()\n\
    \        var stack = mutable.Stack[List[String]]()\n        var flag = false\n\
    \n        for(i <- 0 until lst.length){\n            var next = lst(i)\n\n   \
    \         while(!stack.contains(next)){\n                stack.push(next)\n  \
    \              next = lst(i+1)\n            }\n\n            if(!flag){\n    \
    \            if(next.equals(\"(\")){\n                    stack.push(next)\n \
    \                   next = lst(i+1)\n                }\n                else{\n\
    \                    flag = true\n                }\n            }\n         \
    \   if(next.equals(\"(\")){\n                stack.push(\"(\")\n             \
    \   next = lst(i+1)\n            }\n            else if(stack.contains(next)){\n\
    \                stack.pop\n                next = stack.last\n            }\n\
    \            if(stack.last.equals(\")\") && !stack.last.equals(\"(\")){\n    \
    \            stack.last = \"(\"\n                stack.pop()\n            }\n\
    \            if(stack.last.equals(\"(\") && !stack.last.equals(\")\")){\n    \
    \            stack.last = \"(\"\n                stack.pop()\n            }\n\
    \            if(!stack.last.equals(\"(\") && !stack.last.equals(\")\")){\n   \
    \             stack.last += \")\"\n            }\n        }\n\n        if(stack.last\
    \ == \"(\")\n            return \"Yes\"\n        return \"No\"", "      lst.foldLeft(\"\
    No\") {\n        case (acc, x) => if (x contains \"(\") acc.append(\"Yes\") else\
    \ acc\n      }", "        // Use a stack to keep track of the number of '(' and\
    \ ')'\n        // to see if we can concatenate without making any mistakes.\n\
    \        // The base case: if list is empty, return 'No'\n        // The base\
    \ case: if there are zero '(', return 'No'\n        // The base case: if there\
    \ are zero ')', return 'Yes'\n        // The general case:\n        // Create\
    \ a stack\n        // While there are elements left in list 'lst'\n        //\
    \   Pop the top element from the stack\n        //   Push the element '(element)'\n\
    \        //   If '(element)' is the top element of the stack, add one\n      \
    \  //   If ')' is top element of the stack, remove one\n        //   If '(element)'\
    \ is now empty, repeat from start\n        //   If ')' is now empty, repeat from\
    \ start\n        //   If '(element)' has the same number of '(' and ')' as ')',\
    \ add one\n        //   If ')' has the same number of '(' and ')' as '(', remove\
    \ one\n        //   If '(element)' has the same number of ')' and '(' as '(',\
    \ remove one\n        //   If '(element)' has the same number of ')' and '(',\
    \ add one\n        //   If '(element)' has the same number of ')' and '(', remove\
    \ one\n        // If no element left\n        // return 'No'\n        val stack\
    \ = new Stack[String]\n        var retVal = \"No\"\n        lst.foreach { elem\
    \ =>\n            val isOpen = elem.head() == '('\n            val isClose = elem.head()\
    \ == ')'\n            val count = if (isOpen) 1 else -1\n            if (stack.size\
    \ == 0 || (isOpen && count == 1))\n                stack.push(elem)\n        \
    \    else if (isClose && stack.size == 1)\n                stack.pop()\n     \
    \       else if (stack.size == 1 && (count == -1 || count == 1))\n           \
    \     stack.append(elem)\n            else if (stack.size == 1 && (count == -1\
    \ || count == -1))\n                stack.pop()\n            else if (stack.size\
    \ == 1 && (count < 0 || count == 0))\n                stack.append(elem)\n   \
    \         else if (stack.size == 1 && (count > 0 || count == 0))\n           \
    \     stack.prepend(elem)\n        }\n        if (stack.size == 0)\n         \
    \   retVal = \"No\"\n        else if (stack.size == 1)\n            retVal = \"\
    Yes\"\n        else if (stack.size == 2 && (stack.head == stack.last) && stack.pop()\
    \ == stack.head)\n            retVal = \"Yes\"\n        else if (stack.size ==\
    \ 2 && (stack.head == stack.last) && stack.pop() == stack.last)\n            retVal\
    \ = \"Yes\"\n        else\n            retVal = \"No\"\n        return retVal",
  "        val stack = mutable.Stack[String]()\n        var res   = List[String]()\n\
    \        var isOpen = false\n        lst.foreach(l => stack += l)\n        while(stack.nonEmpty)\
    \ {\n            val s = stack.pop()\n            if(!isOpen) {\n            \
    \    if(s.equals(\"(\")) {\n                    isOpen = true\n              \
    \  } else if(s.equals(\")\")) {\n                    if(!isOpen) {\n         \
    \               res += \"No\"\n                    } else {\n                \
    \        res += \"Yes\"\n                    }\n                    isOpen = false\n\
    \                } else if(!s.isEmpty) {\n                    res += \"Yes\"\n\
    \                }\n            }\n        }\n        if(res.nonEmpty) {\n   \
    \         res.head\n        } else {\n            \"No\"\n        }", "      \
    \  // Use stack to check if there is any balance in lst\n        val stack = new\
    \ Stack[String]\n        for(i <- 0 until lst.size) {\n            stack += lst(i)\n\
    \            while (stack.size > 0 ) {\n                val current = stack.pop\n\
    \                val next = lst(i + 1)\n                val nextIsParen = next.headOption.map(c\
    \ => c == ')')\n                val currentIsParen = current.headOption.map(c\
    \ => c == ')')\n                if ((!nextIsParen && currentIsParen) || nextIsParen\
    \ && currentIsParen) {\n                    stack += current\n               \
    \ }\n            }\n        }\n        if (stack.size == lst.size) {\n       \
    \     return \"Yes\"\n        }\n        return \"No\"", '        // Your code
    goes here', "        val m = lst.map(_.contains(\"(\")).toList.foldLeft(false)(_\
    \ && _)\n        if (m) \"Yes\" else \"No\"", "        def findParen(s  : String)\
    \ : List[Int] = {\n            def openParen(r : String) : List[Int] = {\n   \
    \             val re = r.split(\"\\\\(\")\n                val cnt = 0\n     \
    \           re.map { x =>\n                    if (x.equals(\"()\")) {\n     \
    \                   cnt+=1\n                    }\n                    else if\
    \ (x.equals(\")\")) {\n                        cnt+=-1\n                    }\n\
    \                    cnt\n                }\n            }\n            def closeParen(r\
    \ : String) : List[Int] = {\n                val re = r.split(\"\\\\)\")\n   \
    \             val cnt = 0\n                re.map { x =>\n                   \
    \ if (x.equals(\"(\")) {\n                        cnt+=1\n                   \
    \ }\n                    else if (x.equals(\")\")) {\n                       \
    \ cnt+=-1\n                    }\n                    cnt\n                }\n\
    \            }\n\n            val ops = openParen(s) + closeParen(s)\n       \
    \     val total = ops.sum\n            val pos = ops.min\n            val flag\
    \ = ops.foldLeft[List[Int]](0)(_+_)\n            if ((flag == total) || (flag\
    \ == total-1)) {\n                println(s\"flag==total=$flag,total=$total,pos=$pos,flag=$(flag<0)\"\
    )\n                if (flag < 0){\n                    return \"No\"\n       \
    \         }\n                else {\n                    return \"Yes\"\n    \
    \            }\n            }\n            else{\n                println(s\"\
    flag!=total=$flag,total=$total,pos=$pos,flag=$(flag<0)\")\n                if\
    \ (flag < 0) {\n                    return \"No\"\n                }\n       \
    \         else {\n                    return \"Yes\"\n                }\n    \
    \        }\n        }\n        var flag = 0\n        val result = lst\n      \
    \      .map {\n                s => findParen(s)\n            }\n            .fold(\"\
    \") { (a, b) => a + b.toString}\n        if (result.equals(\"Yes\")){\n      \
    \      return \"Yes\"\n        }\n        else{\n            return \"No\"\n \
    \       }", "        var good = lst.head match {\n            case \"\" => \"\"\
    \n            case s => s\n        }\n        val stack = mutable.Stack[Int]()\n\
    \        val pos = 0\n        for (ele <- lst) {\n            ele match {\n  \
    \              case \"\" => stack.append(-1)\n                case c =>\n    \
    \                val index = if (pos == 0) -1 else stack.pop\n               \
    \     if (c == '(') {\n                        stack.append(index)\n         \
    \           } else if (c == ')') {\n                        if (index == -1) {\n\
    \                            bad += \"(\" + c + \")\"\n                      \
    \  } else {\n                            good += c + \")\"\n                 \
    \       }\n                        pos += 1\n                    }\n         \
    \   }\n        }\n        if (good != \"\") good else \"No\"", "        // use\
    \ stack to check if brackets are balanced\n        var stack = new Stack[List[String]]()\n\
    \        for ( a <- lst ) {\n            if ( !a.contains(\"(\") && !a.contains(\"\
    )\") ) {\n                return \"No\"\n            }\n            else if (\
    \ a == \"(\" ) {\n                stack.append( List(a) )\n            }\n   \
    \         else if ( a == \")\" ) {\n                val temp = stack.pop()\n \
    \               if ( temp.size == 0 ) {\n                    return \"No\"\n \
    \               }\n                val temp = stack.pop()\n                stack.append(\
    \ List( temp(1), a ) )\n            }\n        }\n        if ( stack.size == 0\
    \ ) {\n            return \"No\"\n        }\n        return \"Yes\"", "      \
    \  val stg = lst.map(x => if (x.contains(\")\")) x else x + \")\")\n        val\
    \ arr = stg.toArray\n        val stack = mutable.Stack[String]()\n        val\
    \ stackP = mutable.Stack[Boolean]()\n\n        var count = 0\n        for (i <-\
    \ 0 until arr.length) {\n            count += arr.length\n            if (arr.isDefinedAt(i))\
    \ {\n                if (stackP.contains(arr(i))) {\n                    stackP\
    \ -= 1\n                    if (stackP.size == 0) {\n                        stackP\
    \ += true\n                    }\n                } else {\n                 \
    \   stackP += 1\n                    if (stackP.size == 0) {\n               \
    \         stackP += false\n                    }\n                }\n        \
    \    }\n            if (stack.size == count) {\n                if (stackP ==\
    \ 1) {\n                    if (stack.pop() == \"No\") {\n                   \
    \     return \"No\"\n                    }\n                } else {\n       \
    \             if (stack.pop() == \"No\") {\n                        return \"\
    No\"\n                    }\n                }\n            }\n            stack\
    \ += arr(i)\n        }\n        return \"Yes\"", "        def good(lst1: List[String],\
    \ lst2: List[String]) : Boolean = {\n            var flag = false\n          \
    \  var idx1 : Int = 0\n            var idx2 : Int = 0\n            while(idx1\
    \ < lst1.length && idx2 < lst2.length) {\n                if (lst1(idx1) != lst2(idx2))\
    \ {\n                    return false\n                }\n                if (lst1(idx1)\
    \ == '(') {\n                    if (lst2(idx2) == ')') {\n                  \
    \      flag = true\n                    } else {\n                        idx2\
    \ += 1\n                    }\n                } else {\n                    if\
    \ (lst2(idx2) == ')') {\n                        idx2 += 1\n                 \
    \   } else {\n                        flag = false\n                        return\
    \ false\n                    }\n                }\n                idx1 += 1\n\
    \                idx2 += 1\n            }\n            return flag\n        }\n\
    \        val flag = lst.length <= 1\n        if (flag) {\n            \"Yes\"\n\
    \        } else {\n            val len = lst.length\n            val first = lst(0)\n\
    \            val rest = lst.drop(1)\n            if (good(first, rest)) {\n  \
    \              val newlist = first :: rest\n                if (good(first, newlist))\
    \ {\n                    matchParens(newlist)\n                } else if (newlist.length\
    \ == len) {\n                    matchParens(newlist)\n                } else\
    \ {\n                    \"No\"\n                }\n            } else {\n   \
    \             \"No\"\n            }\n        }", "        val isBalanced = {\n\
    \            def check(pst: Int): Boolean = {\n                val left = lst.head\n\
    \                val right = lst.last\n                if(pst > left) false else\
    \ left == right || (check(pst+1) && check(pst-1))\n            }\n           \
    \ check(0);\n        }\n        if(lst.isEmpty)\n            \"No\"\n        else\
    \ if(isBalanced) \"Yes\"\n        else matchParens(lst.tail);", "        val ls\
    \ = lst.map{\n            case s => if (s.contains(\"(\")) 1 else 0\n        }\n\
    \        ls.sum == ls.sum * ls.sum\n            ? \"Yes\"\n            : \"No\"",
  "        if (lst.length == 0) \"No\"\n        else {\n            var str = \"\"\
    \n            val stack = new Stack[String]\n            stack.push(\"(\")\n \
    \           while (!stack.empty) {\n                str = str + stack.pop\n  \
    \              val lst2 = lst.map(_ + str).toList\n                if (lst2.size\
    \ == 2) \"Yes\"\n                else {\n                    stack.push(lst2(1))\n\
    \                    stack.push(lst2(0))\n                }\n            }\n \
    \       }", "        val inParens = lst.foldLeft(false) { (acc,s) =>\n       \
    \     if (s.isEmpty) acc\n            else acc && s.head == '('\n        }\n \
    \       val lc = lst.foldLeft(\"()\") { (acc,s) =>\n            if (acc && s.head\
    \ == ')') acc // already have a valid one after this\n            else (acc +\
    \ \"()\") + s\n        }\n        if (inParens && !inParens.reverse.contains(\"\
    )\")) // if we are left with ')' at begining, return 'No'\n            \"No\"\n\
    \        else if (lc.length != lst.length)\n            \"No\" // if we have extra\
    \ chars ('), return 'No'\n        else if (lc == \"()\") \"Yes\"\n        else\
    \ \"No\" // if we are left with nothing at begining, return 'No'", "        //\
    \ Initialization\n        var goodStrings = ListBuffer[String]()\n        var\
    \ goodStringsSize = lst.size\n        var openStrings = 0\n        var closeStrings\
    \ = 0\n        // Part 1 check and count\n        for (s <- lst) {\n         \
    \   if (s == \"()\") {\n                openStrings += 1\n            } else if\
    \ ((s != \"()\") && (s != \")\")) {\n                return \"No\"\n         \
    \   }\n            closeStrings += 1\n        }\n        // Part 2 check and count\n\
    \        for (i<- 0 to lst.size - 1) {\n            if (lst(i) == \"(\") {\n \
    \               val stringCount = lst(i + 1)\n                val openCount =\
    \ closeStrings - openStrings\n                if (stringCount < openCount) {\n\
    \                    return \"No\"\n                }\n                if (stringCount\
    \ == openCount) {\n                    val stringSum = lst(i) + lst(i + 1)\n \
    \                   goodStrings += stringSum\n                    goodStringsSize\
    \ += 1\n                    openStrings = 0\n                    closeStrings\
    \ = 0\n                }\n            } else if (lst(i) == \")\") {\n        \
    \        val stringCount = lst(i + 1)\n                val openCount = openStrings\
    \ - closeStrings\n                if (stringCount < openCount) {\n           \
    \         return \"No\"\n                }\n                if (stringCount ==\
    \ openCount) {\n                    val stringSum = lst(i) + lst(i + 1)\n    \
    \                goodStrings += stringSum\n                    goodStringsSize\
    \ += 1\n                    openStrings = 0\n                    closeStrings\
    \ = 0\n                }\n            }\n        }\n        // Part 3 check\n\
    \        if (goodStringsSize != goodStrings.size) {\n            return \"No\"\
    \n        }\n        for (i<- 0 to goodStringsSize - 1) {\n            if (goodStrings(i)\
    \ != goodStrings(i + 1)) {\n                return \"No\"\n            }\n   \
    \     }\n        // Part 4 check\n        val stringCount = goodStrings.last\n\
    \        val openCount = closeStrings - openStrings\n        if (stringCount <\
    \ openCount) {\n            return \"No\"\n        }\n        if (stringCount\
    \ == openCount) {\n            val stringSum = goodStrings.head + goodStrings.last\n\
    \            goodStrings += stringSum\n            goodStringsSize += 1\n    \
    \        openStrings = 0\n            closeStrings = 0\n        }\n        //\
    \ Part 5 check\n        goodStringsSize += 1\n        for (i<- 0 to goodStringsSize\
    \ - 1) {\n            if (goodStrings(i) != goodStrings(i + 1)) {\n          \
    \      return \"No\"\n            }\n        }\n        // Part 6 check\n    \
    \    val stringCount = goodStrings.last\n        val openCount = openStrings -\
    \ closeStrings\n        if (stringCount < openCount) {\n            return \"\
    No\"\n        }\n        if (stringCoun", "        var lst1 = lst.tail\n     \
    \   var lst2 = lst.head\n        var isMatching = false\n        var isTrue =\
    \ false\n        var i = -1\n        while (!isMatching) {\n            i +=1\n\
    \            if (lst1(i) != lst2(i)) {\n                isMatching = true\n  \
    \          } else {\n                if (lst2(i) == \"(\") {\n               \
    \     lst1 = lst1.tail\n                    lst2 = lst2.head\n               \
    \ } else if (lst2(i) == \")\") {\n                    lst1 = lst1.head\n     \
    \               lst2 = lst2.tail\n                } else {\n                 \
    \   isMatching = false\n                }\n            }\n        }\n        if\
    \ (isTrue) {\n            return \"Yes\"\n        } else {\n            return\
    \ \"No\"\n        }", "        val stack = new Stack[String]()\n        for (x\
    \ <- lst) {\n            if (x.equals(\"(\")) {\n                stack.push(x)\n\
    \            } else if (x.equals(\")\")) {\n                val lastStacked =\
    \ stack.pop()\n                if (lastStacked == x) {\n                    if\
    \ (stack.isEmpty) {\n                        \"No\"\n                    } else\
    \ {\n                        \"Yes\"\n                    }\n                }\
    \ else {\n                    \"No\"\n                }\n            } else {\n\
    \                \"No\"\n            }\n        }", "        // Use dynamic programming\n\
    \        // A solution in O(n^2) would be: O(n^2*M), M is the maximum length\n\
    \        var maxLength = 0\n        val arr1 = lst(0)\n        var count = 0\n\
    \        var cur = 0\n        var arr2 = lst(1)\n        while (cur < arr2.length)\
    \ {\n            if (arr2(cur) == '(') {\n                count += 1\n       \
    \     }\n            if (arr2(cur) == ')') {\n                count -= 1\n   \
    \         }\n            if (arr1(cur) == arr2(cur) && count <= 0) {\n       \
    \         maxLength += 1\n            }\n            cur += 1\n        }\n   \
    \     var ans = \"\"\n        var count1 = 0\n        var count2 = 0\n       \
    \ while (count > 0) {\n            if (count1 == maxLength) {\n              \
    \  ans += arr1(count1) + arr2(count2)\n                count1 += 1\n         \
    \       count2 += 1\n            } else {\n                ans += arr1(count1)\n\
    \                count1 += 1\n            }\n            if (count2 == maxLength)\
    \ {\n                ans += arr2(count2)\n                count2 += 1\n      \
    \      } else {\n                ans += arr2(count2)\n                count2 +=\
    \ 1\n            }\n            count -= 1\n        }\n        if (maxLength ==\
    \ 0) {\n            ans = \"Yes\"\n        } else {\n            ans = \"No\"\n\
    \        }\n        return ans", "        var stack = List[String]()\n       \
    \ for (i <- 0 until lst.size) {\n            if (lst(i).contains(\"(\") && lst(i).contains(\"\
    )\")) {\n                if (stack.contains(lst(i) + lst(i+1))) {\n          \
    \          return \"No\"\n                } else {\n                    stack\
    \ += lst(i) + lst(i+1)\n                }\n            }\n        }\n        \"\
    Yes\"", "        val st = new scala.collection.mutable.HashMap[Int, List[String]]()\n\
    \        for (s <- lst) if (st.contains(s.length)) {\n            if (st.apply(s.length).nonEmpty)\
    \ st += s.length -> List(s)\n            else st += s.length -> List()\n     \
    \   }\n        if (st.size != lst.length) \"No\" else if (st.size == 1) st.apply(0)\
    \ else \"Yes\"", "        // Scan the first string and find the balance of open\
    \ and close\n        // parentheses, if they have balance then return 'Yes', otherwise\
    \ return 'No'\n        val s = lst(0)\n        def isBalance(s1: String, s2: String):\
    \ Boolean = {\n            if (s1.isEmpty)\n                true\n           \
    \ else if (s2.isEmpty)\n                false\n            else (s1 startsWith\
    \ s2) || (s2 startsWith s1)\n        }\n\n        var balance = 0\n        var\
    \ open = 0\n        var close = 0\n        for (str <- lst) {\n            if\
    \ (str == \"(\")\n                open += 1\n            if (str == \")\")\n \
    \               close += 1\n            if (open == close)\n                balance\
    \ += close\n        }\n        if (balance == 0 || balance == 2)\n           \
    \ return \"Yes\"\n        else\n            return \"No\"", "        val lst2\
    \ = lst.map(s => List(s)).toList\n        val stack = mutable.Stack[List[String]]()\n\
    \        lst2.foreach(x => stack.push(List(x)))\n        val lastElement = stack.last.last\n\
    \        if(stack.last.isEmpty) lastElement.foldLeft(\"No\") { (a, e) => a + e\
    \ }\n        else {\n            var temp = \"\"\n            var goodString =\
    \ \"\"\n            val len = lst2.length\n            for(i <- 0 until len) {\n\
    \                val nextElement = stack.last.dropRight(1).head\n            \
    \    val nextElementStack = stack.last.dropRight(1).tail\n                val\
    \ nextElementStackLast = nextElementStack.last\n                val nextElementStackLen\
    \ = nextElementStack.length\n                val elementToCheck = lst2.apply(i)\n\
    \                if(nextElementStackLast.contains(elementToCheck)) {\n       \
    \             val temp1 = nextElementStackLast.take(nextElementStackLen - 1).mkString\n\
    \                    val temp2 = nextElementStackLast.drop(nextElementStackLen\
    \ - 1).mkString\n                    if(temp1 == temp2) {\n                  \
    \      goodString = temp\n                        stack.last.takeRight(nextElementStackLen\
    \ - 1).foreach(stack.last.add)\n                        break\n              \
    \      } else {\n                        temp = temp1 + elementToCheck + temp2\n\
    \                        stack.last.dropRight(1).foreach(stack.last.add)\n   \
    \                     break\n                    }\n                } else {\n\
    \                    temp = temp + elementToCheck\n                }\n       \
    \     }\n            goodString\n        }", "        // Convert list to map by\
    \ removing duplicate values\n        // If all values in the map are same then\
    \ return \"Yes\"\n        // Else return \"No\"\n        val map: Map[String,\
    \ Int] = lst.toMap.toList.reverse.groupBy(x => x).mapValues(_.size)\n        val\
    \ keys = map.keys.toList\n        val values = map.values.toList\n        val\
    \ yes = keys.size == values.size && keys.forall(x => x == values.head)\n     \
    \   if(yes) {\n            \"Yes\"\n        } else {\n            \"No\"\n   \
    \     }", "        var result = ListBuffer[String]()\n        def matchParens(lst\
    \ : List[String], acc : List[String], stack : List[String]) : String = {\n   \
    \         if(!lst.isEmpty) {\n                acc :+ lst(0)\n                lst\
    \ :- lst(0)\n                if(!stack.contains(lst(0)) && acc.isEmpty && lst(0).equals(\"\
    (\") && lst(1).equals(\")\")) {\n                    result :+= \"Yes\"\n    \
    \            } else {\n                    matchParens(lst, acc, acc :+ lst(0))\n\
    \                }\n            } else {\n                result :+= \"No\"\n\
    \            }\n        }\n        matchParens(lst,ListBuffer[String](),List[String]())\n\
    \        result.toString()", "        val m = lst.map(x => (x match {\n      \
    \      case \"(\" => 1\n            case \")\" => -1\n            case _ => 0\n\
    \        })).foldLeft(0)(_ + _)\n        lst.map(x => {\n            if (x < \"\
    (\" || x > \")\") {\n                return \"No\"\n            }\n          \
    \  if (x < m) x else \"Yes\"\n        }).foldLeft(\"Yes\")(\n            (acc,\
    \ x) => {\n                val f = acc\n                if (f==\"Yes\" && x ==\
    \ \"Yes\") \"Yes\" else \"No\"\n            }\n        )", "        val stack\
    \ = Stack[String]()\n        val good = \"Yes\"\n        lst.foreach( x =>\n \
    \           if(x.startsWith(\"(\") && x.endsWith(\")\")){\n                stack.push(x)\n\
    \            }\n            if(stack.nonEmpty){\n                var i = 0\n \
    \               var last = 0\n                while (i < stack.size) {\n     \
    \               val n = stack.length - i\n                    var j = 0\n    \
    \                var last_n = 0\n                    while(j < stack.size) {\n\
    \                        val m = stack.length - j\n                        val\
    \ p0 = stack(i).length\n                        val p1 = stack(m).length\n   \
    \                     if(n > 0 && m > 0) {\n                            last_n\
    \ = math.min(p0, p1)\n                            if(last_n == 0){\n         \
    \                       if(stack(n).startsWith(\"(\") && stack(m).endsWith(\"\
    )\") && stack(i + 1).startsWith(\"(\") && stack(m).endsWith(\")\")){\n       \
    \                             good += \"Yes\"\n                              \
    \      return good\n                                }\n                      \
    \      }\n                            if(last_n == 1) {\n                    \
    \            if(stack(n).endsWith(\"(\") && stack(m).endsWith(\")\") && stack(i\
    \ + 1).startsWith(\"(\") && stack(m).endsWith(\")\")){\n                     \
    \               good += \"Yes\"\n                                    return good\n\
    \                                }\n                            }\n          \
    \                  if(last_n == 2) {\n                                if(stack(n).endsWith(\"\
    (\") && stack(m).endsWith(\")\") && stack(i + 1).endsWith(\"(\") && stack(m).endsWith(\"\
    )\")){\n                                    good += \"Yes\"\n                \
    \                    return good\n                                }\n        \
    \                    }\n                        }\n                        j +=\
    \ 1\n                    }\n                    i +=1\n                }\n   \
    \         }\n        )\n        good", "        // The first and last elements\
    \ of lst are empty.\n        val lst_1 = lst.take(1).reverse\n        val lst_2\
    \ = lst.drop(1).reverse\n        val lst_3 = lst_2.take(lst_2.size - 1).reverse\n\
    \        val lst_4 = lst_3.take(lst_3.size - 1).reverse\n        if (lst_4.size\
    \ < lst_2.size) return \"No\"\n        if (lst_3.size < lst_1.size) return \"\
    No\"\n        if (lst_4.size == lst_2.size && lst_4.size == lst_1.size) lst_4.head\n\
    \        else {\n            val lst_5 = lst_4.takeWhile(_ != \"(\")\n       \
    \     val lst_6 = lst_5.takeWhile(_ != \")\")\n            val lst_7 = lst_5.dropWhile(_\
    \ != \"(\")\n            val lst_8 = lst_7.takeWhile(_ != \")\")\n           \
    \ val lst_9 = lst_5.takeWhile(_ != \")\").dropWhile(_ != \"(\")\n            val\
    \ lst_10 = lst_9.takeWhile(_ != \")\").dropWhile(_ != \"(\")\n            val\
    \ lst_11 = lst_10.reverse\n            val lst_12 = lst_11.reverse\n         \
    \   val lst_13 = lst_12.reverse\n            val lst_14 = lst_13.reverse\n   \
    \         val lst_15 = lst_14.reverse\n            val lst_16 = lst_15.reverse\n\
    \            val lst_17 = lst_16.reverse\n            val lst_18 = lst_17.reverse\n\
    \            val lst_19 = lst_18.reverse\n            val lst_20 = lst_19.reverse\n\
    \            val lst_21 = lst_20.reverse\n            val lst_22 = lst_21.reverse\n\
    \            val lst_23 = lst_22.reverse\n            if (lst_14.size != 0) \"\
    Yes\"\n            else {\n                if (lst_13.size != 0) \"Yes\"\n   \
    \             else {\n                    if (lst_12.size != 0) \"Yes\"\n    \
    \                else {\n                        if (lst_11.size != 0) \"Yes\"\
    \n                        else {\n                            if (lst_10.size\
    \ != 0) \"Yes\"\n                            else {\n                        \
    \        if (lst_9.size != 0) \"Yes\"\n                                else {\n\
    \                                    if (lst_8.size != 0) \"Yes\"\n          \
    \                          else {\n                                        if\
    \ (lst_7.size != 0) \"Yes\"\n                                        else {\n\
    \                                            if (lst_6.size != 0) \"Yes\"\n  \
    \                                          else {\n                          \
    \                      if (lst_5.size != 0) \"Yes\"\n                        \
    \                        else {\n                                ", "        val\
    \ map = mutable.Map.empty[String, String]\n        var lst = lst.sorted\n    \
    \    lst(0) = (lst(0)(0)) + (lst(0)(1))\n        lst(1) = lst(1).subList(1, lst.size)\n\
    \        for (i <- lst.indices) {\n            val subst = lst.update(i)\n   \
    \         var temp = subst.apply(i-1)\n            var next = (i-1) + subst.apply(i+1)\n\
    \            while (next < lst.size && temp != lst(next)){\n                temp\
    \ = (temp) + (lst(next))\n                next += 1\n            }\n         \
    \   val key = temp.toString\n            val value = lst(next)\n            if\
    \ (map.contains(key)) {\n                map = (map.updated(key,value))\n    \
    \        } else {\n                map = map + (key -> value)\n            }\n\
    \        }\n        if (!map.isEmpty) {\n            val keys = map.keys.toSeq.sorted\n\
    \            val values = (map.values - keys) ++ keys\n            val rev = values.reverse\n\
    \            val newMap = Map(key -> value)\n            for (i <- rev) {\n  \
    \              val value = newMap(key)\n                val key = newMap(value)\n\
    \                map = (map - key) + (key -> value)\n            }\n        }\n\
    \        if (map.isEmpty) {\n            \"No\"\n        } else {\n          \
    \  \"Yes\"\n        }", "        val str = lst(0)\n        val lst2 = lst(1)\n\
    \        val index = str.indexOf(\"(\")\n        val counts = str.substring(index+1,\
    \ str.length).toInt\n        val sum = 0\n        for(i <- 0 to counts) {\n  \
    \          sum = sum + i\n        }\n        if(sum == (counts*counts)) \"Yes\"\
    \ else \"No\"", "        if (lst.size != 2) \"No\"\n        else if (!checkParens(lst))\
    \ \"No\"\n        else checkParens(lst)", "        // Create a list of stacks,\
    \ one for each string\n        val stacks: List[Stack[String]] = lst.map(_ =>\
    \ Stack.empty[String])\n        // If the top of the stack is empty, return 'No'\
    \ as the answer\n        if (stacks.filter(_.isEmpty).head.isEmpty) \"No\" else\
    \ \"Yes\"", "        val l = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        for (i <- 0 until l) {\n            val p = lst.apply(i)\n          \
    \  if (p == \"(\")\n                open.add(p)\n            else if (p == \"\
    )\")\n                close.add(p)\n            else if (open.isEmpty && close.isEmpty\
    \ && !stack.isEmpty) {\n                val str = stack.pop()\n              \
    \  if (!open.contains(str))\n                    return \"No\"\n            }\n\
    \            else {\n                stack += p\n            }\n        }\n  \
    \      if (!open.isEmpty && !close.isEmpty)\n            return \"No\"\n     \
    \   return \"Yes\"", "        val lst1 = lst.sortBy(_.length)\n        var str\
    \ = \"\"\n        val isMatch = lst1.map(x => {\n            val y = (x.split(\"\
    (\")[1]).split(\")\")[0]\n            str += \"Yes\"\n            if(y != \"\"\
    ) \n                str+y\n            else\n                str+x\n        })\n\
    \        if(isMatch.forall(x => x.contains(\"Yes\"))) \n            str\n    \
    \    else \n            \"No\"", "        val balanced = \"()\".grouped(2).toList.map(x\
    \ => if (x.size == 1) x(0)\n            else (x.tail, x.head))\n        val unbalanced\
    \ = \"()\".grouped(1).toList.map(x => if (x.size == 1) x(0)\n            else\
    \ x.head)\n        val good = balanced.foldLeft(List(\"\"))((list, str) =>\n \
    \           list match {\n                case x::xs if (x == str) => x\n    \
    \            case x::xs if x != str => x :: list\n                case _ => list\n\
    \            })\n        if (balanced.contains(good)) \"Yes\" else \"No\"", " \
    \       // Use a stack to store the position of opening parentheses\n        val\
    \ openStack : Stack[Int] = new Stack[Int]()\n        val closedStack : Stack[Int]\
    \ = new Stack[Int]()\n        // Use a stack to store the position of closing\
    \ parentheses.\n        val closedStackPos : Stack[Int] = new Stack[Int]()\n\n\
    \        val goodStrings : mutable.Queue[String] = new mutable.Queue[String]()\n\
    \        val goodStringsPos : mutable.Queue[Int] = new mutable.Queue[Int]()\n\n\
    \        // A stack to store whether a opening parentheses is closed, if yes,\n\
    \        // push it into closedStack, otherwise push it into openStack.\n    \
    \    for (i <- 0 until lst.size) {\n            val opening = lst(i)\n       \
    \     if (opening == \"(\") openStack.push(i)\n            else if (opening ==\
    \ \")\") {\n                if (closedStack.size == 0) openStack.push(i + 1)\n\
    \                else {\n                    val closed = closedStack.pop()\n\
    \                    if (closed == i) closedStackPos.push(i)\n               \
    \ }\n            }\n        }\n\n        // Use a while loop to check all opening\
    \ parentheses and push them into goodStrings\n        // If an opening parentheses\
    \ is closed, push it into closedStackPos, otherwise,\n        // push it into\
    \ openStack\n        while (openStack.nonEmpty) {\n            val i = openStack.pop()\n\
    \            val open = lst(i)\n            if (opening == \"(\") {\n        \
    \        if (closedStack.nonEmpty && closedStackPos.nonEmpty && goodStrings.nonEmpty\
    \ &&\n                    open == \")\" && closedStackPos.head == i) {\n     \
    \               val closed = closedStack.pop()\n                    if (closed\
    \ == i) closedStackPos.push(i)\n                    else {\n                 \
    \       val pos = closedStackPos.pop()\n                        val goodString\
    \ = goodStrings.dequeue()\n                        val newClosedStack = closedStack.dequeue()\n\
    \                        if (newClosedStack == pos) {\n                      \
    \      goodStringsPos.push(pos)\n                            goodStrings += goodString\n\
    \                        }\n                    }\n                }\n       \
    \         else {\n                    val goodString = goodStrings.dequeue()\n\
    \                    if (goodString == goodStrings.peek())\n                 \
    \       goodStrings += goodString\n                }\n            } else {\n \
    \               if (closedStack.nonEmpty && closedStackPos.nonEmpty && goodStrings.nonEmpty\
    \ &&\n                    open == \")\" && closedStackPos.head == i + 1) {\n \
    \                   val closed = closedStack.pop()\n                    if (closed\
    \ == i + 1) closedStackPos.push(i)\n                    else {\n             \
    \           val pos = closedStackPos.pop()\n                        val good",
  "        var lst1 = lst.map(_.replaceAll(\"^\\\\)\",\"\"))\n        var lst2 = lst.map(_.replaceAll(\"\
    \\\\)\",\"\"))\n        var i = 0\n        var count = 0\n        var str = \"\
    \"\n        while(lst1.nonEmpty){\n            str += \"(\"\n            while(i\
    \ < lst1.length){\n                str += lst1(lst1(i))\n                i +=\
    \ 1 \n                if(lst1(i) == \"(\"){\n                    count += 1\n\
    \                }\n                if(lst1(i) == \")\"){\n                  \
    \  count -= 1\n                }\n                if((count == 0) && (lst1(i)\
    \ == \"(\")){\n                    lst1.remove(lst1(i))\n                    lst2.remove(lst2(i))\n\
    \                    count += 1\n                    i = lst1.length\n       \
    \             count += 1\n                }\n            }\n            str +=\
    \ \")\"\n        }\n        if(lst2.nonEmpty){\n            str += \"(\"\n   \
    \         while(i < lst2.length){\n                str += lst2(lst2(i))\n    \
    \            i += 1 \n                if(lst2(i) == \"(\"){\n                \
    \    count += 1\n                }\n                if(lst2(i) == \")\"){\n  \
    \                  count -= 1\n                }\n                if((count ==\
    \ 0) && (lst2(i) == \"(\")){\n                    lst2.remove(lst2(i))\n     \
    \               lst1.remove(lst1(i))\n                    count += 1\n       \
    \             i = lst2.length\n                    count += 1\n              \
    \  }\n            }\n            str += \")\"\n        }\n        if(str != \"\
    \"){\n            return \"Yes\"\n        }else{\n            return \"No\"\n\
    \        }", "      val stack = mutable.Stack[Boolean]()\n      val isBalanced\
    \ = lst.forall(x => x contains '(' && x contains ')')\n      if (!isBalanced)\
    \ return \"No\"\n      var ret = \"\"\n      var index = -1\n      val lstr =\
    \ lst.reverse\n      while(stack.nonEmpty && index < lstr.length) {\n        val\
    \ item = stack.last\n        stack.pop()\n        if (item == false) {\n     \
    \     ret = (lstr.drop(index) mkString \"\")\n          break\n        }\n   \
    \     index += 1\n      }\n      if (stack.nonEmpty || index < lstr.length) return\
    \ \"No\"\n      ret", "        val inv = lst.foldLeft(new mutable.HashMap[String,\
    \ List[String]]()){ (m, s) =>\n            if (m.containsKey(s)) {\n         \
    \       m.get(s).push(s)\n            } else {\n                var ns: List[String]\
    \ = Nil\n                if (s.contains('(')) {\n                    ns = s filterNot\
    \ (x => x == '(')\n                } else {\n                    ns = s filterNot\
    \ (x => x == ')')\n                }\n                m.put(s, ns)\n         \
    \   }\n            m\n        }\n        if (inv.keys.size == 0) {\n         \
    \   return \"No\"\n        } else {\n            var result: String = \"No\"\n\
    \            var cur = 0\n            var next = 1\n            var isGood = false\n\
    \            while (cur < lst.length) {\n                val leftParen = lst.apply(cur)\n\
    \                val rightParen = lst.apply(next)\n                val curRight\
    \ = inv.apply(leftParen).indexOf(rightParen)\n                val curLeft = inv.apply(leftParen).lastIndexOf(rightParen)\n\
    \                if (curRight != -1) {\n                    isGood = true\n  \
    \              } else {\n                    isGood = false\n                }\n\
    \                if (curLeft == -1) result += \"Yes\"\n                if (isGood)\
    \ result += \"Yes\"\n                cur += next\n                next += 1\n\
    \            }\n            result\n        }", "        var result = \"No\"\n\
    \        val stack = mutable.Stack[String]()\n        val parens = lst.map(x =>\
    \ if (x == \"(\") stack.toList else stack += x)\n        val isGood = parens.forall(x\
    \ => x != \"()\")\n        if (isGood) {\n            val goodStrings = parens.filter(x\
    \ => x != \"()\").takeWhile(x => x != \"()\").tail\n            if (goodStrings.length\
    \ != 1) {\n                result = \"No\"\n            } else {\n           \
    \     result = goodStrings.head\n            }\n        }\n        result", " \
    \       val list1 = lst.head\n        val list2 = lst.tail\n        val n = list2.length\n\
    \        val list1 = list1.replaceAll(\"[()]\", \"\").replaceAll(\"[()]+\", \"\
    \")\n        var count = 0\n        var left = 0\n        var right = 0\n    \
    \    var output = \"Yes\"\n        for (i <- list1.indices) {\n            if\
    \ (list1(i) == '(') {\n                left+=1\n            } else if (list1(i)\
    \ == ')') {\n                right-=1\n            }\n            if (left < right)\
    \ {\n                count += 1\n            }\n        }\n        if (count ==\
    \ n) {\n            output = \"Yes\"\n        } else {\n            output = \"\
    No\"\n        }\n        output", "        val ind = lst.map(_.length).max\n \
    \       val s = lst.reverse.filter(_(ind).isDefined).map(_.substring(0,ind))\n\
    \        val p = lst.map(_.charAt(ind-1))\n        if (p.forall(_.isClosed))\n\
    \            s\"No\"\n        else\n            s\"Yes${s.reverse.mkString}\"",
  "        val map = new mutable.HashMap[String,Int]()\n        val stack = new mutable.Stack[String]()\n\
    \        for(i <- 0 until lst.size){\n            if(i==lst.size -1){\n      \
    \          if(lst(i).contains(\"(\") && lst(i).contains(\")\"))\n            \
    \        return \"Yes\"\n                else {\n                    if(lst(i).contains(\"\
    (\"))\n                        return \"Yes\"\n                    else\n    \
    \                    return \"No\"\n                }\n            }\n       \
    \     val value = lst(i)\n            val isOpen = value.contains(\"(\")\n   \
    \         val isClose = value.contains(\")\")\n            if(!map.contains(value)){\n\
    \                map.put(value,0)\n                stack += value\n          \
    \  }\n            map.get(value) += 1\n            if(isOpen == !isClose){\n \
    \               stack.pop\n                stack += value\n            }\n   \
    \     }\n        \"No\"", "        // 1. Write a method to find the balance of\
    \ parentheses.\n        def balance(s: String): Int = {\n            val l = s.length\n\
    \            var left = 0, right = l\n            while (left < right) {\n   \
    \             if (s(left) <:< '(') left += 1\n                if (s(right) <:<\
    \ ')') right -= 1\n            }\n            left - right\n        }\n\n    \
    \    // 2. Write a method to compare the two strings by concatenating them\n \
    \       //    and see if they are good.\n        def check(l: List[String], s:\
    \ String): Boolean = {\n            val l = l.filter(x => !x.contains(s))\n  \
    \          if (l.length < 2) false\n            else if (balance(s.replaceAll(\"\
    \\\\)\", \"))\") < balance(s.replaceAll(\"\\\\(\", \"(\"))) true\n           \
    \ else check(l.tail, s.replaceAll(\"\\\\(\", \"(\"))\n        }\n\n        //\
    \ 3. Write a recursive method to solve the problem.\n        if (lst.length ==\
    \ 1) lst(0)\n        else check(lst, lst(0))", "        val lst1 = lst.map(x=>x.substring(1,\
    \ x.length-1))\n        val lst2 = lst.map(x=>x.substring(1, x.length-1)).filter(x=>x.equals(\"\
    \"))\n        val lst3 = lst.filter(x=>x.contains(\"(\")).toList\n        val\
    \ lst4 = lst.filter(x=>x.contains(\")\")).toList\n        if(lst1.size==lst2.size+lst3.size+lst4.size){\n\
    \            if(lst1.size==lst3.size+lst4.size){\n                if(lst2.size==lst3.size+lst4.size){\n\
    \                    if(lst3.isEmpty){\n                        \"Yes\"\n    \
    \                }else{\n                        \"No\"\n                    }\n\
    \                }else{\n                    \"No\"\n                }\n     \
    \       }else{\n                \"Yes\"\n            }\n        }else{\n     \
    \       \"No\"\n        }", "        // Solution\n        var ans = lst.foldLeft(\"\
    No\"){ (acc,curr) => {\n            if(curr == \"()\") \"Yes\"\n            else\
    \ acc match {\n                case acc if acc.indexOf(\"(\") < acc.indexOf(\"\
    )\") => acc\n                case acc if acc.indexOf(\"(\") > acc.indexOf(\")\"\
    ) => acc.substring(0, acc.indexOf(\"(\")) + curr + acc.substring(acc.indexOf(\"\
    )\") + 1)\n                case acc if acc.indexOf(\"(\") == acc.indexOf(\")\"\
    ) => acc + curr\n            }\n        }}\n        ans.toUpperCase()", "    \
    \    val l = lst.head // get the first element\n        var count = 0\n      \
    \  for(i <- 0 to l.length){\n            if(l.charAt(i)=='(' && count<l.length){\n\
    \                count = count + 1\n            }\n            if(l.charAt(i)==')'\
    \ && count>0){\n                count = count - 1\n            }\n           \
    \ if(count==0 && count==l.length){\n                return \"Yes\"\n         \
    \   }\n        }\n        \"No\"", "        def loop(remainingParanthesis: List[String],\
    \ result: List[String], i: Int) : String = {\n            if (i == remainingParanthesis.length\
    \ - 1) result.reverse.mkString(\"(\", \")\")\n            else loop(remainingParanthesis,\
    \ result :: result.take(i+1), i + 1)\n        }\n        if (lst.length == 0)\
    \ \"No\"\n        else loop(lst, Nil, 0)", "        val str: List[String] = lst.takeWhile(x\
    \ => x != \"\").reverse\n        // If there are zero parentheses, return \"Yes\"\
    \n        if (str.length == 0) \"Yes\" else \"No\"", "        val countMap = lst.length.toList.foldLeft(Map[Int,\
    \ Int]()){\n            case (acc, elem) =>\n                if (elem==\"(\")\
    \ {\n                    acc + (elem->1)\n                } else {\n         \
    \           acc + (elem->-1)\n                }\n        }\n        val countMap\
    \ = countMap.map{\n            case (_,v) => v\n        }\n        val list2 =\
    \ lst.length.toList.foldLeft(List[String]()){\n            case (acc, i) => acc\
    \ :+ lst(i)\n        }\n        val list3 = list2.length.toList.foldLeft(List[String]()){\n\
    \            case (acc, i) => acc :+ list2(i)\n        }\n        val countMap\
    \ = countMap.toList.reverse.foldLeft(List[Int]()){\n            case (acc, elem)\
    \ =>\n                if (elem > 0) {\n                    acc :+ (elem-1)\n \
    \               } else if (elem < 0) {\n                    acc :+ (elem+1)\n\
    \                } else {\n                    acc\n                }\n      \
    \  }\n        list3.map{\n            x => countMap.reverse.foldLeft(List(false)){\
    \ case (acc, elem) =>\n                if (elem==0) {\n                    acc\
    \ :+ (true)\n                } else {\n                    acc :+ (x contains\
    \ elem) }\n            }\n        }.foldLeft(\"\"){ case (acc, res) => acc :+\
    \ (res :+ \"Yes\")}", "        def matching(str:List[String], open:List[String],\
    \ close:List[String]) : List[String] = {\n            if(str.isEmpty) close\n\
    \            else if(str == open || str == close) matching(str.tail, open, close)\n\
    \            else if(str.length == 1) open\n            else matching(str.tail,\
    \ open ::: str.head, close ::: str.tail)\n        }\n        val open = (lst(0)\
    \ match {\n            case \")\" => Nil\n            case \")(\"   => Nil\n \
    \           case \")((\"  => Nil\n            case \")((\" => Nil\n          \
    \  case \")((((\" => Nil\n            case \")(((\"  => Nil\n            case\
    \ \")((((\" => Nil\n            case \")(((((\"  => Nil\n            case \")((((((\"\
    \ => Nil\n            case \")((((((\" => Nil\n            case \")(((((((\" \
    \ => Nil\n            case \")((((((((\" => Nil\n            case \")(((((((((\"\
    \  => Nil\n            case \")(((((((((\" => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case ", "        val ind = lst.indexWhere(_ startsWith\
    \ \"(\")\n        val vals = lst.drop(ind)\n        val ind2 = lst.indexWhere(_\
    \ startsWith \"(\")\n        val vals2 = lst.drop(ind2)\n        var flag = true\n\
    \        var i = 0\n        while(i < vals2.length) {\n            val temp =\
    \ vals(i).dropRight(1)\n            val j = i + 1\n            while (j < vals2.length)\
    \ {\n                val next = vals2(i).dropRight(1)\n                if((temp+next)==\"\
    \") flag = false\n                else j+=1\n            }\n            i+=1\n\
    \        }\n        if(flag) \"Yes\" else \"No\"", "        var res = 0\n    \
    \    var stack = new mutable.Stack[String]()\n        for (ele <- lst) {\n   \
    \         var opens = 0\n            for (c <- ele) {\n                if (c ==\
    \ '(')\n                    opens += 1\n                else if (c == ')')\n \
    \                   opens -= 1\n                if (opens == 0)\n            \
    \        res += 1\n                stack.push(c)\n            }\n        }\n \
    \       if (res == 0)\n            return \"No\"\n        else\n            return\
    \ \"Yes\"", "        val ps = new Stack[String]\n        val newlst : List[String]\
    \ = lst.filter(_ != \"\")\n        if (newlst.size != 1) {\n            return\
    \ \"No\"\n        }\n        newlst.head match {\n            case \"(\" => ps.push(\"\
    (\")\n            case \")\" => ps.push(\")\")\n            case x => ps.push(x)\n\
    \        }\n        if (ps.size != newlst.size) {\n            return \"No\"\n\
    \        }\n        // loop through all open parentheses\n        while (true)\
    \ {\n            val p = ps.pop\n            if (!ps.isEmpty) {\n            \
    \    ps.head match {\n                    case x if x == \"(\" => ps.push(x)\n\
    \                    case x if x == \")\" => ps.push(x)\n                    case\
    \ _ => println(\"bad string\")\n                }\n            }\n           \
    \ if (ps.isEmpty) break\n        }\n        // loop through all close parentheses\n\
    \        val flag = true\n        while (true) {\n            val p = ps.pop\n\
    \            if (!ps.isEmpty) {\n                ps.head match {\n           \
    \         case x if x == \"(\" => ps.push(x)\n                    case x if x\
    \ == \")\" => ps.push(x)\n                    case _ => flag = false\n       \
    \         }\n            }\n            if (ps.isEmpty) break\n        }\n   \
    \     if (newlst.head == \"()\") {\n            if (flag) \"Yes\" else \"No\"\n\
    \        } else {\n            if (flag) \"No\" else \"Yes\"\n        }", "  \
    \      val leftParentheses = lst(0).filter(c => c == '(')\n        val rightParentheses\
    \ = lst(1).filter(c => c == ')')\n        if(leftParentheses.length < 0 || rightParentheses.length\
    \ < 0 || leftParentheses.length != rightParentheses.length) {\n            return\
    \ \"No\"\n        } else {\n            return \"Yes\"\n        }", "        val\
    \ left = lst(0)\n        val right = lst(1)\n        var openParen = false //\
    \ flag to check open paren count\n        var closeParen = false\n        var\
    \ stack = []\n        var result = \"No\"\n        for(c <- left){\n         \
    \   c match {\n                case \"(\" => {\n                    stack push\
    \ c\n                    openParen += 1\n                }\n                case\
    \ \")\" => {\n                    openParen -= 1\n                    if(openParen\
    \ == 0){\n                        closeParen = true\n                    }\n \
    \               }\n                case _ =>\n            }\n        }\n     \
    \   if(closeParen){\n            result = \"Yes\"\n        }\n        return result",
  "        if(lst.isEmpty) \"\"\n        else {\n            var l1 = lst.head ::\
    \ lst.tail\n            var l2 = lst.tail :: lst.head :: Nil\n            if((l1.isEmpty\
    \ && l2.isEmpty) || (l1.nonEmpty && l2.isEmpty)) \"No\"\n            else if(l1.nonEmpty\
    \ && l2.nonEmpty) matchParens(l1) ++ matchParens(l2)\n            else \"\"\n\
    \        }", "        def rec(left: String, right: List[String], index: Int, res:\
    \ String): String = {\n            if (index >= right.length) return res\n   \
    \         rec(left + \"(\" + right(index) + \")\", right, index + 1, res + left+\"\
    (\"+right(index)+\"))\")\n        }\n        rec(\"(\", lst, 0, \"\")", "    \
    \    val openStack = mutable.Stack[String]()\n        val closeStack = mutable.Stack[String]()\n\
    \        for(i <- 0 until lst.size){\n            if(i == lst.length - 1 || lst(i)\
    \ == \")\"){\n                closeStack.push(lst(i))\n            }\n       \
    \     else if(i == lst.length - 1 && lst(i) == \"(\"){\n                openStack.push(lst(i))\n\
    \            }\n            else{\n                val openParen = openStack.mkString\n\
    \                val closeParen = closeStack.mkString\n                if(i ==\
    \ 0 || (openStack.head.toString.equals(openParen) && closeStack.head.toString.equals(closeParen))){\n\
    \                    if(openStack.size != closeStack.size) throw new Exception(\"\
    not enough parentheses match\")\n                    openStack.pop\n         \
    \           closeStack.pop\n                }\n            }\n        }\n    \
    \    if(openStack.size == 0) \"No\" else \"Yes\"", "        val good = lst.filter(\
    \ s => s.charAt(0) == '(' && s.charAt(s.length - 1) == ')' )\n        println(\
    \ good )\n        good.map(_.substring(1,s.length-1)).mkString(\"\")", "     \
    \   val p = lst.map(c => (c.charAt(0), c.charAt(1))).toSet\n        val n = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toSet\n       \
    \ val l = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.toSet\n\
    \        val n = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toSet\n        val l = lst.map(c => (c.charAt(0), c.charAt(1))).map(c\
    \ => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n\
    \        val ns = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toSet\n        val nl = lst.map(c => (c.charAt(0),\
    \ c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n\
    \        val nls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toSet\n        val nlnl = lst.map(c => (c.charAt(0),\
    \ c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toSet\n\
    \        val nlnls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toSet\n        val nlnlnl = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toList.toSet\n        val nlnlnls = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toList.toSet\n        val nlnlnlnl = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toList.toList.toSet\n        val nlnlnlnls\
    \ = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.",
  "        var goodString = \"\"\n        var goodStringCount = 1\n        val paren\
    \ = mutable.HashSet[String]()\n\n        // Add open parentesi to stack\n    \
    \    for (i <- 0 until lst.size) {\n            val temp = lst(i)\n          \
    \  if (paren.contains(temp)) {\n                paren -= temp\n              \
    \  goodStringCount += 1\n            } else {\n                paren += temp\n\
    \            }\n        }\n\n        // Add close parentesi to stack\n       \
    \ for (i <- lst.size until 0 ) {\n            val temp = lst(i)\n            if\
    \ (paren.contains(temp)) {\n                paren -= temp\n                goodStringCount\
    \ += 1\n            } else {\n                paren += temp\n            }\n \
    \       }\n\n        // Add close parentesi to stack\n        for (i <- 0 until\
    \ lst.size) {\n            val temp = lst(i)\n            if (paren.contains(temp))\
    \ {\n                paren -= temp\n                goodStringCount += 1\n   \
    \         } else {\n                paren += temp\n            }\n        }\n\n\
    \        if (goodStringCount >= lst.size) {\n            goodString = \"Yes\"\n\
    \        } else {\n            goodString = \"No\"\n        }\n\n        goodString",
  "        val str = lst.head\n        val rest = lst.tail\n        var cur = 0\n\
    \        var found = false\n        var stack = 0\n        var strStack = List[String]()\n\
    \n        while (!found) {\n            if (strStack.contains(str)) {\n      \
    \          stack = strStack.lastIndexOf(str) match {\n                    case\
    \ Some(i) => (strStack.length - i) -1\n                    case None => 0\n  \
    \              }\n                found = true\n            }\n            else\
    \ if (cur + 1 == stack) {\n                strStack = strStack.filterNot(_ ==\
    \ str)\n                stack = 0\n                cur = 0\n                if\
    \ (rest.isEmpty || strStack.isEmpty)\n                    return \"No\"\n    \
    \            found = true\n            }\n            else {\n               \
    \ stack = strStack.lastIndexOf(str) match {\n                    case Some(i)\
    \ => (strStack.length - i) -1\n                    case None => 0\n          \
    \      }\n                cur += 1\n                if (stack == 0)\n        \
    \            found = true\n            }\n        }\n\n        val reverseStr\
    \ = str.reverse\n        var curStr = \"\"\n        while (!found) {\n       \
    \     if (curStr == reverseStr) {\n                found = true\n            }\n\
    \            else if (curStr == reverseStr.substring(reverseStr.length - 1, 1))\
    \ {\n                curStr += reverseStr.substring(0, reverseStr.length - 1)\n\
    \            }\n            else if (curStr == reverseStr.substring(reverseStr.length\
    \ - 2, reverseStr.length - 1)) {\n                curStr += reverseStr.substring(0,\
    \ reverseStr.length - 2)\n            }\n            else {\n                curStr\
    \ += reverseStr.substring(0, reverseStr.length - 1)\n            }\n        }\n\
    \n        reverseStr", "        val list = lst.map(x => (x match {\n         \
    \   case xs if xs.matches(\"\\\\(.*\\\\)\")=> xs.replaceAll(\"\\\\(.*\\\\)\",\
    \ \"\\\\*\")\n            case xs if xs.matches(\"\\\\(.*\") => xs.replaceAll(\"\
    \\\\(.*\", \"\\\\(\")\n            case xs if xs.matches(\"\\\\*.*\") => xs.replaceAll(\"\
    \\\\*.*\", \"\\\\*\")\n            case xs if xs.matches(\"\\\\*\") => xs.replaceAll(\"\
    \\\\*\", \"\\\\*\")\n            case xs if xs.matches(\"\") => xs.replaceAll(\"\
    \\\\*\", \"\")\n            case xs => xs\n        }))\n        val list2 = list.zipWithIndex.sortBy(x\
    \ => (x(0), x(1)))\n        var str = \"\"\n        var i = 0\n        for (i\
    \ <- 1 to list2.length) {\n            str = str + list2(i)._1\n        }\n  \
    \      val newStr = str.substring(0, str.length - 1)\n        newStr match {\n\
    \            case xs if xs.matches(\"\\\\*(.*)\\\\*\") => newStr + \"*\"\n   \
    \         case xs if xs.matches(\"\\\\*\\\\*(.*)\\\\*\\\\*\") => newStr + \"***\"\
    \n            case _ => newStr\n        }", "        val stack = Stack[List[String]]()\n\
    \        val list = new collection.mutable.ArrayBuffer[String]()\n        for(l\
    \ <- lst){\n            l match {\n                case \")\" :: tail => list.add(l)\n\
    \                case \")\" => stack.poll()\n                case _ => {\n   \
    \                 l match {\n                        case \")(\"  :: tail => stack.push(tail.reverse:_*)\n\
    \                        case \")(\"  => stack.append(tail.reverse:_*)\n     \
    \                   case _ => stack.append(l:_*)\n                    }\n    \
    \            }\n            }\n        }\n        if(list.size != 2) \"No\"\n\
    \        else {\n            val stack2 = stack.toList\n            val list2\
    \ = list.filter( x => stack2.contains(x) )\n            val list3 = list2.reverse\n\
    \            val stack3 = stack2.filter( x => !list2.contains(x) )\n         \
    \   val list4 = list3.reverse\n            if(stack3.isEmpty) list4\n        \
    \    else list4.mkString(\"(\",\")\",\")\")\n        }", "        // Your code\
    \ here\n        val parenthCounter = lst.filter(_ => _ == \"(\" || _ == \")\"\
    ).size\n        if (parenthCounter == 0) \"No\"\n        else \"Yes\"", "    \
    \    // This checks if all items in the list are open or closed\n        // if\
    \ any item isn't closed, it's an invalid string\n        if(lst.forall(_.contains('('))){\n\
    \            val opens = lst.filter(_.contains('('))\n            val closes =\
    \ lst.filter(_.contains(')'))\n            if(opens.size != closes.size){\n  \
    \              return \"No\"\n            }\n            val openChars = opens.map(_.toString.toInt)\n\
    \            val closeChars = closes.map(_.toString.toInt)\n            // This\
    \ counts the number of open parentheses\n            // and checks if the number\
    \ of open and closed parentheses\n            // are equal\n            if(opens.size\
    \ == closes.size){\n                if(openChars.toSet == closeChars.toSet){\n\
    \                    return \"Yes\"\n                }\n            }\n      \
    \      return \"No\"\n        }\n        return \"No\"", '        // Code goes
    here', "        val stack = mutable.Stack[Int](1 , 0)\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size){\n            val str = lst(i)\n         \
    \   val openParen = str.indexOf(\"(\")\n            val closeParen = str.indexOf(\"\
    )\")\n            val openParenIndex = str.indexOf(\"(\", openParen+1)\n     \
    \       val closeParenIndex = str.indexOf(\")\", closeParen+1)\n            stack.push(openParenIndex+1)\n\
    \            stack.push(closeParenIndex+1)\n            while(stack.length > 0){\n\
    \                val openParenIndex = stack.pop()\n                val closeParenIndex\
    \ = stack.pop()\n                if(openParenIndex < closeParenIndex){\n     \
    \               result.push(str)\n                    break\n                }\n\
    \                result.push(str.substring(openParenIndex+1, closeParenIndex+1))\n\
    \            }\n        }\n        if(result.size == lst.size){\n            \"\
    Yes\"\n        } else {\n            \"No\"\n        }", "        def dfs(lst\
    \ : List[String], res: String, i: Int): String = {\n            if (i == lst.length)\n\
    \                if (res == \"\")\n                    res\n                else\n\
    \                    \"No\"\n            else\n                dfs(lst, res+lst(i),\
    \ i+1)\n        }\n\n        var res = \"\"\n        var i = lst.size - 1\n  \
    \      while (i>0) {\n            if (lst(i) == \"(\") {\n                val\
    \ tmp = dfs(lst.reverse, \"\", i)\n                if (tmp == \"Yes\")\n     \
    \               res += lst(i)\n                i = i - 1\n            } else if\
    \ (lst(i) == \")\") {\n                val tmp = dfs(lst, \"\", i)\n         \
    \       if (tmp == \"Yes\")\n                    res += lst(i)\n             \
    \   i = i - 1\n            } else {\n                val tmp = dfs(lst, \"\",\
    \ i)\n                if (tmp == \"Yes\")\n                    res += lst(i)\n\
    \                i = i - 1\n            }\n        }\n\n        res + dfs(lst.reverse,\
    \ \"\", i)", "        if (lst.isEmpty) \"\"\n        else {\n            var str\
    \ = lst(0)\n            var stack = Stack[Int](1,0)\n            var index = 0\n\
    \            var good = true // = false // flag to indicate whether there's any\
    \ way to make good string\n            while (index<str.length) {\n          \
    \      if (str.charAt(index)=='(') stack.push(index)\n                else if\
    \ (str.charAt(index)==')') {\n                    val top = stack.pop()\n    \
    \                if (stack.empty) good = false // = false // flag to indicate\
    \ whether there's any way to make good string\n                    else if (stack.top()\
    \ < top-1) good = false\n                    else if (stack.top()==top+1 && stack.contains(top-1))\
    \ good = false\n                    else stack.push(top)\n                }\n\
    \                index++\n            }\n            if (stack.empty) \"\"\n \
    \           else good ? \"Yes\" : \"No\"\n        }", "        //If we have two\
    \ string and they have no parenthesis\n        if(lst.size == 2){\n          \
    \  val p1 = lst.head\n            val p2 = lst.last\n            p1 match {\n\
    \                case s\"${p2}$\" => s\"Yes\"\n                case _ => s\"No\"\
    \n            }\n        }\n        //If there is one string with parenthesis\n\
    \        else if(lst.size == 1){\n            val p1 = lst.head\n            p1\
    \ match {\n                case s\"${p1}$\" => s\"Yes\"\n                case\
    \ _ => s\"No\"\n            }\n        }\n        //If there is no parenthesis\n\
    \        else {\n            val p1 = lst.head\n            p1 match {\n     \
    \           case s\"${p1}$\" => s\"Yes\"\n                case _ => s\"No\"\n\
    \            }\n        }", "        var ret = \"No\"\n        if (lst.size !=\
    \ 2) return ret\n        val head = (lst.head)\n        val tail = (lst.tail)\n\
    \        var open = 0\n        var close = 0\n        if (head.charAt(0) == '(')\
    \ open = 1\n        if (head.charAt(0) == ')') close = 1\n        if (head.charAt(1)\
    \ == '(') open += 1\n        if (head.charAt(1) == ')') close += 1\n        if\
    \ (close != open) return \"No\"\n        var res = 0\n        tail.foreach(x =>\
    \ {\n            if (x == '(') open += 1\n            if (x == '[' || x == '{'\
    \ || x == '(') open -= 1\n            if (x == ')' || x == ']' || x == ')') close\
    \ -= 1\n            if (x == '}' || x == '}') close -= 1\n            if (open\
    \ == 0 && close == 0) res +=1\n        })\n        if (res == 0) ret = \"Yes\"\
    \n        return ret", "      val (left, right) = (lst.head match {\n        case\
    \ '(' => Some(lst.tail.head),\n        case ')' => Some(lst.tail.head),\n    \
    \    case _ => None\n      }) match {\n        case Some(x) => Some((x.mkString))\n\
    \        case None => \"No\"\n      }\n      if(left.isEmpty && right.isEmpty)\n\
    \        \"Yes\"\n      else\n        matchParens(lst.tail) match {\n        \
    \  case \"\" => \"Yes\"\n          case _ => left.get + right.get + matchParens(lst.tail)\n\
    \        }", "      lst.foldLeft(\"Yes\") { (result, e) =>\n        val parens\
    \ = e.split(\"\\\\(\").length\n        if (parens == lst.filter(s => s.startsWith(e)).size)\
    \ {\n          result + \"Yes\"\n        } else {\n          result + \"No\"\n\
    \        }\n      }", "      val stack = mutable.Stack[String]()\n      var ret\
    \ = \"No\"\n      for(x <- lst) {\n        if(x contains '(') {\n          stack.push(x)\n\
    \        }\n        if(x contains ')') {\n          if(stack.size > 0) {\n   \
    \         stack.pop\n            if(stack.size == 0) {\n              ret +=\"\
    Yes\"\n            }\n          }\n        }\n      }\n      ret", "        val\
    \ str1 = lst(0) // first string in lst\n        val str2 = lst(1) // second string\
    \ in lst\n        val stack = ListBuffer[String]() // stack for checking\n   \
    \     val stackSize = lst.size - 2 // number of open parentheses in lst\n    \
    \    val index = 0\n        while (index < stackSize) {\n            if (str1\
    \ == \"(\") {\n                stack.push(str1)\n                index += 1\n\
    \            }\n            if (str1 == \")\") {\n                val lastStr\
    \ = stack.pop\n                if (lastStr != \"(\") {\n                    return\
    \ \"No\"\n                }\n                index += 1\n            }\n     \
    \   }\n        if (index == stackSize) {\n            return \"Yes\"\n       \
    \ }\n        return \"No\"", "        def matchParens(lst : List[String], s :\
    \ String) : String = {\n            if (lst.isEmpty)\n                \"No\"\n\
    \            else if (lst.head == \"(\")\n                matchParens(lst.tail,\
    \ \"Yes\") + matchParens(lst.tail, s.dropRight(1))\n            else if (lst.head\
    \ == \")\")\n                matchParens(lst.tail, s.dropRight(1) + matchParens(lst.tail,\
    \ \"Yes\"))\n            else if (lst.head == \"Yes\" && lst.tail.head == \"Yes\"\
    )\n                matchParens(lst.tail.tail, lst.head + s)\n            else\n\
    \                matchParens(lst.tail, \"No\")\n        }\n\n        matchParens(lst,\
    \ \"\")", "        val bList: List[Boolean] = lst.map( x => (x == \"(\") ? true\
    \ : false)\n        val aList: List[Boolean] = lst.map( x => (x == \"(\") ? false\
    \ : true)\n        if (bList.reduce(_ && _) && aList.reduce(_ && _)) {\n     \
    \       if (bList.reduce(_ * _) && aList.reduce(_ * _)) {\n                if\
    \ (bList.reduce(_ * _ * aList.reduce(_ * _))) \n                    \"Yes\" else\
    \ \"No\"\n                \n                else {\n                    val newList:\
    \ List[String] = lst.map(x => x + \"()\")\n                    if (newList.reduce(_\
    \ + _)) \"Yes\" else \"No\"\n                }\n            } else {\n       \
    \         if (bList.reduce(_ * _)) \"Yes\" else \"No\"\n                else \n\
    \                    val newList: List[String] = lst.map(x => x + \"()\")\n  \
    \                  if (newList.reduce(_ + _)) \"Yes\" else \"No\"\n          \
    \  }\n        }\n        else \n            if (bList.reduce(_ * _)) \"Yes\" else\
    \ \"No\"", "        val stack = mutable.Stack[List[String]]()\n        for(x <-\
    \ lst)\n            if(x.toList.size == 0)\n                stack += x\n     \
    \       else if(x.toList(0).toString == \"(\")\n                stack += x.drop(1)\n\
    \            else if(!stack.isEmpty){\n                if(x.toList(0).toString\
    \ == \")\" && stack.last.toList(0).toString == \"(\")\n                    stack.pop()\n\
    \                else\n                    stack += x\n            }\n       \
    \ if(stack.size <= 0)\n            \"No\"\n        else\n            \"Yes\"",
  "        if(lst.length == 0) \"Yes\"\n        else if(lst.length == 1) \"No\"\n\
    \        else if(lst.length == 2) \"Yes\"\n        else matchParens(lst.tail)\
    \ + matchParens(lst.init)", "        var good = \"Yes\"\n        for (a <- lst\
    \ if a.contains(\"(\")) {\n            for (b <- lst if b.contains(\")\")) {\n\
    \                val newA = a.substring(a.indexOf(\"(\"), a.lastIndexOf(\")\"\
    ))\n                val newB = b.substring(b.indexOf(\"(\"), b.lastIndexOf(\"\
    )\"))\n                if ((newA + newB) == a) {\n                    good = \"\
    No\"\n                    break\n                }\n            }\n        }\n\
    \        good", "        val stack = Stack.empty[String]\n        val result =\
    \ Stack.empty[String]\n        lst.reverse.foreach(x => {\n            if(x ==\
    \ \"(\") {\n                stack.push(x)\n            } else if(x == \")\") {\n\
    \                if(!stack.peek().equals(\"(\")) {\n                    result\
    \ += \"No\"\n                } else {\n                    if(!stack.peek().equals(\"\
    (\")) {\n                        result += \"Yes\"\n                    }\n  \
    \              }\n                stack.pop()\n            }\n        })\n   \
    \     result.mkString", "        val stack = mutable.Stack[String]()\n       \
    \ val stackWithParen = mutable.Stack[Boolean]()\n\n        def addParen(s: String)\
    \ : Unit = {\n            if (s.contains(\"(\") || s.contains(\")\")) stackWithParen.push(true)\n\
    \            else stackWithParen.push(false)\n            stack += s\n       \
    \ }\n\n        lst.foreach { s =>\n            if (s.contains(\"(\")) {\n    \
    \            addParen(s)\n            }\n            if (s.contains(\")\")) {\n\
    \                if (stack.size == 1 && stackWithParen.head) {\n             \
    \       return \"Yes\"\n                } else {\n                    return \"\
    No\"\n                }\n            }\n        }\n        return \"No\"", " \
    \       //Write your code here\n        if(lst.size < 2) \n            return\
    \ \"No\"\n        else\n           var open = 1\n           var close = 0\n  \
    \         var str = \"\"\n           var curStr = lst(0)\n           var result\
    \ = \"No\"\n           while(curStr != \"\") {\n                if(curStr == \"\
    (\") \n                    open += 1\n                else if(curStr == \")\"\
    )\n                    close += 1\n                else\n                    return\
    \ \"No\"\n\n                if(open > close)\n                    result = \"\
    Yes\"\n                curStr = lst(open)\n                open -= 1\n       \
    \         close += 1\n           }\n           return result", "        if(lst.isEmpty)\
    \ \n            \"No\" \n        else if(lst.head == lst.last.head) {\n      \
    \      val s = lst.tail\n            (lst.head == s.head) match {\n          \
    \      case true => matchParens(s.tail)\n                case _ => \"No\"\n  \
    \          }\n        } else {\n            val s = lst.tail\n            matchParens(s.tail)\
    \ match {\n                case true => \"Yes\"\n                case _ => matchParens(s.tail)\n\
    \            }\n        }", "        var flag = 1\n        var res : String =\
    \ \"\"\n        for (x <- lst) {\n            val s = x.replaceAll(\"\\\\(\",\
    \ \"\").replaceAll(\"\\\\)\", \"\")\n            val l = s.length\n          \
    \  var cur = 0\n            var sum = 0\n            var flag = 0\n          \
    \  for(i <- 0 until s.length){\n                if(s.charAt(i) == '('){\n    \
    \                sum += 1\n                } else if(s.charAt(i) == ')'){\n  \
    \                  if(sum > 0){\n                        sum -= 1\n          \
    \          } else {\n                        flag = 1\n                    }\n\
    \                }\n                cur += 1\n            }\n            if(flag\
    \ == 0){\n                res = \"No\"\n                break\n            }\n\
    \            res = res + \"(\" + s.substring(cur, cur + l) + \")\"\n        }\n\
    \        if (res.equals(\"\")) {\n            res = \"Yes\"\n        }\n     \
    \   return res", "      require(!lst.isEmpty)\n      var stack = Stack(lst.head)\n\
    \      var result = true\n      for (a <- lst.tail) {\n        if (stack.hasLeft)\
    \ {\n          stack.peek.right\n          stack.pop()\n        } else {\n   \
    \       if (stack.hasRight) {\n            stack.peek.left\n            stack.pop()\n\
    \          } else {\n            stack.pop()\n          }\n          stack.pop()\n\
    \        }\n      }\n      if (stack.hasLeft) {\n        result = \"No\"\n   \
    \   } else if (stack.hasRight) {\n        result = \"Yes\"\n      }\n      result",
  "        val p = lst.foldLeft(List[List[String]]()) {\n            (acc, x) =>\n\
    \                if (acc.isEmpty) x :: acc.head\n                else if (x.charAt(0)\
    \ == '(' && acc.last.last.charAt(0) == ')') acc.last.last + x else acc :+ x\n\
    \        }\n        p.filter(_.length == 2).foldLeft(List[String]()) {\n     \
    \       (acc, x) =>\n                if (x.charAt(0) == '(' && acc.last.last.charAt(0)\
    \ == ')') acc.last.last + x\n                else if (acc.isEmpty) x :: acc.head\n\
    \                else {\n                    if (acc.last.last != x.charAt(0))\
    \ acc :+ x else acc :+ acc.last.last + x\n                }\n        }.head",
  "        val lst1 = lst.map( x => x.split(\"(\").size)\n        val lst2 = lst.map(\
    \ x => x.split(\")\").size)\n        val len = lst1.zipWithIndex.max( x => x._2\
    \ - x._1)\n        val l1 = lst1.filter( x => x._2 < len)\n        val l2 = lst2.filter(\
    \ x => x._2 < len)\n        val l3 = lst1.filter( x => x._2 > len && x._2 < len)\n\
    \        val l4 = lst2.filter( x => x._2 > len && x._2 < len)\n        val s1\
    \ = l1.map( x => x._2).mkString(\"\")\n        val s2 = l2.map( x => x._2).mkString(\"\
    \")\n        val s3 = l3.map( x => x._2).mkString(\"\")\n        val s4 = l4.map(\
    \ x => x._2).mkString(\"\")\n        val n = l1.size + l2.size + l3.size + l4.size\
    \ + 1\n        if (s1.isEmpty) {\n            if (s2.isEmpty) {\n            \
    \    if (s3.isEmpty) {\n                    if (s4.isEmpty) {\n              \
    \          \"Yes\"\n                    } else {\n                        \"No\"\
    \n                    }\n                } else {\n                    \"No\"\n\
    \                }\n            } else {\n                \"No\"\n           \
    \ }\n        } else {\n            \"No\"\n        }"]
stop_tokens:
- "\n    }\n"
