name: HumanEval_57_monotonic
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return true is list elements are monotonically increasing or decreasing.\n\
  \    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))\n\
  \    // (true)\n    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong,\
  \ 10l.toLong)))\n    // (false)\n    // >>> monotonic((List[Long](4l.toLong, 1l.toLong,\
  \ 0l.toLong, -10l.toLong)))\n    // (true)\n    def monotonic(l : List[Long]) :\
  \ Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 10l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 20l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 20l.toLong, 4l.toLong, 10l.toLong))) == (false));\n    assert(monotonic((List[Long](4l.toLong,\
  \ 1l.toLong, 0l.toLong, -10l.toLong))) == (true));\n    assert(monotonic((List[Long](4l.toLong,\
  \ 1l.toLong, 1l.toLong, 0l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));\n    assert(monotonic((List[Long](9l.toLong,\
  \ 9l.toLong, 9l.toLong, 9l.toLong))) == (true));\n    }\n\n}\n"
completions: ["        if (l.length == 0) true\n        else {\n            var high\
    \ = l.head\n            var low = l.head\n            var found = false\n    \
    \        for (var i = 1 until l.length) {\n                if (l(i) > high) high\
    \ = l(i)\n                else if (l(i) < low) low = l(i)\n                else\
    \ found = true\n            }\n            found\n        }", "        val s =\
    \ l.foldLeft(0)(_ + _)\n        s == l.length", "        var result = true\n \
    \       var last = 0\n        for (i <- l.length) {\n            if (i < 1 ||\
    \ i > l.length - 1) continue\n            if (last < 0 || l(i) < last) result\
    \ = false\n            last = l(i)\n        }\n        return result", "     \
    \   if (l.isEmpty) true\n        else monotonicRec(l, l.head.toLong)", "     \
    \   var prev = l(0).toLong\n        var next = (0 to (l.length - 1)).foldLeft(prev)(_\
    \ + _)\n        while (next < l.length) {\n            val current = l((next +\
    \ 0).toLong)\n            if (current < prev) {\n                return false\n\
    \            } else if (current > prev) {\n                return true\n     \
    \       } else {\n                prev = current\n                next = (next\
    \ + 1).toInt\n            }\n        }\n        return false", "        val max\
    \ = l.max\n        val min  = l.min\n        val max = math.max(max, min)\n  \
    \      val min = math.min(max, min)\n        min <= max && l.forall(l => l <=\
    \ max)", "        l.toSet diff List(l.min) diff List(l.max) forall {\n       \
    \     case x :: _ => x != l.min && x != l.max\n        }", "        val newL =\
    \ new mutable.ListBuffer[Long]()\n        for (i<-0 until l.length) {\n      \
    \      if (l(i) > l(i + 1)) {\n                new mutable.ListBuffer[Long]()\n\
    \            } else {\n                newL += l(i)\n            }\n        }\n\
    \        (newL.size == l.length)", "        var inc = false\n        var dec =\
    \ false\n        l.foreach(x => {\n            if (x < l.head + 1) {\n       \
    \         inc = true\n            } else if (x > l.head + 1) {\n             \
    \   dec = true\n            }\n        })\n        (inc || dec)", "        var\
    \ last = 0\n        for (i <- l.toList) {\n            if (i < last) {\n     \
    \           return false\n            }\n            last = i\n        }\n   \
    \     return true", "        val min = l.min\n        val max = l.max\n      \
    \  val range = (max - min) + 1\n        val reversed = (min - 1l) > max\n    \
    \    if (range == 1) true\n        else if (range == 0) true\n        else monotonic_rec(l,\
    \ min, max, reversed)", "        val m = l.head\n        val i = l.tail.indexOf(l.reverse.head)\
    \ // last index for current max element\n        if (i == -1) false\n        else\
    \ (m - l.tail.head) <= l(i) <= (m - l.tail.head)", "        var a = l.head\n \
    \       var b = l.tail.head\n        val n = l.size\n        for (x <- 1 to n)\
    \ {\n            if (a < x && b <= x) {\n                return false\n      \
    \      }\n            else if (a <= x && b > x) {\n                return true\n\
    \            }\n            a = x\n            b = l.tail.tail.head\n        }\n\
    \        false", "        val set = l.toSet\n        val firstSet = l.reverse.tail.toSet\n\
    \        val secondSet = l.reverse.reverse.tail.toSet\n        set.intersect(firstSet).forall(_.toLong\
    \ >= l(0).toLong) && set.intersect(secondSet).forall(_.toLong <= l.last.toLong)",
  "        def monotonic(l : List[Long], current : Long) : Boolean = {\n         \
    \   if (l.isEmpty)\n                true\n            else if (current < l.head)\n\
    \                monotonic(l.tail, current)\n            else\n              \
    \  monotonic(l.tail, l.head)\n        }\n        monotonic(l, 0l)", "        if(l.head\
    \ < l.last) true\n        else if(l.head > l.last) false\n        else {\n   \
    \         val mid = l / 2\n            val left  = monotonic(l.filter(_ < mid))\n\
    \            val right = monotonic(l.filter(_ > mid))\n            if(left &&\
    \ right) true\n            else if(left && !right) true\n            else false\n\
    \        }", "        if (l.isEmpty) true\n        else {\n            // Compare\
    \ the first element\n            var minVal = l.head\n            var minIdx =\
    \ 0\n            var firstChange = true\n\n            // Check if the list is\
    \ monotonically increasing\n            for (i<-l.length-1) {\n              \
    \  if (l(i) > l(i+1)) {\n                    firstChange = false\n           \
    \     }\n                if (firstChange) {\n                    if (l(i) < minVal)\
    \ minVal = l(i)\n                    minIdx = i\n                }\n         \
    \   }\n            // If list is monotonically increasing then all elements are\
    \ increasing except the minimum.\n            if (minIdx > 0) return true\n\n\
    \            // Check if the list is monotonically decreasing\n            for\
    \ (i<-l.length-1) {\n                if (l(i) < l(i+1)) {\n                  \
    \  firstChange = false\n                }\n                if (firstChange) {\n\
    \                    if (l(i) > minVal) minVal = l(i)\n                    minIdx\
    \ = i\n                }\n            }\n            // If list is monotonically\
    \ decreasing then all elements are decreasing except the minimum.\n          \
    \  if (minIdx > 0) return false\n\n            // If both are false then return\
    \ true\n            return true\n        }", "        if(l.isEmpty) true\n   \
    \     else {\n            val sortedList = l.sorted\n            val firstElement\
    \ = sortedList(1)\n            if(firstElement < sortedList(0) || firstElement\
    \ > sortedList(sortedList.size - 1) || firstElement < sortedList(sortedList.size\
    \ - 2)) {\n                true\n            } else {\n                monotonic(l.tail)\n\
    \            }\n        }", "        // Solution\n        l.reverse.foldRight(true)(_\
    \ >= _)", "        if(l.isEmpty) {\n            true\n        } else {\n     \
    \       var xs = l.tail\n            var x = 0l\n            var y = 0l\n    \
    \        while(xs.nonEmpty) {\n                x += 1\n                y = xs.head\n\
    \                if(y > x) {\n                    return false\n             \
    \   }\n                xs = xs.tail\n            }\n            true\n       \
    \ }", "        val x = l.head\n        val ys = l.tail\n        if (ys.isEmpty)\
    \ {\n            true\n        } else {\n            if (x == ys.head) {\n   \
    \             monotonic(ys)\n            } else {\n                monotonic(ys.tail)\n\
    \            }\n        }", "        val sortedList = l.sorted\n        val isIncreasing\
    \ = sortedList.head < sortedList.last\n        isIncreasing", '        l.zipWithIndex.maxBy(_._1)._2
    < l.zipWithIndex.minBy(_._1)._1', "        val h1 = l.head\n        val h2 = l.tail.head\n\
    \        val i = 2\n        while (i < l.length) {\n            if (l(i-1) > h2\
    \ && l(i-1) < h1) return false\n            if (l(i-1) == h1 && l(i-2) > h2) return\
    \ false\n            i += 1\n        }\n        true", "        l.tail.zipWithIndex.foldLeft((false,\
    \ (0l, -1l))) { \n            case (done, (cur, i)) =>\n                if (i\
    \ == l.length) done else if (!done.v && cur > done.v) done.v = (cur, i) else done\n\
    \        }._1", "        val a = l.sorted\n        a.head < a.last || a.head ==\
    \ a.last && a.head > 0", "        val sortedL= l.sorted\n        val head= sortedL.head\n\
    \        val last= sortedL.last\n        (sortedL.head < head) &&\n          \
    \  (sortedL.last > last)", '        l.length == 1 || l.length == 2 || l.length
    == 3 || l.length == 4 || l.length == 5 || l.length == 6 || l.length == 7 || l.length
    == 8 || l.length == 9 || l.length == 10 || l.length == 11 || l.length == 12 ||
    l.length == 13 || l.length == 14 || l.length == 15', "        var prev : Long\
    \ = Long.MaxValue\n        var flag : Boolean = true\n        var i = l.length\n\
    \n        while(i-- != 0)\n        {\n            if(prev < l(i))\n          \
    \  {\n                prev = l(i)\n                flag = false\n            }\n\
    \        }\n\n        if(flag)\n        {\n            true\n        }\n     \
    \   else\n        {\n            false\n        }", "        val d = l.sorted\n\
    \        val p = d.head\n        val q = d.last\n        val qp = d.init\n   \
    \     val pq = d.tail\n        (pq == Seq.empty || pq ++ Seq(p.toLong) < qp) &&\
    \ (pq == Seq.empty || pq ++ Seq(p.toLong) > qp)", "        l.foldLeft(true)((prev,\
    \ cur) =>\n            prev && (cur.lt(prev) || cur.gt(prev)) )", "        val\
    \ length = l.length\n        val head = 0\n        val tail = length - 1\n   \
    \     var isIncreasing = false\n        var isDecreasing = false\n        // traverse\
    \ the list from the head to tail\n        for (i <- 0 until tail) {\n        \
    \    val current = l(i)\n            // if current is greater than head\n    \
    \        if (current > head) {\n                // check if the next value is\
    \ lesser than current or not\n                if (l(i+1) > current) {\n      \
    \              isIncreasing = true\n                } else {\n               \
    \     isDecreasing = true\n                }\n            }\n        }\n     \
    \   (isIncreasing || isDecreasing)", "        val lv = l.toSeq\n        var i\
    \ : Int = lv.length - 1\n        while (i >= 0) {\n            if (lv(i) < lv(i+1))\
    \ \n                i = i - 1\n            else \n                return false\n\
    \        }\n        return true", "        if (l.isEmpty) true\n        else {\n\
    \            // first element\n            var first = 0\n            var last\
    \ = 0\n            var count = 0\n            // get last element\n          \
    \  last = l.head\n            // get first element\n            first = l.tail.head\n\
    \            // calculate difference\n            count = last - first\n     \
    \       // count is either 1 or -1\n            if (count > 0) monotonic_recursive(l,\
    \ first, last, count) else monotonic_recursive(l, last, first, count)\n      \
    \  }", "        def monotonicHelper(l : List[Long], max: Long) : Boolean = {\n\
    \            l match {\n                case Nil => true\n                case\
    \ x::xs => monotonicHelper(xs, max) && isIncreasing(x, max)\n            }\n \
    \       }\n        monotonicHelper(l, 0l.toLong)", "        var minVal =  l.head\
    \ ;\n        var maxVal =  l.last ;\n        var incr = true  ;\n        var decr\
    \ = true  ;\n        var i = 1 // increment from start\n        var j = l.size\
    \ - 1\n        var k = 1 // decrement from end\n        while(i < j)\n       \
    \ {\n            if (l(i) < minVal)\n            {\n                minVal = l(i)\n\
    \                incr = false\n            }\n            if (l(i) > maxVal)\n\
    \            {\n                maxVal = l(i)\n                decr = false\n\
    \            }\n            i = i + 1\n            j = j - 1\n        }\n    \
    \    if (incr && decr)\n        {\n            true\n        }\n        else\n\
    \        {\n            monotonic(l)\n        }", "        if(l == null || l.isEmpty)\
    \ true\n        else if(l.head < l.last) true\n        else false", "        val\
    \ x = l.head\n        if (l.size <= 1) false\n        else {\n            val\
    \ y = l.tail.head\n            x < y || (x == y && monotonic(l.tail.tail))\n \
    \       }", "        val r = scala.collection.mutable.ListBuffer[Long]()\n   \
    \     val l = scala.collection.mutable.ListBuffer[Long]()\n        var i = l.head\n\
    \        while (i < l.last) {\n            l.append(i)\n            i = l.last\n\
    \        }\n        l.foreach {\n            i => r += (i -> i)\n        }\n \
    \       l.foreach {\n            i =>\n                if (i < r.last) {\n   \
    \                 val j = (i + r.last) / 2\n                    val s = r.last\n\
    \                    val e = r.last\n                    val m = r.last\n    \
    \                val x = r.last\n                    r.clear()\n             \
    \       r += (i -> j)\n                    r += (j -> s)\n                   \
    \ r += (s -> e)\n                    r += (e-> m)\n                    r += (m\
    \ -> x)\n                    r += (x -> j)\n                }\n        }\n   \
    \     r.last.isDefined", "        val i = l.indexOf(0l)\n        if (i == 0) true\n\
    \        else {\n            val j = (i+1)%l.length\n            if (l.diff(j,\
    \ l.length).forall(x => x <= 0) || l.diff(j, l.length).forall(x => x >= 0)) false\n\
    \            else monotonic(l.drop(i+1))\n        }", "        val nums = l.toArray\n\
    \        val n1 = nums.head + nums.last\n        val n2 = nums(2) - 1\n      \
    \  val n3 = nums(3) - 1\n        (n1 > n2 && n1 < n3) || n2 > n3", "        val\
    \ s = l.head\n        val e = (l.tail map (_ - s)) min l.head\n        if (e ==\
    \ s) true\n        else false", "        var increasing = true\n        var last\
    \ = 0\n        for(x <- l.reverse) {\n            last = x\n            if(x <\
    \ last) {\n                increasing = false\n                break\n       \
    \     }\n        }\n        if(increasing) {\n            true\n        } else\
    \ {\n            last = -l.reverse\n            for(x <- l.reverse) {\n      \
    \          if(x == last) {\n                    increasing = false\n         \
    \           break\n                }\n            }\n        }\n        increasing",
  "        if (l.isEmpty) true\n        else if (l.head > l.last) true\n        else\
    \ if (!l.exists(_ > l.last)) true\n        else false", "        val low = l.head\n\
    \        val high = l.last\n        low < high", '        l.tail.sorted.reverse
    <= l.head + l.takeWhile(_.isDefined).sum', "        var incr = l.head\n      \
    \  val x = l.tail.foldLeft(incr)((x, y) => x + (if (x < y) else y))\n        (x\
    \ == incr) || (x == 0)", "        val s = l.sorted\n        (0 until l.length).forall\
    \ { i =>\n            val j = i + 1\n            val k = j + 1\n            val\
    \ l = j - 1\n            if (s(i) > s(j) && s(i) > s(k) && s(j) > s(l))\n    \
    \            true\n            else\n                false\n        }", "    \
    \    val sortedList = l.sorted\n        val nextVal = sortedList(sortedList.size\
    \ - 1).toLong\n        val currentVal = sortedList(1).toLong\n        val isIncreasingOrDecreasing\
    \ = nextVal > currentVal\n        return isIncreasingOrDecreasing", "        l.sorted.tail.isEmpty\
    \ ||\n            l.head < l.last  ||\n            l.head > l.last.successor",
  "        if(l == Nil) true\n        else {\n            def comp(a : Long, b : Long)\
    \ : Boolean = {\n                if( a < b) true\n                elseif( a >\
    \ b) false\n                else\n                    comp(a,b) //recursion\n\
    \            }\n            var index = 0\n            val rev = l.tail.reverse\n\
    \            val n = l.length\n            val mrev = rev(0)\n            val\
    \ mn = rev(n-1)\n            for(index <- 0 until n-1){\n                if( comp(\
    \ rev((n-1-index-1)), mrev ) ) index -=1\n                if( comp( mn, rev( index\
    \ ) ) ) index+=1\n            }\n            if( index == 0 ) true\n         \
    \   else false\n        }", "        val l2 = l.toList.sort\n        l2.head <\
    \ l2(0) && l2(0) < l2(1) && l2(1) < l2(2) && l2(2) < l2(3)", "        val nums\
    \ = l.toList\n        var lastNum = nums.head\n        var lastMin = lastNum\n\
    \        var lastMax = lastNum\n        var i = nums.length\n        while (i--\
    \ > 0) {\n            var num = nums.apply(i)\n            if (num < lastNum)\
    \ {\n                return false\n            } else if (num > lastNum) {\n \
    \               return true\n            } else {\n                if (num < lastMin)\
    \ {\n                    lastMin = num\n                } else {\n           \
    \         if (num > lastMax) {\n                        lastMax = num\n      \
    \              }\n                }\n            }\n        }\n        return\
    \ lastMin < lastMax", "        l match {\n            case h :: t if h < t._1\
    \ =>\n                monotonic(l)\n            case h :: t if h > t._1 =>\n \
    \               monotonic(l)\n            case h :: t =>\n                monotonic(l\
    \ :: t)\n            case _ =>\n                true\n        }", "        val\
    \ sorted = l.sortWith(_ > _)\n        sorted < sorted.tail", "        var previous\
    \ = -1l\n        var current : Long = 0l\n        for (x <- l) {\n           \
    \ if (x > previous) {\n                return false\n            }\n         \
    \   previous = current\n            current += x\n        }\n        true", " \
    \       val max = l.foldLeft(0L){ (max, el) =>\n            if (max > el) max\
    \ else el\n        }\n        val min = l.foldLeft((0L, l.head)){ case ((max,\
    \ min), el) =>\n            if (max < el) el -> (min, max)\n            else max\
    \ -> (min , el)\n        }._2\n        max > min", "        val l1 = new mutable.ListBuffer[Long]()\n\
    \        val l2 = new mutable.ListBuffer[Long]()\n        for(i <- 0 until l.length-1)\n\
    \        {\n            l1 += l(i)\n            l2 += l(i+1)\n        }\n    \
    \    l1.lastOption < l2.lastOption", "        def helper(l: List[Long], max: Long,\
    \ count: Long)\n            : (Boolean, Long, Long) = {\n            val result\
    \ = l.tail.isEmpty\n            if (result) (1, max, count) else {\n         \
    \       val cur = l.head\n                val n = l.size\n                val\
    \ prev = (max < cur) && (count == 0)\n                (result, cur, count)\n \
    \           }\n        }\n        helper(l, 0l, 1l)", "        if (l.isEmpty)\
    \ return true\n        var curr = head(l) \n        var curr = head(l) \n    \
    \    var end = last(l) \n        for( n <- tail(l){ \n            if (curr < n)\
    \ curr = n\n            else if (curr > n) curr = n\n            else if (curr\
    \ == n) curr = n\n            else return false\n        }\n        return true",
  "        if (l.isEmpty) true\n        else {\n            val head  = l.head\n \
    \           val tail  = l.tail\n            val mid   = tail.take(1).head\n  \
    \          val first = (head < mid) //(head < mid) ?? (head.compare(mid) < 0)\n\
    \            val last  = (tail.last < mid) //(tail.last < mid) ?? (mid.compare(tail.last)\
    \ < 0)\n            last && first\n        }", "        val m = l.head\n     \
    \   val last = l.tail.last\n        val first = isMonotonic(l.tail.dropRight(1))\n\
    \        // If the list doesn't contain monotonically increasing or decreasing\
    \ elements\n        if (first || last) false else isMonotonic(l.tail)", "    \
    \    val minMaxMap = new mutable.TreeMap[Long, Long]()\n        for (e <- l)\n\
    \            if (!minMaxMap.containsKey(e))\n                minMaxMap.put(e,\
    \ e)\n            else if (!minMaxMap(e) < e)\n                minMaxMap.put(e,\
    \ e)\n            else minMaxMap.remove(e)\n        minMaxMap.values.toList.forall(e\
    \ => e > 0 && e < l.max)", "        if (l.isEmpty) return true\n        if (l.head\
    \ <= l.tail.head) return false\n        l.head < l.tail.head && monotonic(l.tail)",
  "        if (l.isEmpty) true\n        else { \n            val l = l.tail\n    \
    \        val firstInt = l.head\n            val lastInt = l.last\n           \
    \ val l = l.drop(1)\n            if (l.isEmpty) false\n            else if (firstInt\
    \ < lastInt) monotonic(l)\n            else if (firstInt == lastInt) monotonic(l)\n\
    \            else { monotonic(l.init) }\n        }", "        val l = l.toSet\n\
    \        var i = 0\n        while(i < l.size){\n            if(!l.contains(i)\
    \ || l.contains(i+1) || l.contains(i-1))\n                return false\n     \
    \       i += 1\n        }\n        true", "        var low = l.head\n        var\
    \ high = l.head\n        var isIncreasing = true\n        l.tail.foreach{ elem\
    \ =>\n            if (elem < low) {\n                low = elem\n            }\
    \ else if (elem > high) {\n                high = elem\n            } else if\
    \ (elem < low && elem > high) {\n                isIncreasing = false\n      \
    \      }\n        }\n        return isIncreasing", "        // Use map to create\
    \ a list with the original element removed\n        val reversedList = l.map(e\
    \ => (e, true)).map{ case (e, inc) => e }.sortWith(_._1 < _._1).reverse\n    \
    \    val current = l.head\n        // Compare and see if anything changes after\
    \ that point\n        val changed = reversedList.zip(l drop 1).foreach { case\
    \ (e, inc) =>\n            if ((e.head < current) && inc)\n                current\
    \ = e.head\n            else if ((e.head > current) && !inc)\n               \
    \ current = e.head\n        }\n        changed", "        var inc = false\n  \
    \      var decreasing = false\n        var x = 0\n        var i = 0\n\n      \
    \  // Handle empty list\n        if(l.isEmpty)\n            return true\n\n  \
    \      // Handle degenerate case\n        if(l.head <= l.last)\n            return\
    \ false\n\n        // Iterate in reverse order\n        while(i < l.length) {\n\
    \            if(i == 0)\n                x = l.head\n            else\n      \
    \          x = l.apply(i-1)\n\n            // Handle increment case\n        \
    \    if(inc)\n                decreasing = x.toLong < x.toLong + x.toLong\n  \
    \          else if(!decreasing && x.toLong >= x.toLong + x.toLong)\n         \
    \       inc = true\n\n            // Handle decrease case\n            if(!inc)\
    \ {\n                decreasing = x.toLong <= x.toLong + x.toLong\n          \
    \  }\n\n            i += 1\n        }\n\n        inc", "        var i = 1 \n \
    \       var found = false\n        var prev = l head \n        while (i < l.length\
    \ && (found || prev < l head )) {\n            if (found && prev < l head ) {\n\
    \                return false\n            }\n            prev = l head \n   \
    \         i += 1\n        }\n        return true", "        val it = l.iterator\n\
    \        if (it.hasNext) {\n            val cur = it.next()\n            if (it.hasNext)\
    \ {\n                if (cur > it.next()) {\n                    false\n     \
    \           }\n            }\n            if (cur < it.next()) {\n           \
    \     true\n            }\n        }\n        false", "        var i : Long =\
    \ l.head\n        var j : Long = l.tail.head\n        while (i < j) {\n      \
    \      if (j - i == 1)\n                return true\n            else if (j -\
    \ i < 0)\n                return false\n            else if (l.tail.exists(l =>\
    \ l.head < i))\n                return false\n            else\n             \
    \   i += 1\n        }\n        return true", "        val reverse = l.reverse\n\
    \        val low = reverse.head\n        val high = reverse.last\n        low\
    \ <= high && l.forall(i => reverse.indexOf(i) > 0)", "        val l = l.reverse\n\
    \        val l1 = l.drop(1).zipWithIndex\n        val l2 = l.dropRight(1).zipWithIndex\n\
    \        val l3 = l.take(1).zipWithIndex\n        val l4 = l.takeRight(1).zipWithIndex\n\
    \        l1.forall{case (_,i) =>\n            l2.take(i).getOrElse(l4).getOrElse(l.size\
    \ - 1) == l1(i).get\n        }", "        import scala.math.Ordering\n       \
    \ val sorted = l.sorted\n        val low = sorted.head\n        val high = sorted.last\n\
    \        val ordering = Ordering[Long]\n        val cmp = {\n            x =>\
    \ (x < low) ? ordering.LessThan(x) : ordering.GreaterThan(x)\n        }\n    \
    \    low < high && sorted.map(cmp).forall(_.isOrdered)", "        val newL = l\
    \ sortBy (_ > _) reverse\n        (newL.head < newL.last) == (l.head < l.last)",
  "        val i = l.dropRight(1).zipWithIndex.maxBy { case ((_, i), j) => j }\n \
    \       (i > 0) || (l.head > i)", "        if (l.isEmpty) true\n        else {\n\
    \            val lastVal = l.last\n            var isIncreasing = true\n     \
    \       val minVal =  l.head\n            var tempVal = lastVal\n            l.foreach\
    \ { elem =>\n                if (elem < minVal) {\n                    tempVal\
    \ = minVal\n                }\n                if (elem > lastVal && elem < tempVal)\
    \ {\n                    isIncreasing = false\n                }\n           \
    \     tempVal = elem\n            }\n            if (isIncreasing) {\n       \
    \         return true\n            } else {\n                return false\n  \
    \          }\n        }", "        var min = l(0)\n        var max = l(0)\n  \
    \      l.foreach {\n            case x =>\n                if (x < min) min =\
    \ x\n                if (x > max) max = x\n        }\n        if (min > max) return\
    \ false\n        l.foreach {\n            case x =>\n                if (x < min\
    \ - 1) return false\n                if (x > max - 1) return false\n        }\n\
    \        return true", "        // Sort list before comparing elements to determine\
    \ monotonicity of list.\n        l.sort\n        l.length == 0 || l.head < l.last\
    \ || l.head == l.last || monotonic_rec(l, 1)", "        val size = l.length\n\
    \        if(size == 0) return true\n\n        var flag = false\n        var i\
    \ : Int = 0\n        while(i < size) {\n            var j = i + 1\n          \
    \  while(j < size) {\n                if(l(i) > l(j) && i != j) {\n          \
    \          flag = true\n                    return true\n                } else\
    \ if(l(i) < l(j) && i != j) {\n                    flag = true\n             \
    \       return true\n                } else if(l(i) == l(j)) {\n             \
    \       i += 1\n                    j += 1\n                } else {\n       \
    \             i -= 1\n                    j += 1\n                }\n        \
    \    }\n            i += 1\n        }\n        return flag", "        def isGreaterThanOrEqual(l1\
    \ : List[Long], l2 : List[Long]) : Boolean = {\n            val l1 = l1(0)\n \
    \           val l2 = l2(0)\n            val isGreater = l1 > l2\n            val\
    \ l3 = new ArrayList[Long]\n            val l = l3\n            for (i <- 0 until\
    \ l1.length) {\n                if (l3(i) != l3(i-1)) l(l3(i) = l1(i))\n     \
    \       }\n            for (i <- 0 until l2.length) {\n                if (l3(i)\
    \ != l3(i-1)) l(l3(i) = l2(i))\n            }\n            l == l3\n        }\n\
    \        def isLessThanOrEqual(l1 : List[Long], l2 : List[Long]) : Boolean = {\n\
    \            val l1 = l1(0)\n            val l2 = l2(0)\n            val isLess\
    \ = l1 < l2\n            val l3 = new ArrayList[Long]\n            val l = l3\n\
    \            for (i <- 0 until l1.length) {\n                if (l3(i) != l3(i-1))\
    \ l(l3(i) = l1(i))\n            }\n            for (i <- 0 until l2.length) {\n\
    \                if (l3(i) != l3(i-1)) l(l3(i) = l2(i))\n            }\n     \
    \       l == l3\n        }\n        if (isGreaterThanOrEqual(l, List.empty))\n\
    \            isGreaterThanOrEqual(l.tail, l)\n        else if (isLessThanOrEqual(l.tail,\
    \ List.empty))\n            isLessThanOrEqual(l, l.tail)\n        else true",
  "        val l = l.toArray\n        val isMonotonic = l.sorted.zip(l.tail).forall(x\
    \ => x._1 == x._2)\n        isMonotonic", "        val min = l.min\n        val\
    \ max = l.max\n        val minI = l.indexOf(min)\n        val maxI = l.indexOf(max)\n\
    \        // Check if min and max are in same bucket.\n        if(minI == maxI)\
    \ {\n            // If both are in same bucket then check whether they are increasing\
    \ or decreasing.\n            val minValue = l.take(minI)\n            val maxValue\
    \ = l.take(maxI)\n            if(maxValue.toLong < minValue.toLong) {\n      \
    \          true\n            } else {\n                false\n            }\n\
    \        } else {\n            // Not in the same bucket.\n            val prevBucket\
    \ = l.take(minI)\n            val curBucket = l.take(maxI)\n            monotonicBucket(prevBucket,\
    \ curBucket)\n        }", "        val min = l.head\n        var l = l.tail\n\
    \        while(l.nonEmpty) {\n            var flag = true\n            for (i\
    \ <- 0 until l.length) if (l(i) < min) {\n                flag = false\n     \
    \           break\n            }\n            if (flag) min = l.head\n       \
    \     else l = l.tail\n        }\n        true", "        val it = l.iterator\n\
    \        var current = it.next()\n        var next = it.next()\n        while(it.hasNext)\
    \ {\n            current = next\n            next = it.next()\n            if(!current.equals(next))\
    \ return false\n        }\n        true", "        if (l.isEmpty) true\n     \
    \   else l.head < l.last && monotonic(l.tail)", "        if (l.isEmpty) true\n\
    \        else l.head < l.last && monotonic(l.tail)", "        val size = l.size\n\
    \        if (size <= 0) false\n        else {\n            val m = l.min\n   \
    \         val x = l.max\n            val xs = l.filter(x => x < m).map(x => m\
    \ - x).toList\n            val ys = l.filter(x => x > m).map(x => x - m).toList\n\
    \            if (xs.head < ys.head) true\n            else if (xs.head > ys.head)\
    \ false\n            else if (xs.head == ys.head && xs.last < ys.last) true\n\
    \            else monotonic(xs.tail) && monotonic(ys.tail)\n        }", "    \
    \    var result = true\n        val indexMap = mutable.Map[Long, Int]()\n    \
    \    for (i <- 0 until l.length) {\n            val value = l(i)\n           \
    \ if (!indexMap.contains(value)) {\n                indexMap += value -> 1\n \
    \           } else {\n                val count = indexMap(value)\n          \
    \      val index = indexMap.get(value + (count - 1))\n                if (index\
    \ != value) result = false\n            }\n        }\n        result", "     \
    \   val m = l.tail\n        val n = l.head\n        // A tricky way to check for\
    \ monotonicity \n        // Since a sorted list has a monotonic property with\
    \ regards to the \n        // order of its elements:\n        // >>> sorted((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).head\n        // res0: Long =\
    \ -5\n        // >>> sorted((List[Long](4l.toLong, 1l.toLong, 0l.toLong, 3l.toLong,\
    \ 2l.toLong))).head\n        // res1: Long = -3\n        // >>> sorted((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).head\n        // res2: Long =\
    \ -1\n        val sdiff = (m zip m).filter(x => !(n == x._2))\n        val ndiff\
    \ = (m zip m).filter(x => !(x == x._2))\n        (sdiff diff ndiff).length ==\
    \ 0 || sdiff diff ndiff.length == 1", "        var prev = 0l.toLong\n        var\
    \ hasChange = false\n        for (x <- l) {\n            val cur = x\n       \
    \     if (cur < prev) {\n                hasChange = true\n            }\n   \
    \         prev = cur\n        }\n        hasChange", '        l.nonEmpty && l.forall(n
    => l.head < n) && l.forall(n => n < l.last)', "        val list = l.toList\n \
    \       if (list.isEmpty)\n            true\n        else if (list.head < list.last)\n\
    \            monotonic(list.tail)\n        else if (list.head > list.last)\n \
    \           monotonic(list.init)\n        else\n            false", "        for\
    \ (i <- 0 until l.length-1) yield {\n            var x0 = l(i)\n            var\
    \ x1 = l(i+1)\n            var x2 = l(i+2)\n            var x3 = l(i+3)\n    \
    \        if ((x0<x1) || (x0==x1 && x0 < x2)) x0 = x1\n            if ((x0 < x1)\
    \ || (x0==x1 && x0 < x2)) x0 = x2\n            if ((x0<x1) || (x0==x1 && x0 <\
    \ x2)) x0 = x3\n            if ((x0 < x1) || (x0==x1 && x0 < x2)) x0 = x1\n  \
    \          if ((x0 < x1) || (x0==x1 && x0 < x2)) x0 = x2\n            if ((x0<x1)\
    \ || (x0==x1 && x0 < x2)) x0 = x3\n            if (x0==x1) true\n            else\
    \ if (x0==x2) false\n            else if (x0==x3) false\n            else false\n\
    \        }", "        val mn = l.head\n        l.tail.forall((x) => x > mn)",
  "        if (l.isEmpty) true\n        else if (l.last < l.head) false\n        else\
    \ l.zipWithIndex.all{case (x,i) => x < l.drop(i+1).last}", "        // Initialize\
    \ min and max as first elements\n        var min = l.head\n        var max = l.head\n\
    \n        // Loop through the rest of the elements\n        for (i <- l.tail)\
    \ {\n            // If current element is less than min and greater than max,\
    \ update min and max\n            if (i <= max && i >= min) {\n              \
    \  // Update min and max to current element\n                min = i\n       \
    \         max = i\n            } else {\n                // If current element\
    \ is smaller than min and greater than max, return false\n                return\
    \ false\n            }\n        }\n\n        // If min and max are equal, return\
    \ true\n        return true", "        val min = math.min(l)\n        val max\
    \ = math.max(l)\n        l.forall(i => math.abs(i-min) < math.abs(i-max))", " \
    \       val startValue = l.head\n        val startIndex = l.indexOf(startValue)\n\
    \        val isIncreasing = true\n        var currentIndex = startIndex + 1\n\
    \        while (currentIndex < l.length && isIncreasing) {\n            val currentValue\
    \ = l.lift(currentIndex)\n            val currentIndexAfterCurrentValue = l.indexOf(currentValue)\n\
    \            isIncreasing = currentIndexAfterCurrentValue > currentIndex\n   \
    \         currentIndex = currentIndexAfterCurrentValue + 1\n        }\n      \
    \  isIncreasing", "        var prev = Long.MinValue\n        var flag = false\n\
    \        for(i <- 0 until l.length) {\n            val currentElement = l(i)\n\
    \            if (flag) {\n                if (currentElement > prev) {\n     \
    \               return true\n                }\n            }\n            else\
    \ {\n                if (currentElement > prev) {\n                    flag =\
    \ true\n                }\n            }\n            prev = currentElement\n\
    \        }\n        false", "        val sorted = l.sorted\n        val last1\
    \ = sorted.last\n        val last2 = sorted.last\n        val first1 = sorted.head\n\
    \        val first2 = sorted.head\n\n        if(last1 === first2 && last2 ===\
    \ first1)\n            true\n        else\n            false", "        val first\
    \ = l(0)\n        val last = l(-1)\n        (first < last) || (l == Nil)", " \
    \       if (l.isEmpty) true\n        else if (l.head.toLong == l.tail.head.toLong)\
    \ monotonic(l.tail)\n        else if (l.head < l.tail.head) monotonic(l.tail)\n\
    \        else false", "        if (l.isEmpty) true\n        else (l.head < l.last)\
    \ && (monotonic(l.remove(1))) || monotonic(l)", "        // Check only list length\n\
    \        if (l.length == 0) return true\n        var previousVal = l.head\n  \
    \      val list = l.tail\n        for (i<-0 until list.length) {\n           \
    \ // Check previous element\n            if (Math.abs(list(i) - previousVal) >\
    \ 1) return false\n            previousVal = list(i)\n        }\n        true",
  "        val len = l.length\n        var incr = 1\n        var ret = 0\n       \
    \ for (i<-0 until len) {\n            val v = l(i)\n            if (incr < v)\
    \ {\n                incr = v\n                ret = i\n            }\n      \
    \  }\n        ret == len", "        val min = l.min\n        val max = l.max\n\
    \        val length = l.length\n        for( i <- 0 until length-1 ){\n      \
    \      if( l(i) > l(i+1) ){\n                return false\n            }\n   \
    \     }\n        for( i <- 0 until length-1 ){\n            if( l(i) < l(i+1)\
    \ ){\n                return false\n            }\n        }\n        if( l.head\
    \ < min || l.last > max ){\n            return false\n        }\n        return\
    \ true", "        val hi = l.head\n        val lo = l.last\n        lo > hi ||\
    \ l.forall(_ > hi)", "        var i = l.head - 1\n        if (i == -1) return\
    \ false\n        for (e <- l.tail) if (!(e < i)) return false\n        return\
    \ true", "        val l1 = l.tail\n        val l2 = l.head\n        l2.fold(l1.head)(l1.last)\
    \ <= l2.last", "        if (l.isEmpty) true\n        else if (l.head < l.last)\
    \ monotonic(l.tail) else monotonic(l.reverse)", "        // Initialize first value\
    \ as 0\n        var result = true\n        var firstVal = 0l\n\n        // For\
    \ each element in the list, check if the next one is greater than the current\
    \ one or not.\n        // If it's greater than the current one, then return false.\
    \ Otherwise, return true.\n        for (i <- 1 to l.length - 1) {\n          \
    \  // Use scala's compare method to check if the current element is greater than\
    \ the one on the next element\n            // If yes, return false. Otherwise,\
    \ return true.\n            // Scala documentation on compare:\n            //\
    \ http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#ordering-and-equality-relations-eq-and-lt\n\
    \            if (l(i) > l(i + 1)) {\n                result = false\n        \
    \        break\n            }\n        }\n        return result", "        val\
    \ sortedList = l.sorted\n        if (sortedList.length == 1) {\n            return\
    \ sortedList(0) == sortedList(1)\n        }\n        if (sortedList.length ==\
    \ 2) {\n            return sortedList(0) <= sortedList(1) && sortedList(1) >=\
    \ sortedList(0)\n        }\n        if (sortedList.length >= 3) {\n          \
    \  val min = sortedList.head\n            val max = sortedList.last\n        \
    \    return min <= max && min >= max && sortedList.tail.zip(sortedList.tail.tail).forall(a\
    \ => a >= min)\n        }\n        return true", "        val start = 1l\n   \
    \     val end = l.last\n\n        var i = 0\n\n        while (i < l.length) {\n\
    \            val m = l.min\n            val n = l.max\n\n            if (m < n)\
    \ i == l.length || monotonic((l.drop(i).reverse ++ l.take(i))) else i == l.length\
    \ || monotonic((l.drop(i).reverse ++ l.take(i) :: Nil))\n            i += 1\n\
    \        }\n\n        i == l.length", "       val l1 = l.head\n       val l2 =\
    \ l.tail.head\n       val length = l.length\n       val min = length * (length\
    \ + 1) / 2\n       if(l2 < l1){\n           l.foldLeft(true) { (res, x) => if\
    \ (x < l2) res && monotonic(List.fill(length)(x.toLong + 1)).fold(false) } else\
    \ res\n       } else if (l2 < min) {\n           l.foldLeft(true) { (res, x) =>\
    \ if (x < l2) res && monotonic(List.fill(length)(x.toLong + 1)).fold(false) }\
    \ else res\n       } else {\n           true\n       }", "        val l2 = l.toStream\n\
    \        val l3 = l2.map(x => (x + (-x)/2))\n        l3.takeWhile { x => x <=\
    \ 0l }.lastOption.isDefined", "        // The first element is the current \"\
    min\" element\n        var min = l.head\n        // The next element is the \"\
    min\" element + 1 of the following elements\n        var next = l.tail.drop(1).min\n\
    \n        // Return true if both min and next are in ascending order\n       \
    \ // Or if min is larger than next and min isn't in ascending order\n        (min\
    \ < next || min > next || min == next) && l.tail.head < l.head || {\n        \
    \    val last = l.tail.last\n            val cmp = last - min\n            cmp\
    \ >= 0 && cmp <= cmp.abs && cmp == cmp.signum || (cmp > 0 && cmp != cmp.abs &&\
    \ cmp == cmp.signum)\n        }", "        val l = l.toList\n        val l2 =\
    \ l.sortWith(_>_)\n        val l3 = l2.reverse\n        l3 == l", "        val\
    \ m = (0 until l.length).foldLeft(0L)((acc, i) => math.max(acc, l(i)))\n     \
    \   l == l.sortBy(i => math.abs(l(i) - m))", "        if (l.isEmpty) true\n  \
    \      else if (l.size == 1) true\n        else if (l.head < l.tail.head) monotonic(l.tail)\
    \ else monotonic(l.init::l.tail)", "        val nums = l.toList\n        val min\
    \ = l.head\n        val max = l.last\n        if(nums.isEmpty)\n            true\n\
    \        else {\n            if(nums.last < min)\n                return false\n\
    \            else if(nums.head > max)\n                return true\n         \
    \   else if(nums.head < min && nums.last > max)\n                return true\n\
    \            else\n                return monotonic(nums.tail)\n        }", " \
    \       val l = l.toList\n        val prev = l(0)\n        val cur = l(1)\n  \
    \      if (prev > cur) true\n        else {\n            if (prev < cur) false\n\
    \            else {\n                val n = l.length\n                val m =\
    \ n / 2\n                val i = 2\n                val res = mono(l, m, i, prev)\n\
    \                if (res == true) monotonic(l.drop(i+1))\n                else\
    \            monotonic(l.take(i+1))\n            }\n        }", "        if (l.isEmpty)\
    \ true\n        else {\n            var max: Long = l.head\n            var min:\
    \ Long = l.head\n\n            for (i<-l.tail; i!=null; i=i.tail) {\n        \
    \        if (i.toLong > max) max = i.toLong\n                else if (i.toLong\
    \ < min) min = i.toLong\n            }\n            min < max\n        }", " \
    \       val result = l(0)<=l(1)\n        l.zipWithIndex.foreach { e =>\n     \
    \       if (e._1<e._2) {\n                result = e._1<e._2\n            }\n\
    \        }\n        result", "      l.foldLeft((true, 0)){\n          case ((r1,\
    \ r2), x) =>\n            (x < r2) -> (r1, x)\n            (x >= r2) -> (r2, x)\n\
    \        }._1 == true", "        def isMonotonic(x : Long, y : Long) : Boolean\
    \ = {\n            if (y == 0) false\n            else (x % y) == 0 && isMonotonic(x,\
    \ y - 1)\n        }\n        l.forall(isMonotonic)", "        l match {\n    \
    \        case Nil => true\n            case h :: t =>\n                val h1\
    \ = h.asInstanceOf[Long]\n                val t1 = t.asInstanceOf[List[Long]]\n\
    \                val isIncreasing = h1 < t1(0)\n                val isDecreasing\
    \ = h1 > t1(-1)\n                isIncreasing || isDecreasing\n        }", " \
    \       val maxIndex : Int = l.lastOption.orElse(0)\n        var incr : Boolean\
    \ = false\n        var prev : Long = 0\n        for(i <- 0 until l.length) {\n\
    \            val curr = l(i)\n            val currIndex = i\n            if(currIndex\
    \ == 0) {\n                incr = true\n            } else if(currIndex > 0 &&\
    \ curr > prev) {\n                incr = false\n            }\n            prev\
    \ = curr\n        }\n        if(incr) {\n            return true\n        }\n\
    \        else {\n            return false\n        }", "        var i = l.head\n\
    \        var j = l.head\n        while (i < l.tail.head) {\n            if (l.tail.head\
    \ < j) {\n                return true\n            }\n            else {\n   \
    \             i = l.tail.head\n                j = l.tail.head\n            }\n\
    \        }\n        return false", "        val d = l.foldLeft[Option[Long]](Some(0l))\
    \ { (d, x) => if (x < d.get) Some(x) else d }\n        val d = l.foldLeft[Option[Long]](Some(0l))\
    \ { (d, x) => if (x > d.get) Some(x) else d }\n        d.getOrElse(false)", " \
    \       val maxVal = l.max\n        val minVal = l.min\n        if (maxVal ==\
    \ minVal) false\n        else if (maxVal > minVal) true\n        else monotonic(l.reverse)",
  "        def isMonotonic(c1 :Long, c2 : Long) : Boolean = {\n            val diff\
    \ = c2 - c1\n            if (diff < 0)\n                c1 > c2\n            else\n\
    \                c1 < c2\n        }\n        val min = l.head // first element\n\
    \        val max = l.last\n        val l1 = l.tail\n        val l2 = l.tail.tail\n\
    \        for (e <- l1) {\n            if (isMonotonic(e, min))\n             \
    \   return false\n        }\n        if (l1==l.tail)\n            return true\n\
    \        for (e <- l2) {\n            if (isMonotonic(max, e))\n             \
    \   return false\n        }\n        return true", "        val map = new mutable.LinkedHashMap[Long,\
    \ Long]()\n        l.foreach(elem => map.put(elem, map.getOrElse(elem, 0) + elem))\n\
    \        (map.size < map.values.toList.max)", "        if (l.isEmpty)\n      \
    \      true\n        else\n            l.tail.head <= l.head && monotonic(l.tail)",
  "        // Find first and last elements.\n        val (fi,la) = l.partition(_.isLessThan(0))\n\
    \        val (fs,ls) = la.partition(_.isLessThan(0))\n\n        // If list is\
    \ already monotonic\n        if( fi.isDefined && ls.isDefined ) {\n          \
    \  return true\n        }\n\n        // If list is monotonically increasing, return\
    \ true\n        if( fi.isDefined && fs.isDefined && fi.get < fs.get)\n       \
    \     return true\n\n        // If list is monotonically decreasing, return false\n\
    \        if( ls.isDefined && ls.get > la.get)\n            return false\n\n  \
    \      // If list is not monotonic\n        if( fi.isDefined || ls.isDefined)\
    \ {\n            return monotonic(la) || monotonic(fs) // Call recursively\n \
    \       }\n\n        // If list is not monotonic and there is only 1 element\n\
    \        false", "        var lastIndex = l.length - 1\n        while (lastIndex\
    \ >= 0) {\n            if (l(lastIndex) < l(lastIndex - 1)) {\n              \
    \  return false\n            }\n            lastIndex -= 1\n        }\n      \
    \  return true", "        val hb = l.foldLeft((\"\", false)) {\n            (h,\
    \ x) => if (x == h._1) (h._1 + \"x\", false) else (h._1, true)\n        }\n  \
    \      hb._2 || (l.tail.zip(l.tail.reverse).forall(x => x._1 > x._2))", "    \
    \    val l = l.sorted\n        val first = l.head\n        val last = l.last\n\
    \        l.forall(x => x > last)\n        l.forall(x => x < first)", "       \
    \ val n = l.length\n        l.forall{\n            case n if n < 2      => true\n\
    \            case n if n == 2 => true\n            case n if n == 1  => true\n\
    \            case n if n == 0 => false\n            case n if n > 0 => monotonic(l.drop(1))\n\
    \            case n if n < 0 => monotonic(l.take(-1)).or(monotonic(l.dropRight(1)))\n\
    \        }", "        val (min, max) = (l.min, l.max)\n        (min < max && min\
    \ != Long.MaxValue) || (max > min && max != Long.MinValue)", "        if (l.isEmpty)\n\
    \            true\n        else\n            val x = l.head\n            val y\
    \ = l.tail.head\n            val l1 = l.tail.tail\n            val l2 = l.tail.tail.tail\n\
    \n            val y1 = l.head\n            val y2 = l.tail.head\n            val\
    \ l12 = l.tail.tail\n            val l22 = l.tail.tail.tail\n\n            val\
    \ l121 = l12.tail.tail\n            val l122 = l12.tail.tail.tail\n\n        \
    \    val y21 = l12.head\n            val y22 = l12.tail.head\n\n            (x\
    \ == y) && (y1 == y2)\n                    && (l121 == l122)\n               \
    \     && (l22 == l21)\n                    && (x1 == x2)\n                   \
    \ && (l1 == l2)", "        val last = l.last\n        val curr = l.head\n\n  \
    \      l.tail.forall { e => if(e > curr) false; else curr = e }\n        l.head\
    \ < last", "        val x = l.head\n        val y = l.last\n        val xlow =\
    \ l.foldLeft((x, x)) {\n            case ((x1, x2), y1) => if (x1 < y1) ((x1,\
    \ x2), y1) else ((x2, x2), y2)\n        }\n        val xhigh = l.foldLeft((x,\
    \ x)) {\n            case ((x1, x2), y1) => if (x1 > y1) ((x1, x2), y1) else ((x2,\
    \ x2), y2)\n        }\n        (x > y || x < y && xhigh > xlow)", "        val\
    \ a = l.zipWithIndex\n        var inc = true\n        var max = a(l.length-1)\n\
    \        var min = a.head._1\n        for (elem <- a.tail) {\n            if (elem\
    \ > max) {\n                max = elem\n                inc = false\n        \
    \    }\n            if (elem < min) {\n                min = elem\n          \
    \      inc = false\n            }\n        }\n        if (inc) {\n           \
    \ true\n        } else {\n            false\n        }", "        val list = l.sortWith(x\
    \ => x.toLong < 0).toList\n        if(list.length < 2) true\n        else list.head\
    \ < list.last && monotonic(list.tail)", "        if (l.isEmpty)\n            true\n\
    \        else if (l.head < l.last)\n            monotonic(l.tail)\n        else\n\
    \            monotonic(l.init)", "        var min  = l(0)\n        var max  =\
    \ l(0)\n        for (x <- l)\n            if (x < min)\n                min =\
    \ x\n            if (x > max)\n                max = x\n        if (min >= max)\n\
    \            return true\n        else\n            return false", "        val\
    \ newlist = l.toList\n        var isDecreasing = true\n        var isIncreasing\
    \ = true\n        var previous : Long = Long.MaxValue\n        newlist.foreach\
    \ {\n            value =>\n                if (value <= previous) {\n        \
    \            isDecreasing = !isDecreasing\n                }\n               \
    \ else {\n                    isIncreasing = !isIncreasing\n                }\n\
    \                previous = value\n        }\n        isIncreasing || isDecreasing",
  "        def compare(i1: Long, i2: Long) : Boolean = {\n            if (i1 <= i2)\
    \ i1 < i2 else i2 < i1\n        }\n        val l = l.toList\n        if (l.isEmpty)\
    \ true else compare(l.headOption, l.tailOption)", "        l.nonEmpty &&\n   \
    \       l.head <= l.last &&\n          l.head >= l.reverse &&\n          monotonicRec(l,\
    \ l.head, l.last)", "        val d = l.diff\n        if (d.isEmpty)\n        \
    \    true\n        else {\n            val d0 = d.head\n            val d1 = d.tail.head\n\
    \            d0 <= d1\n        }", "        l.zipWithIndex.forall(x => {\n   \
    \             val x0 = x._2\n                if( (x0 != l.head) &&  (x0 <= l.last)){\n\
    \                    monotonic(l.tail)\n                } else {\n           \
    \         true\n                }\n            })", "        var flag : Boolean\
    \ = false\n        val max = l.tail\n        val min = l.head\n        for( i\
    \ <- 0 until l.length-1 ){\n            if( max(i) < min(i) ){\n             \
    \   flag = true\n            }\n        }\n        flag", '        l.take(l.size
    - 1).forall(x => x <= l(0))', "        val min = l.min\n        val max = l.max\n\
    \        l.foreach{e =>\n            if (e < min || e > max) println(\"list is\
    \ not monotonic: \" + e) \n        }\n        true", "        var i = 0\n    \
    \    for (x <- l) \n        { if (x > l(i+1))\n            i += 1 }\n        return\
    \ i == l.length-1", "        var x = l.head\n        var incr = true\n       \
    \ var incr = false\n        l.tail.foreach { y =>\n            if (incr && y >\
    \ x) {\n                incr = false\n            } else if (incr && !(y > x))\
    \ {\n                incr = true\n            } else {\n                return\
    \ false\n            }\n            x = y\n        }\n        return true", " \
    \       val s = l.foldLeft((true, 0l, 0l))((x, y) => (x._3 > y._3, x._2, y._2))\n\
    \        (s._2 >= s._3) && (s._2 <= s._1)", "        val sorted = l.sorted\n \
    \       val first = sorted.head\n        val last = sorted.last\n        if (last\
    \ < first)\n            true\n        else {\n            if (last == first)\n\
    \                false\n            else {\n                val index = l.indexOf(last)\n\
    \                if (index > 0)\n                    monotonic(l.take(index +\
    \ 1))\n                else\n                    true\n            }\n       \
    \ }", "        val m = l.head\n        l.tail.zipWithIndex.foreach { case (x,\
    \ i) => if (x <= m) m.get < x || monotonic(l.tail) }", "        l.zipWithIndex.forall\
    \ {\n            case (lv, i) =>\n                val lh = l.drop(i)\n       \
    \         lv.head < lh.head || lv.tail < lh.tail\n        }", "        // Initialize\
    \ our first element to true.\n        var isSorted = true\n        val first =\
    \ l.head\n        // Initialize our second element to false.\n        var isIncreasing\
    \ = false\n        var lastItem = first\n        val lastValue = lastItem\n  \
    \      for (item <- l.tail) {\n            // The item is greater than the last\
    \ item and this is not the first item\n            if (item > lastValue && !isSorted)\
    \ {\n                // We are NOT increasing\n                isSorted = false\n\
    \                isIncreasing = true\n            }\n            // The item is\
    \ less than the last item and this is not the first item\n            else if\
    \ (item < lastValue && !isSorted) {\n                // We are increasing\n  \
    \              isSorted = true\n                isIncreasing = true\n        \
    \    }\n            // The item is greater than the last item\n            else\
    \ if (item > lastValue) {\n                isSorted = false\n                isIncreasing\
    \ = true\n            }\n            // The item is less than the last item\n\
    \            else if (item < lastValue) {\n                isSorted = true\n \
    \               isIncreasing = true\n            }\n            // The item is\
    \ equal to the last item\n            else if (item == lastValue) {\n        \
    \        isSorted = true\n            }\n            // The item is less than\
    \ the last item and this is not the first item\n            else if (item < lastValue\
    \ && item != first) {\n                isSorted = false\n                isIncreasing\
    \ = true\n            }\n            // The item is greater than the last item\
    \ and this is not the first item\n            else if (item > lastValue && item\
    \ != first) {\n                isSorted = true\n                isIncreasing =\
    \ true\n            }\n        }\n        // Return the answer based on our two\
    \ values.\n        isIncreasing || isSorted", "        val maxIndex = l.length\
    \ -1\n        val maxValue = l(maxIndex)\n\n        val minIndex = l.indexWhere(_\
    \ < 0L)\n        val minValue = l(minIndex)\n\n        (minValue < 0L) || (maxValue\
    \ < 0L) || (minValue > maxValue)", "        val n1 = l.length\n        var j =\
    \ 0\n        var k = 1\n        while (j < n1 && k < n1){\n            val a =\
    \ l(k-1)\n            val b = l(j)\n            if (a > b) true\n            else\
    \ if (a < b) false\n            else j += k\n            k += 1\n        }\n \
    \       j == n1", "        val len = l.length\n        if (len == 0) {\n     \
    \       return true\n        }\n        if (len == 1) {\n            if (l(0)\
    \ > l(1)) {\n                return false\n            }\n        }\n        val\
    \ m = l.min\n        val n = l.max\n        if (m > n) {\n            monotonic(l.drop(1))\n\
    \        } else {\n            monotonic(l.take(l.length - 1))\n        }", " \
    \       val len = l.length\n        if (len < 1) false else {\n            var\
    \ i = 0\n            var x = l.head\n            var y = l.head\n            while\
    \ (i < len) {\n                if (x > y) false else {\n                    x\
    \ = y\n                    y = l.apply(i)\n                }\n               \
    \ i += 1\n            }\n            (x <=> y) match {\n                case -1\
    \ => true\n                case 1 => false\n                case 0 => true\n \
    \               case x => true\n            }\n        }", "        if (l.isEmpty)\
    \ {\n            return true\n        }\n        if (l.head > l.last) {\n    \
    \        return false\n        }\n        val i = 2\n        while (i < l.length\
    \ && l.head < l.last) {\n            i +=  1\n            if (l.head < l.last)\
    \ {\n                if (!(l.head == l.last)) {\n                    return false\n\
    \                }\n            }\n        }\n        i +=  1\n        if (l.head\
    \ == l.last) {\n            return true\n        }\n        return monotonic(l.tail,\
    \ i)", "        var i = 0\n        var prev = l(0)\n        var result = true\n\
    \        l.zip(l.tail).foreach {\n            case (element, next) if element\
    \ < prev => result = false\n            case (element, next) if element > prev\
    \ => result = false\n            case (element, next) if (element == prev && element\
    \ < next) => result = false\n            case (element, next) if (element == prev\
    \ && element > next) => result = false\n            prev = element\n        }\n\
    \        result", "        var lastVal = -1\n        val set = mutable.Set.empty[Long]\n\
    \        l.foreach { x =>\n            if ((lastVal == -1) || (x > lastVal)) {\n\
    \                lastVal = x\n            }\n            else {\n            \
    \    set.add(lastVal)\n                lastVal = -1\n            }\n        }\n\
    \        set.size == l.size", "        val a = l.sort\n        val d = a.reverse.diff(a)\n\
    \        val x = d.isEmpty\n        return x && a.forall(a => a > a.next)", " \
    \       var max = l(0)\n        var i = 1\n        for(elem <- l.drop(1)) {\n\
    \            if(elem > max) {\n                max = elem\n            }\n   \
    \     }\n        l == List.fill(i)(max)", "        def dfs(l : List[Long], acc\
    \ : Long) : Boolean =\n            if (l.isEmpty) acc == 0\n            else {\n\
    \                val l = l.head\n                val mid = l.tail.foldLeft(acc.toDouble\
    \ + (l - mid) / 2)((ac, v) => ac + (v - mid))\n                dfs(l.tail, if\
    \ (mid < acc) mid else acc)\n            }\n\n        dfs(l, 0L)", "        val\
    \ l1 = l.head\n        val l2 = l.tail.head\n        if(l1 > l2) {\n         \
    \   monotonic(l)\n        } else if (l1 < l2) {\n            monotonic(l.tail)\n\
    \        } else {\n            monotonic(l.tail.tail)\n        }", "        if\
    \ (l.length == 1) return true\n        val l1 = l.head\n        val l2 = l.tail.head\n\
    \        // Find common element between two lists\n        val cmp = if (l1 <\
    \ l2) 1 else if (l1 > l2) -1 else 0\n        val l3 = cmp match {\n          \
    \  case -1 => l.tail.tail\n            case 1 => l.head\n            case 0 =>\
    \ l\n        }\n        val cmp1 = if (l1 < l3) 1 else if (l1 > l3) -1 else 0\n\
    \        val cmp2 = if (l2 < l3) 1 else if (l2 > l3) -1 else 0\n        cmp1 ==\
    \ cmp2", "      var i = l.head\n      val l = l.tail\n      if (i == l.head &&\
    \ i == l.tail) {\n          false\n      }\n      else if (i > l.head && i > l.tail)\
    \ {\n          true\n      }\n      else {\n          val x = l.reverse.head\n\
    \          if (x > i) {\n              false\n          }\n          else {\n\
    \              i = l.reverse.tail.head\n              l.reverse.tail.tail.forall{y\
    \ => i > y}\n          }\n      }\n  }\n}\n\nobject Test extends App {\n    val\
    \ l = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l, 16l,\
    \ 17l, 18l, 19l)\n    println(monotonic(List(1l, 2l, 4l, 10l, 19l))) //true\n\
    \    println(monotonic(List(1l, 2l, 3l, 4l, 7l, 10l, 19l))) //false\n    println(monotonic(List(4l,\
    \ 3l, 2l, 1l, 9l, 19l))) //true\n    println(monotonic(List(1l, 2l, 3l, 4l, 5l,\
    \ 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l, 16l, 17l, 18l, 19l))) //true\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you so much for your help. I spent\
    \ a whole day figuring this out. Your solution works perfectly but as I mentioned\
    \ in my comment below I have another question about how to do this in O(1) space\
    \ and O(n) time. I understand that this requires sorting, but I am really not\
    \ too clear on how to do this in O(1) space. I'm thinking I need to use segment\
    \ trees or something to sort the array and then compare the adjacent elements\
    \ to see if they are increasing or decreasing. I'm working on that part now but\
    \ if you have any ideas please let me know. Thanks again.\n<|/ c |>\n<| a tags=scala,list\
    \ |>\nThis is my version of a solution using tail-recursive calls in Scala.\n\
    It requires tail-recursive functions:\n\nmap\nsortBy\nreverse\nhead\ntail\n\n\
    The input list must have unique elements. I added a check in this example to ensure\
    \ this.\n<code>\ndef monotonic(xs: List[Long]): Boolean = {\n  val l: Long = xs.head\n\
    \  val xs = xs.tail\n  if (xs.isEmpty) true\n  else if (xs.head > l && xs.tail.head\
    \ > l) true", "        val l1 = l.size\n        if (l1 <= 1) true\n        else\
    \ {\n            val (l2, i1, i2) = l1.tail span (_ > l.head)\n            if\
    \ (l2 <= l1) {\n                if (i1 ne 0) monotonic(i1-1) else false\n    \
    \        } else if (i2 ne 0) monotonic(i2-1) else false\n            else monotonic(l2-1)\n\
    \        }", "        var i = 0\n        var j = l.length - 1\n        val n =\
    \ 0\n        while (i <= j) {\n            if (l(i) > l(j)) {\n              \
    \  i += 1\n            }\n            if (l(i) < l(j)) {\n                j -=\
    \ 1\n            }\n            n += 1\n        }\n        if (n == 0) return\
    \ true\n        if (n == 1) return false\n        // if (n == 2) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 3) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 4) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 5) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 6) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 7) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 8) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 9) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 10) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 11) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 12) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 13) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 14) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 15) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 16) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 17) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 18) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 19) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        // if (n == 20) return l(i).compareTo(l(j))\
    \ == 0 || l(i).compareTo(l(j)) == -1\n        return false", "        val arr\
    \ = l.toArray\n        val maxIndex = arr.length - 1\n        (0 to maxIndex).map\
    \ { i =>\n            val current = arr(i)\n            (1 to i).map { j =>\n\
    \                val nextIndex = i + j - 1\n                if(nextIndex > maxIndex)\n\
    \                    true\n                else if(current > arr(nextIndex))\n\
    \                    false\n                else\n                    true\n \
    \           }.reduceLeft(_ ||  _)\n        }.reduceLeft(_ && _)", "        if\
    \ (l.isEmpty) true\n        else {\n            val maxItr = l.iterator\n    \
    \        val minItr = l.iterator\n            val maxElem = maxItr.next()\n  \
    \          val minElem = minItr.next()\n            if (maxElem < minElem) false\n\
    \            else do {\n                val newMaxElem = maxItr.next()\n     \
    \           val newMinElem = minItr.next()\n                if (newMaxElem < newMinElem)\
    \ false\n                else (maxElem < newMaxElem) || (maxElem == newMaxElem\
    \ && minElem < newMinElem) || (maxElem == newMaxElem && minElem == newMinElem\
    \ && monotonic(l.drop(1)))\n            }\n        }", "        val hd = l(0)\n\
    \        val tl = l.drop(1)\n        val i = 1\n        while (i < tl.size) {\n\
    \            if (hd > tl(i)) {\n                return false\n            }\n\
    \            i += 1\n        }\n        true", "        def monotonicL(l: List[Long],\
    \ cur : Long, result : Boolean) : Boolean = {\n            if(l == Nil) result\n\
    \            else {\n                val el = l.head\n                if(el >=\
    \ cur) monotonicL(l.tail, el, result)\n                else monotonicL(l.tail,\
    \ cur, result && l)\n            }\n        }\n        monotonicL(l, 0l, true)",
  "        val (max, min) = l.span(l => l.max < l.min)\n        max.forall(l => l.max\
    \ < min)", "        var flag = true\n        var lastValue = l(0)\n        for\
    \ (i <- 1 to l.length) {\n            if(l(i) < lastValue) { flag = false }\n\
    \            lastValue = l(i)\n        }\n        flag", "        var max = 0L;\n\
    \        var min = 0L;\n        var flag = false;\n        var i = 0\n       \
    \ var j = 1\n        var k = 2\n        while (i < l.length) {\n            if\
    \ (l(i) > max(max)) {\n                max = l(i)\n                flag = true\n\
    \            } else if (l(i) < min(min)) {\n                min = l(i)\n     \
    \           flag = false\n            }\n            i = j;\n            j = k\n\
    \            if (j < l.length) {\n                k = k + 1\n            } else\
    \ {\n                k = 2\n                j = j + 1\n            }\n       \
    \ }\n        flag", "        val len = l.length\n        var max1 = l(0)\n   \
    \     var min1 = l(0)\n        var i = 1\n        for (e <- l if !e.isEmpty )\
    \ {\n            if (max1 < e) max1 = e\n            if (min1 > e) min1 = e\n\
    \            i += 1\n        }\n        // check if all elements are equal\n \
    \       if (i == len) return true\n        // check if any elements are equal\n\
    \        var max2 = l(0)\n        var min2 = l(0)\n        var j = 1\n       \
    \ for (e <- l if !e.isEmpty ) {\n            if (max2 < e) max2 = e\n        \
    \    if (min2 > e) min2 = e\n            j += 1\n        }\n        val d = max1.toLong\
    \ - min1.toLong\n        if (d == 0) return true\n        // check if first element\
    \ is greater then second element\n        if (max1 < max2) return true\n     \
    \   // check if first element is less then second element\n        if (max1 >\
    \ max2) return false\n        // check if first element is greater then third\
    \ element\n        val d = max1.toLong - min2.toLong\n        if (d == 0) return\
    \ true\n        // check if first element is greater then third element\n    \
    \    if (max1 < max2) return false\n        // check if first element is less\
    \ then third element\n        val d = max2.toLong - min2.toLong\n        if (d\
    \ == 0) return false\n        // check if all elements are equal\n        return\
    \ true", "        val list = l sortBy (_ < 0)\n        val last = list.last\n\
    \        val lastOfList = list.dropRight(1)\n        val first = list.head\n \
    \       val firstOfList = list.drop(1)\n        val listWithLast = list ::: lastOfList\n\
    \        val listWithoutLast = list ::: firstOfList\n        val listWithoutFirst\
    \ = list ::: firstOfList\n        val isMonotonic = listWithLast last < listWithoutLast\
    \ first &&\n            listWithoutFirst first < listWithoutLast last\n      \
    \  listWithLast.isEmpty && listWithoutFirst.isEmpty && listWithoutLast.isEmpty\
    \ && isMonotonic", "        var current = 1\n        var prev = l.head\n     \
    \   var isIncreasing = true;\n        for (i <- 0 until l.size) {\n          \
    \  if ((current > prev) && !(prev < l(i))) {\n                current = l(i)\n\
    \                prev = l(i)\n                isIncreasing = false\n         \
    \   } else {\n                if (current < prev) {\n                    isIncreasing\
    \ = false\n                } else {\n                    current = l(i)\n    \
    \                prev = l(i)\n                }\n            }\n        }\n  \
    \      return isIncreasing", "        val l1 = l.toList\n        val l2 = l1.tail\n\
    \        l1.zip(l2).zipWithIndex.forall { case (v, i) => v > l1(i) || v < l2(i)\
    \ }", "        def increasing(l: ListBuffer[Long], i: Long) ={\n            val\
    \ m = l.head\n            l.clear()\n            l += m\n            l.headOption.map(i\
    \ => if (m > i) 1 else 0)\n        }\n        def decreasing(l: ListBuffer[Long],\
    \ i: Long) ={\n            val m = l.last\n            l.clear()\n           \
    \ l += m\n            l.lastOption.map(i => if (m > i) -1 else 0)\n        }\n\
    \        def inc(l: ListBuffer[Long], i: Long) ={\n            val m = l.head\n\
    \            l.clear()\n            l += m\n            l.headOption.map(i =>\
    \ if (m > i) 1 else 0)\n        }\n        val li = new ListBuffer[Long]()\n \
    \       l foreach { v => li +=v}\n        li.nonEmpty match {\n            case\
    \ true => \n                li.foldRight(0)(_+_) match {\n                   \
    \ case 0 => false\n                    case n => true\n                }\n   \
    \         case false => \n                li.foldRight(0)(_+_) match {\n     \
    \               case n => false\n                    case 0 => true\n        \
    \        }\n        }", "        var min = l.head\n        val max = l.tail.foldLeft(l.head){case\
    \ (current, x) => current < x ? x : current}\n        val current = l.head\n \
    \       if (current > max) return false\n        var flag = true\n        for\
    \ {\n            i <- List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l,\
    \ 13l, 14l, 15l, 16l, 17l, 18l, 19l, 20l, 21l, 22l, 23l, 24l, 25l, 26l, 27l, 28l,\
    \ 29l, 30l, 31l, 32l, 33l, 34l, 35l, 36l, 37l, 38l, 39l, 40l, 41l, 42l, 43l, 44l,\
    \ 45l, 46l, 47l, 48l, 49l, 50l, 51l, 52l, 53l, 54l, 55l, 56l, 57l, 58l, 59l, 60l,\
    \ 61l, 62l, 63l, 64l, 65l, 66l, 67l, 68l, 69l, 70l, 71l, 72l, 73l, 74l, 75l, 76l,\
    \ 77l, 78l, 79l, 80l, 81l, 82l, 83l, 84l, 85l, 86l, 87l, 88l, 89l, 90l, 91l, 92l,\
    \ 93l, 94l, 95l, 96l, 97l, 98l, 99l, 100l, 101l, 102l, 103l, 104l, 105l, 106l,\
    \ 107l, 108l, 109l, 110l, 111l, 112l, 113l, 114l, 115l, 116l, 117l, 118l, 119l,\
    \ 120l, 121l, 122l, 123l, 124l, 125l, 126l, 127l, 128l, 129l, 130l, 131l, 132l,\
    \ 133l, 134l, 135l, 136l, 137l, 138l, 139l, 140l, 141l, 142l, 143l, 144l, 145l,\
    \ 146l, 147l, 148l, 149l, 150l, 151l, 152l, 153l, 154l, 155l, 156l, 157l, 158l,\
    \ 159l, 160l, 161l, 162l, 163l, 164l, 165l, 166l, 167l, 168l, 169l, 170l, 171l,\
    \ 172l, 173l, 174l, 175l, 176l, 177l, 178l, 179l, 180l, 181l, 182l, 183l, 184l,\
    \ 185l, 186l, 187l, 188l, 189l, 190l, 191l, 192l, 193l, 194l, 195l, 196l, 197l,\
    \ 198l, 199l, 200l, 201l, 202l, 203l, 204l, 205l, 206l, 207l, 208l, 209l, 210l,\
    \ 211l, 212l, 213l, 214l, 215l, 216l, 217l, 218l, 219l, ", "        val size =\
    \ l.size\n        var flag = true\n        for(i <- 0 until size) {\n        \
    \    val x = l(i)\n            val y = l(i + 1)\n            if((x == 0 && y ==\
    \ 0) || (x == y && x > 0)) {\n                flag = false\n                break\n\
    \            }\n        }\n        flag", "        val min1 = l.min\n        val\
    \ max1 = l.max\n        if (min1 == 0l && max1 == 0l) return true\n        if\
    \ (min1 == 0l && max1 != 0l) return false\n        if (min1 != 0l && max1 == 0l)\
    \ return true\n        if (min1 != 0l && max1 != 0l) return monotonic(l.tail)\n\
    \        if (min1 < max1) return monotonic(l.drop(1)) && monotonic(l.dropRight(1))\n\
    \        else return monotonic(l.dropRight(1))", "      l.reverse.zipWithIndex.forall\
    \ {\n        case (elem, index) => index >= 1 && l(index-1) >= elem\n      }",
  "       // Only keep monotonically increasing or decreasing values\n       val increasingOrder\
    \ = l match {\n          case a :: b :: Nil => a > b\n          case a :: Nil\
    \ => true\n          case b :: Nil => false\n          case a :: b :: t => a >\
    \ b\n       }\n\n       // Only keep monotonically decreasing values\n       val\
    \ decreasingOrder = l match {\n          case a :: b :: Nil => a < b\n       \
    \   case a :: Nil => true\n          case b :: Nil => false\n          case a\
    \ :: b :: t => a < b\n       }\n\n       // Return true if all list values are\
    \ increasing and decreasing\n       // or if all values are monotonically increasing\
    \ or decreasing\n       return increasingOrder || decreasingOrder", "        if\
    \ (l.isEmpty) true\n        else {\n            var first = l.head\n         \
    \   var last = l.last\n            for(x<-l if x < first) first = x\n        \
    \    for(x<-l if x > last) last = x\n            if (first == last) return true\n\
    \            else return false\n        }", "        if(l.isEmpty) return true\n\
    \        var left = 0\n        var right = l.length\n        while(left < right)\
    \ {\n            while(left < right && l[left] < l[left+1]) left += 1\n      \
    \      while(left < right && l[right] > l[right-1]) right -= 1\n            if(left\
    \ >= right) return false\n            if(l[left] < l[right]) left += 1\n     \
    \       else right -= 1\n        }\n        true", "        val sorted = l.sortWith(_\
    \ < _) // sort increasing or decreasing\n        var sum = 0\n        sorted.foreach{\
    \ x => sum += x }\n        sum > 0", "        // sort by value, so a is larger\
    \ than b iff a < b\n        val sorted = l.toList.sortBy(_.toLong)\n        var\
    \ sum = 0l\n        val last: Long = -1l\n        val prev: Long = -1l\n     \
    \   for(item <- sorted) {\n            sum = sum + item\n            if(sum >\
    \ last)\n                return true\n            val a = prev + item\n      \
    \      prev = item\n            if(a.toLong > last)\n                return false\n\
    \        }\n        true", "        val m = l.min\n        val n = l.max\n   \
    \     n < m || (n < m && l.exists(x => x > m))"]
stop_tokens:
- "\n    }\n"
