name: HumanEval_83_starts_one_ends
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the count of the numbers of n-digit\n\
  \    // positive integers that start or end with 1.\n    def startsOneEnds(n : Long)\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(startsOneEnds((1l))\
  \ == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l))\
  \ == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l))\
  \ == (18000l));\n    }\n\n}\n"
completions: ["        val ones = scala.collection.mutable.Set[Long]()\n        for\
    \ (i <- 0 to 9) {\n            if (n % 10 == i) ones += n\n        }\n       \
    \ val twos = scala.collection.mutable.Set[Long]()\n        for (i <- 10 to 99)\
    \ {\n            if (n % 10 == i) twos += n\n        }\n        val threes = scala.collection.mutable.Set[Long]()\n\
    \        for (i <- 100 to 999) {\n            if (n % 10 == i) threes += n\n \
    \       }\n        val fours = scala.collection.mutable.Set[Long]()\n        for\
    \ (i <- 1000 to 9999) {\n            if (n % 10 == i) fours += n\n        }\n\
    \        val fives = scala.collection.mutable.Set[Long]()\n        for (i <- 10000\
    \ to 99999) {\n            if (n % 10 == i) fives += n\n        }\n        val\
    \ sixes = scala.collection.mutable.Set[Long]()\n        for (i <- 100000 to 999999)\
    \ {\n            if (n % 10 == i) sixes += n\n        }\n        val sevens =\
    \ scala.collection.mutable.Set[Long]()\n        for (i <- 1000000 to 999999999)\
    \ {\n            if (n % 10 == i) sevens += n\n        }\n        val eights =\
    \ scala.collection.mutable.Set[Long]()\n        for (i <- 10000000 to 99999999999)\
    \ {\n            if (n % 10 == i) eights += n\n        }\n        val nines =\
    \ scala.collection.mutable.Set[Long]()\n        for (i <- 1000000000 to 999999999999)\
    \ {\n            if (n % 10 == i) nines += n\n        }\n        if (ones.size\
    \ == n && ones.size == n) {\n            return ones.size\n        } else if (twos.size\
    \ == n && twos.size == n) {\n            return twos.size\n        } else if (threes.size\
    \ == n && threes.size == n) {\n            return threes.size\n        } else\
    \ if (fours.size == n && fours.size == n) {\n            return fours.size\n \
    \       } else if (fives.size == n && fives.size == n) {\n            return fives.size\n\
    \        } else if (sixes.size == n && sixes.size == n) {\n            return\
    \ sixes.size\n        } else if (sevens.size == n && sevens.size == n) {\n   \
    \         return sevens.size\n        } else if (eights.size == n && eights.size\
    \ == n) {\n            return eights.size\n        } else if (nines.size == n\
    \ && nines.size == n) {\n            return nines.size\n        } else {\n   \
    \         return 0\n        }", "        var count = 0\n        for(i <- 0 until\
    \ n)\n            if (i % 10000000 == 1)\n                count += 1\n       \
    \ for(i <- 0 until n-1)\n            if (i % 100000 == 1)\n                count\
    \ += 1\n        for(i <- 0 until n-2)\n            if (i % 100 == 1)\n       \
    \         count += 1\n        for(i <- 0 until n-3)\n            if (i % 10 ==\
    \ 1)\n                count += 1\n        for(i <- 0 until n-4\n            if\
    \ (i % 1 == 1)\n                count += 1\n        count += (n/5) * 5 + (n/7)\
    \ * 7 + (n/9) * 9 + n/10 * 10\n        count += (n - 1) * 10\n        count",
  "        // Write your code here.\n        if(n < 0)\n            return n\n   \
    \     val countMap = mutable.Map[Long, Long]()\n        for (x <- 1 to n)\n  \
    \          countMap(x * x)\n            countMap(x * x + 1)\n            countMap(x\
    \ * x + 2)\n            countMap(x * x + 3)\n            countMap(x * x + 4)\n\
    \            countMap(x * x + 5)\n            countMap(x * x + 6)\n          \
    \  countMap(x * x + 7)\n            countMap(x * x + 8)\n            countMap(x\
    \ * x + 9)\n            countMap(x * x + 10)\n            countMap(x * x + 11)\n\
    \            countMap(x * x + 12)\n            countMap(x * x + 13)\n        \
    \    countMap(x * x + 14)\n            countMap(x * x + 15)\n            countMap(x\
    \ * x + 16)\n            countMap(x * x + 17)\n            countMap(x * x + 18)\n\
    \            countMap(x * x + 19)\n            countMap(x * x + 20)\n        \
    \    countMap(x * x + 21)\n            countMap(x * x + 22)\n            countMap(x\
    \ * x + 23)\n            countMap(x * x + 24)\n            countMap(x * x + 25)\n\
    \            countMap(x * x + 26)\n            countMap(x * x + 27)\n        \
    \    countMap(x * x + 28)\n            countMap(x * x + 29)\n            countMap(x\
    \ * x + 30)\n            countMap(x * x + 31)\n            countMap(x * x + 32)\n\
    \            countMap(x * x + 33)\n            countMap(x * x + 34)\n        \
    \    countMap(x * x + 35)\n            countMap(x * x + 36)\n            countMap(x\
    \ * x + 37)\n            countMap(x * x + 38)\n            countMap(x * x + 39)\n\
    \            countMap(x * x + 40)\n            countMap(x * x + 41)\n        \
    \    countMap(x * x + 42)\n            countMap(x * x + 43)\n            countMap(x\
    \ * x + 44)\n            countMap(x * x + 45)\n            countMap(x * x + 46)\n\
    \            countMap(x * x + 47)\n            countMap(x * x + 48)\n        \
    \    countMap(x * x + 49)\n            countMap(x * x + 50)\n            countMap(x\
    \ * x + 51)\n            countMap(x * x + 52)\n            countMap(x * x + 53)\n\
    \            countMap(x * x + 54)\n            countMap(x * x + 55)\n        \
    \    countMap(x * x + 56", "        val arr = new Array[Long](10000)\n       \
    \ var count = 0\n        // loop through n starting from 1 to n\n        for (i\
    \ <- 1 to n) {\n            // if i is 1, then arr(i) is 1.\n            if (arr(i)\
    \ == 1) {\n                count += 1\n            }\n            // else if i\
    \ is n or i-1 (which means arr(i-1) = 0), then arr(i) is\n            // not 1.\n\
    \            else if (!(i == n || i == n-1)) {\n                arr(i) += 1\n\
    \            }\n        }\n        count", "        val r = mutable.BitSet(math.pow(10,\
    \ n).toInt)\n        r(0) = true\n        r(math.pow(10, n).toInt) = true\n  \
    \      var cnt = 0\n        for (i = 1 to math.pow(10, n).toInt) {\n         \
    \   if (r(i)) {\n                cnt += 1\n                r(i) = false\n    \
    \        }\n        }\n        return cnt", "        val isOneStartsN = (n + 1)\
    \ % 10000 == 0\n        val isOneEndsN = (n - 1) % 10000 == 0\n        if (isOneStartsN\
    \ && isOneEndsN) 1\n        else if (isOneStartsN) 1L\n        else if (isOneEndsN)\
    \ 0L\n        else {\n            var count = 0L\n            var curr = n\n \
    \           while (curr >= 10000) {\n                val n2 = curr / 10000\n \
    \               val n3 = n2 / 1000\n                val n4 = n3 / 100\n      \
    \          val n5 = n4 / 10\n                val n6 = n5 / 1\n               \
    \ if (n6 == 1) count = 1L\n                if (n6 == 0) count = 0L\n         \
    \       curr = n2\n            }\n            count\n        }", "        if(n\
    \ < 0) return 0\n        val count = Long.MaxValue\n        for(i <- 1 to n) if(i\
    \ % 10 != 1) count -= 1\n        count", "        if (n <= 0) return 0\n     \
    \   var count = 0\n        var remainder = n\n        while (remainder > 0) {\n\
    \            count += 1\n            val nextOne = remainder / 10\n          \
    \  if (nextOne == 1) remainder -= nextOne * 10\n            else remainder -=\
    \ nextOne\n        }\n        return count", "        if(n < 0) throw new Exception(\"\
    Not a positive integer\")\n        var count = 0\n        var flag = 0\n     \
    \   while(n != 0) {\n            count += (n / 10).asInstanceOf[Int]\n       \
    \     flag = n % 10\n            if(flag == 1) {\n                if(count ==\
    \ 1) count += 1\n                count = 0\n            } else if(flag == 0) {\n\
    \                count -= 1\n            }\n            n = n / 10\n        }\n\
    \        if(count == 0) count = -1\n        \n        return count", "       \
    \ var count = 1\n        var pos = n\n        while (pos > 1) {\n            pos\
    \ /= 10\n            count += 1\n        }\n        count += (pos == 1)\n    \
    \    count", "        if (n == 0) return 0\n        val map = mutable.HashMap.empty[Long,\
    \ Long]\n        for (x <- 1 to n toLong) {\n            map.put(x, if (x == 1\
    \ || (x % 10 == 1) || (x % 100 == 1) || (x % 1000 == 1)) 1 else 0)\n        }\n\
    \        map.size", "        if(n < 0) throw new ArithmeticException(\"Negative\
    \ number\")\n        val count = mutable.Map[Long, Long]()\n        for(i <- 0\
    \ to Math.ceil(n/10) - 1) {\n            val num = n.toInt*10 + i\n          \
    \  if((num%10) != 1) count(num) = count(num) + 1\n        }\n        count((n+1).toInt)",
  "        val counter = mutable.HashMap[Long, Int]()\n        (1 to n).filter(x =>\
    \ x == 1).takeWhile(x => x != 1).foreach(x => {\n            val count = counter.getOrElse(x,\
    \ 0)\n            counter.put(x, count + 1)\n        })\n        counter.values.sum",
  "        val count = mutable.ListBuffer.empty[Long]\n        for(i <- 1 to n.toInt)\
    \ if( n % i == 0 ) count += 1\n        count.get.size", "        var count = 1\n\
    \        for( i <- 1 to n){\n            if ( (n%i) == 0){\n                count\
    \ +=1\n            }\n        }\n        count", "        var count = 0\n    \
    \    var n = n.toInt\n        val startsOne = mutable.TreeSet[Int]()\n       \
    \ val endsOne = mutable.TreeSet[Int]()\n\n        while(n > 1) {\n           \
    \ if(n % 10 == 1) {\n                startsOne.add (n % 10)\n            } else\
    \ {\n                endsOne.add (n % 10)\n            }\n            n = n/10\n\
    \        }\n\n        count = startsOne.size + (endsOne.size / 10).round\n   \
    \     return count", "        var result = 0\n        val digits = 10L\n     \
    \   val ones = Set(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)\n        while(n\
    \ != 0) {\n            val d = n.toInt / digits\n            if (d.toLong == 1)\n\
    \                result += ones.count(d - 1L)\n            n /= digits\n     \
    \   }\n        result", "        val ones = mutable.BitSet(10).clear\n       \
    \ // count how many 1s\n        var count = 0\n        // number of digits in\
    \ the number\n        val digitCount = math.pow(10, math.ceil(math.log10(n)))\n\
    \        // loop through each digit\n        for( i <- 0 until digitCount) {\n\
    \            // add the current digit\n            ones = ones | mutable.BitSet(digitCount(i)).clear\n\
    \            // find all ones at position i\n            val set = new BitSet\n\
    \            for( j <- 0 until digitCount) {\n                if( ones(j) && math.pow(10,\
    \ j) == i ) {\n                    set = set | mutable.BitSet(digitCount(j))\n\
    \                }\n            }\n            count += set.size\n        }\n\
    \        count - (n - 1)", "        var count = n\n        val buffer = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        buffer.clear()\n        var i = 2\n        while (count > 0) {\n    \
    \        var temp = count\n            while (temp > 0) {\n                buffer.append(temp)\n\
    \                temp -= 1\n            }\n            buffer.reverse.foreach(buffer.remove)\n\
    \            var a = buffer.last\n            if (a == 1)\n                count\
    \ += 1\n            buffer.clear()\n            i +=1\n        }\n        count",
  "      val ones = List.range(1, 10).toList\n      val twos = List.range(10, 20).toList\n\
    \      val threes = List.range(20, 30).toList\n      val fours = List.range(30,\
    \ 40).toList\n      val fives = List.range(40, 50).toList\n      val sixes = List.range(50,\
    \ 60).toList\n      val sevens = List.range(60, 70).toList\n      val eights =\
    \ List.range(70, 80).toList\n      val nines = List.range(80, 90).toList\n\n \
    \     val counts = mutable.ListBuffer[Long]()\n      val startsWithOne = ones.take(n).contains(1)\n\
    \      if (startsWithOne) counts += n\n      val endsWithOne = ones.drop(n).contains(1)\n\
    \      if (endsWithOne) counts += n\n\n      val startsWithTwo = twos.take(n).contains(1)\n\
    \      if (startsWithTwo) counts += n\n      val endsWithTwo = twos.drop(n).contains(1)\n\
    \      if (endsWithTwo) counts += n\n\n      val startsWithThree = threes.take(n).contains(1)\n\
    \      if (startsWithThree) counts += n\n      val endsWithThree = threes.drop(n).contains(1)\n\
    \      if (endsWithThree) counts += n\n\n      val startsWithFour = fours.take(n).contains(1)\n\
    \      if (startsWithFour) counts += n\n      val endsWithFour = fours.drop(n).contains(1)\n\
    \      if (endsWithFour) counts += n\n\n      val startsWithFive = fives.take(n).contains(1)\n\
    \      if (startsWithFive) counts += n\n      val endsWithFive = fives.drop(n).contains(1)\n\
    \      if (endsWithFive) counts += n\n\n      val startsWithSix = sixes.take(n).contains(1)\n\
    \      if (startsWithSix) counts += n\n      val endsWithSix = sixes.drop(n).contains(1)\n\
    \      if (endsWithSix) counts += n\n\n      val startsWithSeven = sevens.take(n).contains(1)\n\
    \      if (startsWithSeven) counts += n\n      val endsWithSeven = sevens.drop(n).contains(1)\n\
    \      if (endsWithSeven) counts += n\n\n      val startsWithEight = eights.take(n).contains(1)\n\
    \      if (startsWithEight) counts += n\n      val endsWithEight = eights.drop(n).contains(1)\n\
    \      if (endsWithEight) counts += n\n\n      val startsWithNine = nines.take(n",
  "        // Initialize count\n        var count = 0\n        var m = BigInt(n)\n\
    \        while(m > 0) {\n            val x = m/10\n            if(x.toLong ==\
    \ 1) {\n                count += 1\n            }\n            m %= 10\n     \
    \   }\n        count", "        val ones = Long(Array.tabulate(n)(i => if (i.toString.head.toString.head.toString.head.toString.head.toString.head\
    \ == \"1\") 1 else 0))\n        val nines = Long(Array.tabulate(n)(i => if (i.toString.tail.toString.tail.toString.tail.toString.tail.toString.tail\
    \ == \"9\") 1 else 0))\n        ones + nines", "        var count = 0L\n     \
    \   for (i <- 1 to n by 10) count += i.toLong.filter{ x => x == 1 }.length\n \
    \       count += n.toLong.filter{ x => x == 1 }.length\n        count += ((n -\
    \ 1).toLong.filter{ x => x == 1 }.length - 1).toLong\n        count", "      \
    \  var count = 0\n        for(i <- 1L to n) {\n            if((i.toString.toLong)%10\
    \ == 1)\n                count += 1\n        }\n        return count", "     \
    \   var countOfStartOne = 0L\n        var countOfEndOne = 0L\n        var i =\
    \ n\n        var j = i\n        while(j > 0) {\n            if(j % 10 == 1) {\n\
    \                countOfStartOne += 1\n            }\n            if(j % 10 ==\
    \ -1) {\n                countOfEndOne += 1\n            }\n            j /= 10\n\
    \        }\n        countOfStartOne = countOfStartOne * Math.log10(n)\n      \
    \  countOfEndOne = countOfEndOne * Math.log10(n)\n        return countOfStartOne\
    \ + countOfEndOne", "        if (n == 1) return 1\n        if (n == 0) return\
    \ 0\n        if (n < 0) return 0\n\n        // count how many numbers have first\
    \ digits > 1 and last digits <= 1.\n        // This is equal to the number of\
    \ digits that start with a 1 and have\n        // an odd last digit (which means\
    \ they start with 2).\n        // The difference between the first and last digits\
    \ is one or more.\n        // This works because the last digit counts when you\
    \ count the first\n        // digits > 1.\n        var count = 0\n        for(i\
    \ <- 1 until n if n % i == 0) count += 1\n\n        // count how many numbers\
    \ have first digits > 1 and last digits <= 1.\n        // This is equal to the\
    \ number of digits that end with a 1 and have\n        // an even last digit.\n\
    \        // The difference between the first and last digits is one or more.\n\
    \        // This works because the first digit counts when you count the last\n\
    \        // digits > 1.\n        for(i <- 0 until n if n % i == 0) count += 1\n\
    \        \n        // count how many numbers have first digits > 1 and last digits\
    \ <= 1.\n        // This is equal to the number of digits that end with a 1 and\
    \ have\n        // an odd last digit.\n        // The difference between the first\
    \ and last digits is one or more.\n        // This works because the first digit\
    \ counts when you count the last\n        // digits > 1.\n        for(i <- 0 until\
    \ n if n % i == 0) count += 1\n\n        count", "        var count = 0L\n   \
    \     for(i <- 1 to n by 10) count += if((i / 10).isDefined) 1 else 0L\n     \
    \   count", "        if(n < 1) return 0\n        val start = Math.pow(n, 1/10)\
    \ + 1\n        val end = Math.pow(n, 1/10) + 2\n        return Math.max(0, end\
    \ - start)", "        var count = 0\n        val l = scala.math.BigInt(n).toInt\n\
    \        for (i <- 0 until l-1) {\n            var isStart = false\n         \
    \   var isEnd = false\n            while (i < l-1) {\n                if (l.mod(i)==0)\
    \ isStart = true\n                if (l.mod(i)==(l-1)) isEnd = true\n        \
    \        i = i + 1\n            }\n            if (isStart && isEnd) count = count\
    \ + 1\n        }\n        count", "        val zeroes = mutable.BitSet(n.toBytes.length)\n\
    \        val ones = mutable.BitSet(n.toBytes.length)\n        ones.set(0)\n  \
    \      val onesAndZeroes = ones.intersect(zeroes)\n        var onesCount : Long\
    \ = 0\n        for ((onesAndZeroes,i) => onesAndZeroes.size == 1 && onesAndZeroes.set(i))\
    \ onesCount += 1\n        val startsWithOne = ones.subsetOf(onesAndZeroes)\n \
    \       for (i <- 0 until onesAndZeroes.length when onesAndZeroes.bit(i)-1) zeroes.clear(i)\n\
    \        val startsWithOneAndZeroes = ones.subsetOf(onesAndZeroes)\n        var\
    \ zerosCount : Long = 0\n        for ((onesAndZeroes,i) => onesAndZeroes.size\
    \ == 1 && onesAndZeroes.clear(i)) zerosCount += 1\n        val endsWithOne = ones.subsetOf(onesAndZeroes)\n\
    \        for (i <- 0 until onesAndZeroes.length when onesAndZeroes.clear(i)-1)\
    \ zeroes.set(i)\n        val endsWithOneAndZeroes = ones.subsetOf(onesAndZeroes)\n\
    \        ones.clear(onesAndZeroes.length)\n        onesAndZeroes.clear(onesAndZeroes.length)\n\
    \        val zeroesAndOnes = ones.intersect(onesAndZeroes)\n        val startsWithZero\
    \ = zeroes.subsetOf(onesAndZeroes)\n        val endsWithZero = zeroes.subsetOf(onesAndZeroes)\n\
    \        zeroes.clear(onesAndZeroes.length)\n        onesAndZeroes.clear(onesAndZeroes.length)\n\
    \        val zeroesAndOnesAndZeroes = ones.intersect(onesAndZeroes)\n        val\
    \ endsWithOneAndZeroes = ones.subsetOf(onesAndZeroes)\n        ones.clear(onesAndZeroes.length)\n\
    \        onesAndZeroes.clear(onesAndZeroes.length)\n        val zeroesAndOnesAndOnes\
    \ = ones.intersect(onesAndZeroes)\n        val startsWithOneAndZeroes = ones.subsetOf(onesAndZeroes)\n\
    \        val endsWithOneAndZeroes = ones.subsetOf(onesAndZeroes)\n        ones.clear(onesAndZeroes.length)\n\
    \        onesAndZeroes.clear(onesAndZeroes.length)\n        val zeroesAndOnesAndOnesAndZeroes\
    \ = ones.intersect(onesAndZeroes)\n        val startsWithOneAndOnes = ones.subsetOf(onesAndZeroes)\n\
    \        val endsWithOneAndOnes = ones.subsetOf(onesAndZeroes)\n        ones.clear(onesAndZeroes.length)\n\
    \        ", "        var count = 0\n        val ones = n%10000000\n        val\
    \ zeros = n/100000\n        val tens = n/10000\n        val hundreds = n/1000\n\
    \n        if(ones ==  1){\n            count += 1\n        }\n        if(zeros\
    \ == 1){\n            count += 1\n        }\n        if(tens == 1){\n        \
    \    count += 1\n        }\n        if(hundreds == 1){\n            count += 1\n\
    \        }\n\n        return count", "        val twos    = 0 until n\n      \
    \  val prefixes = mutable.LinkedHashSet[Long]()\n        for (p in twos) {\n \
    \           if (n % p == 0) prefixes += p\n            if (prefixes.head == 1)\
    \ return prefixes.size - 1\n        }\n        return 0", "      if(n < 0) {\n\
    \        return -1\n      }\n      if(n % 10 == 1) return 0\n      if(n % 10 ==\
    \ 0) return 1\n      val numsOfOne = numsOfOneAndRest(n)\n      val countFromOneAndRest\
    \ = countFromOneAndRest(n/10)\n      numsOfOne + countFromOneAndRest", "     \
    \   val counter = mutable.Map.empty[Long, Long]\n        for (i <- 0 until n)\
    \ {\n            val s = math.pow(10, i).toLong\n            if (s > 0) {\n  \
    \              val starts = math.floor(s / 1L)\n                if (starts ==\
    \ s) {\n                    counter(i) += 1\n                }\n             \
    \   val ends = math.ceil(s / 1L)\n                if (ends == s) {\n         \
    \           counter(i) += 1\n                }\n            }\n        }\n   \
    \     counter.size", "        val ones = n until (n / 10)\n        val onesAndRest\
    \ = if (n / 10 == 1) ones + 1 else ones + 1\n        onesAndRest + startsOneEnds(n\
    \ / 10) * ones", "        var count = 1\n        for (i <- 0 to (n-1)) {\n   \
    \         val remainder = n % i;\n            if (remainder == 0) {\n        \
    \        count += 1\n            }\n        }\n        count", "        if (n\
    \ == 0) return 0\n        if (n < 0) return -1\n        // use two arrays to store\
    \ the count of each number of n-digits\n        // starting with 1\n        val\
    \ nDigits = Array.ofDim[Long](n+1)\n        val nDigitStartsOne = Array.ofDim[Long](n+1)\n\
    \        val nDigitEndsOne = Array.ofDim[Long](n+1)\n        var i : Long = 0\n\
    \        while (i <= n) nDigits(i) = i toLong * 10\n        // calculate the number\
    \ of n-digit numbers that start with 1\n        // and end in 1\n        var nStarts\
    \ = 1\n        var nEnds = 1\n        while (i <= n) {\n            if (nDigits(i)\
    \ == 1 && (i toLong * 10 - 1) toLong == 1)\n                nStarts += 1\n   \
    \         if (nDigits(i) == 1 && (i toLong * 10 + 1) toLong == 1)\n          \
    \      nEnds += 1\n            i += 1\n        }\n        // use two arrays to\
    \ store the count of each number of n-digits\n        // starting with 1\n   \
    \     val nDigitStartsOne = Array.ofDim[Long](nStarts)\n        val nDigitEndsOne\
    \ = Array.ofDim[Long](nEnds)\n        i = 1\n        while (i <= n) nDigitStartsOne(i)\
    \ = nDigits(i).toLong\n        i = 1\n        while (i <= n) {\n            if\
    \ (nDigits(i) == 1 && (i toLong * 10 - 1) toLong == 1)\n                nDigitStartsOne(i)\
    \ += 1\n            if (nDigits(i) == 1 && (i toLong * 10 + 1) toLong == 1)\n\
    \                nDigitEndsOne(i) += 1\n            i += 1\n        }\n      \
    \  // calculate the number of n-digit numbers that start with 1\n        // and\
    \ end in 1\n        var nStarts = 1\n        var nEnds = 1\n        while (i <=\
    \ n) {\n            if (nDigitStartsOne(i) == nStarts && nDigitEndsOne(i) == nEnds)\n\
    \                nStarts += 1\n            if (nDigitStartsOne(i) == nStarts &&\
    \ nDigitEndsOne(i) == nEnds)\n                nEnds += 1\n            i += 1\n\
    \        }\n        // return the count of n-digit numbers that start or end with\
    \ 1\n        return nStarts + nEnds", "        var i = 0\n        var count =\
    \ 0\n        while (i < n) {\n            if (n % 10 == 1 && i % 10 != 0) {\n\
    \                count += 1\n            }\n            i += 1\n        }\n  \
    \      count", "        val arr = new Array[Long](n)\n        val l = 0\n    \
    \    val r = 0\n        while (l <= n-1) {\n            arr(l) = n\n         \
    \   l += 1\n        }\n        for (r <- 0 until n-1) {\n            if (arr(r)\
    \ == 0) {\n                break\n            }\n            arr(r) = arr(r) +\
    \ 1\n            r += 1\n        }\n        val count = 0\n        arr.zip(arr.tail).foreach{\
    \ case (v, t) => if (v == t) count += 1; count}\n        count", "        val\
    \ start = List(1, 2, 3, 5, 7, 9, ...)\n        val end = List(-1, -2, -3, -5,\
    \ -7, -9, ...)\n        if (n == 1) 1\n        else (start.zipWithIndex.flatMap(t\
    \ => end.zipWithIndex.flatMap(tt => if (n > 1 && (n%tt._1 == 1 && n%dtt._1 ==\
    \ 1)) Some(tt._1 + tt._2)) filterNot (x => x == 0)) count) /  start.length", " \
    \       val countMap = new mutable.HashMap[Long, Long]()\n        for (i <- 1\
    \ to n)\n            if (i.toString.startsWith(\"1\") || i.toString.endsWith(\"\
    1\"))\n                countMap(i.toLong + 1)\n        val sum = countMap.foldLeft(0L)(_\
    \ + _)\n        return countMap.size * (n-1) + sum", "        val ones = mutable.BitSet(2L\
    \ to n by 2)\n        ones.find(_._1)\n            .map { case (start, stop) =>\n\
    \                val start = start + 1\n                val stop = stop + 2\n\
    \                if (ones.contains(start) || ones.contains(stop)) {\n        \
    \            0\n                } else {\n                    ones.count(start\
    \ until stop)\n                }\n            }.sum", "        var count = 0\n\
    \        // find the n-digit long that starts with 1\n        for (i = 1 until\
    \ n / 10) {\n            if (n % i == 0) {\n                count += 1\n     \
    \           if (i % 10 == 0) {\n                    break\n                }\n\
    \            }\n        }\n        count", "        val ones = Set()\n       \
    \ val zeroes = Set()\n        for (i <- 1 to n) yield {\n            if (i / 10\
    \ == 0) ones ++= List(i)\n            if (i % 10 == 1) zeroes ++= List(i)\n  \
    \      }\n        ones.count - zeroes.count", "        var count = 0\n       \
    \ var result = Long.MaxValue\n        for (i <- 1 until n)\n            if (i\
    \ % 10 == 1)\n                count += 1\n            else\n                count\
    \ = 0\n            if (count == 0 && result > 0)\n                result = 1\n\
    \            result = (result * 10) + count\n        return result", "       \
    \ val start = scala.util.Random.nextInt(n)\n        val end = n-1\n        val\
    \ count = scala.util.Random.nextInt((end - start) + 1) + start\n        count",
  "        val starts = mutable.Set[Long]()\n        for(i <- 0 until n) {\n     \
    \       if (i % 10 == 1 && i / 10 <= i)\n                starts += 1\n       \
    \ }\n        starts.toSeq.size", "        val num = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var i = Long.MaxValue - 1\n        var count = 0\n        while (n >\
    \ 0) {\n            i /= 10\n            count += i\n            num append i\n\
    \            if (n == 1) {\n                num.clear()\n                return\
    \ count\n            }\n            n--\n        }\n        num.clear()\n    \
    \    return count", "        val l = new Array[Long](n)\n        (1 to n) foreach\
    \ { x =>\n            (x to Math.pow(10, x-1) - 1) foreach { y =>\n          \
    \      l(y) = 1\n            }\n        }\n        (0 to n-1) foreach { x =>\n\
    \            val y = x % Math.pow(10, n-1)\n            val x = x - y\n      \
    \      if (x < 0) (x + Math.pow(10, n-1)) foreach { z =>\n                l(n-1)\
    \ = 1\n            }\n            else l(x) = 1\n        }\n        l.length",
  "        if (n == 0) return 1\n        val ones = mutable.ListBuffer(Long.MinValue,\
    \ 0)\n        for (i <- 1 to n) {\n            if (i * i % 10 == 1)\n        \
    \        ones add i\n            else if (i * i % 10 == 0)\n                ones\
    \ add i\n        }\n        ones.length", "        var count = 0L\n        var\
    \ current = 0L\n        var last = 0L\n        var last2 = 0L\n        var last3\
    \ = 0L\n        var last4 = 0L\n        var current2 = 0L\n        var current3\
    \ = 0L\n        var current4 = 0L\n        var last3 = 0L\n        var last4 =\
    \ 0L\n        val nStr = n.toString\n        val nArray = nStr.split(\"\")\n \
    \       for (i <- 0 until nArray.length) {\n            if (nArray(i).toLong ==\
    \ 1) {\n                if (i == nArray.length - 1) {\n                    if\
    \ (nArray(i).toLong == 1) {\n                        if (current == 1) {\n   \
    \                         count += 1\n                        }\n            \
    \        }\n                }\n                last = 0L\n                last2\
    \ = 0L\n                last3 = 0L\n                last4 = 0L\n             \
    \   if (nArray(i + 2).toLong == 1) {\n                    current += 1\n     \
    \               last = 1L\n                    last2 = 1L\n                  \
    \  last3 = 1L\n                    last4 = 1L\n                }\n           \
    \     if (nArray(i + 3).toLong == 1) {\n                    current += 1\n   \
    \                 last2 = 1L\n                    last3 = 1L\n               \
    \     last4 = 1L\n                }\n                if (nArray(i + 4).toLong\
    \ == 1) {\n                    current += 1\n                    last3 = 1L\n\
    \                    last4 = 1L\n                }\n                if (nArray(i\
    \ + 5).toLong == 1) {\n                    current += 1\n                    last4\
    \ = 1L\n                }\n                if (nArray(i + 6).toLong == 1) {\n\
    \                    current2 += 1\n                    last3 = 1L\n         \
    \           last4 = 1L\n                }\n                if (nArray(i + 7).toLong\
    \ == 1) {\n                    current3 += 1\n                    last3 = 1L\n\
    \                    last4 = 1L\n                }\n                if (nArray(i\
    \ + 8).toLong == 1) {\n                    current4 += 1\n                   \
    \ last4 = 1L\n                }\n                if (last == 1 && last2 == 1 &&\
    \ last3 == 1 && last4 == 1 && current2 == 1 && current3 == 1 && current4 == 1)\
    \ {\n                    if (nArray(i + 1).toLong == 1) {\n                  \
    \      count += 1\n                    }\n                }\n            }\n \
    \       }\n        count", "        val map = mutable.Map[Long, Int]()\n     \
    \   \n        val ones = mutable.Seq(1L).reverse.iterator\n        for(i <- 0\
    \ until n){\n            val next = ones: Iterator[Long]\n            if(next.hasNext){\n\
    \                val n = next.next()\n                if(map.contains(n)){\n \
    \                   map.update(n, map.get(n)+1)\n                } else {\n  \
    \                  map.update(n, 1L)\n                }\n            }\n     \
    \   }\n        \n        val ret = map.filterKeys(x => x._1 == 0)\n        val\
    \ count = ret.filterKeys(x => x._1 == 1).length\n        ret.map(_._2)", "   \
    \     val r = new scala.collection.mutable.ListBuffer[Long]()\n        val digits\
    \ = n.toString.reverse.grouped(10).toSeq\n        var d = 0\n        val len =\
    \ digits.size + 1\n        for (d = 0 to len) {\n            r ++= digits(d).filter(x\
    \ => x >= 1)\n            d += 1\n        }\n        r.size", "        var count\
    \ : Long = 0\n        for {\n            i <- 0 until (n/10)\n            if (i\
    \ % 10 == 1 && n/10 - i >= 1) count += 1\n        } \n        count", "      \
    \  val numOfStartingOnes = n\n        val numOfEndingOnes = (n*(n+1))/2\n    \
    \    val numOfOnesInner = numOfStartingOnes + numOfEndingOnes - 1\n        numOfOnesInner",
  '        // Your code here.', "        val counter = mutable.TreeSet[Long]()\n \
    \       for( i <- 1 to n ) counter += i\n        counter.size", "        var num\
    \ : Long = 1\n        var nums : List[Long] = List()\n        while (n != 0) {\n\
    \            num *= 10\n            num += n % 10\n            n = (n - n % 10)\
    \ / 10\n            nums += num\n        }\n        nums.sum", "        var count\
    \ = 0\n        var start = 1\n        var end = n\n        while (end > 1) {\n\
    \            var mid = math.floor((start + end) / 2)\n            if (mid == 1)\n\
    \                count += 1\n            else if (start == end)\n            \
    \    break\n            else if (mid != 1)\n                count = count + 1\n\
    \            if (mid < n)\n                start = mid\n            else\n   \
    \             end = mid\n        }\n        count", "        val count = new mutable.HashSet[Long]()\n\
    \        // add 1 to all the digits of n\n        val n = n + 1\n        val digit\
    \ = n.toString.reverse.dropRight(1)\n        val start = 1\n        val stop =\
    \ digit.length\n        for (i <- 1 to stop) {\n            // if ith digit is\
    \ even, that means a starting digit of 1\n            if (digit(i).length == 0\
    \ || digit(i).charAt(0) == '0') {\n                count.add(start)\n        \
    \        start += 1\n            }\n            // if ith digit is odd, that means\
    \ an ending digit of 1\n            else if (digit(i).charAt(0) == '1') {\n  \
    \              count.add(start)\n                start += 1\n            }\n \
    \           // if digit(i).charAt(i) is 1, that means a number that starts with\
    \ 1\n            // and ends with 1 or ends with 0\n            else if (digit(i).charAt(i)\
    \ == '1') {\n                count.add(start)\n                start += 1\n  \
    \          }\n        }\n        count.size", "        if (n == 0)\n         \
    \   return 1\n        var counter = 1\n        while (n > 0)\n        {\n    \
    \        if (n % 10 == 1)\n                counter += 1\n            n /= 10\n\
    \        }\n        return counter", "        if(n < 1000) return 1\n        if(n\
    \ < 10000) return 2\n        if(n < 100000) return 3\n        if(n < 1000000)\
    \ return 4\n        if(n < 10000000) return 5\n        if(n < 100000000) return\
    \ 6\n        if(n < 1000000000) return 7\n        if(n < 10000000000) return 8\n\
    \        if(n < 100000000000) return 9\n        if(n < 1000000000000) return 10\n\
    \        if(n < 10000000000000) return 11\n        if(n < 100000000000000) return\
    \ 12\n        if(n < 1000000000000000) return 13\n        if(n < 10000000000000000)\
    \ return 14\n        if(n < 1000000000000000000) return 15\n        return 0",
  "        if(n <= 0) {\n            return 0\n        }\n        val counts : mutable.Map[Long,\
    \ Int] = mutable.Map()\n        for(x <- 0 until n){\n            val digit =\
    \ math.floor(x / 10.0)\n            if(counts(digit) > 0) {\n                counts(digit)\
    \ += 1\n            } else {\n                counts(digit) = 1\n            }\n\
    \        }\n        counts.filter { case (key, value) => value == 1}.size", " \
    \       // Your code here\n        val retVal =  Long.MaxValue\n        val nums\
    \ = Vector.empty[Long]\n        while (n > 0) {\n            if (n % 10 == 1)\
    \ {\n                nums(n) = nums(n) + 1\n                n = n / 10\n     \
    \       }\n            else {\n                n = n / 10 + 1\n            }\n\
    \        }\n        var count = 0\n        for (i <- nums) {\n            if (i\
    \ == 1) {\n                count ++\n            }\n        }\n        return\
    \ retVal", "        if (n == 0)\n            return 0\n        val one = BigInt(1)\n\
    \        val starts = mutable.ListBuffer(BigInt(0)).withDefaultValue(0)\n    \
    \    val ends = mutable.ListBuffer(BigInt(0)).withDefaultValue(0)\n        val\
    \ iter = mutable.Stack.empty[Long]\n        while (n > 1) {\n            iter\
    \ += n\n            n = n - one\n            if (n % one == 0) starts += n\n \
    \           else if (n % one == 0) ends += n\n        }\n        val answer =\
    \ ends - starts\n        iter.foreach { x =>\n            answer = answer - x\n\
    \        }\n        return answer.get", "      var count = 0\n      var sum :\
    \ Long = 0\n      for(i <- 0 to n-1) {\n        if(i % 2 == 0) {\n          if(sum\
    \ == 0) {\n            sum = i\n          } else if(sum != i) {\n            count\
    \ += n - sum\n            sum = 0\n          }\n        }\n      }\n      count\
    \ += n - sum\n      count", "        val count = mutable.MutableList[Long]()\n\
    \        val digits = n.toString\n        val len = digits.length\n        for\
    \ (i <- 0 until len) {\n            val one = digits.charAt(i) == '1'\n      \
    \      if (one) {\n                if (count == List(1L)) {\n                \
    \    count += 1\n                } else if (count.last == 1L && i < len - 1) {\n\
    \                    count += 1\n                } else {\n                  \
    \  break\n                }\n            } else {\n                if (count ==\
    \ List(1L)) {\n                    count -= 1\n                } else if (count.last\
    \ == 1L && i < len - 1) {\n                    count -= 1\n                } else\
    \ {\n                    break\n                }\n            }\n        }\n\
    \        return count", "        val map = mutable.LinkedHashMap[Long, Long]()\n\
    \        var count = 0\n        var last = 0\n        for(i <- 1 to n) {\n   \
    \         if(i % 10 == 1) {\n                if(map.contains(last)) {\n      \
    \              count += map.get(last)\n                    map.remove(last)\n\
    \                } else {\n                    count += 1\n                }\n\
    \            }\n            last = i\n        }\n        count += map.get(n)\n\
    \        map.remove(n)\n        count", "        if(n > 0)\n          startsOneEnds(n-1)\
    \ + n.toString.indexOf(\"1\".toCharArray()) == 0\n        else\n          0\n\
    \      }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis code doesn't do what the\
    \ OP asked in his original post: \"**Print the number of n-digit positive integers\
    \ that start or end with 1.**\"\n<|/ c |>\n<| c |>\nI think he meant \"print the\
    \ number of integers that start or end with 1\" - i.e. count the numbers that\
    \ begin with 1 or end in 1\n<|/ c |>\n<| c |>\nNo, it does what the OP asked:\
    \ _\"Print the number of n-digit positive integers that start or end with 1.\"\
    _\n<|/ c |>\n<| c |>\nSorry for asking this question, i misinterpreted the question.\
    \ BTW, why does it print the number of n-digit positive integers?\n<|/ c |>\n\
    <| c |>\nAh, sorry, I missed that part. Well, the first part of the answer is\
    \ still correct but you need to change `n > 0` to `n>0L`\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere's an O(n) solution:\n<code>\ndef countingNumbersStartsWithOne(n: Long):\
    \ Long = {\n  if (n == 0) return 0\n  val counters = mutable.Map[Int, Long]()\
    \ // To keep track of the number of times each number starts or ends with 1\n\
    \  def loop(i: Int): Unit = {\n    if (i >= n) return\n    if (counters(i) < i)\
    \ counters(i) = 1\n    if (i == n) counters(i) = counters(i) + 1\n    else loop(i\
    \ + 1)\n  }\n  loop(0)\n  counters.size * (counters.size / n)\n}\n</code>\nLet's\
    \ break it down.\n\nWhen you encounter the number n, you need to know if it starts\
    \ with 1 or ends with 1. The number n can't start or end with anything else (because\
    \ of the limitation of the task). So we build a map of integers that start or\
    \ end with 1, to count how many times they appear.\n\nIf n >= n, it won't start\
    \ or end with 1, so we return 0.\n\nIf n = 0 or n = 1, then we know that we have\
    \ to return the number of times they appear.\n\nOtherwise, we call loop to go\
    \ over the numbers 1...n and count how many times each one appears. We increment\
    \ the counters by one if the number starts with 1 (or increments by one if the\
    \ number ends with 1). Remember that we're counting how many times each number\
    \ starts or ", "        var count = 0;\n        val digits = n.toString.reverse\n\
    \        for (i <- 0 until digits.length) {\n            if ((digits(i).charAt(0)\
    \ == 1) || (digits(i).charAt(0) == -1)) {\n                count = count + 1\n\
    \            }\n        }\n        return count", "        var count = 0L\n  \
    \      for(i <- 1 to n if i.toString.size == 1 && (i.toString.charAt(0) == 1 ||\
    \ i.toString.charAt(i) == 1)) {\n            if(i % 10 == 1) {\n             \
    \   count += 1\n            } else {\n                break\n            }\n \
    \       }\n        return count", "        val count = new mutable.HashMap[Long,\
    \ Long]()\n        var i = n\n        while(i != 0){\n            val temp = new\
    \ BigDecimal(i)\n            val one = temp.toPlainText().substring(0,1)\n   \
    \         val prev = count.get(one)\n            count.put(one, (prev match {\n\
    \                case Some(x) => x + 1\n                case None => 1\n     \
    \       }))\n            i = math.max(math.min(i/10,10),1)\n        }\n      \
    \  count.values.toList.length", "        var count = 0L\n        for (x <- 1 until\
    \ n) {\n            if (n == x) { count += 1L } else { count += 0L }\n       \
    \ }\n        count", "        val res = mutable.ArrayBuffer.empty[Int]\n     \
    \   val ones = mutable.ArrayBuffer.empty[Int]\n        var cnt = 0\n        for(i\
    \ <- 0 until n + 1){\n            if(i % 10 == 0){\n                ones += i\n\
    \            }else{\n                if(ones == 1){\n                    res +=\
    \ cnt\n                    cnt = 0\n                }\n                ones =\
    \ mutable.ArrayBuffer.empty[Int]\n                cnt += 1\n            }\n  \
    \      }\n        res += cnt\n        cnt", "        val onesCount = mutable.ListBuffer(Long.MinValue\
    \ + n)\n        onesCount += n\n        onesCount foreach { n => while(n > 1){\n\
    \            if(n % 10 == 1)\n                onesCount += n\n            n /=\
    \ 10\n        }}\n        onesCount.length", "        var count = 0L;\n      \
    \  for (i <- 1 to n) {\n            if (i%10 == 1) {\n                count +=\
    \ 1L;\n            }\n            if (i%10 == 0) {\n                count -= 2L;\n\
    \            }\n        }\n        count;", "        var count = 0\n        var\
    \ low = 0\n        var high = math.min(n - 1, 10000000)\n        while (low <\
    \ high) {\n            if (isOneStart(low)) {\n                if (isOneEnd(high))\
    \ {\n                    count += 1\n                } else {\n              \
    \      low += 1\n                }\n            } else if (isOneEnd(low)) {\n\
    \                count += 1\n                low = math.min(low, high)\n     \
    \       } else {\n                high -= 1\n            }\n        }\n      \
    \  return count", "        var count = 0\n        while (n > 1) {\n          \
    \  n -= (n / 10L)\n            count += 1\n        }\n        count = 0\n    \
    \    while (n < 1) {\n            count += 1\n            n = n * 10L + 1\n  \
    \      }\n        count += n / 10L\n        count += (n % 10L)\n        count",
  "        val start = List(1, -1)\n        val end = List(-1, 1)\n        val counts\
    \ = mutable.TreeSet[Long]()\n        for (i <- 1 to n by 1) {\n            val\
    \ digit = math.abs(math.floor(i/10d))\n            counts += digit + 1\n     \
    \       if (digits.contains(digit)) {\n                if ((i mod 10) == 1) counts(digit)\
    \ += 1\n                if ((i mod 10) == -1) counts(digit) += 1\n           \
    \ }\n        }\n        for (d <- 1 to digits.size) {\n            assert(counts(d)\
    \ == counts.count(d % 10) + 1)\n        }\n        assert(counts.count(1) == n\
    \ * (n+1) / 2)\n        return counts(1)", "        var num : Int = 0\n      \
    \  var count : Int = 0\n        // The first and last numbers are 1 or n depending\
    \ on whether \n        // starts or ends with 1\n        var nums = if (n == 1)\
    \ List(1) else Seq(n).reverse.takeWhile(x => x > 0).reverse\n        \n      \
    \  for (i <- nums) {\n            num += 1\n            if (num == n) count +=\
    \ 1\n        }\n        return count", "        val a = scala.collection.mutable.Queue[Long]()\n\
    \        val b = new scala.collection.mutable.Queue[Long]()\n        var count\
    \ = 0\n        for (i <- 1 to n)\n            if (i.toString.charAt(0) == '1')\
    \ a.enqueue(i)\n            else b.enqueue(i)\n        while (!a.isEmpty) {\n\
    \            val next = a.poll\n            if (next.toString.charAt(0) == '1')\
    \ count += 1\n            else b.enqueue(next)\n        }\n        while (!b.isEmpty)\n\
    \            count += b.dequeue\n        count", "        val count = new mutable.HashMap[Long,\
    \ Long]()\n        for (i <- 1 to n if i.toString.charAt(0) == 1) {\n        \
    \    count.update(i.toString.toLong, count.getOrElse(i.toString.toLong, 0) + 1)\n\
    \        }\n        count.getOrElse(n, 0L)", "        def isOne(n: Int) : Boolean\
    \ = (n % 10) == 1\n        def countOnes(n : Long) : Long = {\n            val\
    \ result = new Array[Long](100).fill(0)\n            val max = Long.MaxValue /\
    \ 10\n            for(i: Int <- 1 to (n/10) + 1){\n                val temp =\
    \ i\n                while(temp > 0){\n                    val digit = temp %\
    \ 10\n                    if(isOne(digit)){\n                        result(digit)\
    \ += 1\n                    }\n                    temp /= 10\n              \
    \  }\n            }\n            val c = n - 1\n            while((c > 0) && (result[c]\
    \ == 0L)) {\n                c -= 1\n            }\n            result(c)\n  \
    \      }\n        val total: Long = countOnes(n)\n        total / n", "      \
    \  val num = mutable.ListBuffer.empty[Long]\n        val temp = n.abs\n\n    \
    \    while(temp > 0) {\n            num :+= temp % 10\n            temp = temp\
    \ / 10\n        }\n        val ans = mutable.ListBuffer.empty[Long]\n\n      \
    \  val oneStart = num.filter(p => p % 2 == 1)\n        val oneEnd = num.filter(p\
    \ => p % 2 == 0)\n        val oneEndInBoth = oneEnd.filter( p => oneStart.contains(p))\n\
    \        val oneStartInBoth = oneStart.filter( p => oneEnd.contains(p))\n\n  \
    \      if (oneStartInBoth.length == 0 || oneEndInBoth.length == 0) {\n       \
    \     return ans.length\n        }\n\n        val oneStartInBothReversed = oneStartInBoth.reverse\n\
    \        val oneEndInBothReversed = oneEndInBoth.reverse\n        var i = 0\n\
    \        while(i < oneStartInBothReversed.length) {\n            ans :+= oneEndInBothReversed(i)\
    \ - oneStartInBothReversed(i)\n            i = i + 1\n        }\n        ans.length",
  "        var count = 1\n        val ones = mutable.Set(1)\n        while(n > 0)\
    \ {\n            n %= 10000000\n            if (n % 10 == 1) {\n             \
    \   ones += 1\n            }\n            n /= 10\n            count += 1\n  \
    \      }\n        ones.toLong", "        var count = 0\n        val isEven = n%2\
    \ == 0\n        for(i <- 0 until n) {\n            if(i == 0 && !isEven) {\n \
    \               count += 1\n            } else {\n                count += 1\n\
    \            }\n        }\n        count", "        val counts = mutable.HashMap[Int,\
    \ Int]()\n        for (i <- 0 to n by 2) {\n            counts.update(i,counts.getOrElse(i,0)+1)\n\
    \        }\n        for (i <- n.toInt to 0 by -1) {\n            counts.update(i,counts.getOrElse(i,0)+1)\n\
    \        }\n        counts.valuesIterator.filter(x => x==1).size", "        var\
    \ sum = 0L\n        for (i <- 1 to n by 2)\n            if (i%2==0) sum += i\n\
    \            else        sum -= i\n        sum", "      val ans = mutable.Map.empty[Long,\
    \ Long]\n      val nstr = n.toString\n      var sum = 1\n      for (i = 1 until\
    \ nstr.length) sum += nstr(i).toLong\n      for (i <- 0 until nstr.length) sum\
    \ += i.toLong\n      sum", "        val count = mutable.MutableList[Long]()\n\
    \        for(i <- 1 to n) {\n            val str = i.toString.toCharArray\n  \
    \          if( str.exists(i => i == '1')) count += i\n        }\n        count.length",
  "        var count = 0L\n        var last1 = n%10\n        while(last1 > 1){\n \
    \           last1 = last1/10\n            count = count + 1L\n        }\n    \
    \    return count", "        val s = Seq.fill(n + 1 - n.toInt)(\"1\")\n      \
    \  val d = Seq.fill(n + 1 - n.toInt)(\"0\")\n        val p = Seq.fill(n + 1)(\"\
    0\").zip(d)\n        s.count(p => p(0) != p(1))", "        var result = 1\n  \
    \      var k = n\n        while(k >= 10) {\n            result += 1\n        \
    \    k = k / 10\n        }\n        return result", "        var count = 0\n \
    \       for (i <- 1 to n + 1){\n            if (i%10 == 1) count += 1\n      \
    \  }\n        count", "        val result = mutable.MutableList(new collection.mutable.Stack[Long]())\n\
    \        val ones = new collection.mutable.HashSet[Long]()\n        for (i<-0\
    \ to n-1) ones += 1\n        for (i<-0 to n-2) ones += 1\n        ones.add(1)\n\
    \        var count = 0\n        for (i<-0 to n-2) {\n            ones.remove(one(i))\n\
    \            result push ones\n        }\n        count", "        val x = Math.sqrt(n)\n\
    \        var count = 0\n        var pow = math.pow(x-1,2)\n        var i = 2\n\
    \        while(pow>0) {\n            if (pow%i == 0) {\n                count\
    \ = count + 1\n            }\n            pow = pow/i\n        }\n        count",
  "        val arr = Array.ofDim[Long](n+1)\n        for ( i <- 0 until n ) {\n  \
    \          arr(i) += 1\n            arr(n) += 1\n        }\n        for ( (start,\
    \ end) => start == 1 && end == 1 ) yield arr.indexOf(1)", "        val result\
    \ = 0\n        val ones = n / 10\n        val tens = n % 10\n        if(ones %\
    \ 2 == 0) {\n            result = (tens * 10) + ones\n        }\n        result",
  "        // Write your code here\n        var sum : Long = 0\n        for(i <- 1\
    \ to n){\n            sum += if(n % i == 0) 1 else 0\n        }\n        return\
    \ sum", "        val res : mutable.MutableList[Long] = mutable.MutableList(1L)\n\
    \        val m = n.toString.reverse.length\n        for (_ <- 0 to m - 1) res\
    \ += 1\n        (for (i <- 1 to n) if (res(i) == 1) 1 else 0L).sum", "       \
    \ val counts  = mutable.HashMap[Int, Long]()\n        var result = 0\n       \
    \ for(i <- 1 to n){\n            val x = i/10\n            val y = i%10\n    \
    \        val start = if (x==1 && y==1) 1 else 0\n            val end = if (y==1)\
    \ 1 else 0\n            val val = start + (end+1) * x\n            val oldCount\
    \ = counts.getOrElse(val, 0L)\n            result += oldCount\n            counts.put(val,\
    \ oldCount + 1)\n        }\n        result", "        val count = new mutable.HashMap[Long,Int]()\n\
    \        val arr = new Array[Long](n)\n        arr(0) = 1\n        arr(n-1) =\
    \ 1\n        var i = 2\n        while (i < n) {\n            val c = arr(i)\n\
    \            var j = 0\n            while (j < i) {\n                if (arr(j)\
    \ == 1) {\n                    if (i == j) {\n                        count.put(c,\
    \ 1)\n                    } else if (arr(j+1) != 1 && arr(j) != 0) {\n       \
    \                 count.put(c, 1)\n                        break\n           \
    \         }\n                    j += i\n                } else {\n          \
    \          if (arr(j) != 1) {\n                        count.put(c, 1)\n     \
    \                   break\n                    }\n                    j += 1\n\
    \                }\n            }\n            i += 2\n        }\n        count.size",
  "        val arr = (1 to n).toArray\n        val s = arr.filter (x => x % 10 ==\
    \ 1)\n        val e = arr.filter (x => x % 10 != 1)\n        val sum: Long = e.sum\
    \ - s.sum\n        sum", "        // Write your code here\n        var count =\
    \ 0L\n        val arr = mutable.ArrayBuffer.fill(n)(0)\n        for(i <- arr until\
    \ (arr.size - 1) if(arr(i) == 1)) {\n            count += 1\n        }\n     \
    \   count", "        val numbers = List.fill(n - 1)(1).reverse\n        numbers(0)\
    \ should be(true)\n        var count = 0\n        for(i <- 1 until n)\n      \
    \      if (numbers(i) == 1)\n                count += 1\n        return count",
  "        var ans = 0 \n        for( i <- 0 to n ) {\n            ans = ans + math.pow(i,(i+1))\
    \ \n        }\n        return ans", "        val n = n.toInt\n        val ones\
    \ = Vector(1,2,3,4,5,6,7,8,9,0)\n        val zeros  = Vector(0,1,2,3,4,5,6,7,8,9,0)\n\
    \        if(n < ones.size) {\n            return 0\n        } else if(n == ones.size)\
    \ {\n            return 1\n        }\n        val l = ones.size - n\n        val\
    \ r = zeros.size-n\n        if(ones.head < ones.last && ones(l) == 1 && ones.head\
    \ < zeros(l)) {\n            return 1\n        } else if(ones.last > ones.head\
    \ && ones(l) == 1 && ones.last > zeros(l)) {\n            return 1\n        }\
    \ else if(ones.head > ones.last && ones(l) == 1 && ones.head > zeros(l)) {\n \
    \           return 1\n        } else {\n            return 0\n        }", "  \
    \      val ones = Vector(1, oneOfTheDigits(n))\n        val onesSet = ones._\n\
    \        val onesIter = onesSet.iterator\n        var count = 0L\n        while\
    \ (onesIter.hasNext) {\n            if (onesIter.next() == 1)\n              \
    \  count += 1\n        }\n        count", "        var result = 0\n        val\
    \ list = mutable.ListBuffer[Long]()\n        while (n > 0) {\n            list\
    \ += n % 10\n            n /= 10\n        }\n        for ( i <- list ) if ( i\
    \ == 1 ) result += i\n        result", "        val counts = mutable.HashMap[Long,\
    \ Long]()\n        (1 until n).foreach { i =>\n            if (i.toString.toInt==1)\n\
    \                counts.put(i)\n        }\n        (1 until n).foreach { i =>\n\
    \            if (i.toString.toInt==n)\n                counts.put(n)\n       \
    \ }\n        counts.foldLeft(0) { (acc, i) => (acc._1 + i._1.toString.toInt, acc._2\
    \ + i._2.toString.toInt) }._1", "        val onesCount = List.newBuilder[Long]\n\
    \        for (i <- 0 to n-1 step 1) {\n            if (i == 0 || i%3 == 0) onesCount.add(1)\n\
    \            else onesCount.add(-1)\n        }\n        onesCount.result()", " \
    \       // 1. n is positive\n        if (n < 1) {\n            return 0\n    \
    \    }\n        // 2. n is odd\n        if (n%2 == 1) {\n            return 0\n\
    \        }\n        // 3. n is even\n        var count = 0\n        // 4. n is\
    \ odd and even\n        for (i = 3; i * i <= n; i += 2) {\n            count =\
    \ count + 1\n        }\n        return count", "        val ones = mutable.Set[Int](1)\n\
    \        val start = 1\n        val end = 2\n        var count = 0\n        while\
    \ ( n >= end ) {\n            n = n / end\n            count += 1\n          \
    \  if ( n > 1 ) {\n                ones.add(end)\n            }\n        }\n \
    \       while ( n >= start ) {\n            n = n / start\n            count +=\
    \ 1\n            if ( n > 1 ) {\n                ones.add(start)\n           \
    \ }\n        }\n        count + ones.size - 1", "        var numStarts = 0\n \
    \       for ( i <- 1 to n ) {\n            if( i.toString.charAt(0) == '1' ) {\n\
    \                numStarts += 1\n            }\n        }\n        numStarts",
  "        val ones = Array.fill(100000){1L}\n        for (i <- 1 to n) ones += 0L\n\
    \        ones.count(_ == 1) + (ones.count(_ == -1) - 1)", "        val res = mutable.ListBuffer[Long]()\n\
    \        var i = n\n        var rem = n\n        while (i > 0) {\n           \
    \ if (rem % 10 == 1)\n                res += rem\n            rem /= 10\n    \
    \        i -= 1\n        }\n        res.size", "        val counter = new mutable.HashMap[Long,\
    \ Long]\n        for(i <- 0 until (n/10))\n            if(n % 10 == 1 && i !=\
    \ n/10)\n                counter(n/10, 1) = counter(n/10, 1) + 1\n           \
    \     counter(i, 1) = counter(i, 1) + 1\n        counter(n/10, 1)", "        var\
    \ count = 0\n        // For each number from 1 to n\n        for (i = 1 until\
    \ n) count += n.toString.toInt.toString.length\n        // For each number from\
    \ 1 to n and subtract 1 from it\n        for (i = 1 until n) count += n-i.toString.toInt.toString.length\n\
    \        count -= n.toString.toInt.toString.length\n        return count", " \
    \       var count = 0\n        for (i <- 1 to n) {\n            val remainder\
    \ = n % i\n            if (remainder == 0) {\n                count += 1\n   \
    \         } else {\n                break\n            }\n        }\n        return\
    \ count", "        val ones = mutable.ArrayBuffer(n+1)\n        ones.update(0,\
    \ ones.length)\n        var cnt = 0\n        var cnt2 = 1\n        var i = 1\n\
    \        while(i < ones.length && ones(i) == 1) {\n            if((ones(i-1)+ones(i))\
    \ == ones(i-1)) {\n                cnt += 1\n            }\n            else {\n\
    \                cnt2 += 1\n            }\n            i +=1\n        }\n    \
    \    cnt", "        val count = (n to 1 by -1)\n            .filter(i => i % 10\
    \ == 1)\n            .size\n        val divisor = (n to 1 by -1)\n           \
    \ .filter(i => i % 10 != 1)\n            .map(i => i * i)\n            .sum\n\
    \        (count + divisor) / 2", "        val counts = mutable.HashMap.empty[Long,Int]\n\
    \        // Add one to the power of n\n        val power = n.toInt\n        for\
    \ (i: Long <- 0 until power) counts(i.toInt) = 1\n        val ones = mutable.ArrayBuffer.fill(power.toInt)(1)\n\
    \        // Then subtract the number of 1s\n        for (i: Long <- 0 until power)\n\
    \            if (counts(i.toInt) > 0) ones -= counts(i.toInt)\n        counts\
    \ -= ones.sum\n        // And sum the number of 1s\n        counts + (ones.sum\
    \ * ones.size)", "        val countMap = mutable.HashMap.empty[Int, Int]\n   \
    \     var count = 0L\n        for {\n            i <- n until 9 toList\n     \
    \   } countMap.update(i, countMap.getOrElse(i, 0) + 1L)\n        val count = (n-1L)*9\n\
    \        countMap.foreach { case (k,v) =>\n            if (v >= count) count +=\
    \ 1\n        }\n        count", "        val counts = mutable.HashMap[Int, Int]()\n\
    \        val n = math.min(math.ceil(n/10), 10000).toInt\n        for (i <- 1l\
    \ to n) {\n            val digits = (i.toLong - math.pow(10, i.toInt)).toInt\n\
    \            if (digits > 0 && digits < 10) {\n                val start = math.pow(10,\
    \ digits)\n                val end = math.pow(10, digits + 1)\n              \
    \  val start = math.min(start, 1)\n                val end = math.min(end, 1)\n\
    \                counts(start) = counts(start) + math.max(digits - 1, 0)\n   \
    \             counts(end) = counts(end) + math.max(digits + 1, 0)\n          \
    \  }\n        }\n        counts(1)", "        var i = 0\n        while (i < n){\n\
    \            if (i % 10 == 1){\n                i += 1\n            }else if (i\
    \ % 10 == 0){\n                i -= 1\n                i += 1\n            }else{\n\
    \                i += 1\n            }\n        }\n        \n        return i",
  "        var count = 0\n        for(i <- 1 to n by 2){\n            if(i % 2 ==\
    \ 0){\n                count += 1\n            }\n        }\n        return count",
  "        var count = 0\n        for(i <- 0 until n){\n            if((i mod 10)\
    \ == 1){\n                count += 1\n            }\n        }\n        count",
  "        var count = 1\n        var result = 0\n        for(i <- 0 until (n)) {\n\
    \            val x = math.floor(i / Math.pow(10, n).toDouble)\n            if(i\
    \ % Math.pow(10, n).toDouble == 0 || i == 0){\n                count += 1\n  \
    \          }else if(math.floor(math.pow(x, n)).toDouble == x) {\n            \
    \    count += 1\n            }\n        }\n        result = count\n        \n\
    \        return result", "        var count = 0\n        var oneCount = 0\n  \
    \      var nums = scala.collection.mutable.ListBuffer[Long]()\n        for (i\
    \ <- 1 to n) {\n            if(i % 10 == 1) {\n                nums = nums + i\n\
    \                oneCount = oneCount + 1\n            }\n        }\n        if(oneCount\
    \ == 1) {\n            count = count + oneCount\n        }\n        for(i <- 0\
    \ until nums.size) {\n            if(nums(i) == 1) {\n                count =\
    \ count + 1\n            }\n        }\n        return count", "        if (n ==\
    \ 0) \n            return 0\n        val ones = scala.collection.mutable.ArrayBuffer(1)\n\
    \        ones.foldLeft(0){ (c,e) => c + ones.size+(e%10000000000==0) }", "   \
    \     var count = 0\n        for ( i <- 1 to n ) {\n            if ( n % i ==\
    \ 0 ) {\n                count += 1\n                if ( i * i == n ) count +=\
    \ 1\n            }\n        }\n        count", "        // We start by counting\
    \ the numbers of n-digit positive integers\n        // that start or end with\
    \ 1.\n        val sumOne = 1L\n        val oneCount = 0\n        // We need to\
    \ use an iterator because we might need to process the\n        // list in reverse\
    \ order, so we can't use for or while loops.\n        var listOfOnes : List[Int]\
    \ = List()\n        var i = 0\n        while (i < n) {\n            // Increment\
    \ oneCount only if listOfOnes is empty or n is a\n            // multiple of listOfOnes.length.\n\
    \            if (listOfOnes.isEmpty || n % listOfOnes.size == 0) {\n         \
    \       oneCount += 1\n            }\n            listOfOnes = listOfOnes :+ i\n\
    \            i += 1\n        }\n        return sumOne + oneCount", "        var\
    \ count = 0L\n        var start = 1L\n        for(i <- 1 until n){\n         \
    \   start = if (start > i) i else start\n            count += 1\n        }\n \
    \       count", "        val count = mutable.HashMap.empty[Long, Long]\n     \
    \   for(i <- 1 until n) if(i / 10 == 1) count.put(i, count.getOrElse(i, 0) + 1L)\n\
    \        count", "        var nDigit = 0\n        var nOne = 0\n        for (\
    \ num <- 1 until n) {\n            val remainder = num % 10\n            if (remainder\
    \ == 1) {\n                num / 10 += 1\n                nOne = nOne + 1\n  \
    \          }\n        }\n        nDigit = n - nOne\n        nOne", "        val\
    \ m = math.min(n % 10, n)\n        if (n == 0) 1 else math.min(m, math.floor(m\
    \ * (10 / n)))", "        var count=0\n        for (i <- 1 to Math.ceil(n/10))\
    \ \n            if (n%i==0 && n%(i+1).equals(1))\n                count+=1\n \
    \       if (count==0) return 0\n        return count", "        val digits = new\
    \ mutable.LinkedHashSet[Int]()\n        val ones = new mutable.ArrayList[Int]()\n\
    \        for (i = 1 to n)\n            digits += i\n        for (i <- 1 to n)\
    \ {\n            if (digits.contains(i))\n                ones += i\n        }\n\
    \        ones.filter(_ % 2 == 0).length", "        // Your code here\n       \
    \ val counters = mutable.ArrayBuffer.empty[Long]\n        for(i <- 1 to n){\n\
    \            if(i%2 == 0){\n                if(i % 3 == 0 || i % 5 == 0){\n  \
    \                  counters += i\n                }\n            }else if(i%2\
    \ != 0){\n                if(i % 3 == 0 || i % 5 == 0){\n                    counters\
    \ += i\n                }\n            }\n        }\n        counters.count(i\
    \ => i==1 || i==0)", "        // Base case\n        if (n < 1)\n            return\
    \ 0\n        // Count number of numbers starting with 1\n        var result =\
    \ 0\n        var current = 1\n        while(current < n)\n            result +=\
    \ 1\n            current = current * 10 + result\n        return result", "  \
    \      // Initialize result to a long which is zero\n        var result = 0\n\
    \        val l = math.abs(n)\n        for (i <- 1 to l) {\n            // if n\
    \ is greater than or equal to i^2 then increment result by one\n            if\
    \ (math.pow(i, 2) == n) {\n                result += i\n                // when\
    \ n is less than i^2 but greater than or equal to i\n            } else if(math.pow(i,\
    \ 2) > n) {\n                break\n            }\n        }\n        // return\
    \ result\n        return result", "        val result = new Array[Long](10).fill(0)\n\
    \        result(n-10) = result(n-10)+1\n        result(n-9) = (result(n-9)+(n-10)%9==0)+1\n\
    \        result(n-8) = (result(n-8)+(n-9)%8==0)+1\n        result(n-7) = (result(n-7)+(n-8)%7==0)+1\n\
    \        result(n-6) = (result(n-6)+(n-7)%6==0)+1\n        result(n-5) = (result(n-5)+(n-6)%5==0)+1\n\
    \        result(n-4) = (result(n-4)+(n-5)%4==0)+1\n        result(n-3) = (result(n-3)+(n-4)%4==0)+1\n\
    \        result(n-2) = (result(n-2)+(n-3)%4==0)+1\n        result(n-1) = (result(n-1)+(n-2)%4==0)+1\n\
    \        result(n) = (result(n)+(n-1)%4==0)+1\n        result(n+4) = (result(n+4)+(n+3)%4==0)+1\n\
    \        result(n+5) = (result(n+5)+(n+4)%4==0)+1\n        result(n+6) = (result(n+6)+(n+5)%4==0)+1\n\
    \        result(n+7) = (result(n+7)+(n+6)%4==0)+1\n        result(n+8) = (result(n+8)+(n+7)%4==0)+1\n\
    \        result(n+9) = (result(n+9)+(n+8)%4==0)+1\n        result(n+10) = (result(n+10)+(n+9)%4==0)+1\n\
    \        result(n+11) = (result(n+11)+(n+10)%4==0)+1\n        result(n+12) = (result(n+12)+(n+11)%4==0)+1\n\
    \        result(n+13) = (result(n+13)+(n+12)%4==0)+1\n        result(n+14) = (result(n+14)+(n+13)%4==0)+1\n\
    \        result(n+15) = (result(n+15)+(n+14)%4==0)+1\n        result(n+16) = (result(n+16)+(n+15)%4==0)+1\n\
    \        result(n+17) = (result(n+17)+(n+16)%4==0)+1\n        result(n+18) = (result(n+18)+(n+17)%4==0)+1\n\
    \        result(n+19) = (result(n+19)+(n+18)%4==0)+1\n        result", "     \
    \   if (n == 0)\n            return 0\n        val starts = mutable.MutableList(1L)\n\
    \        val ends = mutable.MutableList(1L)\n        val count = new mutable.MutableList[Long]\n\
    \        for (i <- 2L until (n * n)) {\n            if (n % i == 0) {\n      \
    \          for (j <- i * i until (n / i)) {\n                    if (j % i ==\
    \ 0) {\n                        starts += j\n                        count  +=\
    \ 0\n                    }\n                    else {\n                     \
    \   ends += j\n                        count  += 1\n                    }\n  \
    \              }\n            }\n        }\n        return starts.length + ends.length\
    \ + count.length", "        if(n == 0) return 0\n        if(n == 1) return 1\n\
    \        var count = 0\n        while(n > 0) {\n            var temp = n % 10\n\
    \            if(!temp) temp = n\n            if(temp == 1) count += 1\n      \
    \      n /= 10\n        }\n        count", "        var counter = 0\n        while\
    \ (n > 0){\n            if (n%10==1) counter = counter + 1\n            n = n/10\n\
    \        }\n        return counter", "        val ones = mutable.Set[Long]()\n\
    \        for (i <- 0 until n){\n            val curr = i\n            val digits\
    \ = i.toString.length\n            while (curr > 0){\n                val curDigit\
    \ = curr % 10\n                if (curDigit != 0){\n                    if (curDigit\
    \ == 1)\n                        ones -= 1\n                    ones +=1\n   \
    \             }\n                curr /= 10\n            }\n        }\n      \
    \  ones.toSet.size", "        if (n < 1) return 0\n        if (n == 1) return\
    \ 1\n        var result = 0\n        for (i = 1 until n) {\n            val remainder\
    \ = n % i\n            if (remainder == 0) {\n                result = result\
    \ + 1\n            } else if (i == n) {\n                result = result + 2\n\
    \            } else {\n                result = result + 1\n            }\n  \
    \          n = i\n        }\n        result", "        val start = ArrayBuffer(1)\n\
    \        val end = ArrayBuffer(1)\n        val isStartOne = false\n        val\
    \ isEndOne = false\n        for (i <- 1 to n){\n            if (isStartOne){\n\
    \                if (start.length == n){\n                    start.clear()\n\
    \                }\n                else {\n                    start.append(i)\n\
    \                }\n            }\n            else if (isEndOne){\n         \
    \       if (end.length == n){\n                    end.clear()\n             \
    \   }\n                else {\n                    end.append(i)\n           \
    \     }\n            }\n            else if (i == 1){\n                isStartOne\
    \ = true\n            }\n            else if (i == n){\n                isEndOne\
    \ = true\n            }\n        }\n        start.length", "        def countOne(n\
    \ : Long) : Long = if(n > 1) (n % 10 == 1) else 0\n        def countOnes(m : Long)\
    \ : Long = for(i <- m) yield countOne(i)\n        if(n < 1) return 0\n       \
    \ val count = countOnes(n)\n        val end = n%10\n        val starts = countOnes(n+1)\n\
    \        val totalStart = starts + countOnes(m+end)\n        totalStart", "  \
    \      if (n == 0) { return 0 }\n        val startsWithOne = math.ceil(math.log10(n))\
    \ * n == n\n        var sum : Long = 0L\n        val counts = mutable.MutableList.fill(n-1)(1L)\n\
    \        val sums = mutable.MutableList.fill(n-1)(1L)\n        for (i <- 0 until\
    \ n) {\n            if (startsWithOne && i % 10 == 1) {\n                val index\
    \ = i.toLong\n                val value = counts(index) + 1\n                sum\
    \ += value\n                sums(index) += value\n                counts(index)\
    \ = value\n            } else {\n                if (i % 10 != 0) {\n        \
    \            val index = i.toLong\n                    val value = counts(index)\
    \ + 1\n                    sum += value\n                    sums(index) += value\n\
    \                    counts(index) = value\n                }\n            }\n\
    \        }\n        sum", "        // Use array instead of list for better performance\n\
    \        val array = new Array[Long](n)\n        var count = 0\n        for(i\
    \ <- 1 to n) {\n            array(i) = i\n            if(array(i) startsWith 1)\
    \ {\n                count += 1\n                array(i) = -1\n            }\n\
    \            if(array(i) endsWith 1) {\n                count += 1\n         \
    \       array(i) = -1\n            }\n        }\n        return count", "    \
    \    def count(n : Long) : Long = {\n            var count = 0\n            val\
    \ startsWithOne = (n / 1000000000 % 1000) == 0 && (n / 100 % 100) == 0 && (n /\
    \ 10 % 10) == 1 && (n % 10) == 0\n            val endsWithOne = (n / 1000000000\
    \ % 1000) == 0 && (n / 100 % 100) == 0 && (n / 10 % 10) == 1 && (n % 10) == 1\n\
    \            if (startsWithOne && endsWithOne) count = count + 1\n           \
    \ count\n        }\n        count(n)", "        val count = 0\n        for(i <-\
    \ 1 until n){\n            val s = i.toString\n            if(s.charAt(0) == 1\
    \ && (s.charAt(s.length - 1)) == 1){\n                count += 1\n           \
    \ }\n        }\n        count", "       var counter : Long = n \n       var count\
    \ : Long = 0\n       while(n > 0){\n           if((n / 10) % 1 == 0) count +=\
    \ 1\n           n /= 10\n       }\n       counter = counter - count\n       return\
    \ counter", "        if (n == 1) {\n            return 0\n        } else if (n\
    \ < 1000) {\n            return 1\n        } else {\n            var count : Long\
    \ = 1\n            var start = 1\n            var end = n\n            var remainder\
    \ = n\n\n            while (start <= end) {\n                val mid = (start\
    \ + end) / 2\n                if (remain % mid == 0) {\n                    count\
    \ = count + 1\n                    start = mid + 1\n                } else {\n\
    \                    count = count + 0\n                    end = mid\n      \
    \          }\n                remainder = remain % mid\n            }\n      \
    \      return count\n        }", "        // Initialize an array to store the\
    \ count of numbers starting with 1 and ending with 1.\n        var array : Array[Long]\
    \ = new Array[Long](n+1)\n        // Initialize a variable that stores the count\
    \ of numbers starting with 1 and ending with 1.\n        var count : Long = 0\n\
    \        // Initialize a variable that stores the number of digits of the number.\n\
    \        var d : Long = 0\n        // Initialize a variable that stores the number\
    \ of digits of the number.\n        var c : Long = 1\n\n        // Call the method\
    \ to fill the array.\n        fillArray(array, n)\n\n        // Call the method\
    \ to find out the count of the numbers starting with 1 and ending with 1.\n  \
    \      var count : Long = findOneEnds(array, d, c)\n\n        return count", " \
    \       val counts = mutable.HashMap.empty[Long, Long]\n        for (i <- 1 to\
    \ n) {\n            if (counts(i) > 0) counts(i) = counts(i) + 1;\n          \
    \  else counts(i) = 1\n        }\n        val sum = 1\n        for (i <- 0 to\
    \ n) sum = sum * i + 1\n        val res = counts.getOrElse(sum, 0)\n        res",
  "        var count : Long = 0\n        val remainder = n\n        val ones = Long.MaxValue/10\n\
    \        var remainderDigit : Long = 0\n        while(count < ones) {\n      \
    \      count += 1\n            remainderDigit = remainder/10\n            if(remainderDigit\
    \ == 1){\n                count -= 1\n            }\n            remainder = remainderDigit\
    \ * 10\n        }\n        count += (remainder == 1)\n        ones = Long.MaxValue/10\n\
    \        while(count < ones) {\n            count += 1\n            remainder\
    \ = remainder/10\n            if(remainder == 1){\n                count -= 1\n\
    \            }\n        }\n        count += (remainder == 1)\n        return count",
  "        // 1. Scan the integers from 1 to n\n        // 2. For each integer in\
    \ the range 1..n, \n        //    a. if current number is 1, add 1 to a counter\n\
    \        //    b. if current number is 0, add 1 to another counter\n        //\
    \ 3. Return this counter value\n        val counters: mutable.HashMap[Long, Long]\
    \ = mutable.HashMap()\n        var count = 0\n        for (i = 1 until n){\n \
    \           val current = i - 1\n            if (counters.get(current) == null){\n\
    \                counters.put(current, 0)\n                count += 1\n      \
    \      } else if (i == 1){\n                count += 1\n            } else {\n\
    \                counters.put(current, counters.get(current) + 1)\n          \
    \  }\n        }\n        counters", "        val start = 0\n        val end =\
    \ 0\n        var num : Long = 0\n        while (n > 0) {\n            num = (n\
    \ % 10)\n            n /= 10\n            if (num == 0) {\n                start\
    \ = start + num\n            }\n            if (num != 0) {\n                end\
    \ = end + num\n            }\n        }\n        end - start", "        var oneCount\
    \ = 0\n        val oneToNine = List.fill(n)(1)\n        var first = 1\n      \
    \  while(oneCount < n){\n            var current = 0\n            oneCount +=\
    \ 1\n            val oneToNth = oneToNine.takeWhile(x => current != x)\n     \
    \       current = oneToNth.last\n            if(current == 1){\n             \
    \   oneCount += 1\n                oneToNine = oneToNth\n            }\n     \
    \   }\n        return oneCount", "        val startsOne = scala.collection.mutable.ListBuffer[Int]()\n\
    \        for (i = 1 to n by 2) {\n            val temp = i\n            if (temp\
    \ == 1 || temp == 0)\n                startsOne += temp\n        }\n        val\
    \ endsOne = scala.collection.mutable.ListBuffer[Int]()\n        for (i to n by\
    \ -2) {\n            val temp = i\n            if (temp == 0)\n              \
    \  endsOne += temp\n        }\n        return startsOne.size + endsOne.size",
  "        val counter = mutable.ArrayBuffer(0)\n        var i : Int = 0\n       \
    \ while (i != n) {\n            val d = math.pow((10).pow(i - 1),n).toInt\n  \
    \          if (d == 1 || d == 0) {\n                counter += d\n           \
    \ }\n            i += 1\n        }\n        return counter.length", "        var\
    \ count = 0L\n        for(i <- 0 to (n-1)) {\n            for(k <- i+1 to n) {\n\
    \                if (i==0 || i%10==1) && (k%10==1 || k==n) {\n               \
    \     count += 1\n                }\n            }\n        }\n        return\
    \ count", "        val ones = new mutable.ListBuffer[Long]()\n        var count\
    \ = 0\n        for(i <- 0 until n ) {\n            if (i % 10 == 1) {\n      \
    \          count += 1\n                ones += i\n            }\n        }\n \
    \       if (count == 0) {\n            count = 0\n        }\n        ones", " \
    \       var one = 0\n        var count = 0\n        for(x <- 1L until (n / 10))\
    \ {\n            if(x % 10 == 1) {\n                one = one + 1\n          \
    \      count = count + 1\n            }\n        }\n        if(one == n) {\n \
    \           count = count + 1\n        }\n        count", "        val counter\
    \ = mutable.HashSet[Long]()\n        for (i <- 1 until n by 1) {\n           \
    \ if (i % 100000000 == 0) {\n                if (i % 100000 == 0) {\n        \
    \            if (i % 10000 == 0) {\n                        if (i % 1000 == 0)\
    \ {\n                            counter.add(i)\n                        }\n \
    \                   }\n                }\n            }\n        }\n        counter.size",
  "        if (n==0) return 1\n        if (n==1) return 1\n        val r = scala.math.ceil(n)\n\
    \        val startsOneEnds = mutable.Stack()\n        for (i <- 1 until r){\n\
    \            if (i==1 || i*10==n) startsOneEnds.push(true)\n            else startsOneEnds.push(false)\n\
    \        }\n        if (startsOneEnds.isEmpty) 1\n        else startsOneEnds.last.dropWhile(x\
    \ => x).length", "        val counts = mutable.HashMap.empty[Long, Int]\n    \
    \    for {\n            i <- 1 to n\n            start <- isStart(i)\n       \
    \     end <- isEnd(i)\n        } yield {\n            counts.put(start, counts.get(start)\
    \ + 1)\n            counts.put(end, counts.get(end) + 1)\n        }\n        //\
    \ The count of n-digit positive integers that start or end with 1 is the\n   \
    \     // sum of the number of each of these positive integers.\n        counts.values.sum",
  "        val ones = new mutable.BitSet(100000000)\n        var count = 0\n     \
    \   while(ones.size < n)\n            ones.set(1)\n        if(ones.size < n)\n\
    \            count = 0\n        for(i <- 0 until n if ones.test(i+1))\n      \
    \      count += 1\n        return count", "        var count = 0L\n        for(i\
    \ <- 1 to n) if(i % 10 == 1) count += 1\n        count", "        val s = mutable.ListBuffer.empty[Long]\n\
    \        for(i <- 1 to n) {\n            if(!s.contains(i-1)) {\n            \
    \    s ++= i\n            }\n        }\n        s.distinct", "        if (n<0)\
    \ return 0\n        if (n==0) return 1\n        val nums = new mutable.HashSet[Long]()\n\
    \        nums.add(1)\n        var counter = 0\n        while (true) {\n      \
    \      if (nums.contains(n-1)) counter += 1\n            if (nums.contains(n+1))\
    \ counter += 1\n            if (counter>=n) return counter\n            nums.add(n+1)\n\
    \            nums.add(n-2)\n        }", "        if (n<0) 0\n        else if (n==0)\
    \ 1\n        else if (n==1) 1\n        else if (n==2) 1\n        else startsOneEnds(n/10)+1",
  "        val start = 1 until n\n        val count = mutable.HashMap()\n        start.foreach{\
    \ e => if (e % 2 == 0) count(e) += 1}\n        count(1L)", "        def countOne(n\
    \ : Long) : Long = {\n            if (n <= 0)\n                return 0\n    \
    \        val c = if (n % 10 == 1) 1 else 0\n            val n = n / 10\n     \
    \       if (n == 0)\n                return c + countOne(10*n + c)\n         \
    \   else\n                c + countOne(10*n + c)\n        }\n        countOne(n.toInt)",
  "        var count = 0L\n        val nums = mutable.ArrayBuilder.make[Int](n).grow(n\
    \ / 4).result\n        var i = 1L\n        for (i <- 1L until n)\n           \
    \ if (i.toString.size == n) nums(i) = nums(i) + 1\n        nums.toArray.takeWhile(x\
    \ => x >= 1L).filter(x => x == 1L).foreach(x => count = count + x) // Count how\
    \ many 1s\n        count * 2L", "        val starts = mutable.Set[Long]()\n  \
    \      def countStarts(x : Long) = if(x % 10 == 1) starts += x else false\n  \
    \      for(i <- 1 to n) if(i % 10 == 1) countStarts(i) //O(lgN)\n        starts.size\
    \ //O(lgN)", "        // First check if n is odd, in which case we have 0-1-1\n\
    \        if (n % 2 == 1) {\n            return 0\n        }\n        val zero\
    \ = new Array[Long](n)\n        val one = new Array[Long](n)\n        // Fill\
    \ all the digits with 0\n        for (i = 1 until n) {\n            zero(i-1)\
    \ = 0\n        }\n        // Fill the first digit with 1\n        one(0) = 1\n\
    \        // If n is odd, we start the counting from 1\n        // If n is even,\
    \ we start the counting from 0\n        if (n % 2 == 0) {\n            return\
    \ 1\n        }\n        return 1", "        var num = 0\n        for (i <- 1 to\
    \ n) {\n            if ((i % 10) == 1) {\n                num += 1\n         \
    \   }\n        }\n        num", "        val ones = Vector.fill(n / 10)(1)\n \
    \       val tail = n - (ones.length * 10)\n        val startsWithOnes = tail >\
    \ 0 ? ones.takeWhile(x => x % 10 == 1) : Vector.empty\n        val endsWithOnes\
    \ = tail > 0 ? ones.dropWhile(x => x % 10 == 1) : Vector.empty\n        val counts\
    \ = startsWithOnes.zip(endsWithOnes).countBy{_ == 1}\n        counts(0)", "  \
    \      val res = new scala.collection.mutable.ListBuffer[Long]()\n        val\
    \ digits = n.toString.reverse.grouped(9).toList\n        digits foreach { digit\
    \ =>\n            if(digit.toString.toLong == 1 || digit.toString.toLong == 10)\n\
    \                res.add(digit.toString.toLong)\n        }\n        res.length",
  "        var count = 0\n        for (x <- 1 to n by 1)\n        if (x.toString.toLong\
    \ == 1)\n            count += 1\n        count", "        val counts = mutable.HashMap[Int,\
    \ Int]()\n        var count = 0\n        for(i <- 1 to n) {\n            val digit\
    \ = i / 100 % 10\n            val remainder = i / 10 % 10\n            if(remainder\
    \ == 1 && digit = 1) count += 1 \n            else {\n                if(remainder\
    \ == 1 && digit = 0) counts(digit) = counts(digit) + 1\n                else {\n\
    \                    counts(digit) = counts(digit) + 1\n                }\n  \
    \          }\n        }\n        return counts(1)", "        var count = 0\n \
    \       for(i<-0 until(n) step n) { \n            if(i % n==0 && i /= n)\n   \
    \         count += 1\n        }\n        return count", "        val ones = mutable.Set()\n\
    \        for (x <- 0 until n) {\n            if (x % 10 == 1)\n              \
    \  ones += x\n        }\n        ones.count(n)", "        var cnt = 0L\n     \
    \   var start = n\n        while (n%10 != 0) {\n            cnt += 1\n       \
    \     n /= 10\n        }\n        var last = n\n        while(last%10 != 0) {\n\
    \            cnt += 1\n            last /= 10\n        }\n        cnt += (last\
    \ * last) % 11 < start\n        cnt", "        var sum : Long = 0\n        var\
    \ index : Long = 1\n        while (index<=n) {\n            if (index+1 <= n &&\
    \ index+2 == n && index+1 == n) {\n                sum += 1\n            }\n \
    \           index += 1\n        }\n        return sum", "        var count = 0\n\
    \        while (n > 0){\n            if (n % 10 == 1) {\n                count\
    \ += 1\n            }\n            n /= 10\n        }\n        return count",
  "        val a = n.toInt\n        var count = 0\n        var sum = 0\n        var\
    \ temp = 0\n        for(i <- a to 0 by -1) {\n            temp = i\n         \
    \   while(temp != 0) {\n                sum += temp % 10\n                temp\
    \ /= 10\n                count += 1\n            }\n        }\n        return\
    \ count", "        val res = new collection.mutable.ListBuffer[Int]()\n      \
    \  res += n\n        val i = n\n        while(i > 1) {\n            res += i /\
    \ 10\n            i /= 10\n        }\n        res -= 1\n        res", "      \
    \  val arr = mutable.ArrayBuffer(n)\n        var ans = 0\n        while (arr.nonEmpty)\
    \ {\n            val n = arr(0)\n            if (n == 1L && arr.nonEmpty) {\n\
    \                val next = arr(arr.length - 1L)\n                if (next ==\
    \ 1L) {\n                    ans += 1\n                }\n                arr.remove(0)\n\
    \            }\n            else if (n != 1L && n != arr.last()) {\n         \
    \       arr.remove(0)\n            }\n            else {\n                arr.remove(0)\n\
    \            }\n        }\n        ans", "        var count = 0L\n        var\
    \ num = 1L\n        val list = mutable.ArrayBuffer.empty[Long]\n        while\
    \ ( num < n ) {\n            val last = num % 10\n            if( last == 1 )\
    \ count += 1\n            else if( last > 1 )\n                list += num\n \
    \           num += 1\n        }\n        list.toList.length", "        val count\
    \ = mutable.ListBuffer(BigInt(1))\n        for(i <- 1 to n by 10) {\n        \
    \    val v = BigInt(i)\n            val t = v % 100\n            if(t == 1) count\
    \ += BigInt(1)\n        }\n        count.length", "        val counts = mutable.HashMap.empty[Long,\
    \ Long]\n        for (i <- 1 to n) {\n            val j = (i -1).toString.length\n\
    \            if (i.toString.charAt(j) != 1)\n                continue\n      \
    \      counts.mergeIfNotExists(j, i -> 1L, (_: Long,a: Long, b: Long) => a + b)\n\
    \        }\n        counts.size ", "        val num = scala.math.pow(n, -1).toInt\n\
    \        val nums = scala.collection.mutable.ArrayBuffer(n)\n        nums += n\n\
    \        val i = n - 1\n        var count = 0\n        val ones = new scala.collection.mutable.HashSet[Long]()\n\
    \        for (j <- 0 until i) {\n            val j = math.pow(10, j).toInt\n \
    \           if (j >= num) break\n            val test = nums.take(j)\n       \
    \     if (test == 1 && !ones.contains(test)) count += 1\n            ones += test\n\
    \        }\n        count", "        var ans = 0 // to store the number of starts-one,\
    \ ends-zero pairs\n        var nDigits = math.log10(n).toInt // the number of\
    \ digits in n\n        val ones = mutable.Set()\n        var zeros = mutable.Set()\n\
    \        // For each digit in the number n\n        for (i = 1 to nDigits-1) {\n\
    \            // if the current digit is 0\n            if (i % 10 == 0) {\n  \
    \              zeros += i.toLong // add i to zeros\n            }\n          \
    \  // else if the current digit is 1\n            else {\n                // if\
    \ the number is divisible by 10, it starts with a 1\n                if (n % i\
    \ == 0) {\n                    ones += i.toLong // add i to ones\n           \
    \     }\n                // if the number is divisible by 10, it ends with a 0\n\
    \                else {\n                    ans += (ones - zeros) * Math.pow(i.toLong,\
    \ (nDigits - i - 1))\n                    zeros = mutable.Set()\n            \
    \    }\n            }\n        }\n        ans += (ones - zeros) * Math.pow(nDigits,\
    \ nDigits)\n        ans", "        var counter : Long = 0\n        var number\
    \ : Long = 1\n        for(i <- 1 to n)\n        {\n            number = number\
    \ * 10\n            if((number + 1) mod 10 == 1)\n            {\n            \
    \    counter = counter + 1\n            }\n        }\n        return counter",
  "        def countDigitsStartingWith(n: Long, i: Long = 0): Long = {\n         \
    \   if (i == n) {\n                count\n            } else {\n             \
    \   val c = countDigitsStartingWith(n, n + 1)\n                if (n % 10 == 1)\
    \ c + 1\n                else c\n            }\n        }\n        countDigitsStartingWith(n)",
  "        val ns = Array.fill(n)(0)\n        val sums = Array.ofDim[Int](n)\n   \
    \     sums(0) = n // number of 1's in the first digit\n        sums(1) = n //\
    \ number of 1's in the second digit\n        for(i<-2 until n) {\n           \
    \ ns(i) = sums(i-1) + ns(i-2) // number of 1's in the ith digit\n        }\n \
    \       ns.sum"]
stop_tokens:
- "\n    }\n"
