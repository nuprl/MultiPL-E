name: HumanEval_43_pairs_sum_to_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // pairs_sum_to_zero takes a list of integers as an input.\n    // it returns\
  \ true if there are two distinct elements in the list that\n    // sum to zero,\
  \ and false otherwise.\n    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong,\
  \ 5l.toLong, 0l.toLong)))\n    // (false)\n    // >>> pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong)))\n    // (false)\n    // >>> pairsSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong)))\n    // (false)\n    // >>> pairsSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (true)\n   \
  \ // >>> pairsSumToZero((List[Long](1l.toLong)))\n    // (false)\n    def pairsSumToZero(l\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](1l.toLong)))\
  \ == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong,\
  \ 3l.toLong, 2l.toLong, 30l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));\n    }\n\
  \n}\n"
completions: ["        val zeros = l.count(_ == 0)\n        if (zeros == 2) true else\
    \ false", "        val s = l.foldLeft(0l.toLong)((sum, elem) => (sum + elem))\n\
    \        if (s == 0l.toLong)\n            true\n        else\n            false",
  "        var sum = 0\n        var i = 0\n        while (i < l.length) {\n      \
    \      sum += l(i)\n            i += 1\n        }\n        sum == 0", "      \
    \  val set = Set[Long]()\n        l.foreach {x => set.add(x - 0); set.add(x +\
    \ 0)}\n        set.size == 2 && set.count(_ > 0) == 2", "        l.foldLeft(false)\
    \ { (result, item) =>\n            val (sum, count) = item match {\n         \
    \       case 0 => (0l, 0)\n                case _ => (item + result, 1)\n    \
    \        }\n            result && (sum == 0l)\n        }", "        // initialize\
    \ a HashMap to keep track of duplicate elements\n        val map = new mutable.HashMap[Long,\
    \ Boolean]()\n        val pairs = l.flatMap { x =>\n            x match {\n  \
    \              case 0 => None\n                case x1 :: x2 => Some((x1, x2))\n\
    \                case x1 :: Nil => Some((x1, x1))\n                case _ => None\n\
    \            }\n        }.distinct\n\n        val l = pairs.count { x => map.getOrElse(x,\
    \ false) }\n        l == 0", "        if (l.length == 0) return false\n      \
    \  val pairs = l.distinct\n        val (min1, min2) = pairs.minBy(x => x)\n  \
    \      val (max1, max2) = pairs.maxBy(x => x)\n        if (min2 == max2 && min1\
    \ == max1) return true\n        if (min1 <= max1 && min2 <= max2) return true\n\
    \        if (min1 + min2 == max1 && max1 + max2 == min1) return true\n       \
    \ if (min1 + min2 == max1 && min2 < max2) return true\n        if (min1 < min2\
    \ && min2 < min1) return true\n        if (max1 < max2 && max2 < max1) return\
    \ true\n        false", "        for (a <- l.iterator)\n            for (b <-\
    \ l.iterator)\n                if (a + b == 0)\n                    return true\n\
    \        return false", "        val pairs = l.zipWithIndex\n        val pairCount\
    \ = pairs.filter(x => x._2 < l.size).size\n        if (pairCount == 2) pairs.exists\
    \ { x => x._2 + x._2 == 0}.head\n        else false", "        l match {\n   \
    \       case x :: xs => x.zip(x.tail).forall { case (a,b) => b==0 }\n        \
    \  case Nil => false\n          case _ => pairsSumToZero(l.reverse)\n        }",
  "        l match {\n          case Nil => true\n          case h::t => if (h.sum\
    \ == 0) pairsSumToZero(t)\n                    else pairsSumToZero(t filter (_\
    \ != h))\n        }", "        val seen = mutable.Set[Long]()\n        var n =\
    \ 0\n        var m = l.length\n        while(n < (m - 1) && m > 0) {\n       \
    \     val n1 = n\n            val n2 = n1 + 1\n            val n3 = n2 + 1\n \
    \           if(Math.abs(l(n1) - l(n3)) < 10) {\n                n += 1\n     \
    \           m -= 1\n            } else if(Math.abs(l(n2) - l(n3)) < 10) {\n  \
    \              n += 2\n                m -= 1\n            } else {\n        \
    \        n += 3\n                m -= 1\n            }\n        }\n        if(l(n)\
    \ == 0) {\n            seen += l(n)\n        }\n        seen.isEmpty == false",
  "        // write your code here\n        var isTrue = false\n        l.foreach\
    \ { a =>\n            l.foreach { b =>\n                if(a+b == 0) isTrue =\
    \ true\n            }\n        }\n        return isTrue", "        val pairs =\
    \ l.zipWithIndex\n        // We have to start two pairs at one since we're looking\
    \ for the first pair\n        // that sums to zero.\n        val pairsWithIndex\
    \ = pairs.filter(_._2 > 0)\n        pairsWithIndex.size == 2 &&\n            pairsWithIndex.exists(_._1\
    \ == 0) &&\n            pairsWithIndex.exists(_._2 == 1)", '        l.tail.zip(l.tail.tail).forall
    { case (n1,n2) => n1 + n2 <= 0 }', "        // create a set of the elements in\
    \ l\n        val set = new mutable.HashSet[Long](l)\n        // for each element\
    \ of l, see if it is in the set.\n        // if not, it is not pairs with zero.\n\
    \        l.map{ e => !set.contains(e) }.reduceLeft(_&&_)", "        l.foldLeft((false,\
    \ false)) { (r, el) =>\n          val leftSum = r._1\n          val rightSum =\
    \ r._2\n          if (leftSum + el == rightSum)\n            ((leftSum, el), (leftSum\
    \ + el, 0l))\n          else\n            ((leftSum, el), (rightSum, leftSum +\
    \ el))\n        }._1 != (false, false)", "      val newList = mutable.ListBuffer[Long]()\n\
    \      val newSet = mutable.Set[Long]()\n      l.foreach { i => newList += i;\
    \ newSet += i }\n      if (newList.size == 1) newSet.size == 1\n      else if\
    \ (newList.size == 2) newSet.size == 2\n      else if (newList.size == 3) newSet.size\
    \ == 3\n      else if (newList.size == 4) newSet.size == 4\n      else false",
  "        val l1 = l\n        val l2 = l\n        val pairs = l1.zipWithIndex.filter(x\
    \ => x._2 == l2.indexOf(_))\n        pairs.foldLeft((false, List[Long]())) { (t,\
    \ (p, n)) =>\n            if (t._1 && p._2 != n) {\n                t._2 = p._2\n\
    \                t._1 = true\n            }\n            t\n        }._1", " \
    \       l match {\n            case List() => false\n            case h :: t =>\
    \ if(h.sum == 0) pairsSumToZero(t)\n                       else h.sum != 0\n \
    \       }", "        var sum = 0L\n        var count = 0\n        l.foreach(el\
    \ => {\n            if(sum != 0) return\n            sum += el\n            count\
    \ += 1\n        })\n        if(count == 0) return false\n        l.sortWith(_.toLong)\n\
    \        (0.until(l.reduce{(a,b) => a + b}.toLong).contains({sum})) == true",
  "        var pairs = mutable.ListBuffer[Pair[Long, Long]]()\n        var sum = 0\n\
    \        for (i<-0 until l.length-1) {\n            sum+=l(i)\n            if\
    \ (sum>0) pairs += new Pair(l(i), l(i+1))\n        }\n        pairs.size < 2",
  "        l.foldLeft(true) {\n            (acc,v) => if (acc) (v != 0l) else {\n\
    \                for (x <- l if v == (x+v)) yield (v == x)\n            }\n  \
    \      }", "        val pairs = l.grouped(2).map {\n            x => (x._1, x._2)\n\
    \        }\n        (pairs.map(x => (x._1 + x._2)) == (List(0)))", "        if\
    \ (l.isEmpty) false\n        else (l.head + l.tail.head) forall (_ == 0)", " \
    \       var pairs = 0\n        var pairList = new mutable.ListBuffer[Pair[Long,Long]]()\n\
    \        var pair: Pair[Long,Long] = null\n        l.foreach{\n            elt\
    \ => if (pairs == 0) pair = elt;\n            else if (elt != pair) pairs += pairList.length\n\
    \            else pairList += Pair(pair,elt)\n        }\n        if (pairs ==\
    \ 0) false\n        else pairList.size == 1", "        var sum = 0\n        var\
    \ pairs = scala.collection.mutable.Set[List[Long]]()\n        for (elem <- l)\
    \ {\n            if (elem.toLong != 0) {\n                sum += 1\n         \
    \       if (sum > 1) pairs += (List[Long](elem))\n                if (sum < -1)\
    \ pairs += (List[Long](-elem))\n            }\n        }\n        (pairs.size\
    \ == 1)", "        var pairs : List[List[Long]] = Nil\n        for(x <- l)\n \
    \           pairs = x :: pairs\n            pairs = pairs.filter(_ < 0)\n    \
    \        pairs = pairs.filter(_ > 0)\n            pairs = pairs.filter(_ <= pairs.reduceLeft(_\
    \ + _))\n            pairs = pairs.filter(_ >= pairs.reduceLeft(_ + _))\n    \
    \        pairs = pairs.filter(_ == pairs.reduceLeft(_ + _))\n            pairs.nonEmpty",
  "        val pairs = l.groupBy(x => (x % 2).getOrElse(true)).filter(_._2.length\
    \ > 1)\n        pairs.exists(x => (x._1._1 + x._1._2) === 0)", "        val nums\
    \ = l.toSet\n        val zeros = l.count(_ == 0)\n        if (zeros == nums.size)\n\
    \            return true\n        else\n            return false", "        if\
    \ (l.isEmpty) true\n        else {\n            var sum = l(0).toLong\n      \
    \      var i = 0\n            var pairs = List[(Long, Long)]()\n            while\
    \ (i < l.size) {\n                if (l(i).toLong == sum) {\n                \
    \    pairs += (l(i).toLong, sum(l(i+1).toLong))\n                    sum += l(i+1).toLong\n\
    \                }\n                i += 2\n            }\n            if (pairs.size\
    \ == 2) false\n            else pairsSumToZero(pairs.toList)\n        }", "  \
    \      val n = l.toSet.size\n        if (n == 0) false\n        else {\n     \
    \       var total = 0L\n            var i = -1\n            while (i < n) {\n\
    \                total += l.apply(i)\n                if (total > 0) return false\n\
    \                i += 1\n            }\n            if (total == 0) true\n   \
    \         else\n            {\n                val a = l.toList\n            \
    \    var b = a(0)\n                var total = b\n                var c = 1\n\
    \                var d = 1\n                while ( d <= a.size ) {\n        \
    \            if ( total + b < 0 ) return false\n                    total = total\
    \ + b\n                    b += 1\n                    c += 1\n              \
    \      if ( c > d ) d += 1\n                }\n                true\n        \
    \    }\n        }", "        var count : Long = 0\n        var sum : Long = 0\n\
    \        var maxValue : Long = 0\n        for (x <- l)\n            count += x\n\
    \            sum += x\n            if (sum == 0)\n                return false\n\
    \            if (count > maxValue)\n                maxValue = count\n       \
    \     count = 0\n            sum = 0\n        return true", "        var l1 =\
    \ l\n        while (l1.length > 0) {\n            l1 = l1.tail\n            if\
    \ (l1.head - l1.tail.head == 0) {\n                return true\n            }\n\
    \        }\n        return false", "        if (l.length < 2)\n            return\
    \ false\n        var numPairs = 0\n        var sum = 0\n        var i = l.length\n\
    \        while (i > 0) {\n            val x = l(i)\n            sum += x\n   \
    \         if (sum == 0) {\n                numPairs++\n                sum = x\n\
    \            }\n            i -= 1\n        }\n        if (numPairs >= 2)\n  \
    \          return true\n        else\n            return false", "        l.sortWith((x,\
    \ y) => x.compare(y) == 0).size == l.size-1 &&\n            l.count(x => x ==\
    \ 0) == 2 &&\n            l.take(1).forall(x => l.count(y => y == x - x) == 1)",
  "        val map = new mutable.HashMap[Long, Long]\n        l.foreach(x => map.update(x,x+1))\n\
    \        map.size == l.size && map.forall { case (k,v) => v == 0 && k != 0}",
  "        // your code goes here\n        var sum = 0\n        for(i <- 0 until l.length)\
    \ {\n            sum += l(i)\n            if (sum < 0) {\n                sum\
    \ = 0\n            }\n        }\n        return false", "      val set = mutable.Set.empty[Long]\n\
    \      val toSum = mutable.Map.empty[Long, Long]\n      val toRemove = mutable.List.empty[Long]\n\
    \      l.foreach{ x =>\n        if(toSum.contains(x)) {\n          toRemove +=\
    \ x\n        } else {\n          toSum += x -> 0\n        }\n      }\n\n     \
    \ toRemove.foreach{ x =>\n        toSum -= x\n      }\n\n      (toSum.isEmpty\
    \ && toRemove.isEmpty) match {\n        case false => false\n        case true\
    \ => true\n      }", "        var list: mutable.Set[Long] = mutable.Set()\n  \
    \      var i: Long = 0\n        while (i < l.length) {\n            if (list.isEmpty)\
    \ {\n                list += l(i)\n            } else if (list.contains(l(i) +\
    \ l(i + 1))) {\n                return true\n            } else {\n          \
    \      list += l(i + 1) + l(i + 1)\n            }\n            i += 2\n      \
    \  }\n        return false", "        val pairsSumToZero = new mutable.HashSet[(Long,\
    \ Long)] //Map from pair to boolean\n        for (i <- l.indices)\n          \
    \  for (j <- l.indices)\n                if (i + j == 0)\n                   \
    \ pairsSumToZero.add((l(i), l(j)))\n        for ( (a1,b1), (a2,b2) <- pairsSumToZero\
    \ if a1 == a2 && b1 == b2)\n            return true\n        return false", " \
    \       var pairs = 0\n        val setOfPairsSet = new mutable.HashSet[mutable.Set[Long]]()\n\
    \        for (i <- l ) {\n            pairs += i\n            val set = setOfPairsSet\n\
    \            if (set exists _) {\n                val setOfPairs = setOfPairsSet\
    \ get i\n                set.retain { x => !setOfPairs.contains(x) }\n       \
    \         if (set.isEmpty) {\n                    setOfPairsSet += (i.toLong,\
    \ Pairs.pairs(pairs).toSet)\n                }\n            }\n        }\n   \
    \     if (setOfPairsSet.isEmpty)\n            (l exists _)\n        else\n   \
    \         false", '       l.reduceLeft((x, y) => x + y == 0)', "        val xs\
    \ = l.toSet\n        val ys = l.toSet\n        val ones = xs.filter(_==1).toSet\n\
    \        val zerosForAll = xs.filter(_!=1).toSet\n        xs.forall(y=>(ys-y).contains(0l))",
  "        var ans = false\n        val pairs = l.map{ x => x }.toSet\n        pairs.forall(pair\
    \ => l.filter(y => y.toLong == pair._1 && y.toLong != pair._0).length == 2)",
  "        val sums = l.zipWithIndex.map{ case (n,i) => n + i }.toMap\n        val\
    \ pairs = l.zipWithIndex.filter { case (n,i) => sums.contains(n-i) }.toList\n\
    \        pairs.forall { case (n,i) => n == 0 } || pairs.forall { case (n,i) =>\
    \ n == -n }", "        // Your code goes here.\n        var pairs = l.grouped(2)\n\
    \        pairs.groupBy(_._1).map(_._2).contains(pairs.groupBy(_._1).map(_._2).map(s\
    \ => s.foldLeft(0)(_ + _) > 1))", "        val set = new mutable.HashSet[Long]()\n\
    \        for (i <- l) {\n            val key = i + i\n            set.add(key)\n\
    \        }\n        if (set.size == 2) false\n        else true", "        //\
    \ Use two mutable variables to store the results of two distinct sum calculations\n\
    \        var flag1 = false\n        var flag2 = false\n        // Keep track of\
    \ the current element in the list\n        var currentElement = l(0)\n       \
    \ // Keep track of any additional elements added to the list\n        var additionalElements\
    \ = List[Long]()\n        // Keep track of the sum calculations being performed\n\
    \        var sum1 = currentElement\n        var sum2 = currentElement\n      \
    \  // While there are elements in the list\n        while (currentElement != null)\
    \ {\n            // If there are two distinct elements that sum to zero, return\
    \ true\n            // If there are not two distinct elements that sum to zero,\
    \ return false\n            if (sum1 + sum2 == 0) {\n                flag1 = true\n\
    \                flag2 = false\n            }\n            else {\n          \
    \      sum1 = sum2\n                sum2 = currentElement\n                currentElement\
    \ = additionalElements.head\n                additionalElements = additionalElements.tail\n\
    \            }\n        }\n        // Return the results of the two sum calculations\n\
    \        flag1 && flag2", "        val pairs = l zip l.tail\n        pairs.exists(_._1\
    \ + _._2 == 0)", "        def pair(l: List[Long], acc: mutable.Map[Long, Boolean],\
    \ n: Long, sum: Long) : Boolean = {\n            if (n == 1) {\n             \
    \   acc.updated(l(0), true)\n                return true\n            }\n    \
    \        pair(l.tail, acc, n - 1, sum + l(0))\n            pair(l.tail, acc, n,\
    \ sum)\n        }\n        pair(l, Map(), l.length, 0)", "        val map = l.toMap\n\
    \        val values = map.values\n        val keys = map.keys\n        var pairs\
    \ = 0\n        for ( x <- keys) {\n            var sum = 0\n            var j\
    \ = values.indexOf(x)\n            while(j >= 0) {\n                sum = sum\
    \ + j\n                j = values.indexOf(x,j+1)\n            }\n            if\
    \ (sum == 0)\n                pairs += 1\n        }\n        if (pairs == 2)\n\
    \            true\n        else\n            false", "        val pairs = l zip\
    \ l.tail\n\n        // find pairs where the first element of the pair is less\
    \ than 0\n        def pairIsLess(pair : (Long, Long)) : Boolean = {\n        \
    \    pair._1 < 0\n        }\n\n        // find pairs where the first element of\
    \ the pair is greater than or equal to 0\n        def pairIsMoreThanEqual(pair\
    \ : (Long, Long)) : Boolean = {\n            pair._1 >= 0\n        }\n\n     \
    \   // find pairs where the first element of the pair is equal to 0\n        def\
    \ pairIsZero(pair : (Long, Long)) : Boolean = {\n            pair._1 == 0\n  \
    \      }\n\n        // find pairs where the first element of the pair is greater\
    \ than 0\n        def pairIsMoreThanZero(pair : (Long, Long)) : Boolean = {\n\
    \            pair._1 > 0\n        }\n\n        // filter pairs where the first\
    \ element is less than 0\n        val less = pairs.filter(pairIsLess)\n\n    \
    \    // filter pairs where the first element is greater than or equal to 0\n \
    \       val moreThanEqual = pairs.filter(pairIsMoreThanEqual)\n\n        // filter\
    \ pairs where the first element is equal to 0\n        val zero = pairs.filter(pairIsZero)\n\
    \n        // filter pairs where the first element is greater than 0\n        val\
    \ moreThanZero = pairs.filter(pairIsMoreThanZero)\n\n        // return true if\
    \ there are two distinct elements in the list that sum to zero\n        less.size\
    \ == 2 && moreThanEqual.size == 0 && zero.size == 1 && moreThanZero.size == 0",
  "        if (l.isEmpty) false\n        val set = Set.empty[Long]\n        l.foreach(\
    \ x => set += x )\n        if (set.size == l.size) true\n        else false",
  "        val counter = mutable.Map[Long, Int]()\n        for (i<- 0 until l.length)\
    \ {\n            val first = l(i)\n            val second = l(i+1)\n         \
    \   counter.put(first, (counter.get(first)\n                .getOrElse(0) + 1))\n\
    \            counter.put(second, (counter.get(second)\n                .getOrElse(0)\
    \ + 1))\n            if (counter.get(first).getOrElse(0) == counter.get(second).getOrElse(0))\
    \ true\n            else false\n        }", "        val result = if (l.length\
    \ == 1) false else\n        l.foldLeft(false)(_ && (_ + _) == 0)\n        result",
  "        val m = l\n        val n = (m.length/2)\n        var i = m.length/2-1\n\
    \        var j = 0\n        while (i>=0){\n          while (j < n && m(j+i) ==\
    \ m(j)) {\n              j += 1\n          }\n          if (j == n){\n       \
    \     return true\n          }\n          i--\n          j = 0\n        }\n  \
    \      return false", "        var flag : Boolean = false\n        var sum : Long\
    \ = 0\n        var a : Long = 0\n        var b : Long = 0\n        var c : Long\
    \ = 0\n        for(i <- 0 until l.length) {\n            sum += l(i)\n       \
    \     if(sum == 0) {\n                a = l(i)\n                flag = true\n\
    \            } else {\n                b = l(i)\n                c = a - b\n \
    \               if(c != 0) {\n                    flag = true\n              \
    \  } else {\n                    sum = sum - a\n                }\n          \
    \  }\n        }\n        if(!flag) {\n            false\n        } else {\n  \
    \          true\n        }", "        if (l.length < 2) {\n            return\
    \ false\n        }\n\n        val first = l.head + l.tail.head\n        val rest\
    \ = l.tail.tail\n\n        rest.forall { z =>\n            if (z != 0) {\n   \
    \             val z = first + z\n                val next = rest - z\n       \
    \         if (next == Nil) {\n                    return true\n              \
    \  }\n            }\n        }\n        return false", "        // If there are\
    \ no integers left in the list, then there are only two distinct elements that\
    \ sum to zero.\n        // If there are multiple distinct elements that sum to\
    \ zero, then there are two pairs that sum to zero.\n        // If there is one\
    \ distinct element that sums to zero, then there is only one pair that sums to\
    \ zero.\n        // The function should return true if the list contains at least\
    \ two distinct elements that sum to zero.\n        // If there is no distinct\
    \ element that sums to zero, then the function should return false.\n        if\
    \ (l.isEmpty) true\n        else {\n            // Keep track of elements that\
    \ sum to zero\n            var sumToZero: List[Long] = Nil\n            // Keep\
    \ track of pairs that sum to zero\n            var pairsToZero: List[(Long, Long)]\
    \ = Nil\n            for (i <- l) {\n                // If the current element\
    \ is 0, then the sum to zero list is empty\n                if (i == 0L) {\n \
    \                   // If there are no pairs that sum to zero, then there are\
    \ two distinct elements that sum to zero\n                    if (pairsToZero.isEmpty)\
    \ true\n                    // Else there are two pairs that sum to zero\n   \
    \                 else {\n                        // If the first pair in the\
    \ pairs sum to zero list is equal to the first element in the sum to zero list,\
    \ then there are two pairs that sum to zero.\n                        if (pairsToZero(0)\
    \ == sumToZero(0)) pairsSumToZero(pairsToZero.drop(1))\n                     \
    \   // Else the two pairs that sum to zero do not match the first element in the\
    \ sum to zero list\n                        else pairsSumToZero(pairsToZero.take(2))\n\
    \                    }\n                // Else the current element is not 0\n\
    \                } else {\n                    // If there are elements in the\
    \ sum to zero list, then there are two distinct elements that sum to zero.\n \
    \                   if (sumToZero.isEmpty) true\n                    // Else there\
    \ are multiple distinct elements that sum to zero.\n                    else {\n\
    \                        // If the second element in the sum to zero list does\
    \ not equal the first element in the sum to zero list, then there are multiple\
    \ pairs that sum to zero.\n                        if (sumToZero(1) == sumToZero(0))\
    \ pairsSumToZero(pairsToZero.drop(2))\n                        // Else there are\
    \ one distinct element that sums to zero.\n                        else pairsSumToZero(pairsToZero.take(1))\n\
    \                    }\n                }\n            }\n        }", "      \
    \  val sum = l.foldLeft(0l){ (sum, num) => sum + num }\n        (sum == 0l) &&\
    \ (l.length == 1)", "        val a = l.toSet\n        val b = a.filter(_ > 0)\n\
    \        val c = b.filter(_ > 0)\n        if ((c.isEmpty) || (a.isEmpty)) {\n\
    \            false\n        } else {\n            val zeros = c - (a.subsetOf(b))\n\
    \            if (zeros.isEmpty)\n                true\n            else\n    \
    \            false\n        }", "        // the accumulator is of type Pair, which\
    \ has a val type member which is a\n        // Set of pairs of Longs.\n      \
    \  val accumulator = mutable.HashMap.empty[Pair[Long, Long], Set[Long]]\n    \
    \    for (i <- 0 to l.length) {\n            val currentPair = Pair(l(i), accumulator(currentPair))\n\
    \            accumulator += currentPair\n        }\n        // the accumulator\
    \ hash map is of type Map[Pair[Long, Long], Set[Long]], where each\n        //\
    \ key-value pair consists of the current pair and an empty Set\n        if (accumulator\
    \ == Map.empty[Pair[Long, Long], Set[Long]]) false\n        else true", "    \
    \    val pairs = l.groupBy(_ % 2)\n        pairs.exists(pairs => pairs(0l).sum\
    \ == pairs(1l).sum)", "        val pairs = l.groupBy(_ * -1)\n        pairs.forall\
    \ {\n            case (k, v) => k._2 != 0 && v == 0 && (k._1.toLong - k._2.toLong)\
    \ != 0\n        }", "        if (l.length == 0) false\n        else if (l.length\
    \ == 1) true\n        else (l.tail.tail.head + l.head == 0l) &\n        pairsSumToZero(l.tail)",
  "        val count = mutable.HashSet[Long]()\n        val result = mutable.HashSet[Long]()\n\
    \n        for (i<- 0 until l.length) {\n            val sum = (l(i) + l(i + 1))\
    \ / 2\n\n            if (count.contains(sum)) {\n                if (result.contains(sum)\
    \ && result.size < 2) {\n                    println(s\"sum == 0 pair is $sum\"\
    )\n                    return true\n                } else {\n               \
    \     println(s\"sum == 0 pair is $sum, result contains $result\")\n         \
    \           return false\n                }\n            } else {\n          \
    \      count.add(sum)\n                println(s\"sum == 0 pair is $sum, count\
    \ contains $count\")\n                result.add(sum)\n            }\n       \
    \ }\n\n        println(s\"sum == 0 pair is $sum\")\n        return false", " \
    \       l.foldLeft(false) {\n            case ((false, true, tail), n) => \n \
    \               if(n != 0l && n-1l == 0l) tail orElse false\n            case\
    \ ((false, false, tail), n) => \n                if(n != 0l && n+1l == 0l) tail\
    \ orElse false\n            case ((true, false, tail), n) => \n              \
    \  if(n != 0l && n-1l != 0l) tail orElse true\n            case ((true, true,\
    \ tail), n) => \n                if(n != 0l && n+1l != 0l) tail orElse true\n\
    \            case _ => false\n        }", "        if (l.isEmpty) false\n    \
    \    if (l.length == 1) l.head == 0\n        else {\n            var firstElem\
    \ = l.head\n            var secondElem = l.head\n            l.tail.foreach{t\
    \ => {\n                if(t != 0)\n                    if(firstElem + t != 0)\
    \ return false\n                    firstElem = t\n                    secondElem\
    \ = firstElem }\n            }\n            return firstElem + secondElem == 0\n\
    \        }", "        val sum : Long = l.foldLeft((0,0l)) {\n            case\
    \ ((x, y), i) => x + i\n        }\n\n        if (sum < 0)\n            false\n\
    \        else if (sum == 0)\n            true\n        else\n            pairsSumToZero(l.tail)\
    \ && pairsSumToZero(l.init)", "        val nums = new HashSet[Long]()\n      \
    \  l.foreach(x => if (nums.contains(x + x)) nums.remove(x))\n        nums.size\
    \ == 0", "        val pairs = l\n            .distinct\n            .groupBy(x\
    \ => math.abs(x))\n            .filter(_._2.size == 2)\n            .map(_._1)\n\
    \        pairs.forall(pair => pairs.contains(pair + pairs.last)) || pairs.forall(pair\
    \ => pairs.contains(pair - pairs.last))", '        l.size != l.distinct && l.map(e
    => e).map(e => if (e < 0) -e else e).distinct.size == 1 && l.map(e => e).map(e
    => if (e < 0) -e else e).distinct.size == 1', "        l.distinct.length == l.length\
    \ && l.distinct zip l map {\n            case (l,l2) => l2.reduce(_ + _) == 0\n\
    \        } forall {\n            case true => false\n            case _ => true\n\
    \        }", "        val pairs = l.groupBy(e => e%2==0).filter(p => p._2.length\
    \ == 2).map(e => (e._1, e._2.last)).toList\n        val nonPairs = l.filterNot(e\
    \ => e % 2 == 0)\n        val zero = pairs.isEmpty\n        if (nonPairs.isEmpty)\
    \ zero else pairs.exists(e => e._1._1 + e._2._1 == 0) && nonPairs.size == nonPairs.distinct\
    \ && zero", "        val map = new mutable.HashMap[Long, List[Long]]()\n     \
    \   for (i <- l) { map.getOrElse(i, Nil) += i }\n        if (map.isEmpty) {\n\
    \            false\n        } else {\n            val keys = map.keys\n      \
    \      if (keys.size == 2) \n                map.get(keys.head).last == 0l.toLong\n\
    \            else \n                false\n        }", "        var max: Long\
    \ = l.head\n        var min: Long = l.last\n        l.tail.foreach { x =>\n  \
    \          if(x.toLong + min > max)\n                max = x.toLong\n        \
    \    if(x.toLong + max > 0)\n                return false\n            max = max\
    \ * -1\n            min = min * -1\n        }\n        true", "        val xs\
    \ = l.distinct\n        var total = 0l\n        for (x <- xs) {\n            total\
    \ += x\n            if (total == 0l) {\n                return true\n        \
    \    }\n        }\n        return false", "        val n = l.size\n        var\
    \ sum = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ isSummingPair = false\n        while (i < n) {\n            while (j < n) {\n\
    \                val temp = l(i) + l(j)\n                sum = if (sum == 0) temp\
    \ else (temp % sum)\n                j += 1\n            }\n            isSummingPair\
    \ = sum > 0\n            if (isSummingPair) break\n            j += 1\n      \
    \      i += 1\n        }\n        isSummingPair", "        val pairs = l groupBy\
    \ {\n            case x if x > 0 => x\n            case _ => 0\n        }\n  \
    \      pairs.exists(_._2.size == 1)", "        val set = mutable.Set.empty[Long]\n\
    \        l foreach {x => set += x}\n        val res = !set.toSet.size == l.size\
    \ - 1\n        res", "       var i = 0\n       var j = 1\n       var sum = 0\n\
    \       while (j < l.length) {\n          sum += j\n          if (sum == 0) return\
    \ true\n          i += 1\n          j += 1\n       }\n       return false", " \
    \       def pairs(a : Long, b : Long) : List[(Long, Long)] = {\n            if\
    \ (a > b) List((a, b))\n            else List( (a, b), (a, b - a) :: pairs(a +\
    \ b, b) )\n        }\n\n        l match {\n            case Nil => false\n   \
    \         case a :: b :: Nil =>\n                val (aa, bb) = a\n          \
    \      val (ba, bb) = b\n                aa + bb == 0L && aa + ba == bb\n    \
    \        case a :: b :: c :: Nil =>\n                val (aa, bb) = a\n      \
    \          val (ba, bb, cc) = b\n                aa + bb == 0L && aa + bb == bb\
    \ && aa + cc == 0L && aa + ba == bb\n            case a :: b :: c :: d :: Nil\
    \ =>\n                val (aa, bb) = a\n                val (ba, bb, cc, dd) =\
    \ c\n                aa + bb == 0L && aa + bb == bb && aa + cc == 0L && aa + bb\
    \ == bb && aa + dd == cc\n            case a :: b :: c :: d :: e :: Nil =>\n \
    \               val (aa, bb) = a\n                val (ba, bb, cc, dd, ee) = c\n\
    \                aa + bb == 0L && aa + bb == bb && aa + cc == 0L && aa + bb ==\
    \ bb && aa + dd == cc\n            case a :: b :: c :: d :: e :: f :: Nil =>\n\
    \                val (aa, bb) = a\n                val (ba, bb, cc, dd, ee, ff)\
    \ = c\n                aa + bb == 0L && aa + bb == bb && aa + cc == 0L && aa +\
    \ bb == bb && aa + dd == cc\n            case a :: b :: c :: d :: e :: f :: g\
    \ :: Nil =>\n                val (aa, bb) = a\n                val (ba, bb, cc,\
    \ dd, ee, ff, gg) = c\n                aa + bb == 0L && aa + bb == bb && aa +\
    \ cc == 0L && aa + bb == bb && aa + dd == cc\n            case a :: b :: c ::\
    \ d :: e :: f :: g :: h :: Nil =>\n                val (aa, bb) = a\n        \
    \        val (ba, bb, cc, dd, ee, ff, gg, hh) = c\n                aa + bb ==\
    \ 0L && aa + bb == bb && aa + cc == 0L && aa + bb == bb && aa + dd == cc\n   \
    \         case a :: b :: c :: d :: e :: f :: g :: h :: i :: Nil =>\n         \
    \       ", "        val pairs = l.distinct\n        if (pairs.size == 0) {\n \
    \           return false\n        }\n        var sum = 0L\n        val pairsWithSum\
    \ = pairs.map { n => sum <- sum + n; n }\n        for (a <- pairsWithSum) {\n\
    \            for (b <- pairsWithSum) {\n                if (a + b == 0L && a ==\
    \ b) {\n                    return true\n                }\n                if\
    \ (a == b && (a == 0 || b == 0)) {\n                    return false\n       \
    \         }\n            }\n        }\n        return false", '        l.forall{i
    => l.contains(i) && l.filter(x => x == i).size == 1}', "        val pairs = l.flatMap(x\
    \ => (x to x + 1) collect {\n            x => (x, x + 1)\n        })\n       \
    \ val result = pairs.toSet.size == 1\n        result", "        if (l.isEmpty)\
    \ l.length == 1 && l.head == 0\n        else {\n            val lastIndex = l.length\
    \ - 1\n            val firstElement = l.head\n            val secondElement =\
    \ l.tail.head\n            val currentSum = firstElement + secondElement\n   \
    \         val previousSum = l.tail.tail.head\n\n            if (currentSum ==\
    \ 0 || previousSum == 0 || currentSum == previousSum) {\n                return\
    \ false\n            }\n            else {\n                println(l.head)\n\
    \                println(l.tail)\n                println(currentSum)\n      \
    \          println(previousSum)\n                println(currentSum - previousSum)\n\
    \                println(currentSum - previousSum == 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                println(currentSum - previousSum != 0)\n\
    \                println(currentSum - previousSum != 0)\n                println(currentSum\
    \ - previousSum != 0)\n                print", "        val zero = l.filter(_\
    \ == 0)\n        if (zero.isEmpty) false\n        else {\n            val list:\
    \ List[Long] = l filter (x => x != 0)\n            val first = list.head\n   \
    \         val rest = list.tail\n            val sum = 0l\n            for(x <-\
    \ rest){\n                val y = x - first\n                sum += y\n      \
    \      }\n            if (sum == 0l) return false\n            else return true\n\
    \        }", "        val lList = l.toList\n        var i : Int = 0\n        var\
    \ j : Int = 0\n        val pairs = List(List(l(i), l(i+1)), List(l(i+1), l(i+2)),\
    \ List(l(i+1), l(i+2)))\n        var sum : Long = 0\n        while ( i < lList.length-1\
    \ && j < lList.length-1){\n            sum = lList(i) + lList(j) + pairs(i).head\
    \ + pairs(j).head\n            if (sum == 0)\n                i += 1\n       \
    \     else\n                j += 1\n        }\n        if (i < lList.length-1)\n\
    \            pairsSumToZero(l.tail)\n        else\n            j >= lList.length-1",
  "        val pairs = scala.collection.mutable.HashSet[(Long,Long)]()\n        l.foreach\
    \ {\n            pairs += ((_,l(_)))\n        }\n        pairs.size > 0 && pairs.size\
    \ == l.length && pairs.forall { case (l, r) => l+r==0l}", "        val map = new\
    \ mutable.HashMap[Long, Int]()\n        for ( e <- l) {\n            val i = map.getOrElseUpdate(e,\
    \ 0)\n            i += 1\n            map.put(e, i)\n        }\n        if (map.size\
    \ < 2) false\n        else if (map.get(1l.toLong) + map.get(3l.toLong) == 0) true\n\
    \        else false", '        l.count(_ > 0) == l.count(_ == 0) || l.count(_
    < 0) == l.count(_ == 0)', "        // sort list first\n        val sortedList\
    \ = l.sorted\n        // use two pointers, one starts at the beginning of the\
    \ list, and one at the\n        // current element of the list\n        val firstElem\
    \ = sortedList(0)\n        val secondElem = sortedList(1)\n        if (firstElem\
    \ == 0l && secondElem == 0l) {\n            return true\n        } else if (firstElem\
    \ == 0l && secondElem != 0l) {\n            return false\n        } else if (firstElem\
    \ != 0l && secondElem == 0l) {\n            return false\n        }\n        var\
    \ thirdElem = sortedList(2)\n        while (thirdElem != 0l) {\n            val\
    \ pair = sortedList(thirdElem)\n            thirdElem += 1\n            val currentFirstElem\
    \ = sortedList(thirdElem)\n            thirdElem += 1\n            val currentSecondElem\
    \ = sortedList(thirdElem)\n            if (currentFirstElem + currentSecondElem\
    \ == 0l) {\n                val newPair = currentFirstElem + currentSecondElem\n\
    \                if (newPair != 0l) {\n                    val oldPair = sortedList(thirdElem)\n\
    \                    thirdElem += 1\n                    if (oldPair == newPair)\
    \ {\n                        return pairsSumToZero(l)\n                    }\n\
    \                }\n            }\n        }\n        return pairsSumToZero(l)",
  "        val n = l.size\n        // O(n)\n        var i = 0\n        var j = 1\n\
    \        var k = 0\n        // O(n)\n        while (i < n) {\n            if (j\
    \ > n) {\n                false\n            } else {\n                if (l(i)\
    \ + l(j) == 0) {\n                    k = k + 1\n                    i = i + 1\n\
    \                    j = j + 1\n                } else {\n                   \
    \ k = k\n                }\n            }\n        }\n        if (k == n) {\n\
    \            true\n        } else {\n            false\n        }", "        if\
    \ (l.isEmpty) true\n        else {\n            val pairs = l.grouped(2).filter{case\
    \ (x, y) => x + y == 0}\n            if (pairs.size == 2) pairs.toList.length\
    \ == 1\n            else false\n        }", "        var pairs : List[Long] =\
    \ Nil\n        var pair : List[Long] = Nil\n        var sum : Long = 0\n     \
    \   for (i <- l) {\n            sum += i\n            if (pairs.isEmpty) {\n \
    \               pairs = List(List(sum))\n                pair = List(sum)\n  \
    \          } else if (sum == pairs.last.head) {\n                pairs = pairs\
    \ :+ (sum)\n                pair = pairs :+ (sum)\n            } else if (sum\
    \ > pairs.last.head) {\n                pairs = pairs :+ (sum)\n             \
    \   pair = pairs :+ (sum)\n            }\n        }\n        return pairs.distinct.size\
    \ == 2", "        val m = l.toSet\n        l.filter (i => m.contains(i)).isEmpty",
  "        val a = l\n        val sum = 0\n        // create list of pairs of adjacent\
    \ elements \n        // with adjacent elements having the same value\n       \
    \ val pairs: List[(Long, Long)] = (a.zip(a diff 1 ) ++ a drop 1).map(x => (x._1,\
    \ x._2))\n        // check if there is at least one pair with zero\n        //\
    \ If not then return false\n        pairs.exists(_._2 == 0) == true", "      \
    \  if (l.length == 0) false\n        else {\n            val pairs = l.grouped(2).filter(_\
    \ => _.sum > 0)\n            val pairCount = pairs.size\n            if (pairCount\
    \ == 0) false\n            else if (pairCount == 1) true\n            else pairsSumToZero(pairs.tail)\n\
    \        }", "        def pairSum(i : Long, j : Long) : Boolean = {\n        \
    \    if (i == 0l && j == 0l) return true\n            else if ((i == 0l || j ==\
    \ 0l) && i == j) return true\n            else if (i != 0l && j != 0l) Math.abs(i\
    \ - j) == 0\n            else false\n        }\n        val pairs = l.toSet.toList.sortWith(_\
    \ < _).map(i => (i.toLong, i.toLong))\n        for ((i, j) <- pairs) {\n     \
    \       if (!pairSum(i, j) && pairSum(j, i)) {\n                return false\n\
    \            }\n        }\n        true", "        l match {\n            case\
    \ Nil => false\n            case x :: Nil => true\n            case x :: xs =>\
    \ if (x + xs.sum == 0) true else pairsSumToZero(xs)\n        }", "        val\
    \ pairs = l.map( _+_ )\n        pairs.distinct().size < pairs.size", "       \
    \ val pairs = l.groupBy(l => l).filter(_._2.size == 1).map(_._1)\n        pairs.forall(x\
    \ => x.filter(_ != 0).sum == 0)", "        var a = l\n        val n = l.length\n\
    \        for (i <- 0 to n - 1) {\n            for (j <- i + 1 to n) {\n      \
    \          if (l(i) + l(j) == 0)\n                    return true\n          \
    \  }\n        }\n        false", "        var flag = false;\n        for(i <-\
    \ 0 until l.length-1){\n            var sum = 0\n            for(j <- 0 until\
    \ i){\n                sum += l(i-j);\n            }\n            if(sum != 0){\n\
    \                flag = true\n                return true\n            }\n   \
    \     }\n        flag = false\n        return false", "      val pairs = l.groupBy(\
    \ x => x/2 )\n      pairs.map( x => x(1)-x).forall( x => x == 0 )", "        //\
    \ TODO: Write a function that given a list and a target number, finds the pairs\n\
    \        //       of the list with that target that sum to that target number.\n\
    \        //       For example, given l=[1, 3, -3, 5, -7] and target=5 we would\
    \ return\n        //       pairs = [[1, 3], [-3, 5, -7]].\n\n        var pairs\
    \ : List[List[Long]] = None\n        for (i<- l ) {\n            for (j<- l )\
    \ {\n                if(i != j && i + j == 0 ) {\n                    if(pairs\
    \ == None) {\n                        pairs = List(List(i))\n                \
    \    }\n                    else {\n                        pairs = pairs :+ List(i)\n\
    \                    }\n                }\n            }\n        }\n        if(pairs\
    \ == None) {\n            pairs = List(List(l.toLong))\n        }\n        else\
    \ pairs", "        val pairs = l.groupBy(x => math.abs(x))\n        pairs.exists(x\
    \ => x._2.size < 2) || pairs.exists(x => x._2.size == 1)", "        var count\
    \ = 0\n        for (x <- l)\n            count += x\n        count == 0", "  \
    \      l.foldLeft(false)((acc, el) =>\n            if (acc && el != 0l) {\n  \
    \              val others = l.filter( v => v != el )\n                if (others.forall(\
    \ v => v == el.longValue)) {\n                    acc = false\n              \
    \  }\n            }\n            acc\n        )", "        // Write your code\
    \ here\n        val pairs = l.groupBy(i => (i % 2))\n        pairs.exists(x =>\
    \ (x._2 - x._1).isZero)", "        if (l.length == 0) false\n        else if (l.length\
    \ == 1) true\n        else (l.tail.zip(l.tail.tail).forall { case (y,z) => y +\
    \ z == 0 })", "        var total = 0L\n        l.foreach { elem =>\n         \
    \   if (elem.toLong > 0) {\n                total += elem.toLong\n           \
    \ }\n        }\n        if (l.length == 0 || total < 0) {\n            false\n\
    \        } else {\n            if (l.last.toLong == total) {\n               \
    \ false\n            } else {\n                pairsSumToZero(l.removeLast)\n\
    \            }\n        }", "        val h = new HashSet[Long]()\n        for\
    \ (x <- l) if (h.contains(x + 0)) \n            false\n        else h.add(x +\
    \ 0)\n        true", "        val count = l.filter(_ != 0l).size\n        val\
    \ pairs = (0 to (count / 2)) map (i => l(i), l(i + count / 2))\n        pairs.size\
    \ == 2 &&\n            pairs.exists(x => x._1 + x._2 == 0l)", "        val m =\
    \ l.map(_+1).sum\n        val n = l.map(_-1).sum\n        if(m==0) {\n       \
    \   val m = l.dropRight(1).map(_+1).sum\n          if(m==0) {\n            true\n\
    \          } else false\n        } else false", "        var pairs = mutable.ListBuffer[Pair[Long,\
    \ Long]]()\n        for (x<-l) pairs += new Pair(x, l(x).toLong)\n        pairs.toList.distinct.length\
    \ == 2", "        l.length < 2 ||\n        l.zip(l.tail).filter{ t => t._2 ==\
    \ 0 } != l.tail", "        var sum = 0L\n        var count  = 0\n        for (e\
    \ <- l) {\n            sum += e\n            count += 1\n            if (sum ==\
    \ 0) return true\n        }\n        return false", "        val pairs = l groupBy\
    \ (_ % 2) mapValues(_.length) toSeq\n        pairs.forall { case (val, count)\
    \ => val + count == 0 }", "        var pairs = l.groupBy(x => x % 2).toList\n\
    \        if(pairs.isEmpty) false\n        else if(pairs.size == 1) true\n    \
    \    else {\n            val pairs1 = pairs.filter(_._1 != 0)\n            val\
    \ pairs2 = pairs.filter(_._1 == 0)\n            if(pairs1 == pairs) true\n   \
    \         else if(pairs1 == pairs2.filter(_._1 != 0)) return true\n          \
    \  else if(pairs1 == pairs2.filter(_._1 == 0)) return true\n            else if(pairs1\
    \ == pairs2) return true\n            else return false\n        }", "       \
    \ // Create a map of the pairs so that we don't need to check the\n        //\
    \ pair more than once.\n        val pairs = l.groupBy(x => (x - l.head)).toMap\n\
    \        pairs.size == 1 && pairs.head._2 == 0", "        // create a map of integers\
    \ to their sums.\n        val map = l.map(x => (x, x)).groupBy(_._2).map(_._1).map(_._1)\n\
    \        // check that there are at least two elements that have the same sum\n\
    \        // and that there is not more than two elements that have the same sum\n\
    \        (map.size() >= 2) &&\n        (map.size <= 3)", "        if (l.isEmpty)\n\
    \            return false\n        val s = l.tail\n        def f(x : Long, y :\
    \ Long) : Boolean = {\n            if (x == y)\n                return true\n\
    \            if (x > y)\n                return false\n            if (s == null\
    \ || s.isEmpty)\n                return true\n            val last = s.last\n\
    \            if (last - x == 0)\n                return f(x + last, y)\n     \
    \       if (last - x > 0)\n                return f(x + last, y - last)\n    \
    \        val a = last - x\n            if (a < last)\n                return f(x\
    \ + a, y - a)\n            val b = last - y\n            if (b < a)\n        \
    \        return f(x + b, y - b)\n            val c = a - b\n            if (c\
    \ < -2)\n                return f(x + c, y - c)\n            val d = -2 - c\n\
    \            if (d < last)\n                return f(x + d, y - d)\n         \
    \   false\n        }\n        return f(l.head, l.last)", "        if (l.isEmpty)\n\
    \            false\n        val pairs = l zip l.tail\n        pairs.forall(x =>\
    \ x._1 + x._2 == 0)", "        var sum = 0\n        val pairs = mutable.Map[Long,\
    \ (Long, Long)]()\n        l.foreach(x => pairs += x -> (x+sum))\n        pairs.forall(p\
    \ => (p._1 - p._2) != 0)", "        val m = l.map(x => (x + 0).toLong).distinct\n\
    \        val n = l.map(x => (x + 0).toLong).distinct.filter(x => l.contains(x))\n\
    \        m.size == n.size && m.size == l.size", "        if (l.isEmpty) {\n  \
    \          true\n        } else {\n            var sum = 0\n            var pair:\
    \ Int = 0\n            for (i <- 0 until l.length) {\n                sum += l(i)\n\
    \                if (sum == 0) {\n                    pair += 1\n            \
    \        sum = 0\n                }\n            }\n            if (pair > 1)\
    \ {\n                true\n            } else {\n                false\n     \
    \       }\n        }", "      var i : Int = 0\n      while (i < l.length) {\n\
    \          if (l(i) < 0 || l(i) > 0) {\n              val j = i + 1\n        \
    \      val k = j + 1\n              while (j < l.length) {\n                 \
    \ if (l(i) + l(i) > 0 && l(i) + l(j) < 0 && l(j) + l(i) < 0 && l(j) + l(k) < 0)\
    \ {\n                      return true\n                  }\n                \
    \  j += 1\n              }\n          }\n          i += 1\n      }\n      return\
    \ false", "        l.toList.foldLeft(false)( (acc, cur) => {\n            if(cur\
    \ - acc + 1 != 0L)\n                return acc\n            else\n           \
    \     return acc\n        })", "        val distinctList = new mutable.LinkedHashSet[Long]()\n\
    \        for ((x, y) <- l zip l.tail) {\n            if (distinctList.contains(y\
    \ + x)) {\n                return false\n            } else {\n              \
    \  distinctList += y\n                distinctList += x\n            }\n     \
    \   }\n        true", "        l match {\n            case List() => false\n \
    \           case a :: b::c if b - a == 0 :: c => true\n            case _ => pairsSumToZero(b.tail\
    \ + a.tail)\n        }", "      var pairSet = collection.mutable.Set[(Long, Long)]()\n\
    \      for (i <- 0 until l.length) {\n        val newPairSet = collection.mutable.Set[(Long,\
    \ Long)]()\n        for (j <- 0 until l.length) {\n          if (i != j && l(i)\
    \ + l(j) == 0) {\n            newPairSet = (l(i), l(j))\n            break\n \
    \         }\n        }\n        pairSet = pairSet ++ newPairSet\n      }\n   \
    \   pairSet.size == 2", "        val map = (1 to l.length).map (x => x -> l.drop(x).foldLeft(0l)\
    \ { (x,y) => x+y } ) \n        if (map.containKey(l.drop(1))) map.get(l.drop(1)).getOrElse(0)\
    \ == 0\n        else false", "        var pairs = List(Pair(0, l(0)))\n      \
    \  var current = Pair(0, l(0))\n        var hasPair = false\n        var sum =\
    \ 0\n        while (pairs.nonEmpty) {\n            current = pairs.head\n    \
    \        pairs = pairs.tail\n            if (current.second == 0) {\n        \
    \        hasPair = false\n            } else {\n                sum = current.first\
    \ + current.second\n                if (pairs.contains(pairs.find(_._2 == sum)))\
    \ {\n                    hasPair = true\n                } else {\n          \
    \          pairs = pairs :+ Pair(sum, 0)\n                }\n            }\n \
    \       }\n        !hasPair", "        val map = mutable.HashMap[(Long, Long),\
    \ Boolean]()\n        var sum : Long = 0\n        for (i <- l : i : 0) {\n   \
    \         if (map.get((sum, i))) {\n                return false\n           \
    \ } else {\n                map.put((sum, i), true)\n                sum += i\n\
    \            }\n        }\n        return true", "        val l1 = l.toList.sortWith(_.compare(_.toLong)\
    \ < 0)\n        val l2 = l1.map(i => -i)\n        l2.distinct.size == 2 && l2.forall(i\
    \ => l1(i) < 0l) && l1.forall(i => l1(i) < 0l)", "        val sums = mutable.Map[(Long,\
    \ Long), Double]()\n        l.foreach { n =>\n            val sum = (n*n).toLong\n\
    \            sums += ((n, sum) -> sum.toDouble)\n        }\n        sums.size\
    \ == 1 && !sums.contains( _._1._1 == 0) && !sums.contains( _._1._1 == _._1._2)",
  "        val a = l.toSet\n        val b = l.toSet.filter(_ > 0)\n        a.forall(b.contains)",
  "        l match {\n          case Nil => false\n          case x :: Nil => true\n\
    \          case xs => val sum = sum(xs)\n                   if(sum == 0) pairsSumToZero(xs)\n\
    \                   else pairsSumToZero(List(xs.head, sum - xs.head))\n      \
    \  }", "        var last = 0l\n        val resultSet = HashSet[Long]()\n     \
    \   for (i <- l ) {\n            if (i != 0l) {\n                if (last + i\
    \ != 0l) {\n                    resultSet.add(last)\n                    resultSet.add(i)\n\
    \                } else {\n                    resultSet.add(i)\n            \
    \    }\n            }\n            last += i\n        }\n        return !resultSet.isEmpty",
  "        val zero = l.tail.foldLeft((0l, 0l)) { (t,x) => (t._1 + x, t._2 + 1) }\n\
    \        !l.forall(_%2 == 0) && l.forall(_%2 == 1) && l.forall(t => t._2 == zero._1\
    \ + t._1)", "      val x = l.foldLeft(0)((a, b) => a + b)\n      (l.count(_ ==\
    \ x) == 2)", "        var sum = 0L\n        var count = 0L\n        for (i <-\
    \ l)\n            if (i != 0L) {\n                sum += i\n                count\
    \ += 1L\n            }\n        if (count == 2L) {\n            false\n      \
    \  }\n        else {\n            (sum == 0L) && (count != 2L)\n        }", " \
    \       def pairs(l1: List[Long], l2: List[Long]) : List[(Long, Long)] = {\n \
    \           val l3 = l1 +: l2\n            val l4 = l3.toList\n            var\
    \ i1 = 0\n            var i2 = 0\n            var j1 = 1\n            var j2 =\
    \ 1\n            var sum = 0\n            while (l4.nonEmpty) {\n            \
    \    if (i2 >= l4.length) {\n                    (i1, i2) = (j1, j2)\n       \
    \             j1 += 1\n                    j2 = 1\n                    sum = 0\n\
    \                } else if (j2 >= l4.length) {\n                    (j1, j2) =\
    \ (i1, i2)\n                    i1 += 1\n                    i2 = 0\n        \
    \            sum = 0\n                } else {\n                    sum += l4(i2++)\
    \ min l4(i1++)\n                }\n            }\n            if (sum != 0) ((sum,\
    \ i1), (i2, j2))\n            else false\n        }\n        l match {\n     \
    \       case Nil => false\n            case x :: xs => pairs(xs, xs)\n       \
    \ }", "        val (zeroList, nonZeroList) = l.partition(_.toLong == 0)\n    \
    \    if ((nonZeroList.length == 2) && !(nonZeroList(1).toLong == zeroList(1).toLong))\
    \ {\n            true\n        } else {\n            false\n        }", "    \
    \    var sum = 0\n        val pairs = l groupBy (_ % 2L) \n        pairs.foreach{\
    \ case (k,v) =>\n            val l = k.asInstanceOf[Long]\n            val v =\
    \ v.asInstanceOf[List[Long]]\n            sum +=l :: v.length\n        }\n   \
    \     val pairs = pairs.filter(_._1.toLong != 0L)\n        pairs.length == 0",
  "        var ans = false\n        var l = l\n        var pairs = mutable.Map[Long,\
    \ Long]()\n        l.foreach { x =>\n            pairs += ((x): (x))\n       \
    \ }\n        pairs.foreach {\n            case (x,y) => if (x != y) {\n      \
    \          ans = true\n                pairs.remove(y)\n            }\n      \
    \  }\n        pairs\n        ans", "        l.foldLeft((l.size, l.size))((x, y)\
    \ => x match {\n            case (size, 0) => (y._1, y._2)\n            case (_,\
    \ size) => y\n        }) == (0, l.size)", "        // initialize to a map where\
    \ the key is the sum of the elements in the list\n        // and the value is\
    \ a list containing all the elements that sum to 0.\n        val sumToZeroMap:\
    \ Map[Long, List[Long]] = l.foldLeft((0l, new mutable.LinkedList[Long]())) {\n\
    \            (sumToZeroMap, l: List[Long]) => \n                (l.foldRight(pairSum(l.head))\
    \ { (sumToZeroMap, x: Long) => \n                    (sumToZeroMap += (sumToZeroMap.getOrElse(sumToZeroMap.getOrElse(x,\
    \ 0l) + l.head, l.head) -> l) \n                    } , sumToZeroMap)\n      \
    \          }\n            )\n        }\n\n        // the sum of all the elements\
    \ that sum to 0 is zero.\n        sumToZeroMap.getOrElse(0l, 0l) == l.head", " \
    \       if(l.length == 1) return false\n        val pairs = l.groupBy(_.toLong)\n\
    \        val pairs_set = pairs.toSet\n        // only pairs with one element satisfy\
    \ the condition\n        if(pairs_set.size < 2) return false\n        // pairs\
    \ with one element and sum to zero\n        if(pairs_set.size % 2 == 0) pairs.forall\
    \ { case (k, v) =>\n            val sum_v = v.sum\n            if(sum_v == 0)\
    \ false\n            else sum_v != 0 && pairs.filter(k._2 > k._1).exists(k._2.toLong\
    \ == sum_v)\n        }\n        // pairs with two elements and sum to zero\n \
    \       else pairs.forall { case (k, v) =>\n            val sum_v = v.sum\n  \
    \          if(sum_v == 0) false\n            else sum_v != 0 && pairs.filter(k._2\
    \ > k._1).exists(k._2.toLong == sum_v)\n        }", "        var foundTwoZero\
    \ = false\n        val pairs = l.map{_ * 2}\n        val set = new mutable.HashSet[Long]()\n\
    \        val twoZeroPairs = pairs.filter { p => set += (p - 0l) > 0}\n       \
    \ if (!twoZeroPairs.isEmpty)\n            foundTwoZero = true\n        set.toList.exists(x\
    \ => pairs.find(y => y - 0l == x) != pairs.last)", "        val sum = l.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        l.forall(_ != 0l) && l.distinct.size == 2 &&\
    \  sum == 0", "        // Write your code here\n        // let pairs be the list\
    \ of (first elem, second elem) pairs that sum to zero\n        // (i.e. for each\
    \ pair (a, b), a must be less than b)\n        val pairs = l.zipWithIndex\n  \
    \          .toList\n            .sortBy(_._1)\n            .map(p => (p._1, p._2))\n\
    \            .toList\n\n        // let distinctPairs be a list of (first elem,\
    \ second elem) pairs that do not sum to zero\n        // i.e. for each pair (a,\
    \ b), a and b are distinct pairs.\n        val distinctPairs = pairs\n       \
    \     .filter(p => !pairs.exists(q=>q._1 == p._1 && q._2 == p._2))\n         \
    \   .sortBy(_._1)\n            .map(p => (p._1, p._2))\n            .toList\n\n\
    \        // return false if there are 2 distinct elements in the list that sum\
    \ to zero\n        // and true otherwise\n        if (distinctPairs.size == 2)\
    \ {\n            distinctPairs.head._1.toLong == distinctPairs.head._2.toLong\n\
    \        } else {\n            false\n        }\n", "        var zero = 0\n  \
    \      var one = 0\n        var two = 0\n        var three = 0\n        var four\
    \ = 0\n        var five = 0\n        var six = 0\n        l foreach {\n      \
    \      elem =>\n            zero += elem\n            one += elem\n          \
    \  if(elem == 1) two++\n            if(elem == 2) three++\n            if(elem\
    \ == 3) four++\n            if(elem == 4) five++\n            if(elem == 5) six++\n\
    \        }\n        if(three == 0 && four == 0 && five == 0 && six == 1) return\
    \ false\n        if(three == 1 && four == 0 && five == 0 && six == 1) return false\n\
    \        if(three == 1 && four == 1 && five == 0 && six == 1) return false\n \
    \       if(three == 1 && four == 1 && five == 1 && six == 1) return false\n  \
    \      if(three == 2 && four == 0 && five == 0 && six == 1) return false\n   \
    \     if(three == 2 && four == 1 && five == 0 && six == 1) return false\n    \
    \    if(three == 2 && four == 1 && five == 1 && six == 1) return false\n     \
    \   if(three == 2 && four == 2 && five == 0 && six == 1) return false\n      \
    \  if(three == 2 && four == 2 && five == 1 && six == 1) return false\n       \
    \ if(three == 2 && four == 2 && five == 2 && six == 1) return false\n        if(three\
    \ == 3 && four == 0 && five == 0 && six == 1) return false\n        if(three ==\
    \ 3 && four == 1 && five == 0 && six == 1) return false\n        if(three == 3\
    \ && four == 1 && five == 1 && six == 1) return false\n        if(three == 3 &&\
    \ four == 2 && five == 0 && six == 1) return false\n        if(three == 3 && four\
    \ == 2 && five == 1 && six == 1) return false\n        if(three == 3 && four ==\
    \ 2 && five == 2 && six == 1) return false\n        if(three == 4 && four == 0\
    \ && five == 0 && six == 1) return false\n        if(three == 4 && four == 1 &&\
    \ five == 0 && six == 1) return false\n        if(three == 4 && four == 1 && five\
    \ == 1 && six == 1) return false\n        if(three == 4 && four == 2 && five ==\
    \ 0 && six == 1) return false\n        if(three == 4 && four == 2 && five == 1\
    \ && six == 1) return false\n        if(three == 4 && four == 3 && five == 0 &&\
    \ six == 1) return false\n        if(three == 4 && four == 3 && five == 1 && six\
    \ == 1) return false\n        if(three == 4 && four == 3 && five == 2 && six ==\
    \ 1) return false\n        if(three == ", "        for (a <- l)\n            for\
    \ (b <- l)\n                if (a + b == 0)\n                    return true\n\
    \        return false", "        val list = l.toSet\n        val n = list.size\n\
    \        if (n == 1) true\n        else {\n            val first = list.head\n\
    \            val last = list.last\n            var sum = first\n            var\
    \ currentSum = 0\n            for (i<- 1 to n-1) {\n                currentSum\
    \ += list.apply(i)\n                if (currentSum != sum) {\n               \
    \     sum = currentSum\n                    false\n                } else {\n\
    \                    currentSum = 0\n                }\n            }\n      \
    \      true\n        }", "        // initialize two accumulators\n        var\
    \ a = 0\n        var b = 0\n        for( n <- l ) {\n            // check if first\
    \ element is already zero\n            if( n == 0 ) a += 1\n            // if\
    \ first element is not zero and second one already equals to zero\n          \
    \  else if( n == a && b == 0 ) {\n                a += 1\n                b +=\
    \ 1\n            }\n            // if first element is not zero and second one\
    \ is not zero\n            else if( n != a && n != b ) {\n                return\
    \ true\n            }\n            // otherwise if first element is not zero\n\
    \            else if (n != a) {\n                b += 1\n            }\n     \
    \   }\n        // if we get here a equals zero, b equals zero\n        // otherwise\
    \ both are different from zero\n        return a == 0 && b == 0", "        val\
    \ n = l.length\n        if (n <= 1) false\n        else {\n            var sum\
    \ = 0\n            var j = 0\n            while(j < n) {\n                if (l(j)\
    \ <= 0) break\n                else {\n                    sum += l(j)\n     \
    \               j += 1\n                }\n            }\n            val zeros\
    \ = l.filter(_ <= 0).length\n            return (zero != 0 && (sum == 0 || sum\
    \ == n) && zeros == n) ? true : false\n        }", "        val set: Set[Long]\
    \ = l.distinct\n        set.toList.forall(!set.contains)", "        if (l.length\
    \ == 0) false\n        else l.head == l.tail.head && pairsSumToZero(l.tail.tail)",
  "        l.foldLeft(true) {\n            (acc: Boolean, elem: Long) =>\n       \
    \     if (elem > 0) acc || elem == l.lastOption.getOrElse(0L) || \n          \
    \             ((acc && elem == 0L) || (!acc && (l.lastOption.getOrElse(0L) + elem\
    \ == 0L)))\n            else acc\n        }", "        var firstPair = False\n\
    \        var secondPair = False\n        var thirdPair = False\n        var fourthPair\
    \ = False\n        var fivethPair = False\n        var sixthPair = False\n   \
    \     var seventhPair = False\n        var firstPairSet = Set[Long]()\n      \
    \  var secondPairSet = Set[Long]()\n        var thirdPairSet = Set[Long]()\n \
    \       var fourthPairSet = Set[Long]()\n        var fivethPairSet = Set[Long]()\n\
    \        var sixthPairSet = Set[Long]()\n        var seventhPairSet = Set[Long]()\n\
    \n        for(i <- 0 until l.length)\n            if( (l.take(i)).sum == 0l)\n\
    \                if( (l.drop(i)).sum == 0l) {\n                    if( (l.take(i)).sum\
    \ != 0l)\n                        firstPair = True\n                    if( (l.drop(i)).sum\
    \ != 0l)\n                        secondPair = True\n                }\n     \
    \           else if( (l.take(i)).sum != 0l)\n                    if( (l.drop(i)).sum\
    \ == 0l) {\n                        thirdPair = True\n                       \
    \ if( (l.take(i)).sum != 0l)\n                            fourthPair = True\n\
    \                    }\n                    else {\n                        if(\
    \ (l.take(i)).sum != 0l)\n                            fivethPair = True\n    \
    \                    if( (l.drop(i)).sum != 0l) {\n                          \
    \  sixthPair = True\n                            if( (l.take(i)).sum != 0l)\n\
    \                                seventhPair = True\n                        }\n\
    \                    }\n        }\n        if(firstPairSet.isEmpty || secondPairSet.isEmpty\
    \ || thirdPairSet.isEmpty || fourthPairSet.isEmpty || fivethPairSet.isEmpty ||\
    \ sixthPairSet.isEmpty || seventhPairSet.isEmpty)\n            return false\n\
    \        else {\n            if(firstPairSet.size == 1)\n                return\
    \ (firstPairSet._1 == 0l)\n            if(secondPairSet.size == 1)\n         \
    \       return (secondPairSet._1 == 0l)\n            if(thirdPairSet.size == 1)\n\
    \                return (thirdPairSet._1 == 0l)\n            if(fourthPairSet.size\
    \ == 1)\n                return (fourthPairSet._1 == 0l)\n            if(fivethPairSet.size\
    \ == 1)\n                return (fivethPairSet._1 == 0l)\n            if(sixthPairSet.size\
    \ == 1)\n                return (sixthPairSet._1 == 0l)\n            if(seventhPairSet.size\
    \ == 1)\n                return (seventhPairSet._1 == 0l)\n        }", "     \
    \   val seen = mutable.HashSet[Long]()\n        var sum : Long = l.foldLeft(0L)(_\
    \ + _)\n        for (i <- 0 until l.size) {\n            val c = l(i)\n      \
    \      if (seen(c)) {\n                sum -= c\n            }\n            seen.add(sum)\n\
    \            sum += c\n        }\n        sum == 0", "        // pairs is a list\
    \ of all possible pairs in the list\n        // we keep track of the number of\
    \ pairs up to a certain index\n        // to know if the sum is zero.\n      \
    \  val pairs = l.sliding(2).map(i => (i(0), i(1)))\n        var sum = 0L\n   \
    \     pairs.foreach( pair => {\n            sum += pair._1\n            sum +=\
    \ pair._2\n        })\n        sum == 0", "        var x = 0L\n        var y =\
    \ 0L\n        var sum = 0L\n        for ((x, y) <- l.zipWithIndex) {\n       \
    \     sum += y\n            if (sum > 0) {\n                x = sum\n        \
    \        sum = 0\n            }\n        }\n        sum == 0", "        val set\
    \ = Set[Long]()\n        l.foreach { v =>\n            if (v != 0) {\n       \
    \         val newSum = l filter (v => v != 0) filter (v => v != v) reduce (_ +\
    \ _)\n                if (newSum == 0) {\n                    val newPairs = l.filter\
    \ (v => v != 0) filter (v => v != v) map (v => v.toLong)\n                   \
    \ set.add(v.toLong)\n                    set.add(newPairs.headOption.getOrElse(0))\n\
    \                }\n            }\n        }\n        set.size == 2", "      \
    \  var count = 0\n        l.foreach {\n            i => count = count + 1\n  \
    \      }\n        count <= 1", "        // create two separate data structures\
    \ to track pairs\n        // with sum zero\n        val pairs = mutable.Map[Long,\
    \ List[Long]]()\n        val notPairs = mutable.Map[Long, List[Long]]()\n\n  \
    \      // initialize two lists to hold pairs\n        var first = 0\n        var\
    \ second = 0\n        for (i <- l) {\n            val s = i / 2l.toLong\n    \
    \        pairs.getOrElseUpdate(s, l :: Nil) match {\n                case Nil\
    \ =>\n                    first = s\n                    second = s\n        \
    \        case l :: Nil =>\n                    first = s\n                   \
    \ second = s\n                case l :: r =>\n                    // pair exists,\
    \ check if first and second have opposite signs\n                    val sign1\
    \ = l.toLong * -1l.toLong\n                    val sign2 = r.toLong * -1r.toLong\n\
    \                    if (sign1 > sign2) {\n                        notPairs.getOrElseUpdate(s,\
    \ l :: r) match {\n                            case Nil =>\n                 \
    \               first = s\n                                second = s\n      \
    \                      case l :: r =>\n                                first =\
    \ s\n                                second = s\n                        }\n \
    \                   } else {\n                        notPairs.getOrElseUpdate(s,\
    \ l :: r) match {\n                            case Nil =>\n                 \
    \               first = s\n                                second = s\n      \
    \                      case l :: r =>\n                                first =\
    \ s\n                                second = s\n                        }\n \
    \                   }\n            }\n        }\n\n        // if no pair exists,\
    \ return false\n        if (notPairs.isEmpty) false\n        // if a pair exists,\
    \ return true\n        else true", '       l.map(x => if (x == 0l) 1l else x).sum
    == 0l', "        val a = 0l\n        val b = l.size\n        while (a < b) {\n\
    \            val c = a + 1l\n            while (c < b) {\n                if (l(c)\
    \ + l(c) == 0) {\n                    return true\n                }\n       \
    \         c += 1l\n            }\n            a += 1l\n        }\n        false",
  "        var lastElement = -1\n        var lastZero = -1\n        var pairsSumToZero\
    \ : Boolean = false\n        for(i <- 0 until l.length) {\n            if(l(i)\
    \ == lastElement && lastZero != 0) {\n                pairsSumToZero = false\n\
    \            }\n            if(l(i) == lastZero && lastElement != 0) {\n     \
    \           pairsSumToZero = true\n            }\n            lastElement = l(i)\n\
    \            lastZero = l(i) == 0 ? 0 : l(i)\n        }\n        pairsSumToZero",
  "        var sum_of_pairs = 0\n        for (i <- 0 until l.length) {\n         \
    \   // find all pairs whose values add to zero\n            val new_list = l filterNot\
    \ (i+1 until l.length).map (x => x.toLong).toSet\n            sum_of_pairs +=\
    \ new_list.count{x => x == 0}.asInstanceOf[Long]\n            if (sum_of_pairs\
    \ == 2) {\n                return true\n            }\n        }\n        false",
  "        val zeros = l.toSet\n        if (zeros.size == 0) false\n        else {\n\
    \            val pairs = l.groupBy(x => x - zeros.head)\n            if (pairs.size\
    \ == 0) false\n            else {\n                val nonZeroes = pairs.values.toSet\n\
    \                if (nonZeroes.size == 0) false\n                else {\n    \
    \                val diff = nonZeroes.size - zeros.size\n                    nonZeroes.size\
    \ == zeros.size || nonZeroes.size == (diff+1)\n                }\n           \
    \ }\n        }", "        // initialize result to false\n        var result :\
    \ Boolean = false\n        // loop through the input list\n        for (x <- l)\n\
    \            // if the input list contains a pair of elements whose sum is\n \
    \           // zero, return false and exit the loop\n            if (l.count(y\
    \ => y == x + y) == 2)\n                result = true\n        // return the result\n\
    \        result", "        def isPair(l: List[Long]) : Boolean = {\n         \
    \   if (l.size % 2 != 0)\n                return false\n            else\n   \
    \             var i : Int = 0\n                var j : Int = 0\n             \
    \   var sum : Long = 0\n                var found : Boolean = false\n        \
    \        while (i < l.length) {\n                    sum = sum + l(i)\n      \
    \              if (sum != 0) {\n                        found = true\n       \
    \             }\n                    i = i + 1\n                }\n          \
    \      if (found) {\n                    if (i == l.length-1)\n              \
    \          return true\n                    else {\n                        while\
    \ (j < l.length) {\n                            sum = sum + l(j)\n           \
    \                 if (sum != 0) {\n                                found = true\n\
    \                                break\n                            }\n      \
    \                      j = j + 1\n                        }\n                \
    \        return found\n                    }\n                }\n            \
    \    return false\n        }\n        if (isPair(l))\n            return false\n\
    \        else {\n            var i = 0\n            var j = 0\n            var\
    \ sum : Long = 0\n            var found : Boolean = false\n            while (i\
    \ < l.length) {\n                sum = sum + l(i)\n                if (sum !=\
    \ 0) {\n                    found = true\n                }\n                i\
    \ = i + 1\n            }\n            if (found) {\n                if (i == l.length-1)\n\
    \                    return true\n                else {\n                   \
    \ while (j < l.length) {\n                        sum = sum + l(j)\n         \
    \               if (sum != 0) {\n                            found = true\n  \
    \                          break\n                        }\n                \
    \        j = j + 1\n                    }\n                    return found\n\
    \                }\n            }\n            return false\n        }", "   \
    \     val zero = l.find(_ == 0)\n        val nonZero = l.find(_ != 0)\n      \
    \  nonZero.isEmpty && zero.isEmpty", "        val map1 = new mutable.HashMap[Long,\
    \ Long]()\n        val map2 = new mutable.HashMap[Long, Long]()\n        for (i\
    \ <- 0 until l.size) {\n            if (map1.contains(l(i))) {\n             \
    \   map2.put(l(i), map1(l(i)))\n            } else {\n                map1.put(l(i),\
    \ l(i))\n            }\n        }\n        map2.size == 0", "        val map1\
    \ = l.map(_ => 0l)\n        val map2 = l.map(_ => 0l)\n        l.zip(l.tail).foreach\
    \ { e =>\n            map1(e._1) += e._2\n            map2(e._1) -= e._2\n   \
    \         if (map1(e._1) != 0 || map2(e._1) != 0) return false\n        }\n  \
    \      true", "        var sum = 0\n        var count = 0\n        l.foreach{e\
    \ => if(e > 0) sum += e else sum += -e}\n        while(sum > 0){\n           \
    \ var min = math.abs(sum)\n            var sumOfMin = 0\n            count = 0\n\
    \            l.foreach{e => if(sumOfMin < e){\n                count += 1\n  \
    \              sumOfMin += e\n            }}\n            if(count > 1){\n   \
    \             return true\n            }\n            sum -= min\n        }\n\
    \        return false", "        var i = 0\n        var sum = 0\n        var first\
    \ = l(i).asInstanceOf[Long]\n        for(i <- i until l.length) {\n          \
    \  sum += l(i).asInstanceOf[Long]\n            if(sum < 0)\n                return\
    \ false\n        }\n        return sum == 0", "        l.foldLeft(false){\n  \
    \          case (true, (a, b)) if a+b == 0 => false\n            case (true, (a,\
    \ b)) => true\n            case (false, (a, b)) => false\n        }", "      \
    \  val set = l.reduceLeft{ (a, b) => a + b }.toSet\n        set.size == l.length\
    \ && set.size == l.sum", "        val pairs = l.groupBy(l => l.toLong / 2).filter(_._1.size\
    \ == 2).map(_._2)\n        val allZeros = pairs.forall { p =>\n            p.forall(l\
    \ => l.toLong == 0 || l == 0)\n        }\n        return allZeros", "        val\
    \ n = l.length\n        val pairs = mutable.HashSet[Long]()\n        for (i <-\
    \ 0 until n)\n            for (j <- i + 1 until n)\n                if (l(i) +\
    \ l(j) == 0) pairs += l(i) -> l(j)\n        pairs.size == 2", "        val pairs\
    \ = (for {\n            i <- l.iterator\n            j = l.filter(_ != i).iterator\n\
    \        } yield (i, j)).groupBy(t => t._1).filterNot(t => t._2.isEmpty)\n   \
    \     var sum = 0.0\n        for (k <- pairs) sum += k._2.sum\n        (sum !=\
    \ 0)", "        val l1 = l.toSet.toList\n        if (l1.size == 1) false\n   \
    \     else if (l1.size == 2) l1.head == 0l\n        else {\n            val two\
    \ = l1.head + l1.last\n            val twoSet = Set(l1.last, l1.head)\n      \
    \      val three = l1.last + l1.head\n            val threeSet = Set(l1.last)\n\
    \            if (twoSet.subsetOf(twoSet) && threeSet.subsetOf(threeSet)) false\n\
    \            else true\n        }", "        val pairs = l.map(x => (x, l.filter(\
    \ y => x != y).length)).toSet\n        if (pairs.size == 1)\n            pairs(0)\
    \ != 0\n        else\n            pairs.forall { case (a, b) => a == 0 && b !=\
    \ 0 }", "        def pairsSumToZeroHelper(l : List[Long], found : mutable.Set[Long])\
    \ : Boolean = {\n            if (l.isEmpty) found.contains(0)\n            else\
    \ {\n                if (l.reduceLeft(_ + _) == 0) pairsSumToZeroHelper(l.tail,\
    \ found + l.head)\n                else {\n                    pairsSumToZeroHelper(l.tail,\
    \ found)\n                }\n            }\n        }\n        pairsSumToZeroHelper(l,\
    \ mutable.Set(0))", "        var pairs = mutable.ListBuffer[Long]()\n        for\
    \ (i <- l)\n            if (i > 0) {\n                var pair = (i.toLong, (i-1).toLong)\n\
    \                if (!pairs.contains(pair))\n                    pairs += pair\n\
    \            }\n        pairs.size == 1", "        val pairs = l.groupBy(_ % 2)\n\
    \        pairs exists { case (x, y) => y > 0 && x == 2 }", "        val n = l.length\n\
    \        if (n == 0) false\n        else if (n == 1) true\n        else {\n  \
    \          var i = n-1\n            val pairs = mutable.Map[Long, List[Long]()]\n\
    \            while (i >= 0) {\n                pairs(l(i)) = l(i).toList :: pairs.get(l(i))\n\
    \                i -= 1\n            }\n            val x = pairs.get(0).get(0)\n\
    \            if (x == 0) pairsSumToZero(pairs.values.toList)\n            else\
    \ pairsSumToZero(pairs.values.filter(_(_) == x).flatten)\n        }", "      \
    \  val pairs = l.toSeq.groupBy(x => x % 2 == 0).toSeq\n        val twoCounts =\
    \ pairs.count(x => x._2)\n        val oneCounts = pairs.count(x => x._1)\n   \
    \     if (twoCounts == 0 || oneCounts == 0)\n            false\n        else\n\
    \            pairs.forall { x =>\n                if (x._1 && !x._2) oneCounts\n\
    \                else if (x._2 && !x._1) twoCounts\n                else false\n\
    \            }", "        val n = l.length\n        val sums = mutable.ArrayBuffer.empty[Long]\n\
    \        var sum = 0\n        for (i<-n;i>=0;i--) {\n            sum += l(i)\n\
    \            sums += sum\n        }\n        for (j<-n;j>=0;j--) {\n         \
    \   sum += sums(j)\n            if (sum == 0) return false\n            sums -=\
    \ sum\n        }\n        true", "      l.foldLeft((false, 0l)) {\n        case\
    \ ((sum, lastSum), x) =>\n          if (x == lastSum && sum != 0l) \n        \
    \      (true, x) else (false, x)\n      }._1", "        val sumToZero = l.map({\
    \ n => n * n }).sum\n        val noOfPairs = l.size / 2\n        val differences\
    \ = l.zip(l.tail).map { case (x, y) => x - y }\n        val distinctValues = differences.distinct\n\
    \        distinctValues.size == noOfPairs && distinctValues.forall(n => sumToZero\
    \ - n == 0)", "        var countOnes = false\n        var countTwos = false\n\
    \        var total = 0\n        for (i <- l) {\n            total += i\n     \
    \       if (i > 0) {\n                if (i % 2 == 0) {\n                    countTwos\
    \ = true\n                } else {\n                    countOnes = true\n   \
    \             }\n            }\n        }\n        return (total == 0) || (countOnes\
    \ && countTwos)", "        val nList = l.toSet\n        val m = nList.size\n \
    \       if(m == 0){\n            true\n        }else if(m == 1){\n           \
    \ false\n        }else{\n            val zeros = nList.filter(x => x==0)\n   \
    \         val pairs = nList.filter(x => x>0)\n            val pairs2zeros = pairs.filter(x\
    \ => x==0)\n            if(zeros.size == 0){\n                if(pairs2zeros.size\
    \ ==0){\n                    false\n                }else{\n                 \
    \   pairsSumToZero(pairs2zeros)\n                }\n            }else{\n     \
    \           pairsSumToZero(pairs)\n            }\n        }", "        var last\
    \ = 0\n        val pairs = l map { t => last = t; last }\n        val pairs1 =\
    \ pairs.distinct\n        val pairs2 = pairs1.filterNot(pairs1.contains)\n   \
    \     val pairs3 = (pairs zip pairs1) map {\n            case (x, y) => if (x\
    \ + y == 0) true\n            else false\n        }\n        pairs2.forall(x =>\
    \ x)", "        import scala.math._\n        import scala.collection.mutable._\n\
    \        val set = new mutable.HashSet[Long]()\n        for (x <- l) set += x\n\
    \        return set.size == 2 && (set.contains(0l) && set.contains(l.last))"]
stop_tokens:
- "\n    }\n"
