name: HumanEval_40_triples_sum_to_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // triples_sum_to_zero takes a list of integers as an input.\n    // it returns\
  \ true if there are three distinct elements in the list that\n    // sum to zero,\
  \ and false otherwise.\n    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong,\
  \ 5l.toLong, 0l.toLong)))\n    // (false)\n    // >>> triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong)))\n    // (true)\n    // >>> triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong)))\n    // (false)\n    // >>> triplesSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))\n    // (true)\n   \
  \ // >>> triplesSumToZero((List[Long](1l.toLong)))\n    // (false)\n    def triplesSumToZero(l\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, -1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 5l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong)))\
  \ == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong,\
  \ -100l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](100l.toLong,\
  \ 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    }\n\n}\n"
completions: ["        var i = 0\n        var sum = 0\n        var flag = false\n\
    \        for (i <- 0 until l.length) {\n            sum = sum + l(i)\n       \
    \ }\n        if (sum % 3 == 0) {\n            flag = true\n        }\n       \
    \ return flag", "        // use hashSet to keep track of unique integers\n   \
    \     val hashSet = scala.collection.mutable.HashSet.empty[Long]\n        l.foreach(x\
    \ => hashSet.add(x))\n        hashSet.size == 3", "        val count = mutable.ListBuffer[Long]()\n\
    \        for ((a, b, c) <- l)\n            if (a+b+c == 0)\n                count\
    \ += c\n        if (count.size == 3)\n            true\n        else\n       \
    \     false", "        // initialize an accumulator to store our three sums\n\
    \        var totalSum : Long = 0L\n        var sumOne : Long = 0L\n        var\
    \ sumTwo : Long = 0L\n        // for each number in the list, sum it up\n    \
    \    for (a <- l) {\n            totalSum += a\n            // if the total is\
    \ greater than zero\n            if (totalSum > 0l) {\n                // reset\
    \ the accumulator\n                sumOne = 0L\n                sumTwo = 0L\n\
    \                // keep track of which sum we're on\n                for (i <-\
    \ 0 until totalSum) {\n                    // if the number is equal to or below\
    \ zero\n                    if (a <= 0) {\n                        // set the\
    \ sum of the other two sums to 0\n                        sumOne += 0\n      \
    \                  sumTwo += 0\n                        // break the loop since\
    \ we've found our answer\n                        break\n                    }\n\
    \                    // add the number to the current sum\n                  \
    \  sumOne += a\n                    // keep track of which sum we're on\n    \
    \                for (j <- 0 until totalSum) {\n                        // if\
    \ we've found a number that is greater than zero\n                        if (i\
    \ >= j) {\n                            // set the sum of the other two sums to\
    \ 0\n                            sumOne += 0\n                            sumTwo\
    \ += 0\n                            // break the loop since we've found our answer\n\
    \                            break\n                        }\n              \
    \          // add the number to the current sum\n                        sumTwo\
    \ += a\n                    }\n                }\n                // if we've\
    \ found our answer\n                if (sumOne == 0l && sumTwo == 0l) {\n    \
    \                // return true\n                    true\n                //\
    \ else return false\n                } else {\n                    false\n   \
    \             }\n            }\n        }", "        var lastElement : Long =\
    \ 0\n        var sum = 0\n        val numOfElements = l.length\n        for (i<-0\
    \ until numOfElements) {\n            sum += l(i)\n            if (sum < 0) {\n\
    \                sum = sum + lastElement\n            }\n            if (sum ==\
    \ 0) return true\n            lastElement = l(i)\n        }\n        return false",
  "        // The idea is to create three sets of numbers (x1,x2,x3) for a triple\n\
    \        // that sums to zero.\n        // For every element in the list, if the\
    \ sum of the three elements in\n        // the list is zero then add the element\
    \ to an empty list. Then sum\n        // the empty list to check if all elements\
    \ in the list sum to zero.\n        // If there is only one element in the list\
    \ that sums to zero then\n        // return true.\n        // Otherwise, return\
    \ false.\n        // In each iteration, we take the first element in the list.\
    \ The element\n        // is added to an empty list. We then find the sum of empty\
    \ list\n        // and check if it is equal to zero.\n        // If the sum is\
    \ equal to zero then we are done and we return true.\n        // If there are\
    \ two elements that sums to zero then we need to create an\n        // empty list\
    \ for each list to sum to zero and sum the three empty lists.\n        // This\
    \ continues until we find a list that sums to zero.\n        // The next time\
    \ the list that sums to zero becomes the list we are\n        // checking and\
    \ we repeat until we find an element that sums to zero.\n        // If there are\
    \ no elements that sum to zero then return false.\n        val emptySet = scala.collection.mutable.Set[Long]()\n\
    \        var set1 = emptySet\n        var set2 = emptySet\n        var set3 =\
    \ emptySet\n        var sumOfSet1 = 0\n        var sumOfSet2 = sumOfSet1\n   \
    \     var sumOfSet3 = sumOfSet1\n        var firstElementOfList = l.head\n   \
    \     var list2 = l.tail\n        var list3 = l.tail\n        while (list2.isEmpty)\
    \ {\n            val x = l.head\n            val y = l.head\n            val z\
    \ = l.head\n            set1 += x\n            set2 += y\n            set3 +=\
    \ z\n            sumOfSet1 += x\n            sumOfSet2 += y\n            sumOfSet3\
    \ += z\n            list2 = list3.tail\n            list3 = list2.tail\n     \
    \   }\n        while (list3.isEmpty) {\n            val x = l.head\n         \
    \   val y = l.head\n            val z = l.head\n            set1 += x\n      \
    \      set2 += y\n            set3 += z\n            sumOfSet1 += x\n        \
    \    sumOfSet2 += y\n            sumOfSet3 += z\n            list2 = list3.tail\n\
    \            list3 = list2.tail\n        }\n        if (set1.size == 3) {\n  \
    \          // lists set1, set2, set3 contain three distinct elements that sum\
    \ to zero\n            // the sum of the three elements is zero.\n           \
    \ // add the first element to empty list and check if sum of\n            // empty\
    \ list is equal to zero\n            if (", "        val l1 = l.toList\n     \
    \   var l2 = l1\n        var sum = 0\n        var found = false\n        while\
    \ (found == false)\n        {\n            var j = 0\n            var numFound\
    \ = false\n            while (j < l2.size)\n            {\n                sum\
    \ = sum + l2(0)\n                if (sum == 0)\n                {\n          \
    \          numFound = true\n                }\n                else\n        \
    \        {\n                    sum -= l2(0)\n                }\n            \
    \    j++\n            }\n            if (numFound == false)\n            {\n \
    \               found = true\n            }\n            else\n            {\n\
    \                found = false // don't count this element again\n           \
    \     l2 = l1.drop(j)\n            }\n        }\n        l1 == l2", "        //\
    \ Initialize result\n        var result = false\n        // Initialize current\
    \ sum\n        var currentSum = 0\n        // Initialize triples counter\n   \
    \     var triplesCounter = 0\n        // For each element in the list\n      \
    \  for (elem <- l) {\n            // Increment triples counter\n            triplesCounter\
    \ = triplesCounter + 1\n            // Check if current triplesCounter equals\
    \ 3\n            if (triplesCounter == 3) {\n                // Check if current\
    \ triplesCounter is greater than 0\n                if (currentSum != 0) {\n \
    \                   // If current triplesCounter is greater than 0, set result\n\
    \                    result = true\n                }\n                // Reset\
    \ triplesCounter\n                triplesCounter = 0\n            }\n        \
    \    // Add current element to the current sum\n            currentSum = currentSum\
    \ + elem\n        }\n        // Check if result is still true\n        result",
  "        val set = new mutable.HashSet[Long]()\n        val sums = new mutable.HashSet[Long]()\n\
    \        for ((a, b) <- l) {\n            if (set.contains(a) && set.contains(b))\
    \ {\n                sums += b\n            }\n            set.add(a)\n      \
    \  }\n        sums.size == 3", "        val unique = l distinct l.take(3) filter\
    \ (l => l.sum == 0)\n        if (unique.length == 3)\n            true\n     \
    \   else\n            false", "        val set = mutable.Set[Long]()\n       \
    \ for(i <- l)\n            if(!set.add(i))\n                return false\n   \
    \     return true", "        val sum = l.foldLeft(0L)((a, b) => a + b)\n     \
    \   l.count(i => sum - i) == 3", "        l.forall {\n            case x if l.contains(x\
    \ - x.toLong.toInt) =>\n                l.filter(y => y > x).length == 3\n   \
    \     }", "        val totalSum = l.foldLeft((0l, 0l))((sum,v) => \n         \
    \       (v + sum._2, sum._1 + v + sum._2)) \n        totalSum._2 == 0", "    \
    \    val pairs = l zip l.tail\n        pairs.toList exists { x => x._1 + x._2\
    \ == 0 }", "        val numDistinctElements = l.distinct.size\n        if(numDistinctElements\
    \ < 3) {\n            return false\n        }\n        val candidatesSet = l.toSet\n\
    \        val tripletsSet = candidatesSet + candidatesSet\n        tripletsSet.subsetOf(candidatesSet)",
  "        if (l.size < 3) {\n            return false\n        }\n        val total\
    \ = 0l\n        l.foreach(x => total += x)\n        if (l.size == 3) {\n     \
    \       return (total != 0) && (total != 3l)\n        }\n        var i = 0\n \
    \       var j = 0\n        var k = 0\n        l.foreach(x => { i += (x - total);\
    \ if (k == 0) { k = i; j = x } else { k -= i; j = x} })\n        return (k ==\
    \ 1l) && (j == total)", "        val m = l\n        val set = m.toSet\n      \
    \  val res = set.size == 3 && set.forall(i => m.filter(_ != i).length == 1)\n\
    \        res", "        def triplesSumHelper(l : List[Long], acc : mutable.Set[Long])\
    \ : Boolean = {\n            l match {\n                case Nil => false\n  \
    \              case head :: tail => if (acc.contains(head+tail)) triplesSumHelper(tail,\
    \ acc) else triplesSumHelper(tail, acc ++ Set(head+tail))\n            }\n   \
    \     }\n        triplesSumHelper(l, mutable.Set.empty[Long])", "      l match\
    \ {\n        case x::xs => triplesSumToZero(xs, xs)(x.toLong + xs.last)\n    \
    \    case Nil => false\n      }", "        l match {\n            case Nil =>\
    \ false\n            case h :: t => triplesSumToZero(t.filter(( x => x%3 != 0)\
    \ || (x%5 != 0)) ::: h) \n        }", "        val setOfThree = {\n          \
    \  // create a set of three distinct elements among the input list\n         \
    \   val setOfThree = l.foldLeft(mutable.Set.empty[Long]) { (s, x) =>\n       \
    \         s ++ Set(x.toLong, s.lastOption.map(x => x + x.toLong).getOrElse(0l.toLong))\n\
    \            }\n            // check that each of the elements of the set add\
    \ to zero.\n            setOfThree.forall(x => x == 0l.toLong)\n        }\n  \
    \      setOfThree", "        val set = l.toSet\n        set.size == 3 && set.forall(_\
    \ != 0)", "        val set = mutable.Set[Long]()\n        l.foreach {\n      \
    \      i =>\n            if(!set.add(i))\n                set.add(0)\n       \
    \ }\n        set.length == 3", "        // (1) Create a map to keep track of the\
    \ values seen so far\n        val map = new mutable.HashMap[Long,Int]\n      \
    \  for (x <- l)\n        map.put(x, map.getOrElse(x, 0)+1)\n        // (2) Find\
    \ the triplets that sum to zero\n        val sumZero = for ( (k,v) <- map) if\
    \ (v==3 && k-map.get(k)==0) yield (k,v)\n        sumZero.length==0", "       \
    \ l match {\n            case Nil => false\n            case h :: t => triplesSumToZero(tail(l\
    \ drop 1)) && triplesSumToZero(t drop 1) && triplesSumToZero(t(0) + h) && triplesSumToZero(tail(l\
    \ drop 1))\n        }", "        val threeDistinctSums = l\n            .filter(\
    \ n => l.count(_ == n) == 3 )\n            .map( _ + _ )\n            .distinct\n\
    \            .filter( n => n == 0 )\n        threeDistinctSums.isEmpty == false",
  "        val l1 = l.distinct\n        var x = 0\n        var y = -1\n        for(a\
    \ <- l1){\n            if(y != -1){\n                if(y != a){\n           \
    \         if(x < a){\n                        x = a\n                    }\n \
    \               }\n            }else{\n                x = a\n            }\n\
    \            y = a\n        }\n        if(y == 0)\n            true\n        else\n\
    \            false", "        val nums = mutable.HashSet.empty[Long]\n       \
    \ l.foreach { x =>\n            if (nums.contains(x)) { return false }\n     \
    \       nums += x\n        }\n        nums.size == 3", "        def triples_sum_to_zero(p1:\
    \ List[Long], p2: List[Long], p3: List[Long]) : Boolean = \n            p2.head\
    \ == 0l && p3.head == 0l && p1.head == 0l\n        if(l.isEmpty)\n           \
    \ return false\n        else if(l.head == 0l)\n            return true\n     \
    \   else {\n            val h1 = l.head - 1\n            val h2 = l.head + 1\n\
    \            val h3 = l.head + 2\n            if(p1.head < h1)\n             \
    \   if(triples_sum_to_zero(l.tail, l.tail, l.tail))\n                    return\
    \ true\n                else\n                    return false\n            else\n\
    \                if(p1.head == h1)\n                    if(p2.head < h2)\n   \
    \                     if(triples_sum_to_zero(l.tail, p2.tail, p3.tail))\n    \
    \                        return true\n                        else\n         \
    \                   return false\n                    else\n                 \
    \       if(p2.head == h2)\n                            if(p3.head < h3)\n    \
    \                            if(triples_sum_to_zero(l.tail, p3.tail, p3.tail))\n\
    \                                    return true\n                           \
    \     else\n                                    return false\n               \
    \             else\n                                if(p3.head == h3)\n      \
    \                              if(triples_sum_to_zero(l.tail, p3.tail, p3.tail))\n\
    \                                        return true\n                       \
    \             else\n                                        return false\n   \
    \                             else\n                                    return\
    \ false\n                        else\n                            return false\n\
    \        }", "        val nums = l.distinct\n        val numSums = l.map { _ *\
    \ 2 }\n        if (numSums.reduceLeft(_ + _) != nums.sum) false\n        else\
    \ nums.size == 3", "        if (l.length < 3) return false;\n        var a: List[Long]\
    \ = l;\n        for (x <- l.tail) {\n            val y = l.head\n            for\
    \ (j <- 0 until a.length){\n                if (abs(a[j]) > abs(x-y)) {\n    \
    \                a = a.diff(j)\n                } else {\n                   \
    \ return true;\n                }\n            }\n        }\n        return false;",
  "        val set = new mutable.HashSet[Long]()\n        for (x <- l)\n         \
    \   set += x\n        (set.size == 3) && (set.exists(x => x == 0l))", "      \
    \  var listCopy = l\n        val countMap = mutable.Map[Long, Long]()\n      \
    \  while (listCopy.length > 0) {\n            val current = listCopy.head\n  \
    \          val sum = current + listCopy.last\n            if (sum > 0) {\n   \
    \             countMap += (sum -> (countMap.getOrElse(sum, 0) + 1l))\n       \
    \         listCopy = listCopy.tail\n            } else {\n                listCopy\
    \ = listCopy.tail\n            }\n        }\n        countMap.size > 1 &&\n  \
    \          (countMap.exists(k => k._2 <= 1) &&\n                countMap.exists(k\
    \ => k._2 <= 3))", "        val counts = l.groupBy(x => x).mapValues(_.size)\n\
    \        var sum = 0\n        for (triple <- triples_sum_helper(counts)) {\n \
    \           sum += triple\n            if (sum < 0l)\n                return false\n\
    \        }\n        return true", "        l.foldLeft((List[Long](), 0l, 0l))\
    \ { (acc: List[Long], x: Long, y: Long) =>\n            val (xs, ys, zs) = acc\n\
    \            if (x == y)\n                if (x == 0)\n                    (xs,\
    \ y, zs)\n                else\n                    (xs, zs, y + zs)\n       \
    \     else\n                (xs, zs, y + zs)\n        }._3.equals(0)", "     \
    \   val set = HashSet[Long](l)\n        return set.size == 3 && set.sum == 0",
  "        if (l.size != 3) {\n            return false\n        }\n        var sum\
    \ = 0l\n        var i = 0\n        var j = 1\n        while (i < l.length && j\
    \ < l.length) {\n            sum = sum + l(i) + l(j)\n            if (sum == 0)\n\
    \                return true\n            i += 1\n            j += 1\n       \
    \ }\n        return false", "        var i = 0\n        var triples = 0\n    \
    \    while (i < l.length) {\n            if (l(i) == 0) {\n                triples\
    \ = triples + 1\n                if (triples == 3) {\n                    return\
    \ true\n                }\n            }\n            i = i + 1\n        }\n \
    \       return false", "        var lSet = mutable.HashSet[Long]()\n        var\
    \ index = 0\n        for (i <- l) {\n            if (lSet.contains(i)) {\n   \
    \             lSet.remove(i)\n                lSet.add(index + 1)\n          \
    \      index += 2\n            } else {\n                lSet.add(i)\n       \
    \     }\n        }\n        !(lSet.size == 3 && lSet.size == 0)", "        var\
    \ i = 1\n        val count = new mutable.HashMap[Long, Int]()\n        while(i\
    \ <= l.length) {\n          val value = l(i)\n          if(count.contains(value))\
    \ {\n            count.remove(value )\n          }\n          else {\n       \
    \     count(value) = count.get(value, 0) + 1\n          }\n          i += 1\n\
    \        }\n        count.size == 3", "        val threeInts = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        l.foreach { i =>\n            if (i != 0 && i != l.last) { threeInts\
    \ += i }\n        }\n        if (threeInts.size != 3) {\n            return false\n\
    \        }\n        var total = 0l\n        threeInts.foreach { i => total +=\
    \ i }\n        if (total != 0) {\n            return false\n        }\n      \
    \  true", "        val uniqueList: Set[Long] = l.distinct filter (x => l.count(_\
    \ == x) > 1)\n        uniqueList.count(l => l.sum == 0) >= 3", "        val a\
    \ = l.toSet.toList\n        if (a == null || a.size != 3) return false\n     \
    \   val sum = a.sum\n        if (sum != 0) return false\n        val zeros = a.filter(x\
    \ => x != 0).toSet\n        if (zeros.size == 1) return false\n        if (zeros.size\
    \ == 2) return true\n        val m = a.indexOf(0)\n        if (m == 0) return\
    \ false\n        if (m - 1 >= zeros.size) {\n            val x = zeros.toSeq.find(_\
    \ == m - 1)\n            if (x == -1) return false\n            val y = zeros.toSeq.find(_\
    \ == x)\n            if (y == -1) return true\n            val z = zeros.toSeq.find(_\
    \ == y)\n            if (z == -1) return true\n        }\n        val z = zeros.toSeq.find(_\
    \ == m)\n        if (z == -1) return true", "      import scala.math._\n     \
    \ import scala.collection.mutable._\n      val count = mutable.HashMap[Long, Int]()\n\
    \      l.foreach(x => if (count.contains(x+0) || (x>0 && x<0))) count(x+0) +=\
    \ 1\n      count(0)==3", "        val nums = l\n        val numSet = nums.toSet\n\
    \        val s = Set.empty[Long]\n        for (i<-0 until nums.length)\n     \
    \       if(nums(i) != 0) s += nums(i)\n        s contains 0", "        val numSet\
    \ = l.toSet\n        numSet.size == 3 &&\n          (l.foldLeft(true)(_ + _) ==\
    \ 0 ||\n           l.foldRight(true)(_ + _) == 0)", "        var sum = 0\n   \
    \     for (i <- l)\n            sum += i\n        l match {\n            case\
    \ Nil => sum == 0\n            case _ => {\n                // we have three distinct\
    \ elements that sum to zero\n                // if one is non-zero, there will\
    \ be two other elements that sum to zero\n                // we consider one non-zero\
    \ element to be the one with the smallest value\n                // we check to\
    \ see if the smallest value is 0\n                // the smallest value is the\
    \ one with the smallest index, hence the min\n                // we check to see\
    \ if the sum of the two smaller elements is zero\n                // these two\
    \ values must both be non-zero\n                // we compare the sum of the two\
    \ elements to the sum of the two zeroes\n                // this should return\
    \ true if two sums are equal\n                // if these two sums are equal,\
    \ the smallest element was the one with smallest value\n                // this\
    \ sum is the sum of the three distinct elements that sum to zero\n           \
    \     val zeroes: Set[Long] = l.filter(_ != 0)\n                if (zeroes.size\
    \ == 2) {\n                    val smallestZero: Long = zeroes.min\n         \
    \           val secondSmallestZero: Long = zeroes.min - smallestZero\n       \
    \             if (smallestZero == 0 && secondSmallestZero == 0)\n            \
    \            sum == 0\n                    else\n                        sum ==\
    \ 0\n                } else false\n            }\n        }", "        if (l.length\
    \ < 3) {\n          l.contains(0l) || l.contains(l.sum)\n        } else {\n  \
    \        l.tail.tail.contains(0l) || triplesSumToZero(l.tail.tail) || l.tail.contains(l.tail.sum)\n\
    \        }", "        var sum = 0l\n        for (x <- l) {\n            sum +=\
    \ x\n        }\n        if (sum < 0l)\n            false\n        else {\n   \
    \         for (x <- l) {\n                if ((sum - x) == 0)\n              \
    \      return true\n            }\n            false\n        }", "        l match\
    \ {\n            case Nil => false\n            case x::xs =>\n              \
    \  if (l.contains(x + x)) {\n                    triplesSumToZero(xs)\n      \
    \          } else {\n                    triplesSumToZero(xs)\n              \
    \  }\n            case y::ys =>\n                if (l.contains(y - y)) {\n  \
    \                  triplesSumToZero(ys)\n                } else {\n          \
    \          triplesSumToZero(ys)\n                }\n            case z::zs =>\n\
    \                if (l.contains(z - z)) {\n                    triplesSumToZero(zs)\n\
    \                } else {\n                    triplesSumToZero(zs)\n        \
    \        }\n        }", "      val ns = l.reduceLeftOption(_ + _)\n      ns.getOrElse(0)\
    \ != 0", "        var sum = 0\n        for (i <- l)\n            sum += i\n  \
    \      l.size == 3 && sum == 0", "        def triplesSumToZero(sum : Long, l :\
    \ List[Long]) : Boolean = l match {\n            case Nil => sum == 0\n      \
    \      case head :: tail => triplesSumToZero(sum + head, true) \n            case\
    \ head :: tail => triplesSumToZero(sum + head, tail) \n            case Nil =>\
    \ sum == 0\n        }\n        triplesSumToZero(l.sum, l)", "        val m = mutable.HashSet[Long]()\n\
    \        l.foreach {x => m.add(x+0)}\n        return m.size == 3", "        var\
    \ sum = 0L\n        for (i <- l) {\n            sum += i\n        }\n        sum\
    \ == 0", "        def subsum(nums: List[Long], sum: Long) : Boolean = {\n    \
    \        if (nums.isEmpty) sum == 0\n            else {\n                val newSum\
    \ = sum + nums.head\n                if (subsum(nums.tail, newSum)) true else\
    \ false\n            }\n        }\n        subsum(l, 0L)", "        val n = 0\n\
    \        var sum = 0\n        var next = 0\n        var found = false\n      \
    \  l.foreach{e =>\n            if (sum == 0)\n                sum = e\n      \
    \      else {\n                sum += e\n                if (sum == 0) found =\
    \ true\n            }\n        }\n        return found", "        val sums = l.groupBy(x\
    \ => (x % 3) + 1).map(x => (x._1, x._2.length)).toMap\n        if(sums.size ==\
    \ 3) {\n            if(sums.get(1).toLong + sums.get(2).toLong == sums.get(3).toLong)\
    \ {\n                true\n            } else {\n                false\n     \
    \       }\n        } else {\n            false\n        }", "        l.groupBy(_\
    \ % 3) ++ l.groupBy(_ % 3) forall { \n            case (a, b, c) => (a != 0 &&\
    \ b == 0 && c != 0) || (a == 0 && b != 0 && c == 0) || (a != 0 && b != 0 && c\
    \ == 0)\n        }", "        var zero = l.length\n        var foundThree = False\n\
    \        val longs = l.toStream\n        var triples = longs.grouped(3).map(a\
    \ => a.sum)\n        triples = triples.takeWhile(t => t > 0).distinct\n      \
    \  triples = triples.take(zero)\n        triples.forall { t =>\n            if\
    \ (t < zero) foundThree = true else foundThree = false\n        }\n        foundThree",
  "        if (l.isEmpty) return true\n        val h = l.head + l.tail.head\n    \
    \    h match {\n            case 0 => true\n            case 1 => triplesSumToZero(l.tail)\n\
    \            case _ => triplesSumToZero(l.tail.tail)\n        }", "        if(l.isEmpty)\
    \ false\n        val count = l.foldLeft(0L)((count, e) => (count + (if (e > 0)\
    \ e else -e))) \n        (count == 3)", "        val hSet = mutable.HashSet[Long]()\n\
    \        for (i <- l) {\n            if (hSet.contains(i))\n                return\
    \ false\n            hSet.add(i)\n        }\n        true", "        val t = l.toSet\n\
    \        if (t.size < 3) {\n            return false\n        }\n        var sum\
    \ = 0\n        for (i <- 0 until t.size) {\n            sum += t.get(i)\n    \
    \    }\n        return t.size == 3 && sum == 0", "        // count the number\
    \ of distinct elements in the input list\n        var distinct : Int = 0\n   \
    \     for (i<-l.length <- (0 until l)) {\n            if (l.filter(_ != i).distinct().length\
    \ == l(i)) {\n                distinct += 1\n            }\n        }\n\n    \
    \    if (distinct == 3) {\n            // there are three distinct elements that\
    \ sum to zero\n            return true\n        } else {\n            // no three\
    \ distinct elements that sum to zero\n            return false\n        }", " \
    \       var result : Boolean = false\n        var x = 0\n        var y = 0\n \
    \       var z = 0\n        var n = 0\n        var xsum = 0\n        var ysum =\
    \ 0\n        var zsum = 0\n        var nsum = 0\n        for( x <- l ) {\n   \
    \         if( x == 0 ) {\n                result = false\n                break\n\
    \            }\n            if( xsum < x ) {\n                xsum = x\n     \
    \       }\n            nsum += 1\n        }\n        for( y <- l ) {\n       \
    \     if( y == 0 ) {\n                result = false\n                break\n\
    \            }\n            if( ysum < y ) {\n                ysum = y\n     \
    \       }\n            nsum += 1\n        }\n        for( z <- l ) {\n       \
    \     if( z == 0 ) {\n                result = false\n                break\n\
    \            }\n            if( zsum < z ) {\n                zsum = z\n     \
    \       }\n            nsum += 1\n        }\n        for( x <- l ) {\n       \
    \     if( n == 0 ) {\n                result = false\n                break\n\
    \            }\n            if( xsum - xsum == x ) {\n                result =\
    \ true\n            }\n            n -= 1\n        }\n        for( y <- l ) {\n\
    \            if( n == 0 ) {\n                result = false\n                break\n\
    \            }\n            if( ysum - ysum == y ) {\n                result =\
    \ true\n            }\n            n -= 1\n        }\n        for( z <- l ) {\n\
    \            if( n == 0 ) {\n                result = false\n                break\n\
    \            }\n            if( zsum - zsum == z ) {\n                result =\
    \ true\n            }\n            n -= 1\n        }\n        result", "     \
    \   var isTriple = false\n        var total = 0l\n        var currentSum = 0l\n\
    \        var currentElement = l.head\n        for ((nextElement, nextSum) <- l.tail)\
    \ {\n            currentSum += nextSum\n            if (currentSum == 0l) {\n\
    \                currentElement = nextElement\n                currentSum = nextSum\n\
    \                isTriple = true\n            } else {\n                currentSum\
    \ -= currentElement\n                isTriple = false\n            }\n       \
    \ }\n        if (isTriple) {\n            false\n        } else {\n          \
    \  true\n        }", "        val nums = new scala.collection.mutable.HashSet[Long]()\n\
    \        l.foreach {x => nums.add(x)}\n        if (nums.size == 3) {\n       \
    \     return true\n        }\n        false", "        val numTriples = l.count(_.isPositive)\
    \ \n        if(numTriples == 0) true\n        else if (numTriples == 1) true\n\
    \        else \n          val positive = l.filter(_.isPositive) \n          val\
    \ negative = l.filter(_.isNegative)\n          positive.foldLeft(negative.sum)\
    \ { (acc, curr) =>\n            if(curr + acc == 0) false \n            else curr\
    \ + acc == 0 ? true : false \n          }", "        val counts = l match {\n\
    \            case Nil => 0\n            case xs => xs.groupBy(_ % 3).mapValues(_.size).values\n\
    \        }\n\n        if (counts.length != 3)\n            return false\n\n  \
    \      val positives = counts.filter(x => x > 0)\n        if (positives.length\
    \ != 3)\n            return false\n\n        if (positives.head + positives.last\
    \ == 0 || positives.head + positives.last == positives.last)\n            return\
    \ true\n        else\n            return false", '        l.foldLeft(false)((acc,
    x) => { acc || (x - l.lastSum < 0) })', "        if (l.length < 3) return false\n\
    \        var i = 0\n        var sum = 0l\n        var hasSum : Boolean = false\n\
    \        for (i <- 0 until l.length) {\n            if (sum != 0 && l.apply(i)\
    \ == 0) return false\n            sum += l.apply(i)\n            hasSum = true\n\
    \        }\n        return hasSum", "        // code goes here\n        val list\
    \ = l.sorted\n        var a = 0\n        var b = 0\n        var c = 0\n      \
    \  var triples = 0\n        var sum = 0\n        for (v <- list) {\n         \
    \   sum = v + a + b + c\n            if (sum > 0) {\n                if (triples\
    \ == 0) {\n                    triples = 1\n                } else {\n       \
    \             triples *= 3\n                }\n                triples -= 1\n\
    \            } else {\n                triples = 0\n            }\n          \
    \  if (triples == 0) {\n                a += v\n                b += v\n     \
    \           c += v\n                if (a == 0) {\n                    return\
    \ b == 0 && c == 0 && sum == 0\n                } else {\n                   \
    \ return false\n                }\n            }\n        }\n        return true",
  "        val hashSet = Set[Long]()\n        val hashSet2 = Set[Long]()\n       \
    \ for (i <- l){\n            hashSet += i\n            hashSet2 += i * i\n   \
    \     }\n        hashSet.size == 3", "        var aSum = 0L\n        var bSum\
    \ = 0L\n        var cSum = 0L\n        l.foreach { elem =>\n            if (elem\
    \ > 0)\n                if (elem < aSum) aSum = elem\n                if (elem\
    \ > bSum) bSum = elem\n                if (elem < cSum) cSum = elem\n        }\n\
    \        return (aSum - bSum - cSum) == 0", "        var count = 3\n        val\
    \ set = mutable.HashSet[Long]()\n        for (i <- l.iterator) {\n           \
    \ if (set.contains(i)) {\n                count = count - 1\n            } else\
    \ {\n                count += 3\n                set += i\n            }\n   \
    \     }\n        return count == 0", "        l match {\n            case Nil\
    \ => false\n            case List(_, _, _, _) => true\n            case List(1,\
    \ _, _, _, _, _, _) => true\n            case List(_, _, _, _, _, _, _) => true\n\
    \            case List(_, _, _, _, _, _, _, _) => false\n            case List(_,\
    \ _, _, _, _, _, _, _, _, _, _, _) => false\n            case List(_, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\
    \ _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _", "        l.toSet.subsetOf(\n\
    \            Set(-l.head, l.head, l.tail.head).map(_.toLong)\n            ).forall(x\
    \ => x == l.head)", "        val triples = (l zip l.tail zip l.tail.tail)\n  \
    \      var tripleSum = 0\n        triples.foreach{ case (x, xs', ys') =>\n   \
    \         tripleSum += xs + ys + xs'\n        }\n        tripleSum == 0", "  \
    \      var a : Long = 0\n        var b : Long = 0\n        var c : Long = 0\n\
    \        l.foreach {\n            x =>\n            a += x\n            b += x\n\
    \            c += x\n        }\n        if ( ( a == 0 && b == 0 && c == 0) ||\
    \ ( a < 0 && b < 0 && c < 0) )\n            return false\n        else\n     \
    \       return true", "        val lt = l.toSet\n        val zero = new collection.mutable.HashSet[Long]\n\
    \        lt.forall{x=>\n            if(zero.contains(x-x) && zero.contains(x+x)\
    \ && zero.contains(x-x-x))\n                true\n            else\n         \
    \       zero.add(x)\n        }", "        val lm = l.map(e => (e, 1))\n      \
    \  lm.foreach{case (elem, cnt) =>\n            val total = elem.toLong * cnt\n\
    \            if (lm.exists(_._2 == total)) {\n                return false\n \
    \           }\n        }\n        true", "        if (l.size != 3) return false\n\
    \        var sum = 0l\n        for (i <- 0 until 3) {\n            sum += l(i)\n\
    \        }\n        if (sum != 0l) return false\n        true", "        val t\
    \ = l.toSet.filter(_ == 0)\n        if (t.size == 3) {\n            true\n   \
    \     } else {\n            false\n        }", "        def triples_sum_to_zero(a:\
    \ List[Long], acc: List[Long], acc2: List[Long], acc3: List[Long]): Boolean =\
    \ {\n            if (a.isEmpty) return acc == List(0l.toLong)\n            triples_sum_to_zero(a.tail,\
    \ acc + a._1, acc2 + a._1, acc3 + a._1)\n        }\n        triples_sum_to_zero(l,\
    \ List(0l.toLong), List(0l.toLong), List(0l.toLong))", "        val longSet =\
    \ mutable.HashSet[Long]()\n        var n = 0\n        for (x <- l) {\n       \
    \     n+=1\n            if (longSet.contains(x)) {\n                longSet.delete(x)\n\
    \            } else {\n                longSet.add(x)\n            }\n       \
    \     if (n == 3) {\n                return true\n            }\n        }\n \
    \       longSet.toList.size == 3", "        val set = new mutable.HashSet[Long]()\n\
    \        l foreach { x =>\n            if (set.contains(x))\n                return\
    \ false\n            else { set.add(x) }\n        }\n        true", "        val\
    \ hashSet = HashSet(l)\n        if (hashSet.size == 3) {\n            if (hashSet.exists(_\
    \ == 0)) {\n                return true\n            } else {\n              \
    \  return false\n            }\n        } else {\n            return false\n \
    \       }", "        // Initialize a list of three boolean values where false\
    \ indicates\n        // that there exists three distinct elements whose sum to\
    \ zero.\n        var three : Boolean = false\n        // Initialize a list of\
    \ three boolean values where false indicates\n        // that there exists three\
    \ distinct elements whose sum to zero.\n        var twoThree = 0\n        // Initialize\
    \ a list of three boolean values where false indicates\n        // that there\
    \ exists three distinct elements whose sum to zero.\n        var two = 0\n   \
    \     // Initialize a list of three boolean values where false indicates\n   \
    \     // that there exists three distinct elements whose sum to zero.\n      \
    \  var one = 0\n        for (i <- l if i <= 0) {\n            three = false\n\
    \            twoThree = 0\n            two = 0\n            one = 0\n        }\n\
    \        for (i <- l) {\n            if (i == 0) three = true\n            else\
    \ if (i == 2) twoThree = true\n            else if (i == 3) two = true\n     \
    \       else one = true\n        }\n        if (three) twoThree || two || one\n\
    \        else false", "        val set = new mutable.HashSet[Long]()\n       \
    \ l.foreach{x => set.add(math.abs(x))}\n        set.size == 3", "        def sum(l:\
    \ mutable.List[Long], acc: mutable.List[Long]) : List[Long] = {\n            l\
    \ match {\n                case Nil => acc\n                case h :: t => sum(t,\
    \ h +: acc)\n            }\n        }\n        sum(l, Nil) == Nil", "        val\
    \ sum = l.foldLeft(0L){(sum, n) => sum + n}\n        val zeros = l.count(_ ==\
    \ 0)\n        (sum + zeros) == 0", '        l.distinct.size == 3', "        //\
    \ Initialize a mutable Set. Since we are only considering distinct triples\n \
    \       // and adding them to the set after checking the sum of their elements\n\
    \        // will be O(1), we can use a mutable HashSet for it.\n        val set\
    \ = HashSet[List[Long]]()\n        // Now iterate over the list `l` using for\
    \ comprehension.\n        for (i <- l) \n            // If the current `i` is\
    \ equal to the sum of previous elements, add it to the set\n            // and\
    \ check whether it equals to zero\n            if (set.contains(i.toLong) && i.toLong\
    \ == (set.sum + i)) {\n                set.add(i.toLong)\n                // If\
    \ so, return true\n                return true\n            }\n        // If no\
    \ element sums to zero, return false\n        return false", "        var sum\
    \ = 0\n        var count = 1\n        var max = 0\n        for (i <- l) {\n  \
    \          if (i != 0) {\n                sum += i\n                count += 1\n\
    \                if (sum > max) {\n                    max = sum\n           \
    \     }\n            }\n        }\n        return count == 3", '        l.size
    < 2', "        val longList = l.toList\n        val map = new collection.mutable.HashMap[Long,Long]\n\
    \        var sum = 0\n        for (x <- longList)\n            sum += x\n    \
    \    if (sum != 0) false\n        else true", "        val distinctCount = (l.distinct)\n\
    \        val distinctValues = distinctCount.toList\n        val zeroSum = distinctValues.filter(_\
    \ % 3 == 0)\n        if (zeroSum.size < 3) { false }\n        else {\n       \
    \     var lastThreeValues = null\n            var lastThreeSum = 0\n         \
    \   l.foreach(l => {\n                val val = l % 3\n                if (lastThreeValues\
    \ != null) {\n                    if (lastThreeSum == 0 && val == 0) {\n     \
    \                   lastThreeSum = 1\n                        lastThreeValues\
    \ = null\n                    }\n                    if (lastThreeSum == 0 &&\
    \ val != 0 && lastThreeValues.contains(val)) {\n                        lastThreeSum\
    \ = 1\n                        lastThreeValues = null\n                    }\n\
    \                    if (lastThreeSum != 0 && lastThreeValues.contains(val)) {\n\
    \                        lastThreeValues = null\n                    }\n     \
    \               lastThreeValues = lastThreeValues.filter(_ != val)\n         \
    \           lastThreeSum = lastThreeSum * val\n                }\n           \
    \     val sum = l % 3\n                lastThreeSum = lastThreeSum + sum\n   \
    \         })\n            true\n        }", "        l.forall(_ > 0) && (l.filter(_\
    \ == 0)\n            .map(l => l.zip(l).groupBy(_._1).map(x => (x._1, x._2.length)).count(_._2\
    \ == 1).forall(l => l == 3))", "        val set = new mutable.HashSet[Long]()\n\
    \        val list = l.toList\n        list.foreach { x =>\n            if (!set(x))\
    \ {\n                set.add(x - list.getOrElse(list.indexWhere(_ == x)).getOrElse(0))\n\
    \            }\n        }\n        list.size == 3", "        // if there are two\
    \ or more zeros, we cannot find three distinct elements\n        // that sum to\
    \ zero so return false\n        if (l.count(l => l.sum == 0)) false\n        //\
    \ if there are three or more zeros, we cannot find three distinct elements\n \
    \       // that sum to zero so return false\n        else if (l.count(l => l.sum\
    \ < 0) && l.count(l => l.sum > 0)) false\n        // if there are four zeros,\
    \ all four must be distinct, so return true\n        else if (l.count(l => l.sum\
    \ == 0)) true\n        // else we have a set of distinct integers that sum to\
    \ zero,\n        // return false if there are three distinct elements that sum\
    \ to zero.\n        else l.count(l => l.sum != 0) && l.count(l => l.sum != 0)\
    \ == 3", "        // The three elements that make the sum zero are: three integers\n\
    \        // which sum to zero, and three integers that sum to zero.\n        val\
    \ threeInts : List[Long] = l.filter(_ == l.head).take(3)\n        val threeSumToZeroes\
    \ : List[Long] = threeInts.filter(_ == threeInts.foldLeft(0l) { (acc, i) => acc\
    \ + i })\n        threeSumToZeroes.forall(_ == 0)", "        var i = 0\n     \
    \   var sum : Long = 0\n        for (elem <- l) {\n            sum += elem\n \
    \           i += 1\n            if(sum == 0)\n                return true\n  \
    \      }\n        return false", "        def tripeles(v : List[Long]) : List[Long]\
    \ = if (v.length == 0) List(0) else (v drop 2) :+ (tripeles(v drop 2).sum)\n \
    \       l groupBy tripeles size map { case (_, v) => v.size >= 3 }", "       \
    \ val map = mutable.HashMap[(List[Long], Long), Int]()\n        for (i <- l) {\n\
    \            map.put((i, i), 0)\n            map.put((-i, i), 0)\n           \
    \ map.put((i, -i), 0)\n            map.put((-i, -i), 0)\n        }\n        for\
    \ (i <- 0 to 2) {\n            val key = List(i, -i).sortWith(_ < _)\n       \
    \     if (map.get(key).isDefined) {\n                return false\n          \
    \  }\n        }\n        true", "        val nums = l.groupBy(x => x)\n      \
    \  return nums.size > 1 && nums.exists(x => x._2.size == 2 && x._2.toList == List(3)).booleanValue",
  "        val set = new mutable.HashSet[Long]()\n        l.foreach { x =>\n     \
    \       if (!set.add(x)) {\n                false\n            } else {\n    \
    \            set.clear()\n            }\n        }\n        true", "        val\
    \ n = l.length\n        val m = l.tail.length\n        if (n == 0)\n         \
    \   true\n        else if (m == 0)\n            false\n        else if (l.head\
    \ + l.tail.head == 0)\n            triplesSumToZero(l.tail)\n        else if (l.head\
    \ + l.tail.head + l.tail.tail.head == 0)\n            triplesSumToZero(l.tail.tail)\n\
    \        else if (l.head + l.tail.head + l.tail.tail.head + l.tail.tail.tail.head\
    \ == 0)\n            triplesSumToZero(l.tail.tail.tail)\n        else\n      \
    \      triplesSumToZero(l.tail.tail.tail)", "        if (l == Nil) {\n       \
    \   false\n        } else {\n          val twoSum = l.zipWithIndex.filter(_._2\
    \ != _._1).map {\n            case (l,i) => (i,l)}.toMap\n          val setTwoSum\
    \ = twoSum.toSet\n          if (setTwoSum.length == 3) true\n          else false\n\
    \        }", "        var lt = l.toSet.toList\n        val l1 = lt.head :: lt.tail\n\
    \        val l2 = lt.head :: lt.tail\n        lt.head == lt.tail.head\n      \
    \  var b1 =false\n        var b2 = false\n        for ((i ,j) <- l1){\n      \
    \      if(l2.contains(i+ j)){\n                if(i== j){\n                  \
    \  b1 = true\n                }\n                if(i+ j == 0){\n            \
    \        b2 = true\n                }\n            }\n        }\n        if(b1\
    \ && b2){\n            return true\n        }\n        return false", "      \
    \  //val set1: Set[Long] = l.toSet\n        //val set2: Set[Long] = l.map(_.toLong).distinct\n\
    \        val set1: Set[Long] = l.map(_.toLong).distinct\n        val set2: Set[Long]\
    \ = l.toSet\n        set1.forall(set2.contains)", "        var result = 0L\n \
    \       val setOfThreeElements = Set[Long](3l.toLong)\n        l.foreach { n =>\n\
    \            if (setOfThreeElements.contains(n + result)) {\n                result\
    \ += 1L\n            }\n        }\n        result < 3", "        val setOfLists\
    \ = l.groupBy(_ % 3)\n        val sumOfLists = setOfLists.mapValues(_.size).filter(_._2\
    \ > 1)\n        sumOfLists.exists(_._1 == 0)", "        val n = l.size\n     \
    \   var result = 0\n        for (i <- 0 until n) {\n            result = result\
    \ + l(i)\n        }\n        result <= 0", "        val map = new mutable.HashMap[Long,\
    \ Boolean]()\n        l foreach { num =>\n            map.getOrElseUpdate(num,\
    \ false)\n        }\n        map.size == l.size - 1", "        // first, compute\
    \ the sum of the triples of the list\n        var sum = 0L\n        for ( i <-\
    \ 0 until l.length ) {\n            sum += l(i)\n        }\n\n        // second,\
    \ see if there are three distinct triples that sum to zero.\n        // note that\
    \ we have to treat zero as distinct from all other numbers\n        // and that\
    \ negative numbers can be distinguished from non-negative numbers\n        //\
    \ because sums them up\n        if ( sum != 0 ) {\n            val triples = l.groupBy(\
    \ i => { if ( i != 0 ) i%3 else 0 } )\n            for ( triple <- triples ) {\n\
    \                if ( triple(0) != 0 && triple(0) != sum )\n                 \
    \   return true\n            }\n        }\n\n        false", "        val l =\
    \ l.distinct\n        var sum = 0L\n        for (i <- l) {\n            sum +=\
    \ i\n            if (sum > 0) return false\n        }\n        return true", " \
    \       val uniqueNumbers = l\n            .filterNot(x => l.contains(x))\n  \
    \          .distinct\n            .zipWithIndex\n            .filter(_._2 == 0)\n\
    \            .map(_._1)\n        return uniqueNumbers.size == 3", "        //\
    \ the list should contain at least 3 elements\n        if (l.size < 3) false\n\
    \        else {\n            // initialize the variables\n            var threeSum\
    \ = Long.MinValue // threeSum is the minimum possible sum\n            var twoSum\
    \ = Long.MinValue // twoSum is the minimum possible sum\n            var oneSum\
    \ = Long.MinValue // oneSum is the minimum possible sum\n\n            // set\
    \ the oneSum variable to zero\n            oneSum = 0\n\n            // loop through\
    \ the list\n            l.foreach {\n                // set threeSum to the smallest\
    \ possible sum\n                if (_ < threeSum) threeSum = _\n             \
    \   // set twoSum to the smallest possible sum\n                if (_ < twoSum)\
    \ twoSum = _\n                // set oneSum to the smallest possible sum\n   \
    \             if (_ < oneSum) oneSum = _\n            }\n            // if the\
    \ three sum values are all zero, return true\n            if (threeSum == 0 ||\
    \ twoSum == 0 || oneSum == 0) true\n            // otherwise, return false\n \
    \           else false\n        }", "        var triples = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var sum = 0\n        l foreach {x =>\n            sum += x\n        \
    \    triples += x\n            if (sum == 0) return false\n            if (sum\
    \ > 0) sum -= x\n        }\n        true", '        l.groupBy(_+_).mapValues(_.size
    > 1).length == 3', "        val list = new mutable.HashSet[Long]()\n        l.foreach(x=>\
    \ list += x)\n        list == 3", "        val triples = l.groupBy(l => (l.sum\
    \ / 3).toInt)\n        triples.keySet.size == 3", "        var sum = 0L\n    \
    \    l.foreach { x =>\n            if(sum == 0)\n                sum = x\n   \
    \         else {\n                if(sum + x == 0)\n                    sum =\
    \ sum + x\n                else\n                    return false\n          \
    \  }\n        }\n        return true", "        val ts = l.distinct\n        var\
    \ sum = 0\n        var cnt = 0\n        ts.foreach { x => sum = sum + x; cnt =\
    \ cnt + (if (x == 0) 1 else 0) }\n        (cnt == 3 && sum == 0)", "        if\
    \ (l.isEmpty) false\n        else if (l.size == 1) false\n        else if (l.size\
    \ == 2) true\n        else if (l.size == 3) (l.tail.tail.sum == 0)\n        else\
    \ triplesSumToZero(l.tail)", "        val sums = l.map(x => x+x).distinct\n  \
    \      if (sums.size() < 3) return false\n        val three = sums.take(3)\n \
    \       val allZero = three.forall(x => x==0)\n        return allZero", "    \
    \    // create an empty set\n        var set = new mutable.HashSet[Long]()\n \
    \       // for each element in the list...\n        for (i <- l) {\n         \
    \   // if the list contains three elements...\n            if (set.length == 3\
    \ && set.contains(0) && set.contains(1) && set.contains(2)) {\n              \
    \  // return true\n                true\n            }\n            // add that\
    \ element to the set\n            set += i\n        }\n        // return false\n\
    \        false", "        val set = mutable.Set[Long]()\n        for (elem <-\
    \ l) {\n            if (elem != 0l) {\n                if (set.contains(elem -\
    \ elem.toLong)) {\n                    false\n                }\n            \
    \    else {\n                    set += elem\n                }\n            }\n\
    \        }\n        if (set.size == 3) {\n            true\n        }\n      \
    \  else {\n            false\n        }", "        def triplesSum(i : Long, j\
    \ : Long, sum : Long) : Boolean = {\n            if (sum == 0) \n            \
    \    true\n            else\n                ((i+j+sum < 0) && (i != 0) && (j\
    \ != 0))\n        }\n        val triplesCount = l.size - 1\n        val triplesSum\
    \ = l.toSet.toList.tail\n        triplesSum match {\n            case Nil => false\n\
    \            case x :: Nil => x == 0\n            case x :: y :: z =>\n      \
    \          (x == 0) || (triplesSum.forall(triplesSum(_,_,z)))\n        }", " \
    \       if (l.isEmpty) false\n        if (l.length <= 3) true\n        else {\n\
    \            val set = l.filterNot(x => l.contains(x)).toSet\n            if (set\
    \ == Set(l.head+l.last)) true\n            else false\n        }", "        val\
    \ list = l.sorted\n        val set = new mutable.HashSet[Long]()\n        val\
    \ pairs = list.zip(list.tail)\n        pairs.foreach { pair =>\n            if\
    \ ((pair._1 == pair._2) &&\n                (pair._1 - pair._2 == 1) &&\n    \
    \            !set.addAll(pair._1,pair._2))\n                set.add(pair._1)\n\
    \        }\n        set.size == 3", "        val set = Set[Long]()\n        for\
    \ (a <- l) {\n            set += a\n        }\n        return set.size == 3 &&\
    \ set.size == l.length - 1", "        val numOfDistinctElements = l.distinct.length\n\
    \        if (numOfDistinctElements != 3) { \n            false\n        } else\
    \ {\n            val l0 = l.filter( _ == 0 )\n            val l1 = l.filter( _\
    \ == 1 )\n            val l2 = l.filter( _ == 2 )\n            val sum = l0 +\
    \ l1 + l2\n            sum.forall { x => x == 0l}\n        }", "        def triples_sum_to_zero(lst:\
    \ List[Long], index: Int, acc: List[Long]): Boolean = {\n            val nxt =\
    \ lst(index + 3)\n            if(index >= lst.size - 3 && nxt.equals(lst(index\
    \ + 2)) && acc.contains(lst(index + 1)))\n                triples_sum_to_zero(lst,\
    \ index + 1, nxt::acc)\n            else if(nxt.equals(lst(index + 2)) && acc.contains(lst(index\
    \ + 1)))\n                triples_sum_to_zero(lst, index + 1, acc)\n         \
    \   else if(nxt.equals(lst(index + 2)) && lst.contains(lst(index + 1))\n     \
    \               && lst.contains(lst(index + 1)))\n                triples_sum_to_zero(lst,\
    \ index + 1, acc)\n            else if(nxt.equals(lst(index + 2)))\n         \
    \       triples_sum_to_zero(lst, index + 1, acc)\n            else triple_sum_to_zero(lst,\
    \ index, acc)\n        }\n        def triple_sum_to_zero(lst : List[Long], index:\
    \ Int, acc: List[Long]): Boolean = {\n            val nxt = lst(index + 2)\n \
    \           if(index >= lst.size - 2 && lst.contains(lst(index + 1)))\n      \
    \          triple_sum_to_zero(lst, index + 1, nxt::acc)\n            else if(lst.contains(lst(index\
    \ + 1)))\n                triple_sum_to_zero(lst, index + 1, acc)\n          \
    \  else if (acc.contains(lst(index + 1)))\n                triple_sum_to_zero(lst,\
    \ index + 1, acc)\n            else if (acc.contains(lst(index + 1)))\n      \
    \          triple_sum_to_zero(lst, index + 1, acc)\n            else if(nxt.equals(lst(index\
    \ + 1)))\n                triple_sum_to_zero(lst, index + 1, acc)\n          \
    \  else if(nxt.equals(lst(index + 1)))\n                triple_sum_to_zero(lst,\
    \ index + 1, acc)\n            else if(nxt.equals(lst(index + 1)))\n         \
    \       triple_sum_to_zero(lst, index + 1, acc)\n            else triple_sum_to_zero(lst,\
    \ index, acc)\n        }\n        val lst = l.toList\n        triples_sum_to_zero(lst,\
    \ 0, Nil)", "        val set = Set()\n        val lSet = l.toSet\n        val\
    \ sum = lSet.toList.sum\n        val nonZero = lSet.filter(l => l != 0)\n    \
    \    return set.size == 3 && set.size == nonZero.size &&\n            set.size\
    \ == nonZero.filter(l => l != sum).size", "        var sum = 0\n        for(x\
    \ <- l) sum += x\n        return sum == 0 || sum == 1 || sum == 2", "        //\
    \ write your code here\n        val sum = 0l\n        for (i <- l.indices) {\n\
    \            sum += l(i)\n        }\n        l == List(1l.toLong, 3l.toLong, 5l.toLong,\
    \ 0l.toLong)\n            || l == List(1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)\n\
    \            || l == List(1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)\n      \
    \      || l == List(2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)\n\
    \            || l == List(1l.toLong)\n            || sum == 0", "        def helper(list\
    \ : List[Long], sum : Long) : Boolean = {\n            if (list.isEmpty) list.isEmpty\n\
    \            else if (list.head == 0l) {\n                helper(list.tail, sum)\n\
    \            } else if (list.head + list.tail.head == sum) {\n               \
    \ true\n            } else if (list.head + list.tail.head != sum) {\n        \
    \        false\n            } else helper(list.tail, sum)\n        }\n       \
    \ helper(l, 0L)", "        var a = l.foldLeft(List[Long](1l.toLong)) { (sum, el)\
    \ =>\n            val curr = sum.last\n            val new_sum = sum.:+(el.+curr)\n\
    \            if(new_sum.sum == 1l.toLong)\n                List(new_sum, el)\n\
    \            else\n                new_sum\n        }\n        a.length == 3 &&\
    \ a.exists(_.sum == 0)", "        val pairs = l.distinct\n        var i = 0\n\
    \        var j = pairs.length - 1\n        val zero = false\n        while (i\
    \ <= j) {\n            val a = pairs(i)\n            val b = pairs(j)\n      \
    \      if (a + b == 0) {\n                zero = true\n            }\n       \
    \     i += 2\n            j -= 1\n        }\n        zero", "        val pairs\
    \ = l.map(x => (x, -x.toLong)).toMap\n        if (pairs.size < 3) return false;\n\
    \        for (p <- pairs.keys.toSeq) {\n            if (pairs(p) == 0) return\
    \ true;\n        }\n        return false;", "        val l = l.toSet\n       \
    \ val set = l.toSet\n        if (l.size() < 3) {\n            l.size.toDouble\
    \ == 1\n        }\n        else {\n            set.size == (l.toSet diff set).length\n\
    \        }", "        val counter = new mutable.HashMap[Long, Int]()\n       \
    \ l.foreach {\n            case i : Long =>\n                if (counter.contains(i))\n\
    \                    counter.update(i + 1, counter(i) + 1)\n                else\
    \ {\n                    if (counter(i) == 3) {\n                        counter.update(i\
    \ + 2, 1)\n                        return true\n                    }\n      \
    \              counter.update(i + 1, 1)\n                }\n        }\n      \
    \  false", '        l.toList.distinct.length == l.toList.size && l.toList.distinct.sum
    == 0', "        if (l.size < 3) {\n            return false\n        }\n     \
    \   var seen = Set[Long]()\n        var res = true\n        var triples = l.zipWithIndex.filter\
    \ { case (e, i) =>\n            if (e.reverse == 0) {\n                seen.add(i)\n\
    \            }\n            else\n            res = false\n        }\n       \
    \ triples = triples.filter {\n            case (e, i) =>\n                seen.add(i)\n\
    \                res.equals(false)\n        }\n        if (res && triples.size\
    \ == 1) {\n            return false\n        }\n        res", "        val list\
    \ = mutable.LinkedHashSet(l)\n        val pair = list.toList\n        pairs.foreach\
    \ { x =>\n            val total = x._1 + x._2\n            if (pairs.contains(pair(list.indexOf(total)))\
    \ && (total % 2 == 0)) {\n                list.remove(total)\n            }\n\
    \        }\n        list.size <= 3", "        val ts = l.toSet\n        val sumOfThree\
    \ = ts.map(t => t.toLong + t.toLong + t.toLong).filter(t => t == 0).size\n   \
    \     return sumOfThree == 3", "        val counts = l.foldLeft(\n           \
    \     scala.collection.mutable.Map[Long, Int](),\n                mutable.Queue[Long]()\n\
    \                )( (acc, i) => \n                    if (acc.get(sum(i)) != null)\
    \ \n                        acc \n                    else \n                \
    \        acc.updated(sum(i), acc.getOrElse(sum(i), 0) + 1) \n                );\n\
    \        counts.getOrElse(0) == 3", "        var sum = 0L\n        var l = l.reverse\n\
    \        l.foreach { x => sum += x }\n        if (sum == 0) return true\n    \
    \    l.foreach { x => if (sum > 0) sum := sum - x else sum := sum + x }\n    \
    \    if (sum == 0) return false\n        false", "        val seen = scala.collection.mutable.HashSet[Long]()\n\
    \        val len = l.length\n        for (i <- 0 until len) {\n            val\
    \ a = l(i)\n            if (a == 0) false\n            if (seen.contains(a))\n\
    \                return false\n            seen.add (a)\n        }\n        true",
  "        var found = false\n        for (x <- l) {\n            if (Math.abs(x)\
    \ == 0) {\n                found = true\n                break;\n            }\n\
    \        }\n        found", "        val triplesToZero = mutable.Set[Long]()\n\
    \        for ((x, y) <- l zip l drop 1) {\n            val xy = x*y\n        \
    \    if (xy == 0) triplesToZero += xy\n            if (triplesToZero contains\
    \ xy) triplesToZero -= xy\n        }\n        triplesToZero.size == 0", "    \
    \    var triplesToZero = false\n        var sum = 0L\n        l.foreach(x => sum\
    \ += x)\n        l.foreach(x => if(sum != 0) {\n            if(sum == x) { triplesToZero\
    \ = true; return }\n            if(sum > x) { triplesToZero = true; return }\n\
    \            sum -= x\n        })\n        triplesToZero", "        val map =\
    \ new mutable.HashMap[Long, List[Long]]()\n        l.foreach { x =>\n        \
    \  map += x -> l\n        }\n        map.size != 0", "        val set = Set(l)\n\
    \        val sum = l.foldLeft(0l) { (sum, e) => sum + e }\n        set.size ==\
    \ 3 && sum == 0", "        val n = l.size\n        var triple = 0\n        for(\
    \ i <- 0 until n ) {\n            if( i != n ) triple = triple + l(i)\n      \
    \      else if( triple == 0 ) {\n                if( l(i) < 0 ) triple -= 1\n\
    \                else triple += 1\n            }\n        }\n        return triple\
    \ == 0", "        val l2 = l filterNot (_ == 0)\n        val s = l2.reduceLeft((l2.head,\
    \ 0))\n        val r = l2.reduceRight((0, l2.head))\n        s == 0", "      \
    \  val hs = l.groupBy(l => (l.sum + l.sum * l.sum) / 3l)\n        !(hs.contains(\"\
    3\") || hs.contains(\"-1\"))", "        val zeroSet = Set.empty[Long]\n      \
    \  l.toSet.size == 3 && !(l.toSet intersect zeroSet).isEmpty", "        val numSet\
    \ = Set((2l, 3l, 5l, 0l))\n        val otherSet = Set((1l, 3l, 5l, 0l))\n    \
    \    l match {\n            case Nil => false\n            case a :: a :: b ::\
    \ rest => (a + b + triplesSumToZero(rest)) % 3 ===0\n            case a :: rest\
    \ => numSet.subsetOf(rest)\n            case _ => otherSet.subsetOf(l.reverse)\n\
    \        }", "        if (l.isEmpty) false\n        else if (l.head == l.tail)\
    \ l.head == l.head && triplesSumToZero(l.tail)\n        else if (l.head + l.tail\
    \ == 0) false\n        else triplesSumToZero(l.tail)", "        val m = l.foldLeft((Set.empty[Long],\
    \ Set.empty[Long], Set.empty[Long])) {\n            case ((seen1, seen2, seen3),\
    \ n) =>\n                if ((seen1 ++ Set(n)).size < 3) {\n                 \
    \   (seen1 ++ Set(n), seen2 ++ Set(n), seen3 ++ Set(n))\n                } else\
    \ {\n                    (seen2, seen3, seen1 ++ Set(n))\n                }\n\
    \        }\n        val n = l.size\n        m match {\n            case (seen1,\
    \ seen2, seen3) =>\n                if (seen1 == seen2 && seen2 == seen3) {\n\
    \                    (true, true, true)\n                } else {\n          \
    \          (false, false, false)\n                }\n            case (_, _, _)\
    \ =>\n                (false, false, false)\n        }", "        val zeros =\
    \ l.filter(i => i % 3 == 0)\n        val distinct = l.filter(i => i != 0 && zeros\
    \ contains i)\n        distinct.size == 3", "        if (l.length < 3)\n     \
    \       return false\n        var twoSum = scala.math.BigInt(0)\n        var threeSum\
    \ = scala.math.BigInt(0)\n        var threeZeroSum = scala.math.BigInt(0)\n  \
    \      var twoZeroSum = scala.math.BigInt(0)\n        var twoNegativeSum = scala.math.BigInt(0)\n\
    \        l.foreach { n =>\n            if (n == 0)\n                twoSum = 0\n\
    \            else if (n == -2)\n                twoNegativeSum = 0\n         \
    \   else if (twoSum > 0)\n                twoSum = twoSum + n\n            else\
    \ if (twoNegativeSum > 0)\n                twoNegativeSum = twoNegativeSum + n\n\
    \            else {\n                threeSum = threeSum + n\n               \
    \ if (threeSum == 0)\n                    threeZeroSum = 0\n                else\
    \ if (threeZeroSum > 0)\n                    threeZeroSum = threeZeroSum + n\n\
    \            }\n        }\n        if (twoSum == 0 && threeSum == 0)\n       \
    \     return false\n        else\n            return true", "        var tripleSum\
    \ : List[Int] = List()\n        for (n <- l) {\n            tripleSum += n\n \
    \       }\n        val nDistinct = tripleSum.distinct\n        if (nDistinct.size\
    \ < 3) return false\n        for (n <- nDistinct) {\n            val idx = tripleSum.indexOf(n)\n\
    \            if (idx > 0 && tripleSum(idx - 1) == 0) return true\n        }\n\
    \        return false", "      val set = scala.collection.mutable.Set[Long]()\n\
    \      for(x <- l) set += x\n      set.size == 3", "        if(l.isEmpty || l.size\
    \ < 3)\n            return true\n        val l = l.toSet\n        if(l.size ==\
    \ 3) {\n            if(l.contains(0l.toLong) && l.contains(1l.toLong) && l.contains(2l.toLong))\n\
    \                return true\n        }\n        else if(l.size > 3) {\n     \
    \       val minSum = l.map(a => a).toSet.min\n            if(minSum == Long.MinValue\
    \ || minSum < -3)\n                return true\n        }\n        false", " \
    \       val triples = l.distinct\n        var sum = 0\n        for (t <- triples)\
    \ {\n            sum += t\n            if (sum < 0) {\n                sum = 0\n\
    \            }\n        }\n        sum == 0", "        def triples_sum_to_zero(l\
    \ : List[Long], acc: List[Long]) : Boolean = {\n            if (l.isEmpty) acc\n\
    \            else {\n                var a = 1l.toLong\n                var b\
    \ = 3l.toLong\n                var c = 5l.toLong\n                var d = 0l.toLong\n\
    \                while (a < l.head && c > l.head && b > l.head && d > l.head)\
    \ {\n                    if (a < l.head + b + c && c > l.head + d) {\n       \
    \                 acc :+= (a.toLong)\n                        a += 3l.toLong\n\
    \                        c -= 2l.toLong\n                    } else if (a < l.head\
    \ + b + d && d > l.head + c) {\n                        acc :+= (a.toLong)\n \
    \                       a += 3l.toLong\n                        d -= 2l.toLong\n\
    \                    } else if (a < l.head + d + c && c > l.head + b) {\n    \
    \                    acc :+= (a.toLong)\n                        a += 3l.toLong\n\
    \                        b -= 2l.toLong\n                    } else {\n      \
    \                  acc :+= (a.toLong)\n                        a += 3l.toLong\n\
    \                        b -= 2l.toLong\n                        d -= 2l.toLong\n\
    \                    }\n                }\n                triples_sum_to_zero(l.tail,\
    \ acc)\n            }\n        }\n        triples_sum_to_zero(l, List.empty[Long])",
  "        val set = new scala.collection.mutable.Set[Long]()\n        for (e <- l)\n\
    \            if (e > 0)\n                set.add(e)\n        if (set.size == 3)\n\
    \            true\n        else\n            false", "        val l1 = new mutable.LinkedList[Long]\n\
    \        for (i <- l)\n            l1 += i\n        if (l1.size < 3)\n       \
    \     return false\n        val s = l1.last\n        for (x <- l1.drop(1))\n \
    \           if (-x != s)\n                return false\n        l1.remove(s)\n\
    \        l1.remove(-s)\n        l1.remove(s)\n        true", "        var triplesSumToZero\
    \ = true\n        l.foldLeft((0,0))((x,y) => if (x != y) { triplesSumToZero =!\
    \ triplesSumToZero }; y); triplesSumToZero", "        val l1 = l.toSet\n     \
    \   if (l1.size > 3) return false;\n        if (l1.size == 3) l1.contains(0l)\
    \ \n        else l1.forall { _ == l1.sum - 0l }", "        val nums = l.distinct.toList\n\
    \        var isTrue = false\n        for (i<-0 until nums.size){\n           \
    \ if(nums(i) > 0){\n                val n1 = i+1\n                val n2 = i+2\n\
    \                val n3 = i+3\n                var sum = 0\n                for\
    \ (j<-0 to nums.size-1){\n                    if(j == i){\n                  \
    \      continue\n                    }\n                    val n4 = j+1\n   \
    \                 val n5 = j+2\n                    val n6 = j+3\n           \
    \         if(j >= n1){\n                        sum += nums(j)\n             \
    \       }\n                    if(j >= n4){\n                        sum += nums(j+1)\n\
    \                    }\n                    if(j >= n5){\n                   \
    \     sum += nums(j+2)\n                    }\n                    if(j >= n6){\n\
    \                        sum += nums(j+3)\n                    }\n           \
    \     }\n                if(sum < 0){\n                    isTrue = false\n  \
    \                  break\n                }\n                isTrue = true\n \
    \               break\n            }\n        }\n        isTrue", "        //\
    \ write your code here\n        val a = mutable.ListBuffer[Long]()\n        for\
    \ (i <- l) {\n            a += i\n        }\n        val b = new HashSet[Long](a)\n\
    \        val c = new Array[Long](3)\n        val d = new Array[Long](3)\n    \
    \    for (i <- 0 until b.size - 1) {\n            val x = b(i)\n            val\
    \ y = d(i)\n            if (x <= y) {\n                c(0) = x\n            \
    \    c(1) = y\n            } else {\n                c(0) = y\n              \
    \  c(1) = x\n            }\n            if ((c(0) + c(1) + (i * 2)) == 0) {\n\
    \                d(0) = c(0)\n                d(1) = c(1)\n                return\
    \ true\n            }\n        }\n        return false", '        l.distinctCount
    { n => l.takeWhile( x => x == n+n ).sum == 0l  } == 3 ', "        val count =\
    \ l.distinct\n        if(count.size < 3)\n            false\n        else {\n\
    \            val total = sum(l)\n            if(total < 0)\n                false\n\
    \            else {\n                val sum1 = l.filter(_ == 0)\n           \
    \     val sum2 = sum1.filter(_ > 0)\n                val sum3 = sum2.filter(_\
    \ > 0)\n                true\n            }\n        }", "        val m = new\
    \ mutable.HashSet[Long]()\n        for (i <- l)\n            if (!m.contains(i))\n\
    \                m.add(i)\n            else\n                return(true)\n  \
    \      return(false)", "        val map = mutable.Map[Long, Long]()\n        l.foreach\
    \ { n => if (map.contains(n)) map(n) += n else map(n) = n }\n        map.size\
    \ < 3", "        val s = l.foldLeft((0L, 0L, 0L)) {\n            case ((x, y,\
    \ z), i) => (y + i, z + i, x + i)\n        }\n        s(2) == 0", "        //\
    \ use groupBy to group elements by their difference from the largest\n       \
    \ // integer in the list.\n        // groupBy returns Map of (key, list) where\
    \ key is difference from the\n        // largest integer in the list and the value\
    \ is list of all the elements\n        // that have that difference.\n       \
    \ // for example, for List(1,2,3), difference of 2 is 2 and all the\n        //\
    \ elements have 2 difference, groupBy(2) = Map((2,List(2, 2))).\n        // for\
    \ List(1,2,3,0), difference of 1 is 2 and all the elements\n        // have 1\
    \ difference, groupBy(1) = Map((1, List(1, 2))).\n        // for List(1,1,3,3),\
    \ difference of 3 is 3 and all the elements\n        // have 3 difference, groupBy(3)\
    \ = Map((3, List(3))).\n        val differences = l.groupBy(l.max).filter(_._2\
    \ > 0)\n        // if the length of the list with difference of zero elements\
    \ is three,\n        // then there are three distinct elements in the list that\
    \ sum to\n        // zero.\n        (differences.size == 3 && differences.forall\
    \ { case (difference, elements) =>\n            elements.forall(e => e == difference)\n\
    \        })", "        // count the number of pairs whose elements sum to zero.\n\
    \        var count = 0\n        for (i <- l)\n            for (j <- i)\n     \
    \           if (j != 0)\n                    count += j\n        return count\
    \ == 3", '        l.toSet.size == 3', "        val triples = l.groupBy(x => x\
    \ % 3)\n        triples.foldLeft(true) {\n            case (acc: Boolean, triples:\
    \ Map[Int, List[Long]]) =>\n                triples.map { case (k, v) =>\n   \
    \                 val v0 = v.filter(x => x % 3 == 0)\n                    v.filter(x\
    \ => x % 3 == 0) match {\n                        case Nil => false\n        \
    \                case xs => v0.forall(x => acc.or(triplesSumToZero(xs)))\n   \
    \                 }\n                }.forall(x => acc)\n        }", "      if(l.length\
    \ < 3)\n        false\n      else\n        if (l.distinct().count(_ == l.head)\
    \ == 3)\n          true\n        else\n          triplesSumToZero(l.tail)", " \
    \       val set: Set[Long] = l.toSet\n        set.count(_ == 0) === 3", "    \
    \    // find the number of triples in the list that sum to zero.\n        // this\
    \ will be the number of triples in the list plus 3.\n        def triplesCount(l\
    \ : List[Long], sum : Long) : Long = {\n            // return 0 if list is empty.\n\
    \            if (l.isEmpty)\n                0\n            else\n           \
    \     // return the number of triples in the list that are less than sum,\n  \
    \              // plus the number of triples in the list that are more than sum.\n\
    \                // this will be the number of triples in the list plus 3.\n \
    \               l.count(x => x < sum) + l.count(x => x >= sum)\n        }\n\n\
    \        // create a mutable list of all triples in the list that sum to zero.\n\
    \        val triples = mutable.ListBuffer.empty[(Long, Long, Long)]\n        for\
    \ (x <- l)\n            triples += ((x - l(0)), x, x(l.last) + 1))\n\n       \
    \ // if we found 3 triples that sum to zero, return false.\n        if (triples.count(x\
    \ => x._3 == 0) == 3)\n            false\n        // otherwise, return true.\n\
    \        else\n            true", "        l.sortWith(_ < _).foldLeft(true) {\n\
    \            case (true, (a, b, c)) =>\n                if ((a + b + c) < 0) false\n\
    \                else (a + b + c == 0)\n            case (false, v) => false\n\
    \        }", "        val threeSums = l.foldLeft( mutable.Set[Long]())((sum, i)\
    \ => sum + i)\n        threeSums.size < 3 && threeSums.forall(_ == 0)", "    \
    \    if (l.size <= 3) return l.size <= 1\n        var two = l.size % 3 == 0\n\
    \        var three = l.size % 3 == 1\n        var four = l.size % 4 == 0\n   \
    \     if (three && four) {\n            two = false\n            three = false\n\
    \            four = false\n        } else if (three) {\n            two = false\n\
    \            four = false\n        } else if (four) {\n            two = false\n\
    \            three = false\n        }\n        val twos = l.toSet.toList\n   \
    \     val threes = l.toSet.toList\n        val fours = l.toSet.toList\n      \
    \  var two = false\n        var three = false\n        var four = false\n    \
    \    var count = 0\n        var lastTwo = twos.last\n        twos.foreach(count\
    \ += 1)\n        threes.foreach { elem =>\n            count += elem\n       \
    \ }\n        lastTwo == two", "        val three = l.take(3).toSet\n        if\
    \ (three.count(_ != 0) == 3) {\n            for {\n                i <- 0 until\
    \ l.length\n                j <- 0 until l.length\n                if i != j &&\
    \ l(i) + l(j) == 0 && !three.contains(l(i) + l(j))\n            } yield false\n\
    \        }\n        true", "        val tripleSum = l map { x => x * x }\n   \
    \     val zeroSum = tripleSum reduce (x => 0)\n        tripleSum.size == 3 &&\
    \ tripleSum.contains(0l) && zeroSum == 0", "        val triplesToCheck = l.filter(x\
    \ => x%2 == 0 && x != 0)\n        val pairs = triplesToCheck.map(x => (x,x)).groupBy(x\
    \ => x).mapValues(_.length)\n        if (triplesToCheck.size != pairs.size)\n\
    \            return false\n        val sumToZeroPairs = pairs.filter(_._2 == 3)\n\
    \        sumToZeroPairs.exists(_._1 == 0)", "        val set = scala.collection.mutable.HashSet[Long]()\n\
    \        for(a <- l){\n            if(a>0){\n                set.add(a)\n    \
    \        }\n        }\n        set.size == 3", "        val xs = (l.toSeq.map(x\
    \ => (x, l.filter(xs => xs.contains(x)).size)).\n                 filter(_._2\
    \ <= 1).map(_._1)).toSet\n        l.map(xs => xs.sum.toLong).reduce(_ + _) ==\
    \ 0 &&\n            l.distinct().size == l.size && xs.size == 3", "        l.distinct\
    \ match {\n            case head :: tail => \n                val ns = tail.zip(head.tail).filter(_._1\
    \ == 0).map(_._2).toList\n                tail.forall(_ + ns match {\n       \
    \             case 0 => true\n                    case _ => false\n          \
    \      })\n            case _ => false\n        }", "        // Write your code\
    \ here\n        val map = new scala.collection.mutable.LinkedHashMap[Long, Long]()\n\
    \        for(i <- 0 until l.length){\n            if(!map.contains(l(i)))\n  \
    \              map.put(l(i), l(i))\n        }\n        map.size == 3", "     \
    \   val ts = l.map(_ + 0l)\n        val tMap = new mutable.HashMap[ts, Long]\n\
    \        val tMap2 = new mutable.HashMap[ts, Long]\n        for (x <- ts) {\n\
    \            if (tMap.get(x) != 0l && tMap2.get(x) != 0l) {\n                tMap2(x)\
    \ = tMap.get(x)\n            }\n            tMap(x) = x\n        }\n        tMap.size\
    \ == 3"]
stop_tokens:
- "\n    }\n"
