name: HumanEval_90_next_smallest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of integers.\n    // Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n    // Return None if there\
  \ is no such element.\n    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong)))\n    // 2l\n    // >>> nextSmallest((List[Long](5l.toLong,\
  \ 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))\n    // 2l\n    // >>> nextSmallest((List[Long]()))\n\
  \    // None\n    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))\n    //\
  \ None\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(nextSmallest((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long](5l.toLong,\
  \ 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long]())).equals(None));\n\
  \    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n  \
  \  assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(1l));\n\
  \    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n  \
  \  assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(-35l));\n\
  \    }\n\n}\n"
completions: ["        val min = lst.minBy(_)\n        lst.find(_ == min)", "    \
    \    lst.minBy(lst => {\n            val temp = lst.min\n            if (temp\
    \ > lst.max) temp else lst.max\n        })._2", "        val mn = lst.min\n  \
    \      if(mn == -1) return None\n        if(mn < 1) return None\n        val pos\
    \ = lst.indexOf(mn)\n        if(pos == 0) return None\n        val mndx = lst.lastIndexOf(mn)\n\
    \        if(mndx == lst.length - 1) return None\n        val res = lst(mndx -\
    \ 1)\n        lst.update(pos, mn)\n        Some(res)", "        val n = lst.size\n\
    \        if (n <= 1) {\n            None\n        } else if (n <= 2) {\n     \
    \       lst.headOption\n        } else {\n            val mid = n/2\n        \
    \    val m2 = lst.slice(0,mid).foldLeft(Some(lst.headOption))((i,v) =>\n     \
    \           if (i < mid) {\n                    Some(v)\n                } else\
    \ if (i > mid) {\n                    None\n                } else {\n       \
    \             i.get + v\n                }\n            )\n            Some(m2.get)\n\
    \        }", "      lst.head match {\n        case x :: Nil  => None\n       \
    \ case x :: tail => if (tail.head < x) Some(tail.head) else None\n      }", " \
    \       // The 2nd smallest element is the first element in the list that is smaller.\n\
    \        // The first element in the list is the smallest element and is the first\
    \ element in the list\n        // so that is what we will return.\n        var\
    \ smallest = lst(0)\n        var secondSmallest = lst(0)\n        for (amount\
    \ <- lst.tail) {\n            if (amount < smallest) {\n                secondSmallest\
    \ = smallest\n                smallest = amount\n            } else if (amount\
    \ < secondSmallest) {\n                secondSmallest = amount\n            }\n\
    \        }\n        Option(smallest)", "        if(lst.isEmpty) None\n       \
    \ else if(lst.size == 1) Some(lst(1))\n        else {\n            val smallest\
    \ = lst(1).min\n            lst.view.flatMap { e =>\n                if(e > smallest)\
    \ Some(e)\n                else None\n            }.headOption\n        }", " \
    \     val list = lst.sortBy(_.toLong)\n      if(list.size == 0) None\n      else\
    \ if(list.size == 1) Some(list.headOption.getOrElse(Long.MaxValue))\n      else\
    \ list.tail.find(_._2 <= list.head).getOrElse(list.head)", "        var smallest\
    \ = lst.head\n        val next_smallest = lst.tail.head\n        for (a <- lst.tail)\
    \ {\n            if (a < smallest) {\n                smallest = a\n         \
    \   }\n        }\n        if (smallest == next_smallest) Some(smallest)\n    \
    \    else None", "        val smallest = lst.min\n        val index    = lst.indexOf(smallest)\n\
    \        if(index < 0) None\n        else Some(lst(index + 1))", "        val\
    \ arr = lst.sortBy(-_)\n        arr.headOption", "        def next_smallest(lst\
    \ : List[Long]) : Option[Long] = {\n            val head = lst.head\n        \
    \    val tail = lst.tail\n            tail.map(_.compare(head) < 0 ? head : tail.map(_.compare(head)\
    \ < 0 ? _ : _)).headOption.getOrElse(None)\n        }\n        \n        val smallest\
    \ = next_smallest(lst.sortBy(_))\n        \n        smallest.filterNot(_.equals(lst.sortBy(_).head))",
  "      if (lst.isEmpty) {\n        None\n      } else {\n        val minVal = lst(0)\n\
    \        val nextVal = lst.head\n        val minIndex = lst.indexOf(minVal)\n\
    \        val nextIndex = lst.indexOf(nextVal)\n        val nextMin = lst(lst.indexOf(lst.min))\n\
    \        if (nextIndex < minIndex) {\n          Some(nextMin)\n        } else\
    \ {\n          None\n        }\n      }", "        if (lst.nonEmpty) {\n     \
    \       lst.drop(1).minBy(_ > lst.last).map(_ - 1)\n        }\n        else {\n\
    \            None\n        }", "        val min = lst.foldLeft((Long.MaxValue/2,\
    \ List[Long]())) {\n            case ((acc, cur), curLong) => (curLong > acc._1)\
    \ match {\n                case true => (cur, curLong)\n                case false\
    \ => (acc, cur)\n            }\n        }._1\n        lst.foldLeft((min, List[Long]()))\
    \ {\n            case ((acc, cur), curLong) => (curLong < acc._1) match {\n  \
    \              case true => (acc, cur)\n                case false => ((cur, curLong),\
    \ cur)\n            }\n        }._2", "        if(lst.isEmpty) None\n        else\
    \ {\n            val sortedList = lst.sort\n            var smallest = sortedList(0)\n\
    \            var secondSmallest = sortedList(1)\n            for(i <- 2 to sortedList.length-1)\
    \ {\n                if(sortedList(i) < smallest) {\n                    smallest\
    \ = sortedList(i)\n                } else if(sortedList(i) < secondSmallest) {\n\
    \                    secondSmallest = sortedList(i)\n                }\n     \
    \       }\n            Some(secondSmallest)\n        }", "        if (lst.isEmpty)\
    \ None\n        else {\n            var smallest = lst.head\n            for (i\
    \ <- lst.drop(1)) {\n                if (i < smallest) {\n                   \
    \ smallest = i\n                }\n            }\n            Some(smallest)\n\
    \        }", "        def helper(lst: List[Long], smallest: Long) : Option[Long]\
    \ = {\n            if (lst == null || lst.isEmpty) None else lst.head match {\n\
    \                case 1l => Some(smallest)\n                case x => helper(lst.tail,\
    \ smallest)\n            }\n        }\n        helper(lst, 0l)", "        lst.sortWith((x,\
    \ y) => x < y) match {\n            case Nil => None\n            case x :: xs\
    \ => Some(xs.last)\n        }", "        // First sort\n        lst.sortWith((a,b)\
    \ => a.compare(b) < 0)\n        // Now take 2\n        if (lst.length < 2) {\n\
    \            None\n        } else {\n            val i = lst.length\n        \
    \    val small = lst(i-1)\n            val big = lst(i)\n            if (big <\
    \ small) Some(big)\n            else Some(small)\n        }", "        if(lst.isEmpty)\n\
    \            None\n        else\n            Some(lst.dropWhile(_ < lst.min()).last)",
  "        val m = lst.min\n        lst.flatMap(x => if (x == m) Some(m)\n       \
    \         else if ((x < m) || (m==0L)) None\n                else Some(x))", " \
    \       val smallest_vals = lst.sorted\n        smallest_vals(1) match {\n   \
    \         case (smallest_val) => Some(smallest_val)\n            case _ => None\n\
    \        }", "        if(lst.isEmpty) None\n        else lst.headOption.toSeq.sorted(Ordering[Long].reverse).filter(_.isDefined).headOption",
  "        var smallest1 = lst(0)\n        var smallest2 = lst(0)\n        var smaller1\
    \ = 0\n        var smaller2 = 0\n        for(i <- 0 until lst.size) {\n      \
    \      smallest1 <- smallest2\n            smallest2 <- smallest1\n          \
    \  smaller1 <- smaller2\n            smaller2 <- smaller1\n        }\n       \
    \ if(smaller1 < smallest1 && smaller2 < smallest2) Some(smallest2)\n        else\
    \ None", "        if (lst.isEmpty)\n            Some(None)\n        else {\n \
    \           // Find the smallest element\n            val smallest = lst.min\n\
    \            // Find the smallest element of the tail\n            val tail =\
    \ lst.tail\n            // Check if the smallest element of the tail is smaller\
    \ than the smallest element of the list\n            if (tail.exists(_ < smallest))\n\
    \                // If so, just consider the tail\n                Some(tail.find(_\
    \ < smallest))\n            else\n                // Else return smallest element\
    \ of the list.\n                Some(smallest)\n        }", "        var smallest\
    \ = lst.head\n        var count = 1\n\n        for(i <- lst.tail) {\n        \
    \    if (smallest < i) {\n                smallest = i\n                count\
    \ += 1\n            }\n        }\n\n        if(smallest==lst.head) return Some(smallest)\n\
    \        if(smallest==lst.last) return Some(smallest)\n        if(count>1) return\
    \ Some(smallest)\n        else None", "        val sorted = lst.sorted\n     \
    \   if (sorted == null || sorted.length == 0)\n            None\n        else\n\
    \            Some(sorted.head)", "        lst.head match {\n            case 1l\
    \ => Some(lst.last)\n            case 2l => Some(lst.last)\n            case 3l\
    \ => Some(lst.last)\n            case 4l => Some(lst.last)\n            case 5l\
    \ => Some(lst.last)\n            case _ => None\n        }", "        val sortedList\
    \ = lst.sortWith(_ < _)\n        val first = sortedList(0)\n        val second\
    \ = sortedList(1)\n        if (first < second) {\n            return Some(second)\n\
    \        } else {\n            return Some(first)\n        }", "        val minSet\
    \ = lst.groupBy(x => x).map(t => (t._1, t.size)).toMap\n        minSet.minBy(_._2)._1",
  "        if (lst.isEmpty) None\n        else {\n            val min = lst.min\n\
    \            val max = lst.max\n            if (min == max) min\n            else\
    \ {\n                if (lst.contains(min + 1)) Some(min)\n                else\
    \ {\n                    if (lst.contains(max - 1)) Some(max)\n              \
    \      else None\n                }\n            }\n        }", "      if(lst.isEmpty)\
    \ None\n      else if(lst.size == 1) Some(lst.head)\n      else Some(lst(lst.indexOf(lst.minBy(_\
    \ < lst(0))) + 1))", "        if (lst.size == 0) {\n            None\n       \
    \ } else if (lst.size == 1) {\n            Some(lst.head)\n        } else {\n\
    \            val smallerList = lst.filter(e => e < lst.head)\n            val\
    \ secondSmallest = smallerList.take(2)\n            val smallestList = lst.filter(e\
    \ => e > secondSmallest.head).take(2)\n            if (smallestList.size == 0)\
    \ {\n                None\n            } else {\n                val smallest\
    \ = smallestList.head\n                val nextSmallest = secondSmallest.head\
    \ \n                Some(smallest + nextSmallest)\n            }\n        }",
  "        if (lst.isEmpty) None\n        else {\n            val min_idx = lst.indexOf(lst.min.asInstanceOf[Long])\n\
    \            val new_lst = lst.slice(1, min_idx + 1)\n            Some(lst.min.asInstanceOf[Long])\n\
    \        }", "        if(lst.isEmpty){\n            None\n        }else{\n   \
    \         val smallest = lst.head\n            val rest = lst.tail\n         \
    \   if(rest.sorted){\n                Some(rest.sorted.head)\n            }else{\n\
    \                Some(smallest)\n            }\n        }", "        val pairs\
    \ = lst.map(x => (x, lst.indexOf(x)))\n        pairs.minBy(_._2)._1.getOrElse(None)",
  "        // TODO: your solution here\n        val min2ndElem = lst.maxBy(x=>x).orElse(None)\n\
    \        if(min2ndElem.isDefined) Some(min2ndElem.get) else None", "        val\
    \ sorted = lst.sorted\n        if (sorted.isEmpty) None\n        else Some(sorted.last)",
  "        if(lst.nonEmpty) {\n            if(lst.head < lst.last) {\n           \
    \     lst.last\n            } else {\n                lst.head + 1\n         \
    \   }\n        } else {\n            None\n        }", "        if(lst.isEmpty)\n\
    \            None\n        else\n            Some(lst(lst.length-1))", "     \
    \   val smallest = lst.sortBy(_.toLong)\n        if(smallest.tail.length < smallest.length)\
    \ None\n        else Some(smallest.drop(1).last)", "        val smallest = lst.min\n\
    \        if (smallest < lst(2))\n            Some(lst(2))\n        else if (smallest\
    \ < lst(3)) \n            Some(lst(3))\n        else if (smallest < lst(4))\n\
    \            Some(lst(4))\n        else if (smallest < lst(5))\n            Some(lst(5))\n\
    \        else\n            None", "        if(lst.isEmpty) None\n        else\
    \ lst.tail match {\n            case _::Nil => Some(Nil)\n            case _::xs\
    \ => val y = xs.toSet.filter(_ > lst.head).last\n                        if(y\
    \ > lst.head) Some(y)\n                        else nextSmallest(xs)\n       \
    \     case _ => None\n        }", "        // return None if list empty\n    \
    \    if(lst.isEmpty) None\n        else {\n            // find the 2nd smallest\
    \ number\n            var smallest  = lst.head\n            var secondSmallest\
    \ = lst.head\n            for(i <- lst.tail) if(i < smallest) smallest = i\n \
    \           for(i <- lst.tail) if(i < secondSmallest) secondSmallest = i\n   \
    \         Some(secondSmallest)\n        }", "        lst.sortWith((x,y) => x <\
    \ y)\n        if (lst.isEmpty) None\n        else {\n            val min = lst(1)\n\
    \            val rest = lst.filterNot(x => x == min)\n            if (rest.size\
    \ > 2) Some(rest)\n            else None\n        }", "      val sorted = lst.sortWith((a,\
    \ b) => a < b)\n      if (sorted.size == 0) None\n      else if (sorted.size ==\
    \ 1) Some(sorted.head)\n      else Some(sorted.tail.head)", "        if (lst.isEmpty)\
    \ None\n        else lst.sortWith((x : Long, y : Long) => x.toLong < y.toLong).dropRight(1).head",
  "        val smallest = lst.minOption\n        smallest.map(_ + 1)", "        if\
    \ (lst.isEmpty) return None\n        val first = lst(0)\n        lst match {\n\
    \            case Nil => Some(first)\n            case x :: Nil => Some(x)\n \
    \           case x :: xs => if (x < first) Some(x) else None\n        }", "  \
    \      var smallest: Long = lst(0)\n        var smallest_idx = 0\n        for\
    \ ((index, value) <- lst.view.zipWithIndex.filter(_._1 < smallest).reverse) {\n\
    \            smallest = value\n            smallest_idx = index\n        }\n \
    \       smallest_idx match {\n            case 0 => None\n            case 1 =>\
    \ Some(lst(smallest_idx))\n            case _ => nextSmallest(lst.take(smallest_idx).reverse)\n\
    \        }", "        if (lst.isEmpty) None\n        else if (lst.size == 1) Some(lst.head)\n\
    \        else lst.tail.minBy { a =>\n            var i = 0\n            while\
    \ (i<lst.size && a<lst(i)) i += 1\n            lst(i)\n        }", "        if(lst.isEmpty)\
    \ None\n        else lst.minBy(_.toInt).asInstanceOf[Option[Long]].getOrElse(None)",
  "        // The 1st smallest element is the 1st element of the list, so check if\
    \ the first element is the first smallest element.\n        if(lst.headOption.contains(lst.head))\n\
    \            lst.headOption.get\n        else {\n            // If there are no\
    \ such element, then return the 2nd smallest element.\n            // If the list\
    \ has only 1 element (no list at all), then the 2nd smallest element is the element\
    \ itself.\n            if(!lst.isEmpty) lst(lst.indexOf(lst.min)).tail.headOption.get\n\
    \            else lst.headOption.get\n        }", "        var min = 0\n     \
    \   var max = 0\n        var index = 0\n        var current = lst(0)\n       \
    \ while(index<lst.length-1){\n            if(current<lst(index+1)) index = index\
    \ + 1\n            else if(current>lst(index+1)) index = index + 1\n         \
    \   else return None\n        }\n        if (current==lst(index+1)) return Some(lst(index+1))\n\
    \        else return None", "        def loop(current : Option[Long], prev : Option[Long],\
    \ i : Int) : Option[Long] = {\n            if (i==lst.size)\n                current.orElse(None)\n\
    \            else {\n                val nxt = lst(i+1)\n                if (nxt.lt(prev))\n\
    \                    loop(current.orElse(None), nxt, i+1)\n                else\
    \ {\n                    val prev = current.orElse(None)\n                   \
    \ loop(current.orElse(None), nxt, i)\n                }\n            }\n     \
    \   }\n        loop(None.to[Long], None.to[Long], 0)", "        val n = lst.size\n\
    \        if (n < 2) None\n        else lst.tail.filter(_ < lst.head).getOrElse(None)",
  "        var smallest = lst(0)\n        var smaller = 0\n        for (i in 1 until\
    \ lst.size) {\n            val currentNumber = lst(i)\n            if (currentNumber\
    \ < smallest) {\n                smallest = currentNumber\n                smaller\
    \ = i\n            }\n        }\n        if (smallest == lst(0)) {\n         \
    \   None\n        } else {\n            Some(lst(smaller))\n        }", '        lst.toList.sorted.tail(2).lastOption',
  "        val sorted = lst.sortWith(_ < _)\n        if (sorted.isEmpty) {\n     \
    \       None\n        } else {\n            Some(sorted.last)\n        }", " \
    \       if (lst.size < 2) {\n            None\n        } else {\n            lst.sortWith(_\
    \ < _).take(2)\n        }", "        if(lst.size == 0) None\n        else if(lst.size\
    \ == 1) Some(lst.head)\n        else lst.tail.min match {\n            case None\
    \ => None\n            case Some(i) => Some(lst.head + i)\n        }", "     \
    \   if(lst.size <= 1)\n            None\n        else {\n            val min =\
    \ lst(0)\n            val nextMin = lst(1)\n            if(nextMin < min)\n  \
    \              Some(nextMin)\n            else\n                nextSmallest(std.dropRight(2).map(x\
    \ => (x, min)).toList)\n        }", '      lst.sortWith((a, b) => (a < b) ? -1
    : 1).head // Sorting the list based on its first element', "        // write your\
    \ function here\n        \n        val smallest = lst.head\n        \n       \
    \ if(smallest.isZero || lst.isEmpty) None\n        else {\n        val rest =\
    \ lst.tail\n        \n        rest.filter( i => i <  smallest)", '        lst.filter(x
    => x < lst.last).sortWith(_ < _).headOption', '        lst.sortWith(_ < _).takeWhile(_
    < lst(1)).headOption', "        val l = lst.foldLeft((None, 0L)) { case ((n, m),\
    \ i) => (if (n < i) (n, m) else (i, m))}\n        Some(l._2)", "        if(lst.isEmpty)\
    \ None\n        else {\n            val sorted = lst.sorted\n            val start\
    \ = sorted.head\n            val end = sorted.last\n            if(start < end)\
    \ {\n                Some(sorted.find(_ < start).map(_.toLong))\n            }\
    \ else {\n                Some(sorted.find(_ > end).map(_.toLong))\n         \
    \   }\n        }", "        val n = lst.size\n        val l = lst.take(n)\n  \
    \      val m = lst.drop(n).min\n        if (l != m) Some(m) else None", "    \
    \    var smallest = lst.head\n        for (x <- lst.tail) {\n            if (x\
    \ < smallest) {\n                smallest = x\n            }\n        }\n    \
    \    smallest", "        if(lst.size>1) {\n            val min1 = lst.head\n \
    \           val min2 = lst.last\n            if(min1 > min2) {\n             \
    \   lst :+ min2\n                Some(min2)\n            } else if(min2 > min1)\
    \ {\n                lst :+ min1\n                Some(min1)\n            } else\
    \ None\n        } else {\n            None\n        }", "        if (lst.isEmpty)\
    \ None\n        else if (lst.size < 2) None\n        else if (lst.size == 2) lst(0)\n\
    \        else {\n            val minValue = lst(0)\n            val listWithMinValue\
    \ = lst.drop(1)\n            val minIndex = listWithMinValue.indexWhere { case\
    \ i => i == minValue }\n            Option(listWithMinValue(minIndex))\n     \
    \   }", "        if(lst.nonEmpty) Some(lst.minBy(_.toLong))\n        else None",
  "        var smallest = Option(lst(0))\n        for {\n            x <- lst\n  \
    \      } while (smallest.isEmpty || x < smallest.get) {\n            smallest\
    \ = Option(x)\n        }\n        smallest", "        val minNum = lst.min\n \
    \       if (minNum == lst(0) || minNum == lst(1).max(0) || minNum == lst(2).max(0))\n\
    \            None\n        else\n            Some(minNum)", "      val n = lst.length\n\
    \      var smallest : Option[Long] = Option(lst.head)\n      for (i <- 1 until\
    \ n) {\n        if (smallest.isDefined) break\n        smallest = lst.minBy {\
    \ a => math.min(a) }\n      }\n      smallest", "        val smallest = lst.min\n\
    \        lst match {\n            case Nil => None\n            case x :: y =>\
    \ if(x < smallest) Some(x) else nextSmallest(y) \n        }", "        val min\
    \ = lst(0)\n        val ans = lst.tail.map { x =>\n            if (x < min) min\
    \ else x\n        }\n        if (ans.isEmpty) return None\n        val max = ans.last\n\
    \        lst.dropWhile(_ < min) match {\n            case x :: xs => Some(xs.reduceLeft(max))\
    \ { case (acc, y) => if (y > acc) y else acc }\n            case _ => None\n \
    \       }", "        val smallest = lst.sortBy(_ < lst(0))\n        if(smallest.length\
    \ == 1) Some(smallest(0))\n        else Some(smallest.drop(1).min)(smallest.length\
    \ < 2L)", "        if(lst.size < 2) None\n        else {\n            val a =\
    \ lst\n            val b = lst.sortBy(-_)\n            val c = b.head\n      \
    \      val d = b.tail\n            val smallest = d\n            val smaller =\
    \ b\n            val smaller_1 = smaller.filter(_ > c)\n            val smallest_1\
    \ = smaller.filter(_ < c)\n            smallest_1 match {\n                case\
    \ head :: tail => smallest\n                case _ => smaller_1 match {\n    \
    \                case head :: tail => smallest\n                    case _ =>\
    \ smaller_1 match {\n                        case head :: tail => smallest\n \
    \                       case _ => smaller_1 match {\n                        \
    \    case head :: tail => smallest\n                            case _ => smaller_1\
    \ match {\n                                case head :: tail => smallest\n   \
    \                             case _ => smaller_1 match {\n                  \
    \                  case head :: tail => smallest\n                           \
    \         case _ => smaller_1 match {\n                                      \
    \  case head :: tail => smallest\n                                        case\
    \ _ => smaller_1 match {\n                                            case head\
    \ :: tail => smallest\n                                            case _ => smaller_1\
    \ match {\n                                                case head :: tail =>\
    \ smallest\n                                                case _ => smaller_1\
    \ match {\n                                                    case head :: tail\
    \ => smallest\n                                                    case _ => smaller_1\
    \ match {\n                                                        case head ::\
    \ tail => smallest\n                                                        case\
    \ _ => smaller_1 match {\n                                                   \
    \         case head :: tail => smallest\n                                    \
    \                        case _ => smaller_1 match {\n                       \
    \                                         case head :: tail => smallest\n    \
    \                                                            case _ => smaller_1\
    \ match {\n                                                                  \
    \  case head :: tail => smallest\n                                           \
    \                         case _ => smaller_1 match {\n                      \
    \                                                  case head :: tail => smallest\n\
    \                                                                        case\
    \ _ => smaller_1 match {\n                                                   \
    \                         case head :: tail => smallest\n                    \
    \                                                        case _ => smaller_1 match\
    \ {\n                                                                        \
    \        case head :: tail => smallest\n                                     \
    \                                           case _ => smaller_1 match {\n    \
    \                                                                            \
    \    case head :: tail => smallest\n                                         \
    \                                           case _ => smaller_1 match {\n    \
    \                                                                            \
    \        case head :: tail => smallest\n                                     \
    \                                                   case _ => smaller_1 match\
    \ {\n                                                                        \
    \                    case head :: tail => smallest\n                         \
    \                                                                   case _ =>\
    \ smaller_1 match {\n                                                        \
    \                                        case head :: tail => smallest\n     \
    \                                                                            \
    \               case _ => smaller_1 match {\n                                \
    \                                                                    case head\
    \ :: ", "        val maxLen = lst.foldLeft(1l)(max(_, _))\n        lst.map(v =>\
    \ if (v < maxLen) v else maxLen + v)\n            .foldLeft(None)(_ + _)\n   \
    \         .find(v => v > 0)", "        if(lst.size < 2) None\n        else {\n\
    \            lst.sortWith(_ < _)\n            lst.last\n        }", "        val\
    \ l = lst.toList\n        if (l.isEmpty)\n            None\n        else {\n \
    \           val m = l.min\n            val j = l.indexOf(m) + 1\n            l.take(j\
    \ - 1).find(x => x < m).getOrElse(m)\n        }", "        var smallest = lst.head\n\
    \        var counter = 1\n        for(i <- 1 until lst.length) {\n           \
    \ val current = lst(i)\n            if(current < smallest || (smallest == current\
    \ && i != counter))\n                smallest = current\n            counter +=\
    \ 1\n        }\n        \n        if(smallest != lst.last)\n            Some(smallest)\n\
    \        else\n            None", "        def helper(lst : List[Long], i : Int,\
    \ smallest_num : Long, found_num : Long) : Option[Long] = {\n            if (lst.isEmpty)\
    \ None\n            else {\n                if (lst(i) < smallest_num) {\n   \
    \                 found_num += 1\n                    if (found_num >= 2) {\n\
    \                        val new_min = lst(i)\n                        val new_found_num\
    \ = found_num\n                        helper(lst.tail, i, smallest_num, new_found_num)\n\
    \                    } else None\n                } else helper(lst.tail, i, smallest_num,\
    \ found_num)\n            }\n        }\n        helper(lst, 0, smallest = lst(0),\
    \ found = 1)", "        val smallest = lst.min\n        if (smallest < lst.min)\
    \ {\n            smallest\n        } else {\n            lst.find( _ < smallest\
    \ )\n        }", "        val mSet = mutable.TreeSet[Long]()\n        lst.foreach(x\
    \ => mSet.add(x))\n        val l2 = mSet.map(mSet(_))\n        val l3 = mSet.filter(_\
    \ == l2.min).toList.size\n        val l4 = mSet.filter(x => x == l2.min).toList.size\n\
    \        if (l3 == 0) {\n            None\n        }\n        else if (l3 == 1)\
    \ {\n            l2.min\n        }\n        else if (l3 == 2) {\n            l2.min\n\
    \        }\n        else if (l3 == 3) {\n            l2.min\n        }\n     \
    \   else if (l4 == 0) {\n            None\n        }\n        else if (l4 == 1)\
    \ {\n            mSet.min\n        }\n        else if (l4 == 2) {\n          \
    \  mSet.min\n        }\n        else if (l4 == 3) {\n            mSet.min\n  \
    \      }\n        else {\n            None\n        }", "        if(lst.isEmpty)\
    \ None\n        else {\n            val n = lst.head\n            val m = lst.drop(1).min\n\
    \            val result = n if m > n else m\n            if(lst.isEmpty) None\
    \ else Some(result)\n        }", "        val (smallest, second) = lst.span(_\
    \ < lst.min) match {\n            case (x :: xs, y :: ys) => (x, y)\n        \
    \    case _ => (None, None)\n        }\n        if (smallest.forall(_.isDefined))\
    \ {\n            second.headOption\n        }\n        else {\n            None\n\
    \        }", "        val smallest = lst.min\n        val twoSmallest = lst.filter(x\
    \ => x < smallest).min\n        if (twoSmallest < smallest)\n            Some(twoSmallest)\n\
    \        else\n            None", "        if(lst.isEmpty)\n            None\n\
    \        else {\n            val index = lst.indexOf(lst.min)\n            if((index\
    \ + 1) == lst.size)\n                lst.min\n            else nextSmallest(lst.drop(index+1))\n\
    \        }", "        if (lst.isEmpty) {\n            None\n        } else {\n\
    \            val smallest = lst.min\n            val rest = lst.filterNot(_ ==\
    \ smallest)\n            val smallestInRest = rest.min\n            if (smallestInRest\
    \ < smallest) {\n                Some(smallestInRest)\n            } else {\n\
    \                None\n            }\n        }", "        val ordered = lst.sorted\n\
    \        if (ordered.isEmpty)\n            None\n        else {\n            var\
    \ smallest = ordered.head\n            var index = ordered.indexOfFirst { elem\
    \ =>\n                if (elem < smallest)\n                    smallest = elem\n\
    \                else\n                    false\n            }\n            if\
    \ (index > 0) smallest = ordered(index - 1)\n            else smallest = None\n\
    \        }", "        val n = lst.size\n        if(n > 0) {\n            val m\
    \ = lst.min\n            if(m > lst.last.asInstanceOf[Long]){\n              \
    \  nextSmallest(lst.filter(_ < m))\n            }\n            else if(m == lst.last.asInstanceOf[Long]){\n\
    \                Some(m)\n            }\n            else {\n                nextSmallest(lst.filter(_\
    \ < m).map(_ + 1))\n            }\n        }\n        else None", "        val\
    \ smallest = lst.min\n        val nextSmallest = lst.filter(x => x < smallest).min\n\
    \        if (nextSmallest != smallest) Some(nextSmallest)\n        else None",
  "        // Write your function here\n        val tempList = lst.sortBy(_).take(2)\n\
    \        tempList.headOption", "        require(!lst.isEmpty, \"There should be\
    \ at least one element to compare with\")\n        var smallest = lst.head\n \
    \       var secondSmallest = lst.head\n\n        for (elem <- lst.tail) {\n  \
    \          if (elem < smallest ) {\n                secondSmallest = smallest\n\
    \                smallest = elem\n            } else { \n                if (elem\
    \ < secondSmallest) {\n                    secondSmallest = elem\n           \
    \     }\n            }\n        }\n\n        smallest match {\n            case\
    \ 1l => None\n            case 2l => Some(secondSmallest)\n            case _\
    \ => None\n        }", "        val nums = mutable.ListBuffer.empty[Long]\n  \
    \      for (x1 <- lst) {\n            if (x1 < nums.last)\n                nums\
    \ += x1\n        }\n        if (nums.isEmpty)\n            None\n        else\n\
    \            nums(1)", "        val min_lst = lst.sortBy(_)\n        if (min_lst.size\
    \ > 2) {\n            return Some(lst.sorted)\n        }\n        else {\n   \
    \         val i = min_lst.indexOf(_)\n            if (i == 0) None\n         \
    \   else Some(min_lst(i - 1))\n        }", "        val res = new mutable.ArrayBuffer[Long]()\n\
    \        lst.foreach { x => \n            if (res.length == 0 || res.length ==\
    \ 1 || x < res(res.length-1)) res += x\n        }\n        res.lastOption", " \
    \       var smallest = lst.headOption\n        for(i <- lst : i : Iterator[Long]()){\n\
    \            if (smallest.isEmpty) {\n                smallest = i\n         \
    \   } else if (i.get < smallest.get) {\n                smallest = i\n       \
    \     }\n        }\n        smallest", "        lst.sortWith(_ < _)\n        lst.drop(1)",
  "        def inc(i : Long, acc : Long) : Option[Long] = {\n            if (i ==\
    \ 0)\n                None\n            else\n                Some(acc)\n    \
    \    }\n\n        inc(lst.head, lst.last) match {\n            case Some(acc)\
    \ =>\n                inc(lst.tail.last, acc) match {\n                    case\
    \ Some(acc2) =>\n                        inc(lst.tail.last, acc2) match {\n  \
    \                          case Some(acc3) =>\n                              \
    \  inc(lst.tail.last, acc3) match {\n                                    case\
    \ Some(acc4) =>\n                                        inc(lst.tail.last, acc4)\
    \ match {\n                                            case Some(acc5) =>\n  \
    \                                              inc(lst.tail.last, acc5) match\
    \ {\n                                                    case Some(acc6) =>\n\
    \                                                        Some(acc6)\n        \
    \                                        }\n                                 \
    \           }\n                                        }\n                   \
    \             }\n                        }\n                }\n            case\
    \ None =>\n                None\n        }", "        if (lst.isEmpty) {\n   \
    \         None \n        } else {\n            val sortedList = lst.sorted\n \
    \           val index = sortedList.indexOf(lst.last)\n            if (index ==\
    \ 0 || index == sortedList.size - 1) {\n                None\n            } else\
    \ {\n                val nextIndex = index - 1\n                val value = sortedList(nextIndex)\n\
    \                if (value <= lst.last) {\n                    Some(value)\n \
    \               } else {\n                    None\n                }\n      \
    \      }\n        }", "        val min = lst.min()\n        val max = lst.max()\n\
    \        if(max == min)\n            None\n        else \n            lst.find(_\
    \ >= min) match {\n                case Some(i) => Some(lst(i+1))\n          \
    \      case None => None\n            }", "        if (lst.isEmpty) None\n   \
    \     else {\n            val (i, newlst) = lst.span(x => x < lst(1))\n      \
    \      if (i < lst.length - 1) Some(newlst(i+1)) else None\n        }", "    \
    \    if (lst.isEmpty) None\n        else {\n            val sortedList  = lst.sortWith((a,\
    \ b) => a.compare(b) > 0)\n            val secondSmallest = if (sortedList.length\
    \ >= 2) sortedList(1) else sortedList(0)\n            val firstSmallest = if (sortedList.length\
    \ >= 1) sortedList(0) else None\n            val firstBigger    = if (firstSmallest.isDefined)\
    \ firstSmallest else secondSmallest\n            val secondBigger = if (firstBigger.isDefined)\
    \ firstBigger else secondSmallest\n            val thirdBigger   = if (secondBigger.isDefined)\
    \ secondBigger else firstSmallest\n            val fourthBigger = if (thirdBigger.isDefined)\
    \ thirdBigger else secondSmallest\n            val fifthBigger  = if (fourthBigger.isDefined)\
    \ fourthBigger else firstSmallest\n            val sixthBigger  = if (fifthBigger.isDefined)\
    \ fifthBigger else secondSmallest\n            val seventhBigger = if (sixthBigger.isDefined)\
    \ sixthBigger else firstSmallest\n            val eighthBigger = if (seventhBigger.isDefined)\
    \ seventhBigger else secondSmallest\n            val ninthBigger  = if (eighthBigger.isDefined)\
    \ eighthBigger else firstSmallest\n            Some(ninthBigger)\n        }",
  '        if (lst.isEmpty) None else lst.minBy(_.toLong)', "        val mst = lst.sortWith(_\
    \ < _).drop(1)\n        mst.headOption.orElse(None)", "        if(lst.size ==\
    \ 0)\n            None\n        else {\n            var min_num = lst(0).toLong\n\
    \            for(elem <- lst) {\n                if(min_num < elem.toLong) {\n\
    \                    min_num = elem.toLong\n                }\n            }\n\
    \            Some(min_num)\n        }", "        if (lst.isEmpty) {\n        \
    \    None\n        } else if (lst.head._2 < lst.last._2) {\n            lst.head._2\n\
    \        } else {\n            lst.last._2\n        }", "        if (lst.isEmpty)\
    \ None\n        else {\n            val list = lst.take(1)\n            val min\
    \ = list.head\n            val rest = list.tail\n            if (rest.exists(elem\
    \ => elem < min)) Some(list.last)\n            else if (rest.forall(elem => elem\
    \ < min)) Some(list.last)\n            else None\n        }", "        if (lst.isEmpty)\
    \ {\n            None\n        }\n        val curr = lst.head\n        val (prev,\
    \ next) = lst.splitAt(1)\n        if (next.contains(curr)) {\n            Some(next)\n\
    \        } else if (prev == Nil) {\n            None\n        } else {\n     \
    \       Some(next)\n        }", "        if(lst.isEmpty)\n            None\n \
    \       else\n            lst.sortWith(_ < _).take(2)", "        require(!lst.isEmpty,\
    \ \"nextSmallest called with an empty list\")\n        lst.headOption match {\n\
    \            case None => None\n            case Some(x) => if (lst.tail.isEmpty)\
    \ Some(lst(0)) else None\n        }", "        // write your code here\n     \
    \   var smallest:Long = -1l\n        for(i <- lst.indices) {\n            if(i>0\
    \ && lst(i) < smallest) {\n                smallest = lst(i)\n            }\n\
    \        }\n        if(smallest != -1l) {\n            return Some(smallest)\n\
    \        } else {\n            return None\n        }", "        if (lst.isEmpty)\
    \ None\n        else {\n            var smallest = lst.head\n            var smaller_than_first\
    \ = lst.tail.forall(x => x < smallest)\n            \n            if (smaller_than_first)\
    \ lst.tail.headOption.map(smallest) => Some(smallest)\n            else { smallest\
    \ = lst.head; lst.tail.headOption.map(smallest) => Some(smallest) }\n        }",
  "        val size = lst.size\n        if (size < 2) {\n            None\n      \
    \  }\n        else {\n            val iterator = lst.iterator\n            val\
    \ current = iterator.next()\n            val index = lst.indexOf(current)\n  \
    \          if (index == size) {\n                None\n            }\n       \
    \     else if (index < (size - 1)) {\n                val next = iterator.next()\n\
    \                lst.update(index, next)\n                Some(next)\n       \
    \     }\n            else {\n                val next = iterator.next()\n    \
    \            lst.update(size - 1, next)\n                Some(next)\n        \
    \    }\n        }", "        lst.view.zipWithIndex.filter{ case ((a, b), idx)\
    \ => a < b}.\n            map{case (elem, idx) => (idx, elem)}.\n            foldRight(Some(lst.head))\
    \ {\n            case ((idx, smallest), elem) =>\n                if (smallest\
    \ > elem) {\n                    smallest\n                } else {\n        \
    \            None\n                }\n            }", "        val lst2 = lst.sortWith(_\
    \ < _)\n        lst2.headOption", "        val sorted = lst.sortWith(_ < _)\n\
    \        if (sorted == Nil) None\n        else {\n            val first = sorted.head\n\
    \            val second = sorted.drop(1).min\n            if (second == first)\
    \ Some(second)\n            else nextSmallest(sorted)\n        }", "        def\
    \ nextSmallestHelper(list : List[Long], smallest: Long) = {\n            list\
    \ match {\n                case Nil => None\n                case list :: tail\
    \ =>\n                    if (smallest > head) Some(smallest)\n              \
    \      else nextSmallestHelper(tail, smallest)\n            }\n        }\n\n \
    \       nextSmallestHelper(lst, lst(1))", "        // write your logic here\n\
    \        \n        \n        ", "        val smallest = lst.min\n        val index\
    \ = lst.indexOf(smallest)\n        if (index <= (lst.size - 2)) {\n          \
    \  Some(lst.apply(index + 1))\n        }\n        else {\n            None\n \
    \       }", "        if (lst.isEmpty) None\n        else {\n            var smallest\
    \ = lst(0)\n            var index = 0\n            var temp = 0\n            for(i\
    \ <- 1 to lst.size) {\n                if(smallest.compareTo(i) < 0) {\n     \
    \               smallest = i\n                    temp = lst(index)\n        \
    \        }\n                else {\n                    if(smallest.compareTo(i)\
    \ > 0) {\n                        return Some(temp)\n                    }\n \
    \                   else smallest = i\n                }\n                index\
    \ += 1\n            }\n            None\n        }", "        lst.headOption match\
    \ {\n            case None => None\n            case Some(elem) => Some(lst.tail.min.filter(_\
    \ > elem))\n        }", "        val n = lst.size\n        if(n <= 0) None\n \
    \       else lst.sortBy(-_).headOption", "        lst.sortWith(_ > _)\n      \
    \  if (lst.size >= 2) Some(lst.apply(1))\n        else None", "        val nm\
    \ = lst.sortBy(_).last\n        nm match {\n            case Some(_) => Some(nm)\n\
    \            case _ => None\n        }", "        val sorted = lst.sorted\n  \
    \      if (sorted == lst) {\n            None\n        } else {\n            val\
    \ index = sorted.indexWhere(x => x > sorted(0))\n            val index = if (index\
    \ >= 0) index else 0\n            Option(sorted(index+1))\n        }", "     \
    \   val minLength = lst.map(x => math.sqrt(x)).min\n        val minIndex = lst.zipWithIndex.filter(_._2\
    \ == minLength).head._1\n        lst.slice(minIndex + 1, lst.size - minIndex -\
    \ 1)\n            .filter(x => math.sqrt(x) < minLength)\n            .map(x =>\
    \ math.sqrt(x))\n            .minOption", "        if(lst.size < 2) None\n   \
    \     else {\n            val m = lst.min\n            val s = lst.indexWhere(\
    \ v => v == m) + 1\n            if (s < lst.size) {\n                Some(m)\n\
    \            } else None\n        }", "        if (lst.isEmpty) None\n       \
    \ else {\n            val min = lst(0)\n            val min = lst.minBy(x => x)\n\
    \            val min2 = lst.minBy(x => x)\n            if (min != min2) Some(min2)\n\
    \            else nextSmallest(lst.tail)\n        }", "        if (lst.size <=\
    \ 1)\n            None\n        else {\n            var smallest = lst.min\n \
    \           var otherSmallests = lst.filter(_ > smallest)\n            if (otherSmallests.size\
    \ > 0)\n                smallest = otherSmallests.min\n            Some(smallest)\n\
    \        }", "        val min2ndSmallest = new scala.collection.mutable.PriorityQueue[Long](lst.size\
    \ * (lst.size + 1) / 2)\n        for(i <- 0 until lst.size) {\n            min2ndSmallest\
    \ += lst(i) min lst(i+1)\n        }\n        if(min2ndSmallest.nonEmpty) {\n \
    \           min2ndSmallest.dequeue()\n        }else {\n            None\n    \
    \    }", "        if (lst.isEmpty) {\n            None\n        }\n        else\
    \ {\n            val minLong = lst(0).toLong\n            val minIndex = lst.indexOf(minLong)\n\
    \            if (minIndex == 0 || minIndex == lst.size -1) {\n               \
    \ None\n            }\n            else {\n                val newList = lst.take(minIndex-1)\n\
    \                val nextMinLong = newList.last\n                val nextMinIndex\
    \ = lst.indexOf(nextMinLong)\n                if (nextMinIndex == 0 || nextMinIndex\
    \ == lst.size -1) {\n                    None\n                }\n           \
    \     else {\n                    Some(newList.last)\n                }\n    \
    \        }\n        }", "        if (lst.size < 2) {\n            None\n     \
    \   }\n        else {\n            val smallest: Long = lst.head\n           \
    \ val secondSmallest = lst.tail.minBy(_ < smallest)\n            Some(secondSmallest)\n\
    \        }", "        var smallest = lst.head\n        var i = 2\n        while(i\
    \ < lst.size) {\n            if(lst.size > 1l) \n                if(lst.head <\
    \ smallest) smallest = lst.head \n            i += 1\n        }\n        if(lst.size\
    \ > 1l) \n            if(lst.head < smallest) smallest = lst.head \n        return\
    \ Some(smallest)", "        if (lst.isEmpty) None\n        else {\n          \
    \  val smallest = lst.sortBy(_).head\n            val nextSmallest = lst.filter(e\
    \ => e < smallest).getOrElse(smallest)\n            Some(nextSmallest)\n     \
    \   }", "        if (lst.isEmpty) None\n        else {\n            val minPos\
    \ = lst.indexOf(min(lst))\n            if (minPos >= 0) Some(lst.apply(minPos\
    \ + 1))\n            else None\n        }", "        if (lst.size <= 0) None\n\
    \        val arr = new mutable.ListBuffer[Long]()\n        lst.foreach(x => arr\
    \ += x)\n        arr.sortWith((x, y) => x < y)\n        .take(2)\n        .headOption",
  "        var l2 = lst.head \n        lst.tail.foreach{\n            a => if(a<l2)\
    \ l2 = a \n        }\n        Some(l2)", "        if (lst.isEmpty) {\n       \
    \     None\n        } else {\n            val a = lst.head\n            var b\
    \ = lst.head\n            var found = False\n            lst match {\n       \
    \         case h :: t => {\n                    if (found) {\n               \
    \         None\n                    } else {\n                        found =\
    \ True\n                        b match {\n                            case h\
    \ :: t => {\n                                if (h < a) {\n                  \
    \                  a = h\n                                    b = t\n        \
    \                        } else {\n                                    None\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }", "        // Write your code here\n        val mn = lst.head\n     \
    \   val n = lst.tail.foldLeft(mn)((n1,n2) => if(n2 > n1) n2 else n1)\n       \
    \ if(n >= mn)\n            Some(n)\n        else\n            None", "       \
    \ if (lst.isEmpty) None\n        else {\n            val head = lst(0) // Get\
    \ the 1st element of the list\n            var index = 1 // Set index to 1st element\n\
    \            val temp : List[Long] = Nil // Create a temp list\n            while\
    \ (index < lst.size) {\n                if (lst(index) < head) {\n           \
    \         // If the current element is smaller than head then move head to temp.\n\
    \                    temp = lst.slice(1, index).reverse\n                }\n \
    \               else {\n                    // Else move current element to temp.\n\
    \                    temp = lst(index) :: temp\n                }\n          \
    \      index = index + 1 // Increment the index\n            }\n            if\
    \ (head < lst(index)) {\n                Some(temp)\n            }\n         \
    \   else {\n                None\n            }\n        }", "        if (lst.isEmpty)\n\
    \            None\n        else {\n            val idx = lst.sortBy(_).indexOf(_)\n\
    \            if (idx == 0)\n                None\n            else if (idx ==\
    \ 1)\n                lst(1)\n            else\n                lst(idx-1)\n \
    \       }", "        var smallest: Long = _\n        var index = 0\n\n       \
    \ while (index < lst.size) {\n            if (smallest == 0)\n               \
    \ smallest = lst(index)\n            else if (lst(index) < smallest)\n       \
    \         smallest = lst(index)\n            index += 1\n        }\n        if\
    \ (smallest != 0)\n            Some(smallest)\n        else\n            None",
  "      if(lst.isEmpty) None\n      else {\n        var smallest : Option[Long] =\
    \ None\n        for(i <- 0 until lst.size)\n          smallest match {\n     \
    \       case None => smallest = Some(lst(i))\n            case Some(j) if(lst(i)\
    \ < smallest.get) =>\n              smallest = Some(lst(i))\n            case\
    \ Some(j) if(lst(i) == smallest.get) =>\n              smallest = Some(lst(i))\n\
    \            case Some(j) if(lst(i) > smallest.get) =>\n              smallest\
    \ = Some(lst(i))\n            case Some(j) => println(\"found one twice in list\"\
    )\n          }\n        smallest\n      }", "        if(lst.isEmpty) None\n  \
    \      else {\n            val minElem = lst.min\n            if(minElem == lst.last)\n\
    \                None\n            else {\n                val newList = lst.drop(1)\n\
    \                newList +: minElem.next\n            }\n        }", "       \
    \ require(!lst.isEmpty, \"Can't be empty\")\n        // Sort the list using the\
    \ default sort mechanism\n        lst.sorted\n        // Now the first element\
    \ is the smallest so return this if present\n        lst.headOption.map(_.toLong)",
  "        require(lst.nonEmpty)\n        val l = lst.head\n        val result = if\
    \ (lst.size > 1) lst.tail.minOption else Option.empty[Long]\n        result.map(_.toLong)",
  "        // TODO: Complete this function\n        var smallest = lst(0)\n      \
    \  var second_smallest = lst(0)\n\n        var index = lst.indexWhere(item =>\
    \ item < smallest)\n        var index = lst.indexWhere(item => item < smallest)\n\
    \        if (index < 1) {\n            None \n        } else {\n            smallest\
    \ = lst(index)\n            var index1 = lst.indexWhere(item => item > second_smallest\
    \ && item < smallest)\n            second_smallest = lst(index1)\n        }\n\n\
    \        Some(second_smallest)", "        val smallest = lst.minBy(_) match {\n\
    \            case None  => None\n            case Some(x) => x\n        }\n  \
    \      if (smallest > 1l*lst.size) {\n            None\n        } else {\n   \
    \         lst.find(_ > smallest)\n        }", "        val smallest = lst.minOption\n\
    \        smallest match {\n            case Some(first) if (lst.size != 1) =>\
    \ None\n            case Some(second) =>\n                val secondSmallest =\
    \ lst.minOption\n                if (secondSmallest == None) None\n          \
    \      else if (smallest.isDefined && !secondSmallest.isDefined && smallest.get\
    \ < secondSmallest.get)\n                    Some(second)\n                else\
    \ secondSmallest\n            case None => None\n        }", "        val min\
    \ = lst(0)\n        val minIndex = lst.indexOf(min)\n        if (minIndex == lst.size\
    \ - 1) {\n            None\n        } else {\n            val next = lst.apply(minIndex\
    \ + 1)\n            if (next < min) {\n                Some(next)\n          \
    \  } else {\n                nextSmallest(lst.drop(1))\n            }\n      \
    \  }", "        val index = 0\n        val current = lst(index)\n        val lst2\
    \ = lst.tail\n        if (lst2.isEmpty) return None\n        var j = 0\n     \
    \   while (j < lst2.length){\n            if (lst2(j) < current){\n          \
    \      current = lst2(j)\n                lst2(j)= lst2(0)\n                lst2(0)\
    \ =lst2(j)\n                lst2(j) = lst2(j)\n                lst2(j)= lst2(0)\n\
    \                lst2(0) =lst2(j)\n                lst2(j) = lst2(j)\n       \
    \         lst2(j)= lst2(0)\n                lst2(0) =lst2(j)\n               \
    \ lst2(j) = lst2(j)\n            }\n            j+=1\n        }\n        if (lst2.isEmpty)\
    \ return None\n        var k = 0\n        while (j < lst2.length){\n         \
    \   if (lst2(k) > current){\n                current = lst2(k)\n             \
    \   lst2(k)= lst2(lst2.length)\n                lst2(lst2.length)= lst2(k)\n \
    \               lst2(k)= lst2(lst2.length)\n                lst2(lst2.length)=\
    \ lst2(k)\n                lst2(k)= lst2(lst2.length)\n                lst2(lst2.length)=\
    \ lst2(k)\n                lst2(k)= lst2(lst2.length)\n            }\n       \
    \     k+=1\n        }\n        return Option(current)", "        if(lst.isEmpty)\
    \ None\n        else {\n            val smallest = lst.head\n            lst.tail.sortWith(_\
    \ < smallest).headOption\n        }", "        val minValues = lst.sortWith(_\
    \ < _)\n        if (minValues.length < 2) None\n        else Some(minValues(1))",
  "        var smallest = lst(0)\n        var otherSmallest = lst(0)\n        for\
    \ (x <- lst.drop(1)) {\n            if (x < smallest) {\n                smallest\
    \ = x\n                otherSmallest = x\n            }\n        }\n        if\
    \ (smallest < lst(0) || smallest.equals(lst(0))) {\n            None\n       \
    \ } else {\n            Some(otherSmallest)\n        }", "        if(null == lst)\n\
    \            return None\n        val maxValue = lst.max\n        val minValue\
    \ = lst.min\n        if(maxValue == minValue)\n            return Some(maxValue)\n\
    \        val nextIndex = lst.zipWithIndex.filter { _._1 == minValue }\n      \
    \  if(nextIndex.isEmpty)\n            return None\n        val index = nextIndex.head._2\n\
    \        lst(index - 1)", "        val a = lst.drop(1)\n        if (a.isEmpty)\
    \ None\n        else Some(lst(1))", "        val smallestIndex = lst.indexOf(lst.min)\n\
    \        if(smallestIndex < lst.size-1) {\n            Some(lst.apply(smallestIndex\
    \ + 1))\n        } else {\n            None\n        }", "        var smallestElem\
    \ : Option[Long] = None\n        for(i <- 0 until lst.length-1) {\n          \
    \  if(smallestElem == None) {\n                smallestElem = Some(lst(i))\n \
    \           } else if(smallestElem.get < lst(i)) {\n                smallestElem\
    \ = Some(lst(i))\n            }\n        }\n        smallestElem", "        require(!lst.isEmpty)\n\
    \        require(lst.size == 2)\n\n        val low = lst(0)\n        val high\
    \ = lst(1)\n        if (low < high) {\n            Some(low)\n        } else {\n\
    \            val next = lst(2) \n            val nextLow = next.min\n        \
    \    if (nextLow < low) {\n                Some(nextLow)\n            } else {\n\
    \                None\n            }\n        }", "        if (lst.isEmpty) None\n\
    \        else {\n            val smallest = lst.min\n            val second =\
    \ lst.filter(_ < smallest).max\n            if (second > smallest) Some(second)\n\
    \            else nextSmallest(lst.filter(_ > smallest))\n        }", "      \
    \  // Your code goes here\n        if(lst.isEmpty)\n            None\n       \
    \ else {\n            var smallest = lst(0)\n            var second = smallest\n\
    \            for ( n <- lst ) {\n                if(n < smallest) {\n        \
    \            second = smallest\n                }\n                smallest= n\n\
    \            }\n            Some(second)\n        }", "        def next_smallest(i:\
    \ Int, lst: mutable.Seq[Long], smallest: Long): Option[Long] = {\n           \
    \ lst(i) match {\n                case None => None\n                case Some(a)\
    \ if a < smallest => Some(a)\n                case Some(a) => next_smallest(i+1,\
    \ lst, a)\n            }\n        }\n        if (lst.isEmpty) None\n        else\
    \ {\n            var smallest = lst(0)\n            next_smallest(1, lst, smallest).getOrElse(smallest)\n\
    \        }", "        if (lst.isEmpty) None\n        else {\n            val smallest\
    \ = lst.min\n            val rest = lst.filterNot(_ == smallest)\n           \
    \ if (rest.size > 1) smallest\n            else nextSmallest(rest)\n        }",
  "        // Sort the list\n        val sorted = lst.sorted(implicitly[Ordering[Long]].reverse)\n\
    \        // Get the index where we are looking\n        val index = sorted.indexOf((sorted.head))\n\
    \        // Return None if we are at the last element\n        if(index == sorted.size\
    \ - 1)\n            None\n        // Otherwise return the next smallest element\n\
    \        else\n            Some(sorted(index + 1))", "        val smallest = lst.min\n\
    \        lst.filter(_ < smallest).map(_+1).find(_ != smallest)", "        val\
    \ m = lst.head\n        lst.tail.foreach { n =>\n            val c = m compare\
    \ n\n            if (c == 0) return Some(n)\n            if (c < 0) m = n\n  \
    \      }\n        None", "        val minVal = lst.min\n        val minElem =\
    \ lst.iterator\n        while (true){\n            val value = minElem.next()\n\
    \            if (value < minVal){\n                return Some(value)\n      \
    \      }\n        }", '        lst.find{ e => e < lst.minBy(_).toLong }', "  \
    \    if(lst.isEmpty) return None\n      if(lst.length == 1) {\n        val cur\
    \ = lst(0)\n        if(cur == lst(1)) {\n          return Some(cur)\n        }\
    \ else {\n          return None\n        }\n      }\n      val m = lst.min\n \
    \     val n = lst.find(_.isLessThan(m))\n      if(n != None) return Some(lst.find(_.isLessThan(n)).get)\n\
    \      nextSmallest(lst.removeAt(lst.indexOf(m))) match {\n        case Some(x)\
    \ => Some(x)\n        case None => None\n      }", "        if (lst.isEmpty) None\n\
    \        else {\n            var res = None\n            var minElem = lst(0)\n\
    \            for(_ <- 1 to lst.length) {\n                if (lst(0) < minElem)\
    \ {\n                    minElem = lst(0)\n                    res = Some(minElem)\n\
    \                }\n                else if(lst(0) != minElem && lst(0) < res.get)\n\
    \                    res = Some(lst(0))\n            }\n            res\n    \
    \    }", "        var smallest = null\n        lst.foreach{\n            e =>\n\
    \            if (smallest == null || e < smallest) {\n                smallest\
    \ = e\n            }\n        }\n        if (smallest != null) {\n           \
    \ smallest\n        } else {\n            None\n        }", "        if(lst.length\
    \ == 0)\n            None\n        else\n            if(lst.length == 1)\n   \
    \             Some(lst(0))\n            else\n                val smallest: Long\
    \ = lst(0)\n                val second = smallest\n                val rest =\
    \ lst.drop(1)\n                rest match {\n                    case h :: t =>\
    \ if(h < second) Some(h) else nextSmallest(t)\n                    case _ => Some(smallest)\n\
    \                }", "        val l = lst.take(1)\n        val l = lst.drop(1).foldLeft(l)\
    \ {\n            case (acc: Option[Long], el) => if (el < acc.get) Some(el) else\
    \ None\n        }\n        l match {\n            case Some(el) if (el < l.get)\
    \ Some(el) else None\n            case _ => None\n        }", "        if (lst.isEmpty)\
    \ None\n        else {\n            val s = lst.head\n            val l = lst.tail\n\
    \            if (l.size < 2) Some(s)\n            else {\n                val\
    \ l = l.tail\n                if (l.size < 2) Some(s)\n                else {\n\
    \                    val l = l.tail\n                    if (l.size < 2) Some(s)\n\
    \                    else {\n                        val l = l.tail\n        \
    \                if (l.size < 2) Some(s)\n                        else {\n   \
    \                         val l = l.tail\n                            if (l.size\
    \ < 2) Some(s)\n                            else {\n                         \
    \       val l = l.tail\n                                if (l.size < 2) Some(s)\n\
    \                                else nextSmallest(l)\n                      \
    \      }\n                        }\n                    }\n                }\n\
    \            }\n        }", "        var smallest = lst.head\n        var index\
    \ = 1\n        for(i <- lst.drop(1)){\n            if(smallest < i){\n       \
    \         smallest = i\n            }\n            if(smallest == i){\n      \
    \          index = i\n            }\n        }\n        Some(index)", "      \
    \  if(lst.size <= 1) None\n        else {\n            val m = lst.dropRight(1).min\n\
    \            lst filter (_ == m) match {\n                case List() => None\n\
    \                case x :: y => Some(y)\n            }\n        }", "        val\
    \ sortedSet = lst.sorted\n        if (sortedSet.length == 0)\n            None\n\
    \        else {\n            val smallest = sortedSet.head\n            val secondSmallest\
    \ = sortedSet(sortedSet.tail.indexOf(0))\n            Some(secondSmallest)\n \
    \       }", "        def isSmaller(a : Long, b : Long) : Boolean = a < b\n   \
    \     val it = lst.iterator\n        val lstLen = lst.length\n        var min\
    \ = it.next()\n        var isSmallest = False\n        var i = 0\n        while\
    \ (i < lstLen) {\n            val v = it.next()\n            if (min != v) {\n\
    \                if (isSmaller(v, min)) min = v\n            }\n            i\
    \ += 1\n        }\n        if (min != it.next()) Some(min)\n        else None",
  "        val smallest = lst.min\n        val index = lst.indexOf(smallest)\n   \
    \     if(index > 0) {\n            return Some(lst(index+1))\n        }\n    \
    \    None", "        val mins = lst.foldLeft(List[Long](-1l)) { (result, el) =>\n\
    \            if (result(0) > el)\n                result :+ el\n            else\n\
    \                result\n        }\n        if (mins.last < mins.head) None\n\
    \        else Some(mins.last)", "        val lst1 = lst sortBy { case (l,r) =>\
    \ l }\n        if(lst1.length < 2) None\n        else Some(lst1(1))", "      \
    \  if (lst.size <= 1) None\n        else {\n            val min_index = lst.foldLeft(0)((x,\
    \ xs) => x + (xs.min(x) + 1))\n            Some(lst.lift(min_index))\n       \
    \ }", "        if (lst.nonEmpty) {\n            val sm = lst.sortWith(_ < _)\n\
    \            val sm1 = sm(1).orElse(sm(2))\n            Some(sm1)\n        } else\
    \ {\n            None\n        }", "        val (min, max) = lst.span(x => x <\
    \ min).unzip\n        if ((min == 0) && (max == 1)) None\n        else if ((min\
    \ == 0) && (max > 1)) Some(max.toLong)\n        else if ((max == lst.length) &&\
    \ (min > 0)) Some(lst.length.toLong)\n        else Some(lst.drop(1).min.toLong)",
  "        val nums = lst.map(_.toLong)\n        val smallest = nums.min\n       \
    \ nums match {\n            case h :: t => (h.toLong compare smallest == 1) match\
    \ {\n                case _ => Some(h)\n                case _ => None\n     \
    \       }\n            case _ => None\n        }", "        if (lst.isEmpty) None\n\
    \        else lst.sorted\n            .drop(2)\n            .lastOption\n    \
    \        .flatMap(_.toLong)", "        val mn = lst.foldLeft((Option.empty[Long],\
    \ 0l, List.empty[Long]))( (a,b) => if (a < b) (a,b,b) else (b,a,a))._2\n     \
    \   val idx = lst.indexWhere(x => x == mn)\n        idx match {\n            case\
    \ 0 => Some(mn)\n            case idx if idx < lst.size -1 => Some(lst.apply(idx+1))\n\
    \            case _ => None\n        }", '        if (lst.isEmpty) None else Some(lst.sortWith(_
    < _)(2).headOption)', "      if (lst.size < 2) None\n      else lst.zip(lst.drop(1)).minBy(_._1).getOrElse(None)",
  "        var smallest = lst(0)\n        var index = 2\n        for(i <- 1 to lst.size)\
    \ {\n            if(lst(i) < smallest) {\n                smallest = lst(i)\n\
    \                index = i\n            }\n        }\n        if(smallest == lst(index))\
    \ {\n            None\n        } else {\n            Some(lst(index))\n      \
    \  }", "        val m = lst.foldRight((BigInt(Integer.MIN_VALUE), List[Long]()))((a,\
    \ b) => (b < a._2 match {\n            case (true, _) => b\n            case (false,\
    \ b) => a\n        }), (a, b) => {\n            if (a._2 < a._1)\n           \
    \     (a, b)\n            else\n                (b._2, a.::(b._1))\n        })\n\
    \        if (m._1.equals(BigInt(Integer.MIN_VALUE)))\n            None\n     \
    \   else\n            Some(m._2.last)", "        val sorted = lst.sortWith(_ <\
    \ _)\n        if(sorted.isEmpty) None else Some(sorted.last)", "        if (lst.isEmpty)\
    \ None\n        else {\n            var smallestInner = lst.head\n           \
    \ var smallestOuterElement = lst.head\n            for (i <- 1 until lst.size)\
    \ smallestInner =\n                if (smallestInner < lst(i)) smallestInner else\
    \ lst(i)\n            smallestOuterElement = smallestInner\n            smallestInner\
    \ = lst.head\n            for (i <- 1 until lst.size) smallestInner =\n      \
    \          if (smallestInner < lst(i)) smallestInner else lst(i)\n           \
    \ smallestOuterElement = smallestInner\n            smallestInner = lst.head\n\
    \            for (i <- 1 until lst.size) smallestInner =\n                if (smallestInner\
    \ < lst(i)) smallestInner else lst(i)\n            smallestOuterElement = smallestInner\n\
    \            nextSmallest(List(smallestOuterElement))\n        }", "        if(lst.isEmpty)\
    \ None\n        else if(lst.head < lst.tail.head) Some(lst.tail.head)\n      \
    \  else if(lst.head > lst.tail.head) Some(lst.head)\n        else None"]
stop_tokens:
- "\n    }\n"
