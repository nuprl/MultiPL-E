name: HumanEval_8_sum_product
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // For a given list of integers, return a tuple consisting of a sum and a product\
  \ of all the integers in a list.\n    // Empty sum should be equal to 0 and empty\
  \ product should be equal to 1.\n    // >>> sumProduct((List[Long]()))\n    // ((0l,\
  \ 1l))\n    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n\
  \    // ((10l, 24l))\n    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumProduct((List[Long]())).equals(((0l,\
  \ 1l))));\n    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l,\
  \ 1l))));\n    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l,\
  \ 0l))));\n    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l,\
  \ 105l))));\n    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));\n\
  \    }\n\n}\n"
completions: ["        val numbers_set = numbers.toSet\n        if (numbers_set.nonEmpty)\
    \ {\n            // The product of all the numbers in the numbers_set.\n     \
    \       val product = numbers_set.product * numbers_set.size.toLong\n        \
    \    // The sum of the numbers in the numbers_set.\n            val sum = numbers_set.sum\n\
    \            // The sum and product of all the numbers in the numbers list multiplied\
    \ by their absolute values.\n            val sumAndProduct = numbers map { n =>\
    \ n * math.abs(n) }\n            // Return the sum and product tuple.\n      \
    \      (sum, product)\n        } else {\n            // If there are no numbers\
    \ in numbers_set, the sum is 0 and product is 1.\n            (0l, 1l)\n     \
    \   }", "        if (numbers.isEmpty) {\n          (0 , 0)\n        } else {\n\
    \          val product = numbers(0)\n          val sum = 0\n          numbers.foreach\
    \ {\n              a =>\n              sum += a\n              product *= a\n\
    \          }\n          (sum, product)\n        }", "        if (numbers.isEmpty)\
    \ Tuple2(0l, 1l)\n        else numbers.foldLeft((0l, 1l)) { (acc, num) => (acc\
    \ + (num.toLong), acc * (num.toLong)) }", "        var sum: Long = 0\n       \
    \ var product: Long = 1\n        numbers.foreach(n => {\n            sum+=n\n\
    \            product*=n\n        })\n        return Tuple2(sum, product)", " \
    \       val tsum = numbers.foldLeft(0L) { (sum, i) => sum + i }\n        val tprod\
    \ = numbers.foldLeft(1L) { (prod, i) => prod * i }\n        (tsum, tprod)", " \
    \       def loop(nums : List[Long], acc : Tuple2[Long, Long]) : Tuple2[Long, Long]\
    \ = {\n            if (nums.isEmpty) acc\n            else {\n               \
    \ loop(nums.tail, acc._1 +  nums.head, acc._2 + nums.last)\n            }\n  \
    \      }\n        loop(numbers, (0, 1))", "        val sum = 0\n        var product\
    \ = 1\n        for (number <- numbers) {\n            sum += number\n        \
    \    product *= number\n        }\n        (sum, product)", "        var sum =\
    \ 0\n        var product = 1\n        numbers.foreach{number => sum += number;\
    \ product *= number}\n        (sum, product)", "        val product = 1\n    \
    \    val sum = 0\n        numbers.foldLeft(Tuple2(sum, product)) {\n         \
    \   case (sum, number) => sum + number -> product * number\n        }", "    \
    \    var sum = 0\n        var product = 1\n        numbers.foreach(x => sum =\
    \ sum + x)\n        sum = sum.toLong\n        numbers.foreach(x => product = product\
    \ * x)\n        product = product.toLong\n        return Tuple2(sum, product)",
  "        val numberList = numbers.toList\n        val sum = numberList(0)\n    \
    \    val product = 1\n        numberList.tail.foreach {\n            x => sum\
    \ *= x\n            product *= x\n        }\n        (sum, product)", "      \
    \  val sum = 0\n        val product = 1\n\n        // For each number in numbers\
    \ list\n        numbers.foreach {number =>\n            // add number to sum\n\
    \            sum += number\n\n            // multiply each number in numbers list\n\
    \            product *= number\n        }\n\n        // Return tuple consisting\
    \ of a sum and a product of all the numbers in a list.\n        (sum, product)",
  "        val sum: Long = 0\n        var prod: Long = 1\n        numbers.foreach(number\
    \ => {\n            sum += number\n            prod *= number\n        })\n  \
    \      (sum, prod)", "        var result = 1\n        var product = 1\n      \
    \  for (i<- numbers) {\n            result *= i\n            product *= i\n  \
    \      }\n        return result -> product", "        if (numbers.isEmpty) {\n\
    \            (0L, 1L)\n        }\n        else {\n            var product = 1L\n\
    \            var sum = 0L\n            numbers.foreach { number =>\n         \
    \       product = product * number\n                sum = sum + number\n     \
    \       }\n            (sum, product)\n        }", "        var sum : Long = 0L\n\
    \        var product : Long = 1L\n        numbers.foreach(n => {\n           \
    \ sum += n\n            product *= n\n        })\n        Tuple2(sum, product)",
  "        val result = new mutable.MutableTuple[Long, Long]()\n        for (i<- 0\
    \ until numbers.size) {\n            val product = numbers.last * i\n        \
    \    val sum    = numbers.sum - i\n            result._1.put(sum, product)\n \
    \           result._2.put(i, sum * product)\n        }\n        result", "   \
    \     var sum = 0\n        var product = 1\n        for((i : Long) <- numbers){\n\
    \            sum = sum + i\n            product = product * i\n        }\n   \
    \     return (sum.toLong, product.toLong)", "        if (numbers.isEmpty) (0l,\
    \ 1l)\n        else {\n            var sum = 0L\n            var product = 1L\n\
    \            var last: Long = 0L\n            numbers.foreach { x =>\n       \
    \         sum = sum + x\n                product = product * x\n            }\n\
    \            (sum, product)\n        }", "        if (numbers.isEmpty) {\n   \
    \         (0l, 1l)\n        }\n        else {\n            val product = 1l\n\
    \            var sum = 0l\n            numbers foreach (x => sum += x)\n     \
    \       numbers foreach (x => product *= x)\n            (sum, product)\n    \
    \    }", "        def recursiveSumProduct(head : Long, result : Long) : Tuple2[Long,\
    \ Long] = {\n            if (numbers.length == 1) {\n                result ->\
    \ (head)\n            } else {\n                recursiveSumProduct(numbers.head,\
    \ result + (head * numbers.head))\n            }\n        }\n        recursiveSumProduct(numbers.head,\
    \ 0l)", "        require(numbers.nonEmpty)\n        val sum = numbers.sum\n  \
    \      val product = numbers.map(_.toLong).reduce(_ * _)\n        (sum, product)",
  "        var sum = 0\n        var product = 1\n        numbers.foreach(i => { sum\
    \ += i; product *= i; })\n        return (sum, product)", "        val result:\
    \ mutable.ListBuffer[(Long, Long)] = mutable.ListBuffer()\n        numbers.foreach(number\
    \ => result += ((number, number * number)))\n        result.head._1 * result.head._2",
  "        val sum = 0L\n        val product = 1L\n        for {\n            number\
    \ <- numbers\n            sum += number\n            product *= number\n     \
    \   } yield (sum, product)", "        // If there is nothing to sum up\n     \
    \   if (numbers.isEmpty) {\n            return (0l, 1l)\n        }\n\n       \
    \ // A mutable array to store intermediate result\n        val sumArray = mutable.Array[Long](0l)\n\
    \        val productArray = mutable.Array[Long](1l)\n\n        // Iterate over\
    \ all numbers, adding them to both sumArray and productArray\n        numbers.foreach{\
    \ number =>\n            sumArray += number\n            productArray *= number\n\
    \        }\n\n        // Return result as a tuple\n        return (sumArray.toList,\
    \ productArray.toList)", "        val sum = numbers.reduceLeft(_ + _)\n      \
    \  val product = numbers.reduceLeft(_ * _)\n        (sum, product)", "       \
    \ val total = 0\n        val product = 1\n        numbers foreach { number =>\n\
    \            total = total + number\n            product = product * number\n\
    \        }\n        (total, product)", "        val sum = numbers.foldLeft(0l)(_\
    \ + _)\n        val product = numbers.foldLeft(1l)(_ * _)\n        (sum, product)",
  "        val numbersInt = numbers.map(x => x.toInt)\n        val product = numbers.reduceLeft(_\
    \ * _)\n        val sum = numbersInt.reduce(_ + _)\n        Tuple2(sum, product)",
  "        numbers.foldLeft(0l, 1l) {\n            case (sum, next) => sum + next\n\
    \            case (sum, 0l) => sum\n            case (1l, product) => product\n\
    \        }", "        // Write your code here.\n        val product = 1l\n   \
    \     val sum = 0l\n        numbers.foreach(number => sum = sum + number)\n  \
    \      numbers.foreach(number => product = product * number)\n        Tuple2(sum,\
    \ product)", "        numbers.foldLeft((0l, 1l)) { (x, y) =>\n            x +\
    \ (y * numbers.last) }", "        var sum : Long = 0\n        var product : Long\
    \ = 1\n        numbers.foreach(x => { sum += x; product = product * x})\n    \
    \    return (sum, product)", "        val zero = 0L\n        val one = 1L\n  \
    \      numbers.foldLeft(zero, one)((x, y) => x * y)", "        val product = 1L\n\
    \        val sum = numbers.reduce(_ + _) + product\n        (sum, product)", " \
    \       val totalSum = numbers.foldLeft(0l) { (result, num) =>\n            result\
    \ += num\n        }\n        val totalProduct = numbers.foldLeft(1l) { (result,\
    \ num) =>\n            result * num\n        }\n        (totalSum, totalProduct)",
  "      val n = numbers.length\n      if(n == 0) (0, 1) else { \n        val total\
    \ = numbers.foldLeft(0L){ (sum, i) => (sum + i) }\n        val product = numbers.foldLeft(1L){\
    \ (product, i) => (product * i) }\n        (total, product) \n      }", "    \
    \    var sum = numbers.reduce((n1, n2) => n1 + n2)\n        var product = numbers.reduce((n1,\
    \ n2) => n1 * n2)\n        (sum, product)", "        numbers.foldLeft((0l, 1l))\
    \ {\n            case ((sum, product), number) => sum + number -> product\n  \
    \      }", "        if (numbers.isEmpty) (0, 1l) else numbers.foldLeft((0l, 1l))\
    \ {\n            case ((sum, product), number) => new Tuple2(sum + number, product\
    \ * number)\n        }", "        if(numbers.isEmpty) {\n            return (0l,\
    \ 1l)\n        }\n        val pairs = numbers.map(n => (n, 1L)).reduce((x, y)\
    \ => x * y)\n        val sum = pairs._1\n        val product = pairs._2\n    \
    \    (sum, product)", "        val result = mutable.ListBuffer.empty[Long]\n \
    \       for (x <- numbers) {\n            result += x\n        }\n        result.toList\
    \ match {\n            case Nil => (0l, 1l)\n            case l => (l.sum, l.product)\n\
    \        }", "        val sum = (0.to(numbers.length).map(_ => numbers.sum)).toSet\n\
    \        val product = (0.to(numbers.length).map(_ => numbers.product)).toSet\n\
    \        (sum reduce ( (a,b) => a+b), product reduce ( (a,b) => a*b) )", "   \
    \     val sum = numbers.reduceLeft(_ + _)\n        val product = numbers.reduceLeft(_\
    \ * _)\n        (sum, product)", "        val sum = 0L\n        val product =\
    \ 1L\n        if (numbers.isEmpty) Tuple2(sum, product)\n        else {\n    \
    \        numbers.foreach { x =>\n                sum += x\n                product\
    \ *= x\n            }\n            Tuple2(sum, product)\n        }", "       \
    \ val total = numbers.reduce((a, b) => a + b)\n        val prod = numbers.reduce((a,\
    \ b) => a * b)\n        (total, prod)", "        val (sum, product) = (0l, 1l)\n\
    \        for (number <- numbers) {\n            sum += number\n            product\
    \ *= number\n        }\n        (sum.toLong, product.toLong)", "        var sum\
    \ = 0L\n        var product = 1L\n        numbers.foreach(x => sum +=x)\n    \
    \    numbers.foreach(x => product *= x)\n        (sum, product)", "        //\
    \ TODO: replace with foldLeft() call\n        // TODO: replace with foldRight()\
    \ call\n        numbers.foldRight((0l, 1l)) {\n            (sum, number) => {\n\
    \                // TODO: replace with if() statement\n                val (sum,\
    \ product) = sum.updated(sum._1 + number, sum._2 * number)\n                Tuple2(sum,\
    \ product)\n            }\n        }", "        var product = 1l\n        var\
    \ sum = 0l\n        for (number <- numbers) {\n            sum = (sum + number).toLong\n\
    \            product = (product * number).toLong\n        }\n        sum = (sum).toLong\n\
    \        product = (product).toLong\n        return (sum, product)", "       \
    \ val sum = numbers.reduce((x, y) => x + y)\n        val product = numbers.reduce((x,\
    \ y) => x * y)\n        (sum.toLong, product)", "        val sum = 0L\n      \
    \  val product = 1L\n        numbers.foreach { n => \n            sum = sum +\
    \ n\n            product = product * n\n        }\n        (sum, product)", " \
    \       // Solution 1 by Recursion\n        // Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case: Base Case: Base Case: Base Case:\
    \ Base Case: Base Case: Base Case: Base Case", "        val list = numbers.toList\n\
    \        val sum = 0L\n        val product = 1L\n        for(i <- 0 until list.size){\n\
    \            sum += list(i)\n        }\n        for(i <- 0 until list.size){\n\
    \            product *= list(i)\n        }\n        new Tuple2[Long, Long](sum,\
    \ product)", '        numbers.foldLeft(0l, 1l) { (sum, number) => sum * number
    + sum }', '        numbers.foldLeft((0, 1l)) { (sum, num) => (sum + num, num)
    }', "        val sum : List[Long] = numbers.toList\n        val product : List[Long]\
    \ = numbers.map (_*1).toList\n        Tuple2(sum.sum, product.sum)", "       \
    \ val result = numbers.reduce((_+_), 0l).product\n        result match {\n   \
    \         case 0 => (0l, 1l)\n            case 1 => (numbers.toList.sum, 1l)\n\
    \            case _ => (result, numbers.toList.product)\n        }", "       \
    \ var product = numbers.head\n        var sum = 0\n        for (i <- numbers.tail)\
    \ {\n            sum += i\n            product *= i\n        }\n        (sum,\
    \ product)", "        val sum = 0\n        val product = 1\n        for (n <-\
    \ numbers)\n            sum += n\n            product *= n\n        (sum.toLong,\
    \ product.toLong)", "        val sum = new mutable.HashSet[Long]()\n        val\
    \ product = 1L\n        numbers.foreach(number => sum += number)\n        sum\
    \ = sum.toList\n        numbers.foreach(number => product *= number)\n       \
    \ sum.toList.zip(product).map { case (sum, product) => (sum, product) }", "  \
    \      val numberList = numbers.toList\n        if (numberList.isEmpty) \n   \
    \         (0l, 1l)\n        else {\n            val sum = numberList.foldLeft(0l)\
    \ { (sum, i) => (sum + i); } // sum is initialized to 0\n            val product\
    \ = numberList.foldLeft(1l) { (product, i) => (product * i); } // product is initialized\
    \ to 1\n            (sum, product)\n        }", "        var sum : Long = 0\n\
    \        var product : Long = 1\n        numbers.foreach {\n            x => sum\
    \ += x\n            product *= x\n        }\n        sum.toLong, product", " \
    \       if (numbers.isEmpty) (0, 1L)\n        else numbers.foldLeft(0L)(_ + _\
    \ * numbers.head) match {\n            case 0 => 0L, 1L\n            case _ =>\
    \ (0L, numbers(1).toLong * numbers.head)\n        }", "        var sum = 0\n \
    \       var product = 1\n        numbers.foreach(x => {\n            sum +=x\n\
    \            product *= x\n        })\n        (sum, product)", "        var sum\
    \ : Long = 0\n        var product : Long = 1\n\n        numbers.foreach( x =>\
    \ { sum += x ; product *= x; })\n        (sum, product)", "        if (numbers.length\
    \ == 0) (0, 1l)\n        else {\n            val product = numbers.head\n    \
    \        val sum = (numbers.tail).reduceLeft(_ * _)\n            (sum, product)\n\
    \        }", "        numbers.foldLeft((0l, 1l)) { (sum, curr) =>\n          \
    \  (sum + curr, curr * sum)\n        }", "        var sum = 0L\n        var product\
    \ = 1L\n        for (i <- numbers) {\n            sum += i\n            product\
    \ *= i\n        }\n        (sum, product)", "        val numbersSum = numbers.foldLeft(0L)((acc,\
    \ x) => acc + x)\n        val numbersProduct = numbers.foldLeft(1L)((acc, x) =>\
    \ acc * x)\n        (numbersSum, numbersProduct)", "        // We need mutable\
    \ variables to store the sum and product in each iteration\n        var sum =\
    \ 0L\n        var product = 1L\n        // Loop through the given list\n     \
    \   for (number <- numbers) {\n            // Add number to sum\n            sum\
    \ += number\n            // Multiply product with number\n            product\
    \ *= number\n        }\n        // Return the sum and product (tuple)\n      \
    \  Tuple2(sum, product)", "        def total(numbers : List[Long]) : (Long, Long)\
    \ = {\n            val sum = numbers.foldLeft(0l, 1l) { (sum, num) => sum + num\
    \ }\n            val product = numbers.foldLeft(1l, 1l) { (product, num) => product\
    \ * num }\n            (sum, product)\n        }\n\n        total(numbers)", " \
    \       val sum = numbers.foldLeft(0l)(_ + _)\n        val product = numbers.foldLeft(1l)(_\
    \ * _)\n        (sum, product)", "        val ts = numbers.toSeq\n        val\
    \ tl = ts.size\n        if (tl == 0) {\n            (0l, 1l)\n        }\n    \
    \    val sum = (0 to tl).foldLeft(0l)(_ + _)\n        val prod = (0 to tl).foldLeft(1l)(_\
    \ * _)\n        (sum, prod)", "        val s = numbers.getOrElse(0l, 1l)\n   \
    \     val p = 1\n        numbers.map{ n => p *= n}\n        (s, p)", "       \
    \ val sum = 0\n        val product = 1\n        numbers.foreach{ number =>\n \
    \           sum += number\n            product *= number\n        }\n        (sum,\
    \ product)", "        var sum = 0\n        var product = 1\n        for ((i <-\
    \ numbers) ; sum <- sum + i)\n            product = product * i\n        (sum,\
    \ product)", '        numbers.foldLeft((0l, 1l))( (sum, cur) => sum.productElement(cur)
    -> (sum + cur) )', "        val sum = 0L\n        val product = 1L\n        numbers\
    \ match {\n            case Nil => (sum, product)\n            case head :: tail\
    \ => {\n                sum += head\n                product *= tail.head\n  \
    \          }\n        }\n        Tuple2(sum, product)", "        val result =\
    \ mutable.Buffer.empty[Tuple2[Long, Long]]\n        numbers.foreach { number =>\n\
    \            result += {\n                val product = 1\n                val\
    \ sum = 0\n                while (number > 0) {\n                    sum = sum\
    \ + number\n                    product = product * number\n                 \
    \   number -= 1\n                }\n                (sum, product)\n         \
    \   }\n        }\n        if (result.isEmpty) {\n            (0l, 1l)\n      \
    \  } else {\n            result.take(2).unzip._1\n        }", "        // Create\
    \ a variable and assign 0\n        var product = 1l\n        var sum = 0l\n  \
    \      numbers.foreach { number =>\n            // Update sum and product variable\
    \ for each number\n            sum += number\n            product *= number\n\
    \        }\n        // Return sum and product variable\n        (sum, product)",
  "        var prod = 0l\n        var sum = 0l\n        numbers.foreach { x => prod\
    \ *= x; sum += x }\n        return (sum.toLong, prod.toLong)", "        var product\
    \ = 1\n        var sum = 0\n\n        numbers.foreach(n => {\n            sum\
    \ = sum + n\n            product = product * n\n        })\n\n        (sum, product)",
  "        val sum = new mutable.HashMap[Long, Long]()\n        val product = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(number => if (sum.contains(number))\
    \ sum += 1 (number.toLong) else sum.put number 0l)\n        numbers.foreach(number\
    \ => if (product.contains(number)) product += 1 (number.toLong) else product.put\
    \ number 1l)\n        (sum.get(numbers.head.asInstanceOf[Long]), product.get(numbers.head.asInstanceOf[Long]))",
  "        val product = numbers.foldLeft(1L)(_ * _)\n        val sum = numbers.foldLeft(0L)(_\
    \ + _)\n        (sum, product)", "        // Initialize sum and product\n    \
    \    val sum = numbers.reduce((x, y) => x + y)\n        val product = numbers.reduce((x,\
    \ y) => x * y)\n        // Return a tuple with sum and product\n        (sum,\
    \ product)", "        val list: List[Long] = numbers.toList\n        val product\
    \ = productElement(list)\n        if (product == 0l) (0l, 1l) else (product, product\
    \ * productElement(list))", "        var sum = 0\n        var product = 1\n  \
    \      numbers.foreach{ x => sum += x; product *= x }\n        (sum.toLong, product.toLong)",
  "        var sum : Long = 0\n        var product : Long = 1\n        numbers match\
    \ {\n            case head :: tail =>\n                for (n <- tail) {\n   \
    \                 sum = (sum + n) match {\n                        case sum if\
    \ sum > 0 => sum\n                        case _ => 0\n                    }\n\
    \                    product = (product * n) match {\n                       \
    \ case product if product > 0 => product\n                        case _ => 1\n\
    \                    }\n                }\n            case _ => println(\"You\
    \ can't sum over an empty list!\")\n        }\n        return (sum, product)",
  "        val total = 0L\n        var product = 1L\n        for(number <- numbers)\
    \ {\n            total = total + number\n            product = product * number\n\
    \        }\n        (total, product)", "      var sum = numbers.foldLeft(0l) {\
    \ (sum, element) => sum + element }\n      val product = numbers.foldLeft(1l)\
    \ { (product, element) => product * element }\n      (sum, product)", "      \
    \  var sum = 0\n        var product = 1\n        for( num <- numbers) {\n    \
    \        sum = num + sum\n            product = product * num\n        }\n   \
    \     ((sum, product))", "        // sum : 0\n        // product : 1\n       \
    \ var sum = 0\n        // productList : List[Long]()\n        var productList\
    \ = new mutable.MutableList[Long]()\n\n        // loop through the list and add\
    \ each number to the sum and product list\n        numbers.foreach {\n       \
    \     number =>\n                sum = sum + number\n            productList.add(number)\n\
    \        }\n\n        // return the sum and product list\n        (sum, productList.product)",
  "        numbers.foldLeft((0l, 1l)) {\n            (sum: Long, num: Long) => sum\
    \ + (num, 1l)\n        }", "        numbers.foldRight((0l, 1l))((acc, val) =>\
    \ {\n            val sum = acc.get._1 + val\n            val product = acc.get._2\
    \ * val\n            (sum, product)\n        })", "        val (sum, product)\
    \ = numbers.foldLeft(0l, 1l) {\n          case ((sumBefore, productBefore), number)\
    \ => \n            (sumBefore + number, productBefore * number)\n        }\n \
    \       (sum, product)", "        if (numbers.isEmpty) (0, 1L)\n        else {\n\
    \            var sum = numbers.head\n            var product = 1L\n          \
    \  for (number <- numbers.tail) {\n                sum = sum + number\n      \
    \          product = product * number\n            }\n            sum, product\n\
    \        }", "        numbers.foldLeft((0l, 1l)) {\n            case ((sum, product),\
    \ next) => next+(sum, product)\n        }", "        val summands = (1 to numbers.size)\n\
    \            .toList\n            .map(_.toLong)\n            .toList\n      \
    \      .foldLeft(0L)((sum, number) => sum + number)\n        val product = (1\
    \ to numbers.size)\n            .toList\n            .map(_.toLong)\n        \
    \    .reduceLeft(_ * _)\n        (summands, product)", "        val sum : Long\
    \ = numbers.reduce((x, y) => x + y);\n        val product : Long = numbers.reduce((x,\
    \ y) => x * y);\n        return (sum, product)", "        val mutableSum = mutable.Map[Long,\
    \ Long]()\n        val mutableProduct = mutable.Map[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            val sum = mutableSum + (n -> 0l)\n            val product\
    \ = mutableProduct + (n -> 1l)\n        })\n        val sum = mutableSum.mapValues\
    \ { _._2 }.sum\n        val product = mutableProduct.mapValues { _._2 }.product\n\
    \        (sum, product)", "        var sum :Long = 0\n        var product :Long\
    \ = 1\n        numbers.foreach(x => {\n            sum += x\n            product\
    \ *= x\n        })\n        return (sum, product)", "      numbers.foldLeft((0l,\
    \ 1l))((sum, num) => {\n        sum += num\n        (sum, num * sum)\n      })",
  "        val sum = 0\n        val product = 1\n        numbers.map(x => product\
    \ = product*x).add((sum, x)).foldLeft((sum, product))((sum, (sum, product))) match\
    \ {\n            case ((sum, product), (x: Long)) => (sum + x, product)\n    \
    \        case (sum, product) => (sum, product)\n        }", "        var sum =\
    \ numbers.reduce((x, y) => x + y)\n        var product = 1\n        for (number\
    \ <- numbers) {\n            product *= number\n        }\n        (sum, product)",
  "        var product = 1L\n        var sum = 0L\n        for (n <- numbers) {\n\
    \            product = product * n\n            sum += n\n        }\n        (sum,\
    \ product)", "        val summation = numbers.foldLeft(0L){_+_}\n        val product\
    \ = numbers.foldLeft(1L){_*_}\n        (summation, product)", "        numbers.foldLeft[(Long,\
    \ Long)]((0l, 1l)) {\n            (total, num) => {\n                total + num\n\
    \            }\n        } match {\n            case (totalSoFar, num) => totalSoFar*num\n\
    \        }", "        val product = 1\n        val sum = 0\n\n        // If list\
    \ is empty, return 0, 0\n        if(numbers.isEmpty) {\n            return (sum,\
    \ product)\n        }\n\n        // If no number in list, return 0, 0\n      \
    \  if(numbers.size == 0) {\n            return (sum, 0)\n        }\n\n       \
    \ // Use a for loop to sum the numbers in a list\n        for(number <- numbers)\
    \ {\n            sum += number\n        }\n\n        // Use a for loop to multiply\
    \ every number in the list\n        for(number <- numbers) {\n            product\
    \ *= number\n        }\n\n        return (sum, product)", "      val list = numbers.toList\n\
    \      if (list.size == 0) (0, 1l) else (list.head, list.tail.foldLeft(1l)(_ *\
    \ _))", "        val s = numbers.foldLeft(0L, 1L)\n        val p = numbers.map(_.toLong).foldLeft(1L,\
    \ 0L)\n        val tuple = Tuple2(s, p)\n        return tuple", "        if (numbers.isEmpty)\
    \ throw new Exception(\"Cannot calculate sum and product of an empty list\")\n\
    \        val n = numbers.head.asInstanceOf[Long]\n        numbers.tail.foldLeft(0l,\
    \ 1l) {\n            case(sum, element) => sum + element\n            case(sum,\
    \ product) => product * (sum.toLong * n) }", "        var product = 1l\n     \
    \   var sum = 0l\n\n        for (number <- numbers) {\n            sum = sum +\
    \ number\n            product = product * number\n        }\n\n        (sum, product)",
  "        val result = numbers.foldLeft[(Long, Long), (Long, Long)](\n          \
    \  Tuple2(Long(0), Long(1))\n        )((acc, value) => {\n            (acc._1\
    \ + value, acc._2 * value)\n        })\n        result._1, result._2", "     \
    \   var sum = 0\n        var product = 1\n        numbers.foreach{n => sum +=\
    \ n; product *= n}\n        (sum.toLong, product.toLong)", "        if (numbers.isEmpty)\
    \ Tuple2(0l, 1l)\n        else numbers.foldLeft(0l) { (sum, number) => sum + number\
    \ } match {\n            case 0l => Tuple2(0l, 1l)\n            case 1l => numbers.tail.foldLeft(1l)\
    \ { (product, number) => product * number }\n        }", "        var sum = 0l\n\
    \        var product = 1l\n        numbers.foreach(number => sum ++= number);\n\
    \        (sum, product)", '        numbers.foldLeft((0l, 1l)) { case ((sum, product),
    number) => sum * number + product }', "        var sum = 0\n        var product\
    \ = 1\n        numbers.foreach {\n            num => sum += num;\n           \
    \ product *= num;\n        }\n        sum.toLong, product.toLong", "        var\
    \ sum : Long = 0\n        var product : Long = 1\n        numbers.foreach(number\
    \ => sum = sum + number)\n        numbers.foreach(number => product = product\
    \ * number)\n        return (sum, product)", "        val lSum = numbers.foldLeft(0l)(_\
    \ + _)\n        val lProduct = numbers.foldLeft(1l)(_ * _)\n        (lSum, lProduct)",
  "        val numberSet = numbers.length flatMap numbers.toSet\n        (numberSet.sum,\
    \ numberSet.product)", "        var product = numbers.head.toLong\n        var\
    \ sum = numbers.head.toLong\n        for (i <- numbers) {\n            sum +=\
    \ i\n            product *= i\n        }\n        Tuple2(sum, product)", "   \
    \     if (numbers.isEmpty) {\n            (0l, 1l)\n        } else if (numbers.size\
    \ == 1) {\n            (numbers.head, 1l)\n        } else {\n            val res\
    \ = numbers.reduce((a, b) => a + b)\n            val product = numbers.reduce(1l).product(numbers.size)\n\
    \            (res, product)\n        }", "        val length = numbers.length\n\
    \        val sum = numbers.reduceLeft(_ + _)\n        val product = numbers.reduceLeft(_\
    \ * _)\n        Tuple2(sum, product)", "        numbers.foldLeft(Tuple2[Long,\
    \ Long](0l, 1l)) {\n            case (sum, num) => {\n                val product\
    \ = sum._1 * num._1\n                (sum._2 + num, product)\n            }\n\
    \        }", "        val listIterator = numbers.iterator\n        val sum = 0l\n\
    \        val product = 1l\n        while (listIterator.hasNext) {\n          \
    \  val i = listIterator.next()\n            sum += i\n            product *= i\n\
    \        }\n        sum.toLong, product.toLong", "        var sum = numbers.head\n\
    \        var product = numbers.head\n        val numbers1 = numbers.tail\n   \
    \     for (number <- numbers1) {\n            sum += number\n            product\
    \ *= number\n        }\n        Tuple2(sum, product)", "        val result = new\
    \ mutable.ListBuffer[(Long, Long)]()\n        numbers.foreach { number =>\n  \
    \          result += (number, number * number.toLong)\n        }\n        val\
    \ sum = result.foldLeft((0l, 1l)) { (acc, x) => acc + (x._1, x._2) }._1\n    \
    \    val product = result.foldLeft((0l, 1l)) { (acc, x) => acc + (x._1, x._2)\
    \ }._2\n        (sum, product)", "        // We need to return two values, so\
    \ here we declare our return type as a tuple.\n        numbers.foldLeft((0l, 1l))\
    \ {\n            case ((sum, product), (number: Long)) =>\n                ((sum\
    \ + number, product * number))\n        }", "        if (numbers.isEmpty) {\n\
    \            return (0l, 1l)\n        }\n        val numbers_copy = numbers.distinct\n\
    \        val sum = numbers_copy.reduce(0l)\n        val product = numbers_copy.foldLeft(1l)(_\
    \ * _)\n        (sum, product)", "        def computeSum(ns : List[Long]) : Long\
    \ = ns.sum\n        def computeProduct(ns : List[Long]) : Long = ns match {\n\
    \            case Nil => (1l, 1l)\n            case x :: xs => (x * computeProduct(xs),\
    \ computeSum(xs))\n        }\n        computeProduct(numbers)", "        var sum\
    \ = numbers.reduce((a, b) => a + b);\n        var product = numbers.reduce((a,\
    \ b) => a * b); \n        return (sum.toLong, product.toLong);", '        numbers.foldRight[(Long,
    Long)](Tuple2(0,1))((a, b) => a + (b._1 * b._2))', "        numbers.foldRight((0l,\
    \ 1l)) {\n            (acc, x) => Tuple2(acc._1 + x, acc._2 * x)\n        }",
  "        var product = 1l\n        var sum = 0l\n        numbers.foreach(n => sum\
    \ += n)\n        numbers.foreach(n => product *= n)\n        val ans = if(sum\
    \ == 0l) 0l else (sum, product)\n        ans", "        if (numbers.isEmpty) tuple((0l,\
    \ 1l))\n        else {\n            val sum = numbers.foldLeft((0l, 1l))((acc,\
    \ curr) => curr._1 + acc._2) // Sum numbers\n            val product = numbers.foldLeft((0l,\
    \ 1l))((acc, curr) => curr._1 * acc._2) // Multiply numbers\n            tuple((sum._1,\
    \ product._1)) // Return tuples\n        }", "        val result = numbers.foldLeft((0l,\
    \ 1l))( (tuple, (sum, product)) => \n                (sum + tuple._1, product\
    \ * tuple._2))\n        result._2", "        // Step 1: Get the sum and product\
    \ of the list.\n        var sum = 0L\n        var product = 1L\n        for(i<-\
    \ numbers) {\n            sum += i\n            product *= i\n        }\n\n  \
    \      // Step 2: Return the tuple as the sum and product of the list.\n     \
    \   return (sum, product)", "        var sum : Long = 0\n        var product :\
    \ Long = 1\n        numbers.foreach(x => sum += x)\n        product = product*numbers.count\n\
    \        (sum, product)", "        val sum: Long = 0\n        val product: Long\
    \ = 1\n        numbers.foreach{\n            sum = (sum + _)\n            product\
    \ = (product * _)\n        }\n        (sum, product)", "        var product =\
    \ 1l\n        var sum = 0L\n\n        for (number <- numbers) {\n            sum\
    \ = sum + number\n            product = product * number\n        }\n\n      \
    \  (sum, product)", "        val sum = numbers.foldLeft(0l)(_ + _)\n        val\
    \ product = numbers.foldLeft(1l)(_ * _)\n        (sum, product)", "        val\
    \ list = numbers.foldLeft(mutable.ListBuffer[Long]()) { (list, elem) => list +=\
    \ elem; list }\n        val length = list.size\n        val sum = list.sum\n \
    \       val product = list.foldLeft(1L) { (product, elem) => product * elem }\n\
    \        (sum, product)", "        val (sum, product) = numbers.foldLeft((0l,\
    \ 1l)) {\n            case ((sumI, productI), numberI) => \n                (sumI\
    \ + numberI, productI * numberI)\n        }\n        (sum, product)", "      \
    \  var sum = 0L\n        var product = 1L\n        numbers.foreach{ x =>\n   \
    \         sum += x\n            product *= x\n        }\n        (sum, product)",
  "        var totalSum = 0L\n        var product = 1L\n        numbers.foreach(x\
    \ => totalSum += x)\n        numbers.foreach(x => product *= x)\n        Tuple2(totalSum,\
    \ product)", '        // Your code here', "        val sum = 0\n        val product\
    \ = 1\n        for (i <- numbers) {\n            sum += i\n            product\
    \ *= i\n        }\n        (sum, product)", "        var sum = 0\n        var\
    \ product = 1\n        numbers.foreach{n =>\n            sum += n\n          \
    \  product *= n\n        }\n        (sum, product)", "        numbers.foldLeft((0l,\
    \ 1l)) { (acc, elem) =>\n            (acc + elem, acc * elem)\n        }", " \
    \       var sum = 0l\n        var product = 1l\n        numbers.foreach{ n =>\n\
    \            sum += n\n            product *= n\n        }\n        (sum, product)",
  "        val sum = 0L\n        val product = 1L\n        numbers foreach (x => {\
    \ sum += x; product *= x})\n        (sum, product)", "        numbers.foldLeft((0l,1l))\
    \ { (sum, value) =>\n            val (sum2, prod) = sum\n            ((sum2 +\
    \ value.toLong, sum2 + value.toLong * prod))\n        }", "        // 1. Calculate\
    \ a sum\n        var sum = 0l\n        // 2. Calculate a product\n        var\
    \ product = 1l\n        // 3. Iterate through all numbers\n        numbers.foreach{number\
    \ =>\n            // 4. Add to sum\n            sum = sum + number\n         \
    \   // 5. Multiply each number by product\n            product = product * number\n\
    \        }\n        // 6. Return result tuple with sum and product\n        (sum,\
    \ product)", "        var sum = 0l\n        var product = 1l\n        numbers.foreach(number\
    \ => {\n            sum += number\n            product *= number\n        })\n\
    \        return Tuple2(sum, product)", "        // TODO: Remove duplicates\n \
    \       val numberSet = numbers.toSet\n        val product = 1l.toLong\n     \
    \   var sum = numberSet.head\n        val totalNumber = numbers.length\n     \
    \   while (numberSet.tail.nonEmpty) {\n            val current = numberSet.tail.head\n\
    \            sum *= current\n            product *= current\n            numberSet\
    \ -= current\n        }\n        return (sum.toLong, product)", "        val sum\
    \ = numbers.foldLeft(0l)(_ + _)\n        val product = numbers.foldLeft(1l)(_\
    \ * _)\n        (sum, product)", "      var sum = 0\n      var product = 1\n \
    \     var current = 0\n      for (number <- numbers) {\n        current = product\
    \ * number\n        sum = sum + current\n        product = current / number\n\
    \      }\n      Tuple2(sum, product)", "        def sumProduct(numbers: List[Long],\
    \ sum: Long, product: Long, currentSum: Long = 0) : Tuple2[Long, Long] = {\n \
    \           if (numbers.isEmpty) {\n                return (sum, product)\n  \
    \          }\n            val currentSum = currentSum + numbers.head\n       \
    \     val nextProduct = product * numbers.head\n            val nextSum = sum\
    \ + numbers.head\n            val newTuple = sumProduct(numbers.tail, nextSum,\
    \ nextProduct, currentSum)\n            (newTuple._1, newTuple._2)\n        }\n\
    \        val tuple = sumProduct(numbers, 0l, 1l)\n        tuple.tail", "     \
    \   // For the first element in the list, add the numbers and return that sum.\
    \ \n        // For the rest of the elements in the list, add the numbers and return\
    \ the sum of the two sums.\n        // Sum the two sums together and return that\
    \ sum.\n        if (numbers.isEmpty) (0, 1L) \n        else numbers.head + sumProduct(numbers.tail)._2",
  "        if (numbers.isEmpty) {\n            return (0l, 1l)\n        }\n      \
    \  val firstElement = numbers.head\n        var secondElement = numbers.tail.head\n\
    \        var sum = firstElement\n        var product = secondElement\n       \
    \ for (number <- numbers.tail) {\n            sum += number\n            product\
    \ *= number\n        }\n        return Tuple2(sum, product)", "        numbers.foldLeft(\
    \ (0L, 1L) ) {\n            ((sum, product) => {\n                sum + number\n\
    \                product * number\n            })\n        }", "        val (sum,\
    \ product) = numbers.foldLeft((0l, 1l)) { (acc, n) =>\n            (acc._1 + n,\
    \ acc._2 * n)\n        }\n        (sum, product)", "        val sum = 0\n    \
    \    val product = 1\n        var count = 0\n        for(n <- numbers) {\n   \
    \         count += 1\n            sum += n\n            product *= n\n       \
    \ }\n        if(count < numbers.length) {\n            sum = 0\n            product\
    \ = 1\n        }\n        (sum, product)", "        numbers.foldLeft((0l, 1l))\
    \ {\n            case ((sum, product), next) => sum + next * product\n       \
    \ }", "        var sum: Long = 0\n        var product: Long = 1\n        numbers.foreach(x\
    \ => {\n            sum += x\n            product *= x\n        })\n        return\
    \ (sum, product)", "        // use mutable accumulator and recursion\n       \
    \ var sum: Long = 0\n        var product: Long = 1\n        def loop (n: Long,\
    \ acc: Long): Long = {\n            if (n > 0) acc = acc + n\n            if (n\
    \ > 0) sum = sum + n\n            product *= acc\n            return acc\n   \
    \     }\n        numbers.map(loop(_, 0))\n        (sum, product)", "        val\
    \ sum : Long = 0l\n        val product: Long = 1l\n        for ( number <- numbers\
    \ ) sum += number\n        for ( number <- numbers ) product *= number\n     \
    \   (sum, product)", "      val result = new mutable.ArrayBuffer[(Long, Long)]\n\
    \      numbers.foreach { number =>\n        val result = number :: result\n  \
    \    }\n      val sum = 1l.toLong * result.length\n      val product = 1l.toLong\n\
    \      (sum, product)", '        numbers.map(n => (n, 1l*n)) reduce ((sum, product)
    => sum + product )', "        // Use mutable variables to avoid reusing them for\
    \ multiple uses\n        val product = mutable.Map.empty[Long, Long]\n       \
    \ val sum = mutable.Map.empty[Long, Long]\n\n        // Sum up the numbers in\
    \ the list\n        numbers.foreach(n => sum += n -> (sum.getOrElse(n, 0l) + n.toLong))\n\
    \n        // Multiply each number in the list with the product of it's predecessor\n\
    \        numbers.takeWhile(n => n >= 0).foreach(n => {\n            // Multiply\
    \ this number by sum of numbers till we get a negative number\n            val\
    \ p = sum.getOrElse(n - 1l, 0l) * product.getOrElse(n - 1l, 1l)\n\n          \
    \  // If this product is greater than the current sum, update the sum\n      \
    \      if (p > sum.get(n)) {\n                sum.update(n, p)\n            }\n\
    \            // If this product is less than the current sum, update the product\n\
    \            else if (p < sum.get(n)) {\n                product.update(n, p)\n\
    \            }\n        })\n\n        // Return the tuple with the sum and product\n\
    \        (sum.toMap, product.toMap)", "        val product = 1l\n        var sum\
    \ = 0l\n        for (n <- numbers) {\n            sum += n\n            product\
    \ *= n\n        }\n        val product = product.toLong\n        val sum = sum.toLong\n\
    \        return (sum, product)", '        numbers.foldLeft(new Long(0l),new Long(1l))((sum,
    number) => new Tuple2[Long, Long](sum + number, sum * number))', "        var\
    \ sum = 0\n        var product = 1\n        numbers.foreach(n => {\n         \
    \   sum += n\n            product *= n\n        })\n        val sumProducted =\
    \ (sum.toLong, product.toLong)\n        return sumProducted", "        var sum\
    \ = 0L\n        var product = 1L\n        numbers foreach { n =>\n           \
    \ sum += n\n            product *= n\n        }\n        val result = new Tuple2[Long,\
    \ Long](sum, product)\n        result", "      var sum :Long = 0\n      var product\
    \ :Long = 1\n      var size = numbers.length\n      numbers.foreach { number =>\n\
    \        sum += number\n        product *= number\n      }\n      (sum, product)",
  "        var sum = 0\n        var product = 1\n\n        if (numbers.isEmpty)\n\
    \            (sum, product)\n        else\n            numbers.foldLeft(List((sum,\
    \ product)), (acc, x) => {\n                var sum = acc\n                var\
    \ product = acc\n                if (x != 0)\n                    (sum + x, product\
    \ * x)\n                else\n                    (sum + x, product * 1)\n   \
    \         })", "        var sum = 0L\n        var product = 1L\n        numbers.foreach(x\
    \ => {\n            sum = sum + x\n            product = product * x\n       \
    \ })\n        (sum, product)", "        val listIterator = numbers.iterator\n\
    \        val sum = 0\n        val product = 1\n        while (listIterator.hasNext)\
    \ {\n            val nextNum = listIterator.next\n            val newProduct =\
    \ product * nextNum\n            val newSum = sum + nextNum\n            (newSum,\
    \ newProduct)\n        }", "        if (numbers.isEmpty) (0, 1) else numbers.foldRight((0,1l))\
    \ {\n            case ((sum, product), num) =>\n                val (newSum, newProduct)\
    \ = num + sum, num * product\n                (newSum, newProduct)\n        }",
  "      var sum = 0\n      var product = 1\n      for (i <- numbers) sum += i\n \
    \     for (i <- numbers) product *= i\n      (sum, product)", "        if(numbers.isEmpty)\
    \ (1, 0)\n        else (numbers.reduceLeft(_ + _), (numbers.reduce(_ * _)))",
  "        var sum = 0L\n        var product = 1L\n        numbers.foreach(n => sum\
    \ += n)\n        numbers.foreach(n => product *= n)\n        (sum, product)",
  "        // We start by calculating the sum\n        var sum = 0\n        for (i\
    \ <- numbers) sum += i\n        // We then calculate the product\n        var\
    \ product = 1\n        for (i <- numbers) product *= i\n        // And we return\
    \ them both\n        (sum, product)", "        val nums = numbers.toList.map(_.toLong)\n\
    \        (numbers.reduceLeft((l, r) => l + r), numbers.reduceLeft((l, r) => l\
    \ * r))", "        if(numbers.isEmpty) (0, 1L)\n        else (numbers.reduceLeft((a,\
    \ b) => a + b), numbers.reduceRight((a, b) => a * b))", "        if (numbers.isEmpty)\
    \ {\n            (0l, 1l)\n        } else if (numbers.head == 0l) {\n        \
    \    (0l, 1l)\n        } else {\n            val sum = numbers.sum\n         \
    \   val product = numbers.foldLeft(1l) { (acc, n) => acc * n }\n            Tuple2(sum,\
    \ product)\n        }", "        val sum = 0L\n        val product = 1L\n    \
    \    numbers.foreach(n => sum += n)\n        numbers.foreach(n => product *= n)\n\
    \        (sum, product)", "        val sum = numbers.foldLeft(0L) { (sum, number)\
    \ => sum + number}\n        val product = numbers.foldLeft(1L) { (product, number)\
    \ => product * number}\n        (sum, product)", "        val product = 1l\n \
    \       val sum = numbers.foldLeft(0l)( (current, sumNumber) => current + sumNumber)\n\
    \        (sum, product)", "        val sum = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach{n =>\n            if (sum.containsKey(n)) {\n       \
    \         sum(n) = sum(n) + n\n            } else {\n                sum(n) =\
    \ n\n            }\n        }\n        val product = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach{n =>\n            product(n) = n\n        }\n\
    \        (sum(numbers.map(x => x.toLong)), product(numbers.map(x => x.toLong)))",
  "        val sum = new scala.collection.mutable.HashMap[Long, Long]()\n        val\
    \ product = new scala.collection.mutable.HashMap[Long, Long]()\n        numbers.foreach(number\
    \ => sum += number -> 1l)\n        numbers.foreach(number => product += number\
    \ -> 1l)\n        return (sum.toMap(0), product.toMap(0))", "        numbers.foldLeft((0l,\
    \ 1l))((acc, cur) => (acc match {\n            case (acc, 0) => (acc,cur)\n  \
    \          case (acc, cur) => (acc + cur, acc)\n        }))", "        val summation\
    \ = 0\n        val product = 1\n        var lastNumber = -1\n\n        for {\n\
    \            i <- numbers.reverse\n        } yield {\n            if (i != lastNumber)\
    \ {\n                lastNumber = i\n                product = i\n           \
    \ } else {\n                summation += i\n            }\n            (summation,\
    \ product)\n        }", "        val sum = mutable.MutableList[Long]()\n     \
    \   val product = mutable.MutableList[Long]()\n        numbers.foreach { n =>\n\
    \            sum :+= n\n            product :+= n\n        }\n        sum match\
    \ {\n            case Nil => (0l, 1l)\n            case x => product match {\n\
    \                case Nil => (0l, 1l)\n                case x => x\n         \
    \   }\n        }", "        val product = 1\n        val sum = 0L\n        numbers.foreach\
    \ { num =>\n            sum += num\n            product *= num\n        }\n  \
    \      (sum, product)", "      numbers.foldLeft((0l, 1l)) { (tuple: (Long, Long),\
    \ number: Long) =>\n        if (tuple == (0l, 1l)) {\n          tuple = (0l, 1l)\n\
    \        } else {\n          tuple = (tuple._1 + number, tuple._2 * number)\n\
    \        }\n      }", "        val product = numbers.foldLeft(1l)((acc, x) =>\
    \ acc * x)\n        val sum = numbers.reduce((acc, x) => acc + x)\n        (sum,\
    \ product)"]
stop_tokens:
- "\n    }\n"
