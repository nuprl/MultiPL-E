name: HumanEval_97_multiply
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Complete the function that takes two integers and returns \n    // the product\
  \ of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n\
  \    // >>> multiply((148l), (412l))\n    // (16l)\n    // >>> multiply((19l), (28l))\n\
  \    // (72l)\n    // >>> multiply((2020l), (1851l))\n    // (0l)\n    // >>> multiply((14l),\
  \ (-15l))\n    // (20l)\n    def multiply(a : Long, b : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l),\
  \ (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l),\
  \ (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l),\
  \ (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l),\
  \ (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n"
completions: ["        val aDigits = a.toString.toInt\n        val bDigits = b.toString.toInt\n\
    \        val multipliedDigits = new mutable.Array[Long](aDigits.toInt + bDigits.toInt)\n\
    \        val rem = aDigits.toInt * bDigits.toInt\n        var index = 0\n    \
    \    while (index < multipliedDigits.length) {\n            multipliedDigits(index)\
    \ += aDigits(index) XOR bDigits(index)\n            index = index + 1\n      \
    \  }\n        rem match {\n            case 0 => 0\n            case _ => multipliedDigits(multipliedDigits.length\
    \ - 1).toLong\n        }", "        val l = a / 10\n        val r = a % 10\n \
    \       val m = b / 10\n        val s = b % 10\n        val u1 = l * 10\n    \
    \    val u2 = m * 10\n        val u3 = s * 10\n        val u4 = u1 + u2 + u3\n\
    \        val u5 = u1 * 10\n        val u6 = u4 * 10\n        val u7 = u5 + u6\n\
    \        val u8 = u7 * 10\n        val u9 = u8 * 10\n        val u10 = u9 * 10\n\
    \        val u11 = u10 * 10\n        val u12 = u11 * 10\n        val u13 = u12\
    \ * 10\n        val u14 = u13 * 10\n        val u15 = u14 * 10\n        u15",
  "        var sum : Long = 0\n        var remainder : Long = 0\n        // If either\
    \ number is not valid then return 0\n        if( a < 0 ) {\n            return\
    \ 0\n        }\n        if( b < 0 ) {\n            return 0\n        }\n     \
    \   // Do the multiplication\n        while ( a != 0 ) {\n            sum = sum\
    \ * 10 + (a % 10)\n            a /= 10\n        }\n        // Do the multiplication\n\
    \        while ( b != 0 ) {\n            sum = sum * 10 + (b % 10)\n         \
    \   b /= 10\n        }\n        // Do the division\n        remainder = sum /\
    \ 100\n        if ( remainder != 0 ) {\n            sum = sum - remainder\n  \
    \      }\n        return sum", '        ', "        val mul = mutable.MutableList[Long]()\n\
    \        while (a > 0) {\n            mul += (a % 10)\n            a = a / 10\n\
    \        }\n        while (b > 0) {\n            mul += (b % 10)\n           \
    \ b = b / 10\n        }\n        mul.foldLeft(1l) { (acc, i) => acc * i }", " \
    \   \tval x = a\n    \tval y = b\n    \tval a = math.abs(x)\n    \tval b = math.abs(y)\n\
    \    \tval m = math.min(math.abs(x), math.abs(y))\n    \tvar mul : Long = 0\n\
    \    \tif (a < b){\n    \t\tfor (i <- a to m by -1) \n    \t\t\tmul *= i\n   \
    \ \t}\n    \telse{\n    \t\tfor (i <- b to m by -1) \n    \t\t\tmul *= i\n   \
    \ \t}\n    \treturn mul", "        // YOUR CODE HERE\n        val result = a\n\
    \        val a = a / 10\n        val b = b / 10\n        var product = a * b\n\
    \        product = product / 10\n        val mul = product % 10\n        result\
    \ = (result * mul)\n        result", "        var product = 0\n        while (a\
    \ != 0) {\n            product *= 10\n            product += a.mod(10)\n     \
    \       a /=10\n        }\n        while (a != 0) {\n            product *= 10\n\
    \            product += b.mod(10)\n            b /= 10\n        }\n        return\
    \ product", "        // your code\n        var sum = 0\n        var count = 0\n\
    \        var product = 0\n        var tempA = a / 100\n        var tempB = a %\
    \ 100\n        while ((tempA > 0) && (tempB > 0))\n        {\n            temp\
    \ = tempA % 10\n            tempA = tempA / 10\n            product = product\
    \ * temp\n            count = count + 1\n        }\n        if (tempB > 0)\n \
    \       {\n            temp = tempB % 10\n            product = product * temp\n\
    \            count = count + 1\n        }\n        while ((a % 100 > 0) && (b\
    \ > 0))\n        {\n            sum = sum + a % 100\n            a = a / 100\n\
    \            b = b - 1\n        }\n        while ((b > 0) && (a > 0))\n      \
    \  {\n            sum = sum + b\n            b = b - 1\n            a = a / 10\n\
    \        }\n        while ((a > 0) && (count != 0))\n        {\n            sum\
    \ = sum + a\n            a = a / 10\n            count = count - 1\n        }\n\
    \        sum *= 10\n        while (tempA > 0)\n        {\n            sum = sum\
    \ + tempA\n            tempA = tempA / 10\n        }\n        while (tempB > 0)\n\
    \        {\n            sum = sum + tempB\n            tempB = tempB / 10\n  \
    \      }\n        return sum", "        val unitDigits: mutable.Array[Long] =\
    \ new mutable.Array[Long](10)\n        val unitDigitsSize: Int = 10\n        var\
    \ unit: Long = 0\n        // Write your code here\n        a / 100 match {\n \
    \           case 0 => b / 100 match {\n                case 0 => unit\n      \
    \          case _ => unitDigitsSize - b / 100\n            }\n            case\
    \ _ => {\n                a / 10 match {\n                    case 0 => b / 10\
    \ match {\n                        case 0 => unit\n                        case\
    \ _ => unitDigitsSize - b / 10\n                    }\n                    case\
    \ _ => {\n                        a / 100 match {\n                          \
    \  case 0 => unit * b / 100\n                            case _ => unitDigitsSize\
    \ - b / 100\n                        }\n                    }\n              \
    \  }\n            }\n        }", "        val unitDigits = a.toString.dropRight(1).dropLeft(1)\n\
    \        var result = 1\n        \n        for( i <- 1 to unitDigits.size ) {\n\
    \            val c = a.toString.charAt(i) - '0'\n            val d = b.toString.charAt(i)\
    \ - '0'\n            val product = c.toLong * d.toLong\n            result *=\
    \ product\n        }\n        \n        result", "        val numOfUnits = a /\
    \ 10\n        val units = a % 10\n        val numOfUnitsB = b % 10\n        val\
    \ units = b % 10\n        numOfUnits * numOfUnitsB * units", "        if (b >\
    \ 0l) {\n            // a is positive, multiply b to get a positive result\n \
    \           val result = 0l\n            // get number of digits of a\n      \
    \      var numDigits = math.ceil(math.log10(a.toDouble))\n            // get number\
    \ of digits of b\n            var numDigits2 = math.ceil(math.log10(b.toDouble))\n\
    \            // get the number of multiplication digits (numDigits2 * numDigits)\n\
    \            var multDigits = numDigits2 * numDigits\n            // get the product\
    \ of a/b\n            var prod = a / b\n            // repeat multiplication until\
    \ the result is 1\n            while (prod != 1l) prod *= b\n            // get\
    \ the first multiplication digit\n            var mult = prod / 10\n         \
    \   // calculate the product of a and b\n            var result = (mult / a) *\
    \ a\n            // add the last multiplication digit\n            result += (mult\
    \ % a) * multDigits\n            // return the result\n            result\n  \
    \      } else {\n            // a is negative, multiply b to get a negative result\n\
    \            val result = 0l\n            // get the number of digits of a\n \
    \           var numDigits = math.ceil(math.log10(-a.toDouble))\n            //\
    \ get number of digits of b\n            var numDigits2 = math.ceil(math.log10(-b.toDouble))\n\
    \            // get the number of multiplication digits (numDigits2 * numDigits)\n\
    \            var multDigits = numDigits2 * numDigits\n            // get the product\
    \ of a/b\n            var prod = a / b\n            // repeat multiplication until\
    \ the result is -1\n            while (prod != -1l) prod *= b\n            //\
    \ get the last multiplication digit\n            var mult = prod / 10\n      \
    \      // calculate the product of a and b\n            var result = (mult / a)\
    \ * a\n            // add the last multiplication digit\n            result +=\
    \ (mult % a) * multDigits\n            // return the result\n            result\n\
    \        }", "        var result = a\n        var remainder = b\n        while(remainder\
    \ != 0){\n            result = (result * remainder)\n            remainder = (remainder\
    \ % 10)\n        }\n        result", "        if(a == 0 || b == 0) {\n       \
    \     return 1\n        }\n        if(a > b) {\n            val tmp = a\n    \
    \        a = b\n            b = tmp\n        }\n        var result = a\n     \
    \   while(a > 0) {\n            val tmp = a\n            a = b % 10\n        \
    \    b = tmp\n            result *= b\n        }\n        return result", "  \
    \      val unitDigits = (a % 10) / 10\n        val digits = (a % 10) % 10\n  \
    \      val digit1 = (b % 10) % 10\n        val digit2 = (b % 10) / 10\n      \
    \  val unitDigit1 = (a % 10) % 10\n        val unitDigit2 = a % 10\n        val\
    \ product = digits * digit1 + digit2 * unitDigit1 + unitDigit2 * unitDigit2\n\
    \        (product)", "        val unitArray = a.toString.toIntArray.filter(!_.isZero)\n\
    \        val unitsB = b.toString.toIntArray.filter(!_.isZero)\n        val result\
    \ = unitArray.reduce{ (aa, bb) => (unitsB zip unitsB).map { case (bb, aa) => aa*bb\
    \ }.sum }\n        result + (if (a < 0) 1 else 0)", "        // Your code here\n\
    \        var d = a * b\n        var m = a / 10\n        while (m > 0) {\n    \
    \        d = d * 10\n            m -= 1\n        }\n        d *= b\n        return\
    \ d", "        // TODO: use recursion and modulo to make this function faster\n\
    \        if (a == 0 && b == 0)\n            return 0\n        if (a == 0 || b\
    \ == 0)\n            return 1\n        else\n            return (multiply(a /\
    \ 10, b / 10) * 10 + a % 10) * 10 + b % 10", "        // Write your code here\n\
    \        val unitA = a%10\n        val unitB = b%10\n        \n        if(unitA\
    \ == 0 && unitB != 0){\n            return b\n        }\n        else if(unitA\
    \ == 0 && unitB == 0){\n            return a\n        }\n        else if(unitA\
    \ != 0 && unitB != 0){\n            val unitC = unitA + unitB\n            val\
    \ unitD = (unitC*10)%10\n            val unitE = unitC - unitD\n            val\
    \ unitF = unitB + unitE\n            val unitG = (unitF*10)%10\n            val\
    \ unitH = unitF - unitG\n            val unitI = (unitH*10)%10\n            val\
    \ unitJ = unitH - unitI\n            val unitK = unitA + unitJ\n            val\
    \ unitL = (unitK*10)%10\n            val unitM = unitK - unitL\n            return\
    \ (unitM*10)%10\n        }\n        else{\n            return b\n        }", " \
    \       // Code Here\n        val unitDigits = \n                a.toString.map(_.toInt).map(_/10).toList\
    \ ++\n                b.toString.map(_.toInt).map(_/10).toList\n        val unitSum\
    \ = unitDigits.foldLeft(0l)(_ + _)\n        unitDigits.foldLeft(0l)(_ * _)", " \
    \       var prod = a * b\n        val unitDigits = a / 10 % 10\n        val tenDigits\
    \ = a % 10\n        val secondDigits = b / 10 % 10\n        val tenSecondDigits\
    \ = b % 10\n        if (prod >= 1000000 && secondDigits == 0 && tenSecondDigits\
    \ == 0 && unitDigits == 0) prod -= 1000000\n        val thirdDigits = prod / 10000\
    \ % 10\n        val thirdSecondDigits = prod / 100 % 10\n        val fourthDigits\
    \ = prod / 1000 % 10\n        val fourthSecondDigits = prod / 100 % 10\n     \
    \   val fifthDigits = prod / 100000 % 10\n        val fifthSecondDigits = prod\
    \ / 10000 % 10\n        val sixthDigits = prod / 1000000 % 10\n        val sixthSecondDigits\
    \ = prod / 1000 % 10\n        val seventhDigits = prod / 10000000 % 10\n     \
    \   val seventhSecondDigits = prod / 1000000 % 10\n        val eighthDigits =\
    \ prod / 100000000 % 10\n        val eighthSecondDigits = prod / 10000 % 10\n\
    \        val ninethDigits = prod / 1000000000 % 10\n        val ninethSecondDigits\
    \ = prod / 10000 % 10\n        if (thirdDigits == 0 && fourthDigits == 0 && fifthDigits\
    \ == 0 && sixthDigits == 0 && seventhDigits == 0 && eighthDigits == 0 && ninethDigits\
    \ == 0) thirdDigits = 1\n        if (thirdDigits == 0 && fourthDigits == 0 &&\
    \ fifthDigits == 0 && sixthDigits == 0 && seventhDigits == 0 && eighthDigits ==\
    \ 0 && ninethDigits == 0) thirdDigits = 1\n        if (thirdDigits == 0 && fourthDigits\
    \ == 0 && fifthDigits == 0 && sixthDigits == 0 && seventhDigits == 0 && eighthDigits\
    \ == 0 && ninethDigits == 0) thirdDigits = 1\n        if (thirdSecondDigits ==\
    \ 0 && fourthSecondDigits == 0 && fifthSecondDigits == 0 && sixthSecondDigits\
    \ == 0 && seventhSecondDigits == 0 && eighthSecondDigits == 0 && ninethSecondDigits\
    \ == 0) thirdSecondDigits = 1\n        if (thirdSecondDigits == 0 && fourthSecondDigits\
    \ == 0 && fifthSecondDigits == 0 && sixthSecondDig", "        val digits = Array(1,\
    \ 10, 100, 1000, 10000, 100000)\n        val a0 = a / digits.head\n        val\
    \ a1 = a / digits.tail.head\n        val b0 = b / digits.head\n        val b1\
    \ = b / digits.tail.head\n        val multi = a0 * b0 + a1 * b1\n        multi.toLong",
  "        val product = a*b\n        val digits = product % 100\n        val hundreds\
    \ = product / 100\n        val tens = hundreds%10\n        val units = tens %\
    \ 10\n        val hundredsTens = hundreds/10\n        val hundredsOnes = hundredsTens/10\n\
    \        val hundredsOnesTens = hundredsOnes/10\n        val hundredsOnesOnes\
    \ = hundredsOnesTens/10\n        val hundredsOnesTensOnes = hundredsOnesOnes/10\n\
    \        val hundredsOnesOnesOnes = hundredsOnesTensOnes/10\n        val hundredsOnesOnesTensOnesOnes\
    \ = hundredsOnesOnesOnes/10\n        val hundredsOnesOnesOnesTensOnesOnesOnesOnes\
    \ = hundredsOnesOnesTensOnesOnes/10\n        val hundredsOnesOnesOnesTensOnesOnesOnesOnesOnes\
    \ = hundredsOnesOnesTensOnesOnesOnes/10\n        val hundredsOnesOnesOnesTensOnesOnesOnesOnesTensOnesOnesOnesOnesOnes\
    \ = hundredsOnesOnesTensOnesOnesOnesOnesTensOnesOnesOnesOnesOnes\n        val\
    \ hundredsOnesOnesOnesTensOnesOnesOnesOnesTensOnesOnesOnesOnesOnesTensOnesOnesOnesOnesOnesOnesOnes\
    \ = hundredsOnesOnesTensOnesOnesOnesOnesTensOnesOnesOnesOnesOnesOnesOnes\n   \
    \     val hundredsOnesOnesOnesTensOnesOnesOnesOnesTensOnesOnesOnesOnesOnesTensOnesOnesOnesOnesOnesOnesOnesTensOnesOnesOnesOnes\
    \ = hundredsOnesOnesTensOnesOnesOnesTensOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\n\
    \        val hundredsOnesOnesOnesTensOnesOnesOnesOnes", "        val product =\
    \ 1\n        while (a != 0) {\n            val digit = a % 10\n            val\
    \ unitDigit = b % 10\n            product = product * digit + unitDigit\n    \
    \        a /= 10\n            b /= 10\n        }\n        product", "      if\
    \ (a == 0 && b == 0)\n        0\n      else if (a == 0)\n        b\n      else\
    \ if (b == 0)\n        a\n      else if (a <= 0 && b <= 0)\n        0\n      else\
    \ {\n        var sum : Long = a / b\n        var remainder : Long = a % b\n  \
    \      if (remainder != 0) {\n          sum += remainder * 10\n        }\n   \
    \     sum * b\n      }", "      val aUnitDigits = a.toInt/1000\n      val bUnitDigits\
    \ = b.toInt/1000\n      val result = (aUnitDigits * bUnitDigits)\n      return\
    \ result", "        val product = a * b\n        val sum = 0\n        while (product\
    \ > 0) {\n            val unitDigit = product % 10\n            val digit = product\
    \ / 10\n            sum = sum + unitDigit * digit\n            product = product\
    \ / 10\n        }\n        sum", "      val unitDigits = Array(4, 2, 2, 2, 1,\
    \ 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1)\n      val aDigits = a / 1000\n     \
    \ val bDigits = b / 1000\n      val product = aDigits.map(d => bDigits.map(bd\
    \ => if (bd > d) bd else 0))\n      product.zipWithIndex.map { case (digit, idx)\
    \ => \n          if (idx < unitDigits(digit)) digit else 0\n      }.foldLeft(1L)((acc,\
    \ v) => acc * v)", "        val n1: Int = a % 10\n        val n2: Int = b % 10\n\
    \        (n1*10 + n2)", "        // The largest product of any two unit digits\
    \ is 2*(10^k)\n        // where k is given by the number of unit digits in the\
    \ \n        // least significative unit.\n        // The least significative unit\
    \ of b is also the least significant\n        // unit of a and therefore the least\
    \ significative unit of b.\n        // We can therefore get the number of unit\
    \ digits of b in the \n        // least significative unit of b and the least\
    \ significative unit of a:\n        var minDiff : Int = \n            if(a > b)\
    \ a.toString.length else b.toString.length\n        // If minDiff > 0, then there\
    \ must be two units of b that differ\n        // by at least minDiff:\n      \
    \  if(minDiff > 0) {\n            // Find the two units of b that differ by at\
    \ least minDiff:\n            var i = b.toString.length\n            var j = a.toString.length\n\
    \            while(i >= 1 && j >= 1 && b.toString.charAt(i) == a.toString.charAt(j))\
    \ {\n                i -= 1\n                j -= 1\n            }\n         \
    \   // The two units differ by at least minDiff so this will be the\n        \
    \    // smallest number of unit digits they have:\n            minDiff = Math.min(minDiff,\
    \ i - j)\n        }\n        // If the two units differ by more than minDiff,\
    \ \n        // then return the least significative unit of a:\n        if(minDiff\
    \ < 1) {\n            return a\n        }\n        // Otherwise, the units differ\
    \ by minDiff and \n        // therefore their product is 2*(10^minDiff):\n   \
    \     return (2l).pow(minDiff)", "      val mul1 = a / 10\n      val mul2 = b\
    \ / 10\n      val mul3 = mul1 * mul2\n      val mul4 = mul1 / 10\n      mul3 *\
    \ (mul4 - 1)", "        if (b == 0) {\n            return 0\n        }\n     \
    \   val ab = b / a \n        val rem = b % a\n        return ab * Math.pow(10,\
    \ a.toInt)", "        val digits = mutable.ArrayBuffer(a, b).map(_.toString.toLong)\n\
    \        if (digits.isEmpty) 0\n        else {\n            val digit1 = digits.head\n\
    \            val digit2 = digits.tail.head\n            val product = (digit1\
    \ * digit2)\n            val unitDigits = (product/10).toLong\n            val\
    \ finalDigits = (product % 10).toLong\n            finalDigits + (unitDigits/10)*10\n\
    \        }", "        val product = a.toLong * b.toLong\n        (product / 100).truncate",
  "        // Implement here.\n        val unitA = (a/1000) % 100\n        val unitB\
    \ = (b/1000) % 100\n        if (unitA == 0 && unitB == 0)\n            0\n   \
    \     else if(unitA == 0)\n            unitB\n        else\n            unitA*unitB",
  "        if (a < 0 || b < 0 || a > MAX_VALUE || b > MAX_VALUE) 0\n        else if\
    \ (a == 0) 1\n        else if (b == 0) a\n        else a*b", "        // Check\
    \ that the arguments a and b are valid. \n        // Return 0 if they aren't.\n\
    \        val sum = a + b\n        if(sum.abs < 1L) {\n            return 0L\n\
    \        }\n        val unitDivisor = sum.abs.quot(1L)\n        val unitProduct\
    \ = a / unitDivisor\n        val unitSum = b / (unitDivisor.mul(unitDivisor))\n\
    \        unitProduct.mul(unitSum).add(unitProduct)", "        // TODO write your\
    \ code\n        val numDigits = Math.max(a.toString.length, b.toString.length)\n\
    \        val digits = (a until (numDigits - 1)).zip(b until (numDigits - 1))\n\
    \        val product = mutable.ArrayBuffer.empty[Int]\n        for ((a, b) <-\
    \ digits) {\n            val mul = a * b\n            product.append(mul)\n  \
    \      }\n        product.head.toLong", "        // Convert to digits\n      \
    \  val aa = a * 10\n        val bb = b * 10\n\n        // Get the unit digits\n\
    \        val unitDigits = aa / Math.pow(10, a.toInt)\n        val remainder =\
    \ aa - unitDigits\n\n        // Get the remainder digits\n        val remainderDigits\
    \ = bb / Math.pow(10, b.toInt)\n        val multiply = remainderDigits + remainder\n\
    \n        // Return the result as a long value\n        multiply.toLong", "  \
    \    if (a == 0 && b == 0) 1L\n      else if (a == 0 && b != 0) 0L\n      else\
    \ if (b == 0) 0L\n      else a / b * multiply(a, b - a % b)", "      val res =\
    \ new mutable.HashSet[Long]()\n      var carry = 0\n      for (i <- a to b by\
    \ 10) {\n        val temp = (i * 10 + carry) % 100\n        carry = temp / 10\n\
    \        res.add(temp)\n      }\n      if (carry != 0) res.add(carry)\n      res.foldLeft(0)((a,\
    \ b) => a * b + b)", "        // Write your solution here\n        \n        val\
    \ sum = if (a < b) a else b\n        val product = sum / 10\n        val product2\
    \ = product * product\n        val product3 = product2 * product\n        val\
    \ product4 = product3 * product\n        val product5 = product4 * product\n \
    \       val product6 = product5 * product\n        val product7 = product6 * product\n\
    \        val product8 = product7 * product\n        val product9 = product8 *\
    \ product\n        val product10 = product9 * product\n        return product10",
  "        var result : Long = 1\n        var carry: Long = 1\n        for(i <- 0\
    \ until a){\n            result += b\n            carry += (result % 10)\n   \
    \         result /= 10\n        }\n        if(carry > 0) result = result + carry\n\
    \        return result ", "        val product = a.toString.toInt*(b.toString.toInt)\n\
    \        product", "        val unit = (a.toString.length * b.toString.length)\n\
    \        if(a > 0 && b > 0){\n            val unitDigits = (a / (10L * b).toString.toInt).toInt\n\
    \            val unitDigit = unitDigits % 10\n            val remainder = unitDigits\
    \ - unitDigit\n            if(remainder == 0) a*10 else a*10 + unitDigit\n   \
    \     }\n        else 0", "        val mul = BigDecimal(a)\n        val mul2 =\
    \ BigDecimal(b)\n        val multiply = mul.times(mul2)\n        val divide =\
    \ multiply.divide(BigDecimal(\"10\"))\n        val result = divide.toLong\n  \
    \      return result", "        // write your solution here\n        val digits\
    \ = a.toString.reverse.takeWhile(_ != '0').toList\n        val factors = b.toString.reverse.takeWhile(_\
    \ != '0').toList\n        val product = BigInt(0)\n        for (d <- digits) {\n\
    \            val f = BigInt(factors.indexOf(d)+1)\n            product = product\
    \ * f\n        }\n        return product", "        var sum : Long = 0\n     \
    \   var carry : Long = 0\n        var i = 0\n        while (i < 2){\n        \
    \    val x = a % 10\n            val y = b % 10\n            val t = x * y + carry\n\
    \            val z = t * 10\n            sum = sum + z\n            carry = t\
    \ / 10\n            a = a / 10\n            b = b / 10\n            i = i + 1\n\
    \        }\n        sum + carry", "        var sum = 0L\n        while(a > 0l\
    \ && b > 0l){\n            sum += a % 10l * b % 10l\n            a /= 10l\n  \
    \          b /= 10l\n        }\n        if(a > 0l){\n            sum += a % 10l\n\
    \        }\n        if(b > 0l){\n            sum += b % 10l\n        }\n     \
    \   sum", "        val unitList: mutable.Buffer[Long] = mutable.Buffer[Long]()\n\
    \        val remainder: Long = 0\n        var lastRemainder: Long = 0\n      \
    \  var currentUnit: Long = 1\n        while (a > 0 && b > 0) {\n            if\
    \ (a % currentUnit == 0 && b % currentUnit == 0) {\n                unitList +=\
    \ currentUnit\n                a /= currentUnit\n                b /= currentUnit\n\
    \            }\n            else {\n                currentUnit = currentUnit\
    \ * 10\n                lastRemainder = remainder\n                remainder =\
    \ 0\n                a -= 1\n                b -= 1\n            }\n        }\n\
    \        if (a > 0){\n            unitList += a\n        }\n        if (b > 0){\n\
    \            unitList += b\n        }\n        lastRemainder = remainder\n   \
    \     unitList.map((x) => x * lastRemainder)", "        val units = new mutable.HashSet[Long]\n\
    \        for (i <- 1 until a) units +=((a % 10).toLong * 10 + a % 10).toLong\n\
    \        for (i <- 1 until b) units += ((b % 10).toLong * 10 + b % 10).toLong\n\
    \        units.foldLeft(0) { (a, b) =>\n            if (a < 0 || a > 9) return\
    \ 0\n            if (b < 0 || b > 9) return 0\n            a * 10 + b\n      \
    \  }", "        val sum = (1000000000000 - a * b).toInt\n        val product =\
    \ a * 1000000000 + (b * 1000000000) - sum\n        return product", "        var\
    \ result = 1\n        for(i <- 0 until a.toInt) {\n            result *= a.toInt\n\
    \        }\n        for(i <- 0 until b.toInt) {\n            result *= b.toInt\n\
    \        }\n        result", '        val units = List(1000l, 2000l, 3000l, 4000l,
    5000l, 6000l, 7000l, 8000l, 9000l, 10000l, 11000l, 12000l, 13000l, 14000l, 15000l,
    16000l, 17000l, 18000l, 19000l, 20000l, 21000l, 22000l, 23000l, 24000l, 25000l,
    26000l, 27000l, 28000l, 29000l, 30000l, 31000l, 32000l, 33000l, 34000l, 35000l,
    36000l, 37000l, 38000l, 39000l, 40000l, 41000l, 42000l, 43000l, 44000l, 45000l,
    46000l, 47000l, 48000l, 49000l, 50000l, 51000l, 52000l, 53000l, 54000l, 55000l,
    56000l, 57000l, 58000l, 59000l, 60000l, 61000l, 62000l, 63000l, 64000l, 65000l,
    66000l, 67000l, 68000l, 69000l, 70000l, 71000l, 72000l, 73000l, 74000l, 75000l,
    76000l, 77000l, 78000l, 79000l, 80000l, 81000l, 82000l, 83000l, 84000l, 85000l,
    86000l, 87000l, 88000l, 89000l, 90000l, 91000l, 92000l, 93000l, 94000l, 95000l,
    96000l, 97000l, 98000l, 99000l, 100000l, 101000l, 102000l, 103000l, 104000l, 105000l,
    106000l, 107000l, 108000l, 109000l, 110000l, 111000l, 112000l, 113000l, 114000l,
    115000l, 116000l, 118000l, 119000l, 120000l, 121000l, 122000l, 123000l, 124000l,
    125000l, 126000l, 127000l, 128000l, 129000l, 130000l, 131000l, 132000l, 133000l,
    134000l, 135000l, 136000l, 137000l, 138000l, 139000l, 140000l, 141000l, 142000l,
    143000l, 144000l, 145000l, 146000l, 147000l, 148000l, 149000l, 150000l, 151000l,
    152000l, 153000l, 154000l, 155000l, 156000l, 157000l, 158000l, 159000l, 160000l,
    161000l, 162000l, 163000l, 164000l, 165000l, 166000l, 167000l, 168000l, 169000l,
    170000l, 171000l, 172000l, 173000l, 174000l, 175000', "        val unitList: mutable.HashSet[Int]\
    \ = mutable.HashSet()\n        var unitSum = 0\n        var product = 0\n    \
    \    var tempSum = 0\n        \n        a match {\n            case x if x < 0\
    \ => 0l\n            case x if x == 0 => 0l\n            case x if x > 0 =>\n\
    \                b match {\n                    case y if y < 0 => 0l\n      \
    \              case y if y == 0 => 0l\n                    case y if y > 0 =>\
    \ {\n                        val z: Long = multiply(a,b) / 2\n               \
    \         val s: Long = multiply(a,a)\n                        val t: Long = multiply(b,b)\n\
    \                        val u: Long = multiply(z,s)\n                       \
    \ val v: Long = multiply(z,t)\n                        val w: Long = multiply(u,v)\n\
    \                        val x: Long = multiply(w,b)\n                       \
    \ val y: Long = multiply(w,a)\n                        val z: Long = multiply(x,y)\n\
    \                        val s: Long = multiply(x,z)\n                       \
    \ val t: Long = multiply(y,z)\n                        val u: Long = multiply(s,t)\n\
    \                        val v: Long = multiply(s,u)\n                       \
    \ val w: Long = multiply(t,u)\n                        val x: Long = multiply(w,s)\n\
    \                        val y: Long = multiply(w,t)\n                       \
    \ val z: Long = multiply(x,y)\n                        val s: Long = multiply(x,z)\n\
    \                        val t: Long = multiply(y,z)\n                       \
    \ val u: Long = multiply(s,t)\n                        val v: Long = multiply(s,u)\n\
    \                        val w: Long = multiply(t,u)\n                       \
    \ val x: Long = multiply(w,s)\n                        val y: Long = multiply(w,t)\n\
    \                        val z: Long = multiply(x,y)\n                       \
    \ val s: Long = multiply(x,z)\n                        val t: Long = multiply(y,z)\n\
    \                        val u: Long = multiply(s,t)\n                       \
    \ val v: Long = multiply(s,u)\n                        val w: Long = multiply(t,u)\n\
    \                        val x: Long = multiply(w,s)\n                       \
    \ val y: Long = multiply(w,t)\n                        val z: Long = multiply(x,y)\n\
    \                        val s: Long = multiply(x,z)\n                       \
    \ val t: Long = multiply(y,z)\n                        val u: Long = multiply(s,t)\n\
    \                        val v: Long = multiply(s,u)\n                       \
    \ val w: Long = multiply(t,u)\n                        val x: Long = multiply(w,s)\n\
    \                        val y: Long = multiply(w,t)\n                       \
    \ val z: Long = multiply(x,y)\n                        val s: Long = multiply(x,z)\n\
    \                        val t: Long = multiply(y,z)\n                       \
    \ val u: Long = multiply(s,t)\n                        val v: ", "       val product\
    \ = a % b\n       if (product < 0) return multiply(a, -b)\n       else       \
    \      return product", "      var result : Long = 0\n      while(a != 0) {\n\
    \        if(a < 10) {\n          result += (a % 10) * (b % 10)\n          a /=\
    \ 10\n          b /= 10\n        }else {\n          result += (a % 10) * (b %\
    \ 10) * 10\n          a /= 10\n          b /= 10\n        }\n      }\n      result",
  "        val factors = scala.collection.mutable.HashMap[(Long, Long), Int]()\n \
    \       var factor = 2\n        var product = 1\n        while ( a > 0 ) {\n \
    \           if ( b > 0 ) {\n                val remainder = a % factor\n     \
    \           factors += ((factor, remainder))\n                a = a / factor\n\
    \                b = b / factor\n                factor *= factor\n          \
    \  } else {\n                factors += ((factor, 1))\n                a = 0\n\
    \                factor *= factor\n            }\n        }\n        \n      \
    \  factors.foreach{ case ((factor, digit), index) =>\n            if ((factor\
    \ > product)) {\n                product = factor\n            }\n        }\n\n\
    \        product", "        var result = 1\n        var n = 0\n        while(n\
    \ > 0 && a%10 == 0) {\n            n = n/10\n            result *= a\n       \
    \ }\n        result *= b\n        while(n > 0 && b%10 == 0) {\n            n =\
    \ n/10\n            result *= b\n        }\n        result", "        val l =\
    \ a / 1000l\n        val h = a % 1000l\n        val m = b / 1000l\n        val\
    \ n = b % 1000l\n\n        // (10^((n-m)*(n+m)))\n        (1l) ^ ((n - m) * n)",
  "        val product = a*b\n        val numDigits = Math.ceil(product.toDouble /\
    \ Math.pow(2, 16))\n        val unitDigits = product.toDouble - numDigits* Math.pow(2,\
    \ 16)\n        val unitLength = unitDigits.length\n        val unitDigits = unitDigits.toInt\n\
    \        var product = product.toInt\n        var digit = unitDigits(0)\n    \
    \    for (i<-0 until unitLength) {\n            product *= 2\n            if (digit<=9)\
    \ {\n                product += (digit*i)\n                digit += i\n      \
    \      }\n        }\n        if (product >= 10) {\n            return product\n\
    \        }\n        else {\n            return 0\n        }", "        // Your\
    \ code goes here\n        var a =  a.toString.dropWhile( _ <= '0') .toString.drop(\
    \ 1)\n        var b = b.toString.dropWhile( _ <= '0') .toString.drop( 1)\n   \
    \     if(a.size == 0 || b.size == 0) {\n            return 0\n        }\n    \
    \    if(a.length > 0 && b.length > 0) {\n            for(i<- 0 until a.length){\
    \ \n                for(j<- 0 until b.length){\n                    if(a(i) <\
    \ b(i)) {\n                        return 0\n                    }\n         \
    \           if(j == b.length - 1 && b(i) == 0) {\n                        return\
    \ 0\n                    }\n                    if(a(i) == b(i)) {\n         \
    \               \n                    }\n                    \n              \
    \  }\n            }\n            \n        }\n        \n        \n        return\
    \ a.toString.dropWhile( _ <= '0') .toString.drop( 1).dropRight(a.length)", " \
    \      val unitDigits = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n       val tens =\
    \ List.fill(10)(0)\n       val unitDigit = unitDigits.take(a.toInt).dropWhile(x\
    \ => x == 0)\n       val b = unitDigit.take(b).dropWhile(x => x == 0)\n      \
    \ val units = unitDigits.take(b).toList\n       val units = units.zip(tens)\n\
    \       val digits = (a / (b * 10)).map(x => (x % b) * 10)\n       val product\
    \ = digits.zip(units)\n       product.foldLeft(0l)(_ + _).asInstanceOf[Long]",
  "      var sum = 0\n      var product = 1\n      while(a != 0){\n        sum = sum\
    \ + a % 10\n        a = a / 10\n      }\n      while(b != 0){\n        product\
    \ = product * b % 10\n        b = b / 10\n      }\n      product * sum", "   \
    \ \tvar sum = 0;\n    \twhile(b > 0) {\n    \t\tsum += a % 10;\n    \t\ta /= 10;\n\
    \    \t\tb /= 10;\n    \t}\n    \tsum", "        var i = 0\n        var c = 0\n\
    \        var prod = 0\n        for(i <- a until (a + b)){\n            c += 1\n\
    \            if(c % 2 == 1){\n                prod *= i - 1\n            }\n \
    \           else{\n                prod *= i\n            }\n        }\n     \
    \   return prod", "        val factors = a.toDouble/b.toDouble\n        val results\
    \ = (factors.toList.reverse).map(_*10).toList.foldLeft(0l)(_+_)\n        results.toInt",
  "        val aLength = a.toString.length\n        val bLength = b.toString.length\n\
    \        val a = aLength.toString.toInt\n        val b = bLength.toString.toInt\n\
    \        if(a==0 || b==0) 0\n        if(a<b) multiply(a, multiply(b,b))\n    \
    \    if(a>b) multiply(multiply(a,b),b)\n        if(a==b) a\n        else a", " \
    \       val c = (a >>> 4) * b;\n        if (c > 10l) c -= 10l\n        return\
    \ c;", "        var c : Long = 0\n        var a : Long = a % 10\n        var b\
    \ : Long = b % 10\n        \n        while(a != 0 || b != 0) {\n            c\
    \ += (a % 10)\n            a /= 10\n            b /= 10\n        }\n        c\
    \ += a * b\n        c += a * b\n        \n        return c", "        val units\
    \ = List(\n            1l, \n            8l, \n            16l, \n           \
    \ 32l, \n            64l, \n            128l, \n            256l, \n         \
    \   512l, \n            1024l\n        )\n        val remainders = List(\n   \
    \         1l, \n            4l, \n            8l, \n            16l, \n      \
    \      32l, \n            64l, \n            128l, \n            256l, \n    \
    \        512l, \n            1024l\n        )\n        val result = a.toLong *\
    \ b\n        val remainder = result % units(0)\n        var results = 0\n    \
    \    while (true) {\n            val sum = results + units(0)\n            if\
    \ (sum > remainder) {\n                results = sum\n                remainder\
    \ = remainder - units(0)\n            } else {\n                break\n      \
    \      }\n        }\n        remainders.foreach { sum =>\n            if (result\
    \ > sum) {\n                result = result - sum\n            }\n        }\n\
    \        result", "        val unit1 = math.abs(a).toInt\n        val unit2 =\
    \ math.abs(b).toInt\n        var product = unit1 * unit2\n        product /= 10\n\
    \        val newUnit1 = product % 10\n        val newUnit2 = product / 10\n  \
    \      val newUnit = math.abs(newUnit1) + math.abs(newUnit2)\n        val newUnitDigit\
    \ = newUnit % 10\n        val newUnitDigit2 = newUnit / 10\n        val newUnitDigit3\
    \ = math.abs(newUnitDigit)\n        val newUnitDigit4 = math.abs(newUnitDigit2)\n\
    \        val newUnitDigit5 = math.abs(newUnitDigit3)\n        val newUnitDigit6\
    \ = math.abs(newUnitDigit4)\n        val newUnitDigit7 = math.abs(newUnitDigit5)\n\
    \        val newUnitDigit8 = math.abs(newUnitDigit6)\n        val newUnitDigit9\
    \ = math.abs(newUnitDigit7)\n        val newUnitDigit10 = math.abs(newUnitDigit8)\n\
    \        val newUnitDigit11 = math.abs(newUnitDigit9)\n        val newUnitDigit12\
    \ = math.abs(newUnitDigit10)\n        val newUnitDigit13 = math.abs(newUnitDigit11)\n\
    \        val newUnitDigit14 = math.abs(newUnitDigit12)\n        val newUnitDigit15\
    \ = math.abs(newUnitDigit13)\n        val newUnitDigit16 = math.abs(newUnitDigit14)\n\
    \        val newUnitDigit17 = math.abs(newUnitDigit15)\n        val newUnitDigit18\
    \ = math.abs(newUnitDigit16)\n        val newUnitDigit19 = math.abs(newUnitDigit17)\n\
    \        val newUnitDigit20 = math.abs(newUnitDigit18)\n        val newUnitDigit21\
    \ = math.abs(newUnitDigit19)\n        val newUnitDigit22 = math.abs(newUnitDigit20)\n\
    \        val newUnitDigit23 = math.abs(newUnitDigit21)\n        val newUnitDigit24\
    \ = math.abs(newUnitDigit22)\n        val newUnitDigit25 = math.abs(newUnitDigit23)\n\
    \        val newUnitDigit26 = math.abs(newUnitDigit24)\n        val newUnitDigit27\
    \ = math.abs(newUnitDigit25)\n        val newUnitDigit28 = math.abs(newUnitDigit26)\n\
    \        val newUnitDigit29 = math.abs(newUnitDigit27)\n        val newUnitDigit30\
    \ = math.abs(newUnitDigit28)\n        val newUnitDigit31 = math.abs(newUnitDigit29)\n\
    \        val newUnitDigit32 = math.abs(newUnitDigit30)\n        val newUnitDigit33\
    \ = math.", "        val result = a / 10\n        val b = b % 10\n        val\
    \ c = a * b\n        return result * 10 + c", "        val max = Math.max(Math.max(a,\
    \ b), a)\n        val min = Math.min(Math.min(a, b), a)\n        if (max * min\
    \ == a || max * min == b) max else min", "        var product = 0\n        if\
    \ (a/10 * 10 == b/10) {\n            product += a%10 * b%10\n        }\n     \
    \   if (a/10 * 10 > b/10) {\n            product += a%10 * b%10\n        }\n \
    \       if (a/10 * 10 < b/10) {\n            product += a%10 * b%10\n        }\n\
    \        return product", "      def helper(acc: Long, a: Long, b: Long) : Long\
    \ = {\n        a / 1000 match {\n          case 0 => acc\n          case _ =>\n\
    \            b match {\n              case 0 => acc\n              case _ =>\n\
    \                a / 1000 match {\n                  case 0 => acc\n         \
    \         case _ =>\n                    b match {\n                      case\
    \ 0 => acc\n                      case _ =>\n                        a / 1000\
    \ match {\n                          case 0 => acc\n                         \
    \ case _ =>\n                            b match {\n                         \
    \     case 0 => acc\n                              case _ =>\n               \
    \                 a / 1000 match {\n                                  case 0 =>\
    \ acc\n                                  case _ =>\n                         \
    \           b match {\n                                      case 0 => acc\n \
    \                                     case _ =>\n                            \
    \            a / 1000 match {\n                                          case\
    \ 0 => acc\n                                          case _ =>\n            \
    \                                b match {\n                                 \
    \             case 0 => acc\n                                              case\
    \ _ =>\n                                                a / 1000 match {\n   \
    \                                               case 0 => acc\n              \
    \                                    case _ =>\n                             \
    \                       b match {\n                                          \
    \            case 0 => acc\n                                                 \
    \     case _ =>\n                                                        a / 1000\
    \ match {\n                                                          case 0 =>\
    \ acc\n                                                          case _ =>\n \
    \                                                           b match {\n      \
    \                                                        case 0 => acc\n     \
    \                                                         case _ =>\n        \
    \                                                        acc match {\n       \
    \                                                           case 0 => acc\n  \
    \                                                                case _ => acc\n\
    \                                                                }\n         \
    \                                                   }\n                      \
    \                                  }\n                                       \
    \             }\n                                                }\n         \
    \                                   }\n                                      \
    \  }\n                                    }\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n      }\n      if (a > 0 &&\
    \ b > 0) helper(0, a, b)\n      else if (a > 0 && b == 0) 1l\n      else if (a\
    \ == 0 && b > 0) 0l\n      else if (a == 0 && b == 0) 0l\n      else if (a < 0\
    \ && b > 0) helper(-a, a, b)\n      else if (a < 0 && b == 0) -1l\n      else\
    \ if (a == 0 && b < 0) 0l\n      else if (a == 0 && b == 0) 0l\n      else 0l",
  "        // Complete the code here\n        val num = a\n        var product = 1\n\
    \        var carry = 0\n        while (b != 0){\n            val temp = num *\
    \ b + carry\n            product = product * temp\n            carry = temp match\
    \ {\n                case 0 => product\n                case x => x % 10\n   \
    \         }\n            num = num / 10\n            b = b / 10\n        }\n \
    \       return product", "        // Return the product of their unit digits.\
    \ If two numbers have different unit digits, then return 0.\n        // We assume\
    \ all input numbers are positive integers (no zeros).\n        if (a < 0 || b\
    \ < 0) {\n            return 0\n        }\n        if (a > 0 && b > 0) {\n   \
    \         // Use a mutable collection to store the digits of both numbers.\n \
    \           val digits = mutable.ArrayBuffer(a.toString.lastOption, b.toString.lastOption)\n\
    \            val lastDigits = digits.lastOption\n            val result = lastDigits.flatMap(_.toChar)\n\
    \            digits.foreach { d =>\n                // Multiply each digit in\
    \ the two numbers and store it in the mutable collection.\n                //\
    \ The result is a String with each digit multiplied by the corresponding digit.\n\
    \                val digit = d.toInt\n                digits.replace(0, digits.size\
    \ - 1, digit*digit)\n            }\n            return result.getOrElse(0)\n \
    \       }\n        return 0", "        if (a < 0 || b < 0) throw IllegalArgumentException(\"\
    Invalid arguments\")\n        var ret = 0L\n        var units = 0\n        var\
    \ factor = 0\n        while(units < a.toString.length && units < b.toString.length)\
    \ {\n            val temp = a.toString.charAt(units) * b.toString.charAt(units)\n\
    \            if (temp < '0' || '9' < temp) throw IllegalArgumentException(\"Invalid\
    \ arguments\")\n            ret = ret * 10 + temp.toInt\n            units +=\
    \ 1\n        }\n        for (i <- 0 until units) {\n            val temp = (a.toString.charAt(units)\
    \ + b.toString.charAt(units).toInt) % 10\n            factor = factor + temp.toChar\n\
    \            ret = ret * factor\n            units += 1\n        }\n        if\
    \ (units < a.toString.length || units < b.toString.length) throw IllegalArgumentException(\"\
    Invalid arguments\")\n        ret", "        if (a == 0) return 0l\n        if\
    \ (b == 0) return 0l\n        if (b >= a) return 0l\n        val unitArray = a\
    \ / b\n        var product = 0l\n        while (unitArray > 0) {\n           \
    \ product *= unitArray\n            unitArray = unitArray % 10\n        }\n  \
    \      return product", "        val units = mutable.MutableSet[Long]()\n    \
    \    val digits  = mutable.MutableSet[Long]()\n        val newA   = mutable.MutableList[Long]()\n\
    \        val newB   = mutable.MutableList[Long]()\n\n        while (b > 0) {\n\
    \            b /= 10\n            digits += b\n        }\n\n        while (a.nonEmpty)\
    \ {\n            a /= 10\n            digits += a\n        }\n\n        val numUnits\
    \ = digits.toList.length\n        if (numUnits == 0) {\n            return 0\n\
    \        }\n\n        for (i <- 0 until numUnits) {\n            units += digits(i)\n\
    \        }\n\n        while (newA.nonEmpty) {\n            newA :+= newA.head\
    \ * units(0)\n        }\n\n        newA :+= newA.head * units(0)\n        newB\
    \ :+= newB.head * units(0)\n\n        val product = newA.head * newB.head\n  \
    \      val sum    = newA.head + newB.head\n\n        for (i <- 0 until numUnits)\
    \ {\n            product += newA(i) * newB(i)\n        }\n\n        product +\
    \ sum", "        val l = a.toInt;\n        val l1 = b.toInt;\n        val m =\
    \ l1 * l % 10;\n        return m;", "        def unitDigits(a: Long, b: Long):\
    \ Int = {\n            val product = 0\n            val unitLength = math.max(math.abs(a),\
    \ math.abs(b)) / 10\n            val unit = (math.abs(a) < math.abs(b)) ? a :\
    \ b\n            val unitDigits = (if (a < 0) 1 else 2) + (math.floor(math.log10(unit))\
    \ / math.log10(10)) + (if (b < 0) 1 else 2)\n            var i = 0\n         \
    \   while (i < unitDigits) product = (product * 10) + (if (unit >= i * 10) unit\
    \ % i else i * 10 - unit)\n            product\n        }\n\n        def digits(a:\
    \ Long): Int = {\n            if (a < 10) 0\n            else if (a < 100) 1\n\
    \            else 2\n        }\n\n        val digitsA = a * unitDigits(a,b) +\
    \ digits(b)\n        val digitsB = b * unitDigits(a,b) + digits(a)\n        if\
    \ (digitsA < digitsB) digitsA else digitsB", "        val l = (a + b) //to make\
    \ sure it won't exceed long's max value \n        // scala.math.pow(a,b) will\
    \ return a double, so we need to cast it to Long\n        scala.math.pow(a % 10,\
    \ (b % 10).cast).cast.toLong", "        if(a > 0) multiply(a, b/10)\n        else\
    \ multiply(b/10, a)", "        val numDigits = math.max(a.toInt, b.toInt)\n  \
    \      val factors = scala.collection.mutable.ListBuffer.empty[Long]\n       \
    \ factors.push(0L)\n        while(factors.length < numDigits) {\n            val\
    \ i = factors.length\n            val fact = scala.math.pow(10, i)\n         \
    \   factors += fact\n            val a = math.max(a.toInt, (1L * fact).toInt)\n\
    \            val b = math.max(b.toInt, (1L * fact).toInt)\n        }\n       \
    \ var product = 1L\n        val factorIterator = factors.iterator\n        while(factorIterator.hasNext)\
    \ {\n            val factor  = factorIterator.next\n            product = factor\
    \ * product\n        }\n        product", "      val (firstDigit, secondDigit)\
    \ = (a.toInt / 10000l, a.toInt % 10000l)\n      val (firstDigit2, secondDigit2)\
    \ = (b.toInt / 10000l, b.toInt % 10000l)\n      val result = firstDigit * firstDigit2\n\
    \      result * secondDigit", "        val max = Math.max(a.toInt, b.toInt)\n\
    \        val min = Math.min(a.toInt, b.toInt)\n        val product = math.abs(max\
    \ - min) + 1\n        (min until max).foldLeft(1L) { (p, i) =>\n            val\
    \ temp = i.toLong * p\n            if (temp > max)\n                temp - max\
    \ - 1 // return the difference between max and current i\n            else if\
    \ (temp < min)\n                temp + 1 // return the difference between min\
    \ and current i\n            else\n                temp // return the product\
    \ of current i and previous temp\n        }", "        var c = 0\n        for\
    \ {\n            d <- {\n                val temp = a\n                a = b\n\
    \                b = temp\n            }\n            c <- d / 10\n        } yield\
    \ c * 10", "      var result = a \n      val min = 10l \n      val max = 100l\n\
    \      val unitMap = new HashMap[Long, Long]()\n      for (x <- min..max) {\n\
    \        if (a % x == 0) {\n          val unit = getUnit(a / x)\n          if\
    \ (unit < b)\n            result += b * unit\n          else\n            result\
    \ -= b * unit\n          unitMap.put(unit, x)\n        }\n      }\n      for (x\
    \ <- min..max) {\n        if (b % x == 0) {\n          val unit = getUnit(b /\
    \ x)\n          if (unit < a)\n            result += a * unit\n          else\n\
    \            result -= a * unit\n          unitMap.put(unit, x)\n        }\n \
    \     }\n      result + unitMap.getOrElse(b, 0)", "        // Your code here\n\
    \        val unitArray = a.toString.split(\"\").map(_.toLong)\n        val unitArray2\
    \ = b.toString.split(\"\").map(_.toLong)\n        var product = unitArray(0) *\
    \ unitArray2(0)\n        for(i<-1 to unitArray.length){\n            product +=\
    \ unitArray(i) * unitArray2(i)\n        }\n        return product;", "       \
    \ val unitDigits = a.toString + b.toString\n        val unitDigit = unitDigits(0)\
    \ // Extract the first digit from both numbers\n        val unitDigits = unitDigits.substring(1)\n\
    \        // Find the unit digit of each number and multiply them together\n  \
    \      val units = unitDigits.toInt\n        unitDigits(0) * unitDigits(1) + units(1)\
    \ * units(2)", "      val (a0, a1) = (a, a).divmod(10)\n      val (b0, b1) = (b,\
    \ b).divmod(10)\n      val product = a0 * b0 + a1 * b1\n      if (product < 10)\
    \ {\n        product\n      } else {\n        multiply(product, 10)\n      }",
  "        // Complete this function\n        var temp = 0\n        var mul = 1\n\
    \        for (i = a.toString.length-1; i > -1; i -= 1) {\n            temp +=\
    \ (a.toString.charAt(i) - '0') * mul\n            mul *= 10\n        }\n     \
    \   for (i = b.toString.length-1; i > -1; i -= 1) {\n            temp += (b.toString.charAt(i)\
    \ - '0') * mul\n            mul *= 10\n        }\n        return temp", "    \
    \    // Write your code here\n        if (a.isEmpty || b.isEmpty) {\n        \
    \    return 0\n        } else {\n            val c = new mutable.HashSet[Long]()\n\
    \            val a1 = a.toString.toInt\n            val b1 = b.toString.toInt\n\
    \            if (a1 < 0) {\n                c.add(-a1)\n            }\n      \
    \      if (b1 < 0) {\n                c.add(-b1)\n            }\n            for\
    \ (i <- a1 until a1 += 9) {\n                c.add(i)\n            }\n       \
    \     for (i <- b1 until b1 += 9) {\n                c.add(i)\n            }\n\
    \            c.toSet.map(x => (x * b).toInt).reduce((x, y) => x * y)\n       \
    \ }", "        var sum = 0\n        for (i <- 0 until a) {\n            sum +=\
    \ a(i) * b(i)\n        }\n        return sum", "        var c = a * b\n      \
    \  val unitDigits = (c.toInt % 10).toLong\n        val unit = (c.toInt / 10).toLong\n\
    \        if(unitDigits == 0) {\n            unit\n        }\n        else {\n\
    \            multiply(unitDigits, unit)\n        }", "        def unitDigits(a\
    \ : Long) : List[Long] = {\n            if (a == 0)\n                List()\n\
    \            else\n                a / 10\n        }\n        val aUnits = unitDigits(a)\n\
    \        val bUnits = unitDigits(b)\n        val units = aUnits ++ bUnits\n  \
    \      val unitDigit = units.head\n        val units = units.tail\n        val\
    \ product = unitDigit\n        val remainingUnits = units.reverse\n        val\
    \ remainders = remainingUnits map (multiply)(product)\n        remainders.reverse",
  "        var sum = 0\n        for( a <- a.toString.reverse.toInt ; b <- b.toString.reverse.toInt\
    \ ) {\n            if( a > b ) {\n                sum += 1\n            } else\
    \ {\n                sum *= 10\n                if( a < b ) {\n              \
    \      sum -= 10\n                }\n            }\n        }\n        sum.toLong",
  "        val unitDigits = a / b\n        val result = unitDigits * b\n        return\
    \ result", "        val a = a.toString.toInt\n        val b = b.toString.toInt\n\
    \        var prod = 0\n        while (a<10){\n          prod = prod * 10 + a\n\
    \          a = a+1\n        }\n        while (b<10){\n          prod = prod *\
    \ 10 + b\n          b = b+1\n        }\n        prod", "        var product =\
    \ a * b\n        while(product > 10) {\n            product = product / 10\n \
    \       }\n        return product", "      val a = a.toString.reverse\n      val\
    \ b = b.toString.reverse\n      val product = a.zip(b.drop(1)).map { x => x._1\
    \ * x._2 }.sum\n      val str = product.toString.reverse\n      str.charAt(0)",
  "        var result = 1\n        var n1 = a / 1000\n        var n2 = a / 100 % 100\n\
    \        var n3 = a / 10 % 10\n        var n4 = a % 10\n        var n5 = b / 1000\n\
    \        var n6 = b / 100 % 100\n        var n7 = b / 10 % 10\n        var n8\
    \ = b % 10\n        n4 = multiply(n4, n1)\n        n8 = multiply(n8, n1)\n   \
    \     n7 = multiply(n7, n1)\n        n6 = multiply(n6, n1)\n        n5 = multiply(n5,\
    \ n1)\n        n8 = multiply(n8, n2)\n        n7 = multiply(n7, n2)\n        n6\
    \ = multiply(n6, n2)\n        n5 = multiply(n5, n2)\n        n7 = multiply(n7,\
    \ n3)\n        n8 = multiply(n8, n3)\n        n6 = multiply(n6, n3)\n        n5\
    \ = multiply(n5, n3)\n        n8 = multiply(n8, n4)\n        n7 = multiply(n7,\
    \ n4)\n        n6 = multiply(n6, n4)\n        n5 = multiply(n5, n4)\n        n7\
    \ = multiply(n7, n5)\n        n8 = multiply(n8, n5)\n        n6 = multiply(n6,\
    \ n5)\n        n5 = multiply(n5, n5)\n        n8 = multiply(n8, n6)\n        n7\
    \ = multiply(n7, n6)\n        n6 = multiply(n6, n6)\n        n5 = multiply(n5,\
    \ n6)\n        n8 = multiply(n8, n7)\n        n7 = multiply(n7, n7)\n        n6\
    \ = multiply(n6, n7)\n        n5 = multiply(n5, n7)\n        n8 = multiply(n8,\
    \ n8)\n        n7 = multiply(n7, n8)\n        n6 = multiply(n6, n8)\n        n5\
    \ = multiply(n5, n8)\n        n8 = multiply(n8, n8)\n        result = add(n8,\
    \ add(n7, add(n6, add(n5, add(n4, n3)))))\n        return result", "        //\
    \ 1st, calculate unit's digit sum\n        // 2nd,calculate unit's digit product\n\
    \        //\n        // 1st, calculate unit's digit sum\n        val digitSum\
    \ = a / (10 * 100000000l)\n        // 2nd,calculate unit's digit product\n   \
    \     val digitProduct = a / (10000000l * b) \n        // return the product\n\
    \        digitProduct * digitSum", "        val unitDigits = a.toString.last.foldLeft(0)((accum,\
    \ digit) => accum * 10 + (digit.toInt % 10))\n        val resultDigit = b.toString.last.foldLeft(0)((accum,\
    \ digit) => accum * 10 + (digit.toInt % 10))\n        resultDigit / unitDigits",
  "        // Write your solution here\n        val unitDigits = a / (10d * b)\n \
    \       val product = unitDigits.multiply(10d)\n        return product", "   \
    \     val ones: mutable.Set[Long] = mutable.Set(1)\n        val tens: mutable.Set[Long]\
    \ = mutable.Set(10)\n        val hundreds: mutable.Set[Long] = mutable.Set(100)\n\
    \        val thousands: mutable.Set[Long] = mutable.Set(1000)\n        val tenThousands:\
    \ mutable.Set[Long] = mutable.Set(10000)\n        val hundredThousands: mutable.Set[Long]\
    \ = mutable.Set(100000)\n        val millions: mutable.Set[Long] = mutable.Set(1000000)\n\
    \        val billions: mutable.Set[Long] = mutable.Set(1000000000)\n        val\
    \ millionThousands: mutable.Set[Long] = mutable.Set(100000000)\n        val hundredThousandThousands:\
    \ mutable.Set[Long] = mutable.Set(1000000000)\n        val oneMillion: mutable.Set[Long]\
    \ = mutable.Set(10000000)\n        val oneHundred: mutable.Set[Long] = mutable.Set(100000)\n\
    \        val oneThousand: mutable.Set[Long] = mutable.Set(1000)\n        val oneHundredThousand:\
    \ mutable.Set[Long] = mutable.Set(100000)\n        val oneThousandThousand: mutable.Set[Long]\
    \ = mutable.Set(1000)\n        val oneHundredThousandThousand: mutable.Set[Long]\
    \ = mutable.Set(100000)\n        val oneThousandThousandThousand: mutable.Set[Long]\
    \ = mutable.Set(1000)\n        val oneHundredThousandThousandThousand: mutable.Set[Long]\
    \ = mutable.Set(100000)\n        val oneThousandThousandThousandThousand: mutable.Set[Long]\
    \ = mutable.Set(1000)\n        val oneHundredThousandThousandThousandThousand:\
    \ mutable.Set[Long] = mutable.Set(100000)\n        val oneThousandThousandThousandThousandThousand:\
    \ mutable.Set[Long] = mutable.Set(1000)\n        val oneHundredThousandThousandThousandThousandThousand:\
    \ mutable.Set[Long] = mutable.Set(100000)\n        val oneThousandThousandThousandThousandThousandThousand:\
    \ mutable.Set[Long] = mutable.Set(1000)\n", "        val ua = a%100\n        val\
    \ ub = b%100\n        (ua*100 + ub*10)", "        var unitDivisor = 1\n      \
    \  var product = 0\n        while (unitDivisor <= a / 10 && unitDivisor <= b /\
    \ 10) {\n            product += (a % 10 * unitDivisor % 10 * b / 10) % 10\n  \
    \          a = (a/10) * 10\n            b = b % 10\n            unitDivisor *=\
    \ 10\n        }\n        product", "        if ((a >= 0) && (a <= 9) && (b >=\
    \ 0) && (b <= 9)) {\n            val mul = a.toInt * b.toInt\n            if (mul\
    \ <= 9) {\n                return mul\n            } else {\n                return\
    \ mul - 9\n            }\n        } else {\n            return 0\n        }",
  "        var product = 1\n        var dividend = a\n        var divisor = b\n  \
    \      while(divisor > 0) {\n            dividend %= divisor\n            product\
    \ *= dividend\n            divisor /= 10\n        }\n        product", "     \
    \   val c = a * b;\n        val d = c / 10;\n        val e = (c + d / 10) % 10;\n\
    \        return d;", "        val m = (a * b).toInt\n        val r = new Array[Long](m)\n\
    \        for (i <- 0 until m) {\n            val q = a / 10\n            r(i)\
    \ = q * b\n            a = q\n        }\n        val r = new Array[Long](m)\n\
    \        for (i <- 0 until m) {\n            r(i) = a / 10\n            a = r(i)\n\
    \        }\n        r.toLong", "        // write your code\n        var result\
    \ = 0L\n        val divisor = BigInt(b)\n        val dividend = BigInt(a)\n  \
    \      val divisorDigits = divisor.toString().toCharArray().map(x => if (x.isDigit())\
    \ x else ' ').toArray\n        val dividendDigits = dividend.toString().toCharArray().map(x\
    \ => if (x.isDigit()) x else ' ').toArray\n        val arrayDivisor = divisorDigits.filter(x\
    \ => dividendDigits.contains(x))\n        val arrayDividend = dividendDigits.filter(x\
    \ => divisorDigits.contains(x))\n        val minDivisor = divisorDigits.min\n\
    \        val maxDivisor = divisorDigits.max\n        val minDivisorIndex = divisorDigits.indexOf(minDivisor)\n\
    \        val maxDivisorIndex = divisorDigits.indexOf(maxDivisor)\n        val\
    \ divisorDigitDiff = maxDivisorIndex - minDivisorIndex\n        for ((i,j) <-\
    \ divisorDigitDiff..divisorDigitDiff+arrayDivisor.length){\n            if(arrayDivisor(i)\
    \ != 0 && arrayDividend(i) != 0){\n                result = result + (arrayDivisor(i)\
    \ * arrayDividend(i))\n            }\n        }\n        result", "        var\
    \ unit = a;\n        var unitInner = b;\n        while (unitInner > 0) {\n   \
    \         unit *= 10;\n            unitInner -= unit % 10\n        }\n       \
    \ unit", "        val product = a.toString.toInt \n        product *= b.toString.toInt\
    \ \n        (product % 10l).toLong", "        def gcd(a : Long, b : Long) : Long\
    \ = {\n            if (b == 0) return a\n            else {\n                val\
    \ r = gcd(b, a % b)\n                a / r\n            }\n        }\n       \
    \ val q = a / b\n        val r = b % q\n        val t = gcd(q, b)\n        a *\
    \ t / r", "        if (a == 0) { return b }\n        if (b == 0) { return a }\n\
    \        val product = a / b\n        val remainder = a % b\n        multiply(remainder,\
    \ b)", "        val product = a * b\n        val digits = (product / 10).toInt\n\
    \        val unitDigits = product % 10\n        if (unitDigits == 0) return digits.get\n\
    \        val unitString = (digits.length - unitDigits).toString\n        (digits\
    \ * unitString) + (unitDigits)", "        var c = 0\n        var d = a\n     \
    \   var e = b\n        while (e-- > 0) {\n            c += d\n            d *=\
    \ 10\n        }\n        c", "        var c : Long = 0l\n        for (i<-0 until\
    \ a) {\n            c += (b / (i as Long)) % 10\n        }\n        c", "    \
    \    // Write your code here\n        // return 0l", "        if (a < 0 || b <\
    \ 0) {\n            return -1l\n        }\n        // If the input numbers are\
    \ the same, return 0\n        if (a == 0) {\n            return 0l\n        }\n\
    \        // We don't care about the order of the digits\n        // if the first\
    \ digit of the second number is bigger than the first digit of the input number\n\
    \        if (b > a) {\n            return 0l\n        }\n        // If the numbers\
    \ are different length, return the maximum of the lengths\n        if (a > b)\
    \ {\n            return a\n        }\n        // For every digit in a, we take\
    \ its corresponding digit in b\n        // If the digit in b is less than the\
    \ digit in a, we multiply by 10 and subtract it from the original digit in b\n\
    \        // If the digit in b is greater than the digit in a, we multiply by 100\
    \ and subtract it from the original digit in b\n        // If the digit in b is\
    \ equal to both digits in a, we simply subtract it from the original digit in\
    \ b\n        for (i <- a downTo 0 by -1) {\n            val temp = b\n       \
    \     if (temp < i) {\n                temp = temp * 10\n                temp\
    \ -= i\n            } else {\n                temp = temp * 100\n            \
    \    temp -= i\n            }\n            b = temp\n        }\n        // Now\
    \ we simply return the product of all the unit digits in b\n        b.toLong",
  "        var product = a * b\n        while (product > 0) {\n            product\
    \ /= 10\n        }\n        product", "        val unitDigits = a.toInt/10\n \
    \       val aRemainder = a%10\n        val bRemainder = b%10\n        val unitDigitRemainders\
    \ = (aRemainder + bRemainder).toLong/10\n        val unitDigitMultiplier = unitDigits.toLong*unitDigitRemainders\n\
    \        val product = (aRemainder*unitDigits)*(bRemainder*unitDigitMultiplier)\n\
    \        \n        product", "        if(a%10==0 || b%10==0) \n            return\
    \ 0;\n        val result: Long = a * b;\n        if((a%10!=0 && b%10!=0 && result/10!=a%10*b%10)\
    \ || (a%10==0 && b%10==0 && result/10!=b%10*a%10)) {\n            return 0;\n\
    \        }\n        result/10;", "        val num = a * 1000l\n        val den\
    \ = b * 1000l\n        val product = num / den\n        product * 1000l", "  \
    \      if ((a < 0) || (b < 0)) {\n            throw new ArithmeticException\n\
    \        }\n        \n        if (a == 0) {\n            if (b == 0) {\n     \
    \           return 0\n            }\n            \n            throw new ArithmeticException\n\
    \        }\n        \n        if (b == 0) {\n            return a\n        }\n\
    \        \n        var sum = 0\n        \n        var remainder = a % b\n    \
    \    \n        while (remainder != 0) {\n            sum += (remainder % 10) *\
    \ 10\n            remainder = remainder / 10\n        }\n        \n        return\
    \ sum", "        val aStr = a.toString.toInt;\n        val bStr = b.toString.toInt;\n\
    \        val a = aStr.toArray.dropRight(2).reverse;\n        val b = bStr.toArray.dropRight(2).reverse;\n\
    \        val product = a * b match {\n            case x if x == 0 => 0\n    \
    \        case x if x == 1 => b(0)\n            case x if x == -1 => b(1)\n   \
    \         case x => x * b\n        }\n        product.toLong", "        if (a\
    \ == 0) {\n            return b;\n        }\n        if (b == 0) {\n         \
    \   return a;\n        }\n        var min = a\n        var max = b\n        if\
    \ (min < 0 && max > 0) {\n            min = max = 0\n        }\n        if (min\
    \ < 0) {\n            min = -min\n            max = -max\n        }\n        val\
    \ min = max\n        while (max != min - 1) {\n            val product = min *\
    \ (min + max)\n            max = product\n        }\n        if (min == 0) {\n\
    \            1\n        }\n        else if (min > 0) {\n            1l / min\n\
    \        }\n        else if (min < 0) {\n            min\n        }", "      \
    \ // Write code here\n       val unitDigits = a.toString.toCharArray\n       val\
    \ unitDigits2 = b.toString.toCharArray\n       var product = productOfUnitDigits(unitDigits,\
    \ unitDigits2).toInt\n       if (unitDigits.isEmpty || unitDigits2.isEmpty) {\n\
    \           product = 0\n       }\n       return Long.valueOf(product)", "   \
    \ \tval result = new mutable.MutableList[Long]\n    \t\n    \t// Write your code\
    \ here\n    \t// 1. Divide a and b to get a quotient and remainder aQuotient and\
    \ remainder bQuotient\n    \t// 2. Get their remainder and their unit digits in\
    \ aUnitDigits and bUnitDigits respectively\n    \t// 3. Append the results to\
    \ a list\n    \t// 4. Convert the list to string and return\n    \t\n    \tval\
    \ aQuotient = a%b\n    \tval bQuotient = b%a\n    \tval aUnitDigits = aQuotient/10\n\
    \    \tval bUnitDigits = bQuotient/10\n    \tresult.append(aUnitDigits*bUnitDigits)\n\
    \    \tresult.toString", '        // Your code here', "        val num1 = math.max(a,b)\n\
    \        val num2 = math.min(a,b)\n        var product = num1\n        while (num2\
    \ != 0) {\n            val remainder = num2 % 10\n            product *= 10\n\
    \            product += remainder\n            num2 /= 10\n        }\n       \
    \ product", "        val list = a.toString.split(\"\\\\D+\").filterNot(_.isEmpty).toList\n\
    \        val list1 = b.toString.split(\"\\\\D+\").filterNot(_.isEmpty).toList\n\
    \        var num = 1\n        var newValue = 0\n        var index = -1\n     \
    \   var index2 = -1\n        if (list.length < list1.length) {\n            index\
    \ = list1.length - list.length\n        }\n        if (list.length > list1.length)\
    \ {\n            index2 = list.length - list1.length\n        }\n        if (list.indices.contains(index)\
    \ && list1.indices.contains(index2)) {\n            if (list1.apply(index) ==\
    \ list1.apply(index2)) {\n                num += 1\n            }\n          \
    \  else {\n                num += list1.apply(index) - list1.apply(index2)\n \
    \           }\n            if (list.length > list1.length) {\n               \
    \ newValue = num * list1.apply(list1.length - 1)\n            }\n            else\
    \ {\n                newValue = num * list1.apply(0)\n            }\n        }\n\
    \        if (list.indices.contains(index) && list1.indices.contains(index2)) {\n\
    \            if (list1.apply(index) == list1.apply(index2)) {\n              \
    \  num += 1\n            }\n            else {\n                num += list1.apply(index)\
    \ - list1.apply(index2)\n            }\n            if (list.length < list1.length)\
    \ {\n                newValue = num * list1.apply(list1.length - 1)\n        \
    \    }\n            else {\n                newValue = num * list1.apply(0)\n\
    \            }\n        }\n        if (list.indices.contains(index) && list1.indices.contains(index2))\
    \ {\n            if (list1.apply(index) == list1.apply(index2)) {\n          \
    \      num += 1\n            }\n            else {\n                num += list1.apply(index)\
    \ - list1.apply(index2)\n            }\n            if (list.length < list1.length)\
    \ {\n                newValue = num * list1.apply(list1.length - 1)\n        \
    \    }\n            else {\n                newValue = num * list1.apply(0)\n\
    \            }\n        }\n        if (list.indices.contains(index) && list1.indices.contains(index2))\
    \ {\n            if (list1.apply(index) == list1.apply(index2)) {\n          \
    \      num += 1\n            }\n            else {\n                num += list1.apply(index)\
    \ - list1.apply(index2)\n            }\n            if (list.length < list1.length)\
    \ {\n                newValue = num * list1.apply(list1.length - 1)\n        \
    \    }\n            else {\n                newValue = num * list1.apply(0)\n\
    \            }\n        }\n        if (list.indices.contains(index) && list1.indices.contains(index2))\
    \ {\n            if (list1.apply(index) == list1.apply(index2)) {\n          \
    \      num += 1\n            }\n            else {\n                num += list1.apply(index)\
    \ - list1.apply(index2)\n            }\n            if (list.length < list1.length)\
    \ {\n                newValue = num * list1.apply(list1.", "        if (a == 0\
    \ || b == 0)\n            return 0\n        val a = a % 100\n        val b = b\
    \ % 100\n        var c = 0\n        while (a != 0 || b != 0) {\n            val\
    \ a2 = a / 10\n            val b2 = b / 10\n            if (a2 == b2)\n      \
    \          c += a2\n            else if (b2 > a2)\n                c += b2 % 10\n\
    \            else\n                c += a2 % 10\n            a = a2 / 10\n   \
    \         b = b2 / 10\n        }\n        c", "        val product = a / b\n \
    \       val firstUnit = a%b\n        val secondUnit = product%b\n        product\
    \ + (firstUnit * secondUnit)", "        val unitDigit = math.max(math.min(a, b),\
    \ 0) - math.max(math.min(a, b), 0) + math.min(math.min(a, b), 0)\n        math.pow(10,\
    \ unitDigit)", "        val product = a \\ b\n        product + (a & ((1 << (b\
    \ % 2)) - 1))", "        def divide(n : Long) : Long = if (n > 0) n/10 else 1\n\
    \n        def multiply(n : Long) : Long = n * 10\n\n        def divideByTen(n\
    \ : Long) : Long = divide(n) * 10\n\n        val prod = multiply(a) + multiply(b)\n\
    \        val dProd = divide(prod)\n        prod * dProd", "        val c = new\
    \ scala.collection.mutable.ListBuffer[Long]()\n        var i1 = 1\n        var\
    \ i2 = 1\n        while(a > 0) {\n            if(a % 10 == 0 && b > 0) {\n   \
    \             while(a % 10 == 0 && b > 0) {\n                    c += b\n    \
    \                a /= 10\n                    b /= 10\n                }\n   \
    \         } else if(a % 10 != 0 && b > 0) {\n                while(a % 10 != 0\
    \ && b > 0) {\n                    c += b\n                    a /= 10\n     \
    \               b /= 10\n                }\n            }\n            a /= 10\n\
    \            b /= 10\n        }\n        if(a == 0)\n            return c.toList.last\n\
    \        else\n            0", "        val l1 = math.abs(a)\n        val l2 =\
    \ math.abs(b)\n        val l3 = math.max(a, b) //l3 = (l1, l2) or (a, b)\n   \
    \     l3 * math.pow(10, l2/l1)", "        if ((a<=0l) && (b<=0l)) { \n       \
    \     // If both numbers are 0, then zero is the answer\n            return (0l);\
    \ \n        }\n        if ((a<=0l) || (b<=0l)) { \n            // If both are\
    \ negative or both are 0, then product is zero\n            return (0.0l); \n\
    \        }\n        // If one of the numbers is positive, then we need to multiply\
    \ the\n        // digit by 10\n        var multiplier : Long = 10l\n        //\
    \ Keep dividing from the second number while the first number still has\n    \
    \    // remainders\n        var quotient : Long = a\n        while (quotient >\
    \ 0l) {\n            multiplier = multiplier * 10\n            quotient = quotient\
    \ / 10\n        }\n        // Now the quotient is less than 10. We need to multiply\
    \ the remainder by\n        // 10 and add it to the first\n        var remainder\
    \ = b % multiplier\n        multiplier = multiplier * 10\n        multiplier =\
    \ multiplier + remainder\n        return (multiplier); ", "        val digits\
    \ = mutable.ListBuffer.empty[Long]\n        var carry = 0\n        while (a !=\
    \ 0L && b != 0L && a < 10L && b < 10L) {\n            digits += a * b\n      \
    \      carry = a / 10\n            a = a % 10\n            b = b / 10\n      \
    \  }\n        digits.reverse().foldLeft(0L)( (x, acc) => x * acc + carry)", " \
    \       val digits = List(BigInt(a), BigInt(b))\n        val product = BigInt(0)\n\
    \        var i = 0\n        while (i < digits.size) {\n            val sum = BigInt(digits(i))\
    \ * BigInt(i)\n            product = product + sum\n            i = i + 1\n  \
    \      }\n        product", "        val m = BigInt(a).multiply(BigInt(b))\n \
    \       if(m > 9223372036854775807L) BigInt(m)\n        else BigInt(m).divide(BigInt(10)).multiply(BigInt(10))",
  "        var c = a * b\n        c += (b % 10) * 10\n        c -= (b / 10) % 10\n\
    \        c -= (b / 10) / (10 * (b / 10) / (10 * (b / 10)))\n        c *= a\n \
    \       c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n\
    \        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *=\
    \ b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c\
    \ *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n     \
    \   c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n \
    \       c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n\
    \        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *=\
    \ b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c\
    \ *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n     \
    \   c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n \
    \       c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n\
    \        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *=\
    \ b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c\
    \ *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n     \
    \   c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n \
    \       c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n\
    \        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *=\
    \ b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c\
    \ *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n     \
    \   c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n \
    \       c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n\
    \        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c *=\
    \ b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n        c\
    \ *= b\n        c *= b\n        c *= b\n        c *= b\n        c *= b\n     \
    \   c *= b\n        c", "        def unit_digits(x : Long) : Long = \n       \
    \     if (x < 0) (-1L * x) else x\n        val ones = unit_digits(a) * unit_digits(b)\n\
    \        val tens = unit_digits(a) * unit_digits(b)\n        val hundreds = unit_digits(a)\
    \ * unit_digits(b)\n        val thousands = unit_digits(a) * unit_digits(b)\n\
    \        \n        tens % 10 * hundreds % 100 * thousands % 1000 * ones", "  \
    \      var product = BigInt(0)\n        var units = 0\n        val a = BigInt(a)\n\
    \        val b = BigInt(b)\n        // Keep looping while both numbers have digits,\
    \ adding them onto the product as we go.\n        while (a.remainder(BigInt(10))\
    \ == 0 & b.remainder(BigInt(10)) == 0) {\n            // While the remainder of\
    \ both numbers divided by 10 is zero, add them onto the product.\n           \
    \ product = product + a.remainder(BigInt(10)) * (b.remainder(BigInt(10)))\n  \
    \          units = units + 1\n            a = a / 10\n            b = b / 10\n\
    \        }\n        // Return the product of their unit digits.\n        product\
    \ = product * (BigInt(10).toLong + BigInt(units))\n        product", '        //',
  "        val product = if (a < 0 || b < 0) 0 else a * b\n        (product / (Math.pow(2,\
    \ a.toInt) + 1)).toLong", "        val unitA = (a.toString.toInt).filter(_ <=\
    \ 9).toList\n        val unitB = (b.toString.toInt).filter(_ <= 9).toList\n  \
    \      var product = 0\n        for (unit <- unitA +: unitB) {\n            val\
    \ productDigit = unit.toString\n            product *= productDigit\n        }\n\
    \        return product", "        val prod = a * b;\n        val remainder =\
    \ prod % 10;\n        val rem1 = prod / 10;\n        if (rem1 < 10) {\n      \
    \      prod = rem1 + 1;\n        }\n        prod;", "      var c = a\n      while(c\
    \ >= 10) {\n        c = c / 10\n      }\n      c = b * 10 + c\n      while(c >\
    \ 0) {\n        c = c / 10\n      }\n      c", "        val product = a / (10\
    \ * b)\n        val digits = product.toDouble()\n        if (digits() == 0)\n\
    \            return 0\n        else if (digits() < 0)\n            return (-digits())\
    \ * multiply((-digits()), b)\n        else\n            return (digits()) * multiply(digits(),\
    \ b)", "        val unitA = math.abs(a)\n        val unitB = math.abs(b)\n   \
    \     var result = 0\n\n        // Initialize result to 1 since any positive number\
    \ is also a unit digit \n        // and since we are using positive numbers, 1\
    \ will always be a unit digit.\n        result = 1\n\n        // Iterate through\
    \ both unit digits to see if their product is less than 10\n        // and if\
    \ so, add it to the result and subtract it from the larger unit\n        // digit.\n\
    \        while (a / 10 <= 10) {\n            if (a % 10 * b < 10) \n         \
    \       result += 1\n            a /= 10\n        }\n\n        // Iterate through\
    \ both unit digits to see if their product is less than 10\n        // and if\
    \ so, add it to the result and subtract it from the larger unit\n        // digit.\n\
    \        while (a / 10 <= 10) {\n            if (a % 10 * -b < 10) \n        \
    \        result -= 1\n            a /= 10\n        }\n\n        // Return the\
    \ result and update the larger unit digit to equal the larger\n        // of the\
    \ two unit digits.\n        result = result * unitA // Result is product of unit\
    \ digits times larger digit\n        result = result > 0 ? result + a : result\
    \ - a\n        unitA = unitB\n        unitB = result", "        if (a > 0 || b\
    \ > 0)\n            return a * b\n        else\n            return 0", '        //
    TODO: Implement this function', "        // (1) Resolve the problem if the input\
    \ numbers are negative.\n        if (a < 0 || b < 0) {\n            if (a < 0)\n\
    \                return multiply(-a, b);\n            else if (b < 0)\n      \
    \          return multiply(a, -b);\n        }\n        // (2) Reduce the number\
    \ to the unit digit. \n        // (3) If one of the numbers is zero, \n      \
    \  // the result is zero.\n        if (a < 10 && b < 10)\n            return a\
    \ * b * 1000l;\n        else if (a < 10 && b > 10)\n            return multiply(a,\
    \ b) * 1000;\n        else if (b < 10 && a > 10)\n            return multiply(-a,\
    \ b) * 1000;\n        else \n            return multiply(a, b);", "        //Write\
    \ your code here\n        var result = 0\n        var multiplier = 1\n       \
    \ var unitDigit = 0\n        if(b<0){\n            val min = a\n            val\
    \ max = -b\n            max = max%10\n            min = min%10\n            multiplier\
    \ = 10\n            while(multiplier<min){\n                unitDigit = unitDigit+1\n\
    \                multiplier = multiplier*10\n            }\n        }\n      \
    \  if(a<0){\n            val min = a\n            val max = -b\n            max\
    \ = max%10\n            min = min%10\n            multiplier = 10\n          \
    \  while(multiplier<min){\n                unitDigit = unitDigit+1\n         \
    \       multiplier = multiplier*10\n            }\n        }\n        while(a\
    \ != 0 && b!=0){\n            val product = a%10*multiplier%10 + b%10*multiplier%10\n\
    \            result = (result+product)%10\n            a = (a/10)%10\n       \
    \     b = (b/10)%10\n            multiplier = multiplier*10\n        }\n     \
    \   if(result == 0 && b!=0){\n            result = (b%10)*multiplier\n       \
    \ }\n        if(result > 9){\n            while(result != 0){\n              \
    \  result = result%10 + 9\n            }\n        }\n        if(result < 9){\n\
    \            while(result != 9){\n                result = result%10 + 1\n   \
    \         }\n        }\n        if(a > 0 && b == 0){\n            val firstDigit\
    \ = a\n            val secondDigit = 0\n            while(firstDigit != 0){\n\
    \                firstDigit = firstDigit/10\n                secondDigit = secondDigit+firstDigit\n\
    \            }\n            result = secondDigit\n        }\n        if(a == 0\
    \ && b > 0){\n            result = -b\n        }\n        if(a == 0 && b < 0){\n\
    \            result = (-b)\n        }\n        if(a == 0){\n            result\
    \ = b\n        }\n        if(b == 0){\n            result = a\n        }\n   \
    \     return result", "        var result = a.toInt\n        var carry = 0\n \
    \       while (a != 0) {\n            val c = b % 10\n            val t = a /\
    \ 10\n            a = t - c * 10\n            b = c\n            result += a\n\
    \            carry = 1\n            if (result > 9) result -= 10\n           \
    \ if (result > 999) result = result % 1000\n            if (carry == 1) result\
    \ += 10\n        }\n        if (carry == 1) result -= 10\n        result", " \
    \       if(a == 0L) return 0L\n        if(b == 0L) return 0L\n        if(a<b)\
    \ \n            multiply(a+1L, b)\n        else \n            multiply(a, b+1L)",
  "        val unitDivisor = 1000000l\n        val unitDivisorFactor = unitDivisor.toLong\
    \ \n        // a is the unit digit number, \n        // b is the unit digit number\
    \ to be multiplied.\n        \n        // Compute c by computing the product of\
    \ the unit digit \n        // numbers, multiplied by the unit digit factor\n \
    \       val c = (a * unitDivisor).toInt / unitDivisorFactor\n        val c1 =\
    \ c * unitDivisorFactor\n        val c2 = c1 * unitDivisorFactor\n        val\
    \ c3 = c2 * unitDivisorFactor\n        \n        // Return the product of the\
    \ unit digit numbers\n        (c1, c2, c3)", "       if (a == 0 || b == 0) {\n\
    \           0\n       }\n       else {\n           val x = a / 100\n         \
    \  val y = b / 100\n           val z = x / y\n           z * y + x * 100\n   \
    \    }", "        // Write your code here!\n        val product = a * b\n    \
    \    val ones = math.pow(10, product/10)\n        val zeros = math.pow(10, product\
    \ % 10)\n        zeros + ones", "        var unitDigits = 1\n        val factors\
    \ = a / 10 ; val factorsRest = a % 10\n        val factorsNext = b /10 ; val factorsNextRest\
    \ = b % 10\n\n        if(factors.equals(0)) {\n            factorsNext = factors\n\
    \            factorsNextRest = factorsRest\n        }\n        else if(factorsNext.equals(0))\
    \ {\n            factorsRest = factorsNext\n            factorsRest = factors\n\
    \        }\n\n        val resultDigits = factorsRest * factorsNextRest\n     \
    \   if(resultDigits.compareTo((a % 10) * 10) ==  0) {\n            a + (b % 10)\n\
    \        }\n        else {\n            a + (b % 10) + (resultDigits.compareTo((a\
    \ % 10) * 10) * 10)\n        }", "        var sum = 0\n        while (a != 0l)\
    \ {\n            sum = sum + a % 10\n            a /=10\n        }\n        while\
    \ (b != 0l) {\n            sum = sum + b % 10\n            b /=10\n        }\n\
    \        sum", "        val unitDigits = scala.math.pow(10, a.toInt)\n       \
    \ val unitDigits2 = scala.math.pow(10, b.toInt)\n        val unitDigits3 = unitDigits.toDouble/unitDigits2\n\
    \        return a.toLong * unitDigits3", "        val unitList = List(1000l, 10000l,\
    \ 100000l, 1000000l, 10000000l, 100000000l, 1000000000l, 10000000000l, 100000000000l)\n\
    \        val sum = a.toInt + (b.toInt * 10).toInt\n        val product = unitList(sum.toInt.mod(unitList.size))\n\
    \        product", "        if(a < 0L || b < 0L) {\n            if(a > 0L) multiply(a\
    \ / 10, b)\n            else multiply(a * 10, -b / 10)\n        } else {\n   \
    \         if(b > 0L) {\n                multiply(a, b / 10)\n            } else\
    \ if(a * 10 > b) {\n                multiply(a * 10, b)\n            } else multiply(a,\
    \ -b / 10)\n        }", "        val unitDigits = List(14l, 412l)\n        val\
    \ multiplied = a.toLong * b.toLong\n        if(multiplied < 0) return multiplied.abs\
    \ * (unitDigits.last.asInstanceOf[Long])\n        if(multiplied >= 1000000000l)\
    \ return multiplied.abs * (unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long])\n\
    \        if(multiplied >= 1000000000l * 10) return multiplied.abs * (unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long])\n        if(multiplied >= 1000000000l *\
    \ 100) return multiplied.abs * (unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] +\
    \ unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long] + unitDigits.last.asInstanceOf[Long]\
    \ + unitDigits.last.as", "        var result = 0\n        var minVal = a < b ?\
    \ a : b\n        var maxVal = a > b ? a : b\n        while(minVal > 0) result\
    \ += minVal % 10\n        minVal /= 10\n        while(maxVal > 0) {\n        \
    \    result += 1\n            maxVal /= 10\n        }\n        result", "    \
    \    var c = a * b\n        c > 1000000000000l \n            ? (c / 1000000000000l).asInstanceOf[Long]\n\
    \            : c", "        var c: Long = 1\n        // Rewrite this to avoid\
    \ using for-loops.\n        // Scan the integer from right to left\n        for\
    \ {\n            n <- b.toInt\n        } yield {\n            // Rewrite this\
    \ to avoid using for-loops.\n            // Scan the integer from right to left\n\
    \            for {\n                m <- a.toInt\n            } yield {\n    \
    \            c = c * ((10 * m) + (n)) % 10\n            }\n        }\n       \
    \ c", "        val result = a * b\n        val rem = a % b\n        val result2\
    \ = rem match {\n            case 0 => result\n            case _ => multiply(result,\
    \ rem)\n        }\n        result2", "        // Return a*b if both a and b are\
    \ non-zero, else return 0\n        if (a != 0 && b != 0) {\n            val unitDigit\
    \ = scala.math.roundToInt((a*b) / scala.math.pow(10, a.toInt))\n            return\
    \ ((a / scala.math.pow(10, a.toInt)).toInt*(b / scala.math.pow(10, b.toInt))).toLong*unitDigit\n\
    \        } else { return 0 }", "      // Complete this function\n      val sum\
    \ = a * b\n      val unitDigit = sum % 10\n      val result = math.abs(sum - math.pow(10,\
    \ unitDigit))\n      result / 10", "        val unitDigits = a.toString.toLong\
    \ / b.toString.toLong\n        val remainder = a.toString.toLong % b.toString.toLong\n\
    \        val resultDigits = remainder % 10\n        val unitDigits = unitDigits\
    \ + resultDigits\n        unitDigits", "        val mul = (a / b).floor\n    \
    \    val diff = a - mul * b\n        (mul * b + diff).mod(10).div(10)", "    \
    \    var c : Long = 0\n        val div = a / 10\n        var remainder = a % 10\n\
    \        val div2 = b / 10\n        var remainder2 = b % 10\n        remainder2\
    \ = remainder2 % 10\n        \n        remainder = remainder2\n        \n    \
    \    while(remainder != 0){\n            c = c + remainder\n            remainder\
    \ = remainder / 10\n        }\n        \n        c = c + (div2 * remainder2)\n\
    \        c = c + (div * remainder)\n        return c", "        val product =\
    \ a match {\n            case 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 => b\n   \
    \         case a => a * b\n            case _ => 0\n        }\n        product",
  "        if (b == 0) return a\n        if ((a % 10 == 0) && (b % 10 == 0)) (b /\
    \ 10) * a\n        else (a / 10) * (b / 10)", "        val aList = a.toString().toUpperCase().chars().toList\n\
    \        val bList = b.toString().toUpperCase().chars().toList\n        val x\
    \ = aList.zip(bList).map(x => (x._1 * x._2))\n        x.reduce((a, b) => a * b)",
  "        val aDigits = a / 1000000000000\n        val bDigits = b / 1000000000000\n\
    \        val aRem = a % 1000000000000\n        val bRem = b % 1000000000000\n\
    \        if(aRem < bRem) (aDigits * bDigits + aRem * bRem) \n        else (bDigits\
    \ * aDigits + bRem * aRem)", "        val units = getUnits(a).union(getUnits(b)).toSet\n\
    \        \n        var product = 0l\n        var unit = 0\n        \n        while\
    \ (unit < units.length){\n            val unit = units(unit)\n            product\
    \ += (a / Math.pow(10, unit)).longValue()\n            a %= Math.pow(10, unit)\n\
    \            b *= 10\n            unit += 1\n        }\n        \n        product",
  '        // Your code here', "    \tval unitA = a.toString.toInt\n    \tval unitB\
    \ = b.toString.toInt\n    \tif (unitA==0 && unitB==0) 0\n    \telse unitA*unitB",
  "        if (a > 0 || b > 0) {\n            val a2 = a / 10\n            val b2\
    \ = b / 10\n            val unitProduct = a2 * b2\n            val lastDigit =\
    \ a % 10\n            val lastDigit2 = b % 10\n            if (lastDigit == lastDigit2)\
    \ {\n                multiply(unitProduct, lastDigit2)\n            } else {\n\
    \                multiply(unitProduct, lastDigit)\n            }\n        } else\
    \ {\n            0\n        }", "        val factors = computeFactors(a)\n   \
    \     val remainders = computeRemainders(b)\n        val products = factors map\
    \ (f => remainders filter (r => r.asInstanceOf[Int] % f == 0)) map (_ foldLeft\
    \ 1(_))\n        products.sum", "        val product = a / 10 * b\n        val\
    \ digit = a % 10\n        product * digit + product * 10 - digit", "        var\
    \ prod = 0\n        for( i <- 0 until a ) {\n            prod *= a.toInt\n   \
    \     }\n        for( i <- 0 until b ) {\n            prod *= b.toInt\n      \
    \  }\n        prod", "        def multiply(a : Long, b : Long) : Long = {\n  \
    \          val res : Long = 0\n            while (a > 0) {\n                res\
    \ += a%10\n                a /= 10\n            }\n            while (a > 0) {\n\
    \                res *= b\n                b /= 10\n            }\n          \
    \  res\n        }\n        multiply(a, b).abs", "        // Write your code here\n\
    \        var aInt = a.toInt\n        var bInt = b.toInt\n        var res = BigInt(0)\n\
    \        var i = -1\n        while (i < bInt && aInt != 0){\n            res =\
    \ res * 10 + aInt\n            i = i + 1\n        }\n        while (i < aInt &&\
    \ bInt != 0){\n            res = res * 10 + bInt\n            i = i + 1\n    \
    \    }\n        return res", "       val unitA = (a.toInt % 10).toLong\n     \
    \  val unitB = (b.toInt % 10).toLong\n       if (unitA == 0 && unitB == 0) 0\n\
    \       else (unitA * unitB).div(10)", "       val result = 0\n       val arr\
    \ = Array(a,b)\n       arr.sortWith( _ > _ ) // Sort from biggest to smallest\n\
    \       arr.tail.foreach(x => result *= x) // Multiply all units within array\n\
    \       result", "        def sum(c: Long, d: Long): Long = {\n            val\
    \ a1 = c % 10\n            val a2 = d % 10\n            var c1 = c\n         \
    \   var d2 = d\n            while(true) {\n                val s1 = c1 + d2 +\
    \ a1\n                val s2 = a2 + d1 + c2\n                val a3 = s1 + s2\n\
    \                val b1 = c1 + d2 + a3 + a1\n                val b2 = a2 + d1\
    \ + b1 + c2\n                val a4 = b1 + b2\n                val c3 = c1 + d2\
    \ + a4 + a1\n                val b3 = a2 + d1 + c3 + b1 + c2\n               \
    \ val c4 = b1 + b2 + c3\n                val d3 = c1 + d2 + c4 + a1\n        \
    \        val b4 = a2 + d1 + b3 + c3 + b1 + c2\n                val d4 = c1 + d2\
    \ + d4 + a1\n                val b5 = a2 + d1 + b5 + c3 + b1 + c4\n          \
    \      val d5 = c1 + d2 + d5 + a1\n                val b6 = a2 + d1 + b6 + c3\
    \ + b1 + c4 + d1\n                val d6 = c1 + d2 + d6 + a1\n               \
    \ val b7 = a2 + d1 + b7 + c3 + b1 + c4 + d1 + d2\n                val d7 = c1\
    \ + d2 + d7 + a1\n                val b8 = a2 + d1 + b8 + c3 + b1 + c4 + d1 +\
    \ d2 + d1\n                val d8 = c1 + d2 + d8 + a1\n                val b9\
    \ = a2 + d1 + b9 + c3 + b1 + c4 + d1 + d2 + d1 + d2\n                val d9 =\
    \ c1 + d2 + d9 + a1\n                val b10 = a2 + d1 + b10 + c3 + b1 + c4 +\
    \ d1 + d2 + d1 + d2 + d1\n                val d10 = c1 + d2 + d10 + a1\n     \
    \           val b11 = a2 + d1 + b11 + c3 + b1 + c4 + d1 + d2 + d1 + d2 + d1 +\
    \ d2\n                val d11 = c1 + d2 + d11 + a1\n                val b12 =\
    \ a2 + d1 + b12 + c3 + b1 + c4 + d1 + d2 + d1 + d2 + d1 + d2 + d1\n          \
    \      val d12 = c1 + d2 + d12 + a1\n                val b13 = a2 + d1 + b13 +\
    \ c3 + b1 + c4 + d1 + d2 + d1 + d2 + d1 + d2 + d1 + d2 + d1\n                val\
    \ d13 = c1 + d2 + d13 + a1\n                val b14 = a2 + d", "        var result\
    \ = a * b\n        var i = 2\n        while((result = result/10)) % 10 != 0 {\
    \ i ++ }\n        return i * result", "        if( a == 0l && b == 0l ) return\
    \ 0l\n        if( a == 0l && b != 0l ) throw new IllegalArgumentException(\"a\
    \ should be valid\")\n        if( b == 0l ) throw new IllegalArgumentException(\"\
    b should be valid\")\n        val unitDigits = BigDecimal(a/10l).toBigInteger.toString.reverse.grouped(2).toList\n\
    \        val result = BigDecimal(b/10l).toBigInteger.toString.reverse.grouped(2).toList\n\
    \        val product = result.foldLeft(BigInteger.valueOf(0))((acc, value) =>\
    \ acc * BigInteger.valueOf(value, unitDigits))\n        product.remainder(BigInteger.valueOf(10l,\
    \ unitDigits)).intValue()"]
stop_tokens:
- "\n    }\n"
