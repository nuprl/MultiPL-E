name: HumanEval_148_bf
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // There are eight planets in our solar system: the closerst to the Sun \n\
  \    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
  \    // Uranus, Neptune.\n    // Write a function that takes two planet names as\
  \ strings planet1 and planet2. \n    // The function should return a tuple containing\
  \ all planets whose orbits are \n    // located between the orbit of planet1 and\
  \ the orbit of planet2, sorted by \n    // the proximity to the sun. \n    // The\
  \ function should return an empty tuple if planet1 or planet2\n    // are not correct\
  \ planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"), (\"Neptune\"))\n\
  \    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"Earth\"), (\"Mercury\"\
  ))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"Mercury\"), (\"Uranus\"))\n\
  \    // (List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))\n\
  \    def bf(planet1 : String, planet2 : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"),\
  \ (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
  Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
  Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"\
  Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
  Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
  ), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"Earth\"\
  )).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\")).equals((List[String]())));\n\
  \    }\n\n}\n"
completions: ["        // Only change code below this line\n        val mercury =\
    \ List(\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"\
    )\n        val neptune = List(\"Neptune\")\n        val planets = mercury ++ planet1\
    \ :: neptune ++ planet2 :: mercury\n        val sun = List(\"Mercury\",\"Venus\"\
    ,\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        val\
    \ planet1 = planets.find(x => sun.contains(x))\n        val planet2 = planets.find(x\
    \ => !sun(x).contains(x))\n        val orbit1 = planet1.getOrElse(\"Mercury\"\
    )\n        val orbit2 = planet2.getOrElse(\"Mercury\")\n        (planets.filter(x\
    \ => (orbit1 > x && orbit1 < orbit2) && (orbit2 > x && orbit2 < orbit1)).toList).sortBy(x\
    \ => sun(x).distanceTo(planet1(x)))", "        // Your code goes here\n      \
    \  val planet = List(planet1, planet2)\n        def distance(p1: String, p2 :\
    \ String) : Int = {\n            var count = 0\n            if (p1 != p2) {\n\
    \                for( m <- 1 to 1000 if p1 == p2) count += m\n            }\n\
    \            count\n        }\n        val planetSet = Set(planet, planet.reverse)\n\
    \        val sun = distance(\"Earth\", \"Saturn\")\n        var orbits = ListBuffer[String]()\n\
    \        for( p <- planetSet) {\n            val p1 = p._1\n            val p2\
    \ = p._2\n            var count = 0\n            for( m <- 1 to 1000 if p1 ==\
    \ p2 && count < sun) count += m\n            orbits.append(p1 + \"->\" + p2 +\
    \ \",\" + count)\n        }\n        orbits.sortWith( distance(_, planet))\n \
    \       orbits.toList", "        val Planets = mutable.ListBuffer[String]()\n\
    \        for( p <- Planets ) p += planet1\n        for( p <- Planets ) p += planet2\n\
    \        Planets.toList.sortBy( x => x.indexOf( \"Sun\" ) )", "        val planet1orbit\
    \ = orbit(planet1)\n        val planet2orbit = orbit(planet2)\n        val planet1orbitPositions\
    \ = planet1orbit.map( p => (abs(p.longitude - planet2.longitude), abs(p.latitude\
    \ - planet2.latitude)))\n        val planet2orbitPositions = planet2orbit.map(\
    \ p => (abs(p.longitude - planet1.longitude), abs(p.latitude - planet1.latitude)))\n\
    \        val intersection = planet1orbitPositions intersect planet2orbitPositions\n\
    \        val list = (intersection map {case (dist1, dist2) => planet1} union intersection\
    \ map {case (dist1, dist2) => planet2}) sortBy (d => (d - abs(planet1.longitude\
    \ - planet2.longitude), abs(planet1.latitude - planet2.latitude)))\n        list.toList",
  "        var lst1 = List(planet1)\n        var lst2 = List(planet2)\n        val\
    \ planet = if (lst1.contains(planet2)) lst1 else lst2\n        var orbit1 = planet1\n\
    \        var orbit2 = planet2\n        val orbit = if (orbit1 == orbit2) orbit\
    \ else orbit2\n        while (lst != List(orbit)) lst = List(orbit)\n        lst",
  "        var result: mutable.Buffer[String] = mutable.Buffer.empty\n        val\
    \ planet1Orbit = (planet1.toUpperCase == \"EARTH\" ? 6 : planet1.toUpperCase ==\
    \ \"MARS\" ? 3 : planet1.toUpperCase == \"JUPITER\" ? 2 : planet1.toUpperCase\
    \ == \"SATURN\" ? 1 : planet1.toUpperCase == \"URANUS\" ? 0 : -1)\n        val\
    \ planet2Orbit = (planet2.toUpperCase == \"EARTH\" ? 6 : planet2.toUpperCase ==\
    \ \"MARS\" ? 3 : planet2.toUpperCase == \"JUPITER\" ? 2 : planet2.toUpperCase\
    \ == \"SATURN\" ? 1 : planet2.toUpperCase == \"URANUS\" ? 0 : -1)\n        var\
    \ distance = planet1Orbit - planet2Orbit\n        for (i <- 0 to distance) {\n\
    \            if (planet1Orbit == planet2Orbit) {\n                result = (result\
    \ :+ planet1).sortBy(x => (x.toUpperCase == \"EARTH\" ? 6 : x.toUpperCase == \"\
    MARS\" ? 3 : x.toUpperCase == \"JUPITER\" ? 2 : x.toUpperCase == \"SATURN\" ?\
    \ 1 : x.toUpperCase == \"URANUS\" ? 0 : -1));\n            }\n            else\
    \ if (planet1Orbit > planet2Orbit) {\n                distance -= 1;\n       \
    \     }\n            else {\n                distance += 1;\n            }\n \
    \       }\n        result.toList", "        var list: List[String] = Nil\n   \
    \     for ( i <- 1 to planet1 length if planet1 == planet2(i)) list += planet1(i-1)\n\
    \        if (planet2.toInt == planet1.toInt) list += planet1\n        return list",
  "        var planets = Set(planet1, planet2)\n        while(planets.size > 2) {\n\
    \            planets -= Set(planets.last, planets.last)\n        }\n        planets\
    \ :: Set(planets.last)", "        if (planet1 == planet2) List(planet1)\n    \
    \    else if (planet1 == \"\" ) List()\n        else if planet2 == \"\" ) List()\n\
    \        else if (planet1.contains(planet2)){ \n            val names_between\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between2\
    \ = \n                planet2.filter(planet1.contains)\n            val names_between3\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between4\
    \ = \n                planet2.filter(planet1.contains)\n            val names_between5\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between6\
    \ = \n                planet2.filter(planet1.contains)\n            val names_between7\
    \ = \n                planet1.filter(planet2.contains)\n            val names_between8\
    \ = \n                planet2.filter(planet1.contains)\n            names_between.filter(!planet2.contains)\n\
    \        }\n        else None", "        var planet1 = planet1\n        var planet2\
    \ = planet2\n        planet1 match {\n            case planet2 if planet1.isEmpty\
    \ = planet2 => List((planet2))\n            case planet2 if planet1.isEmpty =>\
    \ List()\n            case _ => List()\n        }", "        if(planet1 == null\
    \ || planet2 == null) return List()\n        val orbit1 = Orbit.of(planet1)\n\
    \        val orbit2 = Orbit.of(planet2)\n        // The return value is a list\
    \ containing all the planets\n        // whose orbits lie between the two planets.\
    \ \n        // The distance between the planets is measured by\n        // Eucledean\
    \ distance. \n        val dist1 = orbit1.distance(orbit2)\n        val dist2 =\
    \ orbit2.distance(orbit1)\n        val distanceList = ListBuffer[Double]()\n \
    \       for(i <- 1 to dist1) {\n            distanceList += i\n        }\n   \
    \     for(i <- 1 to dist2) {\n            distanceList += i\n        }\n     \
    \   val orderedList = distanceList.sortBy(distance(_))\n        orderedList.takeWhile(distance(_)\
    \ <= orbit1.distance(orbit2))", "        def distance(planet1 : String, planet2\
    \ : String) : Double = {\n            // Write your code here\n            val\
    \ sun = SunPosition.getInstance()\n            val sun_distance = sun.distance(planet1,\
    \ planet2)\n            val planet_distance = sun.distance(planet1, planet2)\n\
    \            val planet_position = sun_distance.toDouble / (2 * planet_distance)\n\
    \            planet_position.toInt\n        }\n        \n        def isClosestToSun(planet1\
    \ : String, planet2 : String) : Boolean = {\n            // Write your code here\n\
    \            val sun = SunPosition.getInstance()\n            val sun_distance\
    \ = sun.distance(planet1, planet2)\n            val planet_distance = sun.distance(planet1,\
    \ planet2)\n            val planet_position = sun_distance.toDouble / (2 * planet_distance)\n\
    \            planet_position.toInt <= 1\n        }\n        \n        def getPlanets(planet1\
    \ : String, planet2 : String) : List[String] = {\n            // Write your code\
    \ here\n            val sun = SunPosition.getInstance()\n            val sun_distance\
    \ = sun.distance(planet1, planet2)\n            val planet_distance = sun.distance(planet1,\
    \ planet2)\n            val planet_position = sun_distance.toDouble / (2 * planet_distance)\n\
    \            val planets = List(planet1, planet2)\n            if(planet_position.toInt\
    \ < 1){\n                planets\n            } else {\n                planets.filter(!isClosestToSun(planet1,\
    \ planet2))\n            }\n        }\n        \n        def getClosestToSun(planet1\
    \ : String, planet2 : String) : List[String] = {\n            // Write your code\
    \ here\n            val sun = SunPosition.getInstance()\n            val sun_distance\
    \ = sun.distance(planet1, planet2)\n            val planet_distance = sun.distance(planet1,\
    \ planet2)\n            val planet_position = sun_distance.toDouble / (2 * planet_distance)\n\
    \            val planets = List(planet1, planet2)\n            if(planet_position.toInt\
    \ <= 1){\n                planets\n            } else {\n                planets.filter(!isClosestToSun(planet1,\
    \ planet2))\n            }\n        }\n        \n        def getClosestToSun(planet1\
    \ : String, planet2 : String) : List[String] = {\n            // Write your code\
    \ here\n            val sun = SunPosition.getInstance()\n            val sun_distance\
    \ = sun.distance(planet1, planet2)\n            val planet_distance = sun.distance(planet1,\
    \ planet2)\n", "        val planetsBetween = {\n            val sun = new Planet(Sun)\n\
    \            val earth = new Planet(Earth)\n            val venus = new Planet(Venus)\n\
    \            val mercury = new Planet(Mercury)\n            val jupiter = new\
    \ Planet(Jupiter)\n            val saturn = new Planet(Saturn)\n            val\
    \ uranus = new Planet(Uranus)\n            val neptune = new Planet(Neptune)\n\
    \            val earthOrbit = sun.orbit(planet2)\n            val venusOrbit =\
    \ venus.orbit(planet2)\n            val mercuryOrbit = mercury.orbit(planet2)\n\
    \            val jupiterOrbit = jupiter.orbit(planet2)\n            val saturnOrbit\
    \ = saturn.orbit(planet2)\n            val uranusOrbit = uranus.orbit(planet2)\n\
    \            val neptuneOrbit = neptune.orbit(planet2)\n            val earthOrbitInEarth\
    \ = sun.isOrbitInOrbit(earth, earthOrbit)\n            val venusOrbitInVenus =\
    \ sun.isOrbitInOrbit(venus, venusOrbit)\n            val mercuryOrbitInMercury\
    \ = sun.isOrbitInOrbit(mercury, mercuryOrbit)\n            val jupiterOrbitInJupiter\
    \ = sun.isOrbitInOrbit(jupiter, jupiterOrbit)\n            val saturnOrbitInSaturn\
    \ = sun.isOrbitInOrbit(saturn, saturnOrbit)\n            val uranusOrbitInUranus\
    \ = sun.isOrbitInOrbit(uranus, uranusOrbit)\n            val neptuneOrbitInNeptune\
    \ = sun.isOrbitInOrbit(neptune, neptuneOrbit)\n            (earthOrbitInEarth,\
    \ venusOrbitInVenus, mercuryOrbitInMercury, \n            jupiterOrbitInJupiter,\
    \ saturnOrbitInSaturn, uranusOrbitInUranus, \n            neptuneOrbitInNeptune)\n\
    \        }\n        val planetsToAdd = planetsBetween.foldLeft(List[String]())\
    \ {\n            (acc, ", "        var list : List[String] = Nil\n        var\
    \ sunPosition = math.atan2(Double.NaN, Double.NaN)\n        var orbit1 : Double\
    \ = Double.NaN\n        var orbit2 : Double = Double.NaN\n        var planet1Orbit\
    \ : Double = Double.NaN\n        var planet2Orbit : Double = Double.NaN\n    \
    \    var orbitDistance : Double = Double.NaN\n        var planetDistance : Double\
    \ = Double.NaN\n        var planet1OrbitOrbitDistance : Double = Double.NaN\n\
    \        var planet2OrbitOrbitDistance : Double = Double.NaN\n        // We have\
    \ to handle if both planets are sun\n        if (planet1 == planet2) {\n     \
    \       return Nil\n        } else {\n            var sun : Double = math.atan2(Double.NaN,\
    \ Double.NaN)\n            var sunDistance : Double = Double.NaN\n           \
    \ // We have to handle if both planets are not sun\n            if (planet1 !=\
    \ \"Sun\") {\n                // Get the orbit of planet1\n                planet1Orbit\
    \ = planet1Orbit(planet1)\n                // Get the orbit of planet2\n     \
    \           planet2Orbit = planet2Orbit(planet2)\n                // We have to\
    \ handle if both planets are not sun\n                if (planet1 != planet2)\
    \ {\n                    // Get the distance between planets\n               \
    \     planetDistance = planetDistance(planet1, planet2)\n                    //\
    \ We have to handle if both planets are not sun\n                    if (planet1\
    \ != planet2) {\n                        // Get the orbit distance between planets\n\
    \                        planet1OrbitOrbitDistance = planet1OrbitOrbitDistance(planet1,\
    \ planet2)\n                        // Get the orbit distance between planets\n\
    \                        planet2OrbitOrbitDistance = planet2OrbitOrbitDistance(planet2,\
    \ planet1)\n                        // Get the sun position\n                \
    \        sunPosition = sunPosition(planet1, planet2)\n                       \
    \ // We have to handle if both planets are not sun\n                        if\
    \ (planet1 != planet2) {\n                            // Get the distance between\
    \ planets\n                            orbitDistance = orbitDistance(planet1,\
    \ planet2)\n                            // If the distance is less than sun distance\n\
    \                            if (orbitDistance < planet1OrbitOrbitDistance) {\n\
    \                                // If the orbit of planet1 is between the orbit\
    \ of planet2\n                                if (orbit1 > planet2Orbit) {\n \
    \                                   // We have to handle if both planets are not\
    \ sun\n                                    if (planet1 != planet2) {", "     \
    \   // Write your code here\n        val planetNames = Seq(planet1, planet2)\n\
    \        val sun = Planet.calculateSun(planetNames)\n        var planet1Orbit\
    \ = Planet.calculateOrbit(planetNames)\n        var planet2Orbit = Planet.calculateOrbit(planetNames)\n\
    \        for( i<- 0 to planet1Orbit.length - 1){\n            if(planet1Orbit(i)>sun){\n\
    \                planet1Orbit(i+1)=planet1Orbit(i)-sun\n            }\n      \
    \  }\n        for( i<- 0 to planet2Orbit.length - 1){\n            if(planet2Orbit(i)>sun){\n\
    \                planet2Orbit(i+1)=planet2Orbit(i)-sun\n            }\n      \
    \  }\n        val proximity = List(planet1Orbit, planet2Orbit).zipWithIndex.sortWith(_._1\
    \ > _._1)\n        proximity(0)._2 :: proximity(1)._2", "        val orbits1 =\
    \ getOrbits(planet1)\n        val orbits2 = getOrbits(planet2)\n        val orbits1\
    \ = orbits1.toList\n        val orbits2 = orbits2.toList\n        val result =\
    \ orbits1.zip(orbits2).filter {\n            case (l,r) => l.distance(r) < 1\n\
    \        }\n        result.sortWith(_.distance(_) < 1).map { case (l, r) => l\
    \ }.flatMap(List(_))", "        // Write your code here\n\n        val planet1Orbits\
    \ = List(List(\"Mercury\", \"Venus\"), List(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"))\n        val planet2Orbits = List(List(\"\
    Mercury\", \"Venus\"), List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"))\n\n        val planet1Distance = planet1Orbits.map{\n        orb\
    \ => orb.map{ o2 => \n            math.pow(math.pow(o2 - planet1Orbits(0), 2)\
    \ + math.pow(o2 - planet1Orbits(1), 2), 0.5)\n        }.min}\n        val planet2Distance\
    \ = planet2Orbits.map{\n        orb => orb.map{ o2 => \n            math.pow(math.pow(o2\
    \ - planet2Orbits(0), 2) + math.pow(o2 - planet2Orbits(1), 2), 0.5)\n        }.min}\n\
    \n        val distance = math.pow(planet1Distance + planet2Distance, 0.5)\n\n\
    \        if (distance < 5.0) (planet1, planet2)\n        else if (distance < 5.0)\
    \ (planet2, planet1)\n        else ()", "        \n        // Create mutable set\
    \ of planets \n        val planetSet = mutable.Set[String]()\n        planetSet\
    \ += planet1\n        planetSet += planet2\n        \n        // Create mutable\
    \ set of orbit of planets\n        val orbitSet = mutable.Set[String]()\n    \
    \    orbitSet += planet1\n        orbitSet += planet2\n        \n        // Create\
    \ mutable set of closest planet\n        val closestPlanet = mutable.Set[String]()\n\
    \        \n        // Iterate over each planet in set 1 \n        planetSet.foreach(\
    \ x =>\n        // Add each planet in set 2 to the set \n        orbitSet += x)\n\
    \        // Remove each planet from set 1\n        orbitSet -= planet1\n     \
    \   // Iterate over each planet in set 2\n        orbitSet.foreach( x =>\n   \
    \     // If each planet is in set 1, add it to set 2 and remove it from set 1\n\
    \        if (planetSet.contains(x)){\n            closestPlanet += x\n       \
    \     orbitSet -= x\n        }\n        )\n        \n        // Return sorted\
    \ list by proximity to Sun\n        closestPlanet.sortBy(x => math.abs(x.hashCode())\
    \ % 7)", "        var planet1Orbit : OrbitalPlanet = OrbitalPlanet(planet1)\n\
    \        var planet2Orbit : OrbitalPlanet = OrbitalPlanet(planet2)\n        var\
    \ orbitingPlanets : List[String] = List()\n\n        while(planet1Orbit.getOrbits(planet2Orbit)\
    \ > 0){\n            orbitingPlanets = orbitingPlanets ::: List(planet1Orbit.getName())\n\
    \            planet1Orbit = planet1Orbit.getNextPlanet()\n            planet2Orbit\
    \ = planet2Orbit.getNextPlanet()\n        }\n\n        return orbitingPlanets.sortWith(_\
    \ < _)", "        val l1 = planets.filter(x => x._1 == planet1).length\n     \
    \   val l2 = planets.filter(x => x._2 == planet2).length\n        if (l1 == 0)\
    \ List() else if (l2 == 0) List() else if (l1 > l2) List(planet2) else List(planet1)",
  "        val planets = List(planet1, planet2)\n        planets match {\n       \
    \     case List() => List()\n            case x :: xs => planets.filter( y =>\
    \ x < y).sortWith(_ > _).filter(_ != planet1).filter(_ != planet2).toList\n  \
    \      }", "    // Write your code here\n    val sun = JS.Math.toRadians(JS.Math.PI/4)\n\
    \    val planetNames = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n    if (planetNames.contains(planet1)\
    \ && planetNames.contains(planet2)) {\n        val sun1 = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)+1),\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val sun2 = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n        val earthOrbit = JS.Math.toRadians(JS.Math.PI\
    \ * 0.5)\n        val earth = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1))-1,\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val mars = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2))+1,\
    \ planetNames(planetNames.indexOf(planet1)))))\n        val jupiter = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)),\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val saturn = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n        val uranus = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet1)),\
    \ planetNames(planetNames.indexOf(planet2)))))\n        val neptune = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(planetNames(planetNames.indexOf(planet2)),\
    \ planetNames(planetNames.indexOf(planet1)))))\n        var i = 0\n        while\
    \ (i < planetNames.indexOf(planet2)) {\n            val orb1 = JS.Math.toRadians(JS.Math.toDegrees(JS.Math.atan2(",
  "        if(planet1 == null || planet1 == \"\" || planet2 == null || planet2 ==\
    \ \"\") Empty\n        else {\n            val a1 = calculatePlanetOrbit(planet1)\n\
    \            val a2 = calculatePlanetOrbit(planet2)\n            val a3 = calculateProximity(a1,\
    \ a2)\n            val b1 = calculatePlanetOrbit(planet2)\n            val b2\
    \ = calculatePlanetOrbit(planet1)\n            val b3 = calculateProximity(b1,\
    \ b2)\n            a3 ++ b3\n        }", "        var list : mutable.Set[String]\
    \ = mutable.Set()\n        var planet1orbit : String = planet1\n        var planet2orbit\
    \ : String = planet2\n        var planet1orbit : Double\n        var planet2orbit\
    \ : Double\n        var planet1orbit : Double\n        var planet2orbit : Double\n\
    \        \n        // The first step of the algorithm. \n        // The planet\
    \ names are sorted alphabetically in the variable list\n        // by taking the\
    \ last element of the String (the planet name with \n        // the lowest index).\
    \ If planet1orbit is the last element in the \n        // String list (which means\
    \ that planet1 is the first element in the \n        // String list), then planet1orbit\
    \ and planet2orbit have the same \n        // value. \n        // If the planet1orbit\
    \ is not the last, then we put it first in the \n        // list. \n        if(planet1.last.equals(planet2.last)){\n\
    \            list = list.union(planet1.last)\n        }\n        else{\n     \
    \       list = list.union(planet2.last)\n        }\n        list = list.union(planet1)\n\
    \        \n        // The second step of the algorithm. \n        // We first\
    \ calculate the orbital distance between planet1 and planet2. \n        // This\
    \ is done by using the distance formula. \n        // The variable distant is\
    \ assigned the value 0.0. \n        // We can then find the smallest value in\
    \ this list by using a \n        // for loop. \n        // The variable smallest\
    \ is assigned the value of the first element \n        // in the list. \n    \
    \    for(i<- 1 to list.size){\n            planet1orbit = math.pow(math.pow((math.pow(planet2orbit,2)-math.pow(planet1orbit,2)),\
    \ 0.5), 1/2)\n            if(planet1orbit < smallest){\n                smallest\
    \ = planet1orbit\n            }\n        }\n        // The third step of the algorithm.\
    \ \n        // We now calculate the orbit of planet1 and planet2 and add them\
    \ to the list. \n        for(i<- 1 to list.size){\n            planet1orbit =\
    \ math.pow(math.pow((math.pow(planet2orbit,2)-math.pow(planet1orbit,2)), 0.5),\
    \ 1/2)\n            list.add(planet1orbit.toString)\n        }\n        \n   \
    \     // The fourth step of the algorithm. \n        // The list is now sorted\
    \ in ascending order, so we remove the first element \n        // from the list.\
    \ \n        list = list.drop(1)\n        \n        // The fifth step of the algorithm.\
    \ \n        // We now calculate the orbit of planet", "        val distList: List[Double]\
    \ = \n            List(Mercury.orbits.toSeq, Venus.orbits.toSeq, Earth.orbits.toSeq,\
    \ Mars.orbits.toSeq, Jupiter.orbits.toSeq, \n                    Saturn.orbits.toSeq,\
    \ Uranus.orbits.toSeq, Neptune.orbits.toSeq)\n            .map(f => { \n     \
    \           f.filter(f => f.equals(planet1) || f.equals(planet2)).map(f => f.orbit.getOrbit.getOrbit.getDistance\
    \ - sun.orbit.getOrbit.getDistance)\n            }.toList)\n            .reduce((l,\
    \ r) => l.toSeq ++ r.toSeq)\n        distList.filter(f => f > 0.0).sortBy(f =>\
    \ math.abs(f / sun.getOrbit.getOrbit.getDistance - 1))", "        val orbits =\
    \ scala.collection.mutable.ListBuffer.empty[String]\n        var flag = false\n\
    \        var i = 0\n        for(i <- 0 to 8){\n            if(planet1.equals(s\"\
    $i\")){\n                flag = true\n            }\n            else if(planet2.equals(s\"\
    $i\")){\n                flag = true\n            }\n            else if(!flag){\n\
    \                orbits.append(s\"$i\")\n            }\n        }\n        orbits.sortWith((x:\
    \ String, y: String) => x.charAt(0) - y.charAt(0))\n        val tempArray = orbits.toArray\n\
    \        val returnArray = Array.ofDim[String](tempArray.size)\n        for (i<-\
    \ 0 to tempArray.size)\n        {\n            if(i == tempArray.size-1){\n  \
    \              returnArray(i) = tempArray(i)\n            }\n            else{\n\
    \                returnArray(i) = tempArray(i) + tempArray(i+1)\n            }\n\
    \        }\n        returnArray.sorted", "        if (planet1.toUpperCase == \"\
    SATURN\") planet1.toUpperCase()\n        else if (planet1.toUpperCase == \"URANUS\"\
    ) planet1.toUpperCase()\n        else if (planet1.toUpperCase == \"NEPTUNE\")\
    \ planet1.toUpperCase()\n        else if (planet2.toUpperCase == \"MERCURY\")\
    \ planet2.toUpperCase()\n        else if (planet2.toUpperCase == \"VENUS\") planet2.toUpperCase()\n\
    \        else if (planet2.toUpperCase == \"EARTH\") planet2.toUpperCase()\n  \
    \      else if (planet2.toUpperCase == \"MARS\") planet2.toUpperCase()\n     \
    \   else if (planet2.toUpperCase == \"JUPITER\") planet2.toUpperCase()\n     \
    \   else if (planet2.toUpperCase == \"SATURN\") planet2.toUpperCase()\n      \
    \  else if (planet2.toUpperCase == \"URANUS\") planet2.toUpperCase()\n       \
    \ else if (planet2.toUpperCase == \"NEPTUNE\") planet2.toUpperCase()\n       \
    \ else ()", "        def planetOther(p1 : String) : List[String] = p1 :: Nil\n\
    \        def planetOther2(name : String) : List[String] = Nil\n        val planet1Orbit\
    \ = planet1.toUpperCase\n        val planet2Orbit = planet2.toUpperCase\n    \
    \    if (planet1Orbit.equals(\"MERCURY\") && planet2Orbit.equals(\"NEPTUNE\"))\
    \ {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase :: Nil)\n\
    \        } else if (planet1Orbit.equals(\"EARTH\") && planet2Orbit.equals(\"MARS\"\
    )) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase :: Nil)\n\
    \        } else if (planet1Orbit.equals(\"JUPITER\") && planet2Orbit.equals(\"\
    SATURN\")) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase\
    \ :: Nil)\n        } else if (planet1Orbit.equals(\"NEPTUNE\") && planet2Orbit.equals(\"\
    URANUS\")) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase\
    \ :: Nil)\n        } else if (planet1Orbit.equals(\"NEPTUNE\") && planet2Orbit.equals(\"\
    URANUS\")) {\n            (planet1Orbit.toUpperCase :: planet2Orbit.toUpperCase\
    \ :: Nil)\n        } else {\n            ()\n        }", "        val orbit1 =\
    \ Orbital(planet1)\n        val orbit2 = Orbital(planet2)\n        val orbitList\
    \ = List(orbit1, orbit2)\n        val earthOrbit = orbitList._1\n        val mercuryOrbit\
    \ = orbitList._2\n        val planetList = List(earthOrbit, mercuryOrbit)\n  \
    \      val distance = Vector.zero\n        var distanceTuple : List[String] =\
    \ Nil\n        var i = 0\n        while (i < planetList.size) {\n            val\
    \ planet = planetList(i)\n            val planetOrbit = Orbital(planet)\n    \
    \        val distanceToSun = planetOrbit.dist(planetOrbit.sun)\n            val\
    \ distanceToPlanet = planetOrbit.dist(planet)\n            if (distanceToSun >\
    \ distanceToPlanet) {\n                distanceTuple = planetOrbit.sun\n     \
    \           distance = 0\n            } else {\n                distance += distanceToPlanet\n\
    \            }\n            i += 1\n        }\n        if (distance < 1) {\n \
    \           return List()\n        }\n        distanceTuple.sortWith(_.dist(planet1)\
    \ <= _.dist(planet2))", "        def distance(planet1 : String, planet2 : String)\
    \ : Double = {\n            val p1 = Planet(planet1)\n            val p2 = Planet(planet2)\n\
    \            math.pow(p1.distance(p2), 2.0)\n        }\n        val p1 = Planet(planet1)\n\
    \        val p2 = Planet(planet2)\n        val sun = Planet(\"Sun\")\n       \
    \ val orbit1 = Orbit(p1, sun)\n        val orbit2 = Orbit(p2, sun)\n        val\
    \ orbit1List = List(orbit1, orbit2, orbit1, orbit1, orbit1, orbit1, orbit2, orbit2,\
    \ orbit2, orbit2, orbit1, orbit1, orbit1, orbit1)\n        val orbit2List = List(orbit2,\
    \ orbit1, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2, orbit2,\
    \ orbit2, orbit2, orbit2, orbit2, orbit2)\n        val planet1List = orbit1List\
    \ ::: orbit2List\n        val planet2List = orbit2List ::: orbit1List\n      \
    \  val planet1OrbitPairs = planet1List.groupBy(orbit1 => orbit1.name)\n      \
    \  val planet2OrbitPairs = planet2List.groupBy(orbit2 => orbit2.name)\n      \
    \  val planet1OrbitPairsList = planet1OrbitPairs.values.toList\n        val planet2OrbitPairsList\
    \ = planet2OrbitPairs.values.toList\n        val closest = math.pow(planet1.distance(planet2),\
    \ 2.0)\n        val closestPairs = planet1OrbitPairsList.zipWithIndex.filter {\
    \ case (orbit1, orbit2Index) => math.pow(orbit1.distance(orbit2), 2.0) == closest\
    \ }\n        val closestOrbitPairs = closestPairs.groupBy(_._2)\n        val closest\
    \ = closestOrbitPairs.values.toList\n        return closest", "        planet1\
    \ match {\n            case \"Earth\" => (\"Venus\", planet2)\n            case\
    \ \"Mercury\" => (\"Venus\", planet2)\n            case \"Venus\" => (\"Earth\"\
    , planet2)\n            case \"Mars\" => (\"Jupiter\", planet2)\n            case\
    \ \"Jupiter\" => (\"Saturn\", planet2)\n            case \"Saturn\" => (\"Uranus\"\
    , planet2)\n            case \"Uranus\" => (\"Neptune\", planet2)\n          \
    \  case \"Neptune\" => (\"Jupiter\", planet2)\n            case \"Mercury\" =>\
    \ List(planet2)\n            case _ => Nil\n        }", "        val orbit_planet1\
    \ = Orbit(planet1)\n        val orbit_planet2 = Orbit(planet2)\n        val sun\
    \ = Orbit(\"Sun\")\n        \n        // Calculate orbit of planet1\n        val\
    \ orbit_planet1_1 = orbit_planet1.earth_moon\n        val orbit_planet1_2 = orbit_planet1.sun\n\
    \        \n        // Calculate orbit of planet2\n        val orbit_planet2_1\
    \ = orbit_planet2.earth_moon\n        val orbit_planet2_2 = orbit_planet2.sun\n\
    \        \n        // For planet1, find orbit of planet2\n        val orbit_planet1_2_1\
    \ = orbit_planet1_2.earth_moon\n        val orbit_planet1_2_2 = orbit_planet1_2.sun\n\
    \        \n        // For planet2, find orbit of planet1\n        val orbit_planet2_1_1\
    \ = orbit_planet2_1.earth_moon\n        val orbit_planet2_1_2 = orbit_planet2_1.sun\n\
    \        \n        // Calculate distance\n        val distance12 = Vector3.distance(orbit_planet1_2.position,\n\
    \                                       orbit_planet1_2.position)\n        val\
    \ distance21 = Vector3.distance(orbit_planet1_2.position,\n                  \
    \                     orbit_planet2_1.position)\n        val distance22 = Vector3.distance(orbit_planet2_1.position,\n\
    \                                       orbit_planet2_1.position)\n        val\
    \ distance121 = Vector3.distance(orbit_planet1_2.position,\n                 \
    \                       orbit_planet2_1.position)\n        val distance122 = Vector3.distance(orbit_planet1_2.position,\n\
    \                                        orbit_planet2_2.position)\n        val\
    \ distance1222 = Vector3.distance(orbit_planet1_2.position,\n                \
    \                         orbit_planet2_2.position)\n        \n        // Create\
    \ planets list\n        val planets12: List[String] = if (distance12 < distance21)\n\
    \                                        List(planet1, planet2)\n            \
    \                        else if (distance22 < distance121)\n                \
    \                        List(planet2, planet1)\n                            \
    \        else List()\n        val planets21: List[String] = if (distance12 < distance22)\n\
    \                                        List(planet2, planet1)\n            \
    \                        else if (distance22 < distance121)\n                \
    \                        List(planet1, planet2)\n                            \
    \        else List()\n        val planets121: List[String] = if (distance122 <\
    \ distance22", "        val planets = List(planet1, planet2)\n        val orbit1\
    \ = orbs(planet1)\n        val orbit2 = orbs(planet2)\n        val intersection\
    \ = orbit1.intersection(orbit2)\n        val distBetween = intersection.map(_.distanceTo(new\
    \ Point3d(0,0,1)))\n        val toList = intersection.toList\n        toList.sortWith(_.distanceTo(new\
    \ Point3d(0,0,1)) < _.distanceTo(new Point3d(0,0,1)))\n        toList", "    \
    \    var result : List[String] = Nil\n        var temp : List[String] = Nil\n\
    \        for(j <- 0 to 6) {\n            if((planet1.equals(Planet(j)).planet)\
    \ && \n              (planet2.equals(Planet(j+1)).planet)) {\n               \
    \ temp <- temp :+ Planet(j).name\n            }\n            if((planet2.equals(Planet(j)).planet)\
    \ && \n              (planet1.equals(Planet(j+1)).planet)) {\n               \
    \ temp <- temp :+ Planet(j+1).name\n            }\n        }\n        for(j <-\
    \ 0 to 6) {\n            if((temp.contains(Planet(j)).planet) && \n          \
    \    (temp.contains(Planet(j+1)).planet)) {\n                result <- result\
    \ :+ Planet(j).name\n            }\n            if((temp.contains(Planet(j+1)).planet)\
    \ && \n              (temp.contains(Planet(j)).planet)) {\n                result\
    \ <- result :+ Planet(j+1).name\n            }\n        }\n        result.sortWith((x,\
    \ y) => (x.compare(y)) * -1)\n        result", "        var planets1= List(planet1,\
    \ planet2)\n        var planets2= List(planet2, planet1)\n        while(planets1.nonEmpty\
    \ || planets2.nonEmpty) {\n            var planet1orbit = planets1.head\n    \
    \        var planet2orbit = planets2.head\n            planets1 :=  planets1.tail\n\
    \            planets2 :=  planets2.tail\n            if( planet1orbit == planet2orbit)\
    \ yield planet1orbit\n            else if( planet1orbit < planet2orbit) yield\
    \ {planets1; planet2orbit}\n            else {planet2orbit; planets1; planet1orbit}\n\
    \        }\n        List() ", "        def sortByProximity(planet1 : String, planet2\
    \ : String, \n                             orb1 : String, orb2 : String, sunO\
    \ : Double) :\n                                  (Double, List[String]) = {\n\
    \            val dO = orb1.longitude - orb2.longitude\n            val dS = sunO\
    \ - orb1.latitude\n            val dP = sunO - orb2.latitude\n            if (dS\
    \ < 0 || dP < 0) {\n                return (dS, List(planet1, planet2))\n    \
    \        } else if (dO < 0 || dS < 0 || dP < 0) {\n                return (dO,\
    \ List(planet1, planet2))\n            } else if (dO < 0 || dS < 0 || dP > 0)\
    \ {\n                return (dP, List(planet1, planet2))\n            } else if\
    \ (dS > 0 || dP > 0) {\n                return (dS, List(planet1, planet2))\n\
    \            } else if (dS > 0 || dP < 0) {\n                return (dP, List(planet1,\
    \ planet2))\n            }\n        }\n        val planets = List((\"Mercury\"\
    ), (\"Venus\"), (\"Earth\"), \n                          (\"Mars\"), (\"Jupiter\"\
    ), (\"Saturn\"), \n                          (\"Uranus\"), (\"Neptune\"))\n  \
    \      var result: List[String] = Nil\n        var sunO : Double = 7.292115 *\
    \ Math.cos(math.radians(23.439))\n        var orb1 : Double = 0.0\n        var\
    \ orb2 : Double = 0.0\n        for (planet <- planets) {\n            val d =\
    \ sortByProximity(planet1, planet2, planet, planet, sunO)\n            sunO =\
    \ d._1\n            if (sunO < 0.0) sunO = 0.0\n            orb1 = d._2(0).toDouble\n\
    \            orb2 = d._2(1).toDouble\n            if ((orb1 < 0.0 || orb1 > 360.0)\
    \ || (orb2 < 0.0 || orb2 > 360.0)) {\n                result += d._2.toList\n\
    \            } else {\n                if (orb1 > orb2) {\n                  \
    \  if (orb1 - orb2 < 0.0) {\n                        result += d._2.toList\n \
    \                   } else {\n                        result += d._2.toList.drop(1)\n\
    \                    }\n                } else {\n                    if (orb2\
    \ - orb1 < 0.0) {\n                        result += d._2.toList.drop(1)\n   \
    \                 } else {\n                        result += d._2.toList\n  \
    \                  }\n                }\n            }\n        }\n        return\
    \ result", "        var allPlanets = List.empty[String]\n        var earthOrbit\
    \ = Array.empty[Double]\n        var earthDist = List.empty[Double]\n        var\
    \ earthProxy = List.empty[Double]\n        var marsOrbit = Array.empty[Double]\n\
    \        var marsDist = List.empty[Double]\n        var marsProxy = List.empty[Double]\n\
    \        var jupOrbit = Array.empty[Double]\n        var jupDist = List.empty[Double]\n\
    \        var jupProxy = List.empty[Double]\n        var satOrbit = Array.empty[Double]\n\
    \        var satDist = List.empty[Double]\n        var satProxy = List.empty[Double]\n\
    \        var uranusOrbit = Array.empty[Double]\n        var uranusDist = List.empty[Double]\n\
    \        var uranusProxy = List.empty[Double]\n        var neptuneOrbit = Array.empty[Double]\n\
    \        var neptuneDist = List.empty[Double]\n        var neptuneProxy = List.empty[Double]\n\
    \        if(planet1 == planet2) {\n            allPlanets = List(\"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        }\n       \
    \ else {\n            allPlanets = List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\")\n        }\n        for(planet <- allPlanets) {\n            if(planet\
    \ == \"Earth\") {\n                earthOrbit = Array(4.3958, 6.67384)\n     \
    \           earthDist = List(53.7649, 60.7406)\n                earthProxy = List(46.5822,\
    \ 51.9722)\n            }\n            else if(planet == \"Mars\") {\n       \
    \         marsOrbit = Array(3.6338, 8.76764)\n                marsDist = List(59.4014,\
    \ 69.0953)\n                marsProxy = List(52.5039, 58.2778)\n            }\n\
    \            else if(planet == \"Jupiter\") {\n                jupOrbit = Array(3.1444,\
    \ 2.1765)\n                jupDist = List(68.9043, 73.4396)\n                jupProxy\
    \ = List(54.0114, 59.6463)\n            }\n            else if(planet == \"Saturn\"\
    ) {\n                satOrbit = Array(2.4496, 3.6234)\n                satDist\
    \ = List(54.5934, 58.0534)\n                satProxy = List(53.8893, 55.", " \
    \     val planets = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n      val dists = Map(\n          (\"\
    Mercury\", \"Venus\") -> 1,\n          (\"Mercury\", \"Earth\") -> 1.414,\n  \
    \        (\"Mercury\", \"Mars\") -> 0.881,\n          (\"Mercury\", \"Jupiter\"\
    ) -> 0.785,\n          (\"Mercury\", \"Saturn\") -> 0.612,\n          (\"Mercury\"\
    , \"Uranus\") -> 0.646,\n          (\"Mercury\", \"Neptune\") -> 0.646,\n    \
    \      (\"Venus\", \"Earth\") -> 1.414,\n          (\"Venus\", \"Mars\") -> 1.414,\n\
    \          (\"Venus\", \"Jupiter\") -> 1.414,\n          (\"Venus\", \"Saturn\"\
    ) -> 1.414,\n          (\"Venus\", \"Uranus\") -> 1.414,\n          (\"Venus\"\
    , \"Neptune\") -> 1.414,\n          (\"Earth\", \"Mars\") -> 0.881,\n        \
    \  (\"Earth\", \"Jupiter\") -> 0.785,\n          (\"Earth\", \"Saturn\") -> 0.612,\n\
    \          (\"Earth\", \"Uranus\") -> 0.646,\n          (\"Earth\", \"Neptune\"\
    ) -> 0.646,\n          (\"Mars\", \"Jupiter\") -> 0.881,\n          (\"Mars\"\
    , \"Saturn\") -> 0.612,\n          (\"Mars\", \"Uranus\") -> 0.646,\n        \
    \  (\"Mars\", \"Neptune\") -> 0.646,\n          (\"Jupiter\", \"Saturn\") -> 0.785,\n\
    \          (\"Jupiter\", \"Uranus\") -> 0.646,\n          (\"Jupiter\", \"Neptune\"\
    ) -> 0.646,\n          (\"Saturn\", \"Uranus\") -> 0.612,\n          (\"Saturn\"\
    , \"Neptune\") -> 0.646)\n      \n      def dist(planet1 : String, planet2 : String)\
    \ : Double = {\n        dists.get(planet1, planet2)\n      }\n\n      val orbits\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n      val orbits1 = orbits.map( o => (o, o))\n   \
    \   val orbits2 = orbits1.map( o => (o, o))\n      val orbits3 = orbits2.map(\
    \ o => (o, o))\n\n      val orbits1 = orbits.map( o => (", "        val p1 = List(planet1,planet2)\n\
    \        val p2 = List(planet2,planet1)\n        val orbit1 = orbit(p1,p2)\n \
    \       val orbit2 = orbit(p2,p1)\n        val orbits = List(orbit1, orbit2)\n\
    \        val sun = orbits.flatMap(planet => orbit(planet,List(planet)))\n    \
    \    sun match {\n            case Nil => List()\n            case x :: Nil =>\
    \ (x +: sun).sortWith((a,b) => b - a)\n            case x :: xs => x +: (xs ++\
    \ sun).sortWith((a,b) => b - a)\n        }", "        val planet1Orbit = orbit(planet1)\n\
    \        val planet2Orbit = orbit(planet2)\n        val proximity = proximity(planet1Orbit,\
    \ planet2Orbit)\n        proximity.toList.sortBy(x => x)", "        val planet1\
    \ = planet1.toUpperCase()\n        val planet2 = planet2.toUpperCase()\n     \
    \   val planets = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        val planets = planets.toSet\n\
    \        val planet1 = planets(planets.indexOf(planet1))\n        val planet2\
    \ = planets(planets.indexOf(planet2))\n        val sun = Orbits(0.0, 0.0, 0.0)\n\
    \        val orbit = Orbits(planet1.ra(), planet1.dec(), sun.dec)\n        var\
    \ orbits = orbit.orbits\n        var a = 0.0\n        var b = 0.0\n        var\
    \ c = 0.0\n        var d = 0.0\n        var x = 0.0\n        var y = 0.0\n   \
    \     var z = 0.0\n        var d = orbits(planets.indexOf(planet1))\n        var\
    \ e = 0\n        var f = orbits(planets.indexOf(planet2))\n        while (e <\
    \ orbits.size) {\n            while (f < orbits.size && orbits(f) < d) {\n   \
    \             f = f + 1\n            }\n            d = d\n            while (a\
    \ < orbits.size) {\n                while (c < orbits.size && orbits(c) < d &&\
    \ orbits(a) < d) {\n                    c = c + 1\n                }\n       \
    \         d = d\n                while (x < orbits.size) {\n                 \
    \   while (y < orbits.size && orbits(y) < d && orbits(x) < d) {\n            \
    \            y = y + 1\n                    }\n                    d = d\n   \
    \                 while (z < orbits.size) {\n                        while (y\
    \ < orbits.size && orbits(y) < d && orbits(z) < d) {\n                       \
    \     y = y + 1\n                        }\n                        d = d\n  \
    \                      if (orbits(a) < d) {\n                            x = x\
    \ + 1\n                        }\n                        if (orbits(b) < d) {\n\
    \                            z = z + 1\n                        }\n          \
    \              if (orbits(c) < d) {\n                            z = z + 1\n \
    \                       }\n                        if (orbits(d) < d) {\n    \
    \                        x = x + 1\n                        }\n              \
    \          if (y >= orbits.size) {\n                            a = 0\n      \
    \                      b = 0\n                            c = 0\n            \
    \                d = 0.0\n                            x = 0.0\n              \
    \              y = 0.0\n                            z = 0.0\n                \
    \        }\n                    }\n                }\n            }\n        \
    \    orbits = orbits.updated(e, d)\n            e = e + 1\n        }\n       \
    \ val planets = orbits.toList\n        val res = planets.filter(x => x.equals(sun.dec))\n\
    \        if (res.isEmpty) {\n            List[String]()\n        } else {\n  \
    \          res\n        }", "    val planets1 =  List(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    val planets2 =\
    \ List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\")\n    \n    var planets1 = planets1\n    var planets2 =\
    \ planets2\n    \n    if(planets1 == planets2) planets1 = List()\n    if(planets1\
    \ == List()) planets1 = planets2\n    if(planets2 == List()) planets2 = planets1\n\
    \    \n    if (planets1.contains(planet1) && planets2.contains(planet2)) {\n \
    \     val a = planets1.indexWhere(x => x == planet1)\n      val b = planets2.indexWhere(x\
    \ => x == planet2)\n      val sun = planets1(a).distanceTo(planets2(b))\n    \
    \  \n      val orbits = planets1 ++ planets2\n        .filterNot(x => x == planet1)\
    \ ++ planets2 ++ planets1\n        .filterNot(x => x == planet2)\n        .map(x\
    \ => (planets1(a).distanceTo(x) - sun, x))\n      \n      val sorted = orbits.sortBy(_._1).reverse\n\
    \      sorted.filter(!_._1 < 0)\n        .filter(!_._1 >= sun)\n        .map(x\
    \ => x._2)", "        // your code\n        var sun : Double = 0.0\n        var\
    \ planets : List[String] = Nil\n        var planet1 : List[String] = Nil\n   \
    \     var planet2 : List[String] = Nil\n        if (planet1.equals(planet2))\n\
    \        {\n            planet1 = List(\"Sun\")\n            planet2 = List(\"\
    Sun\")\n        }\n        if (planet1.contains(\"Sun\"))\n        {\n       \
    \     sun = Math.toRadians(planet1.indexOf(\"Sun\") + 1)\n            planet1\
    \ = planet1.filterNot(_.equals(\"Sun\"))\n        }\n        if (planet2.contains(\"\
    Sun\"))\n        {\n            sun = Math.toRadians(planet2.indexOf(\"Sun\")\
    \ + 1)\n            planet2 = planet2.filterNot(_.equals(\"Sun\"))\n        }\n\
    \        val distances = planet1 zip planet2 map { case (planet1, planet2) =>\n\
    \            val distance = Math.toRadians(math.pow(math.sin(planet2 - planet1),\
    \ 2))\n            distance\n        }\n        planet1 = planet1.sortBy(distance\
    \ compare sun)\n        planet2 = planet2.sortBy(distance compare sun)\n     \
    \   planets = planet1 ::: planet2\n        planets = planets.filterNot(_.equals(\"\
    Sun\"))\n        planets = planets.sorted\n        return planets", "        //\
    \ write your code here\n        \n        val planetsBetweenSunAndPlanet1 = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val planetsBetweenSunAndPlanet2 = List(\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var planets1 = planetsBetweenSunAndPlanet1.filter(_ == planet1)\n \
    \       var planets2 = planetsBetweenSunAndPlanet2.filter(_ == planet2)\n    \
    \    val orbsBetweenSunAndPlanet1 = List(\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val orbsBetweenSunAndPlanet2\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        val orbsBetweenPlanetAndPlanet1 = List(List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"), List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        val orbsBetweenPlanetAndPlanet2\
    \ = List(List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"), List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"))\n        \n        var planet1Orbs\
    \ : List[String] = List(planet1)\n        var planet2Orbs : List[String] = List(planet2)\n\
    \        val planetDistance = planet1Orbs.zip(planet2Orbs)\n        val distances\
    \ = planetDistance.filter(_._2 != 0)\n        val distanceForPlanet1 = distances.filter(_._1\
    \ == planet1).map(_._2).sum\n        val distanceForPlanet2 = distances.filter(_._1\
    \ == planet2).map(_._2).sum\n        val distanceToSun = distanceForPlanet1.map(\
    \ orb => math.pow(orb, 2) - math.pow(math.pow((orb - 1), 2) + math.pow((orb -\
    \ 2), 2), 0.5))\n        val distanceToSun2 = distanceForPlanet2.filter( orb =>\
    \ math.", "        var a = 0\n        var b = 5\n        var c = 0\n        var\
    \ d = 7\n        var e = 0\n        var f = 0\n        var g = 7\n        var\
    \ h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var\
    \ p = 8\n        var q = 7\n        var r = 0\n        var s = 0\n        var\
    \ t = 0\n        var u = 0\n        var v = 7\n        var w = 8\n        var\
    \ x = 0\n        var y = 0\n        var z = 8\n        val sun = Sun()\n     \
    \   var a = sun.getOrbitalDistance(planet1)\n        var b = sun.getOrbitalDistance(planet2)\n\
    \        var c = sun.getOrbitalDistance(planet2)\n        var d = sun.getOrbitalDistance(planet1)\n\
    \        var e = sun.getOrbitalDistance(planet1)\n        var f = sun.getOrbitalDistance(planet1)\n\
    \        var g = sun.getOrbitalDistance(planet2)\n        var h = sun.getOrbitalDistance(planet2)\n\
    \        var i = sun.getOrbitalDistance(planet2)\n        var j = sun.getOrbitalDistance(planet1)\n\
    \        var k = sun.getOrbitalDistance(planet1)\n        var l = sun.getOrbitalDistance(planet1)\n\
    \        var m = sun.getOrbitalDistance(planet2)\n        var n = sun.getOrbitalDistance(planet1)\n\
    \        var o = sun.getOrbitalDistance(planet1)\n        var p = sun.getOrbitalDistance(planet2)\n\
    \        var q = sun.getOrbitalDistance(planet2)\n        var r = sun.getOrbitalDistance(planet1)\n\
    \        var s = sun.getOrbitalDistance(planet1)\n        var t = sun.getOrbitalDistance(planet1)\n\
    \        var u = sun.getOrbitalDistance(planet1)\n        var v = sun.getOrbitalDistance(planet1)\n\
    \        var w = sun.getOrbitalDistance(planet1)\n        var x = sun.getOrbitalDistance(planet1)\n\
    \        var y = sun.getOrbitalDistance(planet1)\n        var z = sun.getOrbitalDistance(planet1)\n\
    \        if (planet1 == planet2) {\n            return (List(\"Mercury\", \"Saturn\"\
    , \"Uranus\", \"Neptune\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Venus\"\
    ))\n        }\n        val planets = List(\"Mercury\", \"Saturn\", \"Uranus\"\
    , \"Neptun", "        val planet1Orbit = orbit(planet1)\n        val planet2Orbit\
    \ = orbit(planet2)\n        val planetList = List(planet1, planet2)\n        val\
    \ planetList = planetList.map(planet => (planet, planetOrbit(planet)))\n     \
    \   val planetList1 = planetList.filter(_._1 == \"Earth\")\n        val planetList2\
    \ = planetList.filter(_._1 == \"Mercury\")\n        val planetList3 = planetList.filter(_._1\
    \ == \"Venus\")\n        val planetList4 = planetList.filter(_._1 == \"Mars\"\
    )\n        val planetList5 = planetList.filter(_._1 == \"Jupiter\")\n        val\
    \ planetList6 = planetList.filter(_._1 == \"Saturn\")\n        val planetList7\
    \ = planetList.filter(_._1 == \"Uranus\")\n        val planetList8 = planetList.filter(_._1\
    \ == \"Neptune\")\n        val planetList9 = planetList.filterNot(_._1 == \"Earth\"\
    )\n        val planetList10 = planetList.filterNot(_._1 == \"Mercury\")\n    \
    \    val planetList11 = planetList.filterNot(_._1 == \"Venus\")\n        val planetList12\
    \ = planetList.filterNot(_._1 == \"Mars\")\n        val planetList13 = planetList.filterNot(_._1\
    \ == \"Jupiter\")\n        val planetList14 = planetList.filterNot(_._1 == \"\
    Saturn\")\n        val planetList15 = planetList.filterNot(_._1 == \"Uranus\"\
    )\n        val planetList16 = planetList.filterNot(_._1 == \"Neptune\")\n\n  \
    \      val orbit1 = planet1Orbit.zip(planetList1).map{case (planet, orbit) =>\
    \ (planet, orbit)}.sortBy(_._2).map(_._1)\n        val orbit2 = planet2Orbit.zip(planetList2).map{case\
    \ (planet, orbit) => (planet, orbit)}.sortBy(_._2).map(_._1)\n        val orbit3\
    \ = planetList3.zip(planetList4).map{case (planet, orbit) => (planet, orbit)}.sortBy(_._2).map(_._1)\n\
    \        val orbit4 = planetList5.zip(planetList6).map{case (planet, orbit) =>\
    \ (planet, orbit)", "        // Create a list to store the planets\n        var\
    \ l : List[String] = Nil\n        val planets = List(planet1, planet2)\n     \
    \   for(planet <- planets){ // Iterate over each planet\n            // Get the\
    \ orbit for planet1 and planet2\n            val orbit1 = PlanetOrbit(planet,\
    \ planet1)\n            val orbit2 = PlanetOrbit(planet, planet2)\n          \
    \  // Find the distance between these two orbits\n            val d = orbit1.distanceTo(orbit2)\n\
    \            // If the distance is less than or equal to 1 the add it to a new\
    \ list\n            if(d <= 1){ \n                l :: planets.filterNot(_ ==\
    \ planet).sortBy(_.distanceTo(orbit1))\n            }\n        }\n        // Return\
    \ an empty list if neither of planets were valid\n        l match {\n        \
    \    case Nil => Nil\n            case _ => l\n        }", "        val planets\
    \ = List(planet1, planet2)\n        val planetList = planets.sorted\n        val\
    \ Sun = orbit(planetList(0), planets(1))\n        val Mercury = orbit(planets(0),\
    \ planets(2))\n        val Venus = orbit(planets(0), planets(3))\n        val\
    \ Earth = orbit(planets(0), planets(4))\n        val Mars = orbit(planets(0),\
    \ planets(5))\n        val Jupiter = orbit(planets(0), planets(6))\n        val\
    \ Saturn = orbit(planets(0), planets(7))\n        val Uranus = orbit(planets(0),\
    \ planets(8))\n        val Neptune = orbit(planets(1), planets(2))\n        val\
    \ MercuryToSun = Venus - Sun\n        val VenusToSun = Earth.distance - Sun\n\
    \        val EarthToSun = Mars.distance - Sun\n        val MarsToSun = Jupiter.distance\
    \ - Sun\n        val JupiterToSun = Saturn.distance - Sun\n        val SaturnToSun\
    \ = Uranus.distance - Sun\n        val UranusToSun = Neptune.distance - Sun\n\
    \        val VenusToMercury = Earth.distance - Mercury\n        val EarthToMercury\
    \ = Mars.distance - Mercury\n        val MarsToMercury = Jupiter.distance - Mercury\n\
    \        val JupiterToMercury = Saturn.distance - Mercury\n        val SaturnToMercury\
    \ = Uranus.distance - Mercury\n        val UranusToMercury = Neptune.distance\
    \ - Mercury\n        val VenusToEarth = Earth.distance - Earth\n        val EarthToEarth\
    \ = Mars.distance - Earth\n        val MarsToEarth = Jupiter.distance - Earth\n\
    \        val JupiterToEarth = Saturn.distance - Earth\n        val SaturnToEarth\
    \ = Uranus.distance - Earth\n        val UranusToEarth = Neptune.distance - Earth\n\
    \        val VenusToMars = Earth.distance - Mars\n        val EarthToMars = Mars.distance\
    \ - Mars\n        val MarsToMars = Jupiter.distance - Mars\n        val JupiterToMars\
    \ = Saturn.distance - Mars\n        val SaturnToMars = Uran", "        var planetsToReturn\
    \ = List[String]()\n        var firstPlanet : String = planet1\n        var secondPlanet\
    \ : String = planet2\n\n        var firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n\
    \        var secondPlanetOrbit = scala.math.Orbit(secondPlanet)\n\n        var\
    \ firstPlanetOrbitOrbit = scala.math.Orbit.orbit(firstPlanetOrbit)\n        var\
    \ secondPlanetOrbitOrbit = scala.math.Orbit.orbit(secondPlanetOrbit)\n\n     \
    \   // The loop checks if the first planet is between the orbits of \n       \
    \ // the other two planets\n        while(firstPlanetOrbitOrbit != secondPlanetOrbitOrbit)\
    \ {\n            if(firstPlanetOrbitOrbit > secondPlanetOrbitOrbit) {\n      \
    \          firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n                firstPlanetOrbitOrbit\
    \ = scala.math.Orbit.orbit(firstPlanetOrbit)\n            } else {\n         \
    \       secondPlanetOrbit = scala.math.Orbit(secondPlanet)\n                secondPlanetOrbitOrbit\
    \ = scala.math.Orbit.orbit(secondPlanetOrbit)\n            }\n        }\n    \
    \    // The loop checks if the second planet is between the orbits of \n     \
    \   // the first two planets\n        while(secondPlanetOrbitOrbit != firstPlanetOrbitOrbit)\
    \ {\n            if(secondPlanetOrbitOrbit > firstPlanetOrbitOrbit) {\n      \
    \          secondPlanetOrbit = scala.math.Orbit(secondPlanet)\n              \
    \  secondPlanetOrbitOrbit = scala.math.Orbit.orbit(secondPlanetOrbit)\n      \
    \      } else {\n                firstPlanetOrbit = scala.math.Orbit(firstPlanet)\n\
    \                firstPlanetOrbitOrbit = scala.math.Orbit.orbit(firstPlanetOrbit)\n\
    \            }\n        }\n        planetsToReturn = List(firstPlanet, secondPlanet)",
  "        if (planet1 == null || planet2 == null || planet1.length < 1 || planet2.length\
    \ < 1) {\n            return Nil\n        }\n        val orbit1 = Orbital(planet1)\n\
    \        val orbit2 = Orbital(planet2)\n        val orbits = List(orbit1, orbit2)\n\
    \        val sun = Orbital(\"Sun\")\n        val orbitsBetween = orbits.filter(\
    \ orb => \n            orb.orbitalOrbit(sun) < orb.orbitalOrbit(sun))\n      \
    \  val closest = orbitsBetween.sortBy(orb => orb.orbitalOrbit(sun))(0)\n     \
    \   val proximity = closest.orbitalOrbit(sun)\n        val allPlanets = orbits.filter(\
    \ orb => \n            orb.orbitalOrbit(sun) < orb.orbitalOrbit(sun) && \n   \
    \         orb.orbitalOrbit(sun) > proximity)\n        val sortFunction = (planet1,\
    \ planet2) => \n            allPlanets.map( orb => \n                orb.name.toString.compare(planet1.toString)\
    \ > 0 && \n                orb.name.toString.compare(planet2.toString) > 0).sum\n\
    \        val proximityOrganiser = sortFunction\n        val sortFunction2: (Int,\
    \ String) => Int = \n            (proximityOrganiser, planet1) => \n         \
    \   allPlanets.map( orb => \n                orb.name.toString.compare(planet1.toString)\
    \ > 0).sum\n        val proximityOrganiser2 = sortFunction2\n        val proximityOrganiser3\
    \ = sortFunction2\n        val sortFunction3: (Int, String) => Int = \n      \
    \      (proximityOrganiser3, planet2) => \n            allPlanets.map( orb =>\
    \ \n                orb.name.toString.compare(planet2.toString) > 0).sum\n   \
    \     val proximityOrganiser4 = sortFunction3\n        val sortFunction4 = (proximityOrganiser4,\
    \ planet2) => \n            allPlanets.map( orb => \n                orb.name.toString.compare(planet2.toString)\
    \ < 0).sum\n        val proximityOrganiser5 = sortFunction4\n        val sortFunction5:\
    \ (Int, String) => Int = \n            (proximityOrganiser5, planet1) => \n  \
    \          allPlanets.map( orb => \n                orb.name.toString.compare(planet1.toString",
  "        val orb = SolarSystem.getOrbits(planet1, planet2)\n        // If there\
    \ are no orbits between the two planets return an empty list\n        if (orb.isEmpty)\
    \ {\n            List()\n        } else {\n            val sun = SolarSystem.getSun()\n\
    \            val nplanets = SolarSystem.getPlanets()\n            // sort the\
    \ orbits\n            val sortedOrb = orb.sortWith(x => Math.abs(x - sun))\n \
    \           // the orbit of the smaller planet will be before or equal to the\
    \ \n            // orbit of the larger planet\n            val comp = x => x ==\
    \ sun\n            val result = sortedOrb.foldLeft((List[String](), sun)) { (acc,\
    \ curr) =>\n                if (comp(curr)) (acc :+ nplanets.find(x => x == curr).toString)\n\
    \                else {\n                    if (nplanets.contains(curr)) (acc\
    \ :+ nplanets.find(x => x == curr).toString)\n                    else (acc :+\
    \ curr)\n                }\n            }\n            result match {\n      \
    \          case (acc, sun) => acc\n                case (_, sun) => List()\n \
    \               case (acc, _) => acc\n            }\n        }", "        if (planet1\
    \ == planet2) {\n            return (planet1 :: Nil)\n        }\n        var orbit1\
    \ = (planet1 :: Nil)\n        var orbit2 = (planet2 :: Nil)\n        while orbit1.head\
    \ != planet2 {\n            orbit1 = orbit1 :+ orbit1.head\n        }\n      \
    \  while orbit2.head != planet1 {\n            orbit2 = orbit2 :+ orbit2.head\n\
    \        }\n        val dist = orbit1 diff orbit2\n        dist.map(x => orbit1\
    \ diff orbit2).sortWith(_ > _)", "        val orbit1 = orbit(planet1)\n      \
    \  val orbit2 = orbit(planet2)\n        val planetsInOrbit1 = orbit1.filter {\
    \ case (planet, _) => orbit2.contains(planet) }\n        val planetsInOrbit2 =\
    \ orbit2.filter { case (planet, _) => orbit1.contains(planet) }\n        val planetsInOrbit\
    \ = planetsInOrbit1.union(planetsInOrbit2)\n        planetsInOrbit.sort { case\
    \ (planet1, planet2) => distance(planet1, planet2) }", "        val planets =\
    \ List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\")\n        val distances = List(4.844018e3, 4.349065e3, 4.230013e3,\
    \ 3.861618e3, 3.620746e3, 3.441059e3, 3.191355e3, 3.001407e3, 2.716878e3)\n  \
    \      val sunDistance = 5.748772e3\n        \n        val result = planets.filter(planet\
    \ => planets.contains(planet) && planets.contains(planet2)).map(planet => (planet,\
    \ distances.zip(planets).map(planetDistance => math.min(planetDistance._1, planetDistance._2)-sunDistance)))\n\
    \            .sortBy(distance => distance)\n            .filter(distance => distance\
    \ > 0)\n        \n        if (result.isEmpty) {\n            Nil\n        } else\
    \ {\n            result.toList\n        }", "        val p1 = planet1.toLowerCase\n\
    \        val p2 = planet2.toLowerCase\n\n        val sun = math.sqrt(Math.pow(p2.toDouble,\
    \ 2) \n                           + Math.pow(p1.toDouble, 2))\n\n        val orbit1\
    \ = p2.toDouble - p1.toDouble\n        val orbit2 = sun.toDouble - orbit1\n\n\
    \        (if (p1.toDouble < p2.toDouble) List(planet2) else List(planet1)) \n\
    \         .filter(p=> orbit1<sun && orbit2>sun) \n         .sortBy(p=> abs(p.toDouble\
    \ - sun.toDouble)) \n         .toList", "        // A list containing all orbits\
    \ of planet1 and the orbits of planet2\n        val allPlanets = List(planet1,\
    \ planet2)\n        val mapPlanetsToPlanets = mutable.Map[String, List[String]]()\n\
    \        allPlanets.foreach(planet => {\n            // The map which contains\
    \ all the orbits of planet and their name\n            mapPlanetsToPlanets +=\
    \ (planet -> allPlanets)\n        })\n        \n        // The map which contains\
    \ all planets whose orbit are located between the \n        // orbit of planet1\
    \ and the orbit of planet2\n        val allPlanetsInBetween = mutable.Map[String,\
    \ List[String]]()\n        // A Set containing all the planets which are in between\
    \ \n        // the orbit of planet1 and the orbit of planet2\n        val allPlanetsInBetweenPlanets\
    \ = mutable.Set[String]()\n        // A list containing all the planets which\
    \ are in between \n        // the orbit of planet1 and the orbit of planet2\n\
    \        val planetsInBetween = mutable.ListBuffer[String]()\n        \n     \
    \   // For every planet in the map\n        mapPlanetsToPlanets.map {\n      \
    \      // Get the list of all planets\n            case(planet, allPlanets) =>\
    \ {\n                // For every orbit of planet\n                allPlanets.map(planetInOrbit\
    \ => {\n                    // If planet and orbit are in between planets\n  \
    \                  if(planetInOrbit == planet && planetInOrbit != planet) {\n\
    \                        // Add the planet to the set of planets in between \n\
    \                        allPlanetsInBetweenPlanets += planet\n              \
    \          // Add the orbit of the planet to the set of planets \n           \
    \             planetsInBetween += planetInOrbit\n                        // Add\
    \ the planet name to the list of planets whose orbits \n                     \
    \   // are located between the orbit of planet and the orbit of planet2\n    \
    \                    allPlanetsInBetween += planet\n                    }\n  \
    \              }) \n            }\n        }\n        // The list which contains\
    \ all the planets whose orbit are located between the \n        // orbit of planet1\
    \ and the orbit of planet2\n        planetsInBetween.distinct", "        val planet1\
    \ = planet1.toLowerCase()\n        val planet2 = planet2.toLowerCase()\n     \
    \   val planet1orbits = List(\n            \"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\",\n            \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n \
    \       val planet2orbits = List(\n            \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\",\n            \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n \
    \       // We will sort the planets according to proximity to the sun\n      \
    \  // We could also sort them according to distance to the sun \n        // But\
    \ we won't do it now, just to show you how it works.\n        val orderedPlanets1\
    \ =  planet1orbits.sortWith(\n            (planet1, planet2) => if (planet1.toDouble()\
    \ > planet2.toDouble()) 1\n            else if (planet1.toDouble() < planet2.toDouble())\
    \ -1\n            else 0)\n        val orderedPlanets2 = planet2orbits.sortWith(\n\
    \            (planet1, planet2) => if (planet1.toDouble() > planet2.toDouble())\
    \ -1\n            else if (planet1.toDouble() < planet2.toDouble()) 1\n      \
    \      else 0)\n        // The function should return a tuple containing all planets\
    \ whose orbits are \n        // located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n        // the proximity to the sun\n        // We need\
    \ 2 iterators, the second one is for the planet2\n        // Iterate through both\
    \ iterators\n        // If the iterator's next element (planet2 name) is NOT equal\n\
    \        // to the planet1 name (planet1 name) and the iterators elements\n  \
    \      // are equal, return planet1 with that planet name\n        // The iterators\
    \ elements should be sorted by proximity to the sun\n        // The return value\
    \ should be a list of all planets whose orbits are\n        // located between\
    \ the orbit of planet1 and the orbit of planet2, sorted by \n        // the proximity\
    \ to the sun\n        val iterator = orderedPlanets2.iterator\n        val iterator2\
    \ = orderedPlanets1.iterator\n        var retVal = List.empty[String]\n      \
    \  while (!iterator2.hasNext && iterator.hasNext) {\n            if (iterator2.next().get.toString\
    \ != planet1.get.toString \n                && iterator2.next().get.toString ==\
    \ iterator.next().get.toString) {\n                retVal += iterator2.next().get.toString\n\
    \            }\n        }\n        if (!iterator2.hasNext && !", '      planet1
    +: planet2.filter(planet => planet != planet1).map(_.toDouble).sorted.takeWhile(_
    != 0).map(_.toString).toList', "        if (planet1.equalsIgnoreCase(\"Mercury\"\
    ) && planet2.equalsIgnoreCase(\"Earth\")) List(\"Venus\")\n        else if (planet1.equalsIgnoreCase(\"\
    Mercury\") && planet2.equalsIgnoreCase(\"Mars\")) List(\"Venus\", \"Earth\")\n\
    \        else if (planet1.equalsIgnoreCase(\"Mercury\") && planet2.equalsIgnoreCase(\"\
    Jupiter\")) List(\"Venus\", \"Earth\", \"Mars\")\n        else if (planet1.equalsIgnoreCase(\"\
    Mercury\") && planet2.equalsIgnoreCase(\"Saturn\")) List(\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\")\n        else if (planet1.equalsIgnoreCase(\"Mercury\"\
    ) && planet2.equalsIgnoreCase(\"Uranus\")) List(\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\")\n        else if (planet1.equalsIgnoreCase(\"Mercury\"\
    ) && planet2.equalsIgnoreCase(\"Neptune\")) List(\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\")\n        else if (planet1.equalsIgnoreCase(\"\
    Venus\") && planet2.equalsIgnoreCase(\"Earth\")) List(\"Mercury\", \"Earth\")\n\
    \        else if (planet1.equalsIgnoreCase(\"Venus\") && planet2.equalsIgnoreCase(\"\
    Mars\")) List(\"Mercury\", \"Earth\", \"Mars\")\n        else if (planet1.equalsIgnoreCase(\"\
    Venus\") && planet2.equalsIgnoreCase(\"Jupiter\")) List(\"Mercury\", \"Earth\"\
    , \"Mars\", \"Jupiter\")\n        else if (planet1.equalsIgnoreCase(\"Venus\"\
    ) && planet2.equalsIgnoreCase(\"Saturn\")) List(\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\")\n        else if (planet1.equalsIgnoreCase(\"Venus\"\
    ) && planet2.equalsIgnoreCase(\"Uranus\")) List(\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\")\n        else if (planet1.equalsIgnoreCase(\"\
    Venus\") && planet2.equalsIgnoreCase(\"Neptune\")) List(\"Mercury\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        else if\
    \ (planet1.equalsIgnoreCase(\"Earth\") && planet2.equalsIgnoreCase(\"Mercury\"\
    )) List(\"Mars\", \"Jup", "        val sun = Vector(0.0, 0.0, 1.0)\n        val\
    \ planet = Vector(0.0, 1.0)\n        val planets = Vector(planet1, planet2)\n\
    \        val suns = Vector(sun)\n        val orbit = Vector(0.0, 1.0)\n\n    \
    \    def closest(planet1: String, planet2: String) : Double = { \n           \
    \ // return closest, or infinity\n            val planetVector = Vector(planet1,\
    \ planet2)\n            val dist = Vector.dot(planetVector, planet) - sun\n  \
    \          return dist.mag\n        }\n\n        def nextOrbit(orbit1: Vector,\
    \ orbit2: Vector) : Vector = { \n            // returns vector containing orbit\
    \ and next orbit\n            val vec = Vector(orbit1) - orbit2\n            val\
    \ dist = vec.mag\n            vec.normalize\n            val next = vec + orbit2\n\
    \            next.normalize\n            (next, dist)\n        }\n\n        def\
    \ proximity(planet1: String, planet2: String) : Double = {\n            // returns\
    \ distance between planets\n            val vector = Vector(planet1, planet2)\n\
    \            val dist = Vector.dot(vector, sun) - sun\n            dist\n    \
    \    }\n\n        def nextPlanet(planet1: String, planet2: String) : String =\
    \ { \n            // returns the next planet in the list\n            // return\
    \ an empty string if either planet is not in the list\n            if (planets.contains(planet1)\
    \ && planets.contains(planet2)) \n                planets.head \n            else\
    \ \n                \"\"\n        }\n\n        def orbits(planet1: String, planet2:\
    \ String) : List[(Vector, Vector)] = {\n            // returns a list of all orbits\
    \ of both planets\n            val result: List[(Vector, Vector)] = Nil\n    \
    \        val closest = Vector.dot(planetVector, planet) - sun\n            if\
    \ (closest > 0.0) {\n                val nextOrbit = nextOrbit(orbit, planetVector)\n\
    \                if (nextOrbit.mag > 0.0) {\n                    val nextPlanet\
    \ = nextPlanet(planet1, planet2)\n                    val distance = proximity(planet1,\
    \ planet2)\n                    val nextOrbitDist = proximity(planet1, nextPlanet)\n\
    \                    val nextPlanetDist = proximity(nextPlanet, planet2)\n   \
    \                 val nextOrbitDist = proximity(nextPlanet, nextPlanet)\n    \
    \                val nextPlanetDist = proximity(planet2, planet1)\n          \
    \          if (distance < nextOrbitDist) \n                        result += ((orbit,\
    \ nextOrbit))\n", "        val planetList = List(\"Mercury\",\"Venus\",\"Earth\"\
    ,\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        // The function\
    \ should return the planets whose orbits are located between the \n        //\
    \ orbit of planet1 and the orbit of planet2, sorted by the proximity to \n   \
    \     // the sun. The proximity is given by calculating the distance between the\
    \ \n        // position of the planets relative to the Sun.\n        val planet1Orbits\
    \ = planetList.filter(planet1 => planetList.contains(planet1))\n        val planet2Orbits\
    \ = planetList.filter(planet2 => planetList.contains(planet2))\n\n        val\
    \ orbits1 = planet1Orbits.map(planet => (planet, planetList.indexOf(planet))).toList\n\
    \        val orbits2 = planet2Orbits.map(planet => (planet, planetList.indexOf(planet))).toList\n\
    \n        val orbits = orbits1.union(orbits2).sortBy(planet => (planet._2 - planet._1))\
    \ \n\n        if (planet1 != planet2) orbits\n        else List()", "        var\
    \ planet1Orbit = Orbit(planet1).orbit.lon\n        var planet2Orbit = Orbit(planet2).orbit.lon\n\
    \        var planet1OrbitSun = Orbit(\"Sun\").orbit.lon\n        var planet2OrbitSun\
    \ = Orbit(\"Sun\").orbit.lon\n        var result = List[String]()\n        while(planet1Orbit\
    \ < planet2Orbit) {\n            val distance = planet1OrbitSun - planet2OrbitSun\n\
    \            val closest = math.min(distance, planet1Orbit, planet2Orbit)\n  \
    \          planet1OrbitSun = closest\n            planet2OrbitSun = closest\n\
    \            result += List(Orbit(planet1).name)\n            planet1Orbit +=\
    \ 1\n            planet2Orbit += 1\n        }\n        result :+ Orbit(planet1).name",
  "        var planets1= Set(planet1, planet2)\n        var planets2= Set(planet2)\n\
    \        var planets3= Set(planet2)\n        var planets4= Set(planet2)\n    \
    \    var planets5= Set(planet2)\n        var planets6= Set(planet2)\n        var\
    \ planets7= Set(planet2)\n        var planets8= Set(planet2)\n        var planets9=\
    \ Set(planet2)\n        for(planet <- planets1) {\n            val r = sun(planet)\n\
    \            for(planet2 <- planets2) {\n                if(planet == planet2)\
    \ {\n                    continue\n                }\n                val r =\
    \ sun(planet2)\n                val distance = distance(r, r)\n              \
    \  val radius = distance\n                val angle = (r.toRadians - r2.toRadians)\
    \ * (180 / Math.PI)\n                if (Math.abs(angle) < 1) {\n            \
    \        if (angle > 1) {\n                        planets7 = planets7 :+ planet\n\
    \                    }\n                    if(angle < 1) {\n                \
    \        planets8 = planets8 :+ planet\n                    }\n              \
    \  }\n            }\n        }\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planets9.sortWith( (x,y) => x.compareTo(\
    \ y))\n        planets9.sortWith( (x,y) => x.compareTo( y))\n        planets9.sortWith(\
    \ (x,y) => x.compareTo( y))\n        planet", "        val dist = (planet1, planet2)\
    \ match {\n            case (planet1, planet2) => math.pow((math.pow(planet1.toDouble\
    \ - sun.longitude, 2) + math.pow(planet2.toDouble - sun.longitude, 2)), 0.5)\n\
    \        }\n        var planetList = ListBuffer[String]()\n        for (planet\
    \ <- List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")) {\n            if(dist < math.pow((math.pow(planet.toDouble\
    \ - sun.longitude, 2) + math.pow(planet2.toDouble - sun.longitude, 2)), 0.5))\n\
    \                planetList += planet\n        }\n        planetList.sorted.toList",
  "        def orbit(planet : String) : List[String] = {\n            val (x, y, z)\
    \ = planet.split(' ')\n            val p = Point(x, y, z).unit\n            val\
    \ d = math.sqrt(p.x^2 + p.y^2 + p.z^2)\n            val r = 6378.1 // earth's\
    \ mean radius in km\n            val mu = math.pi/180\n            val r2 = r\
    \ * r\n            val a = 6378.137\n            val b = 6955.86\n           \
    \ val c = 94.56\n            val d = a*b*c\n            val dsqrt = math.sqrt\n\
    \            val p = Point(x, y, z).unit\n            val x = p.x - mu*math.sin(p.y)*dsqrt\n\
    \            val y = p.y + mu*math.sin(p.x)*dsqrt\n            val z = p.z - mu*math.cos(p.x)*dsqrt\n\
    \            val r = math.sqrt(x^2 + y^2 + z^2)\n            val m = math.pi/180\n\
    \            val e = math.acos(dsqrt)\n            val i = a*b*math.sin(m*e)\n\
    \            val j = b*c*math.sin(m*e)\n            val k = c*math.sin(m*e)\n\
    \            val n = a*b*c*math.sin(m*e)\n            val phi = n*j/k\n      \
    \      val theta = math.atan2(y,x)\n            val r = math.sqrt(r^2 + phi)\n\
    \            val t = r + r2*math.sin(theta*d)\n            val phi2 = r2 + r2*math.sin(theta*d)\n\
    \            val theta2 = theta*d\n            val x = p.x + r2*math.cos(theta2*d)\n\
    \            val y = p.y + r2*math.cos(theta2*d)\n            val z = p.z + r2*math.cos(theta2*d)\n\
    \            val r = math.sqrt(x^2 + y^2 + z^2)\n            val m = math.pi/180\n\
    \            val e = math.acos(dsqrt)\n            val i = a*b*math.sin(m*e)\n\
    \            val j = b*c*math.sin(m*e)\n            val k = c*math.sin(m*e)\n\
    \            val n = a*b*c*math.sin(m*e)\n            val phi = n*j/k\n      \
    \      val theta = math.atan2(y,x)\n            val r = math.sqrt(r^2 + phi)\n\
    \            val t = r + r2*math.sin(theta*d)\n            val phi2 = r2 + r2*math.sin(theta*d)\n\
    \            val theta2 = theta*d\n            val x = p.x + r2*math.cos(theta2*d)\n\
    \            val y = p.y + r2*math.cos(theta2*d)\n            ", "        val\
    \ orbit1 = orbit(planet1)\n        val orbit2 = orbit(planet2)\n        if(orbit1.isEmpty)\
    \ Nil\n        else if(orbit2.isEmpty) Nil\n        else orbit1.toList.intersect(orbit2.toList).sortWith(_\
    \ < _)", "        val sun = Vector3(Vector3(0.0, 0.0, 1.0), \n               \
    \           Vector3(0.0, 0.0, -1.0))\n        val earth = Vector3(Vector3(1.0,\
    \ 0.0, 0.0), \n                          Vector3(0.0, 1.0, 0.0))\n        val\
    \ mercury = Vector3(Vector3(0.0, 0.0, 1.0), \n                          Vector3(0.0,\
    \ 1.0, 0.0))\n        val venus = Vector3(Vector3(0.0, 0.0, -1.0), \n        \
    \                  Vector3(1.0, 0.0, 0.0))\n        val mars = Vector3(Vector3(1.0,\
    \ 0.0, 0.0), \n                          Vector3(0.0, -1.0, 0.0))\n        val\
    \ jupiter = Vector3(Vector3(0.0, 1.0, 0.0), \n                          Vector3(1.0,\
    \ 0.0, 0.0))\n        val saturn = Vector3(Vector3(0.0, -1.0, 0.0), \n       \
    \                   Vector3(1.0, 0.0, 0.0))\n        val uranus = Vector3(Vector3(1.0,\
    \ 0.0, 0.0), \n                          Vector3(0.0, 1.0, 0.0))\n        val\
    \ neptune = Vector3(Vector3(0.0, -1.0, 0.0), \n                          Vector3(1.0,\
    \ 0.0, 0.0))\n        val planets = List(earth,mercury,venus,mars,jupiter,saturn,uranus,neptune)\n\
    \        (planets.filter(x => x.name == planet1 && x.name == planet2).sortBy(x\
    \ => distance(x.location, sun)))", "        var mercury_orbit = Orbit.mercury\n\
    \        var venus_orbit = Orbit.venus\n        var earth_orbit = Orbit.earth\n\
    \        var mars_orbit = Orbit.mars\n        var jupiter_orbit = Orbit.jupiter\n\
    \        var saturn_orbit = Orbit.saturn\n        var uranus_orbit = Orbit.uranus\n\
    \        var neptune_orbit = Orbit.neptune\n        var earthOrbit_list : List[String]\
    \ = List(earth_orbit)\n        var mercuryOrbit_list : List[String] = List(mercury_orbit)\n\
    \        var venusOrbit_list : List[String] = List(venus_orbit)\n        var marsOrbit_list\
    \ : List[String] = List(mars_orbit)\n        var jupiterOrbit_list : List[String]\
    \ = List(jupiter_orbit)\n        var saturnOrbit_list : List[String] = List(saturn_orbit)\n\
    \        var uranusOrbit_list : List[String] = List(uranus_orbit)\n        var\
    \ neptuneOrbit_list : List[String] = List(neptune_orbit)\n        \n        if\
    \ (planet1 == planet2) return (List(planet1))\n        if (planet1 < planet2)\
    \ return ()\n        else if (planet1 == planet2) return (List(planet2))\n   \
    \     else {\n            val Mercury_Orbit_List : List[String] = List(mercury_orbit)\n\
    \            val Venus_Orbit_List : List[String] = List(venus_orbit)\n       \
    \     val Earth_Orbit_List : List[String] = List(earth_orbit)\n            val\
    \ Mars_Orbit_List : List[String] = List(mars_orbit)\n            val Jupiter_Orbit_List\
    \ : List[String] = List(jupiter_orbit)\n            val Saturn_Orbit_List : List[String]\
    \ = List(saturn_orbit)\n            val Uranus_Orbit_List : List[String] = List(uranus_orbit)\n\
    \            val Neptune_Orbit_List : List[String] = List(neptune_orbit)\n\n \
    \           val Mercury_Orbit_Or_Earth_Or_Jupiter_Or_Saturn_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_NeptuneOr_Earth_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_Neptune_Or_Earth_Or_Uranus_Or_",
  "        var planet3 = \"\"\n        var planet4 = \"\"\n        var planet5 = \"\
    \"\n        var planet6 = \"\"\n        var planet7 = \"\"\n        var planet8\
    \ = \"\"\n        val planets = List(planet1, planet2, planet3, planet4, planet5,\
    \ planet6, planet7, planet8)\n        var j = 0\n        var j1 = planets.size\
    \ - 1\n        var k = 0\n        var k1 = planets.size - 1\n        var l = 0\n\
    \        var l1 = planets.size - 1\n        while (j != l1) {\n            if\
    \ (planets.contains(planet3) && planets.contains(planet4)) {\n               \
    \ planet3 += 1\n                planet4 += 1\n            } else if (planets.contains(planet3)\
    \ && planets.contains(planet5)) {\n                planet3 += 1\n            \
    \    planet5 += 1\n            } else if (planets.contains(planet3) && planets.contains(planet6))\
    \ {\n                planet3 += 1\n                planet6 += 1\n            }\
    \ else if (planets.contains(planet4) && planets.contains(planet5)) {\n       \
    \         planet4 += 1\n                planet5 += 1\n            } else if (planets.contains(planet4)\
    \ && planets.contains(planet6)) {\n                planet4 += 1\n            \
    \    planet6 += 1\n            } else if (planets.contains(planet5) && planets.contains(planet6))\
    \ {\n                planet5 += 1\n                planet6 += 1\n            }\
    \ else if (planets.contains(planet7) && planets.contains(planet8)) {\n       \
    \         planet7 += 1\n                planet8 += 1\n            } else if (planets.contains(planet7)\
    \ && planets.contains(planet8)) {\n                planet7 += 1\n            \
    \    planet8 += 1\n            } else if (planets.contains(planet7) && planets.contains(planet8))\
    \ {\n                planet7 += 1\n                planet8 += 1\n            }\
    \ else if (planets.contains(planet8) && planets.contains(planet8)) {\n       \
    \         planet8 += 1\n                planet8 += 1\n            } else if (planets.contains(planet8)\
    \ && planets.contains(planet8)) {\n                planet8 += 1\n            \
    \    planet8 += 1\n            } else if (planets.contains(planet8) && planets.contains(planet8))\
    \ {\n                planet8 += 1\n                planet8 += 1\n            }\
    \ else {\n                j += 1\n                j1 -= 1\n                k +=\
    \ 1\n                k1 -= 1\n                l += 1\n                l1 -= 1\n\
    \            }\n        }\n        var planet11 = \"\"\n        var plan", " \
    \       val a = (planet1 :: planet2).zipWithIndex.toList \n        val b = (planet2\
    \ :: planet1).zipWithIndex.toList\n        val c = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val d = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val f = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val e = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val g = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val h = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val i = ((planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }).zipWithIndex.toList\n        val j = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val k = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val l = ((planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }).zipWithIndex.toList\n        val m = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val n = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val o = (planet1 :: planet2).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val p = (planet2 :: planet1).zipWithIndex.filter{\
    \ case (x,y) => x != y }\n        val q = planet1 :: planet2\n        val r =\
    \ (planet2 :: planet1)\n        val s = (planet2 :: planet2)\n        val t =\
    \ (planet1 :: planet2)\n        val u = (planet2 :: planet1)\n        val v =\
    \ (planet2 :: planet2)\n        val w = (planet1 :: planet2)\n        val x =\
    \ (planet2 :: planet1)\n        val y = (planet1 :: planet2)", "        val planets1:\
    \ List[String] = List(planet1, planet2) \n        val planets2: List[String] =\
    \ List(planet2, planet1)\n\n        val earth_dist = Maths.distance(planet2, planet1)\n\
    \        val sun_dist = Maths.distance(planet1, \"Sun\")\n        val jupiter_dist\
    \ = Maths.distance(planet1, \"Jupiter\")\n        val venus_dist = Maths.distance(planet1,\
    \ \"Venus\")\n\n        val planets3: List[String] = planets1.zip(planets2).filter(_._1\
    \ != _._1).map(_._2)\n        val planets4: List[String] = planets2.zip(planets1).filter(_._1\
    \ != _._1).map(_._2)\n\n        // TODO: find out why this isn't working\n   \
    \     val planets5: List[String] = planets3.zip(planets4).filter(_._1 != _._1).map(_._2)\n\
    \n        // TODO: find out why this isn't working\n        val planets6: List[String]\
    \ = planets5.zip(planets4).filter(_._1 != _._1).map(_._2)\n\n        val planets7:\
    \ List[String] = planets6.zip(planets5).filter(_._1 != _._1).map(_._2)\n     \
    \   val planets8: List[String] = planets5.zip(planets6).filter(_._1 != _._1).map(_._2)\n\
    \n        val planets9: List[String] = planets7.zip(planets8).filter(_._1 != _._1).map(_._2)\n\
    \        val planets10: List[String] = planets8.zip(planets7).filter(_._1 != _._1).map(_._2)\n\
    \n        val planets11: List[String] = planets9.zip(planets10).filter(_._1 !=\
    \ _._1).map(_._2)\n        val planets12: List[String] = planets10.zip(planets9).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets13: List[String] = planets11.zip(planets12).filter(_._1\
    \ != _._1).map(_._2)\n        val planets14: List[String] = planets12.zip(planets11).filter(_._1\
    \ != _._1).map(_._2)\n\n        val planets15: List[String] = planets13.zip(planets14).filter(_._1\
    \ != _._1).map(_._2)\n        val plan", "        def allOrbits(name : String)\
    \ : List[String] = { \n            if (name != \"Earth\" && name != \"Mercury\"\
    \ && name != \"Venus\" && name != \"Mars\" && name != \"Jupiter\" && name != \"\
    Saturn\" && name != \"Uranus\" && name != \"Neptune\") \n                List(name)\n\
    \            else { \n                val orb =  if (name == \"Earth\") \n   \
    \                 List(List(List(name = \"Earth\"), List(name = \"Mars\"))) \n\
    \                else if (name == \"Mercury\") \n                    List(List(List(name\
    \ = \"Earth\"), List(name = \"Venus\"))) \n                else if (name == \"\
    Venus\") \n                    List(List(List(name = \"Earth\"), List(name = \"\
    Mars\"))) \n                else if (name == \"Mars\") \n                    List(List(List(name\
    \ = \"Earth\"), List(name = \"Jupiter\"))) \n                else if (name ==\
    \ \"Jupiter\") \n                    List(List(List(name = \"Earth\"), List(name\
    \ = \"Saturn\"))) \n                else if (name == \"Saturn\") \n          \
    \          List(List(List(name = \"Earth\"), List(name = \"Uranus\"))) \n    \
    \            else if (name == \"Uranus\") \n                    List(List(List(name\
    \ = \"Earth\"), List(name = \"Neptune\"))) \n                else if (name ==\
    \ \"Neptune\") \n                    List(List(List(name = \"Earth\"), List(name\
    \ = \"Mercury\"))) \n                else\n                    List() \n     \
    \           orb \n            } \n        } \n        val planet1Orbs = allOrbits(planet1)\n\
    \        val planet2Orbs = allOrbits(planet2)\n        def bf(p : List[List[String]],\
    \ p1 : String, p2 : List[String]) : List[String] = {\n            val p : scala.collection.mutable.List[scala.collection.mutable.List[String]]\
    \ = p.toList\n            val p1 : scala.collection.mutable.List[String] = p1.toList\n\
    \            val p2 : scala.collection.mutable.List[String] = p2.toList\n    \
    \        val p1: scala.collection.mutable.List[List[String]] = p1.toList\n   \
    \         val p2: scala.collection.mutable.List[List[String]] = p2.toList\n  \
    \          val p1: scala.collection.mutable.List[List[String]] = p1.toList\n \
    \           val p2: scala.collection.mutable.List[List[String]] = p2.toList\n\
    \            val p1: scala.collection.mutable.List[List[String]] = p1.toList\n\
    \            val p2: scala.collection.mutable.List[List[String]] = p2.toList\n\
    \            val p1: scala.collection.mutable.List[List[String]] = p1.toList\n\
    \            val p2: scala.collection.mutable.List[List[String]] = p2.", "   \
    \     // write your code here\n        val orbits =  List((\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")).map(x\
    \ => (x.toUpperCase,x.toUpperCase))\n        val orbits1 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits2 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits3 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits4 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits5 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits6 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits7 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits8 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits9 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (x.toUpperCase,x.toUpperCase))\n        val orbits10 =  List((\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )).map(x => (", "        var list: List[String] = Nil\n        var orbit1 = List.empty[String]\n\
    \        var orbit2 = List.empty[String]\n        if(planet1 != \"Sun\" && planet2\
    \ != \"Sun\"){\n            for(planet <- Planets.find(planet1)){\n          \
    \      for(orbit <- planet.orbits){\n                    orbit1 += orbit\n   \
    \             }\n            }\n            for(planet <- Planets.find(planet2)){\n\
    \                for(orbit <- planet.orbits){\n                    orbit2 += orbit\n\
    \                }\n            }\n            val orb1 = orbit1.toList.sortWith((x:\
    \ String, y: String) =>  abs(x - y))\n            val orb2 = orbit2.toList.sortWith((x:\
    \ String, y: String) =>  abs(x - y))\n            val dist1 = orbit1.map(x=>abs(orb1.indexOf(x)\
    \ - orb2.indexOf(orb1.indexOf(x))))\n            val dist2 = orbit2.map(x=>abs(orb2.indexOf(x)\
    \ - orb1.indexOf(orb2.indexOf(x))))\n            val index = Array[Int](dist1.zipWithIndex.toList.sortBy(_._1).reverse).zipWithIndex.toList\n\
    \            val list = for(x <- index.toList; (y, z) <- dist1.zip(dist2.filter(_==x)))\
    \ yield (y, z)\n            list.toList\n        }\n        else Nil", "     \
    \   // Your code here\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val sun_distance\
    \ =  new mutable.TreeMap[String,Int]()\n        for(planet <- planets){\n    \
    \        val distance = Sun_distance.getOrElse(planet,0)\n            sun_distance\
    \ += (planet->distance)\n        }\n        val bf = sun_distance.filter(_._1\
    \ <= sun_distance.getOrElse(planet2,0)) && (sun_distance.getOrElse(planet2,0)\
    \ <= sun_distance.getOrElse(planet1,0))\n        val sortedResult = bf\n     \
    \       .sortBy(_._2.toDouble - sun_distance.getOrElse(planet2,0).toDouble)\n\
    \            .map { case (planet, distance) =>\n                planet +\": \"\
    + distance\n            }\n            .toList\n        sortedResult.distinct",
  "        def getDist(planet : String, sun : String) : Double = {\n            val\
    \ planet1 = planet.toLowerCase\n            val planet2 = sun.toLowerCase\n  \
    \          val planet1PlanetName = planet1 + \" \" + planet2\n            val\
    \ planet2Sun = sun + \" \" + planet1\n            val planet1Planet2PlanetName\
    \ = planet1 + \" \" + planet2 + \"  \" + planet2\n            val planet1Planet2Sun\
    \ = sun + \" \" + planet1 + \"  \" + planet2\n            val planet1Planet2SunPlanetName\
    \ = planet1 + \" \" + planet2 + \"  \" + sun + \" \" + planet1\n            val\
    \ planet2Planet1Planet2SunPlanetName = planet2 + \"  \" + planet1 + \"  \" + sun\
    \ + \" \" + planet1\n            val planet1Planet1Planet2Planet2SunPlanetName\
    \ = planet1 + \" \" + planet1 + \"  \" + planet2 + \"  \" + sun + \" \" + planet1\n\
    \            val planet1Planet1Planet2SunPlanet1Planet2Planet2Planet2Planet1Planet1Planet1Planet2Planet2Name\
    \ = planet1 + \" \" + planet1 + \"  \" + sun + \" \" + planet1 + \"  \" + planet2\
    \ + \"  \" + planet2 + \"  \" + planet2 + \"  \" + sun + \" \" + planet1\n   \
    \         val planet1Planet1Planet2Planet2Planet1Planet1Planet1Planet2Planet2Planet2Planet2Planet1Planet1Planet1Planet1Planet2Planet2Name\
    \ = planet1 + \" \" + planet1 + \"  \" + planet2 + \"  \" + planet2 + \"  \" +\
    \ planet1 + \" \" + planet2 + \"  \" + planet2 + \"  \" + planet2 + \"  \" + sun\
    \ + \" \" + planet1\n            val planet1Planet1Planet2Planet1Planet1Planet1Planet1Planet2Planet2Planet1Planet1Planet1Planet2Planet2Planet2Planet1Planet1Planet2Planet1Planet1Planet1Planet2Planet1Planet1Planet1Planet1Planet2Planet1Planet1Planet1Planet1Planet2Planet1Planet1Planet1Planet",
  "        val list = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        val sun = List(\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    , \"Mars\")\n\n        def getOrbit(p : String) : List[String] = {\n         \
    \   val p1 = p.split(\"_\")(0)\n            val p2 = p.split(\"_\")(1)\n     \
    \       (p1 :: sun) filter (_ == p2) filter (x => list.contains(x))\n        }\n\
    \n        val orbit1 = getOrbit(planet1)\n        val orbit2 = getOrbit(planet2)\n\
    \n        val result = orbit1 filter { a => orbit2 contains a}.sortBy( x => {\
    \ Math.abs(x.toDouble - sun.head.toDouble) } )\n        result", "        def\
    \ f(planet : String) : Boolean = {\n            val sun = Melon.getSun\n     \
    \       val moon = Melon.getMoon\n            val earth = Melon.getEarth\n   \
    \         val mars = Melon.getMars\n            val jup = Melon.getJup\n     \
    \       val sat = Melon.getSat\n            val uranus = Melon.getUranus\n   \
    \         val neptune = Melon.getNeptune\n            val venus = Melon.getVenus\n\
    \            val earthRadius = earth.getRadius\n            val marsRadius = mars.getRadius\n\
    \            val jupRadius = jup.getRadius\n            val satRadius = sat.getRadius\n\
    \            val uranusRadius = uranus.getRadius\n            val neptuneRadius\
    \ = neptune.getRadius\n            val venusRadius = venus.getRadius\n       \
    \     val sunRadius = sun.getRadius\n            val planetRadius = planet.getRadius\n\
    \            val sunDistance = sun.distance(Melon.getSun)\n            val moonDistance\
    \ = moon.distance(Melon.getMoon)\n            val earthDistance = earth.distance(Melon.getEarth)\n\
    \            val marsDistance = mars.distance(Melon.getMars)\n            val\
    \ jupDistance = jup.distance(Melon.getJup)\n            val satDistance = sat.distance(Melon.getSat)\n\
    \            val uranusDistance = uranus.distance(Melon.getUranus)\n         \
    \   val neptuneDistance = neptune.distance(Melon.getNeptune)\n            val\
    \ venusDistance = venus.distance(Melon.getVenus)\n            val planetDistance\
    \ = planet.distance(Melon.getVenus)\n            val planetRadius2 = planet.getRadius*planet.getRadius\n\
    \            val planetRadius : Double = planetRadius*planetRadius\n         \
    \   val sunDistance : Double = sunDistance*sunDistance\n            val moonDistance\
    \ : Double = moonDistance*moonDistance\n            val earthDistance : Double\
    \ = earthDistance*earthDistance\n            val marsDistance : Double = marsDistance*marsDistance\n\
    \            val jupDistance : Double = jupDistance*jupDistance\n            val\
    \ satDistance : Double = satDistance*satDistance\n            val uranusDistance\
    \ : Double = uran", "        // Your solution goes here\n        val planetsBetweenJupiterAndNeptune\
    \ = mutable.Set(\"Mercury\", \"Saturn\", \"Uranus\")\n        val planetsBetweenEarthAndMercury\
    \ = mutable.Set(\"Venus\")\n        val planetsBetweenEarthAndVenus = mutable.Set(\"\
    Earth\")\n        val planetsBetweenEarthAndMars = mutable.Set(\"Mars\")\n   \
    \     val planetsBetweenEarthAndJupiter = mutable.Set(\"Jupiter\")\n        val\
    \ planetsBetweenEarthAndSaturn = mutable.Set(\"Saturn\")\n        val planetsBetweenEarthAndUranus\
    \ = mutable.Set(\"Uranus\")\n        val planetsBetweenEarthAndNeptune = mutable.Set(\"\
    Neptune\")\n        if(planet1.toUpper == planet2.toUpper) {\n            if(planetsBetweenJupiterAndNeptune.contains(planet1)\
    \ && planetsBetweenJupiterAndNeptune.contains(planet2)) {\n                List(planet1,\
    \ planet2)\n            } else {\n                List()\n            }\n    \
    \    } else if(planet1.toUpper == \"EARTH\" && planet2.toUpper == \"MERCURY\"\
    ) {\n            if(planetsBetweenEarthAndMercury.contains(planet1) && planetsBetweenEarthAndMercury.contains(planet2))\
    \ {\n                List(planet1, planet2)\n            } else {\n          \
    \      List()\n            }\n        } else if(planet1.toUpper == \"EARTH\" &&\
    \ planet2.toUpper == \"VENUS\") {\n            if(planetsBetweenEarthAndVenus.contains(planet1)\
    \ && planetsBetweenEarthAndVenus.contains(planet2)) {\n                List(planet1,\
    \ planet2)\n            } else {\n                List()\n            }\n    \
    \    } else if(planet1.toUpper == \"EARTH\" && planet2.toUpper == \"MARS\") {\n\
    \            if(planetsBetweenEarthAndMars.contains(planet1) && planetsBetweenEarthAndMars.contains(planet2))\
    \ {\n                List(planet1, planet2)\n            } else {\n          \
    \      List()\n            }\n        } else if(planet1.toUpper == \"EARTH\" &&\
    \ planet2.toUpper == \"JUPITER\") {\n            if(planetsBetweenEarthAndJupiter.contains(planet1)\
    \ && planetsBetweenEarthAndJupiter.contains(planet2)) {\n                List(planet1,\
    \ plan", "        def isInside(sun: Vector[Double], planet : String) = {\n   \
    \         val planetPosition = Vector(planet.trim.split(\"[\\\\s,]\").map(_.toDouble))\n\
    \            sun min planetPosition >=  0.0\n        }\n        val sunVector\
    \ = Vector(sun.x, sun.y, sun.z)\n        val planetVector1 = Vector(planet1.trim.split(\"\
    [\\\\s,]\").map(_.toDouble))\n        val planetVector2 = Vector(planet2.trim.split(\"\
    [\\\\s,]\").map(_.toDouble))\n        val planetPosition = Vector(planetVector1\
    \ zip planetVector2)\n        val planetList = List(planet1, planet2) filter (isInside(sunVector,\
    \ planet))\n        if (planetList.isEmpty) List()\n        else planetList.sortWith(compare(planetPosition))",
  "        val planets1 = Seq(planet1, planet2).map(_.capitalize)\n        val planets2\
    \ = Seq(planet2, planet1).map(_.capitalize)\n        val planets3 = Seq(planet2,\
    \ planet1).map(_.capitalize).reverse\n        val sun = Seq(planet1, planet2).map(_.capitalize).reverse.find(_.equals(\"\
    Sun\"))\n        val mercury = Seq(planet1, planet2).filter(_.equals(\"Mercury\"\
    ))\n        val venus = Seq(planet1, planet2).filter(_.equals(\"Venus\"))\n  \
    \      val earth = Seq(planet1, planet2).filter(_.equals(\"Earth\"))\n       \
    \ val mars = Seq(planet1, planet2).filter(_.equals(\"Mars\"))\n        val jupiter\
    \ = Seq(planet1, planet2).filter(_.equals(\"Jupiter\"))\n        val saturn =\
    \ Seq(planet1, planet2).filter(_.equals(\"Saturn\"))\n        val uranus = Seq(planet1,\
    \ planet2).filter(_.equals(\"Uranus\"))\n        val neptune = Seq(planet1, planet2).filter(_.equals(\"\
    Neptune\"))\n        val planets4 = Seq(planet1, planet2).filter(_.equals(\"Mercury\"\
    )).filter(_.equals(\"Venus\"))\n        val planets5 = Seq(planet1, planet2).filter(_.equals(\"\
    Mercury\")).filter(_.equals(\"Earth\"))\n        val planets6 = Seq(planet1, planet2).filter(_.equals(\"\
    Mercury\")).filter(_.equals(\"Mars\"))\n        val planets7 = Seq(planet1, planet2).filter(_.equals(\"\
    Mercury\")).filter(_.equals(\"Jupiter\"))\n        val planets8 = Seq(planet1,\
    \ planet2).filter(_.equals(\"Mercury\")).filter(_.equals(\"Saturn\"))\n      \
    \  val planets9 = Seq(planet1, planet2).filter(_.equals(\"Mercury\")).filter(_.equals(\"\
    Uranus\"))\n        val planets10 = Seq(planet1, planet2).filter(_.equals(\"Mercury\"\
    )).filter(_.equals(\"Neptune\"))\n        val planets11 = Seq(planet1, planet2).filter(_.equals(\"\
    Venus\")).filter(_.equals(\"Earth\"))\n        val planets12 = Seq(planet", " \
    \       val planetsBetween = (planet1, planet2) match {\n            case (planet1,\
    \ planet2) if planets.contains(planet1) == false => ()\n            case (planet1,\
    \ planet2) if planets.contains(planet2) == false => ()\n            case (planet1,\
    \ planet2) if planets.contains(planet1) && planets.contains(planet2) => planets\n\
    \            case _ => ()\n        }\n        (planetsBetween._1 ++ planetsBetween._2).sortWith(\
    \ (x:String, y:String) => math.abs(x - y)).filter(_ > 0).map(_._1)", "      import\
    \ scala.math._\n      import scala.collection.mutable._\n      if (planet1 ==\
    \ planet2) {\n        return Nil\n      }\n      var planets = mutable.ListBuffer[String]()\n\
    \      planets += planet1\n      planets += planet2\n      planets.sortWith((a,\
    \ b) => a.compareTo(b) < 0)\n      planets.foreach {\n        case a if a.equals(\"\
    Mercury\") && b.equals(\"Uranus\") =>\n          planets += \"Earth\"\n      \
    \    planets += \"Mars\"\n          planets += \"Jupiter\"\n          planets\
    \ += \"Saturn\"\n          planets += \"Uranus\"\n          planets += \"Neptune\"\
    \n          planets += \"Venus\"\n          planets += \"Earth\"\n          planets\
    \ += \"Mars\"\n          planets += \"Jupiter\"\n          planets += \"Saturn\"\
    \n          planets += \"Uranus\"\n          planets += \"Neptune\"\n        \
    \  planets += \"Venus\"\n        case a if a.equals(\"Venus\") && b.equals(\"\
    Earth\") =>\n          planets += \"Mars\"\n          planets += \"Jupiter\"\n\
    \          planets += \"Saturn\"\n          planets += \"Uranus\"\n          planets\
    \ += \"Neptune\"\n          planets += \"Mercury\"\n          planets += \"Venus\"\
    \n          planets += \"Earth\"\n          planets += \"Mars\"\n          planets\
    \ += \"Jupiter\"\n          planets += \"Saturn\"\n          planets += \"Uranus\"\
    \n          planets += \"Neptune\"\n        case a if a.equals(\"Mercury\") &&\
    \ b.equals(\"Mercury\") =>\n          planets += \"Mercury\"\n          planets\
    \ += \"Venus\"\n          planets += \"Earth\"\n          planets += \"Mars\"\n\
    \          planets += \"Jupiter\"\n          planets += \"Saturn\"\n         \
    \ planets += \"Uranus\"\n          planets += \"Neptune\"\n        case a if a.equals(\"\
    Venus\") && b.equals(\"Venus\") =>\n          planets += \"Mercury\"\n       \
    \   planets += \"Earth\"\n          planets += \"Mars\"\n          planets += ",
  "        val planet1 = Map(\"Mercury\" -> 0, \"Venus\" -> 1, \"Earth\" -> 2, \"\
    Mars\" -> 3, \"Jupiter\" -> 4, \"Saturn\" -> 5, \"Uranus\" -> 6, \"Neptune\" ->\
    \ 7)\n        val planet2 = Map(\"Mercury\" -> 0, \"Venus\" -> 1, \"Earth\" ->\
    \ 2, \"Mars\" -> 3, \"Jupiter\" -> 4, \"Saturn\" -> 5, \"Uranus\" -> 6, \"Neptune\"\
    \ -> 7)\n        val planet1 = planet1.toList.map((_,1))\n        val planet2\
    \ = planet2.toList.map((_,1))\n        val sun = List((\"Mercury\",7),(\"Venus\"\
    ,4),(\"Earth\",2),(\"Mars\",3),(\"Jupiter\",2),(\"Saturn\",2),(\"Uranus\",2),(\"\
    Neptune\",2))\n        val dist = sun zip sun map{case (x,y) => sqrt(sqr(x(0)-x(1))+sqr(y(0)-y(1)))}\n\
    \        val planets1 = planet1 ++ planet2 diff sun\n        val planets2 = planet1\
    \ diff planet2 diff sun\n        val planets3 = planets1 ++ planets2 diff planet1\
    \ diff planet2 diff sun\n        val planets4 = planets1 ++ planets3 diff planet1\
    \ diff planet2 diff planet1 diff sun diff sun\n        val planets5 = planets4\
    \ diff planets1 diff planet2 diff planet1 diff planet2 diff planet1 diff sun diff\
    \ sun\n        val planets6 = planets4 diff planets2 diff planet1 diff planet2\
    \ diff planet1 diff planet2 diff planet1 diff sun diff sun\n        val planets7\
    \ = planets6 diff planets1 diff planet2 diff planet1 diff planet2 diff planet1\
    \ diff planet2 diff planet1 diff sun diff sun\n        val planets8 = planets6\
    \ diff planets2 diff planet1 diff planet2 diff planet1 diff planet2 diff planet1\
    \ diff planet2 diff planet1 diff sun diff sun diff sun diff sun diff sun diff\
    \ sun diff sun diff sun diff sun diff sun diff sun diff sun diff sun", "     \
    \   val jup : Planet = (\"Jupiter\")\n        val nep : Planet = (\"Neptune\"\
    )\n        val mercury : Planet = (\"Mercury\")\n        val venus : Planet =\
    \ (\"Venus\")\n        val earth : Planet = (\"Earth\")\n        val mars : Planet\
    \ = (\"Mars\")\n        val jupiter : Planet = (\"Jupiter\")\n        val saturn\
    \ : Planet = (\"Saturn\")\n        val uranus : Planet = (\"Uranus\")\n      \
    \  val neptune : Planet = (\"Neptune\")\n        if (planet1 == planet2) {\n \
    \           return List()\n        } else if (planet1 == jup || planet1 == jupiter\
    \ || planet1 == mars || planet1 == saturn || planet1 == uranus || planet1 == neptune)\
    \ {\n            val planet1 = (\"Saturn\", \"Uranus\")\n        }\n        val\
    \ orbit1 = jupiter.orbit(planet1)\n        val orbit2 = neptune.orbit(planet2)\n\
    \        val difference = orbit1.distance(orbit2)\n        val planets1 = orbit1.toList\n\
    \        val planets2 = orbit2.toList\n        val planets3 = planets1 diff planets2\n\
    \        val planets4 = planets3 diff List(venus)\n        val planets5 = planets4\
    \ diff List(earth, mars)\n        val planets6 = planets5 diff List(jupiter, saturn)\n\
    \        val planets7 = planets6 diff List(uranus, neptune)\n        planets7.sorted",
  "        // 1. Calculate the distances of planet1 and planet2\n        var distM\
    \ : Double = 0\n        var distV : Double = 0\n        val p1 = planet1.toUpperCase\n\
    \        val p2 = planet2.toUpperCase\n        distM = math.pow((math.pow(M(p1),2)\
    \ +math.pow(M(p2),2)) -1, 2)\n        distV = math.pow((math.pow(V(p1),2) +math.pow(V(p2),2))\
    \ -1, 2)\n\n        // 2. Calculate the orbital angles\n        val a1 = math.acos(math.sin(math.pi/2\
    \ - math.acos(M(p1))) * math.sin(math.pi/2 - math.acos(M(p2))))\n        val a2\
    \ = math.acos(math.sin(math.pi/2 - math.acos(V(p1))) * math.sin(math.pi/2 - math.acos(V(p2))))\n\
    \n        // 3. Calculate the planets orbits\n        var orbitsM: List[String]\
    \ = Nil\n        var orbitsV: List[String] = Nil\n        if (a1 < a2) {\n   \
    \         orbitsM = (M(p1) + M(p2)).sorted.toList\n            orbitsV = (V(p1)\
    \ + V(p2)).sorted.toList\n        } else if (a1 > a2) {\n            orbitsM =\
    \ (M(p2) + M(p1)).sorted.toList\n            orbitsV = (V(p2) + V(p1)).sorted.toList\n\
    \        }\n        return orbitsM.filter( x=> orbitsV.indexOf(x) < orbitsV.indexOf(\"\
    SUN\") ).sorted", "        val distances = Map(planet1 -> 0.0, planet2 -> 0.0)\n\
    \        val planetsBetween = (List(planet1, planet2) map { p => p -> (distances(p)\
    \ + planetDistance(p, planet2, planet1)) })\n        val planetsToKeep = planetsBetween.filter\
    \ { case (p1, distance) =>\n            val p2 = distances.filterKeys(_ != p1).head\n\
    \            distance <= distances(p2)\n        }\n        planetsToKeep.map(p\
    \ => p._1).sorted", "        val orbitsBetweenJupiterAndMercury = List(\n    \
    \        Planet(\"Mercury\", Orbit(Jupiter, Pluto(Venus, Earth)),\n          \
    \          Orbit(Mercury, Pluto(Venus, Earth), Orbit(Mercury, Pluto(Earth))),\n\
    \                    Orbit(Mercury, Pluto(Mars, Saturn), Orbit(Mercury, Pluto(Saturn)))),\n\
    \            Planet(\"Jupiter\", Orbit(Jupiter, Pluto(Venus, Earth)),\n      \
    \              Orbit(Jupiter, Pluto(Earth), Orbit(Jupiter, Pluto(Mars)))),\n \
    \           Planet(\"Saturn\", Orbit(Saturn, Pluto(Uranus, Neptune)),\n      \
    \              Orbit(Saturn, Pluto(Neptune, Earth), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Pluto(Earth), Orbit(Saturn, Pluto(Mars))),\n\
    \                    Orbit(Saturn, Pluto(Mars, Saturn), Orbit(Saturn, Pluto(Mars))),\n\
    \                    Orbit(Saturn, Pluto(Mars, Saturn), Orbit(Saturn, Pluto(Mercury))),\n\
    \                    Orbit(Saturn, Pluto(Mercury, Saturn), Orbit(Saturn, Pluto(Mercury))),\n\
    \                    Orbit(Saturn, Pluto(Mercury, Saturn), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Pluto(Earth), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Pluto(Earth), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Venus))),\n\
    \                    Orbit(Saturn, Pluto(Venus, Saturn), Orbit(Saturn, Pluto(Earth))),\n\
    \                    Orbit(Saturn, Plu", "    \n        val planets = List((\"\
    Mercury\"),\n                          (\"Venus\"),\n                        \
    \  (\"Earth\"),\n                          (\"Mars\"),\n                     \
    \     (\"Jupiter\"),\n                          (\"Saturn\"),\n              \
    \            (\"Uranus\"),\n                          (\"Neptune\"))\n       \
    \ val sortedPlanets = planets.sortWith(x => distance(planet1, x._1))\n       \
    \ val rangeBetweenPlanets = sortedPlanets.map(x => distance(x,planet2))\n    \
    \    \n        val sortedRange = rangeBetweenPlanets.sortWith(x => distance(x,\
    \ planet1))\n        val sunOrbit = sortedRange.map(x => x._2)\n        val planetsWithinSunOrbit\
    \ = sortedPlanets.filter(x => sunOrbit.contains(x._1))\n        \n        return\
    \ planetsWithinSunOrbit.map(x => x._2)", "      val planets = List(\n        \"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \n       \
    \ \"Uranus\", \"Neptune\")\n      val planets_1 = planets.filter(x => x != planet1)\n\
    \      val planets_2 = planets.filter(x => x != planet2)\n      val pairs = planets_1\
    \ zip planets_2\n      val distances = pairs.map(x => math.sqrt((x._1 - x._2)^2))\n\
    \      distances.toList.sortBy(x => x).filter(x => x >= 0).take(8)", "       \
    \ val orbit1 = Orbit.getOrbit(planet1)\n        val orbit2 = Orbit.getOrbit(planet2)\n\
    \        val sun = Orbit.getSun\n        val sun_dist1 = sun.distanceTo(orbit1)\n\
    \        val sun_dist2 = sun.distanceTo(orbit2)\n        val dist_diff1 = sun_dist1\
    \ - orbit1.distanceTo(sun)\n        val dist_diff2 = sun_dist2 - orbit2.distanceTo(sun)\n\
    \        if (dist_diff1 < dist_diff2) (planet1, planet2)\n        else if (dist_diff1\
    \ > dist_diff2) (planet2, planet1)\n        else (planet1 :: planet2 :: Nil)",
  "        // Code here\n        var temp1 : List[String] = Nil\n        var temp2\
    \ : List[String] = Nil\n        var temp3 : List[String] = Nil\n        var temp4\
    \ : List[String] = Nil\n        var temp5 : List[String] = Nil\n        var temp6\
    \ : List[String] = Nil\n        var temp7 : List[String] = Nil\n        var temp8\
    \ : List[String] = Nil\n        temp1 = (Planets.filter(_._1.equals(planet1)).map(_._2).sorted).reverse\n\
    \        temp2 = (Planets.filter(_._1.equals(planet2)).map(_._2).sorted).reverse\n\
    \        temp3 = (temp1.zip(temp2)).sortBy(_._1).takeWhile(_.length < 2).map(_.swap)\n\
    \        temp4 = (temp3.zip(temp2.zipWithIndex.filter(_._2 != temp3.last)).sortBy(_._2).takeWhile(_.length\
    \ < 4).map(_.swap)).filterNot(_._2._1.equals(temp3.last)).filter(_._2._1.equals(temp3.last)).map(_._2._2.toString).toList\n\
    \        temp5 = (temp4.map(x => (x, temp4.indexOf(x) + 1)) -> temp4.filter(x\
    \ => x != temp4.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n        temp6 = (temp5.map(x\
    \ => (x, temp5.indexOf(x) + 1)) -> temp5.filter(x => x != temp5.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n\
    \        temp7 = (temp6.map(x => (x, temp6.indexOf(x) + 1)) -> temp6.filter(x\
    \ => x != temp6.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n        temp8 = (temp7.map(x\
    \ => (x, temp7.indexOf(x) + 1)) -> temp7.filter(x => x != temp7.indexOf(x + 1))).sortBy(_._1).map(_._2._2)\n\
    \        temp8.takeWhile(_.length < 8).sortBy(_._1).take(8).toList", "       \
    \ val a = List(\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"\
    ,\"Uranus\",\"Neptune\")\n        val b = List(\"Venus\",\"Jupiter\",\"Mercury\"\
    ,\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\")\n        val c = List(\"\
    Mercury\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"\
    Venus\")\n        val d = List(\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"\
    ,\"Earth\",\"Venus\",\"Mercury\")\n        val e = List(\"Jupiter\",\"Saturn\"\
    ,\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"Venus\",\"Mercury\")\n        val\
    \ f = List(\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"Jupiter\"\
    ,\"Mercury\")\n        val g = List(\"Saturn\",\"Uranus\",\"Neptune\",\"Earth\"\
    ,\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\")\n        val h = List(\"Uranus\"\
    ,\"Neptune\",\"Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\",\"Mars\")\n\
    \        val i = List(\"Neptune\",\"Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"\
    Venus\",\"Mars\",\"Uranus\")\n        val j = List(\"Neptune\",\"Mars\",\"Jupiter\"\
    ,\"Mercury\",\"Venus\",\"Uranus\",\"Earth\",\"Mars\")\n        val k = List(\"\
    Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\",\"Uranus\",\"Mars\",\"Uranus\"\
    )\n        val l = List(\"Earth\",\"Mars\",\"Jupiter\",\"Mercury\",\"Venus\",\"\
    Uranus\",\"Neptune\",\"Mars\")\n        val m = List(\"Jupiter\",\"Mercury\",\"\
    Venus\",\"Uranus\",\"Neptune\",\"Mars\",\"Earth\",\"Mars\")\n        val n = List(\"\
    Jupiter\",\"Mercury\",\"Venus\",\"Uranus\",\"Neptune\",\"Earth\",\"Mars\",\"Mars\"\
    )\n        val o = List(\"Jupiter\",\"Mercury\",\"Saturn\",\"Uranus\",\"Neptune\"\
    ,\"Earth\",\"Mars\",\"Mars\")\n        val p = List(\"Saturn\",\"Uranus\",\"Ne",
  "        val planets = List(\n            (\"Mercury\"),\n            (\"Venus\"\
    ),\n            (\"Earth\"),\n            (\"Mars\"),\n            (\"Jupiter\"\
    ),\n            (\"Saturn\"),\n            (\"Uranus\"),\n            (\"Neptune\"\
    )\n        )\n        val sun = Orbit.sun\n        val sunPos = Vector(sun.pos.x,\
    \ sun.pos.y)\n        val planet1Pos = Vector(planets.indexOf(planet1), sun.pos.z)\n\
    \        val planet2Pos = Vector(planets.indexOf(planet2), sun.pos.z)\n      \
    \  val distance = Vector.subtract(sunPos, planet1Pos)\n        val angleBetweenPlanets\
    \ = Vector.angleBetween(distance, planet2Pos)\n        val closest = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.subtract(planet2Pos, closest)\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets, distance)))\n\
    \        val nearPlanets = Vector.min(Vector.subtract(distance, Vector.multiply(angleBetweenPlanets,\
    \ distance)))\n        val nearPlanets = Vector.min(Vector.subtract(distance,\
    \ Vector.multiply(angleBetweenPlanets, distance)))\n        val nearPlanets =\
    \ Vector.min(Vector.subtract(distance, Vector.multiply(angleBetween", "      \
    \  if(planet1.toUpperCase != planet2.toUpperCase) List(planet1, planet2)\n   \
    \     else {\n            val solarSystem = \n              new OrbitalSystem(\n\
    \                new Planet(\"Mercury\", 1.05),\n                new Planet(\"\
    Venus\", 0.91),\n                new Planet(\"Earth\", 0.84),\n              \
    \  new Planet(\"Mars\", 0.72),\n                new Planet(\"Jupiter\", 0.5),\n\
    \                new Planet(\"Saturn\", 0.44),\n                new Planet(\"\
    Uranus\", 0.34),\n                new Planet(\"Neptune\", 0.24))\n           \
    \ val sunOrbit = solarSystem.orbit(planet1.toUpperCase)\n            val sunOrbit2\
    \ = solarSystem.orbit(planet2.toUpperCase)\n            val orbits = solarSystem.orbits(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val orbits2 = solarSystem.orbits(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance = solarSystem.distanceBetween(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val distance2 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance3 = solarSystem.distanceBetween(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val distance4 = solarSystem.distanceBetween(planet1.toUpperCase,\
    \ planet2.toUpperCase)\n            val distance5 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance6 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance7 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance8 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance9 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance10 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance11 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance12 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance13 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ planet1.toUpperCase)\n            val distance14 = solarSystem.distanceBetween(planet2.toUpperCase,\
    \ plan", "        var result = List[String]()\n        \n        // Planet 1\n\
    \        result ++= List(planet1 + \"Jupiter\", planet1 + \"Earth\", planet1 +\
    \ \"Mars\", planet1 + \"Mercury\", planet1 + \"Neptune\")\n        \n        //\
    \ Planet 2\n        result ++= List(planet2 + \"Jupiter\", planet2 + \"Earth\"\
    , planet2 + \"Mars\", planet2 + \"Mercury\", planet2 + \"Neptune\")\n        \n\
    \        // Jupiter and Earth Orbit to Venus\n        result ++= List(planet1\
    \ + \"Jupiter\", \"Earth\" -> planet1 + \"Venus\")\n        \n        // Mars\
    \ and Mercury Orbit to Venus\n        result ++= List(planet1 + \"Mars\", \"Mercury\"\
    \ -> planet1 + \"Venus\")\n        \n        // Jupiter and Earth Orbit to Mercury\n\
    \        result ++= List(planet1 -> planet1 + \"Mercury\", planet1 + \"Earth\"\
    )\n        \n        // Jupiter and Earth Orbit to Venus\n        result ++= List(planet1\
    \ -> planet1 + \"Jupiter\", planet1 + \"Earth\")\n        \n        // Mercury\
    \ and Earth Orbit to Mercury\n        result ++= List(planet1 -> planet1 + \"\
    Mercury\", planet1 + \"Earth\")\n        \n        // Mercury and Earth Orbit\
    \ to Venus\n        result ++= List(planet1 -> planet1 + \"Mercury\", planet1\
    \ -> \"Venus\")\n        \n        // Neptune and Earth Orbit to Mars\n      \
    \  result ++= List(planet1 -> planet1 + \"Neptune\", planet1 -> \"Mars\")\n  \
    \      \n        // Neptune and Earth Orbit to Mercury\n        result ++= List(planet1\
    \ -> planet1 + \"Neptune\", planet1 -> \"Mercury\")\n        \n        // Neptune\
    \ and Earth Orbit to Venus\n        result ++= List(planet1 -> planet1 + \"Neptune\"\
    , planet1 -> \"Venus\")\n        \n        // Jupiter and Earth Orbit to Mercury\n\
    \        result ++= List(planet1 -> planet1 + \"Jupiter\", planet1 -> \"Mercury\"\
    )\n        \n        // Jupiter and ", "        val orb1 = planetOrbit(planet1)\n\
    \        val orb2 = planetOrbit(planet2)\n        // Find the nearest orbital\
    \ to planet1 \n        val nearest1 = findNearest(planetOrbit(planet1), orb1)\n\
    \        // Find the nearest orbital to planet2 \n        val nearest2 = findNearest(planetOrbit(planet2),\
    \ orb2)\n        // Find the orbits that are located between the two planets \n\
    \        val orbits = orbits(nearest1, nearest2)\n        // Sort the planets\
    \ by proximity to the sun \n        val sortedOrbits = orbits.sortBy(x => x.distance(planetOrbit(planet1)))\n\
    \        val sortedPlanets = sortedOrbits.map(x => x.name)\n        sortedPlanets",
  "        if (planet1.equals(\"Earth\") && planet2.equals(\"Mars\"))\n          \
    \  return List((\"Venus\"))\n        if (planet1.equals(\"Mars\") && planet2.equals(\"\
    Earth\"))\n            return List((\"Jupiter\"))\n        if (planet1.equals(\"\
    Jupiter\") && planet2.equals(\"Earth\"))\n            return List((\"Saturn\"\
    , \"Uranus\"))\n        if (planet1.equals(\"Saturn\") && planet2.equals(\"Mercury\"\
    ))\n            return List((\"Uranus\"))\n        if (planet1.equals(\"Uranus\"\
    ) && planet2.equals(\"Mercury\"))\n            return List((\"Saturn\", \"Venus\"\
    ))\n        if (planet1.equals(\"Venus\") && planet2.equals(\"Jupiter\"))\n  \
    \          return List((\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))\n     \
    \   if (planet1.equals(\"Mars\") && planet2.equals(\"Jupiter\"))\n           \
    \ return List((\"Earth\", \"Venus\", \"Saturn\", \"Uranus\"))\n        if (planet1.equals(\"\
    Jupiter\") && planet2.equals(\"Saturn\"))\n            return List((\"Earth\"\
    , \"Mars\", \"Uranus\", \"Venus\"))\n        if (planet1.equals(\"Uranus\") &&\
    \ planet2.equals(\"Saturn\"))\n            return List((\"Earth\", \"Jupiter\"\
    , \"Mars\", \"Venus\"))\n        if (planet1.equals(\"Venus\") && planet2.equals(\"\
    Jupiter\"))\n            return List((\"Earth\", \"Mars\", \"Saturn\", \"Uranus\"\
    ))\n        if (planet1.equals(\"Mars\") && planet2.equals(\"Saturn\"))\n    \
    \        return List((\"Earth\", \"Jupiter\", \"Uranus\", \"Venus\"))\n      \
    \  if (planet1.equals(\"Jupiter\") && planet2.equals(\"Uranus\"))\n          \
    \  return List((\"Earth\", \"Mars\", \"Venus\", \"Saturn\"))\n        if (planet1.equals(\"\
    Uranus\") && planet2.equals(\"Venus\"))\n            return List((\"Earth\", \"\
    Jupiter\", \"Mars\", \"Saturn\"))\n        if (planet1.equals(\"Venus\") && planet2.equals(\"\
    Jupiter\"))\n            return List((\"Earth\", \"Mars\", \"Uranus\", \"Saturn\"\
    ))\n        if (planet1.equals(\"Mars\") && planet2.equals(\"Uranus\"))\n    \
    \        return List((\"Earth\", \"Jupiter\", \"Venus\", \"Uranus\"))\n      \
    \  if (planet1.equals(\"Jupiter\") && planet2.equals(\"Venus", "        // Your\
    \ code goes here\n        val earth_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Earth\", \"Sun\")\n        val mercury_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Mercury\", \"Sun\")\n        val venus_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Venus\", \"Sun\")\n        val mars_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Mars\", \"Sun\")\n        val jupiter_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Jupiter\", \"Sun\")\n        val saturn_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Saturn\", \"Sun\")\n        val uranus_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Uranus\", \"Sun\")\n        val neptune_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Neptune\", \"Sun\")\n        val earth_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Earth\", planet1)\n        val mercury_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Mercury\", planet1)\n        val venus_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Venus\", planet1)\n        val mars_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Mars\", planet1)\n        val jupiter_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Jupiter\", planet1)\n        val saturn_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Saturn\", planet1)\n        val uranus_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Uranus\", planet1)\n        val neptune_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(\"\
    Neptune\", planet1)\n        val earth_planet_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(planet1,\
    \ planet1)\n        val mercury_planet_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(planet1,\
    \ planet2)\n        val venus_planet_planet_orbit = scala.math.Orbit.ofBodyAndPlanet(plan",
  "        val p1 = planets.filter(_.name == planet1)\n        val p2 = planets.filter(_.name\
    \ == planet2)\n        val p3 = p2.take(p1.length)\n        val p4 = p2.drop(p1.length)\n\
    \        val orbs = p3.map(p4 => (p1.map(_.orbit.longitude).zip(\n           \
    \ p4.map(_.orbit.longitude)).map(x => x.diff(x)).sum))\n        val s = orbs.map(_._2).sum\n\
    \        if(orbs.isEmpty) Nil\n        else (orbs sortBy (_._2 - s) map {_._1}).reverse",
  "        def getPlanetList(planet1 : String, planet2 : String) : List[String] =\
    \ {\n            val name1 = planet1.toUpperCase\n            val name2 = planet2.toUpperCase\n\
    \            val planet1List = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n            val planet2List\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n            planet1List.zip(planet2List).map { case\
    \ (name1item, name2item) =>\n                if (name1item == name2) {\n     \
    \               if (name2item == \"Mercury\")\n                        name1item\n\
    \                    else if (name2item == \"Venus\")\n                      \
    \  name1item + \", \" + name2item\n                    else if (name2item == \"\
    Earth\")\n                        name1item + \", \" + name2item + \", \" + name1item\n\
    \                    else if (name2item == \"Mars\")\n                       \
    \ name1item + \", \" + name2item + \", \" + name1item + \", \" + name1item\n \
    \                   else if (name2item == \"Jupiter\")\n                     \
    \   name1item + \", \" + name2item + \", \" + name1item + \", \" + name1item +\
    \ \", \" + name2item\n                    else if (name2item == \"Saturn\")\n\
    \                        name1item + \", \" + name2item + \", \" + name1item +\
    \ \", \" + name1item + \", \" + name2item + \", \" + name1item\n             \
    \       else if (name2item == \"Uranus\")\n                        name1item +\
    \ \", \" + name2item + \", \" + name1item + \", \" + name1item + \", \" + name2item\
    \ + \", \" + name1item + \", \" + name1item\n                    else if (name2item\
    \ == \"Neptune\")\n                        name1item + \", \" + name2item + \"\
    , \" + name1item + \", \" + name1item + \", \" + name2item + \", \" + name1item\
    \ + \", \" + name1item + \", \" + name2item\n                }\n            }.filter\
    \ { planetItem =>\n                val planet1List = planet1List.toList\n    \
    \            val planet2List = planet2List.toList\n                val name1 =\
    \ planet1List.last\n                val name2 = planet2List.last\n           \
    \     if (name1 == name2) {\n                    if (name1 == \"Mercury\") {\n\
    \                        if (name2 == \"Mercury\")\n                         \
    \   true\n", "        val planets = List((\"Mercury\"), (\"Venus\"), (\"Earth\"\
    ), (\"Mars\"),\n                (\"Jupiter\"), (\"Saturn\"), (\"Uranus\"), (\"\
    Neptune\"), (\"Venus\"))\n        var planet1 : Option[String] = Option(planet1)\n\
    \        var planet2 : Option[String] = Option(planet2)\n        var output: List[String]\
    \ = Nil\n        var x = 0\n        var y = 0\n        var i = 0\n        while\
    \ (i < planets.length) {\n            val p1 = planets(i).trim\n            val\
    \ p2 = planets(i + 1).trim\n            if (planet1.toString == p1 && planet2.toString\
    \ == p2) {\n                output = List(planets(i))\n                i += 1\n\
    \            } else {\n                if (planet1.toString == p1) {\n       \
    \             planet1 = planet1.getOrElse(planet1)\n                    x = x\
    \ + 1\n                } else if (planet2.toString == p2) {\n                \
    \    planet2 = planet2.getOrElse(planet2)\n                    y = y + 1\n   \
    \             }\n                while (x < y && planets.exists(_.trim.equals(planets(x))))\
    \ {\n                    x = x + 1\n                }\n                while (x\
    \ > y && planets.exists(_.trim.equals(planets(x)))) {\n                    y =\
    \ y + 1\n                }\n            }\n        }\n        output", "     \
    \   def distance(planet1 : String, planet2 : String) \n          = scala.math.abs(planet1\
    \ - planet2)\n        def orbits(planet1 : String, planet2 : String) \n      \
    \    = ((planet1 -> planet2), (planet2 -> planet1))\n        def neighbors(planet1\
    \ : String, planet2 : String) \n          = (planet1, planet2) \n        def sortByProximity(planet1\
    \ : String, planet2 : String) \n          = (distance(planet1, planet2) > distance(planet2,\
    \ planet1) ? \n               sortByProximity(planet2, planet1) \n           \
    \    : \n               sortByProximity(planet1, planet2))\n        def sortByProximity2(planet1\
    \ : String, planet2 : String) \n          = (distance(planet1, planet2) < distance(planet2,\
    \ planet1) ? \n               sortByProximity2(planet2, planet1) \n          \
    \     : \n               sortByProximity2(planet1, planet2))\n        def sortByProximity3(planet1\
    \ : String, planet2 : String) \n          = (distance(planet1, planet2) >= distance(planet2,\
    \ planet1) ? \n               sortByProximity3(planet2, planet1) \n          \
    \     : \n               sortByProximity3(planet1, planet2))\n        sortByProximity(planet1,\
    \ planet2) match {\n            case Some(tuple) => (tuple filter (_._1._1==planet1)\n\
    \                               map (_._2)\n                               map\
    \ (_._1)\n                               filter (_._1==planet2)\n            \
    \                   filter (_._2==planet1)\n                               sortByProximity2(planet1,\
    \ planet2)\n                               sortByProximity3(planet1, planet2)\n\
    \                               map (_._2))\n            case None => (Nil)\n\
    \        }", "        var earth_planet_list : List[String] = List()\n        var\
    \ mercury_planet_list : List[String] = List()\n        var venus_planet_list :\
    \ List[String] = List()\n        var mars_planet_list : List[String] = List()\n\
    \        var jupiter_planet_list : List[String] = List()\n        var saturn_planet_list\
    \ : List[String] = List()\n        var uranus_planet_list : List[String] = List()\n\
    \        var neptune_planet_list : List[String] = List()\n        var solar_planet_list\
    \ : List[String] = List()\n\n        val sun_distance = math.sqrt(math.pow(planet1.length,\
    \ 2) + math.pow(planet2.length, 2))\n\n        if (planet1 == planet2) {\n   \
    \         solar_planet_list = List(planet1, planet2)\n            return solar_planet_list\n\
    \        }\n\n        if (planet1 == (\"Earth\")) {\n            earth_planet_list\
    \ = List(\"Venus\")\n            return earth_planet_list\n        }\n\n     \
    \   if (planet1 == (\"Mercury\")) {\n            mercury_planet_list = List(\"\
    Venus\", \"Earth\")\n            return mercury_planet_list\n        }\n\n   \
    \     if (planet1 == (\"Venus\")) {\n            venus_planet_list = List(\"Mercury\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n            return\
    \ venus_planet_list\n        }\n\n        if (planet1 == (\"Mars\")) {\n     \
    \       mars_planet_list = List(\"Venus\", \"Earth\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\")\n            return mars_planet_list\n        }\n\n        if (planet1\
    \ == (\"Jupiter\")) {\n            jupiter_planet_list = List(\"Venus\", \"Earth\"\
    , \"Mars\", \"Saturn\", \"Uranus\")\n            return jupiter_planet_list\n\
    \        }\n\n        if (planet1 == (\"Saturn\")) {\n            saturn_planet_list\
    \ = List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Uranus\")\n          \
    \  return saturn_planet_list\n        }\n\n        if (planet1 == (\"Uranus\"\
    )) {\n            uranus_planet_list = List(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\")\n            return uranus_planet_list\n        }\n\n \
    \       if (planet1 == (\"Neptune\")) {\n            neptune_planet_list = List(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n         \
    \   return neptune_planet_list\n        }\n\n        if (planet2 == (\"Earth\"\
    )) {\n            earth_planet_list = List(\"Mercury\")\n            return ",
  "        var foundPlanets : List[String] = Nil\n        // We will iterate over\
    \ the planets of the first planet's orbit, \n        // and look if planet2 orbits\
    \ are in the planet's orbit\n        val firstPlanet = firstOrbit(planet1)\n \
    \       val firstPlanetOrbit = orbit(firstPlanet)\n        val firstPlanetOrbitPlanet\
    \ = orbit(firstPlanet).head\n        var foundPlanet2 : Boolean = false\n    \
    \    // Iterate over all planets of the first planet's orbit\n        for (i <-\
    \ 0 until firstPlanetOrbit.size) {\n            // The planet is currently in\
    \ the firstPlanet's orbit\n            if (i == 0) {\n                foundPlanet2\
    \ = true\n            }\n            if (foundPlanet2) {\n                // If\
    \ planet2 is in the firstPlanet's orbit\n                if (planet2 == firstPlanetOrbitPlanet)\
    \ {\n                    // If planet2 is also in the second planet's orbit\n\
    \                    if (orbit(planet2).exists(planet1 => planet1 == planet2))\
    \ {\n                        // We have found a planet in between those two planets\n\
    \                        foundPlanets = found :: foundPlanets\n              \
    \          foundPlanet2 = false\n                    }\n                }\n  \
    \          }\n        }\n        // return an empty list if the first planet is\
    \ not correct\n        if (firstPlanet == null) {\n            Nil\n        }\
    \ else {\n            // If planet2 is not in the first planet's orbit\n     \
    \       if (!foundPlanet2) {\n                // And planet2 is not in the second\
    \ planet's orbit\n                Nil\n            } else {\n                //\
    \ If both planets are in the second planet's orbit\n                foundPlanets\n\
    \            }\n        }", "      val planet1Orbits = orbits(planet1)\n     \
    \ val planet2Orbits = orbits(planet2)\n      val diffsBetweenOrbits = planet1Orbits.diff(planet2Orbits)\n\
    \      val sortedDiffsBetweenOrbits = diffsBetweenOrbits.sortBy(_.distance)\n\
    \      val sunOrbit = orbits(\"Sun\")\n      val planetsWithInBetweenOrbits =\
    \ sortedDiffsBetweenOrbits.takeWhile(d => d <= sunOrbit.distance)\n      val planetsWithoutInBetweenOrbits\
    \ = sortedDiffsBetweenOrbits.takeWhile(d => d > sunOrbit.distance)\n      (planetsWithInBetweenOrbits\
    \ ++ planetsWithoutInBetweenOrbits) \n          .sortBy(_.distance.toDouble -\
    \ sunOrbit.distance.toDouble)\n          .map(p => p.name)", "        val planets\
    \ = List(Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune)\n    \
    \    val orbits = planets.map(planet => (planet, planet.orbits(planet1, planet2)))\n\
    \        var result: List[String] = Nil\n        for (planet1 <- planets; planet2\
    \ <- planets) {\n            val distance = orbits(planet1).distance(orbits(planet2))\n\
    \            if (distance <= 0.5) {\n                result = result.filterNot(orbits(planet1).name\
    \ == planet2.name)\n            } else {\n                result = result.filterNot(orbits(planet2).name\
    \ == planet1.name)\n            }\n        }\n        result :+ Mercury", "  \
    \     // TODO: Implement this function\n       println(planet1 + \" \" + planet2)",
  "        // TODO: use pattern matching and a switch statement to decide which \n\
    \        // case is to be performed.\n        val planets: List[String] = List(planet1,\
    \ planet2)\n        val orbits = planets.map(_.toLowerCase).toSet\n        val\
    \ sun = Planet.calculateSunOrbit()\n        val sunOrbit = Planet.calculateOrbit(planet1,\
    \ sun)\n        val sunOrbit1 = Planet.calculateOrbit(planet2, sun)\n        val\
    \ sunOrbit2 = Planet.calculateOrbit(planet1, sunOrbit)\n        val sunOrbit3\
    \ = Planet.calculateOrbit(planet2, sunOrbit1)\n        val sunOrbit4 = Planet.calculateOrbit(planet1,\
    \ sunOrbit2)\n        val sunOrbit5 = Planet.calculateOrbit(planet2, sunOrbit3)\n\
    \        val sunOrbit6 = Planet.calculateOrbit(planet1, sunOrbit4)\n        val\
    \ sunOrbit7 = Planet.calculateOrbit(planet2, sunOrbit5)\n        val sunOrbit8\
    \ = Planet.calculateOrbit(planet1, sunOrbit6)\n        val sunOrbit9 = Planet.calculateOrbit(planet2,\
    \ sunOrbit7)\n        val sunOrbit10 = Planet.calculateOrbit(planet1, sunOrbit8)\n\
    \        val sunOrbit11 = Planet.calculateOrbit(planet2, sunOrbit9)\n        val\
    \ sunOrbit12 = Planet.calculateOrbit(planet1, sunOrbit10)\n        val sunOrbit13\
    \ = Planet.calculateOrbit(planet2, sunOrbit11)\n        val sunOrbit14 = Planet.calculateOrbit(planet1,\
    \ sunOrbit12)\n        val sunOrbit15 = Planet.calculateOrbit(planet2, sunOrbit13)\n\
    \        val sunOrbit16 = Planet.calculateOrbit(planet1, sunOrbit14)\n       \
    \ val sunOrbit17 = Planet.calculateOrbit(planet2, sunOrbit15)\n        val sunOrbit18\
    \ = Planet.calculateOrbit(planet1, sunOrbit16)\n        val sunOrbit19 = Planet.calculateOrbit(planet2,\
    \ sunOrbit17)\n        val sunOrbit20 = Planet.calculateOrbit(planet1, sunOrbit18)\n\
    \        val sunOrbit21 = Planet.calculateOrbit(planet2, sunOrbit19)\n       \
    \ val sunOrbit", "        var sol : List[String] = List()\n        var list1 :\
    \ List[String] = List()\n        var list2 : List[String] = List()\n        var\
    \ list3 : List[String] = List()\n        var list4 : List[String] = List()\n \
    \       var list5 : List[String] = List()\n        var list6 : List[String] =\
    \ List()\n        var list7 : List[String] = List()\n        var list8 : List[String]\
    \ = List()\n        \n        if (planet1 != planet2) {\n            sol = sol\
    \ :+ planet1\n        }\n        else {\n            sol = sol :+ planet2\n  \
    \      }\n        \n        val planets1 : List[String] = List(\"Mercury\",\"\
    Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n  \
    \      val planets2 : List[String] = List(\"Mercury\",\"Venus\",\"Earth\",\"Mars\"\
    ,\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\")\n        \n        // If planet1\
    \ is the same as planet2\n        \n        if (planet1 == planet2) {\n      \
    \      sol = sol :+ planet1\n        }\n        else {\n            val planetIndex1\
    \ : Int = planets1.indexOf(planet1)\n            val planetIndex2 : Int = planets2.indexOf(planet2)\n\
    \            \n            for (i <- 0 until 8)\n            {\n             \
    \   // If planet1 is between the two planets indexed i and i+1\n             \
    \   \n                if (planets1(planetIndex1) == planets1(i) && planets1(planetIndex1\
    \ + 1) == planets1(i + 1))\n                {\n                    // If planet2\
    \ index is between the two planets indexed j and j+1\n                    \n \
    \                   if (planets2(planetIndex2) == planets2(j) && planets2(planetIndex2\
    \ + 1) == planets2(j + 1))\n                    {\n                        //\
    \ if i and j are within range of the list\n                        \n        \
    \                val j = j + 1\n                        val i = i + 1\n      \
    \                  val r = math.abs(i - j) \n                        \n      \
    \                  // if r is in range\n                        if (0 <= r &&\
    \ r <= 1)\n                        {\n                            // Append the\
    \ planets to the list\n                            if (planets1(planetIndex1)\
    \ == planets2(planetIndex2))\n                            {\n                \
    \                list1 = list1 :+ planets2(i)\n                            }\n\
    \                            else\n                            {\n           \
    \                     list1 = list1 :+ planets1(i)\n                         \
    \   }\n                            if (planets1(planetIndex1 + 1) == planets",
  "        // Write your code here.\n        var list: List[String] = List()\n   \
    \     if(planet1 == planet2){\n            list = List(planet1)\n        }else\
    \ if(planet1.contains(\"Neptune\") || planet2.contains(\"Neptune\")){\n      \
    \      list = List()\n        }else{\n            val distances = Array(50.2,\
    \ 101.4, 204.3, 309.6, 420.4, 527.8, 642.4, 756.3, 870.6, 987.4)\n           \
    \ val startTime = System.nanoTime\n            val distance1 = distances.filter(_\
    \ == distances.indexOf(planet1)).head\n            val distance2 = distances.filter(_\
    \ == distances.indexOf(planet2)).head\n            val difference = distance1\
    \ - distance2\n            val endTime = System.nanoTime\n            val totalTimeInSeconds\
    \ = (endTime - startTime)/1e9\n            val timeInSeconds = totalTimeInSeconds\
    \ * (difference/distance1)\n            list = distances.filter(_ == distance1).sortBy(x\
    \ => x/distance1).takeWhile(_ < timeInSeconds)\n        }\n        list.toList",
  "    val distanceMatrix = Array.ofDim[Int](7, 7)\n    val planetsBetween = List(planet1,\
    \ planet2).sorted\n    for (i <- 0 until 7) {\n        for (j <- 0 until 7) {\n\
    \            distanceMatrix(i, j) = math.pow(math.pow(math.pow(i - planet1.toDouble,\
    \ 2) + math.pow(j - planet2.toDouble, 2), 0.5), 0.5)\n        }", "        //\
    \ Code here\n        (planet1.toInt, planet2.toInt).flatMap{\n            case\
    \ (x, y) => if(x >= y){\n                List(planet2) :: List(planet1)\n    \
    \        } else {\n                List(planet1) :: List(planet2)\n          \
    \  }\n        }.toList", "        var planet1Orbits = ListBuffer[String]()\n \
    \       var planet2Orbits = ListBuffer[String]()\n        planet1Orbits = orbits(planet1)\n\
    \        planet2Orbits = orbits(planet2)\n        if (planet1Orbits.isEmpty)\n\
    \            return (planet2Orbits)\n        if (planet2Orbits.isEmpty)\n    \
    \        return (planet1Orbits)\n        var orbitsBetween = planet1Orbits.intersect(planet2Orbits)\n\
    \        planet1Orbits.foreach { planet1orbit =>\n            planet2Orbits.foreach\
    \ { planet2orbit =>\n                if (planet1orbit < planet2orbit) {\n    \
    \                orbitsBetween = planet1Orbits.intersect(planet2Orbits)\n    \
    \            }\n            }\n        }\n        orbitsBetween.sort { distanceToSun(it)\
    \ }", "        val sun = new Planet(\"Sun\")\n        val mercury = new Planet(\"\
    Mercury\")\n        val venus = new Planet(\"Venus\")\n        val earth = new\
    \ Planet(\"Earth\")\n        val mars = new Planet(\"Mars\")\n        val jupiter\
    \ = new Planet(\"Jupiter\")\n        val saturn = new Planet(\"Saturn\")\n   \
    \     val uranus = new Planet(\"Uranus\")\n        val neptune = new Planet(\"\
    Neptune\")\n        val planetList1 = List(mercury, venus, earth, mars, jupiter,\
    \ saturn, uranus, neptune)\n        val planetList2 = List(sun, planet1, planet2)\n\
    \        val planetList3 = planetList1.union(planetList2).sortBy(p => distance(p.position,\
    \ sun))\n        val planetList4 = planetList3.filter(_ == planet1 || _ == planet2)\n\
    \        return planetList4.toList", "        val sun : java.math.Coordinate =\
    \ java.util.Arrays.asList(1,0,0)\n        val earth : java.math.Coordinate = java.util.Arrays.asList(0,0,1)\n\
    \        val mercury : java.math.Coordinate = java.util.Arrays.asList(0,1,0)\n\
    \        val venus : java.math.Coordinate = java.util.Arrays.asList(0,-1,0)\n\
    \        val mars : java.math.Coordinate = java.util.Arrays.asList(-1,0,0)\n \
    \       val jupiter : java.math.Coordinate = java.util.Arrays.asList(0,-1,-1)\n\
    \        val saturn : java.math.Coordinate = java.util.Arrays.asList(-1,0,-1)\n\
    \        val uranus : java.math.Coordinate = java.util.Arrays.asList(-1,0,1)\n\
    \        val neptune : java.math.Coordinate = java.util.Arrays.asList(1,0,1)\n\
    \        val planetsList : List[String] = new mutable.HashSet[String]()\n\n  \
    \      planetsList.addAll(planet1, planet2)\n        planetsList.addAll(planet2,\
    \ planet1)\n        if (planetsList.toSet.size == 2) {\n            return planetsList.toList.sortBy(e\
    \ => sun.distance(e, earth))\n        }\n        return List() // return an empty\
    \ list if planetsList doesn't contain exactly two planets", "        val a = mutable.MutableList[String]()\n\
    \        for(((s, p1), (p2, d)) <- planetsAndDistances(planet1, planet2).zipWithIndex)\
    \ {\n            var xx = s\n            var yy = p1\n            var zz = p2\n\
    \            val d = d / Math.sqrt(Math.pow(xx - yy,2) + Math.pow(zx - zz,2))\n\
    \            val p = d * ((xx - yy) * Math.pow(zx - zz, 2) + (yy - zz) * Math.pow(xx\
    \ - zz, 2))\n            val q = d * ((yy - zz) * Math.pow(xx - zz, 2) + (xx -\
    \ zz) * Math.pow(yy - zz, 2))\n            val r = Math.sqrt((p * p) + (q * q))\n\
    \            if(r > 1){\n                r = r / Math.sqrt(Math.pow(xx - yy,2)\
    \ + Math.pow(zx - zz,2))\n                val (x1, y1) = xx, yy = yy\n       \
    \         val (x2, y2) = zz, zz\n                val dx = x2 - x1\n          \
    \      val dy = y2 - y1\n                val d = Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2))\n\
    \                val r = Math.sqrt((p * p) + (q * q))\n                val x =\
    \ (dx * p + dy * q) / (r * r * r)\n                val y = (dy * p + dx * q) /\
    \ (r * r * r)\n                val z = ((p * x) + (q * y)) / (r * r * r)\n   \
    \             val (xx1, yy1) = xx, yy = yy\n                val (zz1, zz2) = zz,\
    \ zz\n                val d = Math.sqrt(Math.pow(xx1 - yy1,2) + Math.pow(zz1 -\
    \ zz2,2))\n                val p = d * ((xx1 - yy1) * Math.pow(zz1 - zz2, 2) +\
    \ (yy1 - zz1) * Math.pow(xx1 - zz2, 2))\n                val q = d * ((yy1 - zz1)\
    \ * Math.pow(xx1 - zz2, 2) + (xx1 - zz1) * Math.pow(yy1 - zz2, 2))\n         \
    \       val r = Math.sqrt((p * p) + (q * q))\n                val x = (dx * p\
    \ + dy * q) / (r * r * r)\n                val y = (dy * p + dx * q) / (r * r\
    \ * r)\n                val z = ((p * x) + (q * y)) / (r * r * r)\n          \
    \      a = a :+ ((x).toString + \"|\" + (y).toString + \"|\" + (z).toString)\n\
    \            }\n        }\n        a.sortWith((s1, s2) => s1 < s2)", "       \
    \ val planets = List(planet1, planet2)\n        val sun = Planet(Planet.Name.SUN,\
    \ \"Sun\", Planet.Position.ZERO)\n        val mercury = Planet(Planet.Name.MERCURY,\
    \ \"Mercury\", Planet.Position.ZERO)\n        val venus = Planet(Planet.Name.VENUS,\
    \ \"Venus\", Planet.Position.ZERO)\n        val earth = Planet(Planet.Name.EARTH,\
    \ \"Earth\", Planet.Position.ZERO)\n        val mars = Planet(Planet.Name.MARS,\
    \ \"Mars\", Planet.Position.ZERO)\n        val jupiter = Planet(Planet.Name.JUPITER,\
    \ \"Jupiter\", Planet.Position.ZERO)\n        val saturn = Planet(Planet.Name.SATURN,\
    \ \"Saturn\", Planet.Position.ZERO)\n        val uranus = Planet(Planet.Name.URANUS,\
    \ \"Uranus\", Planet.Position.ZERO)\n        val neptune = Planet(Planet.Name.NEPTUNE,\
    \ \"Neptune\", Planet.Position.ZERO)\n        val planetList = (List(mercury,\
    \ venus, earth, mars, jupiter, saturn, uranus, neptune), List(sun))\n        val\
    \ planetsAfterMercuryAndEarth = planetList.map { p => (p) }\n        planetsAfterMercuryAndEarth\
    \ = planetsAfterMercuryAndEarth.map { p => (p.name.toString, p.position.toString,\
    \ p.radius.toDouble) }\n        val planetsAfterMercuryAndEarth1 = planetsAfterMercuryAndEarth.map\
    \ { x => x._1 }\n        val planetsAfterMercuryAndEarth2 = planetsAfterMercuryAndEarth.map\
    \ { x => x._2 }\n        val sunOrbit = sun.getOrbit(mercury, earth)\n       \
    \ val mercuryOrbit = mercury.getOrbit(sun, venus)\n        val earthOrbit = earth.getOrbit(sun,\
    \ mars)\n        val marsOrbit = mars.getOrbit(sun, jupiter)\n        val jupiterOrbit\
    \ = jupiter.getOrbit(sun, saturn)\n        val saturnOrbit = saturn.getOrbit(sun,\
    \ uranus)", "        val orbit1 = Orbits(planet1)\n        val orbit2 = Orbits(planet2)\n\
    \n        val orbit1sun = orbit1.getSunPosition\n        val orbit2sun = orbit2.getSunPosition\n\
    \n        val orbit1Orbits = orbit1.getAllOrbits\n        val orbit2Orbits = orbit2.getAllOrbits\n\
    \n        val orbit1OrbitsSun = orbit1Orbits.filter(orbit1 => orbit1.getSunPosition.distanceToOrbit(orbit1sun)\
    \ < 0.2)\n        val orbit2OrbitsSun = orbit2Orbits.filter(orbit2 => orbit2.getSunPosition.distanceToOrbit(orbit2sun)\
    \ < 0.2)\n\n        // return empty list if planet1 or planet2 not correct planet\
    \ names\n        if (orbit1OrbitsSun.isEmpty || orbit2OrbitsSun.isEmpty)\n   \
    \         List()\n        else {\n            val orbit1OrbitsSunSorted = orbit1OrbitsSun.sortWith((orbit1,\
    \ orbit2) => orbit1.getSunPosition.distanceToOrbit(orbit1sun) - orbit2.getSunPosition.distanceToOrbit(orbit2sun))\n\
    \            val orbit2OrbitsSunSorted = orbit2OrbitsSun.sortWith((orbit1, orbit2)\
    \ => orbit1.getSunPosition.distanceToOrbit(orbit1sun) - orbit2.getSunPosition.distanceToOrbit(orbit2sun))\n\
    \n            (orbit1OrbitsSunSorted.take(3), orbit2OrbitsSunSorted.take(3))\n\
    \        }", "        planet1 match {\n            case planet1 if (planet1.length\
    \ < 2) => \"no planet\"\n            case planet1 if (planet1.length < 4) => \"\
    no planet\"\n            case planet1 if (planet1.length < 6) => \"no planet\"\
    \n            case planet1 if (planet1.length < 8) => \"no planet\"\n        \
    \    case planet1 if (planet1.length < 10) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 12) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 14) => \"no planet\"\n            case planet1 if (planet1.length\
    \ < 16) => \"no planet\"\n            case planet1 if (planet1.length < 18) =>\
    \ \"no planet\"\n            case planet1 if (planet1.length < 20) => \"no planet\"\
    \n            case planet1 if (planet1.length < 22) => \"no planet\"\n       \
    \     case planet1 if (planet1.length < 24) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 26) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 28) => \"no planet\"\n            case planet1 if (planet1.length\
    \ < 30) => \"no planet\"\n            case planet1 if (planet1.length < 32) =>\
    \ \"no planet\"\n            case planet1 if (planet1.length < 34) => \"no planet\"\
    \n            case planet1 if (planet1.length < 36) => \"no planet\"\n       \
    \     case planet1 if (planet1.length < 38) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 40) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 42) => \"no planet\"\n            case planet1 if (planet1.length\
    \ < 44) => \"no planet\"\n            case planet1 if (planet1.length < 46) =>\
    \ \"no planet\"\n            case planet1 if (planet1.length < 48) => \"no planet\"\
    \n            case planet1 if (planet1.length < 50) => \"no planet\"\n       \
    \     case planet1 if (planet1.length < 52) => \"no planet\"\n            case\
    \ planet1 if (planet1.length < 54) => \"no planet\"\n            case planet1\
    \ if (planet1.length < 56) => \"no planet\"\n            case planet1 if (plan",
  "        val planets = mutable.ListBuffer[String]()\n        planets ++= Seq(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        planets ++= Seq(planet1, planet2)\n        planets.toList\
    \ sortBy (x => planets.indexOf(x.toUpperCase).asInstanceOf[Int] - planets.indexOf(x.toUpperCase).asInstanceOf[Int])\
    \ * planets.indexOf(planet1.toUpperCase).asInstanceOf[Int] - planets.indexOf(planet2.toUpperCase).asInstanceOf[Int]",
  "      val planetsBetween = for {\n        planet <- Planets\n        if (planet.name\
    \ == planet1) || (planet.name == planet2)\n      } yield planet.name\n      val\
    \ planetsBetweenWithDistance = for {\n        planet <- Planets\n        if (planet.name\
    \ == planet1) || (planet.name == planet2)\n      } yield (planet.name, distance(planet))\n\
    \      planetsBetween.sortBy(_._2)\n    } \n    def distance(p1 : Planet) : Double\
    \ = {\n      val earth = Sun\n      val sun = p1.orbit(earth)\n      val p2 =\
    \ p1.orbit(p1.orbit(sun))\n      val p3 = p2.orbit(p2.orbit(sun))\n      val p4\
    \ = p3.orbit(p3.orbit(sun))\n      val p5 = p4.orbit(p4.orbit(sun))\n      val\
    \ p6 = p5.orbit(p5.orbit(sun))\n      val p7 = p6.orbit(p6.orbit(sun))\n     \
    \ val p8 = p7.orbit(p7.orbit(sun))\n      val planet1Dist = math.pow((sun - p1),\
    \ 2)\n      val planet2Dist = math.pow((sun - p2), 2)\n      val planet3Dist =\
    \ math.pow((sun - p3), 2)\n      val planet4Dist = math.pow((sun - p4), 2)\n \
    \     val planet5Dist = math.pow((sun - p5), 2)\n      val planet6Dist = math.pow((sun\
    \ - p6), 2)\n      val planet7Dist = math.pow((sun - p7), 2)\n      val planet8Dist\
    \ = math.pow((sun - p8), 2)\n      math.sqrt(((planet1Dist + planet2Dist + planet3Dist\
    \ + planet4Dist + planet5Dist + planet6Dist + planet7Dist + planet8Dist)^(1/2)))",
  "        def distance(a: Double, b: Double) : Double = a * b\n        val planets\
    \ = Set(planet1, planet2)\n        val a1 = planets.filter(x => x == planet1).map(x\
    \ => distance(x,0))\n        val a2 = planets.filter(x => x == planet2).map(x\
    \ => distance(0, x))\n        val b = a1.zip(a2).map(x => distance(x(0), x(1)))\n\
    \        val sorted = b.sortBy(x => x)\n        if (sorted.last < 0 ) { List()\
    \ } else { sorted.reverse }", "        // TODO: your code here\n        val a\
    \ = List(planet1, planet2)\n        var b : List[String] = Nil\n        for (x\
    \ <- a){\n            var c : List[String] = Nil\n            for (y <- a){\n\
    \                val distance = getDistance(planet1, x)\n                if (distance\
    \ < getDistance(x, planet2)){\n                    c = x :: y\n              \
    \  }\n            }\n            b +=  c.sortWith((x1,x2) => x1.compareTo(x2))\n\
    \        }\n        b.toList", "        val mercury = getOrbital(planet1)\n  \
    \      val venus = getOrbital(planet2)\n        val earth = getOrbital(planet1)\n\
    \        val mars = getOrbital(planet2)\n        val jupiter = getOrbital(planet1)\n\
    \        val saturn = getOrbital(planet2)\n        val uranus = getOrbital(planet2)\n\
    \        val neptune = getOrbital(planet2)\n        val planets = List(mercury,\
    \ venus, earth, mars, jupiter, saturn, uranus, neptune)\n        val sunOrbit\
    \ = Orbital(\"Sun\", 0, 0, 0)\n        val orbits = List(mercury, venus, earth,\
    \ mars, jupiter, saturn, uranus, neptune)\n        val sunOrbitIndex = orbits.index(sunOrbit)\n\
    \        val planet1 = orbits(sunOrbitIndex)\n        val planet2 = orbits((sunOrbitIndex\
    \ + 1) %orbits.length)\n        val distance = math.sqrt((planet1.x - planet2.x)\
    \ * (planet1.x - planet2.x) + (planet1.y - planet2.y) * (planet1.y - planet2.y)\
    \ + (planet1.z - planet2.z) * (planet1.z - planet2.z))\n        var sortedOrbits\
    \ = orbits.filterNot(p => planets.contains(p)).sortWith((a, b) => math.abs(a.x\
    \ - b.x) < math.abs(a.y - b.y) && math.abs(a.x - b.x) < math.abs(a.z - b.z))\n\
    \        val distances = sortedOrbits.map(p => math.sqrt((p.x - planet1.x) * (p.x\
    \ - planet1.x) + (p.y - planet1.y) * (p.y - planet1.y) + (p.z - planet1.z) * (p.z\
    \ - planet1.z)))\n        val result = distances.filter(_ < distance)\n      \
    \  result.map(p => orbits((orbits.index(planet1) + p) %orbits.length)).toList",
  "        if(planet1.toUpperCase == \"MERCURY\"){\n            if(planet2.toUpperCase\
    \ == \"NEPTUNE\"){\n                return List(\"Saturn\", \"Uranus\")\n    \
    \        }\n        }", "        val planets = mutable.LinkedHashMap[String, String]()\n\
    \        planets +=(\"Jupiter\" -> \"Saturn\")\n        planets +=(\"Earth\" ->\
    \ \"Venus\")\n        planets +=(\"Mercury\" -> \"Uranus\")\n        planets +=(\"\
    Venus\" -> \"Earth\")\n        planets +=(\"Mars\" -> \"Jupiter\")\n        planets\
    \ +=(\"Saturn\" -> \"Mercury\")\n        planets +=(\"Uranus\" -> \"Mercury\"\
    )\n        planets +=(\"Neptune\" -> \"Earth\")\n\n        (planets.get(planet1),\
    \ planets.get(planet2)).filter(_ != null).map(_._2).sortBy(_ > _)", "        val\
    \ orbit_planet1 = orbit(planet1, planet2)\n        val orbit_planet2 = orbit(planet2,\
    \ planet1)\n        val list1 = findOrbitBetweenPlanets(orbit_planet1, orbit_planet2)\n\
    \        val list2 = findOrbitBetweenPlanets(orbit_planet2, orbit_planet1)\n \
    \       list1 ::: list2", "        val planets = mutable.ListBuffer[String]()\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(rep(word(alphabet)))\n\
    \        planets ++= scala.util.parsing.combinator.JavaTokenParsers.spaceDelimitedList(re",
  "        val planets = List(planet1, planet2)\n        val sunOrbit = planets.map(_\
    \ -> 1).sum\n        val sun = planets.map(_ -> 0).sum\n        val orbit = planets.map((_,\
    \ _) => 0).zipWithIndex\n        val planets = orbit.filter(_._2 <= sun).filter(_._2\
    \ > sunOrbit).sortBy(_._1)\n        val a = planets.filter(_._1 == \"Earth\")\n\
    \        val b = planets.filter(_._1 == \"Mercury\")\n        val c = planets.filter(_._1\
    \ == \"Venus\")\n        val d = planets.filter(_._1 == \"Mars\")\n        val\
    \ e = planets.filter(_._1 == \"Jupiter\")\n        val f = planets.filter(_._1\
    \ == \"Saturn\")\n        val g = planets.filter(_._1 == \"Uranus\")\n       \
    \ val h = planets.filter(_._1 == \"Neptune\")\n        a :+ b :+ c :+ d :+ e :+\
    \ f :+ g :+ h match {\n            case x => x.toList\n        }", "      val\
    \ (earth, mercury, venus, mars, jupiter, saturn, uranus, neptune) = (planet1 ::\
    \ planet2).sliding(2)\n      \n      val (earth1, mercury1, venus1, mars1, jupiter1,\
    \ saturn1, uranus1, neptune1) = (earth :+ mercury, venus :+ mercury, venus :+\
    \ mars, jupiter, saturn, uranus, neptune)\n      val (earth2, mercury2, venus2,\
    \ mars2, jupiter2, saturn2, uranus2, neptune2) = (earth :+ mercury, venus :+ mercury,\
    \ venus :+ mars, jupiter, saturn, uranus, neptune)\n      \n      val p1 = earth1\
    \ ++ mercury1 ++ venus1 ++ mars1 ++ jupiter1 ++ saturn1 ++ uranus1 ++ neptune1\n\
    \      val p2 = earth2 ++ mercury2 ++ venus2 ++ mars2 ++ jupiter2 ++ saturn2 ++\
    \ uranus2 ++ neptune2\n\n      val p1 = p1.toList\n      val p2 = p2.toList\n\n\
    \      val p1 = p1 diff p2\n      val p2 = p2 diff p1\n\n      val p1 = p1 sortBy\
    \ (x => math.abs(x - math.round(math.sin(math.pi/6) * (x - (math.pi/6))))) \n\
    \      val p2 = p2 sortBy (x => math.abs(x - math.round(math.sin(math.pi/6) *\
    \ (x - (math.pi/6))))) \n      \n      p1 ++ p2", "        val planets = List(planet1,\
    \ planet2)\n        val sun = Planet(\"Sun\")\n        val mercury = Planet(\"\
    Mercury\")\n        val venus = Planet(\"Venus\")\n        val earth = Planet(\"\
    Earth\")\n        val mars = Planet(\"Mars\")\n        val jupiter = Planet(\"\
    Jupiter\")\n        val saturn = Planet(\"Saturn\")\n        val uranus = Planet(\"\
    Uranus\")\n        val neptune = Planet(\"Neptune\")\n\n        // A simple function\
    \ to find the distance between two planets\n        val distanceBetweenPlanets\
    \ = (planet: Planet) => planet.distanceTo(sun)\n\n        // Planets where the\
    \ planet is located between its orbits\n        val planetsBetweenPlanets = planets.map(distanceBetweenPlanets)\n\
    \            .filter( d => d > 0)\n\n        // Sort planets\n        val orderedPlanets\
    \ = planetsBetweenPlanets.sorted\n            .zipWithIndex.filter{case (planet,\
    \ index) => planet > 0}\n            .map{case (planet, index) => planets(index)\
    \ }\n\n        // return empty list if one of the planets are not correct\n  \
    \      if (planet1 != planet2) {\n            val empty = List[String]()\n   \
    \         if (planet1 == null || planet2 == null) {\n                empty\n \
    \           } else if (planet1 == planet2) {\n                List(planet1)\n\
    \            } else {\n                List(planet1, planet2)\n            }\n\
    \        } else {\n            orderedPlanets\n        }", "        def distance(x:\
    \ Double, y: Double) : Double = {\n            val dist = sqrt(x*x + y*y)\n  \
    \          dist\n        }\n        val list1 = List(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val list2 =\
    \ List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\")\n        if(planet1.toUpperCase == \"JUPITER\" && planet2.toUpperCase\
    \ == \"NEPTUNE\") {\n            return list2.sortWith(distance(_, 8.4))\n   \
    \     } else if (planet1.toUpperCase == \"EARTH\" && planet2.toUpperCase == \"\
    MERCURY\") {\n            return list1.sortWith(distance(_, 8.4))\n        } else\
    \ if (planet1.toUpperCase == \"MERCURY\" && planet2.toUpperCase == \"URANUS\"\
    ) {\n            return list1.sortWith(distance(_, 4.4))\n        } else if (planet1.toUpperCase\
    \ == \"MERCURY\" && planet2.toUpperCase == \"NEPTUNE\") {\n            return\
    \ list2.sortWith(distance(_, 4.4))\n        } else if (planet1.toUpperCase ==\
    \ \"MARS\" && planet2.toUpperCase == \"JUPITER\") {\n            return list1.sortWith(distance(_,\
    \ 8.4))\n        } else if (planet1.toUpperCase == \"MARS\" && planet2.toUpperCase\
    \ == \"SATURN\") {\n            return list2.sortWith(distance(_, 8.4))\n    \
    \    } else if (planet1.toUpperCase == \"MARS\" && planet2.toUpperCase == \"URANUS\"\
    ) {\n            return list1.sortWith(distance(_, 4.4))\n        } else if (planet1.toUpperCase\
    \ == \"MARS\" && planet2.toUpperCase == \"NEPTUNE\") {\n            return list2.sortWith(distance(_,\
    \ 4.4))\n        } else if (planet1.toUpperCase == \"JUPITER\" && planet2.toUpperCase\
    \ == \"SATURN\") {\n            return list1.sortWith(distance(_, 8.4))\n    \
    \    } else if (planet1.toUpperCase == \"JUPITER\" && planet2.toUpperCase == \"\
    URANUS\") {\n            return list1.sortWith(distance(_, 4.4))\n        } else\
    \ if (planet1.toUpperCase == \"JUPITER\" && planet2.toUpperCase == \"NEPTUNE\"\
    ) {\n            return list2.sortWith(distance(_, 4.4))\n        } else if (planet1.toUpperCase\
    \ == \"SATURN\" && planet2.toUpperCase == \"URANUS\") {\n            return list1.",
  "        val orbits = Map(\n            (\"Jupiter\", \"Mercury\"),\n          \
    \  (\"Venus\", \"Earth\"),\n            (\"Earth\", \"Mars\"),\n            (\"\
    Mars\", \"Jupiter\"),\n            (\"Jupiter\", \"Saturn\"),\n            (\"\
    Saturn\", \"Uranus\"),\n            (\"Uranus\", \"Neptune\")\n        )\n   \
    \     val orbit1 = orbits(planet1)\n        val orbit2 = orbits(planet2)\n   \
    \     val intersections = intersection(orbit1, orbit2)\n        val planetsInOrbit1\
    \ = intersections.map(x => orbits(x)).sortBy(x => scala.math.sqrt((x - orbit2).pow(2)).abs)\n\
    \        val planetsInOrbit2 = intersections.map(x => orbits(x)).sortBy(x => scala.math.sqrt((x\
    \ - orbit1).pow(2)).abs)\n        val intersection = planetsInOrbit1 ++ planetsInOrbit2\n\
    \        val sun = orbits(\"Sun\")\n        val planetsInOrbit = intersection.map(x\
    \ => orbits(x)).sortBy(x => scala.math.sqrt((x - sun).pow(2)).abs)\n        planetsInOrbit",
  "        val orbit1 = List(Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus,\
    \ Neptune).toMap\n        val orbit2 = List(Mercury, Venus, Earth, Mars, Jupiter,\
    \ Saturn, Uranus, Neptune).toMap\n        val orbit12 = orbit1 ++ orbit2\n   \
    \     val sun = Melania\n        val dist = new DistanceCalc(sun)\n        val\
    \ planetsBetween = (planet1 :: planet2) map { planet => planet }\n        if (planetsBetween.forall(_.startsWith(\"\
    Mercury\"))) List(planet1) else List()\n    } \n    // There is only one planet\
    \ in our solar system Earth. \n    // Write a function that, given a string planet\
    \ name, returns the orbit \n    // of that planet. \n    // The function should\
    \ return \"0.0\" if the planet does not exist. \n    // Examples\n    // >>> planet(Melania)\n\
    \    // 0.0\n    // >>> planet(\"Mercury\")\n    // 0.0\n    // >>> planet(\"\
    Earth\")\n    // 0.0\n    // >>> planet(\"Venus\")\n    // 0.0\n    def planet(planet\
    \ : String) : Double = {\n        val orbit = List(Mercury, Venus, Earth, Mars,\
    \ Jupiter, Saturn, Uranus, Neptune).toMap\n        if (planet.startsWith(\"Mercury\"\
    )) 0.0\n        else if (planet.startsWith(\"Venus\")) 0.0\n        else if (planet.startsWith(\"\
    Earth\")) 0.0\n        else if (planet.startsWith(\"Mars\")) 0.0\n        else\
    \ if (planet.startsWith(\"Jupiter\")) 0.0\n        else if (planet.startsWith(\"\
    Saturn\")) 0.0\n        else if (planet.startsWith(\"Uranus\")) 0.0\n        else\
    \ if (planet.startsWith(\"Neptune\")) 0.0\n        else orbit.get(planet)\n  \
    \  } \n    // The radius of the Sun is 0.6973 au. \n    // Write a function that,\
    \ given a name of a planet and returns its radius. \n    // The function should\
    \ return \"0.0\" if the planet does not exist. \n    // Examples\n    // >>> radius(Melania)\n\
    \    // 0.0\n    // >>> radius(\"Mercury\")\n    // 0.0\n    // >>> radius(\"\
    Earth\")\n    // 0.0\n    // >>> radius(\"Venus\")\n    // 0.0\n    def radius(planet\
    \ : String) : Double = {\n        val orbit = List(Mercury, Venus, Earth, Mars,\
    \ Jupiter, Saturn, Uranus, Ne", "        val planet1 = \"Mercury\"\n        val\
    \ planet2 = \"Venus\"\n        val planet3 = \"Earth\"\n        val planet4 =\
    \ \"Mars\"\n        val planet5 = \"Jupiter\"\n        val planet6 = \"Saturn\"\
    \n        val planet7 = \"Uranus\"\n        val planet8 = \"Neptune\"\n      \
    \  val planet = planet1 :: planet2 :: planet3 :: planet4 :: planet5 :: planet6\
    \ :: planet7 :: planet8\n        val sun = Planet.sun\n        val orb = (planet\
    \ contains planet1) match {\n            case true => (planet contains planet2)\n\
    \            case false => orb(planet1, planet2)\n        }\n        val sun_orb\
    \ = (sun contains planet1) match {\n            case true => (sun contains planet2)\n\
    \            case false => orb(planet1, planet2)\n        }\n        if (sun_orb.isDefined)\
    \ List(planet1.toString -> sun_orb.get.orbit.toString, sun_orb.get.orbit.toString)\
    \ :: orb.toList else orb", "        val sunOrbit = List(\n            List(List(List(0.12,\
    \ 0.12, 0.12), List(0.17, 0.17, 0.17), List(0.30, 0.30, 0.30)), \n           \
    \ List(List(0.07, 0.13, 0.06), List(0.06, 0.11, 0.07), List(0.09, 0.12, 0.12),\
    \ List(0.09, 0.11, 0.11)), \n            List(List(0.06, 0.07, 0.06), List(0.06,\
    \ 0.07, 0.11), List(0.05, 0.11, 0.05)),\n            List(List(0.05, 0.11, 0.05),\
    \ List(0.05, 0.11, 0.05), List(0.07, 0.11, 0.07)),\n            List(List(0.07,\
    \ 0.11, 0.07), List(0.07, 0.11, 0.07)), \n            List(List(0.09, 0.10, 0.09),\
    \ List(0.09, 0.11, 0.09), List(0.09, 0.11, 0.11)), \n            List(List(0.05,\
    \ 0.12, 0.10), List(0.05, 0.11, 0.10), List(0.05, 0.11, 0.10), List(0.07, 0.11,\
    \ 0.10)), \n            List(List(0.05, 0.11, 0.10), List(0.05, 0.12, 0.10), List(0.05,\
    \ 0.11, 0.10), List(0.06, 0.11, 0.10)), \n            List(List(0.07, 0.11, 0.10),\
    \ List(0.05, 0.12, 0.10), List(0.05, 0.11, 0.10), List(0.06, 0.11, 0.10)),\n \
    \           List(List(0.05, 0.11, 0.10), List(0.05, 0.12, 0.10), List(0.05, 0.11,\
    \ 0.10), List(0.06, 0.11, 0.10))\n        )\n        val p1 = planet1 \n     \
    \   val p2 = planet2 \n        val orbits1 = sunOrbit(p1)\n        val orbits2\
    \ = sunOrbit(p2)\n        val orbits = orbits1.intersect(orbits2).sortBy(x =>\
    \ x.diff[Double](x.productElement(0)))\n        orbits.flatMap(x => List(if (p1\
    \ < x) p1 else x, if (p2 < x) p2 else x))", "        var list : List[String] =\
    \ Nil\n        var x = 0\n        var y = 0\n        var z = 100\n\n        //The\
    \ sun should be located in Earth\n        if (planet1.equals(\"Earth\")) list\
    \ = Nil\n\n        //Mercury is a great planet but is located between Mars and\
    \ Jupiter\n        else if (planet1.equals(\"Mercury\") && planet2.equals(\"Mars\"\
    ) || planet1.equals(\"Mercury\") && planet2.equals(\"Jupiter\")) list += planet1\n\
    \n        //Mercury and Venus are far apart so they aren't in the list.\n    \
    \    else if (planet1.equals(\"Mercury\") && planet2.equals(\"Venus\")) list =\
    \ Nil\n\n        //Earth and Jupiter are both great planets so they will be in\
    \ the list\n        else if (planet1.equals(\"Earth\") && planet2.equals(\"Jupiter\"\
    )) list += planet1\n\n        //Mercury and Venus are too close so the planets\
    \ must be in the list.\n        else if (planet1.equals(\"Mercury\") && planet2.equals(\"\
    Venus\")) list += planet1\n\n        //The two planets are near each other so\
    \ they are in the list.\n        else if (planet1.equals(\"Neptune\") && planet2.equals(\"\
    Pluto\")) list += planet1\n\n        //The two planets are too far apart so the\
    \ planets must be in the list.\n        else if (planet1.equals(\"Neptune\") &&\
    \ planet2.equals(\"Pluto\")) list += planet1\n\n        //The two planets are\
    \ near each other but Mercury and Venus are too far apart so they are in the list.\n\
    \        else if (planet1.equals(\"Neptune\") && planet2.equals(\"Pluto\")) list\
    \ += planet1\n\n        //The two planets are too far apart so the planets must\
    \ be in the list.\n        else if (planet1.equals(\"Neptune\") && planet2.equals(\"\
    Pluto\")) list += planet1\n\n        //The two planets are too far apart so the\
    \ planets must be in the list.\n        else if (planet1.equals(\"Neptune\") &&\
    \ planet2.equals(\"Pluto\")) list += planet1\n\n        //The two planets are\
    \ too far apart so the planets must be in the list.\n        else if (planet1.equals(\"\
    Neptune\") && planet2.equals(\"Pluto\")) list += planet1\n\n        //The two ",
  "        val mercuryVsJupiter = orbbetween(\"Mercury\", \"Jupiter\")\n        val\
    \ venusVsEarth = orbbetween(\"Venus\", \"Earth\")\n        val mercuryVsMercury\
    \ = orbbetween(\"Mercury\", \"Mercury\")\n        val mercuryVsVenus = orbbetween(\"\
    Mercury\", \"Venus\")\n        val mercuryVsEarth = orbbetween(\"Mercury\", \"\
    Earth\")\n        val mercuryVsMars = orbbetween(\"Mercury\", \"Mars\")\n    \
    \    val mercuryVsJupiter = orbbetween(\"Mercury\", \"Jupiter\")\n        val\
    \ mercuryVsSaturn = orbbetween(\"Mercury\", \"Saturn\")\n        val mercuryVsUranus\
    \ = orbbetween(\"Mercury\", \"Uranus\")\n        val mercuryVsNeptune = orbbetween(\"\
    Mercury\", \"Neptune\")\n        val venusVsEarth = orbbetween(\"Venus\", \"Earth\"\
    )\n        val mercuryVsMercury = orbbetween(\"Mercury\", \"Mercury\")\n     \
    \   val mercuryVsVenus = orbbetween(\"Mercury\", \"Venus\")\n        val mercuryVsEarth\
    \ = orbbetween(\"Mercury\", \"Earth\")\n        val mercuryVsMars = orbbetween(\"\
    Mercury\", \"Mars\")\n        val mercuryVsJupiter = orbbetween(\"Mercury\", \"\
    Jupiter\")\n        val mercuryVsSaturn = orbbetween(\"Mercury\", \"Saturn\")\n\
    \        val mercuryVsUranus = orbbetween(\"Mercury\", \"Uranus\")\n        val\
    \ mercuryVsNeptune = orbbetween(\"Mercury\", \"Neptune\")\n        val venusVsMars\
    \ = orbbetween(\"Venus\", \"Mars\")\n        val mercuryVsJupiter = orbbetween(\"\
    Mercury\", \"Jupiter\")\n        val mercuryVsSaturn = orbbetween(\"Mercury\"\
    , \"Saturn\")\n        val mercuryVsUranus = orbbetween(\"Mercury\", \"Uranus\"\
    )\n        val mercuryVsNeptune = orbbetween(\"Mercury\", \"Neptune\")\n     \
    \   val venusVs", "      val planets = mutable.ListBuffer[String]()\n      val\
    \ planet1 = planet1.toUpperCase\n      val planet2 = planet2.toUpperCase\n   \
    \   \n      if(planet1 == planet2) planets += planet1\n      else {\n        if(planet1\
    \ == planets(\"Mercury\"))\n          planets ++= planets(\"Mercury\") :+ planet2\n\
    \        else\n          planets ++= planets(\"Earth\") :+ planets(\"Mars\") :+\
    \ planets(\"Jupiter\") :+ planets(\"Saturn\") :+ planets(\"Uranus\") :+ planets(\"\
    Neptune\")\n      }\n      \n      planets.toList", "        val orbit1 = Orbit(planet1,\
    \ 0, 0, 0)\n        val orbit2 = Orbit(planet2, 0, 0, 0)\n        var earth_distance\
    \ : Double = 0.0\n        var earth_list: List[String] = Nil\n        var earth_name\
    \ = \"\"\n        var i = 0\n        var j = 0\n        var k = 0\n        for(\
    \ i <- 0 to orbit1.earth_distance) {\n            earth_distance += orbit1.earth_distance\n\
    \            for( j <- 0 to orbit2.earth_distance) {\n                if(earth_distance\
    \ > orbit2.earth_distance) {\n                    break\n                }\n \
    \               if((orbit1.earth_distance == orbit2.earth_distance) && (earth_distance\
    \ == orbit1.earth_distance)) {\n                    for( k <- 0 to orbit2.earth_distance)\
    \ {\n                        if(earth_distance > orbit2.earth_distance) {\n  \
    \                          break\n                        }\n                \
    \        if((orbit1.earth_distance == orbit2.earth_distance) && (earth_distance\
    \ == orbit1.earth_distance)) {\n                            if(orbit1.sun_distance\
    \ < orbit2.sun_distance) {\n                                earth_name = planet1\n\
    \                                earth_list = orbit2.orbit1\n                \
    \            }\n                            if(orbit1.sun_distance > orbit2.sun_distance)\
    \ {\n                                earth_name = planet2\n                  \
    \              earth_list = orbit1.orbit1\n                            }\n   \
    \                         earth_distance = orbit2.earth_distance\n           \
    \             }\n                    }\n                }\n                earth_distance\
    \ = orbit2.earth_distance\n            }\n        }\n        return earth_list.sortWith(_\
    \ < _)", "        val orbit1 = getOrbit(planet1)\n        val orbit2 = getOrbit(planet2)\n\
    \        var res : List[String] = Nil\n        for ( i <- 1 to orbit1.length )\
    \ {\n            res ::= getOrbit(orbit1.get(i)) \n            if (orbit2.contains(orbit1.get(i)))\
    \ {\n                for ( j <- 1 to orbit2.length ) {\n                    if\
    \ (orbit1.contains(orbit2.get(j))) {\n                        res += orbit2.get(j)\n\
    \                    }\n                }\n            }\n        }\n        res",
  "        var planets : List[String] = Nil\n        var i = 0\n        while(i <\
    \ planet1.length) {\n            planets = planets ++ List((planet1.substring(i,\
    \ i + 1), planet2.substring(i, i + 1)))\n            i += 2\n        }\n     \
    \   var j = 0\n        var k = 0\n        var j1 = 0\n        var k2 = 0\n   \
    \     while(j < planet2.length) {\n            if(planet1.length == j1) {\n  \
    \              planets = planets ++ List((planet2.substring(j, j), planet2.substring(k,\
    \ k)))\n                j += 2\n                k += 2\n            }\n      \
    \      if(planet1.length == k2) {\n                planets = planets ++ List((planet1.substring(j,\
    \ j), planet1.substring(k, k)))\n                j += 2\n                k +=\
    \ 2\n            }\n            j1 = j + 1\n            k2 = k + 1\n        }\n\
    \        if(planet1.length != j) {\n            planets = planets ++ List((planet1.substring(j,\
    \ j), planet2.substring(j, j)))\n        }\n        if(planet2.length != k) {\n\
    \            planets = planets ++ List((planet1.substring(j, j), planet2.substring(k,\
    \ k)))\n        }\n        planets.sortBy(x => (getProximity(x).toDouble))", " \
    \     val planets = Set(planet1, planet2)\n      val planetList1 = List(\n   \
    \     \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\",\n \
    \       \"Neptune\")\n      val planetList2 = List(\n        \"Mercury\", \"Moon\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\",\n        \"Uranus\"\
    , \"Neptune\")\n      val distFunc = (planet1: String, planet2: String) => \n\
    \        planetList1.map(planet1 => planetList2.map(planet2 => \n          if\
    \ (planet1 == planet2) 0 else\n        math.sqrt((planetList1.indexWhere(p =>\
    \ p < planet1) + \n          planetList1.indexWhere(p => p > planet1) + \n   \
    \       planetList2.indexWhere(p => p < planet2) + \n          planetList2.indexWhere(p\
    \ > planet2)) - planetList1.indexWhere(p => \n          p < planet1) + planetList2.indexWhere(p\
    \ > planet2))).max(0)).min(0)\n      val result = (planets: Iterable[String]).iterator.map(planet1\
    \ =>\n        planets.filter(planet2 => distFunc(planet1, planet2) == distFunc(planet2,\
    \ \n          planet1)).toList)\n      result.flatten.sorted", "        if (planet1\
    \ == planet2) List(planet1)\n        else if (planet1 <> planet2) List()\n   \
    \     else (\n            (\n                planet1.toUpperCase.takeWhile(_ !=\
    \ 'E').foldLeft(List())((list, letter) =>\n                    val (i, planet)\
    \ = if (letter == 'M') (planet1.toUpperCase.indexOf(\"MERCURY\") + 1, planet1)\n\
    \                              else if (letter == 'V') (planet1.toUpperCase.indexOf(\"\
    VENUS\") + 1, planet1)\n                              else if (letter == 'E')\
    \ (planet1.toUpperCase.indexOf(\"EARTH\") + 1, planet1)\n                    \
    \          else if (letter == 'M') (planet1.toUpperCase.indexOf(\"MARS\") + 1,\
    \ planet1)\n                              else if (letter == 'J') (planet1.toUpperCase.indexOf(\"\
    JUPITER\") + 1, planet1)\n                              else if (letter == 'S')\
    \ (planet1.toUpperCase.indexOf(\"SATURN\") + 1, planet1)\n                   \
    \           else if (letter == 'U') (planet1.toUpperCase.indexOf(\"URANUS\") +\
    \ 1, planet1)\n                              else if (letter == 'N') (planet1.toUpperCase.indexOf(\"\
    NEPTUNE\") + 1, planet1)\n                              else (\n             \
    \                   0, planet1\n                              )\n            \
    \        if (i > 0) {\n                        (list + planet, planet)\n     \
    \               } else {\n                        (list, planet)\n           \
    \         }\n                )\n            ).flatten.toList ++\n            (\n\
    \                planet2.toUpperCase.takeWhile(_ != 'E').foldLeft(List())((list,\
    \ letter) =>\n                    val (i, planet) = if (letter == 'M') (planet2.toUpperCase.indexOf(\"\
    MERCURY\") + 1, planet2)\n                              else if (letter == 'V')\
    \ (planet2.toUpperCase.indexOf(\"VENUS\") + 1, planet2)\n                    \
    \          else if (letter == 'E') (planet2.toUpperCase.indexOf(\"EARTH\") + 1,\
    \ planet2)\n                              else if (letter == 'M') (planet2.toUpperCase.indexOf(\"\
    MARS\") + 1, planet2)\n                              else if (letter == 'J') (planet2.toUpperCase.indexOf(\"\
    JUPITER\") + 1, planet2)\n                              else if (letter == 'S')\
    \ (planet2.toUpperCase.indexOf(\"SATURN\") + 1, planet2)\n                   \
    \           else if (letter == 'U') (planet2.toUpperCase.indexOf(\"URANUS\") +\
    \ 1, planet2)\n", '        planet1 :: planet2 :: planet1.toLower :: planet2.toLower',
  "        var orbit : String = \"\"\n        var distance : Double = Double.MaxValue\n\
    \        var orbitList : List[String] = ListBuffer[String]()\n        val orbit1\
    \ = orbit(planet1)\n        val orbit2 = orbit(planet2)\n        val orbit1List\
    \ = orbitList(orbit1)\n        val orbit2List = orbitList(orbit2)\n        if\
    \ (planet1 == planet2) (orbit1List :+ orbit2List)\n        else if (orbit1List\
    \ == List()) {\n            (orbit2List :+ planet2)\n        } else if (orbit2List\
    \ == List()) {\n            (orbit1List :+ planet1)\n        } else {\n      \
    \      orbit1List.foreach((orbit1Planet) => {\n                orbit2List.foreach((orbit2Planet)\
    \ => {\n                    val orbitPlanet1 = orbit1Planet + orbit2Planet\n \
    \                   val distancePlanet1 = distance(planet1, orbitPlanet1)\n  \
    \                  val distancePlanet2 = distance(planet2, orbitPlanet1)\n   \
    \                 if (distancePlanet1 <= distancePlanet2) {\n                \
    \        distancePlanet1 <- distancePlanet2\n                        distancePlanet1\
    \ <- distancePlanet1\n                    }\n                    if (distancePlanet1\
    \ < distance) {\n                        distancePlanet1 <- distancePlanet1\n\
    \                        orbitPlanet1 <- orbitPlanet1\n                    }\n\
    \                    if (distancePlanet1 > distance) {\n                     \
    \   distancePlanet1 <- distancePlanet1\n                        orbitPlanet1 <-\
    \ orbitPlanet1\n                    }\n                    if (distancePlanet2\
    \ < distance) {\n                        distancePlanet2 <- distancePlanet2\n\
    \                        orbitPlanet2 <- orbitPlanet2\n                    }\n\
    \                    if (distancePlanet2 > distance) {\n                     \
    \   distancePlanet2 <- distancePlanet2\n                        orbitPlanet2 <-\
    \ orbitPlanet2\n                    }\n                    if (distancePlanet1\
    \ == distancePlanet2) {\n                        orbitList += (orbitPlanet1 :+\
    \ orbitPlanet2)\n                    }\n                    if (distancePlanet2\
    \ < distancePlanet1) {\n                        distancePlanet1 <- distancePlanet2\n\
    \                        orbitPlanet1 <- orbitPlanet1\n                    }\n\
    \                    if (distancePlanet1 < distancePlanet2) {\n              \
    \          distancePlanet2 <- distancePlanet1\n                        orbitPlanet2\
    \ <- orbitPlanet2\n                    }\n                    if (distancePlanet1\
    \ > distancePlanet2) {\n                        distancePlanet1 <- distancePlanet1\n\
    \                        orbitPlanet1 <- orbitPlanet1\n                    }\n\
    \                })\n            })\n        }\n        if (orbitList == List())\
    \ {\n            (List())\n        } else {\n            orbitList.sorted\n  \
    \      }", "        if(planet1.toUpperCase != planet2.toUpperCase)\n         \
    \   return (List())\n        else {\n            val m1 = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \            val m2 = List(Planets.Mercury,Planets.Venus,Planets.Earth,Planets.Mars,Planets.Jupiter,Planets.Saturn,Planets.Uranus,Planets.Neptune)\n\
    \            val i1 = m1.toSet.contains(planet1.toUpperCase)\n            val\
    \ i2 = m2.toSet.contains(planet2.toUpperCase)\n            if(!(planet1.toUpperCase.equals(planet2.toUpperCase)))\n\
    \                return (List())\n            else if((m1.toSet.contains(planet1.toUpperCase))\
    \ && (m2.toSet.contains(planet2.toUpperCase)))\n                return (m1.filter(x\
    \ => x.toString.contains(planet1.toUpperCase)).sorted((x1,x2) => java.lang.Math.abs(x1.getOrbit(planet1).getTime(x2)-planet2.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet2.toUpperCase)) && (m2.toSet.contains(planet1.toUpperCase)))\n\
    \                return (m2.filter(x => x.toString.contains(planet2.toUpperCase)).sorted((x1,x2)\
    \ => java.lang.Math.abs(x1.getOrbit(planet1).getTime(x2)-planet2.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet1.toUpperCase)) && (m2.toSet.contains(planet2.toUpperCase)))\n\
    \                return (m1.filter(x => x.toString.contains(planet1.toUpperCase)).sorted((x1,x2)\
    \ => java.lang.Math.abs(x1.getOrbit(planet2).getTime(x2)-planet1.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet2.toUpperCase)) && (m2.toSet.contains(planet1.toUpperCase)))\n\
    \                return (m2.filter(x => x.toString.contains(planet2.toUpperCase)).sorted((x1,x2)\
    \ => java.lang.Math.abs(x1.getOrbit(planet2).getTime(x2)-planet1.toString.toString.toDouble).get))\n\
    \            else if((m1.toSet.contains(planet1.toUpperCase)) && (m2.toSet.contains(planet2.toUpperCase",
  "        var planets = List(planet1, planet2)\n        var i = 0\n        while(planets.contains(planet2)\
    \ && (i < planets.length-1)) {\n            planets = planets.filter(!planets.contains(planet1))\n\
    \            i += 1\n        }\n        planets", "        val orbit1 = orbit(planet1)\n\
    \        val orbit2 = orbit(planet2)\n        val planet = if (orbit1.size < orbit2.size)\
    \ planet2 else planet1\n        val orbit = orbit1 ++ orbit2\n        val d =\
    \ distanceFromSun(planet)\n        val d = orbit.sortWith((a,b) => (a < b).abs,\
    \ (a,b) => (a > b).abs).takeWhile(_ < d)\n        d.toList", "        var list1\
    \ : List[String] = List(planet1, planet2)\n        var list2 : List[String] =\
    \ List(planet2)\n        var list3 : List[String] = List()\n        while(list1.head\
    \ != list2.head && list2.head != list3.head){\n            list1 :::: list3 ::\
    \ list2.reverse :::: list3\n            list1 :::: list2 :: list3\n          \
    \  list2 :::: list1 :: list3\n        }\n        \n        val map1 = Map (List\
    \ (planet1, planet2) -> (1,0))\n        val map2 = Map (List (planet2, planet1)\
    \ -> (0,1))\n        list3.filter( x => map1.containsKey(x) || map2.containsKey(x)).toList",
  "        var planet1Orbit : Option[Double] = None\n        var planet2Orbit : Option[Double]\
    \ = None\n        var orbitDistance : Double = 0.0\n        var orbits : List[String]\
    \ = Nil\n        for(p <- planet1, p <- planet2){\n            val orbit = calculateOrbit(planet1Orbit,\
    \ planet2Orbit)\n            orbitDistance += math.pow((orbit(2) - orbit(1)),\
    \ 2)\n            orbits = orbits.::(p) :: orbits\n            planet1Orbit =\
    \ orbit(1)\n            planet2Orbit = orbit(2)\n        }\n        if (planet1Orbit\
    \ == None || planet2Orbit == None)\n            Nil\n        else\n          \
    \  orbits.sortBy(orbitDistance)", "        val solar_system = SolarSystem.getInstance\n\
    \        val mercury = solar_system.getPlanetOrbit(planet1)\n        val venus\
    \ = solar_system.getPlanetOrbit(planet2)\n        val earth = solar_system.getPlanetOrbit(\"\
    Earth\")\n        val mars = solar_system.getPlanetOrbit(\"Mars\")\n        val\
    \ jupiter = solar_system.getPlanetOrbit(\"Jupiter\")\n        val saturn = solar_system.getPlanetOrbit(\"\
    Saturn\")\n        val uranus = solar_system.getPlanetOrbit(\"Uranus\")\n    \
    \    val neptune = solar_system.getPlanetOrbit(\"Neptune\")\n        var orbit_list\
    \ = [mercury, venus, earth, mars, jupiter, saturn, uranus, neptune]\n        orbit_list\
    \ = orbit_list.filter(_ != null).sortWith((e1, e2) => e1.distance < e2.distance).map(_.name)\n\
    \        orbit_list.filter(_ != planet1).filter(_ != planet2).filter(_ != planet1\
    \ + planet2)", "        val planets = List(\n            new Planet(\"Mercury\"\
    , new OrbitalPeriod(3, 245600)),\n            new Planet(\"Venus\", new OrbitalPeriod(4,\
    \ 1138000)),\n            new Planet(\"Earth\", new OrbitalPeriod(5, 968000)),\n\
    \            new Planet(\"Mars\", new OrbitalPeriod(6, 731000)),\n           \
    \ new Planet(\"Jupiter\", new OrbitalPeriod(7, 388000)),\n            new Planet(\"\
    Saturn\", new OrbitalPeriod(8, 242000)),\n            new Planet(\"Uranus\", new\
    \ OrbitalPeriod(9, 1285000)),\n            new Planet(\"Neptune\", new OrbitalPeriod(10,\
    \ 811000))\n        )\n        planets.filter{planet => planet1.equals(planet.orbitalPeriod.name)\
    \ && planet2.equals(planet.orbitalPeriod.name)}\n            .sortBy(planet =>\
    \ planet.orbitalPeriod.distance(planet.orbitalPeriod.name))", "        val planets1\
    \ = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        val planets2 = List(\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     if (planets1.indexOf(planet1) < 0 || planets1.indexOf(planet2) < 0) {\n\
    \            return List()\n        }\n        if (planets2.indexOf(planet2) <\
    \ 0 || planets2.indexOf(planet1) < 0) {\n            return List()\n        }\n\
    \        val sun = math.sqrt((1 - Math.pow(planet1.toDouble/planet2.toDouble,2)/Math.pow(planet2.toDouble/planet1.toDouble,2)))\n\
    \        planets2.map(planet2 => if (planet1.toDouble / planet2.toDouble < sun.toDouble)\
    \ planet2 else planet1).sortWith((x,y) => Math.abs(x-y) < sun).map((x => x)).sorted",
  "      val p1 = planet1\n      val p2 = planet2\n      val p1_orbits = planets(p1)\n\
    \      val p2_orbits = planets(p2)\n      val p1_orbits_long = orbits_long(p1_orbits)\n\
    \      val p2_orbits_long = orbits_long(p2_orbits)\n      val sun_coords = sun_coords()\n\
    \      val sun_coords_long = sun_coords_long()\n      val planets_within_range\
    \ = \n        p1_orbits_long.zip(p2_orbits_long) filter \n        { (p2_orbits_long,\
    \ p2_orbits_long) => \n          (distance(p2_orbits_long, sun_coords) <= distance(p1_orbits_long,\
    \ sun_coords))\n        } \n        sort { (p1, p2) => distance(p1, p2) }\n  \
    \    val planets_sorted = planets_within_range filter\n        { (planet1, planet2)\
    \ => \n          (planets(planet1) exists p1_orbits) || (planets(planet2) exists\
    \ p2_orbits)\n        }\n      planets_sorted.toList ", "        var orbits1 =\
    \ List(\"Mercury\", \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbits2\
    \ = List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\",\
    \ \"Neptune\")\n        var i = 0\n        for (i <- 0 to orbits2.size - 1 by\
    \ 2) {\n            if (orbits1(i) <= planet1 && planet1 <= orbits1(i + 1) &&\
    \ orbits1(i + 1) <= planet2)\n                orbits1 = orbits1.drop(i + 1)\n\
    \            else if (orbits1(i) > planet1 && planet1 <= orbits1(i + 1) && orbits1(i\
    \ + 1) <= planet2)\n                orbits1 = orbits1.drop(i)\n            else\
    \ if (orbits2(i) <= planet1 && planet1 <= orbits2(i + 1) && orbits2(i + 1) <=\
    \ planet2)\n                orbits2 = orbits2.drop(i + 1)\n            else if\
    \ (orbits2(i) > planet1 && planet1 <= orbits2(i + 1) && orbits2(i + 1) <= planet2)\n\
    \                orbits2 = orbits2.drop(i)\n        }\n        orbits1.sorted",
  "        val l1 = planet1.toUpperCase\n        val l2 = planet2.toUpperCase\n  \
    \      val planets = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        val orbits = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit1 = 0\n        var orbit2 = 0\n        var orbit3 = 0\n  \
    \      var orbit4 = 0\n        var orbit5 = 0\n        var orbit6 = 0\n      \
    \  var orbit7 = 0\n        var orbit8 = 0\n        var orbit1 = 0\n        var\
    \ orbit2 = 0\n        var orbit3 = 0\n        var orbit4 = 0\n        var orbit5\
    \ = 0\n        var orbit6 = 0\n        var orbit7 = 0\n        var orbit8 = 0\n\
    \        if (l1 == planet1) (planets.filter { x => x == l2 }, 0)\n        else\
    \ if (l2 == planet2) (planets.filter { x => x == l1 }, 0)\n        else {\n  \
    \          orbit1 = orbit(planet1)\n            orbit2 = orbit(planet2)\n    \
    \        orbit3 = orbit(planet1)\n            orbit4 = orbit(planet2)\n      \
    \      orbit5 = orbit(planet1)\n            orbit6 = orbit(planet2)\n        \
    \    orbit7 = orbit(planet1)\n            orbit8 = orbit(planet2)\n          \
    \  return (planets.filter { x => orbit(planet1) < orbit(planet2) }, 0)\n     \
    \   }", "        val m1 = orbit(planet1, planet2)\n        val m2 = orbit(planet2,\
    \ planet1)\n        val m3 = orbit(planet1, planet3)\n        val m4 = orbit(planet3,\
    \ planet1)\n        val m5 = orbit(planet1, planet5)\n        val m6 = orbit(planet5,\
    \ planet1)\n        val m7 = orbit(planet1, planet7)\n        val m8 = orbit(planet7,\
    \ planet1)\n        val orbits = List(m1, m2, m3, m4, m5, m6, m7, m8)\n      \
    \  orbits.sort((x: Double, y: Double) => math.abs(x - y))", "        var sun =\
    \ Planet(\"Sun\")\n        var planetList: List[Planet] = Nil\n        if (planet1\
    \ == sun) {\n            planetList = List(Planet(planet1))\n        } else if\
    \ (planet2 == sun) {\n            planetList = List(Planet(planet2))\n       \
    \ } else {\n            planetList = List(Planet(planet1), Planet(planet2))\n\
    \            val distance = sun\n            val distanceList: List[Planet] =\
    \ List(sun)\n            planetList.foreach(x => {\n                var d = distance\n\
    \                val distanceList: List[Planet] = List(d)\n                distanceList.foreach(y\
    \ => {\n                    if (Planet(x).isAdjacent(Planet(y))) {\n         \
    \               distance = d\n                    }\n                })\n    \
    \        })\n        }\n        planetList.sortBy(_.distanceTo(sun))", "     \
    \   val p1 = planet1.toLowerCase ; val p2 = planet2.toLowerCase\n        if(!(planet1.equals(\"\
    mercury\") || planet2.equals(\"venus\"))) return Nil\n        val x = Vector(0,0,0)\
    \ ; val y = Vector(0,0,0) ; val z = Vector(0,0,0) \n        val p3 = (planet1.equals(\"\
    mercury\") || planet2.equals(\"venus\")) ? \"mercury\" : \"venus\" \n        val\
    \ mercury  = Vector(3.241592653589793 , 0.69545221033424 , -3.141592653589793)\
    \ ; val venus   = Vector(6.283185307179586 , -1.511906410991249 , 3.141592653589793)\
    \ ; val earth   = Vector(0.7853981633974483 , 1.570796326794921 , -4.71238898038469)\
    \ ; val mars    = Vector(0.7853981633974483 , 0.5403023058681349 , 2.694915254237288)\
    \ ; val jupiter = Vector(0.7853981633974483 , -0.9644113294334183 , 3.141592653589793)\
    \ ; val saturn  = Vector(0.7853981633974483 , -1.598770757324219 , 2.78055059864084)\
    \ ; val uranus  = Vector(2.598076211353345 , -1.791927837593352 , -1.791927837593352)\n\
    \        val distMercury = {\n            val distMercury1 = distance(p1,mercury)\n\
    \            val distMercury2 = distance(p3,mercury)\n            if(distMercury1\
    \ < distMercury2) distMercury1\n            else if(distMercury1 > distMercury2)\
    \ distMercury2\n            else distMercury1 + distMercury2\n        }\n    \
    \    val distVenus = {\n            val distVenus1 = distance(p1,venus)\n    \
    \        val distVenus2 = distance(p3,venus)\n            if(distVenus1 < distVenus2)\
    \ distVenus1\n            else if(distVenus1 > distVenus2) distVenus2\n      \
    \      else distVenus1 + distVenus2\n        }\n        val distEarth = {\n  \
    \          val distEarth1 = distance(p1,earth)\n            val distEarth2 = distance(p",
  "        var orbit1 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit2 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit3 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit4 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit5 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit6 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        var orbit7 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit8 = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n\n        if (planet1 == planet2) {\n            return (List())\n        }\n\
    \        orbit1.foreach {\n            planet => if (planet.equalsIgnoreCase(planet1))\
    \ {\n                orbit2.foreach {\n                    planet => if (planet.equalsIgnoreCase(planet2))\
    \ {\n                        orbit3.foreach {\n                            planet\
    \ => if (planet.equalsIgnoreCase(planet1)) {\n                               \
    \ orbit4.foreach {\n                                    planet => if (planet.equalsIgnoreCase(planet2))\
    \ {\n                                        orbit5.foreach {\n              \
    \                              planet => if (planet.equalsIgnoreCase(planet1))\
    \ {\n                                                orbit6.foreach {\n      \
    \                                              planet => if (planet.equalsIgnoreCase(planet2))\
    \ {\n                                                        orbit7.foreach {\n\
    \                                                            planet => if (planet.equalsIgnoreCase(planet1))\
    \ {\n                                                                orbit8.foreach\
    \ {\n                                                                    planet\
    \ => if (planet.equalsIgnoreCase(planet2)) {\n                               \
    \                                         return(List(planet1, planet2))\n   \
    \                                                                 }\n        \
    \                                                        }\n                 \
    \                                           }\n                              \
    \                          }\n                                               \
    \     }\n                                                }\n                 \
    \                           }\n                                        }\n   \
    \                                 }\n                                }\n     \
    \                       }\n                        }\n                    }\n\
    \                }\n            }\n", "        var j : List[String] = List[String]()\n\
    \        var jd : Double = 0.0 // Distance between planet1 and planet2\n     \
    \   var d : Double = 0.0 // Distance between planet1 and sun\n        var s :\
    \ Double = 0.0 // Distance between sun and planet1\n        var sd : Double =\
    \ 0.0 // Distance between sun and planet2\n        var r : Double = 0.0 // Distance\
    \ between planet1 and planet2\n        var u : Double = 0.0 // Distance between\
    \ planet1 and sun\n        var v : Double = 0.0 // Distance between sun and planet1\n\
    \        var vd : Double = 0.0 // Distance between sun and planet2\n        var\
    \ c : Double = 0.0 // Time between planet1 and planet2\n        var c : Double\
    \ = 0.0 // Time between planet1 and sun\n        var c : Double = 0.0 // Time\
    \ between sun and planet1\n        var c : Double = 0.0 // Time between sun and\
    \ planet1\n        planet1.toUpperCase match {\n            case planet2 => return\
    \ List(planet2)\n            case planet => {\n                planet2.toUpperCase\
    \ match {\n                    case planet => {\n                        jd =\
    \ math.sqrt((j.toDouble - jd.toDouble)*(j.toDouble - jd.toDouble))\n         \
    \               d = math.sqrt((j.toDouble - d.toDouble)*(j.toDouble - d.toDouble))\n\
    \                        s = math.sqrt((s.toDouble - sd.toDouble)*(s.toDouble\
    \ - sd.toDouble))\n                        r = math.sqrt((r.toDouble - u.toDouble)*(j.toDouble\
    \ - r.toDouble))\n                        v = math.sqrt((v.toDouble - vd.toDouble)*(v.toDouble\
    \ - vd.toDouble))\n                        c = math.sqrt((c.toDouble - c.toDouble)*(c.toDouble\
    \ - c.toDouble))\n                        val temp = planet1.toUpperCase + \"\
    \ \" + planet2.toUpperCase\n                        for (a <- List(planet1, planet2))\
    \ {\n                            if (a.equals(planet)) {\n                   \
    \             j = List(planet)\n                            }\n              \
    \          }\n                        val planet = planet.toUpperCase + \" SUN\"\
    \n                        jd = math.sqrt((j.toDouble - jd.toDouble)*(j.toDouble\
    \ - jd.toDouble))\n                        d = math.sqrt((j.toDouble - d.toDouble)*(j.toDouble\
    \ - d.toDouble))\n                        s = math.sqrt((s.toDouble - sd.toDouble)",
  "        var orbit1 = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\")\n        var orbit2 = orbit1\n        val\
    \ planet1Orbit = orbit1.toSet.filter( x => x == planet1 )\n        val planet2Orbit\
    \ = orbit2.toSet.filter( x => x == planet2 )\n        if(!planet1Orbit.contains(planet2)\
    \ || !planet2Orbit.contains(planet1) )\n            return Nil\n        val result\
    \ = planet1Orbit.map(x => orbit2.find( y => Math.abs(x - y) < Math.sqrt(2) ) )\n\
    \        result.filter( x => x != None).sortWith( x => x._1.toDouble - x._2.toDouble\
    \ )", "        planet1.toList match {\n            case PlanetNames(Planet1(a))\
    \ => planet2.toList match {\n                case PlanetNames(Planet2(b)) => {\
    \ \n                    val r = scala.math.sqrt(math.pow(a, 2) + math.pow(b, 2))\n\
    \                    val r1 = math.pow(r, 1.0/3.0)\n                    math.round(math.sqrt(r1)*100)/100.0\n\
    \                }\n            }\n            case PlanetNames(Planet1(a, _,\
    \ _, _, _, _, _, _)) => planet2.toList match {\n                case PlanetNames(Planet2(b,\
    \ _, _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _)) =>\
    \ planet2.toList match {\n                case PlanetNames(Planet2(_, _, _, _,\
    \ _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _, _))\
    \ => planet2.toList match {\n                case PlanetNames(Planet2(_, _, _,\
    \ _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _, _,\
    \ _)) => planet2.toList match {\n                case PlanetNames(Planet2(_, _,\
    \ _, _, _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.0)\n  \
    \                  math.round(math.sqrt(r1)*100)/100.0\n                }\n  \
    \          }\n            case PlanetNames(Planet1(_, _, _, _, _, _, _, _, _,\
    \ _, _)) => planet2.toList match {\n                case PlanetNames(Planet2(_,\
    \ _, _, _, _, _, _, _, _, _, _)) => { \n                    val r = scala.math.sqrt(math.pow(a,\
    \ 2) + math.pow(b, 2))\n                    val r1 = math.pow(r, 1.0/3.", "  \
    \      var orbit1 = Planet(planet1).orbit\n        var orbit2 = Planet(planet2).orbit\n\
    \        var orb: List[String] = Nil\n\n        while(orbit1.size != 0 || orbit2.size\
    \ != 0) {\n            if(orbit1.contains(orbit2.head)) {\n                orb\
    \ = orbit1 ++ orbit2 ++ orb\n            }\n        }\n        \n        orb.sortWith((x:\
    \ String, y: String) => x.distance < y.distance)", '        val planet1Orbs =
    planet1.toLowerCase ++ "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase
    + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLowerCase + "orbit".toLower',
  "        if(planet1 == planet2) (List[String]())\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Venus\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Earth\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Mars\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Jupiter\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Saturn\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Uranus\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Mercury\"\
    ) && planet2.equals(\"Neptune\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Venus\")\
    \ && planet2.equals(\"Mercury\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Venus\")\
    \ && planet2.equals(\"Earth\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Venus\")\
    \ && planet2.equals(\"Mars\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Venus\")\
    \ && planet2.equals(\"Jupiter\")) (List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"))\n        if(planet1.equals(\"Ven", " \
    \       val a = getOrbits(planet1, planet2)\n        val b = getOrbits(planet2,\
    \ planet1)\n        val intersection = a.filter(b(_) > 0) \n\n        val distances\
    \ = intersection.map(x => \n            Math.abs(getDistance(planet1, planet2,\
    \ x) / 2.0)) \n        val tuple = intersection.sortedBy(distances.max)\n    \
    \    if (distances.size == 0) (List[String]())\n        else tuple", "       \
    \ val planets = List(planet1, planet2)\n        val d = Distances.sunSphereDistance(planets,\
    \ Planets.planets(0))\n        if (planets == Nil || d == 0.0) Nil\n        else\
    \ planets.sortBy(Planets.distanceFromSun).filter(p => d > Planets.sunSphereDistance(List(p),\
    \ Planets.planets(0)).abs)", "        val orbits = List(\n            List(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ),\n            List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"),\n            List(\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"),\n            List(\"Earth\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"),\n            List(\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"),\n            List(\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"),\n            List(\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        )\n        val p = orbits(planet1)\n        val q = orbits(planet2)\n\
    \        val a = (p diff q).toList\n        val b = (q diff p).toList\n      \
    \  (a.toList ++ b.toList).sortWith((a, b) => math.abs(a.toDouble - b.toDouble))",
  "        // Write your code here\n        val planets = new mutable.ListBuffer[String]()\n\
    \        val distances = mutable.ListBuffer[Double]()\n        for(planet <- List(planet1,\
    \ planet2)){\n            // Compute distance of planets\n            distances.clear()\n\
    \            for(i <- 0 until Planets[planet].length){\n                val distance\
    \ = Planets[planet](i).distanceTo(Planets(planet))\n                distances\
    \ += distance\n            }\n            // Add planets to list\n           \
    \ planets ++= Planets(planet).filterNot(distance => distances.contains(distance))\n\
    \        }\n        planets.toList.sortWith(_ < _).reverse", "        val planet1Orbit\
    \ = orbit(planet1)\n        val planet2Orbit = orbit(planet2)\n        if (planet1Orbit\
    \ == Nil || planet2Orbit == Nil) {\n            return Nil\n        }\n      \
    \  if (planet1Orbit.isEmpty || planet2Orbit.isEmpty) {\n            return Nil\n\
    \        }\n        if (planet1Orbit contains planet2Orbit) {\n            val\
    \ list = planet1Orbit ++ planet2Orbit\n            val sorted = list.sortWith(a\
    \ => distance(a, sun))\n            return sorted\n        }\n        else {\n\
    \            return Nil\n        }", "        val orbit1 = List(\n           \
    \     new Planet(\"Venus\", 6378.147, 0.0866),\n                new Planet(\"\
    Mercury\", 6378.1392, -0.0308),\n                new Planet(\"Earth\", 6378, (2\
    \ * math.pi/180)),\n                new Planet(\"Mars\", 6378.339, (2 * math.pi/180)),\n\
    \                new Planet(\"Jupiter\", 6378.346, (3 * math.pi/180)),\n     \
    \           new Planet(\"Saturn\", 6378.340, (4 * math.pi/180)),\n           \
    \     new Planet(\"Uranus\", 6378.341, (5 * math.pi/180)),\n                new\
    \ Planet(\"Neptune\", 6378.337, (6 * math.pi/180))\n                )\n\n    \
    \    val orbit2 = List(\n                new Planet(\"Saturn\", 6378.0, (4 * math.pi/180)),\n\
    \                new Planet(\"Uranus\", 6378.0, (5 * math.pi/180)),\n        \
    \        new Planet(\"Neptune\", 6378.0, (6 * math.pi/180)),\n               \
    \ new Planet(\"Mercury\", 6378.0, (2 * math.pi/180)),\n                new Planet(\"\
    Mars\", 6378.0, (2 * math.pi/180)),\n                new Planet(\"Jupiter\", 6378.0,\
    \ (3 * math.pi/180)),\n                new Planet(\"Earth\", 6378.0, (2 * math.pi/180)),\n\
    \                new Planet(\"Venus\", 6378.0, (0.0866 * math.pi/180))\n     \
    \           )\n\n        var output: List[String] = List()\n        var j = 0\n\
    \        var i = orbit1.size\n        while (i < orbit2.size) {\n            if\
    \ (orbit1(i).name == planet1 && orbit2(i).name == planet2) {\n               \
    \ output = output :+ orbit1(i).name\n                j = j + 1\n             \
    \   if (j == orbit1.size) {\n                    i = 0\n                    j\
    \ = 0\n                }\n            }\n            i = i + 1\n        }\n  \
    \      if (output.size == 0) {\n            output = List()\n        }\n     \
    \   output.sortBy(e => orbit1.find(e => e.name == e).distanceTo(orbit2.find(e\
    \ => e.name == e).distanceTo))\n        return output", "        def makePlanetName(planets:\
    \ Array[String], x: Int): String = \n            planets.reduceLeft((p1, p2) =>\
    \ p1 + \" \" + p2 + \" \") + (\"Planet \" + x)\n        def makeOrbitNames(planets:\
    \ Array[String]): Array[String] =\n            planets.map(p => makePlanetName(planets,\
    \ p.length))\n        def makeOrbit(planets: Array[String], x: Int): String =\n\
    \            planets.map(p => \"Orbit of \" + p).reduceLeft((p1, p2) => \"Orbit\
    \ of \" + p1 + \" and \" + p2).drop(2)\n        val planets = makeOrbitNames(Array(planet1,\
    \ planet2))\n        val orbit1 = makeOrbit(planets, 0)\n        val orbit2 =\
    \ makeOrbit(planets, 1)\n        val orbits = makeOrbitNames(Array(orbit1, orbit2))\n\
    \        val sunOrbit = orbits.filter(_.startsWith(\"Orbit of Sun\"))\n      \
    \  val sunOrbitIndex = orbits.indexOf(sunOrbit.last)\n        val sunOrbitList\
    \ = orbits(sunOrbitIndex)\n        val sunOrbitNames = makePlanetName(planets,\
    \ sunOrbitList.length)\n        val sunOrbitString = sunOrbitNames + \" and \"\
    \ + sunOrbitList\n        val sunOrbitToPlanets = sunOrbitList.map(planet => sunOrbitNames.drop(sunOrbitNames.indexOf(planet)).mkString(\"\
    \ \")).map(planets => planets + \" \" + planet)\n        val proximity = (sunOrbitList.size\
    \ / sunOrbitList.size.toDouble).toInt\n        val sunOrbits = proximity * sunOrbitList\n\
    \        val sunOrbitsIndex = sunOrbitNames.indexOf(sunOrbits)\n        val sunOrbitsList\
    \ = sunOrbitNames(sunOrbitsIndex) + \" and \" + sunOrbitList\n        val sunOrbitsName\
    \ = sunOrbitsList.mkString(\" \")\n        val planetsInOrbit = planets.filter(p1\
    \ => planet1.equals(p1))\n        val planetsNotInOrbit = planets.filter(p1 =>\
    \ !planet1.equals(p1))\n        val planetsInOrbitIndex = planets.indexOf(planetsInOrbit)\n\
    \        val planetsInOrbitList = planetsInOrbit(planetsInOrbitIndex)\n      \
    \  val planetsInOrbitNames = planetsInOr", "        val earth = scala.collection.mutable.ListBuffer()\n\
    \        val mercury = scala.collection.mutable.ListBuffer()\n        val venus\
    \ = scala.collection.mutable.ListBuffer()\n        val mars = scala.collection.mutable.ListBuffer()\n\
    \        val jupiter = scala.collection.mutable.ListBuffer()\n        val saturn\
    \ = scala.collection.mutable.ListBuffer()\n        val uranus = scala.collection.mutable.ListBuffer()\n\
    \        val neptune = scala.collection.mutable.ListBuffer()\n        val earthOrbit\
    \ = scala.collection.mutable.ListBuffer()\n        val mercuryOrbit = scala.collection.mutable.ListBuffer()\n\
    \        val venusOrbit = scala.collection.mutable.ListBuffer()\n        val marsOrbit\
    \ = scala.collection.mutable.ListBuffer()\n        val jupiterOrbit = scala.collection.mutable.ListBuffer()\n\
    \        val saturnOrbit = scala.collection.mutable.ListBuffer()\n        val\
    \ uranusOrbit = scala.collection.mutable.ListBuffer()\n        val neptuneOrbit\
    \ = scala.collection.mutable.ListBuffer()\n        scala.collection.mutable.ListBuffer(\"\
    Venus\", \"Mercury\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     scala.collection.mutable.ListBuffer(\"Earth\", \"Mercury\", \"Venus\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"\
    Mars\", \"Mercury\", \"Earth\", \"Venus\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Saturn\"\
    , \"Uranus\", \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Uranus\"\
    , \"Neptune\")\n        scala.collection.mutable.ListBuffer(\"Neptune\")\n   \
    \     if(planet1.equals(planet2) || planet1.equals(\"Earth\")){\n            planet1\
    \ +: planet2\n        }\n        else if(planet2.equals(planet1) || planet", " \
    \       val sun = Planet(\"sun\")\n        val earth = Planet(\"Earth\")\n   \
    \     val mercury = Planet(\"Mercury\")\n        val venus = Planet(\"Venus\"\
    )\n        val mars = Planet(\"Mars\")\n        val jupiter = Planet(\"Jupiter\"\
    )\n        val saturn = Planet(\"Saturn\")\n        val uranus = Planet(\"Uranus\"\
    )\n        val neptune = Planet(\"Neptune\")\n\n        val sunOrbit = sun.orbit(planet2)\n\
    \        val earthOrbit = earth.orbit(planet1)\n        val mercuryOrbit = mercury.orbit(planet1)\n\
    \        val venusOrbit = venus.orbit(planet1)\n        val marsOrbit = mars.orbit(planet1)\n\
    \        val jupiterOrbit = jupiter.orbit(planet1)\n        val saturnOrbit =\
    \ saturn.orbit(planet1)\n        val uranusOrbit = uranus.orbit(planet1)\n   \
    \     val neptuneOrbit = neptune.orbit(planet1)\n\n        def proximity(planetOrbit\
    \ : String, sunOrbit : String) : Int = {\n            if (planetOrbit == sunOrbit)\
    \ 0 else 1\n        }\n\n        val planet1 = List(mercury, venus, mars, jupiter,\
    \ saturn, uranus, neptune).sortBy(proximity)\n        val planet2 = List(sun,\
    \ earth, mercury, venus, mars, jupiter, saturn, uranus, neptune).sortBy(proximity)\n\
    \n        val orbits = planet1 ++ planet2\n        val planetOrbits = orbits.filter(_.orbit(planet1)\
    \ == _.orbit(planet2)).sortBy(proximity)\n\n        val result = planetOrbits.map(p\
    \ => (p.name, p.orbit(planet2)))\n        return result.sortBy(_._1).map(_._2).toList",
  '        // Write your logic here', "        val planet1_orbit =  getOrbital(planet1)\n\
    \        val planet2_orbit =  getOrbital(planet2)\n        if (planet1_orbit ==\
    \ 0 || planet2_orbit == 0) \n            return Nil\n        var planet1 : List[String]\
    \ = Nil\n        var planet2 : List[String] = Nil\n        var orbit1 : List[String]\
    \ = Nil\n        var orbit2 : List[String] = Nil\n        var orbit_distance :\
    \ Double = 0.0 \n        var orbits_distance : List[Double] = List(0)\n      \
    \  var distance_difference : Double = 0\n        var planet1_orbits : List[String]\
    \ = List(0)\n        var planet2_orbits : List[String] = List(0)\n        for\
    \ ((orbit1, orbit_distance) in planet1_orbits) {\n            if (orbit_distance\
    \ < orbit_distance) {\n                planet1 += orbit1\n                orbits_distance\
    \ += orbit_distance\n            }\n        }\n        for ((orbit2, orbit_distance)\
    \ in planet2_orbits) {\n            if (orbit_distance < orbit_distance) {\n \
    \               planet2 += orbit2\n                orbits_distance += orbit_distance\n\
    \            }\n        }\n        planet1 = planet1.sortWith((x,y) => x.compareTo(y))\n\
    \        planet2 = planet2.sortWith((x,y) => x.compareTo(y))\n        planet1\
    \ = planet1.sortWith((x,y) => x.compareTo(\"Sun\"))\n        planet2 = planet2.sortWith((x,y)\
    \ => x.compareTo(\"Sun\"))\n        planet1 = planet1.filter((x,i) => i < planet1.length)\n\
    \        planet2 = planet2.filter((x,i) => i < planet2.length)\n        planet1\
    \ = planet1.map((x,i) => Planet(x, orbits_distance(i)))\n        planet2 = planet2.map((x,i)\
    \ => Planet(x, orbits_distance(i)))\n        planet1.toList.zip(planet2.toList).foreach\
    \ { case (planet1, planet2) =>\n            planet1.getOrbit_distance(planet2)\n\
    \            if (planet1 <- planet1 && planet2 <- planet2) {\n               \
    \ distance_difference = planet1.getOrbit_distance(planet2) \n                planet1.getOrbits(planet2)\n\
    \                planet2.getOrbits(planet1)\n                distance_difference\n\
    \            }\n        }", "        val planetsBetweenSun = \n            (for\
    \ { \n                a <- Planets(planet1) \n                b <- Planets(planet2)\
    \ \n                if (a.orbit(b) < 0) \n                } yield (a, b)).sortBy(-_._2)\n\
    \        val sun = Planets(\"Sun\")\n        val planetsBetweenPlanets = planetsBetweenSun.filter(_._1\
    \ ne sun).flatMap(p => Planets(p._1))\n        val result: List[String] = planetsBetweenPlanets.filter(p2\
    \ => p2.orbit(sun) < 0).sortBy(-_.orbit(sun))\n        if (result.isEmpty) result\
    \ else result.reverse", "        val orbits = List(\n            List(\n     \
    \           List(\"Venus\", \"Earth\"),\n                List(\"Jupiter\", \"\
    Mars\"),\n                List(\"Saturn\", \"Uranus\"),\n                List(\"\
    Uranus\", \"Neptune\")\n                ),\n            List(\n              \
    \  List(\"Mercury\", \"Earth\"),\n                List(\"Venus\", \"Mars\"),\n\
    \                List(\"Saturn\", \"Jupiter\"),\n                List(\"Jupiter\"\
    , \"Saturn\")\n                )\n            )\n        for (planetsOrbit <-\
    \ orbits) {\n            val planet1 = planetsOrbit(0)\n            val planet2\
    \ = planetsOrbit(1)\n            val planet1Orbit = planet1.toList.flatMap(planet\
    \ => planet.toList)\n            val planet2Orbit = planet2.toList.flatMap(planet\
    \ => planet.toList)\n            val sunOrbit = PlanetOrbit(planet1, planet2).orbit\n\
    \            val result = planet1Orbit.filter(orbit => orbit.distance(sunOrbit)\
    \ >= planet1Orbit.distance + planet2Orbit.distance - sunOrbit.distance)\n    \
    \        result\n        }", "        var temp : List[String] = Nil\n        //\
    \ TODO\n        if (planet1 == \"Mercury\" && planet2 == \"Neptune\")\n      \
    \      temp = \"Saturn\"\n        else if (planet1 == \"Venus\" && planet2 ==\
    \ \"Earth\")\n            temp = \"Earth\"\n        else if (planet1 == \"Venus\"\
    \ && planet2 == \"Neptune\")\n            temp = \"Uranus\"\n        else if (planet1\
    \ == \"Earth\" && planet2 == \"Mercury\")\n            temp = \"Mercury\"\n  \
    \      else if (planet1 == \"Earth\" && planet2 == \"Neptune\")\n            temp\
    \ = \"Mars\"\n        else if (planet1 == \"Mars\" && planet2 == \"Mercury\")\n\
    \            temp = \"Mercury\"\n        else if (planet1 == \"Mars\" && planet2\
    \ == \"Neptune\")\n            temp = \"Jupiter\"\n        else if (planet1 ==\
    \ \"Jupiter\" && planet2 == \"Mercury\")\n            temp = \"Mercury\"\n   \
    \     else if (planet1 == \"Jupiter\" && planet2 == \"Neptune\")\n           \
    \ temp = \"Saturn\"\n        else if (planet1 == \"Saturn\" && planet2 == \"Mercury\"\
    )\n            temp = \"Mercury\"\n        else if (planet1 == \"Saturn\" && planet2\
    \ == \"Neptune\")\n            temp = \"Uranus\"\n        else if (planet1 ==\
    \ \"Uranus\" && planet2 == \"Mercury\")\n            temp = \"Mercury\"\n    \
    \    else if (planet1 == \"Uranus\" && planet2 == \"Neptune\")\n            temp\
    \ = \"Venus\"\n        else if (planet1 == \"Neptune\" && planet2 == \"Mercury\"\
    )\n            temp = \"Mercury\"\n        else if (planet1 == \"Neptune\" &&\
    \ planet2 == \"Earth\")\n            temp = \"Earth\"\n        else if (planet1\
    \ == \"Neptune\" && planet2 == \"Venus\")\n            temp = \"Venus\"\n    \
    \    else if (planet1 == \"Neptune\" && planet2 == \"Mars\")\n            temp\
    \ = \"Mars\"\n        else if (planet1 == \"Neptune\" && planet2 == \"Jupiter\"\
    )\n            temp = \"Jupiter\"\n        else if (planet1 == \"Neptune\" &&\
    \ planet2 == \"Saturn\")\n            temp = \"Saturn\"\n        else if (planet1\
    \ == \"Neptune\" && planet2 == \"Uranus\")\n            temp = \"Uranus\"\n  \
    \      else if (planet1 == \"Neptune\" && planet2 == \"Neptune\")\n          \
    \  temp = \"Mercury\"\n        \n        return ", "        if(planet1 == planet2)\
    \ List();\n        if(planet1 == \"\" || planet2 == \"\") List(\"\");\n      \
    \  val planets1 : List[String] = List(planet1, planet2, planet1 + \"_Mercury\"\
    , planet1 + \"_Jupiter\", planet1 + \"_Saturn\", planet1 + \"_Uranus\", planet1\
    \ + \"_Neptune\", planet1 + \"_Mars\")\n        val planets2 : List[String] =\
    \ List(planet2 + \"_Mercury\", planet2 + \"_Jupiter\", planet2 + \"_Saturn\",\
    \ planet2 + \"_Uranus\", planet2 + \"_Neptune\", planet2 + \"_Mars\")\n      \
    \  val planets3 : List[String] = planets2 ++ planets1\n        val planets4 :\
    \ List[String] = planets3 filter { planet1 + \"_Mercury\" =:= planet2 + \"_Mercury\"\
    \ } \n        val planets5 : List[String] = planets4 filter { planet1 + \"_Jupiter\"\
    \ =:= planet2 + \"_Jupiter\" } \n        val planets6 : List[String] = planets5\
    \ filter { planet1 + \"_Saturn\" =:= planet2 + \"_Saturn\" } \n        val planets7\
    \ : List[String] = planets6 filter { planet1 + \"_Uranus\" =:= planet2 + \"_Uranus\"\
    \ } \n        val planets8 : List[String] = planets7 filter { planet1 + \"_Neptune\"\
    \ =:= planet2 + \"_Neptune\" } \n        val planets9 : List[String] = planets8\
    \ filter { planet1 + \"_Mars\" =:= planet2 + \"_Mars\" } \n        planets9.sorted",
  '        //TODO: write your solution here', "        // Your code goes here\n  \
    \      val planet1Orbits = List(planet1 + \"Orbit\", planet1 + \"Orbits\")\n \
    \       val planet2Orbits = List(planet2 + \"Orbit\", planet2 + \"Orbits\")\n\
    \        val sunOrbits = List(\"Sun\", \"Suns\")\n        val planet1Orbit = planet1Orbits.filter(_\
    \ contains planet1)\n        val planet2Orbit = planet2Orbits.filter(_ contains\
    \ planet2)\n        val sunOrbit = sunOrbits.filter(_ contains planet1)\n    \
    \    val orbs = planet1Orbit ++ planet2Orbit ++ sunOrbit\n        val suns = sunOrbit.map(_\
    \ + \" Orbit\")\n        val orbOrb = orbs.map(_ + \" Orbits\")\n        val planets\
    \ = orbOrb ++ suns\n        val sunOrbits = suns.map(_ + \" Orbit\")\n       \
    \ val sunOrbits1 = suns.map(_ + \" Orbits\")\n        val orbOrb1 = orbOrb.map(_\
    \ + \" Orbits\")\n        val orbOrb2 = orbOrb.map(_ + \" Orbit\")\n        val\
    \ orbOrb3 = orbOrb.map(_ + \" Orbits\")\n        val sunOrbits2 = suns.map(_ +\
    \ \" Orbits\")\n        val orbOrb4 = orbOrb1.map(_ + \" Orbit\")\n        val\
    \ orbOrb5 = orbOrb2.map(_ + \" Orbit\")\n        val orbOrb6 = orbOrb3.map(_ +\
    \ \" Orbits\")\n        val orbOrb7 = sunOrbits.map(_ + \" Orbits\")\n       \
    \ val orbOrb8 = orbOrb4.map(_ + \" Orbits\")\n        val orbOrb9 = orbOrb5.map(_\
    \ + \" Orbit\")\n        val orbOrb10 = orbOrb6.map(_ + \" Orbit\")\n        val\
    \ orbOrb11 = orbOrb7.map(_ + \" Orbit\")\n        val orbOrb12 = orbOrb8.map(_\
    \ + \" Orbits\")\n        val orbOrb13 = orbOrb9.map(_ + \" Orbit\")\n       \
    \ val orbOrb14 = orbOrb10.map(_ + \" Orbit\")\n        val orbOrb15 = orb", " \
    \       var firstOrbit : Double = 0.0, secondOrbit : Double = 0.0\n        var\
    \ firstPlanet : List[String] = Nil\n        var secondPlanet : List[String] =\
    \ Nil\n        // If the planet names are correct, the following code will work\n\
    \        if (planet1 != \"Mercury\" && planet1 != \"Venus\" && planet1 != \"Earth\"\
    \ && planet1 != \"Mars\" && planet1 != \"Jupiter\" && planet1 != \"Saturn\" &&\
    \ planet1 != \"Uranus\" && planet1 != \"Neptune\") return Nil\n        if (planet2\
    \ != \"Mercury\" && planet2 != \"Venus\" && planet2 != \"Earth\" && planet2 !=\
    \ \"Mars\" && planet2 != \"Jupiter\" && planet2 != \"Saturn\" && planet2 != \"\
    Uranus\" && planet2 != \"Neptune\") return Nil\n        if (planet1 == planet2)\
    \ return (List(planet1))\n        if (planet1 -> planet2 == (\"Mercury\" -> \"\
    Earth\")) return (List(\"Earth\" -> \"Mars\"))\n        if (planet1 -> planet2\
    \ == (\"Mercury\" -> \"Earth\" -> \"Mars\")) return (List(\"Earth\" -> \"Mars\"\
    \ -> \"Jupiter\"))\n        if (planet1 -> planet2 == (\"Mercury\" -> \"Earth\"\
    \ -> \"Mars\" -> \"Jupiter\")) return (List(\"Earth\" -> \"Mars\" -> \"Jupiter\"\
    \ -> \"Saturn\"))\n        if (planet1 -> planet2 == (\"Mercury\" -> \"Earth\"\
    \ -> \"Mars\" -> \"Jupiter\" -> \"Saturn\")) return (List(\"Earth\" -> \"Mars\"\
    \ -> \"Jupiter\" -> \"Saturn\" -> \"Uranus\"))\n        if (planet1 -> planet2\
    \ == (\"Mercury\" -> \"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" -> \"\
    Uranus\")) return (List(\"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" ->\
    \ \"Uranus\" -> \"Neptune\"))\n        if (planet1 -> planet2 == (\"Mercury\"\
    \ -> \"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" -> \"Uranus\" -> \"Neptune\"\
    )) return (List(\"Earth\" -> \"Mars\" -> \"Jupiter\" -> \"Saturn\" -> \"Uranus",
  "      val orbit1 = orbit(planet1)\n      val orbit2 = orbit(planet2)\n      val\
    \ orbit1Sun = orbit(planet1.substring(0, planet1.length-1))\n      val orbit2Sun\
    \ = orbit(planet2.substring(0, planet2.length-1))\n      if (planet1.equals(planet2))\
    \ {\n        return List()\n      } else if (orbit1Sun == null || orbit1Sun.size\
    \ < 1) {\n        return List()\n      } else if (orbit2Sun == null || orbit2Sun.size\
    \ < 1) {\n        return List()\n      }\n      val orbit1SunPlus1 = orbit1Sun.map(x\
    \ => x + 1.toDouble)\n      val orbit2SunPlus1 = orbit2Sun.map(x => x + 1.toDouble)\n\
    \      val orbit1SunMinus1 = orbit1Sun.map(x => x - 1.toDouble)\n      val orbit2SunMinus1\
    \ = orbit2Sun.map(x => x - 1.toDouble)\n      var temp1 : List[Double] = List()\n\
    \      var temp2 : List[Double] = List()\n      val result: mutable.Set[String]\
    \ = new mutable.HashSet[String]()\n      for (i <- 0 until orbit1SunPlus1.size)\
    \ {\n        temp1 = orbit1SunPlus1.map( x => x - i ).toList\n        for (j <-\
    \ 0 until orbit2SunPlus1.size) {\n          temp2 = orbit2SunPlus1.map( x => x\
    \ - j ).toList\n          if (temp1.forall(f => temp2.exists( g=> f < g)) && temp2.forall(f\
    \ => temp1.exists( g=> f < g))) {\n            result.add(planet1 + \"-\" + planet2)\n\
    \          } else {\n          }\n        }\n      }\n      result.map(x => println(x)).sorted",
  "        val sun = Planet(Planet.Sun.name, Planet.Sun.mass, Planet.Sun.distance,\
    \ Planet.Sun.mass)\n        val mercury = Planet(Planet.Mercury.name, Planet.Mercury.mass,\
    \ Planet.Mercury.distance, Planet.Mercury.mass)\n        val venus = Planet(Planet.Venus.name,\
    \ Planet.Venus.mass, Planet.Venus.distance, Planet.Venus.mass)\n        val earth\
    \ = Planet(Planet.Earth.name, Planet.Earth.mass, Planet.Earth.distance, Planet.Earth.mass)\n\
    \        val mars = Planet(Planet.Mars.name, Planet.Mars.mass, Planet.Mars.distance,\
    \ Planet.Mars.mass)\n        val jupiter = Planet(Planet.jupiter.name, Planet.jupiter.mass,\
    \ Planet.jupiter.distance, Planet.jupiter.mass)\n        val saturn = Planet(Planet.saturn.name,\
    \ Planet.saturn.mass, Planet.saturn.distance, Planet.saturn.mass)\n        val\
    \ uranus = Planet(Planet.uranus.name, Planet.uranus.mass, Planet.uranus.distance,\
    \ Planet.uranus.mass)\n        val neptune = Planet(Planet.neptune.name, Planet.neptune.mass,\
    \ Planet.neptune.distance, Planet.neptune.mass)\n        val planets = (List(\
    \ earth, mars, jupiter, saturn, uranus, neptune ))\n\n        val distance = planets.map\
    \ { p =>\n            p.orbit(planet1, planet2).distance\n        }.sortBy(distance).reverse\n\
    \        distance.head :: distance", "        var orbit1 = orbitOf(planet1)\n\
    \        var orbit2 = orbitOf(planet2)\n        var orbitsBetween = orbit2.toSet\
    \ - orbit1.toSet\n        val result = orbitsBetween.sorted\n        result match\
    \ {\n            case Nil => List()\n            case _ => result\n        }",
  "        val planet1 = Planet(planet1)\n        val planet2 = Planet(planet2)\n\
    \        val sun = Planet(\"Sun\")\n        // The orbits of planet1 & planet2\
    \ are given as a pair \n        val orbits1 = planet1.orbits(planet2)\n      \
    \  val orbits2 = planet2.orbits(planet1)\n        // The planets are located between\
    \ their orbits and the sun\n        val planetsBetweenOrbits = orbits1 ++ orbits2\
    \ ++ List(sun)\n        // The orbits between the planets are sorted by their\
    \ distance to the sun\n        val proximityToSun = planetsBetweenOrbits.sorted\n\
    \        // The planets that are between their orbits and the sun are in the list\n\
    \        val planetsWithinOrbits = proximityToSun.filter(_.inOrbits(planet1))\n\
    \        val planetsWithoutOrbits = proximityToSun.filter(_.inOrbits(planet2))\n\
    \        // The planets that aren't within their orbits are in the list\n    \
    \    val planetsWithoutOrbitsBoth = proximityToSun.filter(!_.inOrbits(planet1))\n\
    \        val planetsWithoutOrbitsOnly = proximityToSun.filter(!_.inOrbits(planet2))\n\
    \n        if (planetsWithoutOrbitsBoth.isEmpty)\n            (planetsWithoutOrbitsOnly.toList)\n\
    \        else\n            (planetsWithoutOrbitsBoth.toList ++ planetsWithoutOrbitsOnly.toList)",
  "        val planets = List(planet1, planet2)\n        val sun = Planet(\"Sun\"\
    )\n        val mercury = Planet(\"Mercury\")\n        val venus = Planet(\"Venus\"\
    )\n        val earth = Planet(\"Earth\")\n        val mars = Planet(\"Mars\")\n\
    \        val jupiter = Planet(\"Jupiter\")\n        val saturn = Planet(\"Saturn\"\
    )\n        val uranus = Planet(\"Uranus\")\n        val neptune = Planet(\"Neptune\"\
    )\n        val list = mutable.ListBuffer[Planet]()\n        var list2 = mutable.ListBuffer[Planet]()\n\
    \        var list3 = mutable.ListBuffer[Planet]()\n        for (p <- planets)\
    \ {\n            list += p\n            if (sun == p) {\n                continue\n\
    \            } else {\n                list2 = list ++ List(p, sun)\n        \
    \    }\n            if (mercury == p) {\n                continue\n          \
    \  } else {\n                list2 = list2 ++ List(p, mercury)\n            }\n\
    \            if (venus == p) {\n                continue\n            } else {\n\
    \                list2 = list2 ++ List(p, venus)\n            }\n            if\
    \ (earth == p) {\n                continue\n            } else {\n           \
    \     list2 = list2 ++ List(p, earth)\n            }\n            if (mars ==\
    \ p) {\n                continue\n            } else {\n                list2\
    \ = list2 ++ List(p, mars)\n            }\n            if (jupiter == p) {\n \
    \               continue\n            } else {\n                list2 = list2\
    \ ++ List(p, jupiter)\n            }\n            if (saturn == p) {\n       \
    \         continue\n            } else {\n                list2 = list2 ++ List(p,\
    \ saturn)\n            }\n            if (uranus == p) {\n                continue\n\
    \            } else {\n                list2 = list2 ++ List(p, uranus)\n    \
    \        }\n            if (neptune == p) {\n                continue\n      \
    \      } else {\n                list2 = list2 ++ List(p, neptune)\n         \
    \   }\n        }\n        list2.filter(n => list.indexOf(n) < list.indexOf(sun)).filter(n\
    \ => list.indexOf(n) < list.indexOf(mercury))\n        .filter(n => list.indexOf(n)\
    \ < list.indexOf(venus))\n        .filter(n => list.indexOf(n) < list.indexOf(earth))\n\
    \        .filter(n => list.indexOf(n) < list.indexOf(mars))\n        .filter(n\
    \ => list.indexOf(n) < list.indexOf(jupiter))\n        .filter(n => list.indexOf(n)\
    \ < list.indexOf(saturn))\n        .filter(n => list.indexOf(n) < list.indexOf(uranus))\n\
    \        .filter(n => list.indexOf(n) < list.indexOf(neptun", "        if (planet1\
    \ == planet2) List()\n        else {\n            val a = List(planet1, planet2)\n\
    \            val b = a.zipWithIndex.filter(x => x._1.equals(x._2))\n         \
    \   b.sortBy(x => x._1.distance(x._2))\n        }", "        if (planet1 == \"\
    \" || planet2 == \"\") return Nil\n        val l1 = planet1.toList.sorted\n  \
    \      val l2 = planet2.toList.sorted\n        val l3 = l1.zipWithIndex.flatMap(x\
    \ => {\n            val p = x._1\n            val ix = x._2\n            l2.zipWithIndex.flatMap(x\
    \ => {\n                val q = x._1\n                val iy = x._2\n        \
    \        l3.zipWithIndex.flatMap(x => {\n                    val r = x._1\n  \
    \                  val iz = x._2\n                    val v1 = l2.indexWhere(p\
    \ < x._1)\n                    val v2 = l2.indexWhere(p > x._1)\n            \
    \        val v3 = l2.indexWhere(q < x._1)\n                    val v4 = l2.indexWhere(q\
    \ > x._1)\n                    val v5 = l2.indexWhere(r < x._1)\n            \
    \        val v6 = l2.indexWhere(r > x._1)\n                    val v7 = l2.indexWhere(iy\
    \ < x._1)\n                    val v8 = l2.indexWhere(iy > x._1)\n           \
    \         val v9 = l2.indexWhere(iz < x._1)\n                    val v10 = l2.indexWhere(iz\
    \ > x._1)\n                    if (v1 == -1) Nil\n                    else if\
    \ (v1 == 0 && v2 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 &&\
    \ v3 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == 0 &&\
    \ v4 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == 0 &&\
    \ v4 == 0 && v5 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 &&\
    \ v3 == 0 && v4 == 0 && v5 == 0 && v6 == -1) Nil\n                    else if\
    \ (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 && v5 == 0 && v6 == 0 && v7 == -1)\
    \ Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 &&\
    \ v5 == 0 && v6 == 0 && v7 == 0 && v8 == -1) Nil\n                    else if\
    \ (v1 == 0 && v2 == 0 && v3 == 0 && v4 == 0 && v5 == 0 && v6 == 0 && v7 == 0 &&\
    \ v8 == 0 && v9 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 &&\
    \ v3 == 0 && v4 == 0 && v5 == 0 && v6 == 0 && v7 == 0 && v8 == 0 && v9 == 0 &&\
    \ v10 == -1) Nil\n                    else if (v1 == 0 && v2 == 0 && v3 == 0 &&\
    \ v4 == 0 && v5 == 0 && v6 == 0 && v7 == 0 && v8 == 0 && ", "        val p1 =\
    \ Planet(planet1)\n        val p2 = Planet(planet2)\n        val sun = Planet(\"\
    Sun\")\n        val ps = List(sun, p1, p2)\n        val orbits = Orbits(ps).all\n\
    \        if (orbits.isEmpty) return Nil\n        val p1 = orbits(0)\n        val\
    \ p2 = orbits(1)\n        val a = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val b = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ c = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val d = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val e = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val f = orbits.map{case Orbit(Sun, p, p, p) =>\
    \ p.orbit}\n        val g = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val h = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ i = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val j = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val k = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val l = orbits.map{case Orbit(Sun, p, p, p) =>\
    \ p.orbit}\n        val m = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val n = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ o = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val p = orbits.map{case\
    \ Orbit(Sun, p, p, p) => p.orbit}\n        val q = orbits.map{case Orbit(Sun,\
    \ p, p, p) => p.orbit}\n        val r = orbits.map{case Orbit(Sun, p, p, p) =>\
    \ p.orbit}\n        val s = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n\
    \        val t = orbits.map{case Orbit(Sun, p, p, p) => p.orbit}\n        val\
    \ u = orbits.map{case Orbit(Sun, p, p, ", "        val orbits = List(\n      \
    \      Planet(planet1, Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"\
    Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Neptune\", Planet(\"\
    Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\"\
    , Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\",\
    \ Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"\
    Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\"\
    , Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\"\
    , Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"\
    Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\"\
    , Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"\
    Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\"\
    , Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\",\
    \ Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"\
    Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\"\
    , Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"Mercury\"\
    , Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"\
    Saturn\", Planet(\"Uranus\", Planet(\"Mercury\", Planet(\"Venus\", Planet(\"Earth\"\
    , Planet(\"Mars\", Planet(\"Jupiter\", Planet(\"Saturn\", Planet(\"Uranus\", Planet(\"\
    Mercury\", Planet(\"Venus\", Planet(\"Earth\", Planet(\"Mars\", Planet(\"Jupiter\"\
    , Planet(\"Saturn\", ", "      val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n      val orbits\
    \ = planets.map(x => (x, x))\n        .reduce((x: (List[String], List[String]),\
    \ y: (List[String], List[String])) => {\n            val x1: List[String] = x._1;\n\
    \            val x2: List[String] = x._2;\n            val y1: List[String] =\
    \ y._1;\n            val y2: List[String] = y._2;\n            val orb1 = orbits(x1);\n\
    \            val orb2 = orbits(x2);\n            val dist1 = orb1.map(x1 => orb2.map(y2\
    \ => (x1, y2)).minBy(_._2).map(_._2).map(_._1).map(x => Math.pow(x - y, 2)).sum)\n\
    \            val dist2 = orb2.map(x2 => orb1.map(y1 => (x2, y1)).minBy(_._2).map(_._2).map(_._1).map(x\
    \ => Math.pow(x - y, 2)).sum)\n            (dist1, dist2)\n        }) match {\n\
    \        case (Some(a), Some(b)) => (a :: b)\n        case _ => List()", "   \
    \     val planetList : List[String] = Nil\n        val orbits = List(\n      \
    \      new Orbit(planet1, 0, 0),\n            new Orbit(planet1, 1, 0),\n    \
    \        new Orbit(planet1, 2, 0),\n            new Orbit(planet1, 3, 0),\n  \
    \          new Orbit(planet1, 4, 0),\n            new Orbit(planet1, 5, 0),\n\
    \            new Orbit(planet1, 6, 0),\n            new Orbit(planet1, 7, 0),\n\
    \            new Orbit(planet1, 8, 0)\n            )\n        for (orbit <- orbits)\
    \ {\n            if (planetList.contains(orbit.planet)) {\n            }\n   \
    \         else {\n                val distance = (planetList.indexOf(orbit.planet)\
    \ * 1000 + orbit.orbit)\n                planetList += orbit.planet\n        \
    \    }\n        }\n        return planetList.sortWith((s1, s2) => {\n        \
    \    val d1 =  (planetList.indexOf(s1) * 1000 + orbitList.indexOf(s1))\n     \
    \       val d2 =  (planetList.indexOf(s2) * 1000 + orbitList.indexOf(s2))\n  \
    \          (d1 - d2) / (d1 + d2)\n        })", "        def isCorrectPlanet(planetName\
    \ : String) : Boolean = {\n            planetName match {\n                case\
    \ \"Mercury\" => \"Mercury\" != \"Earth\" && \"Mercury\" != \"Mars\"\n       \
    \         case \"Venus\" => \"Venus\" != \"Earth\" && \"Venus\" != \"Mars\"\n\
    \                case \"Earth\" => \"Earth\" != \"Mercury\" && \"Earth\" != \"\
    Venus\" && \n                    \"Earth\" != \"Mars\"\n                case \"\
    Mars\" => \"Mars\" != \"Earth\" && \"Mars\" != \"Venus\" && \n               \
    \     \"Mars\" != \"Jupiter\"\n                case \"Jupiter\" => \"Jupiter\"\
    \ != \"Earth\" && \"Jupiter\" != \"Mars\" && \n                    \"Jupiter\"\
    \ != \"Saturn\"\n                case \"Saturn\" => \"Saturn\" != \"Earth\" &&\
    \ \"Saturn\" != \"Mars\" && \n                    \"Saturn\" != \"Uranus\"\n \
    \               case \"Uranus\" => \"Uranus\" != \"Earth\" && \"Uranus\" != \"\
    Mars\" && \n                    \"Uranus\" != \"Neptune\"\n                case\
    \ \"Neptune\" => \"Neptune\" != \"Earth\" && \"Neptune\" != \"Mars\" && \n   \
    \                 \"Neptune\" != \"Uranus\"\n                case _ => false\n\
    \            }\n        }\n\n        def orbitalPlanets(planetName : String) :\
    \ List[String] = {\n            planetName match {\n                case \"Mercury\"\
    \ => List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n                case \"Venus\" => List(\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n                case \"Earth\"\
    \ => List(\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n      \
    \          case \"Mars\" => List(\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n                case \"Jupiter\" => List(\"Saturn\", \"Uranus\", \"Neptune\"\
    )\n                case \"Saturn\" => List(\"Uranus\", \"Neptune\")\n        \
    \        case \"Uranus\" => List(\"Neptune\")\n                case \"Neptune\"\
    \ => List()\n                case _ => List()\n            }\n        }\n\n  \
    \      def orbitalPlanetsOfPlanet(planetName : String) : List[String] = {\n  \
    \          planetName match {\n                case \"Mercury\" => List(\"Venus",
  "       val orbits1 = mutable.ListBuffer[String]()\n       val orbits2 = mutable.ListBuffer[String]()\n\
    \       for (e <- 1 to Planets) {\n           val planet = Planets(e)\n      \
    \     if (planet.name == \"Mercury\" && planet1.name == \"Earth\") orbits1 +=\
    \ planet.name \n           if (planet.name == \"Venus\" && planet2.name == \"\
    Earth\") orbits2 += planet.name\n       }\n       orbits1.toList.sortWith(_ <\
    \ _) ::: orbits2.toList.sortWith(_ < _)", '        // your code here']
stop_tokens:
- "\n    }\n"
