language: scala
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numCarrots = number.toInt\n\
    \        val needCarrots = need.toInt\n        val remainCarrots = remaining.toInt\n\
    \        var list: List[Long] = Nil\n        if (numCarrots >= needCarrots){\n\
    \            var c = 0\n            var n = 0\n            var r = numCarrots\
    \ - needCarrots \n            while (r > 0){\n                c += 1\n       \
    \         n += r\n                r %= numCarrots\n            }\n           \
    \ list += List(numCarrots - c, numCarrots - n)\n        }\n        else{\n   \
    \         list += List(numCarrots - needCarrots, numCarrots - remainCarrots)\n\
    \        }\n        list.sortBy(x => x.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnxdj1nhg.scala:44:17 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            list += List(numCarrots - c, numCarrots -\
    \ n)\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ += is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnxdj1nhg.scala:47:17 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            list += List(numCarrots - needCarrots, numCarrots\
    \ - remainCarrots)\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var meals : List[Long] =\
    \ List(number.toLong);\n        var carrots : List[Long] = List(remaining.toLong);\n\
    \        var total : List[Long] = List(number.toLong);\n        var remaining\
    \ : List[Long] = List(remaining.toLong);\n        while(carrots.nonEmpty) {\n\
    \            total += carrots\n            if(total.length + carrots.length +\
    \ carrots.nonEmpty < 10000) {\n                meals += carrots\n            \
    \    carrots = List(need - carrots.head)\n            } else {\n             \
    \   meals += carrots\n                carrots = List(need)\n                total\
    \ += carrots\n            }\n        }\n        if(total.length + carrots.length\
    \ + carrots.nonEmpty > 10000) {\n            meals += carrots\n            carrots\
    \ = List(need - carrots.head)\n        }\n        total += carrots\n        if(total.length\
    \ < 10000) {\n            meals += carrots\n        }\n        meals\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmxlpqj4p.scala:32:50 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mcarrots\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List(remaining.toLong);\n\e[31m\e[31m   |\e[0m        \
    \                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpmxlpqj4p.scala:34:52 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List(remaining.toLong);\n\e[31m\e[31m   |\e[0m        \
    \                                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmxlpqj4p.scala:36:18\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            total += carrots\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpmxlpqj4p.scala:37:45 -----------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            \e[33mif\e[0m(total.length + carrots.length +\
    \ carrots.nonEmpty < \e[31m10000\e[0m) {\n\e[31m\e[31m   |\e[0m              \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod"
  stdout: ''
  timestamp: 1660010670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining <= 0) {\n\
    \            List(number.toLong)\n        }\n        else {\n            val carrots\
    \ = number\n            val meals = need\n            val newCarrots = remaining\
    \ - carrots\n            val newMeals = meals - carrots\n            if (newCarrots\
    \ > 0) {\n                eat(number - newCarrots, newMeals, remaining)\n    \
    \        }\n            else {\n                List(number.toLong)\n        \
    \    }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2pysh__.scala:48)\n\tat Problem.main(tmpl2pysh__.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining == 0) {\n\
    \            List(number.toLong)\n        } else {\n            val newNeed  =\
    \ if (number < need) need.toLong else number.toLong\n            val newRemaining\
    \ = if (number > remaining) number.toLong else remaining.toLong\n            val\
    \ remainder  = newRemaining - newNeed\n            val newNumber  = number + need\n\
    \            val totalCarrots = newNumber.toLong\n            val carrotLeft \
    \ = newNumber - totalCarrots\n            List(carrotLeft.toLong, totalCarrots)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpavnx3vn7.scala:44)\n\tat Problem.main(tmpavnx3vn7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots : List[Long]\
    \ = List()\n        var counter : Long = number\n        var counter2 : Long =\
    \ 0\n        while (counter > 0) {\n            if (counter2 > remaining) {\n\
    \                carrots = carrots :+ counter2\n                counter = 0\n\
    \            } else {\n                carrots = carrots :+ (counter2 - counter)\n\
    \                counter = counter - counter2\n                counter2 = 0\n\
    \            }\n        }\n        carrots = carrots :+ counter2\n        carrots\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var numRemaining = remaining;\n\
    \        var eaten = number;\n\n        while (numberRemaining > 0) {\n      \
    \      if (numberRemaining < need) {\n                eaten += numberRemaining;\n\
    \                numberRemaining -= need;\n            } else {\n            \
    \    numberRemaining -= eaten;\n                eaten = 0;\n            }\n  \
    \      }\n\n        eatenList.head :: eatenList.tail\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjs166g3l.scala:34:15 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mwhile\e[0m (numberRemaining > \e[31m0\e\
    [0m) {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               Not found: numberRemaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjs166g3l.scala:35:16 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (numberRemaining < need) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \             Not found: numberRemaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpjs166g3l.scala:36:22 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                eaten += numberRemaining;\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpjs166g3l.scala:36:25 ------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                eaten += numberRemaining;\n\e[31m\e[31m   |\e[0m     \
    \                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \      Not found: numberRemaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpjs166g3l.scala:37:16 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                numberRemaining -= need;\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: numberRemaining\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjs166g3l.scala:39:16\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                numberRemaining\
    \ -= eaten;\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Not found: numberRemaining\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation avai"
  stdout: ''
  timestamp: 1660010666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots : List[Long]\
    \ = number :: Nil\n        var carrots_left : Long = remaining\n\n        while(true)\
    \ {\n            carrots_left = carrots.dropRight(1)\n            if(need <= carrots_left)\
    \ {\n                carrots = carrots :+ carrots_left\n                break\n\
    \            }\n            carrots = carrots :+ carrots_left\n        }\n   \
    \     carrots.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjpw5au30.scala:35:44\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            carrots_left = carrots.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                        \
    \   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjpw5au30.scala:38:16\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010666
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code here\n    \
    \    var carrots = number\n        \n        while(carrots > 0) {\n          \
    \  carrots -= 1\n            \n            if (carrots > need) {\n           \
    \     carrots += remaining\n            } else {\n                carrots = 0\n\
    \            }\n        }\n        \n        // Your code here\n        \n   \
    \     List(carrots, carrots - need)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyzmvdi4q.scala:49)\n\tat Problem.main(tmpyzmvdi4q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code here!\n   \
    \     val meals : List[Long] = List(number.toLong)\n        val remainingCarrots\
    \ : List[Long] = List(remaining.toLong)\n\n        meals match {\n           \
    \ case Nil => remainingCarrots.reverse\n            case h :: tail if h > remaining\
    \ => {\n                val numberOfCarrots : Long = tail.head\n             \
    \   val hungryRabbits : List[Long] = tail.tail\n                hungryRabbits.reverse\n\
    \                remainingCarrots match {\n                    case Nil => List(numberOfCarrots.toLong)\n\
    \                    case h :: tail if h > numberOfCarrots => {\n            \
    \            val restCarrots : List[Long] = tail.tail\n                      \
    \  remainingCarrots match {\n                            case Nil => List(numberOfCarrots.toLong\
    \ :: restCarrots)\n                            case h :: tail if h < numberOfCarrots\
    \ => List(numberOfCarrots.toLong :: restCarrots)\n                           \
    \ case h :: tail if h == numberOfCarrots => List(numberOfCarrots.toLong :: restCarrots)\n\
    \                        }\n                    }\n                    case h\
    \ :: tail if h < numberOfCarrots => List(numberOfCarrots.toLong :: tail)\n   \
    \             }\n            }\n            case h :: tail if h > remaining =>\
    \ List(need.toLong :: tail)\n            case h :: tail if h < need => List(need.toLong\
    \ :: tail)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3pv8ny8e.scala:46:45\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m                            \e\
    [33mcase\e[0m Nil => List(numberOfCarrots.toLong :: restCarrots)\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    \e\
    [1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m    \
    \                                         Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3pv8ny8e.scala:47:74 --------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                            \e[33mcase\e[0m h :: tail\
    \ \e[33mif\e[0m h < numberOfCarrots => List(numberOfCarrots.toLong :: restCarrots)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                    Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \                                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3pv8ny8e.scala:48:75 --------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                            \e[33mcase\e[0m h :: tail\
    \ \e[33mif\e[0m h == numberOfCarrots => List(numberOfCarrots.toLong :: restCarrots)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                    Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \                                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3pv8ny8e.scala:51:66 --------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m     "
  stdout: ''
  timestamp: 1660010669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val ans = ListBuffer[Long]()\n\
    \        val carrots = ListBuffer[Long]()\n\n        if (number > 1000)\n    \
    \        throw new Exception(\"Bad input! You have already eaten too many carrots.\\\
    n\")\n\n        if (need > 1000)\n            throw new Exception(\"Bad input!\
    \ You need too many carrots.\\n\")\n\n        if (remaining > 1000)\n        \
    \    throw new Exception(\"Bad input! You are out of carrots left.\\n\")\n\n \
    \       while (remaining > 0) {\n            if (remaining >= need) {\n      \
    \          ans += remaining.toLong\n                remaining -= need\n      \
    \      }\n            else {\n                ans += need.toLong\n           \
    \     remaining -= need\n            }\n        }\n        ans :: carrots\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdv1fpu4l.scala:46:26 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                remaining -= need\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not\
    \ a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpdv1fpu4l.scala:50:26 ------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m                remaining -= need\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not a member of Long\
    \ - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdv1fpu4l.scala:53:12\
    \ ------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        ans :: carrots\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :: is not\
    \ a member of scala.collection.mutable.ListBuffer[Long] - did you mean carrots.+:?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var remaining = remaining\n\
    \        var left = 0\n        var meals = ListBuffer[Long]()\n        while (left\
    \ < remaining) {\n            meals += number\n            left += number\n  \
    \          number -= 1\n            if (number < 0) {\n                number\
    \ += remaining\n                remaining -= number\n            }\n        }\n\
    \        meals.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph_9rub1r.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_9rub1r.scala:36:17\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            left += number\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmph_9rub1r.scala:37:19 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of\
    \ Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_9rub1r.scala:39:23\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                number +=\
    \ remaining\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m              value += is not a member of Long - did you mean number.!=?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_9rub1r.scala:43:14 --------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        meals.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number > 1000 || need\
    \ > 1000 || remaining > 1000) throw new Exception(\"All arguments must be positive\
    \ and less than 1000\")\n        val eaten = number\n        val leftToEat = need\n\
    \        val needToEat = leftToEat - eaten\n        val stock = remaining\n  \
    \      val remainingToEat = (needToEat * stock).toLong\n        val remainingLeft\
    \ = (remaining * stock).toLong\n        val remainder = remainingToEat - remainingLeft\n\
    \        if (remainder.toLong >= stock) remainder else stock\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl5wfs6pq.scala:39:39\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mif\e[0m (remainder.toLong\
    \ >= stock) remainder \e[33melse\e[0m stock\n\e[31m\e[31m   |\e[0m           \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                      Found:    (remainder : Long)\n\e[31m   |\e[0m         \
    \                              Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpl5wfs6pq.scala:39:54 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mif\e[0m (remainder.toLong >= stock) remainder\
    \ \e[33melse\e[0m stock\n\e[31m\e[31m   |\e[0m                               \
    \                       ^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                      Found:    (stock : Long)\n\e[31m   |\e[0m             \
    \                                   Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if( number > 0 && number\
    \ <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000){\n\
    \            var eaten = 0\n            var needLeft = need\n            var totalEaten\
    \ = 0\n            var totalLeft = 0\n            var temp = 0\n            while(\
    \ totalLeft < remaining and needLeft > 0){\n                temp = number - need\n\
    \                if( temp == 0){\n                    eaten = need\n         \
    \           totalLeft += eaten\n                    totalEaten += eaten\n    \
    \                needLeft -= eaten\n                }else{\n                 \
    \   eaten = temp\n                    totalLeft += eaten\n                   \
    \ totalEaten += eaten\n                    needLeft -= eaten\n               \
    \ }\n            }\n            if( totalLeft < remaining){\n                while(needLeft\
    \ > 0){\n                    eaten = number - need\n                    totalLeft\
    \ += eaten\n                    totalEaten += eaten\n                    needLeft\
    \ -= eaten\n                }\n            }\n            if( totalEaten < totalLeft){\n\
    \                while(needLeft > 0){\n                    eaten = number - need\n\
    \                    totalLeft += eaten\n                    totalEaten += eaten\n\
    \                    needLeft -= eaten\n                }\n            }\n   \
    \         if( totalEaten == totalLeft){\n                var result: List[Long]\
    \ = List()\n                result = (totalLeft :: totalEaten :: result)\n   \
    \             return result\n            }\n        }else{\n            error(\"\
    Please input correct information.\")\n        }\n        return List()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp407gn2vb.scala:37:41 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mwhile\e[0m( totalLeft < remaining and\
    \ needLeft > \e[31m0\e[0m){\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value and is not a member of Boolean\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp407gn2vb.scala:38:23 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                temp = number - need\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \            Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp407gn2vb.scala:40:28\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    eaten = need\n\
    \e[31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0m  \
    \                          Found:    (need : Long)\n\e[31m   |\e[0m          \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp407gn2vb.scala:53:28 --------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m                    eaten = number - need\n\e[31m\e[31m   |\e[0m     \
    \                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \          Found:    Long\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp407gn2vb.scala:61:28\
    \ --------------------\e[0m\e[0m\n\e[31m61 |\e[0m                    eaten = number\
    \ - need\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Found:    Long\n\e[31m   |\e[0m   \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp407gn2vb.scala:69:26 -------------"
  stdout: ''
  timestamp: 1660010669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0 && number\
    \ <= 1000, \"carrot number must be between 0 and 1000\")\n        require(need\
    \ > 0 && need <= 1000, \"carrot need must be between 0 and 1000\")\n        require(remaining\
    \ > 0 && remaining <= 1000, \"carrot remaining must be between 0 and 1000\")\n\
    \        if (remaining == 0) {\n            List(number.toLong)\n        }\n \
    \       else {\n            var sum = 0\n            var next = number - need\n\
    \            while (next > 0) {\n                sum += next\n               \
    \ next -= remaining\n            }\n            List(number.toLong, sum)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1ueb7urq.scala:41:20 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                sum += next\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining <= 0) List(1L)\
    \ else {\n            val temp = remaining % number\n            val remainders\
    \ = remaining - temp\n            val remainders1 = remainders.toLong\n      \
    \      val result = number + temp\n            val result1 = result.toLong\n \
    \           val result2 = result1.toLong\n            val remainders2 = remainders1.toLong\n\
    \            List(result2, remainders2)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxd9z1xuk.scala:43)\n\tat Problem.main(tmpxd9z1xuk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number > 1000 || number\
    \ < 0 || need > 1000 || need < 0 || remaining > 1000 || remaining < 0)\n     \
    \       return (List[Long](0l.toLong, 0l.toLong))\n        var carrots = number\n\
    \        var carrots_left_after_meals = remaining\n        var needEaten = 0L\n\
    \        var eaten = 0L\n        var left = 0L\n        var needToEat = 0L\n \
    \       while (carrots > 0L && carrots_left_after_meals > 0L && needEaten < need)\
    \ {\n            needToEat = carrots - carrots_left_after_meals\n            if\
    \ (needToEat > 0L) {\n                carrots_left_after_meals -= needToEat\n\
    \                eaten += needToEat\n                left += needToEat\n     \
    \       }\n            carrots = left\n        }\n        List(eaten.toLong, left.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_kbmf42.scala:51)\n\tat Problem.main(tmpl_kbmf42.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val meals = number - need\n\
    \        val leftover = remaining - meals\n        if(leftover == 0) {\n     \
    \       List(number - need)\n        } else {\n            List(number - need,\
    \ leftover)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1hrui99.scala:40)\n\tat Problem.main(tmpj1hrui99.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - need\n\
    \        val left  = remaining - eaten\n        if (left == 0) {\n           \
    \ List(eaten.toLong)\n        } else if (left > 0) {\n            List(eaten.toLong,\
    \ left.toLong)\n        } else {\n            List()\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl1ahdat2.scala:42)\n\tat Problem.main(tmpl1ahdat2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      val num = number.toInt\n \
    \     val needn = need.toInt\n      val remaining = remaining.toInt\n      if\
    \ (num <= 0 && needn <= 0 && remaining <= 0) {\n        List(0l.toLong, 0l.toLong)\n\
    \      } else if (num < needn && needn <= remaining) {\n        List(num.toLong,\
    \ needn - num.toLong)\n      } else if (num < needn) {\n        List(num.toLong,\
    \ remaining - needn.toLong)\n      } else if (num > remaining) {\n        List(num.toLong,\
    \ needn - num.toLong)\n      } else {\n        List(0l.toLong, 0l.toLong)\n  \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfjubek9e.scala:33:22 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m      \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(remaining < 0)\n    \
    \        error(\"Need more carrots!\")\n        if(number > need)\n          \
    \  error(\"More carrots than needed!\")\n\n        val mealsRemaining  = remaining\
    \ - number\n        val eatenCarrots = number.toLong\n\n        val carrots =\
    \ mutable.ListBuffer[Long]()\n        while(mealsRemaining > 0) {\n          \
    \  carrots += mealsRemaining\n            mealsRemaining -= need\n        }\n\
    \        carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpot32tnbv.scala:32:12 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            error(\e[31m\"Need more carrots!\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m            Not found:\
    \ error\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpot32tnbv.scala:34:12\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            error(\e[31m\"\
    More carrots than needed!\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\
    \e[31m   |\e[0m            Not found: error\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpot32tnbv.scala:39:22 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpot32tnbv.scala:42:27 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            mealsRemaining -= need\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value -= is not a\
    \ member of Long - did you mean mealsRemaining.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots = number - need\n\
    \        val remainder = math.max(1000 - need, 0L)\n        val totalToEat = math.min(remainder,\
    \ remaining) + carrots\n        if(totalToEat == 0) {\n            return List(0l).asInstanceOf[List[Long]]\n\
    \        }\n        val eaten = List(carrots).asInstanceOf[List[Long]]\n     \
    \   carrots = number - totalToEat + need\n        val leftovers = math.max(1000\
    \ - carrots, 0L)\n        val remainingToEat = math.min(leftovers, remaining)\
    \ + carrots\n        val leftovers1 = math.max(1000 - remainingToEat, 0l)\n  \
    \      val remainingToEat1 = math.min(leftovers1, remaining) + carrots\n     \
    \   eaten :+ remainingToEat\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5a933319.scala:46)\n\tat Problem.main(tmp5a933319.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val newNumber = number -\
    \ need\n        val newNeed = needed + need\n        val newRemaining = remaining\
    \ - need\n        val answer = (List(newNumber, newRemaining))\n        return\
    \ answer\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzk9w7rj8.scala:32:22 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mnewNeed\e[0m = needed +\
    \ need\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: needed\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0)\n  \
    \      require(need > 0)\n        require(remaining > 0)\n        var totalEaten\
    \ = 0\n        var needLeft = need\n        var result: List[Long] = Nil\n   \
    \     while(remaining > 0){\n            require(needLeft > 0)\n            require(totalEaten\
    \ <= need)\n            totalEaten += 1\n            needLeft -= 1\n        }\n\
    \        result = (0 until totalEaten).map(_ => remaining)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpae0is60q.scala:43:41\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m        result = (\e[31m0\e[0m\
    \ until totalEaten).map(_ => remaining)\n\e[31m\e[31m   |\e[0m               \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \     Found:    IndexedSeq[Long]\n\e[31m   |\e[0m                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number <= 1000,\
    \ \"The number of carrots that you have eaten is invalid.\")\n        require(need\
    \ <= 1000, \"The need is the number of carrots that you need to eat is invalid.\"\
    )\n        require(remaining <= 1000, \"The remaining number of carrots is invalid.\"\
    )\n        if (number < need) {\n            return List(number + need)\n    \
    \    }\n        if (number < remaining) {\n            List(number - need, remaining\
    \ - number).sortBy(_ + _)\n        }\n        List(need, need).sortBy(_ + _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpc14u4zzh.scala:38:59 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            List(number - need, remaining - number).sortBy(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \           ^^^^^\e[0m\n\e[31m   |\e[0m                                 Wrong\
    \ number of parameters, expected: 1\n\e[31m\e[31m-- Error: /tmp/tmpc14u4zzh.scala:38:65\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m       \
    \     List(number - need, remaining - number).sortBy(_ + _)\n\e[31m\e[31m   |\e\
    [0m                                                                 ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpc14u4zzh.scala:40:32 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        List(need, need).sortBy(_ + _)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                        Wrong number of parameters, expected: 1\n\e[31m\e[31m--\
    \ Error: /tmp/tmpc14u4zzh.scala:40:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        List(need, need).sortBy(_ + _)\n\e[31m\e[31m\
    \   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000 && need >= 0 && need <= 1000 && remaining >= 0 && remaining <= 1000)\n\
    \        var list = []\n        if (remaining >= need) {\n            for (i <-\
    \ 1 to number by -1) {\n                list += i\n            }\n        }\n\
    \        else {\n            for (i <- 1 to need by -1) {\n                list\
    \ += i\n            }\n            list += remaining\n        }\n        list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpboyibmud.scala:32:20 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mlist\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    an\
    \ identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpboyibmud.scala:33:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m\
    \ (remaining >= need) {\n\e[31m\e[31m   |\e[0m^^\e[0m\n\e[31m   |\e[0m'=>' expected,\
    \ but 'end of statement' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpboyibmud.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mfor\e[0m (i\
    \ <- \e[31m1\e[0m to number by -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m       \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (number : Long)\n\e[31m   |\e[0m                           Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpboyibmud.scala:35:21\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                list += i\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is\
    \ not a member of Null, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitCo"
  stdout: ''
  timestamp: 1660010686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def eat(carrot : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n            val meal = remaining.toDouble\
    \ / need.toDouble\n            if (remaining <= 0L)\n                List(0l.toLong)\n\
    \            else {\n                val result = remaining - carrot\n       \
    \         val newRemaining = result * need\n                val newRemaining1\
    \ = newRemaining + carrot\n                val newRemaining2 = newRemaining1 *\
    \ meal\n                List(newRemaining2.toLong, newRemaining1.toLong)\n   \
    \         }\n        }\n        if (number > 0L && need > 0L && remaining > 0L)\n\
    \            List(eat(number, need, remaining))\n        else\n            List(0l.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuzv1g4vr.scala:44:20\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m            List(eat(number,\
    \ need, remaining))\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e\
    [0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                 Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val newList = mutable.ListBuffer.empty[Long]\n\
    \        val carrots = number - need\n        var remain = remaining - need\n\
    \        while(remain > 0) {\n            newList += carrots\n            remain\
    \ -= 1\n        }\n        newList += 0\n        newList.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmiop7swy.scala:31:22 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // complete the implementation\
    \ here\n        val list = mutable.ListBuffer(number - need)\n        while(list.size\
    \ < remaining && number > 0){\n            number -= 1\n            list += number\n\
    \        }\n        number - need.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4efju1wv.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer(number\
    \ - need)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4efju1wv.scala:34:19 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4efju1wv.scala:37:8 ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \        number - need.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def helper(total : Long,\
    \ left : Long, carrots : Long) : List[Long] = {\n            if (carrots == 0)\
    \ {\n                if (total > remaining) {\n                    total - left\n\
    \                } else if (left > 0) {\n                    List(total + left.toLong)\n\
    \                } else {\n                    List(total)\n                }\n\
    \            } else {\n                val res = helper(total, left + need, carrots\
    \ - need)\n                res.head :: res.tail\n            }\n        }\n  \
    \      helper(0, number, remaining).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vaupg_i.scala:34:20\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                    total - left\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  Found:    Long\n\e[31m   |\e[0m                    Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number > 1000 || need\
    \ > 1000 || remaining > 1000) return(List[Long](0l.toLong, 0l.toLong))\n     \
    \   var carrots : Long = number\n        var eaten : Long = 0\n        while (number\
    \ > 0 && need > 0) {\n            if (carrots <= remaining) {\n              \
    \  eaten += 1\n                number -= 1\n            } else {\n           \
    \     carrots = remaining\n                remaining -= carrots\n            }\n\
    \        }\n        var list : List[Long] = List()\n        list += List(eaten)\n\
    \        list += List(carrots - eaten)\n        list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0jv6rkhx.scala:37:23 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                number -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -=\
    \ is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp0jv6rkhx.scala:40:26 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                remaining -= carrots\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not a member\
    \ of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0jv6rkhx.scala:44:13 ------------------------\e[0m\e[0m\n\e[31m44 |\e\
    [0m        list += List(eaten)\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0jv6rkhx.scala:45:13 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        list += List(carrots - eaten)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean List[Long].!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def getRemain(number : Long,\
    \ need : Long, remaining : Long) : List[Long] = {\n            var newRemaining\
    \ = remaining\n            var list = List[Long]()\n            while (newRemaining\
    \ > 0) {\n                list :+= newRemaining\n                newRemaining\
    \ -= need\n            }\n            list\n        }\n        if (number <= 0\
    \ || need <= 0 || remaining <= 0) {\n            List[Long]()\n        } else\
    \ {\n            getRemain(number, need, remaining) match {\n                case\
    \ Nil => List[Long]()\n                case list => list\n            }\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcghc1f4q.scala:50)\n\tat Problem.main(tmpcghc1f4q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining <= 0) {\n\
    \            List(number);\n        } else if (number <= remaining) {\n      \
    \      number :: eat(number, need - number, remaining - number);\n        } else\
    \ {\n            number :: eat(number, need, remaining - number);\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2nonym_f.scala:40)\n\tat Problem.main(tmp2nonym_f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0 && number\
    \ <= 1000, \"invalid number \" + number)\n        require(need > 0 && need <=\
    \ 1000, \"invalid need \" + need)\n        require(remaining > 0 && remaining\
    \ <= 1000, \"invalid remaining \" + remaining)\n\n        var hungry = false\n\
    \        var eaten = number\n        val list = mutable.ArrayBuffer(new mutable.ListBuffer[Long])\n\
    \        while (eaten > 0 && need) {\n            if (hungry) {\n            \
    \    if (remaining <= eaten) {\n                    hungry = false\n         \
    \           list.clear()\n                    list.add(eaten)\n              \
    \      list.add(0l)\n                } else {\n                    list.add(eaten)\n\
    \                    list.add(remaining) // number of remaining carrots for next\
    \ time\n                    eaten = eaten - remaining\n                }\n   \
    \         } else {\n                if (eaten > need) {\n                    hungry\
    \ = true\n                    eaten = eaten - need\n                } else {\n\
    \                    list.add(eaten)\n                    list.add(need) // number\
    \ of remaining carrots for next time\n                    eaten = 0l\n       \
    \         }\n            }\n        }\n        list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr9gkug62.scala:37:19 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ArrayBuffer(\e\
    [33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m])\n\e[31m\e[31m   |\e[0m     \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr9gkug62.scala:38:28\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mwhile\e[0m (eaten\
    \ > \e[31m0\e[0m && need) {\n\e[31m\e[31m   |\e[0m                           \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                            Found:    (need : Long)\n\
    \e[31m   |\e[0m                            Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var number : Long = 0\n\
    \        var need: Long = 0\n        var remaining: Long = 0\n        var i =\
    \ 0\n        while (i <= 1000) {\n            if (number >= need) {\n        \
    \        number = 0\n                need = 0\n                remaining = remaining\
    \ - 1\n            }\n            else {\n                number = number + 1\n\
    \                need = need + 1\n            }\n            i = i + 1\n     \
    \   }\n        var result: List[Long] = List(0l)\n        var j = 0\n        while\
    \ (j <= 1000) {\n            if (remaining == 0) {\n                result = result\
    \ :+ number\n                j = 0\n            }\n            else {\n      \
    \          result = result :+ number\n                j = j + 1\n            }\n\
    \            i = i + 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwo5kbdng.scala:63)\n\tat Problem.main(tmpwo5kbdng.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n\
    \            throw new Exception(\"Invalid inputs\")\n        }\n\n        val\
    \ carrotEaten = number - need\n        val carrotLeft = needed - remaining\n \
    \       if (carrotLeft <= 0l) List(1l to 0l) else List(1l to carrotLeft) match\
    \ {\n            case head :: tail =>\n                val carrotEatenLeft = head\
    \ - carrotEaten\n                val carrotLeftLeft = tail.sum - 1\n         \
    \       if(carrotLeftLeft <= 0l) {\n                    List(1l to carrotEaten)\
    \ match {\n                        case head :: tail =>\n                    \
    \        List(1l to carrotLeft) match {\n                                case\
    \ head :: tail =>\n                                    List(1l to carrotEaten)\
    \ match {\n                                        case head :: tail =>\n    \
    \                                        List(1l to carrotLeft) match {\n    \
    \                                            case head :: tail =>\n          \
    \                                          List(1l to carrotEaten) match {\n \
    \                                                       case head :: tail =>\n\
    \                                                            List(1l to carrotLeft)\
    \ match {\n                                                                case\
    \ head :: tail =>\n                                                          \
    \          List(1l to carrotEaten) match {\n                                 \
    \                                       case head :: tail =>\n               \
    \                                                             List(1l to carrotLeft)\
    \ match {\n                                                                  \
    \              case head :: tail =>\n                                        \
    \                                            List(1l to carrotEaten) match {\n\
    \                                                                            \
    \            case head :: tail =>\n                                          \
    \                                                  List(1l to carrotLeft) match\
    \ {\n                                                                        \
    \                        case head :: tail =>\n                              \
    \                                                                      List(1l\
    \ to carrotEaten) match {\n                                                  \
    \                                                      case head :: tail =>\n\
    \                                                                            \
    \                                List(1l to carrotLeft) match {\n            \
    \                                                                            \
    \                        case head :: tail =>\n                              \
    \                                                                            \
    \          List(1l to carrotEaten) match {\n                                 \
    \                                                                            \
    \           case head :: tail =>\n                                           \
    \                                                                            \
    \ List(1l to carrotLeft) match {\n                                           \
    \                                                                            \
    \     case head :: tail =>\n                                                 \
    \                                                                            \
    \   List(1l to carrotEaten) match {\n                                        \
    \                                                                            \
    \                case head :: tail =>\n                                      \
    \                                                                            \
    \                      List(1l to carrotLeft) match {\n                      \
    \                                                                            \
    \                                          case head :: tail =>\n            \
    \                                                                            \
    \                                                        List(1l to carrotEaten)\
    \ match {\n                                                                  \
    \                                                                            \
    \      case head :: tail =>\n                                                \
    \                                                                            \
    \                            List(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3myxgakp.scala:76:157 --------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m                                                    \
    \                                                                            \
    \                        List(\n\e[31m\e[31m   |\e[0m                        \
    \                                                                            \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3myxgakp.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp3myxgakp.scala:36:25 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeft\e[0m = needed - remaining\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                      Not found: needed\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3myxgakp.scala:37:35 --------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (carrotLeft <= \e[31m0l\e[0m) List(\e\
    [31m1l\e[0m to \e[31m0l\e[0m) \e[33melse\e[0m List(\e[31m1l\e[0m to carrotLeft)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m       Found:    scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3myxgakp.scala:39:43 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m                \e[33mval\e[0m \e[36mcarrotEatenLeft\e[0m\
    \ = head - carrotEaten\n\e[31m\e[31m   |\e[0m                                \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of scala.collection.immutable.NumericRange"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots = number - need\n\
    \        var remaining = remaining - need\n        var meals = List[Long]()\n\
    \        while remaining != 0l {\n            val temp = remaining.min(need)\n\
    \            carrots += temp\n            meals += temp.toLong\n            remaining\
    \ -= temp\n        }\n        meals\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl0sep8_s.scala:40:13 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        meals\n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl0sep8_s.scala:32:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mremaining\e[0m = remaining - need\n\e[31m\e[31m   |\e[0m             \
    \           ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvariable\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (number < 0)\n            throw new RuntimeException(\"Not a valid\
    \ carrots count. Must be greater or equal to 0.\")\n        else if (need < 0)\n\
    \            throw new RuntimeException(\"Not a valid carrots need. Must be greater\
    \ or equal to 0.\")\n        else if (remaining < 0)\n            throw new RuntimeException(\"\
    Not a valid carrots need. Must be greater or equal to 0.\")\n        else if (number\
    \ == 0 && need == 0 && remaining == 0)\n            return result\n        else\
    \ if (remaining <= need) {\n            var totalCarrots = number\n          \
    \  while (totalCarrots > 0) {\n                var leftovers = remaining % need\n\
    \                result :+= leftovers.toLong\n                remaining -= leftovers\n\
    \                totalCarrots = totalCarrots - 1\n            }\n        }\n \
    \       else {\n            var totalCarrots = number\n            while (totalCarrots\
    \ > 0) {\n                var leftovers = remaining % need\n                result\
    \ :+= leftovers.toLong\n                remaining -= leftovers\n             \
    \   totalCarrots = totalCarrots - 1\n            }\n            result :+= remaining.toLong\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxt3quf3r.scala:45:26 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                remaining -= leftovers\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -=\
    \ is not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxt3quf3r.scala:54:26 ------------------------\e[0m\e\
    [0m\n\e[31m54 |\e[0m                remaining -= leftovers\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not\
    \ a member of Long - did you mean remaining.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if((number + need) > 1000)\
    \ List(number.toLong)\n        else List(number + need, number - remaining)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpothkgub5.scala:35)\n\tat Problem.main(tmpothkgub5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - remaining\n        val carrotLeft = (carrots - meals).toLong\n\
    \        val newCarrots = remaining - carrots.toLong\n        List(newCarrots,\
    \ carrotLeft)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn2ho65o6.scala:38)\n\tat Problem.main(tmpn2ho65o6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def max(a, b : Long) : Long\
    \ = {\n            if (a > b) a else b\n        }\n        // Your code here\n\
    \        // Base case\n        if (remaining == 0L) {\n            List(number.toLong)\n\
    \        } else if (number == 0L) {\n            List(remaining.toLong)\n    \
    \    } else if (need > remaining) {\n            List(number.toLong)\n       \
    \ } else {\n            val tmp = number % remaining\n            val remain =\
    \ number - tmp\n            val rest = eat(need, remain, remaining)\n        \
    \    List(rest)(0) :: rest\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdwz9u4m7.scala:31:17 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mdef\e[0m \e[36mmax\e[0m(\e[36ma\e[0m, \e\
    [36mb\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e[0m   \
    \              ^\e[0m\n\e[31m   |\e[0m                 ':' expected, but ',' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdwz9u4m7.scala:46:22 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            List(rest)(\e[31m0\e[0m) :: rest\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemain = remaining\n        if ((hungry > 0) || (hungryRemain\
    \ > 0)) {\n            if ((hungry > 0) || (hungryRemain > 0)) {\n           \
    \     val eatenCarrots = List(need, hungry)\n                val remainingCarrots\
    \ = List(need, remaining)\n                eat(number - hungry, need - hungry,\
    \ remaining - hungryRemain)\n            }\n            else {\n             \
    \   eat(number - hungry, need - hungry, 0)\n            }\n        }\n       \
    \ else {\n            eatenCarrots ::: remainingCarrots\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvkwq_4uw.scala:44:29 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            eatenCarrots ::: remainingCarrots\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: remainingCarrots\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number.toInt\n\
    \        var remaining = remaining.toInt\n        val needEaten = need.toInt\n\
    \n        if (eaten > need) {\n            val left = (need - eaten).toInt\n \
    \           remaining -= left\n            remaining\n        } else {\n     \
    \       val left = (needEaten - eaten).toInt\n            remaining -= left\n\
    \            remaining\n        }\n\n        remaining\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp_8jxubj.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      if (number == 0l) {\n    \
    \    List(0l)\n      } else {\n        if (need == 0l) {\n          number\n \
    \       } else {\n          number -= need\n          remaining = remaining -\
    \ need\n          if (remaining <= 0l) {\n            remaining = 0l\n       \
    \     need = number - remaining\n            number = 0l\n          }\n      \
    \    List(number, remaining)\n        }\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5d4ybejz.scala:35:10\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m          number\n\e[31m\e[31m\
    \   |\e[0m          ^^^^^^\e[0m\n\e[31m   |\e[0m          Found:    (number :\
    \ Long)\n\e[31m   |\e[0m          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5d4ybejz.scala:37:17 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m          number -= need\n\e[31m\e[31m   |\e[0m     \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value -= is not a member of Long\
    \ - did you mean number.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5d4ybejz.scala:38:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m          remaining\
    \ = remaining - need\n\e[31m\e[31m   |\e[0m          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m          Reassignment to val remaining\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp5d4ybejz.scala:40:22 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            remaining = \e[31m0l\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val remaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5d4ybejz.scala:41:17\
    \ -----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            need = number\
    \ - remaining\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val need\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp5d4ybejz.scala:42:19 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            number = \e[31m0l\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remain = remaining +\
    \ 1\n        val res = number + need - remain\n        if (res > 0) {\n      \
    \      List[Long](res.toLong)\n        } else {\n            List[Long](remaining.toLong)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ylvi3oj.scala:40)\n\tat Problem.main(tmp2ylvi3oj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val carrotsLeft = need - carrots\n        val carrotLeftRemaining = remaining\
    \ - carrots\n        val carrotList: List[Long] = List(carrotList.toLong, carrotLeftRemaining.toLong)\n\
    \        if (carrotLeftRemaining <= 0) {\n            carrotList.foldLeft((carrots,\
    \ carrotLeftRemaining))(_ + _)\n        }\n        else {\n            carrotList.foldLeft((carrots,\
    \ carrotLeftRemaining))((a, b) => a + b).toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9mfefv3u.scala:34:53 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mcarrotList\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List(carrotList.toLong, carrotLeftRemaining.toLong)\n\e\
    [31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9mfefv3u.scala:36:66 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            carrotList.foldLeft((carrots, carrotLeftRemaining))(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \                ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of (Int, Long),\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9mfefv3u.scala:39:76 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            carrotList.foldLeft((carrots, carrotLeftRemaining))((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a + b).toLong\n\e[31m\e[31m   |\e[0m            \
    \                                                              ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of (Int, Long), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFr"
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var i = 0\n        var j\
    \ = need\n        var list = List[Long]()\n        while (i < remaining)\n   \
    \     { \n          list += number.toLong\n          i +=1\n          j +=1\n\
    \        }\n        list += i\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdzred79t.scala:36:15 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m          list += number.toLong\n\e[31m\e[31m   |\e[0m\
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdzred79t.scala:40:13\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        list += i\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) \n \
    \           throw new IllegalArgumentException(\"Invalid input\");\n\n       \
    \ var temp : List[Long] = Nil;\n        var num : Long = number;\n\n        while(true)\
    \ {\n            if(num >= need) {\n                num %= need;\n           \
    \     temp = temp :+ num;\n                remaining -= num;\n            } else\
    \ {\n                break;\n            }\n        }\n        if(remaining <\
    \ 0) {\n            num %= remaining;\n            temp = temp :+ num;\n     \
    \   }\n        if(temp.isEmpty) \n            Nil\n        else\n            temp.map(x\
    \ => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxvydjegv.scala:41:26 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                remaining -= num;\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not\
    \ a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpxvydjegv.scala:43:16 ------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m                break;\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0, s\"\
    $number must be greater than 0!\")\n        require(need > 0, s\"$need must be\
    \ greater than 0!\")\n        require(remaining > 0, s\"$remaining must be greater\
    \ than 0!\")\n        val newRemaining = remaining\n        val newNumber = number\n\
    \        if (newRemaining == 0l) {\n            return List(newNumber.toLong)\n\
    \        }\n        if (newRemaining < need) {\n            newNumber += newRemaining\n\
    \            newRemaining = 0\n        }\n        if (newNumber + newRemaining\
    \ > need) {\n            newNumber += need - newRemaining\n            newRemaining\
    \ = need\n        }\n        List(newNumber.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmtau48nw.scala:40:22 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            newNumber += newRemaining\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value += is\
    \ not a member of Long - did you mean newNumber.!=?\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmpmtau48nw.scala:41:25 -----------------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m            newRemaining = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val newRemaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmtau48nw.scala:44:22\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            newNumber +=\
    \ need - newRemaining\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m           value += is not a member of Long - did you mean newNumber.!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpmtau48nw.scala:45:25 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            newRemaining = need\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val newRemaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010702
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number <= 1000 && need\
    \ <= 1000 && remaining <= 1000) return List((number - need).toLong, remaining\
    \ - need)\n        else List(0l.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnzgg4y5x.scala:35)\n\tat Problem.main(tmpnzgg4y5x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val result = ListBuffer[Long]()\n\
    \        val newNeed = need - remaining\n        val remainingCarrots = remaining\n\
    \        while (number > 0) {\n            number -= 1\n            remaining\
    \ += newNeed\n            result.addOne(number + newNeed)\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuitlumbo.scala:35:19 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuitlumbo.scala:36:22\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            remaining +=\
    \ newNeed\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \           value += is not a member of Long - did you mean remaining.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(remaining < 0){\n   \
    \         return List(number.toLong)\n        }\n\n        // Complete the function\n\
    \        var list = []\n        var eaten = number\n        var carrotsToEat =\
    \ need\n        var remainingCarrots = remaining\n\n        while (remainingCarrots\
    \ > 0){\n            carrotsToEat -= 1\n            carrots = carrots + 1\n  \
    \          remainingCarrots = remainingCarrots - 1\n            list += carrots.toLong\n\
    \        }\n        println(list)\n        list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptk0lcvvy.scala:36:20 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e[36mlist\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    an\
    \ identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptk0lcvvy.scala:37:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m\
    \ \e[36meaten\e[0m = number\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>'\
    \ expected, but 'end of statement' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptk0lcvvy.scala:43:12 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m            carrots = carrots + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: carrots\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptk0lcvvy.scala:43:22 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            carrots = carrots + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: carrots\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmptk0lcvvy.scala:45:17 ------------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m            list += carrots.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Null - did you mean\
    \ Null.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptk0lcvvy.scala:45:20\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            list += carrots.toLong\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: carrots\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(0 <= number && number\
    \ <= 1000)\n        require(0 <= need && need <= 1000)\n        require(0 <= remaining\
    \ && remaining <= 1000)\n        val carrotsRemaining = number - remaining\n \
    \       val carrotsNeeded = need + carrotsRemaining\n        val carrots = carrotsNeeded\
    \ - carrotsRemaining\n        val remaining = carrots - carrotsNeeded\n      \
    \  (List(carrots, remaining))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbepb5ywx.scala:34:40 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mcarrotsRemaining\e[0m =\
    \ number - remaining\n\e[31m\e[31m   |\e[0m                                  \
    \      ^\e[0m\n\e[31m   |\e[0m                                    Recursive \e\
    [33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var meals: List[Long] =\
    \ List[Long](number, need)\n        var carrots_left = 1\n        while (carrots_left\
    \ < remaining) {\n            meals = meals :+ number\n            carrots_left\
    \ = meals.sum\n        }\n        if (meals.sum < remaining) {\n            meals\
    \ :+= remaining\n        }\n        meals\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4u16ydue.scala:35:27\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            carrots_left = meals.sum\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    Long\n\e[31m   |\e[0m                  \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def eatOne(number : Long,\
    \ need : Long, remaining : Long) : Long = {\n            if (remaining < need)\
    \ {\n                number -= need\n                remaining += need\n     \
    \           need = number / 3\n            } else {\n                number -=\
    \ remaining\n                remaining = 0\n            }\n            number\n\
    \        }\n        // your solution goes here\n        val mylist = new ListBuffer[Long]\n\
    \        for (x <- 0 to 1000) {\n            if (x == number) {\n            \
    \    mylist += eatOne(x, need, remaining)\n            } else {\n            \
    \    mylist += eatOne(x, remaining - number, remaining - number)\n           \
    \ }\n        }\n        if (remaining > 0) {\n            mylist += eatOne(remaining,\
    \ 0, 0)\n        }\n        mylist.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpps55gqft.scala:33:23 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                number -= need\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpps55gqft.scala:34:26 ------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                remaining += need\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value += is not a member of Long\
    \ - did you mean remaining.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpps55gqft.scala:35:21\
    \ -----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                need\
    \ = number / \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val need\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpps55gqft.scala:37:23 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                number -= remaining\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpps55gqft.scala:38:26 -----------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                remaining = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val remaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010708
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        if (remaining <= 0) {\n            List(number - need)\n        } else\
    \ {\n            val needToEat = need - remaining\n            if (needToEat <=\
    \ 0) {\n                List(number - need)\n            } else {\n          \
    \      val remaining = number - need\n                val carrots = need + remaining\n\
    \                List(number - need, number)\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyxd0kh3.scala:46)\n\tat Problem.main(tmpuyxd0kh3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var hungry = true\n    \
    \    var carrots = number\n        var eaten = 0\n        var left = 0\n     \
    \   while (hungry && carrots > 0 && eaten < need && remaining > 0) {\n       \
    \     left += carrots\n            hungry = false\n            carrots = if (left\
    \ >= remaining) 0 else remaining\n            eaten = number - carrots\n     \
    \       number -= carrots\n            remaining -= carrots\n        }\n     \
    \   List(number, left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0hft4qw.scala:36:17 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            left += carrots\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf0hft4qw.scala:39:20\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m            eaten = number -\
    \ carrots\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Found:    Long\n\e[31m   |\e[0m             \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0hft4qw.scala:40:19\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            number -= carrots\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf0hft4qw.scala:41:22 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m            remaining -= carrots\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not a member\
    \ of Long - did you mean remaining.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0 && remaining\
    \ > 0 && number < 1000 && need < 1000 && remaining < 1000, \"Eat: number or need\
    \ is too small or large\")\n        val eat = number - need\n        val remaining\
    \ = remaining + eat\n        if (number > need) {\n            remaining + eat\n\
    \        } else {\n            List(need, remaining)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptrzwfwqg.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ + eat\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toDouble\
    \ * 0.85\n        val hungryRemaining = remaining.toDouble * 0.85\n        val\
    \ hungryNeed = hungryRemaining - hungry\n        val hungryNeededString = hungryNeed\
    \ + s\"l\"\n        val hungryNeededString = hungryNeededString.replace(\"l\"\
    , \"m\")\n        val hungryNeededString = hungryNeededString.replace(\"m\", \"\
    u\")\n        val hungryNeededString = hungryNeededString.replace(\"u\", \"i\"\
    )\n        val hungryNeededString = hungryNeededString.replace(\"i\", \"o\")\n\
    \        val hungryNeededString = hungryNeededString.replace(\"o\", \"y\")\n \
    \       val hungryNeededString = hungryNeededString.replace(\"y\", \"s\")\n  \
    \      val hungryNeededString = hungryNeededString.replace(\"s\", \"e\")\n   \
    \     val hungryNeededString = hungryNeededString.replace(\"e\", \"o\")\n    \
    \    val hungryNeededString = hungryNeededString.replace(\"o\", \"y\")\n     \
    \   val hungryNeededString = hungryNeededString.replace(\"y\", \"s\")\n      \
    \  val hungryNeededString = hungryNeededString.replace(\"s\", \"e\")\n       \
    \ val hungryNeededString = hungryNeededString.replace(\"e\", \"o\")\n        val\
    \ hungryNeededString = hungryNeededString.replace(\"o\", \"y\")\n        val hungryNeededString\
    \ = hungryNeededString.replace(\"y\", \"s\")\n        val hungryNeededString =\
    \ hungryNeededString.replace(\"s\", \"e\")\n        val hungryNeededString = hungryNeededString.replace(\"\
    e\", \"o\")\n        val hungryNeededString = hungryNeededString.replace(\"o\"\
    , \"y\")\n        val hungryNeededString = hungryNeededString.replace(\"y\", \"\
    s\")\n        val hungryNeededString = hungryNeededString.replace(\"s\", \"e\"\
    )\n        val hungryNeededString = hungryNeededString.replace(\"e\", \"o\")\n\
    \        val hungryNeededString = hungryNeededString.replace(\"o\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0hkp76ok.scala:55:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36mhungryNeededString\e[0m\
    \ = hungryNeededString.replace(\"o\n\e[31m\e[31m   |\e[0m                    \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                    unclosed string literal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp0hkp76ok.scala:57:34 -----------------------------------------\e[0m\e\
    [0m\n\e[31m57 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                           \
    \       ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but '=' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0hkp76ok.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryNeededString\e[0m = hungryNeededString.replace(\e[31m\"l\"\e[0m,\
    \ \e[31m\"m\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeededString is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryNeededString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0hkp76ok.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryNeededString\e[0m\
    \ = hungryNeededString.replace(\e[31m\"m\"\e[0m, \e[31m\"u\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeededString is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryNeededString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0hkp76ok.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryNeededString\e[0m\
    \ = hungryNeededString.replace(\e[31m\"u\"\e[0m, \e[31m\"i\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      val totalEaten = number -\
    \ remaining\n      val leftOver = remaining - need\n      require(number >= 0)\n\
    \      require(need >= 0)\n      require(remaining >= 0)\n\n      if (number ==\
    \ 0)\n        List(number.toLong)\n      else {\n        if (leftOver == 0)\n\
    \          List(number.toLong)\n        else {\n          val list = List(number.toLong)\n\
    \          if (list.head < leftOver)\n            List(list.head + leftOver.toLong)\n\
    \          else {\n            val tempList = list\n            while (tempList.head\
    \ < leftOver)\n              tempList = tempList.tail\n            List(tempList.head\
    \ + leftOver.toLong)\n          }\n        }\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5x3eminr.scala:49:23 -----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m              tempList = tempList.tail\n\e[31m\e[31m\
    \   |\e[0m              ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \       Reassignment to val tempList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var list: List[Long] = Nil\n\
    \        if (number >= need) {\n            var n = need\n            var m =\
    \ number\n            while (m+n != 0) {\n                m -= 1\n           \
    \     n -= 1\n                list += m.toLong\n            }\n            if\
    \ (m == 0) {\n                list += number.toLong\n            } else {\n  \
    \              list += n.toLong\n            }\n        }\n        if (number\
    \ > remaining) {\n            list += number.toLong\n        }\n        list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6i9v_bmb.scala:38:21 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                list += m.toLong\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp6i9v_bmb.scala:41:21 ------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m                list += number.toLong\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long] - did\
    \ you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6i9v_bmb.scala:43:21\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                list += n.toLong\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    value +=\
    \ is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6i9v_bmb.scala:47:17 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            list += number.toLong\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ - need\n        if (remaining < 0L) {\n            List(0L)\n        } else\
    \ {\n            List(number - remaining)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0cahou6s.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - need\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number - remaining\n\
    \        val newNumber = needed + remaining\n        val newNeed = needed + remaining\n\
    \        val newRemaining = number - newNeed - newNumber\n        if (remaining\
    \ < 0) {\n            newRemaining = 0\n        }\n        val result = List(total.toLong,\
    \ newRemaining.toLong)\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp54twgp9m.scala:32:24 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mnewNumber\e[0m = needed\
    \ + remaining\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: needed\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp54twgp9m.scala:33:22 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mnewNeed\e[0m = needed +\
    \ remaining\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                      Not found: needed\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp54twgp9m.scala:36:25 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            newRemaining = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val newRemaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0 && number\
    \ <= 1000, \"Invalid number\")\n        require(need > 0 && need <= 1000, \"Invalid\
    \ need\")\n        require(remaining > 0 && remaining <= 1000, \"Invalid remaining\"\
    )\n        val nCarrots = number\n        val kCarrots = need\n        val rCarrots\
    \ = remaining\n        var remainder = 0\n        var newNumber = 0L\n       \
    \ var newNeed = 0L\n        var newRemaining = 0L\n        var i = 0\n       \
    \ while (rCarrots > 0) {\n            val carrots = nCarrots.pow(i).mod(rCarrots)\n\
    \            newNumber += carrots\n            newNeed += kCarrots.pow(i)\n  \
    \          newRemaining += carrots\n            remainder = carrots\n        \
    \    i += 1\n        }\n        val result: List[Long] = List(newNumber.toLong,\
    \ newRemaining.toLong)\n        require(remainder == 0)\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgmm70z48.scala:43:35 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = nCarrots.pow(i).mod(rCarrots)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue pow is not a member of Long, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgmm70z48.scala:45:20 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            newNeed += kCarrots.pow(i)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpgmm70z48.scala:45:32 ------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m            newNeed += kCarrots.pow(i)\n\e[31m\e[31m   |\e[0m        \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue pow is not a member of\
    \ Long, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\e[31m   |\e[0m\
    \  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var hungry = true\n    \
    \    var eaten = 0\n        var left = 0\n        var answer = new ListBuffer[Long]()\n\
    \        while (hungry) {\n            // eat as much as possible\n          \
    \  while (number >= eaten) {\n                eaten += 1\n                number\
    \ -= 1\n            }\n            while (need >= left) {\n                left\
    \ += 1\n                need -= 1\n            }\n            hungry = false\n\
    \            while (number >= left || need >= eaten) {\n                // eat\
    \ and update counters\n                eaten += 1\n                number -= 1\n\
    \                left += 1\n                need -= 1\n                // check\
    \ if hungry after eat\n                if ((number >= eaten) && (need >= left))\
    \ {\n                    hungry = true\n                }\n            }\n   \
    \         answer += left.toLong\n            answer += eaten.toLong\n        }\n\
    \        if (left < remaining) {\n            answer += left.toLong\n        \
    \    answer += remaining\n        }\n        answer.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplhq7jiqt.scala:39:23 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                number -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -=\
    \ is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmplhq7jiqt.scala:43:21 ------------------------\e[0m\e[0m\n\
    \e[31m43 |\e[0m                need -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a member\
    \ of Long - did you mean need.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplhq7jiqt.scala:49:23\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m                number -=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m              value -= is not a member of Long - did you mean number.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplhq7jiqt.scala:51:21 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                need -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                value -=\
    \ is not a member of Long - did you mean need.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var meals : List[Long] =\
    \ List()\n        if (number > 1000) meals = List(0l)\n        if (need > 1000)\
    \ meals = meals.reverse\n        if (remaining > 1000) meals = meals.reverse\n\
    \        meals = meals.reverse.head :: meals.reverse.tail\n        meals\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.eat(tmpdp0f9o2j.scala:35)\n\
    \tat Problem$.main(tmpdp0f9o2j.scala:39)\n\tat Problem.main(tmpdp0f9o2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots = number\n \
    \       var remaining = remaining\n        var meals = List[Long]()\n\n      \
    \  while(number > 0 && need > 0) {\n            meals = meals :+ carrots\n   \
    \         carrots -= 1\n            number -= 1\n            need -= 1\n     \
    \   }\n        meals = meals :+ carrots\n        carrots = remaining\n       \
    \ meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfml8chsa.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfml8chsa.scala:38:19\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            number -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value -= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfml8chsa.scala:39:17 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            need -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean need.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010714
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining <= 0) List(number,\
    \ 0)\n        else if (number <= need) List(number, 0)\n        else List(number,\
    \ need - number)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptaivfc5v.scala:36)\n\tat Problem.main(tmptaivfc5v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Initialize your solution\
    \ here\n        val ans = List[Long]()\n        var remaining = remaining\n  \
    \      val carrots = ListBuffer(number)\n\n        while(number > 0) {\n     \
    \       carrots.toList\n            number -= need\n        }\n        ans ::=\
    \ carrots.toList\n\n        while(number > 0) {\n            carrots ++= ListBuffer(number)\n\
    \            number -= need\n        }\n        ans ::= carrots.toList\n     \
    \   remaining -= 1\n        while(remaining > 0) {\n            carrots ++= ListBuffer(number)\n\
    \            number -= need\n        }\n        ans ::= carrots.toList\n\n   \
    \     while(number > 0) {\n            carrots ++= ListBuffer(number)\n      \
    \      number -= need\n        }\n        ans ::= carrots.toList\n        remaining\
    \ -= 1\n        while(remaining > 0) {\n            carrots ++= ListBuffer(number)\n\
    \            number -= need\n        }\n        ans ::= carrots.toList\n     \
    \   ans.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph04qq9bh.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph04qq9bh.scala:38:19\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            number -= need\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph04qq9bh.scala:40:12 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m        ans ::= carrots.toList\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m        value ::= is not a member of List[Long]\
    \ - did you mean ans.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph04qq9bh.scala:44:19\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            number -= need\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph04qq9bh.scala:46:12 ------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m        ans ::= carrots.toList\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m        value ::= is not a member of List[Long]\
    \ - did you mean ans.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph04qq9bh.scala:50:19\
    \ ------------------------\e[0m\e[0m\n\e[31m50 |\e[0m            number -= need\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph04qq9bh.scala:52:12 ------------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m        ans ::= carrots.toList\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m        value ::= is not a member of List[Long]\
    \ - did you mean ans.::?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph04qq9bh.sca"
  stdout: ''
  timestamp: 1660010720
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = (number - remaining)\n\
    \        if(hungry < 0) {\n            List(number.toLong)\n        }\n      \
    \  else if(hungry == 0) {\n            List(need)\n        }\n        else {\n\
    \            val hungryCarrots = number - remaining\n            val hungryCarrotsNeed\
    \ = (need - hungry)\n            val hungryCarrotsNeedRemaining = hungry - hungryCarrotsNeed\n\
    \            val hungryCarrotsNeedRemainingNeed = (hungryCarrotsNeed - hungryCarrotsNeedRemaining)\n\
    \            if(hungryCarrotsNeedRemainingNeed == 0) {\n                List(need)\n\
    \            }\n            else {\n                val hungryCarrotsNeedRemainingNeedRemaining\
    \ = hungryCarrotsNeedRemaining - hungryCarrotsNeedRemainingNeed\n            \
    \    if(hungryCarrotsNeedRemainingNeedRemaining == 0) {\n                    List(need)\n\
    \                }\n                else {\n                    List(need + hungryCarrotsNeedRemainingNeedRemaining,\
    \ hungry)\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnwsti_5.scala:58)\n\tat Problem.main(tmprnwsti_5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numbers = mutable.ArrayBuffer(number.toLong)\n\
    \        while (numbers.size < 1000 && remaining > 0) numbers += (numbers.size\
    \ + 1)\n        if (numbers.size > 1000) (numbers(numbers.size-1), numbers(0))\n\
    \        else (numbers.toArray, numbers.toArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx0askrw2.scala:31:22 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mnumbers\e[0m = mutable.ArrayBuffer(number.toLong)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx0askrw2.scala:33:33 --------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (numbers.size > \e[31m1000\e[0m) (numbers(numbers.size-\e\
    [31m1\e[0m), numbers(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                              Found:    (Nothing, Nothing)\n\e[31m   |\e[0m \
    \                                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx0askrw2.scala:34:13 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33melse\e[0m (numbers.toArray, numbers.toArray)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    (Nothing, Nothing)\n\e[31m   |\e[0m      \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010720
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number < 0 || need <\
    \ 0 || remaining < 0) {\n            throw new IllegalArgumentException(\"You\
    \ need more than 0 carrots to eat!\")\n        }\n        if (number >= need)\
    \ {\n            List[Long](need, 0l)\n        } else if (remaining < need) {\n\
    \            List[Long](remaining - need, 0l)\n        } else {\n            List[Long](number\
    \ - need, 0l)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz2zbm_gg.scala:43)\n\tat Problem.main(tmpz2zbm_gg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      val remaining = remaining.toLong\n\
    \      val need = need.toLong\n      val carrots = number.toLong\n      val result\
    \ = remaining.toLong - carrots.toLong\n      if (remaining > need) {\n       \
    \ List(result + need + carrots.toLong)\n      }\n      else {\n        List(result\
    \ + carrots.toLong)\n      }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm60ufloe.scala:31:22 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toLong\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm60ufloe.scala:32:17 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36mneed\e[0m = need.toLong\n\e\
    [31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 Recursive\
    \ \e[33mvalue\e[0m \e[35mneed\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number\n   \
    \     var left = 0\n        val result: List[Long] = new ArrayList[Long]\n   \
    \     while(number <= need){\n            left = number - eaten\n            number\
    \ = remaining\n            eaten = 0\n        }\n        while(number > 0){\n\
    \            number = number - 1\n            left = left + number\n         \
    \   eaten = eaten + 1\n        }\n        result.add(eaten.toLong)\n        result.add(left.toLong)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwtac1_1o.scala:33:37 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwtac1_1o.scala:35:19 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            left = number - eaten\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpwtac1_1o.scala:36:19 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            number = remaining\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwtac1_1o.scala:37:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            eaten =\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val eaten\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpwtac1_1o.scala:40:19 -----------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m            number = number - \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwtac1_1o.scala:41:19\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m            left = left + number\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      val eaten = mutable.Buffer[Long]()\n\
    \      val remaining = mutable.Buffer[Long]()\n\n      val carrot = number - need\n\
    \      if(number <= 0)\n        return List(number * 2l)\n      while(remaining.size\
    \ < carrot){\n        number -= 1\n        remaining += number\n        eaten\
    \ += number\n      }\n      if(number > 0)\n        return List(remaining += number\
    \ * 2l, eaten += number * 2l)\n      else {\n        val carrotRemaining = number\
    \ - remaining.size\n        if(number > remaining.size){\n          while (carrotRemaining\
    \ > 0){\n            number -= 1\n            remaining += number\n          \
    \  eaten += number\n            carrotRemaining -= 1\n          }\n        }\n\
    \        List(remaining += number * 2l, eaten += number * 2l)\n      }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b13pchf.scala:31:18 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mval\e[0m \e[36meaten\e[0m = mutable.Buffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6b13pchf.scala:32:22 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36mremaining\e[0m = mutable.Buffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6b13pchf.scala:38:15 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value -= is not a member of Long\
    \ - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6b13pchf.scala:48:19\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m            number -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value -= is not a member of Long - did you mean number.!=?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if ((number + need + remaining)\
    \ <= 1000) {\n            val result = (number + need + remaining).toList :: 0l.toList\n\
    \            result\n        } else {\n            val result = eat(number + need\
    \ - remaining, need, remaining).toList :: 0l.toList\n            result\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr151fs5c.scala:32:66 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = (number\
    \ + need + remaining).toList :: \e[31m0l\e[0m.toList\n\e[31m\e[31m   |\e[0m  \
    \                                                             ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m  value toList is not a member of Long - did you mean (\e[31m0L\e\
    [0m : Long).toInt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr151fs5c.scala:35:86\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36mresult\e[0m = eat(number + need - remaining, need, remaining).toList ::\
    \ \e[31m0l\e[0m.toList\n\e[31m\e[31m   |\e[0m                                \
    \                                                   ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m  value toList is not a member of Long - did you mean (\e[31m0L\e[0m : Long).toInt?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1qptnr1c.scala:30:73\
    \ --------------------\e[0m\e[0m\n\e[31m 30 |\e[0m    \e[33mdef\e[0m \e[36meat\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m, \e[36mneed\e[0m : \e[35mLong\e[0m, \e\
    [36mremaining\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\
    \e[31m\e[31m    |\e[0m                                                       \
    \                  ^\e[0m\n\e[31m    |\e[0m                                  \
    \                Found:    Unit\n\e[31m    |\e[0m                            \
    \                      Required: List[Long]\n\e[31m 31 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 32 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 33 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 34 |\e\
    [0m        \e[34m// Your code goes here\e[0m\n\e[31m 35 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 36 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 37 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 38 |\e\
    [0m        \e[34m// Your code goes here\e[0m\n\e[31m 39 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 40 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 41 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 42 |\e\
    [0m        \e[34m// Your code goes here\e[0m\n\e[31m 43 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 44 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 45 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 46 |\e\
    [0m        \e[34m// Your code goes here\e[0m\n\e[31m 47 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 48 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 49 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 50 |\e\
    [0m        \e[34m// Your code goes here\e[0m\n\e[31m 51 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 52 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 53 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 54 |\e\
    [0m        \e[34m// Your code goes here\e[0m\n\e[31m 55 |\e[0m        \e[34m//\
    \ Your code goes here\e[0m\n\e[31m 56 |\e[0m        \e[34m// Your code goes here\e\
    [0m\n\e[31m 57 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m 58 |\e\
    [0m        \e[34m// Your code goes here\e"
  stdout: ''
  timestamp: 1660010726
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val totalEaten = if (number\
    \ >= need) number else need\n        val remainingEaten = if (remaining >= number\
    \ && number > 0) number - number else 0\n        val newRemaining = (remaining\
    \ - remainingEaten)\n        val newRemainingAfter = totalEaten + newRemaining\n\
    \        val newNeedAfter = need + newRemainingAfter\n        List(newNeedAfter.toLong,\
    \ newRemainingAfter.toLong)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmuw7ac4x.scala:39)\n\tat Problem.main(tmpmuw7ac4x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number > 1000) throw\
    \ new IllegalArgumentException(\"Number must be less than 1000\")\n        if\
    \ (need > 1000) throw new IllegalArgumentException(\"Need must be less than 1000\"\
    )\n        if (remaining > 1000) throw new IllegalArgumentException(\"Remaining\
    \ must be less than 1000\")\n        // Your code goes here\n        var list\
    \ = List[Long]()\n        if (number == 0) {\n            list = List(need.toLong)\n\
    \        } else {\n            list = List(need - number.toLong)\n        }\n\
    \        if (remaining > 0) {\n            list = list :+ remaining\n        }\n\
    \        return list\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsqcylbj5.scala:47)\n\tat Problem.main(tmpsqcylbj5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n\
    \        val left   = hungry - need\n        val remain = hungry - remaining\n\
    \        if (left <= 0) {\n            List(number.toLong)\n        }\n      \
    \  else {\n            List(left.toLong, remaining.toLong)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwp4xdovg.scala:42)\n\tat Problem.main(tmpwp4xdovg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val neededCarrots = math.max(math.min(math.abs(need - remaining), remaining),\
    \ 0).toInt\n        val remaining = needed - carrots\n        if (remaining ==\
    \ 0) {\n            List[Long](number, 0)\n        } else {\n            List[Long](number,\
    \ math.min(neededCarrots, remaining))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu103sth5.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = needed\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: needed\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010720
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = math.min(number,\
    \ need)\n        val total = math.min(number, math.max(0, remaining))\n      \
    \  val newNumber = total - carrots\n        val newNeed = math.max(0, total)\n\
    \        val newRemaining = math.max(0, math.min(number, math.max(0, remaining)))\n\
    \        List(total.toLong, carrots.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb37lr9mh.scala:39)\n\tat Problem.main(tmpb37lr9mh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Write your code here\n\
    \        var list = List[Long]()\n        var remain = remaining\n        var\
    \ cnt = number\n        while(remain > 0) {\n            list.insert(0, cnt)\n\
    \            remain -= 1\n            cnt += 1\n        }\n        if(remain ==\
    \ 0) {\n            list.insert(0, cnt)\n        }\n        return list\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpngs3x_7f.scala:36:17 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            list.insert(\e[31m0\e[0m, cnt)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue insert is not\
    \ a member of List[Long] - did you mean List[Long].init?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpngs3x_7f.scala:41:17 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m            list.insert(\e[31m0\e[0m, cnt)\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue insert is not a member\
    \ of List[Long] - did you mean List[Long].init?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010731
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Solution code goes here\n\
    \        val carrots = number.toInt\n        var meals : List[Long] = List()\n\
    \        var carrots_left : Long = 0\n        while (carrots_left < remaining)\
    \ {\n            val meals_count = carrots - carrots_left\n            meals =\
    \ meals ++ List(need.toLong * meals_count)\n            carrots_left += meals_count\n\
    \        }\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Solve\n        // O(n)\n\
    \        // O(1)\n        val eaten = math.max(0, remaining - need)\n        val\
    \ leftovers = math.max(0, remaining - number)\n        val list = List(number.toLong)\n\
    \        if (eaten != 0) {\n            list :+= (eaten.toLong)\n        }\n \
    \       if (leftovers != 0) {\n            list :+= leftovers.toLong\n       \
    \ }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpespju_5i.scala:38:17 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            list :+= (eaten.toLong)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value :+= is not a member\
    \ of List[Long] - did you mean list.:+?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpespju_5i.scala:41:17 ------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m            list :+= leftovers.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         value :+= is not a member of List[Long] - did you\
    \ mean list.:+?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numbers = scala.util.Random\n\
    \                .shuffle(List(number, need, remaining).map(_.toLong))\n     \
    \   val needs = numbers.takeWhile(_ < needed)\n        val eaten = numbers.dropWhile(_\
    \ < needed).sum\n        val remaining = numbers.dropWhile(_ < need).sum\n   \
    \     List(needs.sum, eaten.sum, remaining.sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjp7pa4h_.scala:35:24 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = numbers.dropWhile(_\
    \ < need).sum\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mnumbers\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjp7pa4h_.scala:33:42\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds\e[0m = numbers.takeWhile(_ < needed)\n\e[31m\e[31m   |\e[0m        \
    \                                  ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                            Not found: needed\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjp7pa4h_.scala:34:42 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36meaten\e[0m = numbers.dropWhile(_\
    \ < needed).sum\n\e[31m\e[31m   |\e[0m                                       \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m                                          Not\
    \ found: needed\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjp7pa4h_.scala:36:30\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        List(needs.sum, eaten.sum,\
    \ remaining.sum)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        value sum is not a member of Long\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val result = mutable.ListBuffer.empty[Long]\n\
    \n        // Check number of remaining carrots first\n        if (remaining <\
    \ 0)\n            result.add(0)\n        else if (remaining <= number)\n     \
    \       result.addAll(0, number - remaining)\n        else {\n            // Check\
    \ remaining carrots first\n            if (remaining > number)\n             \
    \   result.add(number - remaining)\n            else {\n                // Check\
    \ need carrots next\n                if (need <= number)\n                   \
    \ result.add(need)\n                else {\n                    // Check number\
    \ carrots next\n                    val next = number - result.size\n        \
    \            if (next <= need)\n                        result.add(next)\n   \
    \                 else\n                        result.add(need)\n           \
    \     }\n            }\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm97taomz.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots = number //\
    \ total number of carrots you have eaten\n        var left = 0 // number of carrots\
    \ that you need to eat\n        while(carrots > 0 && left < remaining) {\n   \
    \         if (carrots >= need) {\n                carrots -= need\n          \
    \      left += 1\n            }\n            else {\n                carrots -=\
    \ remaining\n                carrots += number\n            }\n        }\n   \
    \     (carrots, left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8dcsax5i.scala:43:8\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m        (carrots, left)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (Long, Int)\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total : Long = 0l\n\
    \        var eaten : Long = 0l\n        var remaining = remaining\n        var\
    \ need = need\n\n        while (remaining > 0) {\n            if (remaining >\
    \ need) {\n                total += need\n                remaining -= need\n\
    \                eaten += 1\n            } else {\n                total += remaining\n\
    \                remaining -= remaining\n            }\n        }\n        List(eaten.toLong,\
    \ total.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp81wvu7n.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp81wvu7n.scala:34:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mneed\e[0m = need\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvariable\e[0m \e[35mneed\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require (number > 0 && number\
    \ <= 1000,\n            \"Invalid input: Number of carrots must be greater than\
    \ 0, and less than 1000.\")\n        require (need > 0 && need <= 1000,\n    \
    \        \"Invalid input: Number of carrots must be greater than 0, and less than\
    \ 1000.\")\n        require (remaining > 0 && remaining <= 1000,\n           \
    \ \"Invalid input: Number of carrots must be greater than 0, and less than 1000.\"\
    )\n\n        val totalCarrots = number.toInt\n        val needCarrots = need.toInt\n\
    \        val remainingCarrots = remaining.toInt\n\n        val hungry = if (totalCarrots\
    \ == needCarrots && remainingCarrots == 0) true else false\n        val hungryNumbers\
    \ = if (totalCarrots == needCarrots && remainingCarrots > 0) List(totalCarrots\
    \ - needCarrots, remainingCarrots) else List(needCarrots, remainingCarrots)\n\n\
    \        val eatenCarrots = if (hungry) hungryNumbers.sum.toLong else totalCarrots\
    \ - needCarrots + needCarrots.toLong\n        val leftCarrots = if (hungry) hungryNumbers.sum\
    \ - eatenCarrots else totalCarrots - needCarrots + needCarrots.toLong - eatenCarrots\n\
    \n        List(eatenCarrots, leftCarrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3h4rcy3v.scala:51)\n\tat Problem.main(tmp3h4rcy3v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val result: List[Long] =\
    \ List(number + need - remaining)\n        if(remaining == 0)\n            result\n\
    \        else if(number == 0)\n            List(number + need, remaining)\n  \
    \      else\n            result ++ eat(number - 1, need, remaining - number)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpny9flr8u.scala:40)\n\tat Problem.main(tmpny9flr8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(number > 1000) return\
    \ List()\n        if(need > 1000) return List()\n        if(remaining > 1000)\
    \ return List()\n\n        val n = number.toInt\n        val m = need.toInt\n\
    \        val r = remaining.toInt\n        val arr = (1 to n)\n            .map(x\
    \ => (x * m) / r)\n            .map(x => x + x)\n            .map(x => x * x -\
    \ 1)\n            .map(x => x + 1)\n\n        val total = (arr :+ 0).sum\n   \
    \     val res = (arr.sum - n).toLong\n\n        if(res < 0) {\n            val\
    \ m = Math.ceil(res / 1)\n            val m2 = (m - 1).toLong\n            val\
    \ m3 = m2.toLong\n\n            val newres = (m3 * m2).toLong - n\n          \
    \  if(newres <= 0) List(total) else List(total, m2, m3)\n        } else List(total)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp019xmg7g.scala:57)\n\tat Problem.main(tmp019xmg7g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val nRemaining = remaining\
    \ - need\n        require(number > 0 && number < 1000 && need > 0 && need < 1000\
    \ && remaining > 0 && remaining < 1000, \"invalid argument\")\n        var result:\
    \ List[Long] = Nil\n        val c = number / need\n        val l = List(c, c +\
    \ (c / 2))\n        if (nRemaining > 0) result += nRemaining :: l\n        if\
    \ (nRemaining <= 0) result += l.map(_ * need) ::: List(l.last)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp652dk6vl.scala:36:35 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (nRemaining > \e[31m0\e[0m) result\
    \ += nRemaining :: l\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value += is not a member of List[Long] - did you mean\
    \ List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp652dk6vl.scala:37:36\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (nRemaining\
    \ <= \e[31m0\e[0m) result += l.map(_ * need) ::: List(l.last)\n\e[31m\e[31m  \
    \ |\e[0m                             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ += is not a member of List[Long] - did you mean List[Long].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val carrotsorextracted = remaining.toInt\n        val needextracted =\
    \ need.toInt\n        val listOfNine = List(9l.toLong,\n                     \
    \         10l.toLong,\n                              11l.toLong,\n           \
    \                   12l.toLong,\n                              13l.toLong,\n \
    \                             14l.toLong,\n                              15l.toLong,\n\
    \                              16l.toLong,\n                              17l.toLong,\n\
    \                              18l.toLong,\n                              19l.toLong)\n\
    \        val carrotsleft = (carrots*(needextracted-carrots)).toLong\n        val\
    \ carrotsleftofNine = carrotsleft.toLong-carrotsleftofNine\n        val carrotsleftofTen\
    \ = carrotsleft.toLong-carrotsleftofTen\n        val carrotsleftofEleven = carrotsleft.toLong-carrotsleftofEleven\n\
    \        val carrotsleftofTwelve = carrotsleft.toLong-carrotsleftofTwelve\n  \
    \      val carrotsleftofThirteen = carrotsleft.toLong-carrotsleftofThirteen\n\
    \        val carrotsleftofFourteen = carrotsleft.toLong-carrotsleftofFourteen\n\
    \        val carrotsleftofFifteen = carrotsleft.toLong-carrotsleftofFifteen\n\
    \        val carrotsleftofSixteen = carrotsleft.toLong-carrotsleftofSixteen\n\
    \        val carrotsleftofSeventeen = carrotsleft.toLong-carrotsleftofSeventeen\n\
    \        val carrotsleftofEighteen = carrotsleft.toLong-carrotsleftofEighteen\n\
    \        val carrotsleftofNineteen = carrotsleft.toLong-carrotsleftofNineteen\n\
    \n        val carrotsList = new mutable.MutableList[Long]\n        if(carrotsleftofNine\
    \ > 0){\n            carrotsList += listOfNine\n        }\n        if(carrotsleftofTen\
    \ > 0){\n            carrotsList += listOfNine\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm88gpiqw.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm88gpiqw.scala:46:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsleftofNine\e[0m = carrotsleft.toLong-carrotsleftofNine\n\e[31m\e\
    [31m   |\e[0m                                                   ^\e[0m\n\e[31m\
    \   |\e[0m                            Recursive \e[33mvalue\e[0m \e[35mcarrotsleftofNine\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm88gpiqw.scala:47:50\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsleftofTen\e[0m = carrotsleft.toLong-carrotsleftofTen\n\e[31m\e\
    [31m   |\e[0m                                                  ^\e[0m\n\e[31m\
    \   |\e[0m                             Recursive \e[33mvalue\e[0m \e[35mcarrotsleftofTen\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm88gpiqw.scala:48:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsleftofEleven\e[0m = carrotsleft.toLong-carrotsleftofEleven\n\e\
    [31m\e[31m   |\e[0m                                                     ^\e[0m\n\
    \e[31m   |\e[0m                          Recursive \e[33mvalue\e[0m \e[35mcarrotsleftofEleven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm88gpiqw.scala:49:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsleftofTwelve\e[0m = carrotsleft.toLong-carrotsleftofTwelve\n\e\
    [31m\e[31m   |\e[0m                                                     ^\e[0m\n\
    \e[31m   |\e[0m                          Recursive \e[33mvalue\e[0m \e[35mcarrotsleftofTwelve\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explai"
  stdout: ''
  timestamp: 1660010742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val m = remaining.toInt\
    \ % need.toInt\n        val r = remaining.toInt / need.toInt\n        val list\
    \ = List(number.toLong, m.toLong, r.toLong)\n        if (m == 0) {\n         \
    \   list.sortBy(x => x)\n        }\n        else {\n            list.sortBy(x\
    \ => x % 2)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnd46kocv.scala:42)\n\tat Problem.main(tmpnd46kocv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ + number\n        val stock = List(number.toLong, remaining.toLong)\n      \
    \  val meals = List(number.toLong, need.toLong)\n        val carrots = stock.diff(meals)\n\
    \        val hungry = carrots.last\n        if (carrots.isEmpty) {\n         \
    \   List(number, need)\n        } else {\n            (eat(carrots, number - hungry,\
    \ remaining), hungry)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl2az37hn.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ + number\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2az37hn.scala:39:17\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m            (eat(carrots, number\
    \ - hungry, remaining), hungry)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    (carrots : List[Long])\n\e[31m\
    \   |\e[0m                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numEaten = number.toLong\n\
    \        val numNeed = need.toLong\n        val numLeft = remaining - numNeed\n\
    \        if (numLeft == 0) {\n            List(0l.toLong, 0l.toLong)\n       \
    \ } else {\n            List(numEaten.toLong + numLeft.toLong, numLeft.toLong)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptstw1aj1.scala:41)\n\tat Problem.main(tmptstw1aj1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val food = need.toInt\n        val remaining = remaining.toInt\n    \
    \    val numCarrots = math.min(carrots, food + remaining)\n        val carrotLeft\
    \ = numCarrots - food\n        val numEaten = carrots - numCarrots\n        val\
    \ leftOfCarrots = remaining - numEaten\n        (List(carrotLeft.toLong, numEaten.toLong))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1995ht_m.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val result: List[Long] =\
    \ new Array[Long](2)\n        // Write your code here\n        val carrots = number.toInt\n\
    \        val carrotsNeed = need.toInt\n        val carrotsRemaining = remaining.toInt\n\
    \        val carrotsEaten = carrots - carrotsNeed\n        val carrotsLeft = (carrotsRemaining\
    \ - carrotsEaten)\n        result(0) = carrotsEaten.toLong\n        result(1)\
    \ = carrotsLeft.toLong\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyqg665h3.scala:31:33\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m](\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m                                 Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyqg665h3.scala:38:8\
    \ -------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        result(\e[31m0\e\
    [0m) = carrotsEaten.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue update is not a member of List[Long] - did you mean result.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyqg665h3.scala:39:8 -------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        result(\e[31m1\e[0m) = carrotsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member\
    \ of List[Long] - did you mean result.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require (number > 0, need\
    \ > 0, remaining > 0)\n        var result : List[Long] = Nil\n        var numberEaten\
    \ = 0\n        var needEaten = 0\n        var remainingCarrots = remaining\n \
    \       while (remainingCarrots > 0) {\n            numberEaten += number / remainingCarrots\n\
    \            needEaten += need / remainingCarrots\n            if (needEaten >\
    \ numberEaten) {\n                result :: needEaten :: result\n            }\n\
    \            number -= numberEaten * remainingCarrots\n            need -= needEaten\
    \ * remainingCarrots\n            remainingCarrots -= numberEaten * needEaten\n\
    \        }\n        result :: needEaten :: result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpyysi7zf7.scala:31:8 ------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        require (number > \e[31m0\e[0m, need > \e[31m0\e\
    [0m, remaining > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mrequire\e\
    [0m in \e[33mobject\e[0m \e[35mPredef\e[0m with types\n\e[31m   |\e[0m (requirement:\
    \ Boolean, message: => Any): Unit\n\e[31m   |\e[0m (requirement: Boolean): Unit\n\
    \e[31m   |\e[0mmatch arguments (Boolean, Boolean, Boolean)\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyysi7zf7.scala:37:24 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            numberEaten += number / remainingCarrots\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpyysi7zf7.scala:38:22 ------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m            needEaten += need / remainingCarrots\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpyysi7zf7.scala:42:19 ------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            number -= numberEaten * remainingCarrots\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyysi7zf7.scala:43:17\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            need -= needEaten\
    \ * remainingCarrots\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            value -= is not a member of Long - did you mean need.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyysi7zf7.scala:46:8 ---------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        result :: needEaten :: result\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[Matchable]\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compi"
  stdout: ''
  timestamp: 1660010750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number < 1000)\n\
    \        require(need < 1000)\n        require(remaining < 1000)\n        val\
    \ list = (1 to 1000 - number).map(_ + number).toList.sorted\n        val res =\
    \ list map {\n            case x if x == need => remaining + need\n          \
    \  case x if x < need => remaining + x else 0\n        }\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxlyem7z_.scala:37:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x < need\
    \ => remaining + x \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                         ^^^^\e[0m\n\e[31m   |\e[0m         \
    \                     end of statement expected but 'else' found\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxlyem7z_.scala:34:25 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = (\e[31m1\e[0m\
    \ to \e[31m1000\e[0m - number).map(_ + number).toList.sorted\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \           Found:    Long\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val listOfCarrots = List.range(1,\
    \ number + 1).map(x => 0l)\n        var counter = 0\n        // loop to check\
    \ if you have enough carrots to eat:\n        while (counter < remaining) {\n\
    \            // loop to check if you need more carrots to eat\n            while\
    \ (counter < need) {\n                // loop to check if you have too many carrots\
    \ to eat\n                while (counter < number) {\n                    counter\
    \ += 1\n                    listOfCarrots(counter) = listOfCarrots(counter) +\
    \ 1\n                }\n                counter += 1\n            }\n        \
    \    counter += 1\n        }\n        listOfCarrots.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp42c0vkn5.scala:31:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlistOfCarrots\e[0m = List.range(\e\
    [31m1\e[0m, number + \e[31m1\e[0m).map(\e[36mx\e[0m => \e[31m0l\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                No implicit Ordering defined for AnyVal.\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n\
    \            throw new IllegalArgumentException(\"Cannot eat negative numbers\
    \ or numbers over 1,000.\")\n        }\n        val myList = mutable.ListBuffer[Long]()\n\
    \        val myRemaining = remaining\n        var carrots = 0\n        while (myRemaining\
    \ > 0 && !carrots) {\n            val next = number - need\n            if (next\
    \ < 0) {\n                carrots = next * -1\n            } else {\n        \
    \        carrots = next\n            }\n            myRemaining -= carrots\n \
    \           myList += carrots\n        }\n        if (carrots) {\n           \
    \ myList += carrots\n        }\n        myList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpma7610ka.scala:34:21 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmyList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpma7610ka.scala:37:34 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mwhile\e[0m (myRemaining > \e[31m0\e[0m\
    \ && !carrots) {\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value unary_! is not a member of Int - did you mean\
    \ Int.unary_+?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpma7610ka.scala:40:26\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                carrots = next\
    \ * -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpma7610ka.scala:42:26 --------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m                carrots = next\n\e[31m\e[31m   |\e[0m    \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                          Found:\
    \    (next : Long)\n\e[31m   |\e[0m                          Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpma7610ka.scala:44:24\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            myRemaining -=\
    \ carrots\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m         value -= is not a member of Long - did you mean myRemaining.!=?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpma7610ka.scala:47:12 --------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mif\e[0m (carrots) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (carrots : Int)\n\
    \e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000)\n        require(need >= 0 && need <= 1000)\n        require(remaining\
    \ >= 0 && remaining <= 1000)\n\n        if(remaining == 0) {\n            List(number.toLong)\n\
    \        } else {\n            val n = math.min(number.toLong, remaining)\n  \
    \          remaining -= n\n            List(n.toLong, number.toLong)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcnnouqub.scala:39:22 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            remaining -= n\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not a member\
    \ of Long - did you mean remaining.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining > 0)\n   \
    \         if (number >= need) {\n                val carrot = number - need\n\
    \                number -= need\n                remaining -= 1\n            \
    \    List(carrot.toLong, remaining.toLong)\n            } else {\n           \
    \     val carrot = remaining\n                number -= remaining\n          \
    \      remaining -= carrot\n                List(carrot.toLong, remaining.toLong)\n\
    \            }\n        else\n            List(remaining.toLong, 0l.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxnnyms5l.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                number -= need\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpxnnyms5l.scala:35:26 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                remaining -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not a member\
    \ of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxnnyms5l.scala:39:23 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m                number -= remaining\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              value -= is not a member of Long - did you mean\
    \ number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxnnyms5l.scala:40:26\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                remaining\
    \ -= carrot\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m           value -= is not a member of Long - did you mean remaining.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCount = math.min(number,\
    \ remaining)\n        val restCount = math.max(remaining - number, 0)\n      \
    \  number - hungryCount :: (remaining - restCount) :: Nil\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqnf2484l.scala:36)\n\tat Problem.main(tmpqnf2484l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if ( number > 1000 || need\
    \ > 1000 || remaining > 1000 ) {\n            throw new IllegalArgumentException(\"\
    number/need/remaining must be within [0,1000]\")\n        }\n        val result:\
    \ List[Long] = List()\n        var carrotEaten = 0\n        val carrotNeed = remaining\
    \ - carrotEaten\n        val remainingCarrots = List(1 until number)\n       \
    \ for(c <- remainingCarrots) {\n            if (carrotEaten == need) {\n     \
    \           result ::= c.toLong\n                break\n            }\n      \
    \      if (c.sum == carrotNeed) {\n                result ::= c.toLong\n     \
    \           carrotEaten += 1\n            }\n        }\n        if (carrotEaten\
    \ < need) {\n            result ::= remainingCarrots.sum.toLong\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjav7wyjf.scala:37:44\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mremainingCarrots\e\
    [0m = List(\e[31m1\e[0m until number)\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                       Found:    (number : Long)\n\e[31m   |\e[0m           \
    \                                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjav7wyjf.scala:40:23 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                result ::= c.toLong\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value ::= is not a member\
    \ of List[Long] - did you mean result.::?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpjav7wyjf.scala:40:29 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                result ::= c.toLong\n\e[31m\e[31m   |\e[0m                \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of Range,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjav7wyjf.scala:41:16 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjav7wyjf.scala:44:23 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                result ::= c.toLong\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value ::= is not a member\
    \ of List[Long] - did you mean result.::?\n\e[31m\e[31m-- [E008] Not Found E"
  stdout: ''
  timestamp: 1660010759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Write your solution here\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        if (number <= need\
    \ && number <= remaining){\n            if (number > 0)\n                result.addOne(number)\n\
    \        }\n        else if (!(number <= remaining && number > 0)){\n        \
    \    val newNumbers = number - remaining\n            if (newNumbers > 0)\n  \
    \              result.addAll(List(newNumbers.toLong, 0l.toLong))\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptf78oxba.scala:32:21 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            val newNeed = (remaining + need)\n            val newRemaining =\
    \ (remaining - need)\n            val newNumber = (number + newNeed)\n       \
    \     val newNeed = newNeed / newNumber\n            val newRemaining = newRemaining\
    \ - newNeed\n            val newNumber = newNumber + 1\n            eat(newNumber,\
    \ newNeed, newRemaining)\n        } else {\n            val newNumber = (number\
    \ + need)\n            val newNeed = newNumber / remaining\n            val newRemaining\
    \ = newNumber % remaining\n            val newNumber = newNumber - 1\n       \
    \     eat(newNumber, newNeed, newRemaining)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_rrumghg.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mnewNeed\e[0m = newNeed\
    \ / newNumber\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewNeed is already defined as \e[33mvalue\e[0m \e[35mnewNeed\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_rrumghg.scala:36:16 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m            \e[33mval\e[0m \e[36mnewRemaining\e[0m = newRemaining\
    \ - newNeed\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewRemaining is already defined as \e[33mvalue\e[0m \e[35mnewRemaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_rrumghg.scala:37:16 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m            \e[33mval\e[0m \e[36mnewNumber\e[0m = newNumber + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mnewNumber is already defined as \e[33mvalue\e[0m \e[35mnewNumber\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_rrumghg.scala:43:16 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m            \e[33mval\e[0m \e[36mnewNumber\e[0m = newNumber - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mnewNumber is already defined as \e[33mvalue\e[0m \e[35mnewNumber\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1660010749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(number > 1000) \n   \
    \     throw new IllegalArgumentException(\"Number of carrots exceed 1000, please\
    \ try again\")\n        if(need > 1000) \n        throw new IllegalArgumentException(\"\
    Number of carrots exceed 1000, please try again\")\n        if(remaining > 1000)\
    \ \n        throw new IllegalArgumentException(\"Number of carrots exceed 1000,\
    \ please try again\")\n        var eat = List[Long]()\n        val remainingInStock\
    \ = remaining.toDouble\n        val carrotsNeed = need.toDouble\n        var remaining\
    \ = remainingInStock\n        var carrots = number\n        while(remaining >\
    \ 0){\n            carrots += carrotsNeed\n            if(carrots > 1000) throw\
    \ new IllegalArgumentException(\"Number of carrots exceed 1000, please try again\"\
    )\n            if(carrots < 1) throw new IllegalArgumentException(\"Number of\
    \ carrots exceed 1, please try again\")\n            if(carrots < remaining)\n\
    \            carrots = remaining\n            else\n            carrots -= remaining\n\
    \            remaining -= carrotsNeed\n            eat += carrots\n        }\n\
    \        return eat.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuka0hqvi.scala:38:31 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mremainingInStock\e[0m =\
    \ remaining.toDouble\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvariable\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpuka0hqvi.scala:43:20 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m            carrots += carrotsNeed\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Long - did you mean\
    \ Long.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuka0hqvi.scala:51:16\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            eat += carrots\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not\
    \ a member of List[Long] - did you mean List[Long].!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code goes here!\n\
    \        val hungry = (1000 - number) - need\n        val hungryRemaining = 1000\
    \ - hungry\n        val newEaten = number - hungry\n        val newEatenRemaining\
    \ = 1000 - newEaten\n        val newEatenList = List(hungry.toLong, newEaten.toLong)\n\
    \        val newEatenRemainingList = List(newEatenRemaining.toLong, 0)\n     \
    \   val newEatenList = hungryRemaining :: newEatenList\n        val newEatenRemainingList\
    \ = hungryRemaining :: newEatenRemainingList\n        val result: List[Long] =\
    \ newEatenList\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3f6lja7_.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mnewEatenList\e[0m = hungryRemaining\
    \ :: newEatenList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewEatenList is already defined as \e[33mvalue\e[0m \e[35mnewEatenList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3f6lja7_.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mnewEatenRemainingList\e[0m = hungryRemaining\
    \ :: newEatenRemainingList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewEatenRemainingList is already defined as \e[33mvalue\e\
    [0m \e[35mnewEatenRemainingList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    \n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt1rr2q94.scala:30:73\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \e[33mdef\e[0m \e[36meat\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m, \e[36mneed\e[0m : \e[35mLong\e[0m, \e\
    [36mremaining\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \                Found:    Unit\n\e[31m   |\e[0m                             \
    \                       Required: List[Long]\n\e[31m31 |\e[0m        \e[34m//\
    \ your code here\e[0m\n\e[31m32 |\e[0m        \n\e[31m33 |\e[0m        \n\e[31m34\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // TODO: write your code\
    \ here\n        val mealsRequired = need.toInt\n        var mealsRemaining = remaining\n\
    \        var list: List[Long] = ListBuffer.empty[Long]\n        while(mealsRemaining\
    \ > 0){\n            if(mealsRemaining >= need.toInt){\n                list +=\
    \ number.toLong\n                mealsRemaining -= need.toInt\n              \
    \  number -= 1\n            }\n            else {\n                list += number.toLong\n\
    \                mealsRemaining -= number.toInt\n                number -= 1\n\
    \            }\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp57asc6x.scala:34:47\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mlist\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = ListBuffer.empty[\e[35mLong\e[0m]\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpp57asc6x.scala:37:21 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                list += number.toLong\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpp57asc6x.scala:39:23 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp57asc6x.scala:42:21\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                list += number.toLong\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    value +=\
    \ is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpp57asc6x.scala:44:23 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                number -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -=\
    \ is not a member of Long - did you mean number.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010763
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000, \"Invalid number of carrots eating\")\n        require(need >= 0 &&\
    \ need <= 1000, \"Invalid need of carrots to eat\")\n        require(remaining\
    \ >= 0 && remaining <= 1000, \"Invalid remaining carrots left after meal\")\n\
    \        if(number <= need) {\n            List(number + remaining)\n        }\
    \ else {\n            val remaining = number - need\n            List(need + remaining)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1072syah.scala:42)\n\tat Problem.main(tmp1072syah.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000, \"invalid number\")\n        require(need >= 0 && need <= 1000, \"\
    invalid need\")\n        require(remaining >= 0 && remaining <= 1000, \"invalid\
    \ remaining\")\n        val remaining = number - need\n        if (remaining <\
    \ 1000) {\n            List[Long](number, need)\n        } else {\n          \
    \  val need1 = need / 2\n            val remaining = remaining - need + need1\n\
    \            if (remaining < 1000) {\n                eat(number / 2, need1, remaining)\n\
    \            } else {\n                List(number, need)\n            }\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx4ah7tn6.scala:39:28 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - need + need1\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e\
    [31m   |\e[0m                            Recursive \e[33mvalue\e[0m \e[35mremaining\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number\n   \
    \     val left = number - eaten\n        if (left == 0)\n            List(number\
    \ * need)\n        else {\n            val eatenNext = math.ceiling(number / need)\n\
    \            val needNext = math.floor(number / eatenNext)\n            if (needNext\
    \ > remaining)\n                List(number * need)\n            else\n      \
    \          eat(number - eatenNext, needNext, remaining)\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbvvpjaa_.scala:36:33 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36meatenNext\e[0m = math.ceiling(number\
    \ / need)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            value ceiling is not a member of math\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbvvpjaa_.scala:41:40 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                eat(number - eatenNext, needNext, remaining)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                        Found:    (needNext : Double)\n\
    \e[31m   |\e[0m                                        Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      require(number > 0 && number\
    \ <= 1000,\"Invalid number\")\n      require(need > 0 && need <= 1000,\"Invalid\
    \ need\")\n      require(remaining > 0 && remaining <= 1000,\"Invalid remaining\"\
    )\n      val meals : List[Long] = number - remaining\n      val remaining = remaining\
    \ - number\n      if (meals == 0) List(number)\n      else {\n        val carrots\
    \ = remaining.toLong\n        val meals = meals.toLong\n        var remaining\
    \ = 0\n        while (meals > 0) {\n          remaining += meals\n          meals\
    \ -= carrots\n        }\n        List(remaining,number)\n      }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg24a_cqf.scala:35:22 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m      \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - number\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m\
    \                      Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpg24a_cqf.scala:36:10 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m      \e[33mif\e[0m (meals == \e[31m0\e[0m) List(number)\n\
    \e[31m\e[31m   |\e[0m          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     Values of\
    \ types List[Long] and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpg24a_cqf.scala:39:20 ---------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = meals.toLong\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mmeals\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = (number - need)\
    \ > 0\n        val hungryOrEaten = if (hungry) needed + needed else number\n \
    \       val hungryRemaining = hungry ? remaining : 0\n        val eaten = if (hungry)\
    \ number - needed else needed\n        val leftover = if (hungry) remaining -\
    \ number else 0\n        val list = List(eaten.toLong, hungryOrEaten.toLong, hungryRemaining.toLong,\
    \ leftover.toLong)\n        list\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0dxl27r.scala:32:40 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryOrEaten\e[0m = \e\
    [33mif\e[0m (hungry) needed + needed \e[33melse\e[0m number\n\e[31m\e[31m   |\e\
    [0m                                        ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                  Not found: needed\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpf0dxl27r.scala:33:37 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = hungry\
    \ ? remaining : \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              value ? is not\
    \ a member of Boolean\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0dxl27r.scala:34:41\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36meaten\e[0m = \e[33mif\e[0m (hungry) number - needed \e[33melse\e[0m needed\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                         Not found: needed\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0dxl27r.scala:34:53 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36meaten\e[0m = \e[33mif\e\
    [0m (hungry) number - needed \e[33melse\e[0m needed\n\e[31m\e[31m   |\e[0m   \
    \                                                  ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                     Not found: needed\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val a = math.min(need, remaining)\n\
    \        val b = math.min(number, remaining).toLong\n        val list: List[Long]\
    \ = for (i <- 0 to math.max(0, a)) yield b\n        list.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvk89nzz6.scala:33:58\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlist\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mfor\e[0m (i <- \e[31m0\e[0m to math.max(\e\
    [31m0\e[0m, a)) \e[33myield\e[0m b\n\e[31m\e[31m   |\e[0m                    \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                                     Found:    (a : Long)\n\e[31m   |\e[0m  \
    \                                                  Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < 0)\n   \
    \         remaining = 0\n        val need2 = need + number\n        val remaining2\
    \ = remaining - number\n        val answer = need2.toLong.drop(need2).filter(_\
    \ > 0).toList ++ remaining2.toLong.filter(_ > 0).toList\n        return answer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqzqfatpi.scala:32:22 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            remaining = \e[31m0\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val remaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqzqfatpi.scala:35:34\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36manswer\e[0m = need2.toLong.drop(need2).filter(_ > \e[31m0\e[0m).toList ++\
    \ remaining2.toLong.filter(_ > \e[31m0\e[0m).toList\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  value drop is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = new mutable.ListBuffer[Long]()\n\
    \        var carrotLeft = number // Number of carrots we have left to eat\n  \
    \      while (carrotLeft > 0) {\n            carrotLeft -= 1\n            if (carrotLeft\
    \ >= need) {\n                hungry += (carrotLeft - need)\n                carrotLeft\
    \ = number\n            } else {\n                hungry += (carrotLeft)\n   \
    \         }\n        }\n        if (!hungry.isEmpty) hungry.reverse.toList\n \
    \       else List(remaining * 2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe4__3wx1.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots = number.toLong\n\
    \        var needs = need.toLong\n        val result = ListBuffer(needs)\n   \
    \     val hungerBeforeEaten = math.max(0, needs - carrots)\n        if (hungerBeforeEaten\
    \ > 0) {\n            if (remaining > hungerBeforeEaten) {\n                val\
    \ eatenCarrots = math.max(0, hungerBeforeEaten - carrots)\n                result.add(carrots\
    \ + eatenCarrots)\n                carrots += eatenCarrots\n                remaining\
    \ -= eatenCarrots\n            }\n            else {\n                val eatenCarrots\
    \ = math.max(0, remaining - hungerBeforeEaten)\n                result.add(carrots\
    \ + eatenCarrots)\n                carrots += eatenCarrots\n                remaining\
    \ -= eatenCarrots\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx19rts7l.scala:38:23 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                result.add(carrots + eatenCarrots)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value add\
    \ is not a member of scala.collection.mutable.ListBuffer[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx19rts7l.scala:40:26 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                remaining -= eatenCarrots\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -=\
    \ is not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpx19rts7l.scala:44:23 ------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                result.add(carrots + eatenCarrots)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is not\
    \ a member of scala.collection.mutable.ListBuffer[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.buffer\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.buffer\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.mutableSeq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.mutableSeq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx19rts7l.scala:46:26\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                remaining\
    \ -= eatenCarrots\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m           value -= is not a member of Long - did you mean remaining.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx19rt"
  stdout: ''
  timestamp: 1660010772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code here\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppil1x224.scala:30:73\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \e[33mdef\e[0m \e[36meat\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m, \e[36mneed\e[0m : \e[35mLong\e[0m, \e\
    [36mremaining\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \                Found:    Unit\n\e[31m   |\e[0m                             \
    \                       Required: List[Long]\n\e[31m31 |\e[0m        \e[34m//\
    \ Your code here\e[0m\n\e[31m32 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val nRemaining = number\
    \ - remaining\n        val nEaten = need - number\n        var result = List[Long](number.toLong,\
    \ 0)\n        var maxRemaining = number - remaining\n        if(nRemaining > 0)\
    \ result :+ eat(maxRemaining, need, remaining).toList.max\n        if(nEaten >\
    \ 0) result :+ eat(number, need, remaining).toList.max\n        if(!nEaten) result\
    \ :+ eat(number, need, remaining).toList.max\n        return result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphw_dn_9g.scala:37:11 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m(!nEaten) result :+ eat(number,\
    \ need, remaining).toList.max\n\e[31m\e[31m   |\e[0m           ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m    value unary_! is not a member of Long - did you mean nEaten.unary_+?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = List(0, number\
    \ - remaining)\n        var carrotNum = 0\n        while(list.lastOption.isEmpty\
    \ == false) {\n            list.lastOption match {\n                case Some(x)\
    \ => carrotNum = carrotNum + x\n                case None => return list\n   \
    \         }\n        }\n        var carrotLeft = 0\n        list.lastOption match\
    \ {\n            case Some(x) => carrotLeft = carrotLeft + x\n            case\
    \ None => return list\n        }\n        if(carrotLeft > need) {\n          \
    \  carrotLeft -= need\n            carrotLeft += remaining\n        }\n      \
    \  return list\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8mzdi4fl.scala:35:44\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mcase\e\
    [0m Some(x) => carrotNum = carrotNum + x\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                                 Found:    Long\n\e[31m   |\e[0m            \
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8mzdi4fl.scala:41:41 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mcase\e[0m Some(x) => carrotLeft = carrotLeft\
    \ + x\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    Long\n\e\
    [31m   |\e[0m                                         Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8mzdi4fl.scala:45:23 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            carrotLeft -= need\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a\
    \ member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8mzdi4fl.scala:46:23 ------------------------\e[0m\e[0m\n\e[31m46 |\e\
    [0m            carrotLeft += remaining\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010773
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Solution:\n        val\
    \ needToEat = if (need > remaining) remaining else need\n        val numberToEat\
    \ = if (number > remaining) remaining else number\n        val result: List[Long]\
    \ = List(needToEat.toLong, numberToEat.toLong)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0a2hsrpt.scala:38)\n\tat Problem.main(tmp0a2hsrpt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010773
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val totalCarryed = number\
    \ - remaining\n        val leftCarryed = remaining - need\n        if (leftCarryed\
    \ == 0) List[Long](totalCarryed) else List[Long](totalCarryed, leftCarryed)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphr7vxf8o.scala:36)\n\tat Problem.main(tmphr7vxf8o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010773
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number <= 1000 &&\
    \ need <= 1000 && remaining <= 1000, \"Invalid value\")\n        val nCarrots\
    \ = (number - need)\n        val needCarrots = if (remaining > 0) (need + 1) else\
    \ need\n        val leftCarrots = nCarrots - needCarrots\n        if (leftCarrots\
    \ == 0) List[Long](number.toLong, 0l.toLong) else eat(nCarrots, needCarrots, leftCarrots)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010776
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Write your code here\n\
    \        if (remaining == 0) {\n            return List(number.toLong, 0)\n  \
    \      } else if (number > remaining) {\n            return List(number.toLong,\
    \ remaining.toLong)\n        } else {\n            return List(number.toLong,\
    \ remaining.toLong - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphklb_i1_.scala:41)\n\tat Problem.main(tmphklb_i1_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrotEaten = number.toInt\n\
    \        val carrotNeed = need.toInt\n        val carrotRemaining = remaining.toInt\n\
    \        val numToEat = cmath.pow(10, carrotEaten - carrotNeed)\n        val numLeft\
    \ = cmath.pow(10, carrotRemaining - carrotNeed)\n        List(numToEat.toLong,\
    \ numLeft.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyh092q8s.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mnumToEat\e[0m = cmath.pow(\e\
    [31m10\e[0m, carrotEaten - carrotNeed)\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: cmath\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyh092q8s.scala:35:22\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mnumLeft\e[0m = cmath.pow(\e[31m10\e[0m, carrotRemaining - carrotNeed)\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \             Not found: cmath\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // code goes here\n    \
    \    val l1 = number - remaining\n        val l2 = remaining - need\n        if(number\
    \ < 0 || number > 1000){\n            return Nil\n        }\n        if(need <\
    \ 0 || need > 1000){\n            return Nil\n        }\n        if(remaining\
    \ < 0 || remaining > 1000){\n            return Nil\n        }\n        if(l1\
    \ != 0 && l2 != 0){\n            val l = l1 + l2\n            val l3 = l / 2\n\
    \            val l4 = l - l3\n            val n = (l1 * l2) + (l3 * l4)\n    \
    \        val n1 = n\n            val n2 = n - l1\n            val n3 = n - l2\n\
    \            val n4 = n - l3\n            val x = n1 + n2 + n3 + n4\n        \
    \    val y = l1 * l2 * l3 * l4\n            val z = n1 + n2 * n3 * n4\n      \
    \      val list = if(x >= y) return List(x) else if(x < y) return List(y) else\
    \ List(x-y)\n            val z1 = z\n            val z2 = z - l1\n           \
    \ val z3 = z - l2\n            val z4 = z - l3\n            val a = (n * n) -\
    \ (z * z4)\n            val b = (n * n) + (z1 * z4)\n            val c = (n1 *\
    \ n2) - (z2 * z4)\n            val d = (n1 * n2) + (z1 * z4)\n            val\
    \ e = c - (z1 * z2)\n            val f = b - (z2 * z3)\n            val g = a\
    \ - (z1 * z3)\n            val h = (a * b) - (x * x)\n            val i = (h *\
    \ h) - (z * z)\n            val j = (d * d) - (z1 * z2)\n            val k = (k\
    \ * k) - (z3 * z3)\n            val l = (j * j) - (z2 * z4)\n            val m\
    \ = (l * l) - (z * z1)\n            val n = (m * m) - (z4 * z4)\n            val\
    \ x = (i * i) - (x * x)\n            val y = (k * k) - (y * y)\n            val\
    \ z = (l * l) - (y * y)\n            val a1 = (e * e) + (z * z)\n            val\
    \ a2 = (a1 * a1) - (x * x)\n            val a3 = (a2 * a2) - (y * y)\n       \
    \     val a4 = (a3 * a3) - (z * z)\n            val a5 = (a4 * a4) - (x * x)\n\
    \            val a6 = (a5 * a5) - (y * y)\n            val a7 = (a6 * a6) - (z\
    \ * z)\n            val a8 = (a7 * \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprms3zcjt.scala:84:26 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m            \e[33mval\e[0m \e[36ma8\e[0m = (a7 * \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmprms3zcjt.scala:96:0 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprms3zcjt.scala:71:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m71 |\e[0m            \e[33mval\e\
    [0m \e[36ml\e[0m = (j * j) - (z2 * z4)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprms3zcjt.scala:73:16 ---------------------------\e[0m\e[0m\n\e[31m73\
    \ |\e[0m            \e[33mval\e[0m \e[36mn\e[0m = (m * m) - (z4 * z4)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is\
    \ already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprms3zcjt.scala:74:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m74 |\e[0m            \e[33mval\e\
    [0m \e[36mx\e[0m = (i * i) - (x * x)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mx is already defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprms3zcjt.scala:75:16 ---------------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m            \e[33mval\e[0m \e[36my\e[0m = (k * k) - (y * y)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0my is already\
    \ def"
  stdout: ''
  timestamp: 1660010776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      // Your code here\n      val\
    \ meals: mutable.Buffer[Long] = mutable.Buffer.empty[Long]\n      if (remaining\
    \ >= need) {\n        remaining -= need\n        meals += number\n      }\n  \
    \    if (remaining <= 0) {\n        remaining += need\n        meals += remaining\n\
    \      }\n      meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps0otx9x8.scala:32:17 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36mmeals\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m\
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps0otx9x8.scala:32:40\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m      \e[33mval\e[0m \e[36mmeals\e\
    [0m: mutable.Buffer[\e[35mLong\e[0m] = mutable.Buffer.empty[\e[35mLong\e[0m]\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                        Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0otx9x8.scala:34:18 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        remaining -= need\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value -= is not a member of Long\
    \ - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0otx9x8.scala:38:18\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        remaining += need\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value +=\
    \ is not a member of Long - did you mean remaining.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000)\n        require(need >= 0 && need <= 1000)\n        require(remaining\
    \ >= 0 && remaining <= 1000)\n        // Code here\n        val carrotLeft = number\
    \ - need\n        val carrotEaten = number - remaining\n        val list: List[Long]\
    \ = List(carrotEaten.toLong, carrotLeft.toLong)\n        list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa50s19p4.scala:41)\n\tat Problem.main(tmpa50s19p4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code here\n    \
    \    if (number < 0 || number > 1000 || need < 0 || need > 1000 || remaining <\
    \ 0 || remaining > 1000) {\n            throw new ArithmeticException(\"Invalid\
    \ input.\")\n        }\n        val list = mutable.ListBuffer(number)\n      \
    \  while (remaining > 0) {\n            if (number <= 0) {\n                break\n\
    \            }\n            remaining -= 1\n            list += number\n     \
    \       number -= 1\n        }\n        val rem = number - list.length\n     \
    \   if (rem > need) {\n            list += list.drop(list.length - need)\n   \
    \     } else if (rem > 0 && rem <= need) {\n            list += list.take(rem)\n\
    \        }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixdmjaeg.scala:35:19 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpixdmjaeg.scala:38:16 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m                break\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpixdmjaeg.scala:40:22 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            remaining -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is\
    \ not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpixdmjaeg.scala:42:19 ------------------------\e[0m\e[0m\n\
    \e[31m42 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of\
    \ Long - did you mean number.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number == 0) {\n   \
    \         List(0l, remaining)\n        } else if (number < need) {\n         \
    \   List(number, remaining+need)\n        } else {\n            val total = math.max(number,need)\n\
    \            val left = math.min(number-total, need)\n            List(total,\
    \ left)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaa5mlvh2.scala:42)\n\tat Problem.main(tmpaa5mlvh2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining <= 0l) {\n\
    \            return List.empty[Long]\n        }\n        val hungry = number -\
    \ remaining\n        if (need <= 0l) {\n            return List(1l)\n        }\n\
    \        val needed = need - remaining\n        val count = hungry + needed\n\
    \        val total = number - count\n        return List((total).toLong, count)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph31fumpi.scala:44)\n\tat Problem.main(tmph31fumpi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = remaining -\
    \ need\n        if (eaten <= 0) List.empty\n        else{\n        val carrots\
    \ = mutable.ListBuffer(number)\n        while(eaten > 0) {\n            carrots\
    \ += number.toLong\n            eaten = eaten - 1\n        }\n        (carrots.reverse,\
    \ eaten.toLong)}\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmgc_9d7d.scala:34:22 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpmgc_9d7d.scala:37:18 -----------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            eaten = eaten - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val eaten\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmgc_9d7d.scala:39:8\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m        (carrots.reverse, eaten.toLong)}\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (Nothing, Long)\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining == 0) {\n\
    \            List(number.toLong)\n        }\n        else {\n            var newNeed\
    \ = 0\n            var newRemaining = remaining\n            var newNumber = number\n\
    \            while (newRemaining > 0 && newNeed < need) {\n                newNeed\
    \ += newNumber\n                newRemaining -= newNumber\n                newNumber\
    \ += 1\n            }\n            if (newRemaining == 0) {\n                List(newNumber.toLong)\n\
    \            }\n            else {\n                eat(newNumber, newNeed, newRemaining)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj5qf74v6.scala:39:24 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                newNeed += newNumber\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten : List[Long] =\
    \ List(number.toLong)\n        while (eaten.length != 0) {\n            val remaining\
    \ = remaining.toLong - eaten(0)\n            if (remaining > 0) {\n          \
    \      eat = eaten\n            }\n            else {\n                eaten =\
    \ eaten :+ remaining\n                remaining = 0\n            }\n        }\n\
    \        number :: eaten\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7vf05k3u.scala:33:28 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toLong\
    \ - eaten(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                            ^\e\
    [0m\n\e[31m   |\e[0m                            Recursive \e[33mvalue\e[0m \e\
    [35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7vf05k3u.scala:35:22 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                eat = eaten\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                      Found:    (eaten : List[Long])\n\
    \e[31m   |\e[0m                      Required: (Long, Long, Long) => List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp7vf05k3u.scala:39:26 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                remaining = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val remaining\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - need\n\
    \        if(eaten < 0)\n            List[Long](eaten.toLong)\n        else {\n\
    \            if(eat == 0 && need.toLong > 0L)\n                List[Long](0L)\n\
    \            else {\n                if(eat == 0 && need.toLong == 0)\n      \
    \              List[Long](eaten.toLong)\n                else {\n            \
    \        if(eat == 0 && need.toLong < 0L)\n                        List[Long](-1l)\n\
    \                    else {\n                        if(eat >= remaining) {\n\
    \                            List[Long](need.toLong, eaten.toLong)\n         \
    \               } else {\n                            val leftToEat = remaining.toLong\
    \ - eat\n                            List[Long](need.toLong, eaten.toLong, leftToEat)\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpetznk29i.scala:35:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m(eat == \e[31m0\e[0m && need.toLong\
    \ > \e[31m0L\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mValues of types (Long, Long, Long) => List[Long] and Int cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpetznk29i.scala:38:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mif\e[0m(eat == \e[31m0\e[0m &&\
    \ need.toLong == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types (Long, Long, Long) => List[Long] and Int cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpetznk29i.scala:41:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m41 |\e[0m       \
    \             \e[33mif\e[0m(eat == \e[31m0\e[0m && need.toLong < \e[31m0L\e[0m)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mValues\
    \ of types (Long, Long, Long) => List[Long] and Int cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpetznk29i.scala:44:31 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                        \e[33mif\e[0m(eat >= remaining)\
    \ {\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue >= is not a member of (Long, Long, Long) => List[Long], but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpetznk29i.scala:47:61 -----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                            \e[33mval\e[0m \e[36mleftToEat\e\
    [0m = remaining.toLong - eat\n\e[31m\e[31m   |\e[0m                          \
    \                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Doub"
  stdout: ''
  timestamp: 1660010790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val res = if (remaining\
    \ > 0) number :: eat(number, need - number, remaining - number) :: Nil else number\
    \ :: Nil\n        val maxValue = res.max\n        if (maxValue == 0) 0l :: 0l\
    \ :: Nil else 0l :: maxValue :: res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7ccp_0bg.scala:32:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxValue\e[0m = res.max\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0mNo implicit\
    \ Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type\
    \ variable with constraint >: Matchable\n\e[31m   |\e[0m..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mB\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[B]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[B].\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7ccp_0bg.scala:33:48 --------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mif\e[0m (maxValue == \e[31m0\e[0m) \e[31m0l\e[0m :: \e[31m0l\e\
    [0m :: Nil \e[33melse\e[0m \e[31m0l\e[0m :: maxValue :: res\n\e[31m\e[31m   |\e\
    [0m                                                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                               Found:    List[Matchable]\n\
    \e[31m   |\e[0m                                               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots : List[Long]\
    \ = List()\n        val result = carrots.foldRight(List(number)) {\n         \
    \   case (acc, elem) => {\n                if(elem < 0){\n                   \
    \ acc :+ 0\n                }else if(elem > remaining){\n                    acc\
    \ :+ (remaining - elem)\n                }else{\n                    acc :+ (remaining\
    \ - elem)\n                }\n            }\n        }\n        \n        // print\
    \ result\n        println(s\"total eaten: ${result.head}, left carrots: ${result.tail}\"\
    )\n        result.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpniobl92v.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e[0m(elem < \e[31m0\e[0m){\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpniobl92v.scala:35:24 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    acc :+ \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \ value :+ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpniobl92v.scala:36:30\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                }\e[33melse\e\
    [0m \e[33mif\e[0m(elem > remaining){\n\e[31m\e[31m   |\e[0m                  \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpniobl92v.scala:37:24 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    acc :+ (remaining - elem)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    value :+ is not a member of Long\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpniobl92v.scala:37:38\
    \ -----------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                   \
    \ acc :+ (remaining - elem)\n\e[31m\e[31m   |\e[0m                           \
    \ ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): D"
  stdout: ''
  timestamp: 1660010790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        // TODO\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3prlpr_4.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3prlpr_4.scala:33:5 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // write your code here\n\
    \        var result : List[Long] = List[Long]()\n        while (remaining != 0)\
    \ {\n            if (remaining <= need) {\n                result :+ number\n\
    \                remaining :- need\n            }\n            else {\n      \
    \          result :+ number\n                remaining :- remaining\n        \
    \    }\n        }\n        result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_1n7h2c1.scala:36:26 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                remaining :- need\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value :-\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_1n7h2c1.scala:40:26\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                remaining\
    \ :- remaining\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value :- is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // write your code in here\n\
    \        val newNumber = number - need + remaining\n        val newNeed = need\
    \ - number \n        val newRemaining = remaining.toLong - number\n\n        if\
    \ (newNumber < 0 ) \n        {\n            newNumber = newNumber.toLong\n   \
    \         newNeed = newNeed.toLong\n            newRemaining = newRemaining.toLong\n\
    \        }\n        else if (newNumber == 0 ) {\n            newNeed = newNeed.toLong\n\
    \            newRemaining = newRemaining.toLong\n        }\n        else if(newNeed\
    \ < 0 ) {\n            newNeed = newNeed.toLong\n            newRemaining = newRemaining.toLong\n\
    \        }\n        else if (newNeed == 0 ) {\n            newRemaining = newRemaining.toLong\n\
    \        }\n\n        val newEaten = scala.math.pow(newRemaining, 2).toLong.toLong\n\
    \        val newHungry = newNeed - newEaten\n        val newRemaining = newRemaining.toLong\
    \ - newEaten\n\n        if (newEaten < 0 ) {\n            newEaten = newEaten.toLong\n\
    \            newHungry = newHungry.toLong\n            newRemaining = newRemaining.toLong\n\
    \        }\n        else if (newEaten == 0) {\n            newHungry = newHungry.toLong\n\
    \        }\n        else if(newHungry < 0 ) {\n            newHungry = newHungry.toLong\n\
    \        }\n\n        List(newEaten.toLong, newHungry.toLong)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6tdwyss2.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mnewRemaining\e[0m = newRemaining.toLong\
    \ - newEaten\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewRemaining is already defined as \e[33mvalue\e[0m \e[35mnewRemaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmp6tdwyss2.scala:38:22 -----------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m            newNumber = newNumber.toLong\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val newNumber\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6tdwyss2.scala:39:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            newNeed\
    \ = newNeed.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val newNeed\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp6tdwyss2.scala:40:25 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            newRemaining = newRemaining.toLong\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val newRemaining\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp6tdwyss2.scala:43:20 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            newNeed = newNeed.toLong\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Reassignment to val newNeed\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp6tdwyss2.scala:44:25 -----------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m            newRemaining = newRema"
  stdout: ''
  timestamp: 1660010784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var i = 0\n        var j\
    \ = 0\n        val result = mutable.ListBuffer.empty[Long]\n        while(i <\
    \ remaining && j < (number - need)) {\n            result += List(number)\n  \
    \          i += number\n            j += number\n        }\n        if(j > 0)\
    \ {\n            result += List(j)\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0r8altt8.scala:33:21 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0r8altt8.scala:36:14 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            i += number\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0r8altt8.scala:37:14\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            j += number\n\
    \e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010792
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      // TODO: your solution here\n\
    \      if(need > remaining)\n        List(number - need)\n      else\n       \
    \ List(number - need, need)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2zpvuh9u.scala:38)\n\tat Problem.main(tmp2zpvuh9u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val result = new ListBuffer[Long]()\n\
    \        if (remaining <= 0l) {\n            // Your daily routine is complete\n\
    \            // Print your daily routine complete message to the console\n   \
    \         result += (number.toLong)\n            result += (need.toLong)\n   \
    \         result += (need.toLong)\n        } else {\n            // You have enough\
    \ carrots to complete your routine.\n            // Get your daily routine completed\
    \ message to the console\n            result += (number.toLong)\n            result\
    \ += (need.toLong)\n            result += (number.toLong)\n        }\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplfr_09rl.scala:45:8\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : scala.collection.mutable.ListBuffer[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Solve this puzzle by\
    \ recursion!\n        // The recursion will take care of the problem of eating\
    \ carrots,\n        // by calling itself recursively, once the carrots eat themselves,\
    \ you eat the rest.\n        // The base case of this recursion is when remaining\
    \ is 0, you reach a base case,\n        // and the solution is a list of integers,\
    \ where each integer is the total number of carrots you just eaten.\n        //\
    \ The last base case of this recursion is when remaining is less than 0, you reach\
    \ a base case,\n        // and the solution is a list of integers, where each\
    \ integer is the total number of carrots you need in order to eat all the carrots\
    \ left in the store.\n        // The recursive case is when remaining is more\
    \ than 0, you eat the needed carrots,\n        // and then call this recursion\
    \ with remaining minus those carrots.\n        // Since you eat the needed carrots\
    \ in each recursion, they should always eat the rest carrots in the recursion,\n\
    \        // unless you eat the needed carrots less than the number of carrots\
    \ left in the store.\n        // Since your recursive function calls itself, you\
    \ need not to care about the first recursive call.\n\n        // Your implementation\
    \ here\n        // ...\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5jdm93hf.scala:30:73\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \e[33mdef\e[0m \e[36meat\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m, \e[36mneed\e[0m : \e[35mLong\e[0m, \e\
    [36mremaining\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \                Found:    Unit\n\e[31m   |\e[0m                             \
    \                       Required: List[Long]\n\e[31m31 |\e[0m        \e[34m//\
    \ Solve this puzzle by recursion!\e[0m\n\e[31m32 |\e[0m        \e[34m// The recursion\
    \ will take care of the problem of eating carrots,\e[0m\n\e[31m33 |\e[0m     \
    \   \e[34m// by calling itself recursively, once the carrots eat themselves, you\
    \ eat the rest.\e[0m\n\e[31m34 |\e[0m        \e[34m// The base case of this recursion\
    \ is when remaining is 0, you reach a base case,\e[0m\n\e[31m35 |\e[0m       \
    \ \e[34m// and the solution is a list of integers, where each integer is the total\
    \ number of carrots you just eaten.\e[0m\n\e[31m36 |\e[0m        \e[34m// The\
    \ last base case of this recursion is when remaining is less than 0, you reach\
    \ a base case,\e[0m\n\e[31m37 |\e[0m        \e[34m// and the solution is a list\
    \ of integers, where each integer is the total number of carrots you need in order\
    \ to eat all the carrots left in the store.\e[0m\n\e[31m38 |\e[0m        \e[34m//\
    \ The recursive case is when remaining is more than 0, you eat the needed carrots,\e\
    [0m\n\e[31m39 |\e[0m        \e[34m// and then call this recursion with remaining\
    \ minus those carrots.\e[0m\n\e[31m40 |\e[0m        \e[34m// Since you eat the\
    \ needed carrots in each recursion, they should always eat the rest carrots in\
    \ the recursion,\e[0m\n\e[31m41 |\e[0m        \e[34m// unless you eat the needed\
    \ carrots less than the number of carrots left in the store.\e[0m\n\e[31m42 |\e\
    [0m        \e[34m// Since your recursive function calls itself, you need not to\
    \ care about the first recursive call.\e[0m\n\e[31m43 |\e[0m        \e[34m// Your\
    \ implementation here\e[0m\n\e[31m44 |\e"
  stdout: ''
  timestamp: 1660010794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ - need\n        if (remaining <= 0) {\n            List(number.toLong, remaining.toLong)\n\
    \        }\n        else {\n            List(number.toLong, remaining.toLong)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm8_xnj0r.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - need\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number > 1000)\n   \
    \         throw new RuntimeException(\"invalid input\")\n        else if (need\
    \ > 1000)\n            throw new RuntimeException(\"invalid input\")\n       \
    \ else if (remaining > 1000)\n            throw new RuntimeException(\"invalid\
    \ input\")\n        else if (number > remaining)\n            throw new RuntimeException(\"\
    invalid input\")\n        else if (need > remaining)\n            throw new RuntimeException(\"\
    invalid input\")\n        else (for (i <- 1 to remaining) yield number).tail.takeWhile(_\
    \ <= remaining).map(x => (number - x).toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9uzl4_1j.scala:41:29\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33melse\e[0m (\e[33mfor\e\
    [0m (i <- \e[31m1\e[0m to remaining) \e[33myield\e[0m number).tail.takeWhile(_\
    \ <= remaining).map(x => (number - x).toLong)\n\e[31m\e[31m   |\e[0m         \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \    Found:    (remaining : Long)\n\e[31m   |\e[0m                           \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010795
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      if (remaining <= 0) List(number,\
    \ need)\n      else {\n        val carrots = number - remaining\n        val leftCarrots\
    \ = remaining - need\n        List(number, leftCarrots, carrots)\n      }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyrta2v8n.scala:39)\n\tat Problem.main(tmpyrta2v8n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val totalCarrots = number\n\
    \        var eatenCarrots = number\n        var hungryCarrots = remaining\n  \
    \      // write your code here\n        while (eatenCarrots < need && hungryCarrots\
    \ > 0) {\n            if (totalCarrots - eatenCarrots > hungryCarrots) {\n   \
    \             eatenCarrots = eatenCarrots + hungryCarrots\n                hungryCarrots\
    \ = hungryCarrots - totalCarrots - eatenCarrots\n                totalCarrots\
    \ = totalCarrots - eatenCarrots\n            } else {\n                eatenCarrots\
    \ = eatenCarrots + hungryCarrots\n                hungryCarrots = hungryCarrots\
    \ - totalCarrots - eatenCarrots\n                totalCarrots = totalCarrots -\
    \ eatenCarrots\n            }\n        }\n        if (eatenCarrots < need) {\n\
    \            val hungryCarrotsList = List(hungryCarrots)\n            hungryCarrotsList\n\
    \        } else {\n            List(totalCarrots)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzqgz8hwg.scala:39:29 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                totalCarrots = totalCarrots - eatenCarrots\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val totalCarrots\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpzqgz8hwg.scala:43:29 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                totalCarrots = totalCarrots - eatenCarrots\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val totalCarrots\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining > 0)\n   \
    \         List(eatWith(number, need, remaining - need))\n        else\n      \
    \      List(eatWith(number, need, remaining))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa54mdqtj.scala:32:17 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            List(eatWith(number, need, remaining - need))\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \       Not found: eatWith\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpa54mdqtj.scala:34:17 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m            List(eatWith(number, need, remaining))\n\e[31m\e[31m   |\e[0m \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: eatWith\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010791
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val notHungry = remaining\
    \ - need\n        val notHungryList = List(notHungry.toLong)\n        if(hungry\
    \ < 0)\n            notHungryList ++ hungryList\n        else\n            hungryList\
    \ ++ notHungryList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ex378mt.scala:41)\n\tat Problem.main(tmp7ex378mt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        if(remaining <= need){\n            list.add(number)\n        }\n   \
    \     else{\n            list.add(number)\n            val result = eat(number-1,\
    \ need, remaining-number)\n            list ++= result\n        }\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ga8lb5e.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots = number.toLong\n\
    \        // Write your solution here\n        var newNumber = number.toLong\n\
    \        var newNeed= need.toLong\n        var newRemaining = remaining.toLong\n\
    \        if (newRemaining < newNeed) {\n            carrots = newRemaining\n \
    \           newNumber = newNeed\n            newNeed = 0\n            newRemaining\
    \ = newNumber - newNeed\n        }\n        var newCarrots = newNumber.toLong\n\
    \        var newEaten = 0\n        var newLeft = 0\n        while (newCarrots\
    \ > 0l) {\n            newEaten += 1\n            newCarrots = newCarrots - 1\n\
    \            if (newCarrots <= need.toLong) {\n                newLeft = newCarrots\
    \ - newEaten\n                newCarrots = newEaten\n                newEaten\
    \ = 0\n            } else {\n                newLeft += newCarrots - newEaten\n\
    \                newCarrots = newCarrots - newEaten\n                newEaten\
    \ = 0\n            }\n        }\n        val a = newLeft\n        val b = newEaten\n\
    \        List[Long](a.toLong,b.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq6xaa4c1.scala:49:26\
    \ --------------------\e[0m\e[0m\n\e[31m49 |\e[0m                newLeft = newCarrots\
    \ - newEaten\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpq6xaa4c1.scala:53:24 ------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m                newLeft += newCarrots - newEaten\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numberToEat = math.min(number,\
    \ math.min(remaining, need))\n        numberToEat match {\n            case 0\
    \ => List.empty\n            case 1 => List(numberToEat)\n            case _ =>\
    \ List(numberToEat, remaining - numberToEat)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpngqqgice.scala:39)\n\tat Problem.main(tmpngqqgice.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000, \n            \"Carrots number must be between 0 and 1000\")\n    \
    \    require(need >= 0 && need <= 1000, \n            \"Carrots number must be\
    \ between 0 and 1000\")\n        require(remaining >= 0 && remaining <= 1000,\n\
    \            \"Carrots number must be between 0 and 1000\")\n        val numEaten\
    \ = number.toInt\n        val numNeed = need.toInt\n        val numRemaining =\
    \ remaining.toInt\n        require(numEaten >= 0 && numEaten <= 1000, \"Carrots\
    \ number must be between 0 and 1000\")\n        require(numNeed >= 0 && numNeed\
    \ <= 1000, \"Carrots number must be between 0 and 1000\")\n        require(numRemaining\
    \ >= 0 && numRemaining <= 1000, \"Carrots number must be between 0 and 1000\"\
    )\n        val currentCarrotNum = numEaten\n        val nextCarrotNum = numRemaining\n\
    \        val remainingCarrots = numRemaining\n        val numCarrots = numEaten\
    \ + numNeed\n        val currentNeed = (numNeed - remainingCarrots).toLong\n \
    \       val nextNeed = (remaining - remainingCarrots).toLong\n        val nextRemaining\
    \ = (remaining - numRemaining).toLong\n        val totalNeed = (numNeed * need.toLong).toLong\n\
    \        val totalEaten = (numEaten * need.toLong).toLong\n        val totalRemaining\
    \ = (remaining * need.toLong).toLong\n        val totalCarrots = (numCarrots *\
    \ need.toLong).toLong\n        val carrotList: List[Long] = new mutable.ListBuffer[Long]()\n\
    \        while (currentCarrotNum > 0 && nextCarrotNum > 0) {\n            if (currentNeed\
    \ > 0) {\n                carrotList += nextNeed.toLong\n                currentNeed\
    \ -= 1\n            }\n            if (nextRemaining > 0) {\n                carrotList\
    \ += nextRemaining.toLong\n                nextRemaining -= 1\n            }\n\
    \            currentCarrotNum -= 1\n            nextCarrotNum -= 1\n        }\n\
    \        (carrotList + totalNeed.toLong + totalEaten.toLong + totalRemaining.toLong).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppqz0_cma.scala:54:41 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mcarrotList\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                         Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppqz0_cma.scala:57:27 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                carrotList += nextNeed.toLong\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean carrotList.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppqz0_cma.scala:58:28 ------------------------\e[0m\e\
    [0m\n\e[31m58 |\e[0m                currentNeed -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value -=\
    \ is not a member of Long - did you mean currentNeed.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppqz0_cma.scala:61:27 ------------------------\e[0m\e\
    [0m\n\e[31m61 |\e[0m                carrotList += nextRemaining.toLong\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean carrotList.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppqz0_cma.scala:62:30 ------------------------\e[0m\e\
    [0m\n\e[31m62 |\e[0m                nextRemaining -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value -=\
    \ is not a member of Long - did you mean nextRemaining.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppqz0_cma.scala:64:29 ------------------------\e[0m\e\
    [0m\n\e[31m64 |\e[0m            currentCarrotNum -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value -= is\
    \ not a member of Int - did you mean currentCarrotNum.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppqz0_cma.scala:65:26 ------------------------\e[0m\e\
    [0m\n\e"
  stdout: ''
  timestamp: 1660010809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val meals = new mutable.ListBuffer[Long]()\n\
    \        while(number > 0)\n        number match {\n            case 0 => meals\
    \ += 0\n            case _ => meals += need\n        }\n        meals match {\n\
    \            case 0 => (remaining > 0) match {\n                case true => (List(number.toLong,\
    \ remaining.toLong))\n                case false => List(0l.toLong, 0l.toLong)\n\
    \            }\n            case _ => if(number > remaining) {\n             \
    \   number match {\n                    case 0 => meals += 0\n               \
    \     case _ => meals += need\n                }\n                (List(number.toLong,\
    \ 0l.toLong))\n            } else {\n                (List(number.toLong, need.toLong))\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpch5unjkv.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Add your code here\n\
    \        val totalCarrots = number - need\n        val numCarrots = math.min(totalCarrots,\
    \ remaining)\n        val newRemainingCarrots = total - numCarrots\n        List(totalCarrots,\
    \ numCarrots)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9w4fxi3p.scala:34:34 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mnewRemainingCarrots\e[0m\
    \ = total - numCarrots\n\e[31m\e[31m   |\e[0m                                \
    \  ^^^^^\e[0m\n\e[31m   |\e[0m                                  Not found: total\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val answer = mutable.ListBuffer.empty[Long]\n\
    \        val canEat = number.toDouble / need.toDouble * 100d\n        var carrots\
    \ = number.toDouble % need.toDouble\n        remaining > 0 match {\n         \
    \   case true => {\n                val remain = remaining.toDouble * 100d\n \
    \               for(i <- 0 until canEat){\n                    if(remaining >\
    \ 0){\n                        val r = math.round(carrots.toDouble / remain.toDouble)\n\
    \                        if(remaining <= r){\n                            carrots\
    \ = r\n                        }else{\n                            carrots = carrots\
    \ - r * remain\n                        }\n                    }else{\n      \
    \                  carrots = remain\n                    }\n                 \
    \   answer += carrots.toLong\n                    remaining -= 1\n           \
    \     }\n            }\n            case false => {\n                for(i <-\
    \ 0 until canEat){\n                    carrots = math.round(carrots.toDouble\
    \ / need.toDouble)\n                    answer += carrots.toLong\n           \
    \         remaining -= 1\n                }\n            }\n        }\n      \
    \  answer.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxlxsfnvi.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36manswer\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxlxsfnvi.scala:37:33 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                \e[33mfor\e[0m(i <- \e[31m0\e[0m until\
    \ canEat){\n\e[31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Found:    (canEat : Double)\n\e\
    [31m   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxlxsfnvi.scala:49:30 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                    remaining -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \ value -= is not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxlxsfnvi.scala:53:33 --------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                \e[33mfor\e[0m(i <- \e[31m0\e[0m until\
    \ canEat){\n\e[31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Found:    (canEat : Double)\n\e\
    [31m   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxlxsfnvi.scala:56:30 ------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m                    remaining -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \ value -= is not a member of Long - did you mean remaining.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010807
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result : List[Long]\
    \ = Nil\n        val totalRemaining : Long = number - remaining\n        if (totalRemaining\
    \ >= need) {\n            result += List(remaining, totalRemaining).toLong\n \
    \           result += List(totalRemaining, need - totalRemaining).toLong\n   \
    \     }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnrrz6z8y.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            result += List(remaining, totalRemaining).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnrrz6z8y.scala:34:54 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            result += List(remaining, totalRemaining).toLong\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnrrz6z8y.scala:35:19 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            result += List(totalRemaining, need - totalRemaining).toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnrrz6z8y.scala:35:66 ------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m            result += List(totalRemaining, need - totalRemaining).toLong\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number <= 1000)\n\
    \        require(need <= 1000)\n        require(remaining <= 1000)\n        val\
    \ maxNum = number + remaining\n        val maxNeed = need + remaining\n      \
    \  val maxRemaining = remaining + remaining\n        require(maxNum > 0 && maxNeed\
    \ > 0 && maxRemaining > 0)\n        List(maxNum.toLong, maxNeed.toLong, maxRemaining.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp943ls06i.scala:41)\n\tat Problem.main(tmp943ls06i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining > need) List(number.toLong)\n\
    \        else if (remaining < need) List(remaining.toLong, need)\n        else\
    \ {\n            val (hungry, rest) = eat(number, remaining - need, 1000)\n  \
    \          hungry.filter(_ > 0).foldLeft(List.empty[Long]){\n                case\
    \ (acc, x) =>\n                    if (acc > 0) acc + x.toLong\n             \
    \       else List(x) // add the hungry carrots to the list\n            }\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0relv68l.scala:35:19 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            hungry.filter(_ > \e[31m0\e[0m).foldLeft(List.empty[\e\
    [35mLong\e[0m]){\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value filter is not a member of Any\n1 error found\n"
  stdout: ''
  timestamp: 1660010809
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ - remaining)\n        else List(number - need, remaining - need)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7yzzwobi.scala:35)\n\tat Problem.main(tmp7yzzwobi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var remainingCarrots = remaining\n\
    \        var currentEaten = number\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        while (remainingCarrots > 0 && currentEaten > 0) {\n            currentEaten\
    \ -= 1\n            remainingCarrots -= 1\n            result.add(currentEaten)\n\
    \        }\n        if (remainingCarrots == 0) {\n            result.addAll(eat(remaining,\
    \ need, remaining))\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe8u5t8h7.scala:33:21 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(number <= 0 || need <=\
    \ 0 || remaining <= 0) {\n          throw new Exception(\"Invalid argument\")\n\
    \        }\n        val eaten = number\n        val leftover = number - eaten\n\
    \        if(leftover >= need) {\n          return List(number.toLong, remaining.toLong)\n\
    \        }\n        else {\n          return List(number.toLong, need - remaining.toLong)\n\
    \        }\n      }\n    // Print out your happiness and your level\n    // Variables:\n\
    \    // @happiness : integer\n    // the number of happinesses you have.\n   \
    \ // @level : integer\n    // the number of levels you have.\n    // Constrains:\n\
    \    // * 0 <= happiness <= 1000\n    // * 0 <= level <= 1000\n    def printHappiness(happiness:\
    \ Long, level: Long) {\n      val maxHappiness = happiness.toLong\n      val maxLevel\
    \ = level.toLong\n      if(maxHappiness < 0) {\n        throw new Exception(\"\
    Invalid argument\")\n      }\n      if(maxLevel < 0) {\n        throw new Exception(\"\
    Invalid argument\")\n      }\n      if(maxHappiness > maxLevel) {\n        throw\
    \ new Exception(\"Invalid argument\")\n      }\n      if(maxLevel == 0 || maxHappiness\
    \ == 0) {\n        throw new Exception(\"Invalid argument\")\n      }\n      println(s\"\
    Your happiness is ${happiness.toLong} out of ${maxHappiness.toLong} happinesses.\"\
    )\n      println(s\"Your level is ${level.toLong} out of ${maxLevel.toLong} levels.\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9dqfpcof.scala:52:53 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    \e[33mdef\e[0m \e[36mprintHappiness\e[0m(\e[36mhappiness\e\
    [0m: \e[35mLong\e[0m, \e[36mlevel\e[0m: \e[35mLong\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                             '=' expected, but '{' found\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ArrayBuffer.empty[Long]\n\
    \        val meals = number / need + 1\n        var carrots = 0\n        var i\
    \ = need\n        while (carrots < meals && (carrots + remaining) > 0) {\n   \
    \         carrots += i\n            i = i / 2\n        }\n        carrots += remaining\n\
    \        number -= carrots\n        list += carrots\n        list.map{x =>\n \
    \           val i = x / meals\n            val m = x - i * meals\n           \
    \ if (i % 2 == 0)\n                m + i\n            else\n                m\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpatty0t0k.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpatty0t0k.scala:36:20 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            carrots += i\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpatty0t0k.scala:39:16\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        carrots += remaining\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value +=\
    \ is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpatty0t0k.scala:40:15 ------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        number -= carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value -= is not a member of Long - did you mean number.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = ListBuffer.empty[Long]\n\
    \        var hungry = 0\n        var meals = 0\n        var num = 0\n        while(num\
    \ < number) {\n            carrots ++= num\n            hungry += num\n      \
    \      meals += num\n            num += 1\n        }\n        if(carrots.length\
    \ == need && hungry > remaining && meals > 0) {\n            List(hungry, remaining).reverse\n\
    \        }\n        else {\n            carrots ++= num\n            hungry +=\
    \ num\n            meals += num\n            while(meals < need) {\n         \
    \       hungry += num\n                meals += num\n            }\n         \
    \   if(hungry > remaining && meals > 0) {\n                List(hungry, remaining).reverse\n\
    \            }\n            else {\n                List(hungry, remaining).toList\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4utron2x.scala:36:24\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            carrots ++= num\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m       \
    \                 Found:    (num : Int)\n\e[31m   |\e[0m                     \
    \   Required: IterableOnce[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4utron2x.scala:42:36 --------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            List(hungry, remaining).reverse\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m            Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4utron2x.scala:45:24\
    \ --------------------\e[0m\e[0m\n\e[31m45 |\e[0m            carrots ++= num\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m       \
    \                 Found:    (num : Int)\n\e[31m   |\e[0m                     \
    \   Required: IterableOnce[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4utron2x.scala:53:40 --------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m                List(hungry, remaining).reverse\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \         Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m            \
    \    Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4utron2x.scala:56:40 --------------------\e[0m\e\
    [0m\n\e[31m56 |\e[0m                List(hungry, remaining).toList\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m     \
    \           Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660010816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000) {\n\
    \            throw new IllegalArgumentException(s\"Illegal arguments given to\
    \ eat.\\n\" +\n              s\"number: $number\\n\" +\n              s\"need:\
    \ $need\\n\" +\n              s\"remaining: $remaining\")\n        }\n       \
    \ val food: List[Long] = List.fill(number)(1l)\n        val needsToEat: List[Long]\
    \ = List.fill(need)(0l)\n        val remainingCarrots: List[Long] = List.fill(remaining)(-99999l)\n\
    \n        val result = mutable.ListBuffer[Long]()\n        while (food(0) < 100)\
    \ {\n            if (needsToEat(0) < need(0)) {\n                remainingCarrots(0)\
    \ = -99999l\n            } else {\n                val carrots = food.head + needsToEat.head\n\
    \                val newFood = food.tail\n                val newNeedsToEat =\
    \ needsToEat.tail\n                val newRemainingCarrots = remainingCarrots.tail\n\
    \                val newResult = eat(newCarrots, newNeedsToEat, newRemainingCarrots)\n\
    \                newResult foreach (a => result += a)\n                food :=\
    \ newFood\n                needsToEat := newNeedsToEat\n                remainingCarrots\
    \ := newRemainingCarrots\n            }\n        }\n        result toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8i671yl8.scala:57:21 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        result toList\n\e[31m\e[31m   |\e[0m        \
    \             ^\e[0m\n\e[31m   |\e[0m                     expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8i671yl8.scala:37:41 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mfood\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]\
    \ = List.fill(number)(\e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                Found:    (number : Long)\n\e[31m   |\e[0m                  \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8i671yl8.scala:38:47 --------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mneedsToEat\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List.fill(need)(\e[31m0l\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                              ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                           Found:    (need : Long)\n\e[31m  \
    \ |\e[0m                                               Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8i671yl8.scala:39:53 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mremainingCarrots\e[0m: \e\
    [35mList\e[0m[\e[35mLong\e[0m] = List.fill(remaining)(-\e[31m99999l\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                                     ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    (remaining\
    \ : Long)\n\e[31m   |\e[0m                                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8i671yl8.scala:41:21\
    \ ------------------------\e[0m"
  stdout: ''
  timestamp: 1660010818
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val totalCarrots = number\
    \ - need\n        if (totalCarrots < 0) {\n            List[Long]((remaining +\
    \ totalCarrots).toLong, 0)\n        } else {\n            List[Long](remaining.toLong,\
    \ 0)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp9ru63gx.scala:39)\n\tat Problem.main(tmpp9ru63gx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var carrots : List[Long]\
    \ = Nil\n        \n        var hungry : List[Long] = number :: carrots\n     \
    \   var hungryCut = 0\n        var hungryDone : Boolean = true\n        var carrotLeft\
    \ : List[Long] = remaining :: carrots\n        while (hungryDone && hungry.nonEmpty)\
    \ {\n            hungryCut = hungryCut+1\n            val hungryCarrots : List[Long]\
    \ = hungry filter (_ > hungryCut)\n            val hungryLeft = car hungryCut\n\
    \            hungryDone =  hungryCarrots.isEmpty || remaining < hungryLeft\n \
    \           carrots = carrots.+(hungryCarrots take hungryLeft)\n            hungry\
    \ = hungryCarrots\n        }\n        \n        var done = false\n        while\
    \ (!done && carrotLeft.nonEmpty) {\n            val carrotLeftAfterMeals = carrots\
    \ take remaining\n            carrots = carrots.drop(carrotLeftAfterMeals.size)\n\
    \            done = remaining == 0\n        }\n        \n        if (carrots.isEmpty)\n\
    \            hungryDone = true\n        \n        carrots.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6k1d5ek7.scala:41:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            hungryDone =  hungryCarrots.isEmpty || remaining\
    \ < hungryLeft\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e\
    [0m                       end of statement expected but '=' found\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6k1d5ek7.scala:40:29 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mhungryLeft\e[0m = car\
    \ hungryCut\n\e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: car\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6k1d5ek7.scala:42:30 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            carrots = carrots.+(hungryCarrots take hungryLeft)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6k1d5ek7.scala:48:52\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m            \e[33mval\e[0m \e\
    [36mcarrotLeftAfterMeals\e[0m = carrots take remaining\n\e[31m\e[31m   |\e[0m\
    \                                                    ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                            Found:    (remaining : Long)\n\
    \e[31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var remainingCarrots = remaining\
    \ - 1\n        var list = []\n        var carrots = 1\n        var n = 0\n   \
    \     while (number > 0) {\n            list :+= carrots\n            number -=\
    \ 1\n            carrots += 1\n            n += 1\n            if (remainingCarrots\
    \ > 0) {\n                remainingCarrots -= 1\n            }\n        }\n  \
    \      list :+= carrots\n        if (remainingCarrots < 0) {\n            remainingCarrots\
    \ = 0\n        }\n        list :+= remainingCarrots\n        return list\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpswp9k1ki.scala:32:20 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mlist\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    an\
    \ identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpswp9k1ki.scala:33:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mcarrots\e[0m = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e\
    [0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpswp9k1ki.scala:36:17 ------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            list :+= carrots\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value :+= is not a member of Null\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpswp9k1ki.scala:37:19 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpswp9k1ki.scala:44:13\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        list :+= carrots\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value :+= is\
    \ not a member of Null\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpswp9k1ki.scala:48:13\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        list :+= remainingCarrots\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value :+= is\
    \ not a member of Null\n6 errors found\n"
  stdout: ''
  timestamp: 1660010819
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val m = math.min(number,\
    \ math.min(need, remaining)).toLong\n        if (m == 0) List(number.toLong)\n\
    \        else eat(m-1, number-m, remaining-m) ::: List(number.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp34_m07s6.scala:36)\n\tat Problem.main(tmp34_m07s6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000, \"Invalid number : \" + number)\n        require(need >= 0 && need\
    \ <= 1000, \"Invalid need : \" + need)\n        require(remaining >= 0 && remaining\
    \ <= 1000, \"Invalid remaining : \" + remaining)\n        var carrots : List[Long]\
    \ = List()\n        var carrots_need = number\n        var carrots_remaining =\
    \ remaining\n        while(carrots_remaining > 0) {\n            carrots_need\
    \ += need\n            carrots_remaining -= need\n            carrots = List(carrots_need.toLong)\
    \ + carrots\n        }\n        carrots\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe6ncvtzy.scala:40:48 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            carrots = List(carrots_need.toLong) + carrots\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number >= 0 && number\
    \ <= 1000 && need >= 0 && need <= 1000 && remaining >= 0 && remaining <= 1000)\n\
    \            List.tabulate(remaining)(_ + _)\n        else\n            List.tabulate(remaining)(_\
    \ + _ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1c6tplmh.scala:32:26\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            List.tabulate(remaining)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    (remaining : Long)\n\e[31m   |\e\
    [0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp1c6tplmh.scala:32:37 ---------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m            List.tabulate(remaining)(_ + _)\n\e[31m\e[31m\
    \   |\e[0m                                     ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                              Wrong number of parameters, expected: 1\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1c6tplmh.scala:34:26 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            List.tabulate(remaining)(_ + _ + _)\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (remaining : Long)\n\e[31m   |\e[0m            \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmp1c6tplmh.scala:34:37 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            List.tabulate(remaining)(_ + _ + _)\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                         Wrong number of parameters, expected: 1\n4 errors found\n"
  stdout: ''
  timestamp: 1660010819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n      val numbers = mutable.ListBuffer[Long]()\n\
    \      while(number > 0 && remaining > 0) {\n        number -= 1\n        remaining\
    \ -= 1\n        numbers :+= number\n      }\n      val needs = mutable.ListBuffer[Long]()\n\
    \      while(need > 0 && remaining > 0) {\n        need -= 1\n        remaining\
    \ -= 1\n        needs :+= need\n      }\n      if(remaining > 0) {\n        numbers\
    \ :+= remaining\n        needs :+= remaining\n      }\n      val ret: List[Long]\
    \ = numbers.toList ++ needs.toList\n      if(ret.length == 0) ret :+= 0\n    \
    \  ret\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1h9qvfzk.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mval\e[0m \e[36mnumbers\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp1h9qvfzk.scala:33:15 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value -= is not a member of Long\
    \ - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h9qvfzk.scala:34:18\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        remaining -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ -= is not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp1h9qvfzk.scala:37:18 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m      \e[33mval\e[0m \e[36mneeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp1h9qvfzk.scala:39:13 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        need -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m        value -= is not a member of Long\
    \ - did you mean need.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h9qvfzk.scala:40:18\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        remaining -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ -= is not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp1h9qvfzk.scala:48:30 ------------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m      \e[33mif\e[0m(ret.length == \e[31m0\e[0m) ret :+= \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m  "
  stdout: ''
  timestamp: 1660010823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000){\n \
    \           throw new IllegalArgumentException\n        }\n        val rem = number\
    \ - need\n        val lef = remaining - rem\n        if(rem <= 0){\n         \
    \   List(lef)\n        }\n        else{\n            val newList = List(lef)\n\
    \            remaining -= 1\n            if(remaining > 0){\n                newList\
    \ = newList :+ remaining\n            }\n            newList\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptq2qr0x_.scala:41:22 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            remaining -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is\
    \ not a member of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmptq2qr0x_.scala:43:24 -----------------------------\e[0m\e[0m\n\
    \e[31m43 |\e[0m                newList = newList :+ remaining\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               Reassignment to val newList\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def eat(list: List[Long],\
    \ needed : Long, num : Long, acc : List[Long]) : List[Long] = {\n            list\
    \ match {\n                case Nil => acc.reverse\n                case x ::\
    \ xs => {\n                    val nextNeed = needed - x\n                   \
    \ val nextRemaining = remaining - x\n                    val nextNum = num + x\n\
    \                    val nextAcc = eat(nextList, nextNeed, nextNum, nextAcc)\n\
    \                    if (nextNum < needed) {\n                        nextAcc\
    \ ++ List(x)\n                    } else {\n                        nextAcc\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ list: List[Long] = List(1, number, need, remaining)\n        eat(list, need,\
    \ number, List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb8uvzh1x.scala:38:38 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    \e[33mval\e[0m \e[36mnextAcc\e[0m\
    \ = eat(nextList, nextNeed, nextNum, nextAcc)\n\e[31m\e[31m   |\e[0m         \
    \                             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                     Not found: nextList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpb8uvzh1x.scala:38:67 ---------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                    \e[33mval\e[0m \e[36mnextAcc\e[0m = eat(nextList,\
    \ nextNeed, nextNum, nextAcc)\n\e[31m\e[31m   |\e[0m                         \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                           Recursive \e[33mvalue\e[0m \e[35mnextAcc\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number >= 0 && number\
    \ <= 1000 && need >= 0 && need <= 1000 && remaining >= 0 && remaining <= 1000)\n\
    \        var numEaten = 0\n        var numEatenNeed = 0\n        var remainEaten\
    \ = 0\n        var remainingNeed = 0\n        for(i <- 0 until remaining) {\n\
    \            if(i == number)\n                numEaten += 1\n            if(i\
    \ >= need)\n                numEatenNeed += 1\n            remainEaten += i\n\
    \            remainingNeed -= i\n        }\n        if(numEatenNeed >= need) {\n\
    \            var eat = numEaten\n            var needsRemain = need\n        \
    \    for(i<-0 until numEatenNeed) {\n                if(i == need)\n         \
    \           eat += 1\n                eat -= remainingNeed\n                needsRemain\
    \ -= remainingNeed\n            }\n            return eat :: Nil\n        } else\
    \ {\n            return Nil\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1sb4gx7v.scala:36:25\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m0\e[0m until remaining) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    (remaining : Long)\n\e\
    [31m   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010826
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remainders = remaining\
    \ % need\n        var list = []\n        var i = 0\n        while(i < remainders)\
    \ {\n            list = list :+ number - i + 1\n            i = i + 1\n      \
    \  }\n        list = list :+ number\n        list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9lt6w251.scala:32:20 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mlist\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    an\
    \ identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9lt6w251.scala:33:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>'\
    \ expected, but 'end of statement' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9lt6w251.scala:35:24 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m            list = list :+ number - i + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   value :+ is\
    \ not a member of Null\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9lt6w251.scala:38:20\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        list = list :+ number\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :+ is not\
    \ a member of Null, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Solution here\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqfljawbo.scala:30:73\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \e[33mdef\e[0m \e[36meat\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m, \e[36mneed\e[0m : \e[35mLong\e[0m, \e\
    [36mremaining\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \                Found:    Unit\n\e[31m   |\e[0m                             \
    \                       Required: List[Long]\n\e[31m31 |\e[0m        \e[34m//\
    \ Solution here\e[0m\n\e[31m32 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010825
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        var remainingCarrots = remaining.toInt\n        if (remainingCarrots\
    \ == 0) List(remaining, 0l) else eat(carrots, need, remainingCarrots)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        if(remaining > 0){\n            val need1 = need - remaining\n      \
    \      val number1 = number - need1\n            val need2 = number1 - need\n\
    \            val number2 = number - need2\n            val number = number - need1\n\
    \            val need1 = need2\n            val need = need1\n            val\
    \ number1 = number2\n            val number2 = number\n            val number\
    \ = number1\n            val need = need1\n            val number1 = number2\n\
    \            val number2 = number\n            val number = number1\n        \
    \    val need = need1\n            val number1 = number2\n            val number2\
    \ = number\n            val number = number1\n            val need = need1\n \
    \           val number1 = number2\n            val number2 = number\n        \
    \    val number = number1\n            val need = need1\n            val number1\
    \ = number2\n            val number2 = number\n            val number = number1\n\
    \            val need = need1\n            val number1 = number2\n           \
    \ val number2 = number\n            val number = number1\n            val need\
    \ = need1\n            val number1 = number2\n            val number2 = number\n\
    \            val number = number1\n            val need = need1\n            val\
    \ number1 = number2\n            val number2 = number\n            val number\
    \ = number1\n            val need = need1\n            val number1 = number2\n\
    \            val number2 = number\n            val number = number1\n        \
    \    val need = need1\n            val number1 = number2\n            val number2\
    \ = number\n            val number = number1\n            val need = need1\n \
    \           val number1 = number2\n            val number2 = number\n        \
    \    val number = number1\n            val need = need1\n            val number1\
    \ = number2\n            val number2 = number\n            val number = number1\n\
    \            val need = need1\n            val number1 = number2\n           \
    \ val number2 = number\n            val number = number1\n            val need\
    \ = need1\n            val number1 = number2\n            val number2 = number\n\
    \            val number = number1\n            val need = need1\n            val\
    \ number1 = number2\n            val number2 = number\n            val number\
    \ = number1\n            val need = need1\n            val number1 = number2\n\
    \            val number2 = number\n            val number = number1\n        \
    \    val need = need1\n            val number1 = number2\n            val number2\
    \ = number\n            val number = number1\n            val need\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpisroxs5i.scala:108:4 ---------------------------\e\
    [0m\e[0m\n\e[31m108 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpisroxs5i.scala:119:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m119 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpisroxs5i.scala:31:19 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpisroxs5i.scala:38:16 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mneed1\e[0m = need2\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneed1\
    \ is already defined as \e[33mvalue\e[0m \e[35mneed1\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpisroxs5i.scala:40:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e\
    [0m \e[36mnumber1\e[0m = number2\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumber1 is already defined as \e[33mvalue\e[0m \e[35mnumber1\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpisroxs5i.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m            \e[33mval\e[0m \e[36mnumber2\e[0m = number\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnumber2 is\
    \ already defined as \e[33mvalue\e[0m \e[35mnumber2\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpisroxs5i.scala:42:16\
    \ ------------"
  stdout: ''
  timestamp: 1660010831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def eatOne(c: Long, remaining\
    \ : Long) =\n            (remaining / 2l).toLong match {\n                case\
    \ 1 => List(c)\n                case 2 => List(c, c + c)\n                case\
    \ 3 => List(c, c, c + c, c + c)\n                case 4 => List(c, c, c + c, c\
    \ + c, c + c)\n                case _ => List(c, c, c + c, c + c, c + c, c + c)\n\
    \            }\n        val meals = number / 2l\n        val remaining = number\
    \ - meals * 2l\n        meals.toList match {\n            case 1 => List(meals.toLong)\n\
    \            case 2 => List(meals.toLong, meals.toLong)\n            case 3 =>\
    \ List(meals.toLong, meals.toLong, meals.toLong)\n            case 4 => List(meals.toLong,\
    \ meals.toLong, meals.toLong, meals.toLong)\n            case _ => List(meals.toLong,\
    \ meals.toLong, meals.toLong, meals.toLong, meals.toLong)\n        }.flatten.map(eatOne)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpg4nhbqr9.scala:47:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        }.flatten.map(eatOne)\n\e[31m\e[31m   |\e[0m\
    \         ^\e[0m\n\e[31m   |\e[0m         end of statement expected but '.' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg4nhbqr9.scala:41:14 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        meals.toList \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toList is not\
    \ a member of Long - did you mean meals.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010828
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val totalEaten = number\
    \ - remaining\n        val leftover = remaining - need\n        List(totalEaten.toLong,\
    \ leftover.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgnfcsemj.scala:36)\n\tat Problem.main(tmpgnfcsemj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if(number == 0) List(number\
    \ -> 0); else \n            // You need a number to eat, so first eat that number\n\
    \            val eat = eat1(remaining, number, need); \n            // The remaining\
    \ carrots are still hungry, so eat them as well\n            val eat2 = eat1(remaining\
    \ - eat.size, number, need); \n            // The numbers are equal, so you eat\
    \ the first number\n            eat2 :+ eat.head \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8j2cxs1j.scala:31:29\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mif\e[0m(number\
    \ == \e[31m0\e[0m) List(number -> \e[31m0\e[0m); \e[33melse\e[0m \n\e[31m\e[31m\
    \   |\e[0m                             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                        Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m              \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8j2cxs1j.scala:33:22 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m            \e[33mval\e[0m \e[36meat\e[0m = eat1(remaining, number, need);\
    \ \n\e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                  Not found: eat1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8j2cxs1j.scala:35:23 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m            \e[33mval\e[0m \e[36meat2\e[0m = eat1(remaining - eat.size, number,\
    \ need); \n\e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e\
    [0m                       Not found: eat1\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code goes here\n\
    \        val result = mutable.ListBuffer[Long]()\n        if(number > 0 && need\
    \ > 0 && remaining > 0){\n            if (number+need+remaining > 1000) return\
    \ result\n            if (number+need+remaining <= 1000) {\n                if\
    \ (remaining >= need) result += (number+need)\n                if (number+need+remaining\
    \ < 1000) result += (number+need+remaining) \n            }\n        }\n     \
    \   result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaby_q39t.scala:32:21 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number <= 0 || number\
    \ > 1000) throw new RuntimeException(\"Not a valid number of carrots.\")\n   \
    \     if (need <= 0 || need > 1000) throw new RuntimeException(\"Not a valid need\"\
    )\n        if (remaining <= 0 || remaining > 1000) throw new RuntimeException(\"\
    Not a valid number of carrots.\")\n        var total : List[Long] = List[Long](0l)\n\
    \        while (remaining > 0) {\n            total :+= number\n            number\
    \ -= need\n            remaining -= need\n        }\n        total\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb1bv49t7.scala:37:19 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            number -= need\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb1bv49t7.scala:38:22\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            remaining -=\
    \ need\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \         value -= is not a member of Long - did you mean remaining.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val a = { ((100l - number)\
    \ * (100l - remaining)) / (100l - need) }\n        if (number > need + a * remaining)\
    \ List(need.toLong, a * remaining + number.toLong)\n        else List(number.toLong,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcigmqqx_.scala:36)\n\tat Problem.main(tmpcigmqqx_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010835
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        def foo(number : Long, need\
    \ : Long, remaining : Long, list : List[Long]) : List[Long] = { // a helper function\
    \ which returns the list\n            if(number == 0) list else foo(remaining\
    \ - need, need, number, list :+ number) // recurse to next level\n        }\n\
    \        foo(number, need, remaining, List.empty[Long]) // return empty list if\
    \ any condition not met\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // TODO: complete this function\n\
    \        val myList = mutable.ListBuffer[Long]()\n        val neededCarrots =\
    \ number.toLong - remaining\n        val remainingCarrots = need.toLong - neededCarrots\n\
    \        if (remainingCarrots < 0) {\n            myList += remainingCarrots.toLong\n\
    \        } else {\n            myList += neededCarrots.toLong\n        }\n   \
    \     myList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo97wooyq.scala:32:21 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmyList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var remaining = remaining\n\
    \        var total = 0L\n        if (remaining < need) {\n            for (i <-\
    \ 0 until remaining) {\n                total += number\n            }\n     \
    \       val hungryIndex = total - need\n            total += hungryIndex\n   \
    \         val hungryRemaining = remaining - hungryIndex\n            remaining\
    \ = hungryRemaining\n            val hungryNeeds = need - hungryRemaining\n  \
    \          val hungryEaten = number - hungryIndex\n            val hungryEatenList\
    \ = hungryEaten.toList\n            val hungryEatenListIndex = hungryEatenList.indexOf(0)\n\
    \            total += hungryEatenList\n            val hungryEatenListRemaining\
    \ = hungryEatenList - hungryEatenListIndex\n            remaining -= hungryEatenListRemaining\n\
    \            val hungryEatenListNeeds = hungryNeeds - hungryEatenListRemaining\n\
    \            val hungryEatenListNeedsIndex = hungryEatenListNeeds.indexOf(0)\n\
    \            remaining += hungryEatenListNeedsIndex\n            val hungryEatenListNeedsRemaining\
    \ = hungryEatenListNeeds - hungryEatenListNeedsIndex\n            val hungryEatenListNeedsNeeds\
    \ = hungryNeeds - hungryEatenListNeedsRemaining\n            val hungryEatenListNeedsNeedsIndex\
    \ = hungryEatenListNeedsNeeds.indexOf(0)\n            remaining += hungryEatenListNeedsNeedsIndex\n\
    \            val hungryEatenListNeedsNeedsRemaining = hungryEatenListNeedsNeeds\
    \ - hungryEatenListNeedsNeedsIndex\n            remaining += hungryEatenListNeedsNeedsRemaining\n\
    \            val hungryEatenListNeedsNeedsRemainingIndex = hungryEatenListNeedsNeedsRemaining.indexOf(0)\n\
    \            remaining += hungryEatenListNeedsNeeds\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7zmxq72n.scala:70:0 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7zmxq72n.scala:31:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mremaining\e[0m = remaining\n\e[31m\e[31m   |\e[0m                    \
    \    ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvariable\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp7zmxq72n.scala:43:46 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m            \e[33mval\e[0m \e[36mhungryEatenList\e[0m = hungryEaten.toList\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m  value toList is not a member of Long - did you mean hungryEaten.toInt?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7zmxq72n.scala:69:1 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp7zmxq72n.scala:60:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m60 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numberCarry = 0\n  \
    \      var remaining = remaining\n        var numNeed = 0\n        while (numberCarry\
    \ < number) {\n            numberCarry += 1\n            numNeed += 1\n      \
    \  }\n        val numNeedCarrot = (numNeed * need).toLong\n        val numCarrotCarry\
    \ = numNeed * (need - numberCarry)\n        val numCarrotLeft = (numNeed * remaining).toLong\n\
    \        val numCarrotLeftCarry = numCarrotLeft - numberCarry\n        val numCarrotLeftNeed\
    \ = (numCarrotCarry * numNeed).toLong\n        val numCarrotLeftNeedCarry = numCarrotLeftNeed\
    \ - numCarrotCarry\n        val numCarrotLeftNeedNeed = (numCarrotLeftCarry *\
    \ numNeedCarry).toLong\n        val numCarrotLeftNeedNeedCarry = numCarrotLeftNeedNeedCarry\
    \ - numCarrotLeftCarry\n        val numCarrotLeftNeedNeedCarry = numCarrotLeftNeedNeedCarry\
    \ - numCarrotLeftNeedCarry\n        List(numCarrotLeftNeedNeed.toLong + numCarrotLeftNeedCarry)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnoh1o844.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mnumCarrotLeftNeedNeedCarry\e\
    [0m = numCarrotLeftNeedNeedCarry - numCarrotLeftNeedCarry\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumCarrotLeftNeedNeedCarry is already defined as \e[33mvalue\e\
    [0m \e[35mnumCarrotLeftNeedNeedCarry\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnoh1o844.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnoh1o844.scala:35:24\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            numberCarry +=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m          value += is not a member of Int - did you mean numberCarry.!=?\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnoh1o844.scala:45:41 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mnumCarrotLeftNeedNeedCarry\e\
    [0m = numCarrotLeftNeedNeedCarry - numCarrotLeftCarry\n\e[31m\e[31m   |\e[0m \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \      Recursive \e[33mvalue\e[0m \e[35mnumCarrotLeftNeedNeedCarry\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        for(i <- 0 until number){\n            val temp =\
    \ remaining - i\n            if(temp > 0)\n                list += temp\n    \
    \        else\n                break\n        }\n        if(list.size < need)\n\
    \            list += list.size until (need - list.size)\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7wgdjg30.scala:33:25\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m0\e[0m until number){\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    (number : Long)\n\e[31m\
    \   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7wgdjg30.scala:38:16 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7wgdjg30.scala:41:37 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            list += list.size until (need - list.size)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Found:    Long\n\e[31m   |\e\
    [0m                                     Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        require(number > 0 && number\
    \ <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000)\n\
    \        val list = scala.collection.mutable.ListBuffer[Long]()\n        var index\
    \ = 0\n        var remaining = remaining\n        var need = need\n        var\
    \ number = number\n        while(number != 0){\n            if(remaining == 0){\n\
    \                number -= 1\n                remaining += need\n            \
    \    index += 1\n            } else if(number > need){\n                number\
    \ -= need\n                remaining += need\n                index += 1\n   \
    \         } else {\n                number -= 1\n                remaining -=\
    \ 1\n                index += 1\n            }\n            list += number.toLong\n\
    \        }\n        return list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppt81sjg7.scala:36:21 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e[36mnumber\e[0m = number\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m              \
    \       Recursive \e[33mvariable\e[0m \e[35mnumber\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppt81sjg7.scala:34:24 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppt81sjg7.scala:35:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mneed\e[0m = need\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvariable\e[0m \e[35mneed\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // TODO: implement here\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4rewtetj.scala:30:73\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \e[33mdef\e[0m \e[36meat\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m, \e[36mneed\e[0m : \e[35mLong\e[0m, \e\
    [36mremaining\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \                Found:    Unit\n\e[31m   |\e[0m                             \
    \                       Required: List[Long]\n\e[31m31 |\e[0m        \e[34m//\
    \ TODO: implement here\e[0m\n\e[31m32 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010836
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val left   = need-remaining\n        val result = List(carrots, left)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3kwapcs4.scala:37)\n\tat Problem.main(tmp3kwapcs4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010837
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val l1 = if (number <= 0)\
    \ List(0l) else List(1l, number - 2l)\n        val l2 = if (remaining <= 0) List(need)\
    \ else List(remaining - need)\n        l1 ++ l2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptnsib7kp.scala:36)\n\tat Problem.main(tmptnsib7kp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if ((number < 0) || (number\
    \ > 1000) || (need < 0) || (need > 1000) || (remaining < 0) || (remaining > 1000))\
    \ throw new IllegalArgumentException(\"Invalid input\")\n\n        var carrotLeft\
    \ = 0l\n        var eaten = 0l\n        var meals = List[Long]()\n        var\
    \ total = 0l\n        while (carrotLeft <= remaining) {\n            if (carrotLeft\
    \ < need) {\n                total += 1\n                meals = meals :+ number\n\
    \                carrotLeft += 1l\n            } else {\n                total\
    \ += 1\n                meals = meals :+ number\n            }\n        }\n  \
    \      return (total.toLong, carrotLeft.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06yrcyng.scala:47:15\
    \ --------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mreturn\e[0m (total.toLong,\
    \ carrotLeft.toLong)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    (Long, Long)\n\e[31m   |\e[0m   \
    \            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010836
