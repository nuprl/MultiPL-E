name: HumanEval_116_sort_array
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // In this Kata, you have to sort a list of non-negative integers according\
  \ to\n    // number of ones in their binary representation in ascending order.\n\
  \    // For similar number of ones, sort based on decimal value.\n    // It must\
  \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong,\
  \ -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong, -5l.toLong,\
  \ -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
  \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long]) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
  \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
  \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
  \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
  \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
  \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong,\
  \ 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong, 6l.toLong,\
  \ 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
  \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
  \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
  \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
  \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
  \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
completions: ["        var maxLen :Int = 0\n        var sortedArr = arr.toList\n \
    \       var resultArr = arr.toList\n        val oneBitCount = arr.count{x => x\
    \ & 1 == 1}\n        var remainArr = arr.toList\n        var oneBitCountNew =\
    \ 0\n        while(sortedArr.nonEmpty) {\n            maxLen = maxLen + oneBitCountNew\n\
    \            remainArr.toList.sortWith{\n                (x: Long, y: (Long)=>Boolean)\
    \ => {\n                    if((x % 2) == 0) (x == y) || (y == (x%2))\n      \
    \              else (x == y)\n                }\n            }\n            oneBitCountNew\
    \ = oneBitCountNew + oneBitCount\n            resultArr = resultArr ++ remainArr\n\
    \            sortedArr = sortedArr.drop(maxLen)\n        }\n        resultArr",
  '        arr.sortWith( x => countOnes(x) )', "        if (arr.size < 2) arr\n  \
    \      else if (arr.lastOption.orElse(0L) == -1L) arr.reverse\n        else arr.sortWith(compare)",
  "        def rec(arr : List[Long]) : List[Long] = {\n            arr.head match\
    \ {\n                case x if x == 0l => arr.tail\n                case x if\
    \ x == 1l => arr.head :: rec(arr.tail)\n                case x => {\n        \
    \            val numOnes = arr.filter(x => (x & 1l).toLong).length\n         \
    \           if (numOnes > arr.length / 2l) {\n                        rec(arr.tail)\n\
    \                    } else {\n                        rec(arr.head :: arr.tail)\n\
    \                    }\n                }\n            }\n        }\n        rec(arr)",
  "        val n = arr.size\n        val ones = arr.filter(_ % 2 == 1).size\n    \
    \    val twos = arr.filter(_ % 2 == 0).size\n\n        var res = List[Long]()\n\
    \        for (i<- 0 until n)\n        {\n            if (ones > twos)\n      \
    \      {\n                val tempArray = arr.slice(i+1,n).filter(_ % 2 == 0).sortBy(_\
    \ => -(_ % 10).toLong)\n                val tempArray2 = tempArray.filter(_ %\
    \ 2 == 1).sortBy(_ => -(_ % 10).toLong)\n                res = res + tempArray2\n\
    \            }\n            else if (ones == twos)\n            {\n          \
    \      val tempArray = arr.slice(i+1,n).filter(_ % 2 == 1).sortBy(_ => -(_ % 10).toLong)\n\
    \                val tempArray2 = tempArray.filter(_ % 2 == 0).sortBy(_ => -(_\
    \ % 10).toLong)\n                res = res + tempArray2\n            }\n     \
    \       else if (ones < twos)\n            {\n                val tempArray =\
    \ arr.slice(i+1,n).filter(_ % 2 == 0).sortBy(_ => -(_ % 10).toLong)\n        \
    \        val tempArray2 = tempArray.filter(_ % 2 == 1).sortBy(_ => -(_ % 10).toLong)\n\
    \                res = res + tempArray2\n            }\n        }\n        res",
  "        var i = arr.length\n        val ans = arr.toList\n        while ( i >=\
    \ 1 ) {\n            var count = 1\n            while ( i >= 1 ) {\n         \
    \       if ( arr(i) % 2 != 0 ) {\n                    ans(i) = 0l.toLong\n   \
    \                 count = count+1\n                }\n                i = i-1\n\
    \            }\n            if ( count == 1 ) {\n                ans(i) = 0l.toLong\n\
    \            }\n            i = i-1\n        }\n        ans.toList", '        arr.zipWithIndex.sortBy(t
    => t._2).map(t => t._1).reverse', "        var ans = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 0 until arr.length){\n            val bin = Long.numberOfLeadingZeros(arr(i))\n\
    \            val dec = arr(i).toString.toInt\n            val value = dec / bin\n\
    \            ans += value\n        }\n        ans.toList", "        arr.sortBy((x)\
    \ => x.toString match {\n            case s if (s.startsWith(\"1\")) => 1\n  \
    \          case s if (s.startsWith(\"0\")) => -1\n            case _ => 0\n  \
    \      })", "        if (arr.isEmpty) {\n            List()\n        }\n     \
    \   val onesCount = arr.map(n => 1l.toLong.asInstanceOf[Long] & n).toArray\n \
    \       val zerosCount = arr.map(n => 0l.toLong.asInstanceOf[Long] & n).toArray\n\
    \        val maxOnesCount = onesCount.max\n        val maxZeroesCount = zerosCount.max\n\
    \        val onesIndex = onesCount.zipWithIndex.sortBy(_._1).last._2\n       \
    \ val zerosIndex = zerosCount.zipWithIndex.sortBy(_._1).last._2\n        val onesDiff\
    \ = maxOnesCount - onesCount\n        val zerosDiff = maxZeroesCount - zerosCount\n\
    \        val onesMax = (onesIndex.toDouble / maxOnesCount).floor.toInt\n     \
    \   val zerosMax = (zerosIndex.toDouble / maxZeroesCount).floor.toInt\n      \
    \  val onesMaxDiff = onesDiff - onesMax\n        val zerosMaxDiff = zerosDiff\
    \ - zerosMax\n        val onesMin = (onesIndex.toDouble / maxOnesCount).ceil.toInt\n\
    \        val zerosMin = (zerosIndex.toDouble / maxZeroesCount).ceil.toInt\n  \
    \      val onesMinDiff = onesMax - onesMin\n        val zerosMinDiff = zerosMax\
    \ - zerosMin\n        val onesMaxOnesDiff = onesMaxDiff + onesMaxDiff\n      \
    \  val zerosMaxZeroesDiff = zerosMaxDiff + zerosMaxDiff\n        val onesMinZeroesDiff\
    \ = onesMinDiff + onesMinDiff\n        val zerosMinOnesDiff = zerosMinDiff + zerosMinDiff\n\
    \        val onesMaxOnesMaxDiff = onesMaxOnesDiff + onesMaxOnesDiff\n        val\
    \ zerosMaxZeroesMaxDiff = zerosMaxZeroesDiff + zerosMaxZeroesDiff\n        val\
    \ onesMinZeroesMaxDiff = onesMinZeroesDiff + onesMinZeroesDiff\n        val zerosMinOnesMaxDiff\
    \ = zerosMinOnesDiff + zerosMinOnesDiff\n        val onesMaxOnesMinDiff = onesMaxOnesDiff\
    \ + onesMaxOnesDiff\n        val zerosMaxZeroesMinDiff = zerosMaxZeroesDiff +\
    \ zerosMaxZeroesDiff\n        val onesMinZeroesMinDiff", '        arr.toList.sortWith((x,
    y) => compare(x, y) == 0)', "        val ones = arr.toSet.map(i => i.toBinary.length.toLong).toArray\n\
    \        val binary = arr.toSet.map(i => i.toBinary.toLong).toArray\n        val\
    \ count = binary.filter(i => i.toLong == 1).size\n        var newArray = Array[Long](arr.size)\n\
    \        var index = 0\n        var i = 0\n        while (i < binary.length) {\n\
    \            if (binary(i) == 1) {\n                var j = 0\n              \
    \  while (j < ones.length) {\n                    if (ones(j) == binary(i)) {\n\
    \                        newArray(index) = ones(j)\n                        index\
    \ = index + 1\n                        break\n                    }\n        \
    \            j = (j + 1).toInt\n                }\n                i = i + 1\n\
    \            }\n            i = i + 1\n        }\n        newArray.sortWith((i,\
    \ j) => i.toInt < j.toInt)", "        val binArr = arr.map(n => bin(n))\n    \
    \    val sortedBin = binArr.sortWith(_ < _)\n        val sortedStr = sortedBin.map(x\
    \ => x.reverse.toInt).map(x => x.toLong).map(Long2Int)\n        sortedStr.map(_.toLong).sorted",
  '        //  Your code here!', '        arr.sortWith((x, y) => if(x.toString.toInt==y.toString.toInt)
    0 else 1)', '      arr.sortWith((x,y) => if (x==0) y else x.toInt == y.toInt)',
  "        val ones: mutable.Map[Long, Int] = mutable.Map()\n        val negs: mutable.Map[Long,\
    \ Int] = mutable.Map()\n        val zeros: mutable.Map[Long, Int] = mutable.Map()\n\
    \        for(num <- arr) {\n            val bin = Integer.toBinaryString(num.toInt)\n\
    \            val i = bin.length\n            val v = bin.substring(bin.length\
    \ - i, bin.length).toInt\n            val a = num.toLong\n            val b =\
    \ num.toLong\n            val c = num.toLong\n            val d = num.toLong\n\
    \            val e = num.toLong\n            if(v > 0) {\n                ones\
    \ += ((a, b), v + 1)\n            } else if(v < 0) {\n                negs +=\
    \ ((c, d), -v)\n            } else if(v == 0) {\n                zeros += ((e,\
    \ i), 0)\n            }\n        }\n        val sortedOnes = ones.toSeq.sortBy(_._2)\n\
    \        val sortedNegs = negs.toSeq.sortBy(_._2)\n        val sortedZeros = zeros.toSeq.sortBy(_._2)\n\
    \        val merged = sortedOnes ++ sortedNegs ++ sortedZeros\n        val result\
    \ = merged.map(x => x._1 + x._2).sorted\n        result.toList", "        val\
    \ ones = arr.foldLeft(0)((acc, curr) => acc + (curr.toLong & 1))\n        val\
    \ sorted = arr.sortWith((a, b) => (ones > b) match {\n            case false =>\
    \ a < b\n            case true => a > b // if number of ones is equal, sort according\
    \ to decimal value\n        })\n        sorted", "        val oneBits = arr.filter(x\
    \ => x != 0).map(_ => 1).count()\n        val twoBits = arr.filter(x => x != 0).map(x\
    \ => x.toInt % 2L).count() * 2\n        val threeBits = arr.filter(x => x != 0).map(x\
    \ => (x.toInt % 3L) * 3L).count() * 3\n        val fourBits = arr.filter(x =>\
    \ x != 0).map(x => x.toInt % 4L).count() * 4\n\n        val oneToOne = oneBits\
    \ == 1\n        val twoToOne = twoBits == 2\n        val threeToOne = threeBits\
    \ == 3\n        val fourToOne = fourBits == 4\n\n        val oneToTwo = oneToOne\
    \ && twoBits == 2\n        val oneToThree = oneToOne && threeBits == 3\n     \
    \   val oneToFour = oneToOne && fourBits == 4\n\n        val twoToThree = twoToOne\
    \ && threeBits == 3\n        val twoToFour = twoToOne && fourBits == 4\n\n   \
    \     val threeToFour = threeToOne && fourBits == 4\n\n        val allOnes = oneToOne\
    \ && twoToOne && threeToOne && fourToOne\n        val allTwos = twoToOne && threeToOne\
    \ && fourToOne\n        val allThrees = threeToOne && fourToOne\n\n        val\
    \ allOnesAndTwos = oneToTwo && twoToTwo\n        val allOnesAndThrees = oneToThree\
    \ && threeToThree\n        val allOnesAndFours = oneToFour && fourToFour\n\n \
    \       val allTwosAndThrees = twoToThree && threeToThree\n        val allTwosAndFours\
    \ = twoToFour && fourToFour\n\n        val allThreesAndFours = threeToFour &&\
    \ fourToFour\n\n        val onlyOne = oneBits == 1\n        val onlyTwo = twoBits\
    \ == 2\n        val onlyThree = threeBits == 3\n        val onlyFour = fourBits\
    \ == 4\n\n        val oneAndOnlyOne = oneBits == 1 && onlyOne\n        val oneAndOnlyTwo\
    \ = oneBits == 1 && onlyTwo\n        val oneAndOnlyThree = oneBits == 1 && onlyThree\n\
    \        val oneAndOnlyFour = oneBits == 1 && onlyFour\n\n        val twoAndOnlyOne\
    \ = twoBits == 2 && onlyOne\n        val twoAndOnlyTwo = twoBits == 2 && onlyTwo\n\
    \        val twoAndOnlyThree = two", "        def sort(arr: List[Long], result:\
    \ List[Long], counter: Int) : List[Long] = {\n            if (counter == arr.length)\
    \ {\n                result\n            } else if (counter == 0) {\n        \
    \        if (arr(0) == 0) {\n                    sort(arr.tail, result, 0)\n \
    \               } else {\n                    sort(arr.tail, result, 1)\n    \
    \            }\n            } else {\n                if (arr(counter) == 1) {\n\
    \                    sort(arr.tail, result, counter + 1)\n                } else\
    \ {\n                    sort(arr.tail, result, counter)\n                }\n\
    \            }\n        }\n        sort(arr, Nil, 0)", '        arr.sortWith((x,
    y) => x.toBinary.length < y.toBinary.length || (x.toBinary.length == y.toBinary.length
    && x == y) ? x : y)', "        val n = arr.length\n        val bins = arr.map(n\
    \ -> bin(n))\n        val numOnes = bins.map(_.length).sum\n        val sortedArray\
    \ = arr.sortWith((a, b) => compare(numOnes, bins(a), bins(b)))\n        val binsToString\
    \ = bins.map(_.mkString(\",\"))\n        val numOnesToString = numOnes.toString\n\
    \        val resultArray = sortedArray.map { x =>\n            val onesArray =\
    \ binsToString.map(_.contains(x.toString.toLong))\n            if (onesArray.contains(true))\
    \ {\n                x.toString.toLong\n            } else {\n               \
    \ numOnesToString + x.toString.toLong\n            }\n        }\n        resultArray.toList",
  '        arr.sortWith(compareNumOnes)', '        // Implementation here', "    \
    \    val bitCounts = arr.foldLeft(Map[Int, Long]())((counts, item) => {\n    \
    \        counts + (item::item.toLong) -> (counts(item::item.toLong) + 1)\n   \
    \     })\n        val maxBitCounts = bitCounts.maxBy(_._1)\n        val binaryCounts\
    \ = maxBitCounts._1 -> maxBitCounts._2\n        val sortedBinaryCounts = binaryCounts.sortBy(_._1)\n\
    \        val maxDecimalValues = binaryCounts.maxBy(_._2)\n        val sortedDecimalValues\
    \ = maxDecimalValues._2 -> maxDecimalValues._1\n        val binaryIndexes = sortedBinaryCounts.keys\n\
    \        val decimalIndexes = sortedDecimalValues.keys\n        sortedBinaryCounts.flatMap\
    \ { case (binaryCount, decimalCount) =>\n            val binaryPartIndex = binaryIndexes.findIndex(i\
    \ => i <= binaryCount)\n            val decimalPartIndex = decimalIndexes.findIndex(i\
    \ => i <= decimalCount)\n            (binaryPartIndex, decimalPartIndex)\n   \
    \     }.map { case (binaryPartIndex, decimalPartIndex) =>\n            (arr.apply(binaryPartIndex),\
    \ arr.apply(decimalPartIndex))\n        }", "        var arr = arr.toList\n  \
    \      var sortedArr = arr.sortWith(_._2 > _._2)\n        var counts = arr.foldLeft((0,\
    \ 0))((acc, x) => acc + (x & (-x -> 1))._1)\n        var sortedCount = counts.max\n\
    \        var maxCount = sortedCount.toLong\n        var sortedArr2 = sortedArr.sortWith(_._2\
    \ > _._2) \n        var sortedCount2 = sortedArr2.foldLeft((0, 0))((acc, x) =>\
    \ acc + (x & (-x -> 1))._1)\n        var sortedCount2max = sortedCount2.max\n\
    \        val binary = sortedArr2.map { x => x._1.toString }\n        val decimal\
    \ = sortedArr2.map { x => x._1.toString.toDouble }\n        var binArr : List[String]\
    \ = binary.toList\n        var decArr : List[Double] = decimal.toList\n      \
    \  var finalArr : List[Double] = decArr.sortWith(_._2 < _._2)\n        var finalArr1\
    \ = finalArr.reverse\n        var finalArr2 = finalArr1.sortWith(_._2 > _._2)\n\
    \        var finalArr3 = finalArr2.reverse\n        return finalArr3", "     \
    \   var oneCount = 0\n        var otherCount = 0\n        val result = new mutable.ArrayList[Long]()\n\
    \        for (i<- 0 until arr.length) {\n            if (arr(i).toInt % 2 == 0)\
    \ {\n                oneCount += 1\n            } else {\n                otherCount\
    \ += 1\n            }\n        }\n        if (oneCount < otherCount) {\n     \
    \       result.addAll(arr.filter(_ % 2 == 0).toList)\n        } else {\n     \
    \       result.addAll(arr.filter(_ % 2 != 0).toList)\n        }\n        val sortedArray\
    \ = result.sortWith(_.compareTo(_) < 0)\n        sortedArray.toList", "      \
    \  val ones = arr.map(x => 1).filter(x => x == 1)\n        val twos = arr.map(x\
    \ => 2).filter(x => x == 1)\n        val threes = arr.map(x => 3).filter(x =>\
    \ x == 1)\n        val fours = arr.map(x => 4).filter(x => x == 1)\n        val\
    \ fives = arr.map(x => 5).filter(x => x == 1)\n        val sixes = arr.map(x =>\
    \ 6).filter(x => x == 1)\n        val twosOne = twos++ones\n        val threesOne\
    \ = threes++ones\n        val foursOne = fours++ones\n        val fivesOne = fives++ones\n\
    \        val sixesOne = sixes++ones\n        val twosTwo = twos++twos\n      \
    \  val threesTwo = threes++twos\n        val foursTwo = fours++twos\n        val\
    \ fivesTwo = fives++twos\n        val sixesTwo = sixes++twos\n        val twosThree\
    \ = twos++threes\n        val threesThree = threes++threes\n        val foursThree\
    \ = fours++threes\n        val fivesThree = fives++threes\n        val sixesThree\
    \ = sixes++threes\n        val twosFour = twos++fours\n        val threesFour\
    \ = threes++fours\n        val foursFour = fours++fours\n        val fivesFour\
    \ = fives++fours\n        val sixesFour = sixes++fours\n        val twosFive =\
    \ twos++fives\n        val threesFive = threes++fives\n        val foursFive =\
    \ fours++fives\n        val fivesFive = fives++fives\n        val sixesFive =\
    \ sixes++fives\n        val twosSix = twos++sixes\n        val threesSix = threes++sixes\n\
    \        val foursSix = fours++sixes\n        val fivesSix = fives++sixes\n  \
    \      val sixesSix = sixes++sixes\n        val allNums = twosOne++threesOne++foursOne++fivesOne++sixesOne++twosTwo++threesTwo++fours",
  "        val bits = arr.map(_.toString).toList\n        val bins = bits.grouped(8).map(_.foldLeft(\"\
    \")((acc, i) => acc + (if (i == \"1\") \"1\" else \"0\")))\n        val ones =\
    \ bits.filter(s => s.charAt(0) == \"1\").length\n        val decs = bins.map(i\
    \ => i.dropRight(8).reverse.toInt).map(_.toLong)\n        val sortedArray = if\
    \ (ones == decs.length) decs.sortBy(d => d.toInt) else decs.sortBy(d => d.toDouble)\n\
    \        val list = new Array[Long](sortedArray.length)\n        sortedArray.zip(list)\
    \ foreach { case (d, i) => list(i) = d}\n        arr map { i => list(i) }", " \
    \       arr.toList.sortBy(l => {\n            val ones = l.toBinaryString.drop(l.length-1)\n\
    \            (ones.length).compareTo(ones.toBinaryString.reverse)\n        }).sortWith(_.compareTo(0l)\
    \ <= 0)", "        val oneCount = arr.count(x => x == 1l.toLong).toLong\n    \
    \    var result = (oneCount == 0) ? arr : arr.zipWithIndex.sortBy(_._2).map(_._1).reverse\n\
    \        if (oneCount != 0) {\n            result = sortArray(result)\n      \
    \  }\n        result", "        // Write your code here\n        var resultList\
    \ = arr.sortBy(x => arr.count(bi => bi == x))\n\n        for((i, v) <- arr.zipWithIndex)\
    \ {\n            val count = resultList.count(bi => bi == v)\n            resultList(v)\
    \ = count\n            if(count == 1) {\n                resultList.indexWhere(bi\
    \ => bi == v) = i\n            }\n        }\n        resultList", "        val\
    \ ones = arr.groupBy(x => x.toBinaryString().toInt)\n        val res = ones\n\
    \            .mapValues(x => x.size)\n            .mapValues(x => x.toList)\n\
    \            .sortWith((x, y) => x._2 - y._2)\n            .map(_._1)\n      \
    \      .toList\n        arr", "        val ones = arr.count(x => x>0)\n      \
    \  val zeros = arr.count(x => x==0)\n        val sortedOnes = arr.sortBy(x =>\
    \ (ones-if(x>0).negate).abs\n          ,Ordering[Long].reverse).reverse\n    \
    \    val sortedZeros = arr.sortBy(x => (zeros-if(x==0).negate).abs\n         \
    \ ,Ordering[Long].reverse).reverse\n        sortedOnes :+ sortedZeros", "    \
    \    val oneBitSet = arr filter (_ != 0l)\n        val countMap = oneBitSet groupBy\
    \ (_ % 2 != 0l) mapValues (_.length.toLong)\n        val sortedNums = countMap.map\
    \ (_._2) sortWith (_ < _)\n        sortedNums.map(oneBitSet find _ != 0l).toList\
    \ ::: arr", "        arr.sortWith((x, y) => { \n            if (x == 1l) y < x\
    \ else x < (y==1l ? 1l : y) \n        })", "        val m = arr.size\n       \
    \ val bin = arr.map(_.toBinaryString).map(_.toLong).mkString(\",\")\n        val\
    \ dec = arr.map(_.toInt).map(_.toLong).mkString(\",\")\n        val bindec = bin+\"\
    ,\"+dec\n        val sorted = sc.parallelize(bindec).map(x=>{\n            val\
    \ bindec = x.split(\",\").map(_.toLong)\n            val bin = bindec.head\n \
    \           val dec = bindec.last\n            val binaryString = bin.toBinaryString\n\
    \            val str = s\"${binary.substring(bin.indexOf(0)+1)}(${dec.toInt})\"\
    \n            val str = binaryString + str\n            val binary = binaryString\
    \ + str\n            binary\n        }).map(x=>{\n            val bindec = x.split(\"\
    ,\").map(_.toLong)\n            val bin = bindec.head\n            val dec = bindec.last\n\
    \            (bin,dec).zipWithIndex.sortBy(_._1).map(_._2)\n        }).flatMap(x=>x).collect.toList\n\
    \        val resArr = sorted.map(_.toLong)\n        resArr", "        arr.sort((x,y)\
    \ => {\n                val bin = Integer.toString(x.toInt, 2)\n             \
    \   val bin2 = Integer.toString(y.toInt, 2)\n                val bin3 = bin.concat(bin2)\n\
    \                val bin4 = bin3.toCharArray\n                val bin5 = bin4(0)\n\
    \                val bin6 = bin4.drop(1)\n                val bin7 = bin6.map(Integer.parseInt)\n\
    \                val bin8 = bin7.take(bin7.length-1)\n                val bin9\
    \ = bin8.reverse\n                val bin10 = bin9.map(Integer.toString)\n   \
    \             val bin11 = bin10.reverse\n                val bin12 = bin11.toList\n\
    \                bin12.sortWith((x,y) => x-y)\n                })", "        //\
    \ Use a Map to record how many ones in each number\n        // For instance, a\
    \ number with 1 will be recorded as 1\n        // A number with 0 will be recorded\
    \ as 0\n        val oneCountMap = new mutable.HashMap[Long, Int]()\n        for\
    \ (a <- arr) {\n            val bin = Integer.toBinaryString(a)\n            if\
    \ (bin.length == 1) {\n                oneCountMap += (a -> 1)\n            }\
    \ else {\n                oneCountMap += (a -> bin.length)\n            }\n  \
    \      }\n        \n        // Sort the map and create an array to return\n  \
    \      val sortedMap = new TreeMap[Long, Int]()(oneCountMap)\n        val sortedArray\
    \ = sortedMap.map(kv => kv.key).toArray\n        val returnArray = Array.ofDim[Int](sortedArray.size)\n\
    \        System.arraycopy(sortedArray, 0, returnArray, 0, sortedArray.size)\n\
    \        returnArray", '        arr.toSeq.sorted.map { x => (x % 2) == 0l) ? x
    : -x }.toList', "        val oneBits = arr.map(x => (x & x.toString.toLong).map(x\
    \ => (x & x).toString.toLong).sum)\n        val decimal = arr.map(x => (x & x.toString.toLong).map(x\
    \ => (x & x).toString.toLong).sum).map(_.toDouble)\n        val result = (oneBits\
    \ zip decimal).sortBy(_._1).sortBy(_._2)\n        result.map(_._1)", "       \
    \ // Write your logic here\n        val map = arr.reduce{ (a,b) =>\n         \
    \   val key = a.toLong /+ (b :+ 1).toLong\n            (key, a) :+ (key -> b.toLong)\n\
    \        }\n        val result = arr.groupBy(_ / 2).toList.sortWith(a => a._1\
    \ < a._2 match {\n            case true => true\n            case false => false\n\
    \        }).map(a => a._2.sortWith(_.toLong < a._2.toLong).head).flatMap(a =>\
    \ a)\n        result", "        var arr = arr.toList\n        var arrSize = arr.size\n\
    \        arr.sortWith((x, y) => arr.count(_ == y) < arr.count(_ == x))\n     \
    \   arr", "        // If input array is empty, return empty array\n        if(arr.isEmpty)\
    \ arr.toList\n\n        // If there is only one element, return it\n        if(arr.size\
    \ == 1) arr\n\n        // Sort array from small to big\n        var big = 0\n\
    \        var small = arr.size-1\n        while(small != big)\n        {\n    \
    \        // If there is a tie in binary representation sort by decimal\n     \
    \       if(arr(small) == 1 && arr(big) == 0)\n            {\n                arr(small)\
    \ = arr(big)\n                arr(big) = arr(small)\n                arr(small-1)\
    \ = arr(big-1)\n                arr(big-1) = arr(small-1)\n                big\
    \ -= 1\n                small -= 1\n            }\n            // If there is\
    \ a tie in decimal sort by binary representation\n            else if(arr(small)\
    \ == 0 && arr(big) == 1)\n            {\n                arr(small) = arr(big)\n\
    \                arr(big) = arr(small)\n                arr(small-1) = arr(big-1)\n\
    \                arr(big-1) = arr(small-1)\n                big -= 1\n       \
    \         small -= 1\n            }\n            // If there is a tie in decimal\
    \ and binary representation, sort by decimal\n            else if(arr(small) ==\
    \ 1 && arr(big) == 1)\n            {\n                arr(small) = arr(big)\n\
    \                arr(big) = arr(small)\n                arr(small-1) = arr(big-1)\n\
    \                arr(big-1) = arr(small-1)\n                big -= 1\n       \
    \         small -= 1\n            }\n        }\n        arr", "        val numOnes\
    \ = arr.filter(_ != 0L).toList\n        val bins = numOnes.map(_.toString(2)).map(_.toChar)\n\
    \        val binLen = bins.map(_.length).sum\n        val binMap : mutable.Map[String,\
    \ List[String]] = bins.foldLeft(mutable.Map[(String, Int), List[String]]()) {\n\
    \            case (acc, bin) => acc + (bin -> List())\n        }\n        val\
    \ zeros = binMap.filter(_._2.isEmpty).map(_._1)\n        val ones = binMap.filter(_._2.nonEmpty).map(_._1)\n\
    \        val binLists = (0 until binLen).map(x => (x -> List(bins(x - binLen).take(bin(x))))).toList\n\
    \        val sortedBins = binLists.flatMap(x => x._2).map(x => (x -> x.head))\n\
    \        val zeroBins = zeros.map(x => (x -> x._2))\n        val oneBins = ones.map(x\
    \ => (x -> x._2))\n        val binMaps = zeroBins ++ oneBins ++ sortedBins\n \
    \       binMaps.flatMap(x => x._2.map(y => (y, x._1)))", "        val n = arr.size\n\
    \        var max = 0L\n        var numOnes = 0L\n        var sortedArray = arr.filterNot(_\
    \ < 0).toList\n\n        arr.foreach{\n            num =>\n            if( num\
    \ == 0 ) numOnes += 1\n            if( num == max) numOnes += 1\n            if(\
    \ numOnes > max ) max = numOnes\n        }\n\n        val ones = arr.filterNot(_\
    \ == 0)\n        val twos = arr.filterNot(_ == 1)\n        val tens = arr.filterNot(_\
    \ == 10L)\n        val hundreds = arr.filterNot(_ == 100L)\n        val thousands\
    \ = arr.filterNot(_ == 1000L)\n\n        ones = ones.sortWith(_.compareTo(_) >\
    \ 0).sorted\n        twos = twos.sortWith(_.compareTo(_) > 0).sorted\n       \
    \ tens = tens.sortWith(_.compareTo(_) > 0).sorted\n        hundreds = hundreds.sortWith(_.compareTo(_)\
    \ > 0).sorted\n        thousands = thousands.sortWith(_.compareTo(_) > 0).sorted\n\
    \n        sortedArray = ones ::: twos ::: tens ::: hundreds ::: thousands\n  \
    \      sortedArray", "        val ones = arr.filter(_.toInt == 1)\n        val\
    \ twos = arr.filter(_.toInt == 2)\n        val tens = arr.filter(_.toInt == 10)\n\
    \        val hundreds = arr.filter(_.toInt == 100)\n        val thousands = arr.filter(_.toInt\
    \ == 1000)\n        val tHundreds = arr.filter(_.toInt == 10000)\n        val\
    \ onesAndHundreds = ones + hundreds\n        val tensAndHundreds = tens + hundreds\n\
    \        val onesAndTensAndHundreds = ones + tens + hundreds\n        val onesAndHundredsAndHundreds\
    \ = ones + hundreds + hundreds\n        val onesAndHundredsAndTens = ones + hundreds\
    \ + tens\n        val onesAndHundredsAndTensAndHundreds = ones + hundreds + tens\
    \ + hundreds\n        val onesAndHundredsAndHundredsAndHundreds = ones + hundreds\
    \ + hundreds + hundreds\n        val onesAndHundredsAndHundredsAndTens = ones\
    \ + hundreds + hundreds + tens\n        val onesAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + hundreds + tens + hundreds\n        val onesAndHundredsAndHundredsAndHundredsAndTens\
    \ = ones + hundreds + hundreds + hundreds + tens\n        val onesAndHundredsAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + hundreds + hundreds + tens + hundreds\n        val onesAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + hundreds + tens + hundreds\n        val onesAndHundredsAndTensAndHundredsAndHundreds\
    \ = ones + hundreds + tens + hundreds + hundreds\n        val onesAndHundredsAndTensAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + tens + hundreds + hundreds + tens\n        val onesAndHundredsAndTensAndHundredsAndHundredsAndTensAndHundreds\
    \ = ones + hundreds + tens + hundreds + hundreds + hundreds + tens + hundreds\n\
    \        val onesAndHundredsAndTensAndH", "        if (arr.isEmpty || arr.head\
    \ < 0)\n            throw new RuntimeException(\"Input array cannot be empty or\
    \ negative elements.\");\n        var result = [];\n        var countOne = 0;\n\
    \        var countZero = 0;\n        for (i<- 0 until arr.size) {\n          \
    \  if (arr(i) == 1)\n                countOne += 1;\n            else\n      \
    \          countZero += 1;\n        }\n        for (i<- 0 until arr.size) {\n\
    \            if (countOne < countZero) {\n                if (arr(i) == 1) {\n\
    \                    countOne += 1;\n                } else {\n              \
    \      result += arr(i).toLong\n                }\n            } else if (countOne\
    \ == countZero) {\n                if (arr(i) == 0)\n                    countZero\
    \ += 1;\n                else\n                    result += arr(i).toLong\n \
    \           }\n        }\n        result", '        arr.sortWith(_>_)', "    \
    \    if (arr.isEmpty) arr\n        else if (arr.head == 0l) sortArray(arr.tail)\n\
    \        else {\n            val binStr = arr.map(x => (x.toBinary.length.toInt,\
    \ x)).toMap\n            val bins = binStr.sortWith((x,y) =>\n               \
    \ if (binStr(x) > binStr(y)) 1\n                else -1\n            )\n     \
    \       val arr1 = arr.map { x => bins(binStr(x).toInt) }\n            sortArray(arr1)\n\
    \        }", "        // convert array to a vector and sort it\n        val vecArr\
    \ = arr.toVector\n        vecArr.sortWith(compareNumber)", "        def count(a\
    \ : Long, b : Long) : Long = {\n            val ones = a & b\n            a ^\
    \ b ^ ones\n        }\n        val binary = arr.map( x => (count(x, 2l), x))\n\
    \        binary.sortBy(x => x._1)", '        arr.sortWith(compareToOne)', '        arr.sortWith((x,
    y) => if (x.toInt == 1) y.toInt else x.toInt - y.toInt)', "        val res =\n\
    \            if(arr.isEmpty)\n                List(arr.head.toLong)\n        \
    \    else\n                arr.head match {\n                    case 0l => sortArray(arr.tail)\n\
    \                    case _ if arr.head.signum == -1l =>\n                   \
    \     val l2 = List(arr.tail.head)\n                        val l3 = sortArray(arr.tail.tail)\n\
    \                        l2 ++ l3.map(x => x + l2.last)\n                    case\
    \ _ =>\n                        val l2 = List(arr.tail.head)\n               \
    \         val l3 = sortArray(arr.tail.tail)\n                        l2.reverse.tail.map(x\
    \ => x + l2.last)\n                }\n        res", "        val res = arr.sortWith(\
    \ (l, r) => {\n            if (l = 0L) {\n                if (r = 1L) return 1L\n\
    \                else if (r = 0L) return -1L\n                else return 0L\n\
    \            }\n            else if (r = 0L) {\n                if (l = 1L) return\
    \ 1L\n                else if (l = 0L) return -1L\n                else return\
    \ 0L\n            }\n            else if (l > r) {\n                if (l == 0L)\
    \ return 0L\n                else if (r == 1L) return 1L\n                else\
    \ if (r == 0L) return -1L\n                else if (l == 1L) return 1L\n     \
    \           else if (l == 0L) return -1L\n                else return 0L\n   \
    \         }\n            else if (l < r) {\n                if (l == 0L) return\
    \ -1L\n                else if (r == 1L) return 1L\n                else if (r\
    \ == 0L) return 0L\n                else if (l == 1L) return 1L\n            \
    \    else if (l == 0L) return 0L\n                else return -1L\n          \
    \  }\n            else return 0\n        })\n        val resultArr = new mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 0 until res.size) {\n            resultArr += (res(i))\n  \
    \      }\n        resultArr", '        arr.sortWith(_.compareTo(_.toBinaryString)
    == 0)', "        if (arr.length == 0) arr\n        else {\n            val ones\
    \ = arr.count(_ == 1)\n            val negatives = arr.count(_ < 0)\n        \
    \    val zeros = arr.count(_ == 0)\n            val base = (ones + negatives +\
    \ zeros).toLong\n            val base2 = base.toString + base.toString\n     \
    \       val onesBase = base2.indexOf(\"1\")\n            val negativesBase = base2.indexOf(\"\
    0\")\n            val zerosBase = base2.lastIndexOf(\"0\")\n            val negativesOnesBase\
    \ = base2.lastIndexOf(\"1\", negativesBase)\n            val zerosOnesBase = base2.lastIndexOf(\"\
    0\", zeros)\n            val negativesOnesBase2 = base2.indexOf(\"1\", negativesOnesBase)\n\
    \            val zerosOnesBase2 = base2.indexOf(\"0\", zerosOnesBase)\n      \
    \      val negOnesBase = base2.indexOf(\"1\", negativesOnesBase2)\n          \
    \  val negOnesBase2 = base2.indexOf(\"0\", negOnesBase)\n            val negOnesBase3\
    \ = base2.lastIndexOf(\"1\", negOnesBase2)\n            val negOnesBase3 = base2.lastIndexOf(\"\
    0\", negOnesBase3)\n\n            val arr2 = arr.reverse\n            val arr3\
    \ = arr2.reverse\n            val arr4 = arr3.reverse\n            val arr5 =\
    \ arr4.reverse\n\n            var arr = arr\n            while (arr.length !=\
    \ 0) {\n                val nextOne = arr.find(_ == 1)\n                val nextNegative\
    \ = arr.find(_ < 0)\n                val nextZero = arr.find(_ == 0)\n       \
    \         val nextBase = (nextOne + nextNegative + nextZero).toLong\n        \
    \        val nextBase2 = nextBase.toString + nextBase.toString\n             \
    \   val nextOnesBase = nextBase2.indexOf(\"1\")\n                val nextNegativesBase\
    \ = nextBase2.indexOf(\"0\")\n                val nextZerosBase = nextBase2.lastIndexOf(\"\
    0\")\n                val nextNegativesOnesBase = nextBase2.lastIndexOf(\"1\"\
    , nextNegativesBase)\n                val nextZerosOnesBase = nextBase2.lastIndexOf(\"\
    0\", nextZerosBase)\n                val nextNegativesOnesBase2 = nextBase2.indexOf(\"\
    1\", nextNegativesOnesBase)\n                val nextZerosOnesBase2 = nextBase2.indexOf(\"\
    0\", nextZerosOnesBase)\n                val nextNegOnesBase = nextBase2.indexOf(\"\
    1\", nextNegative", "        val map = mutable.Map[Long, List[Long]]()\n     \
    \   arr.foreach{a => val b = bin(a)\n                       if(map.getOrElse(b,\
    \ 0).getOrElse(0) <= 1) map += a -> b\n                       else map += b ->\
    \ a }\n        val m = map.toSeq.sortWith((x,y) => x._2 > y._2)\n        m.toList",
  "        var arr1 = arr.toSet\n        arr1 = arr1.filter(_ != 0).toSet\n      \
    \  arr1 = arr1.map(_ / 2).toSet\n        arr1 = arr1.sortBy(identity).sorted\n\
    \        arr1.toList", '        //Write your code here', "        var result =\
    \ arr.sortBy(x => -math.log2(x % 1L))\n        for (i <- 0 until arr.length)\n\
    \            if (math.log2(arr(i) % 1L) == math.log2(result(i) % 1L))\n      \
    \          result = result.sortWith((x, y) => x - y)\n        result", "     \
    \   var res = arr.sortWith(greaterThan(_, _)) // sorts the array with the right\
    \ order\n        val i = res(0).toInt // pick the first value\n        var inv\
    \ = -1\n        for(j <- 1 to res.size - 1) \n            if(res(j).toInt == i)\n\
    \                inv += 1\n            else\n                if(res(j).toInt ==\
    \ i) res(j) <- res(j) - inv\n        res", '      arr.sortWith(compareTwoOnesFirst)',
  "        var zeros : List[Long] = Nil\n        var ones : List[Long] = Nil\n   \
    \     var numOfOnes = 0\n        var sortedList : List[Long] = Nil\n        for(i\
    \ <- arr) {\n            if(i < 0l) {\n                if(numOfOnes <= 0) {\n\
    \                    ones = List(i)\n                }\n                else {\n\
    \                    zeros = List(i)\n                }\n                numOfOnes\
    \ = 1\n            }\n            else if(i > 0l) {\n                if(numOfOnes\
    \ <= 0) {\n                    zeros = List(i)\n                }\n          \
    \      else {\n                    ones = List(i)\n                }\n       \
    \         numOfOnes += 1\n            }\n        }\n\n        if(numOfOnes > 0)\
    \ {\n            sortedList = ones\n        }\n        else {\n            sortedList\
    \ = zeros\n        }\n\n        sortedList", '        arr.sortWith((a,b) => if(b==0)
    a else b).reverse', '        arr.map(x => (arr.count(y => (x & y) == x) + x.toInt,
    x)).sortBy(_._1).map(x => x._2)', "        val n = arr.size\n        val bin =\
    \ arr.map(x => (x.toString.toInt, (x.toString map {\n          case '1' => 1\n\
    \          case '0' => 0\n        }).sum)).toList\n        val dec = bin.map(x\
    \ => x._2 / 10).sortBy(x => x).toList\n        val sorted = dec.map(x => bin.find(y\
    \ => y._1 < (x - x) / x.toLong * x.toLong) == Some(y))\n        if (sorted.size\
    \ == n) {\n            sorted\n        } else {\n            sortArray(sorted)\n\
    \        }", '        arr.sortBy(elem => arr.count(i => i & elem == i))', "  \
    \      val ones = arr.filter(x => x.toInt == 1)\n        val zeros = arr.filter(x\
    \ => x.toInt == 0)\n        val oneAndZeros = ones.toList ++ zeros.toList\n  \
    \      val sortList = oneAndZeros.sortWith((x,y) => x.toLong > y.toLong)\n   \
    \     sortList.toList", '        arr.sortWith(_ < _)', "        var ones = mutable.MutableList[Long]()\n\
    \        var decimals = mutable.MutableList[Long]()\n        for (i <- 0 until\
    \ arr.size) {\n            val binary = arr(i).toBinaryString\n            ones\
    \ += if(binary.contains(\"1\")) 1l else 0l\n            decimals += if(binary.contains(\"\
    1\")) arr(i) else None\n        }\n        ones.toList", "        val ones = arr.map(x\
    \ => if (x == 1l.toLong) 1\n        else 0l).toList\n        val zeros = arr.filter(_\
    \ == 0l.toLong).toList\n        val onesZeros = arr.zip(ones).zip(zeros)\n   \
    \     val sortedArr = onesZeros.sortWith { (a, b) => a._2 < b._2 }\n        val\
    \ sortedZeros = sortedArr.filter(_._1 == 0l.toLong).toList\n        val sortedOnes\
    \ = sortedArr.filter(_._1 == 1l.toLong).toList\n        val sortedListOfOnesZeros\
    \ = sortedZeros.zip(sortedOnes)\n        val zeroIndex = sortedListOfOnesZeros.filter(_._2\
    \ == 1l.toLong).toList\n        val oneIndex = sortedListOfOnesZeros.filter(_._2\
    \ == 0l.toLong).toList\n        val zerosAndOnes = sortedArr.zip(zeroIndex).zip(oneIndex)\n\
    \        val sortedZeroAndOnes = sortedZeroAndOnes.sortWith { (a, b) => a._1 <\
    \ b._1 }\n        sortedZeroAndOnes.filter(_._1 == 0l.toLong).map(_._2).toList.zip(onesZeros).map(_._1).toList",
  "        arr.sortBy(l => l % 2l.toLong) ++\n            arr.sortBy(l => l.toInt).reverse",
  "        val ones = arr.filter(_ % 2 == 0).size\n        val negs = arr.filter(_\
    \ % 2 == 1).size\n\n        if(ones > negs) {\n            arr.sortBy(x => (x\
    \ - ones).toInt)\n        } else if (negs > ones) {\n            arr.sortBy(x\
    \ => (x + negs).toInt)\n        } else {\n            arr.sortBy(x => (x - negs).toInt)\n\
    \        }", "        arr.zipWithIndex.sortBy(l => {\n            if (l._1 ==\
    \ 0) -1 else l._1.bitLength\n        }).map(x => x._2).map(x => x.toLong).reverse",
  "        val n = arr.length\n        val ones = arr.zipWithIndex.filter(x => x._1\
    \ == 1)\n        val zeros = arr.zipWithIndex.filter(x => x._1 == 0)\n       \
    \ val oneInd = ones.map(x => x._2).sortBy(x => x.toLong)\n        val zeroInd\
    \ = zeros.map(x => x._2).sortBy(x => x.toLong)\n        val onedArr = oneInd.map(_\
    \ => arr(_))\n        val zerodArr = zeroInd.map(_ => arr(_))\n        val maxOneCount\
    \ = ones.maxBy(x => x._2)._2.toLong\n        val maxZeroCount = zeros.maxBy(x\
    \ => x._2)._2.toLong\n        val resultArr = (zeroInd.toList zip oneInd.toList).sortBy(x\
    \ => {\n            val oneCount = x._2.toLong\n            val zeroCount = x._1.toLong\n\
    \            oneCount / maxOneCount > zeroCount / maxZeroCount ? oneCount : zeroCount\n\
    \        }).map(_._1)\n        resultArr.map(x => arr(x))", "        arr.toList\
    \ match {\n            case head :: tail =>\n                val m = head % 2\n\
    \                val ones = arr.filter(x => x % 2 == 0).toList.sorted\n      \
    \          if (ones.length == 1) head else (head + ones(0))\n            case\
    \ _ => arr.toList\n        }", "        arr.sortWith(a => a < (arr.last) match\
    \ {\n            case true => false\n            case false => true\n        })",
  "        // your code goes here\n        arr.foldLeft(List[Long]())(_ ++ sortArray(_))",
  "        var arrList = arr\n        var newArrList = List[Long]()\n        for (i\
    \ <- 0 until arrList.size) {\n            if (arrList(i) == 0) {\n           \
    \     newArrList ::= arrList(i)\n            } else {\n                val m =\
    \ ((arrList(i) - 1) >>> 0).toInt\n                newArrList ::= (m << 1) | arrList(i)\n\
    \            }\n        }\n        return newArrList", "        var ans = arr.toList\n\
    \        var max = 0L\n        var i = 0\n        while (i < arr.length) {\n \
    \           if (ans.lastOption.isDefined) {\n                max = ans.lastOption.get\
    \ + max\n            }\n            ans += (i.toLong + max / 2).toLong\n     \
    \       i += max\n            max /= 2\n        }\n        ans", "        var\
    \ maxVal = 0L\n        var maxIdx = 0\n        var i = 0\n        for(l <- arr)\
    \ {\n            val current = l\n            var j = i\n            for(k <-\
    \ i + 1 to arr.length) {\n                if(current & (1L << k).toLong == current)\
    \ {\n                    j -= 1\n                }\n            }\n          \
    \  var temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            maxVal = Math.max(maxVal, arr(i))\n            if(maxVal == current)\
    \ {\n                maxIdx = j\n            }\n            i += 1\n        }\n\
    \        arr.drop(maxIdx).reverse", "        if (arr.isEmpty) arr\n        else\
    \ if (arr.head < 0 && arr.tail.head < 0) arr.head :: sortArray(arr.tail)\n   \
    \     else if (arr.head < 0 && arr.tail.head >= 0) arr.head :: sortArray(arr.tail.reverse)\n\
    \        else if (arr.head >= 0 && arr.tail.head < 0) sortArray(arr.tail)\n  \
    \      else if (arr.head >= 0 && arr.tail.head >= 0) sortArray(arr.tail.reverse)\n\
    \        else arr", '        arr.sortWith((x, y) => x.toLong compareTo y.toLong)',
  "        arr.sortWith(x => {\n            val binStr = x.toString\n            val\
    \ bin = binStr.length.toLong\n            val ones = binStr.count('1')\n     \
    \       val dec = (bin.toLong - ones) / 2\n            if (ones == bin) true else\
    \ dec > x\n        })", "        var sortedArr = arr.toList\n        sortedArr.sortBy(x\
    \ => (-(x%2l).compareTo(x)))\n        sortedArr", "        if (arr.isEmpty) {\n\
    \            return arr\n        }\n        var list = arr.toList\n        list.sortWith((x,\
    \ y) => if (x % 2 == 0 && y % 2 == 0) {\n            x - y\n        } else if\
    \ (y % 2 == 0) {\n            y - x\n        } else {\n            x - y\n   \
    \     })\n        list.toArray", "        val l = arr.length\n        val m =\
    \ 2l\n        var i = 0\n        val r = arr\n        var j = l-1\n        var\
    \ k = m-1\n        while (i != j){\n            while ((k <= l) && (r.head(k).asInstanceOf[Long]==1)){\n\
    \                k += 1\n            }\n            val temp = r.tail(k)\n   \
    \         r.tail(k) = r.tail(j)\n            r.tail(j) = temp\n            j +=\
    \ 1\n            i -= 1\n            k += 1\n            k += 1\n        }\n \
    \       arr", "        // TODO: Write code here\n        var arr1 = arr.map(_\
    \ => 0)\n        var arr2 = arr.map(_ => 0)\n        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        while(i < arr.length && j < arr.length) {\n\
    \            arr1(i) = arr(i)\n            arr2(j) = arr(j)\n            if(arr1(i)\
    \ == arr2(j)) {\n                arr1(i) += 1\n                arr2(j) += 1\n\
    \                i += 1\n                j += 1\n            } else if(arr1(i)\
    \ < arr2(j)) {\n                arr1(k) = arr1(i)\n                arr1(i) +=\
    \ 1\n                k += 1\n            } else {\n                arr2(k) = arr2(j)\n\
    \                arr2(j) += 1\n                k += 1\n            }\n       \
    \ }\n        if(i < arr.length) {\n            for(x <- 0 until i) {\n       \
    \         arr1(k) = arr1(x)\n                arr2(k) = arr2(x)\n             \
    \   k += 1\n            }\n        }\n        if(j < arr.length) {\n         \
    \   for(x <- 0 until j) {\n                arr1(k) = arr1(x)\n               \
    \ arr2(k) = arr2(j)\n                k += 1\n            }\n        }\n      \
    \  arr1.toList", "        var result = Array[Long](arr.size)\n        var count\
    \ = 0\n        arr.foreach(num => {\n            if (num == -1l.toLong) count\
    \ = 0\n            if (num == -2l.toLong) count = -1\n            count = count\
    \ + 1\n            if (count == 0) result = result.updated(count, num)\n     \
    \   })\n        result", "        var result: List[Long] = Nil\n        var oneCounts\
    \ = mutable.Map[Long, Long]()\n        var negCounts = mutable.Map[Long, Long]()\n\
    \        for(i <- 0 until arr.size) {\n            val i = arr(i)\n          \
    \  if(i < 0) {\n                negCounts += (i.toLong -> 1L)\n            } else\
    \ {\n                oneCounts += (i.toLong -> 1L)\n            }\n        }\n\
    \        val negCount = negCounts.toSeq.sortBy(_._1).reverse\n        val oneCount\
    \ = oneCounts.toSeq.sortBy(_._1).reverse\n        oneCount ::: negCount ::: result",
  "        val len = arr.length\n        val map = new mutable.LinkedHashMap[Long,\
    \ Long]()\n        for(i <- 0 until len) {\n            map.put(arr(i), map.getOrElse(arr(i),\
    \ 0l))\n            map.put(arr(i), map.get(arr(i))+1)\n        }\n        val\
    \ res = new mutable.ArrayBuffer[Long]()\n        for(i <- 0 until len) {\n   \
    \         if(map.get(arr(i)) != 0) {\n                res.insert(i, arr(i))\n\
    \            }\n        }\n        res", '        arr.sortWith(_ == 0) || (arr.sortWith(_
    == 1) || (arr.sortWith(_ > 0) && arr.sortWith(_ > 1)))', "        val sortedList\
    \ = mutable.ArrayBuffer.empty[Long]\n        arr.foreach(x=>\n            if(x>0){\n\
    \                sortedList += x\n            }\n        )\n        val sortedList\
    \ = sortedList.sorted\n        val reverseList = sortedList.map(x=>(x>>>1).map(x=>x*2-(x*2>>>1)+1).reduceLeft((x,y)=>(x*2+1)+y)\n\
    \        return reverseList.toList", "        arr\n            .sortBy(x => countOnes(x))\n\
    \            .sortBy(x => x.toDouble / 10)", "        arr.sortBy { x =>\n    \
    \        val bs = x.toBinaryString\n            val bits = bs.substring(bs.length\
    \ - 1, bs.length)\n            val ones = bits.toLong\n            val num = ones\
    \ - 1\n            if(num == 0) num else num.toInt\n        }", "        val n\
    \ = arr.length\n        val m = n\n        val s = arr.head\n        val v = arr.tail\n\
    \n        // 1. Get sorted index for every number\n        // 2. Get sorted value\
    \ for every index\n        // 3. Rearrange the list\n        val newArr = new\
    \ Array[Long](m)\n        for( i <- 0 until m )\n            newArr(i) = i\n\n\
    \        var sortedIdx = 0\n        var sortedVal = s\n        var i = 0\n   \
    \     while( i < n ) {\n            var j = 0\n            while( j < m ) {\n\
    \                if( arr(i) < arr(j) ) j++\n                else {\n         \
    \           if( sortedIdx == j ) {\n                        sortedVal = arr(j)\n\
    \                        sortedIdx = i\n                    }\n              \
    \      newArr(i) = arr(j)\n                    newArr(j) = 0\n               \
    \     j++\n                }\n            }\n            i++\n        }\n    \
    \    newArr.toList", '        arr.sortWith(a => a._2 > a._1)', '        arr.foldLeft(List.empty[Long])
    { (acc, x) => acc append (x :: acc.lastOption.getOrElse(List.empty[Long])) }',
  "        val arr = arr.sortWith { (a, b) => if (a==1) 1l else -1l }\n        //\
    \ Sorting by decimal value\n        if (arr.isEmpty) arr\n        else {\n   \
    \         val cur = arr(1)\n            val curNum = arr.sum\n            val\
    \ prev = arr(0)\n            val prevNum = arr.sum * -1\n            val prevBin\
    \ = \"0\"\n            val curBin = Array(prevBin.length, 0).map(\"0\").toList\n\
    \            val arr = arr.tail\n            val bin = arr.map(_.toString.toBinaryString).toList\n\
    \            val diff = 1\n            while (diff > 0 && bin.length > 1) {\n\
    \                val preBin = bin.tail\n                val preNum = bin.sum\n\
    \                val curBin = preBin.reverse.zipWithIndex.foldLeft(\"0\") {\n\
    \                    case ((str, i), v) =>\n                        if (i < preBin.length)\
    \ str ++ v.toString else str\n                }\n                val curNum =\
    \ preNum * -1\n                val diff = curNum - prevNum\n                prev\
    \ = cur\n                prevBin = preBin.reverse\n                prevNum = preNum\n\
    \                curBin = preBin.reverse.zipWithIndex.foldLeft(\"0\") { case ((str,\
    \ i), v) =>\n                    if (i < preBin.length) str ++ v.toString else\
    \ str\n                }\n                bin = bin.tail\n            }\n    \
    \        Array(prev, curBin.reverse, diff, arr).filter(_ != 0).toList\n      \
    \  }", "        val s = arr.map(v => v.asInstanceOf[Long] & (1 << v.asInstanceOf[Long])\
    \ - 1)\n        val m = s.sortWith(_ < _)\n        val r = m.toList + m.head\n\
    \        r.sortWith(_ > _)", "        val ones = arr.count(_ == 1).toLong\n  \
    \      val zeros = arr.count(_ == 0).toLong\n        if (ones <= zeros) {\n  \
    \          val s = arr.sortWith(_ < _)\n            s\n        } else {\n    \
    \        val d = arr.map(x => x.toString.toInt).sorted\n            val r = d.zip(ones.to(1).toLong).takeWhile(_._2\
    \ != 0).map(_._1)\n            r.sorted\n        }", "        val sortedArray\
    \ = arr sortWith { case (b1, b2) =>\n            b1.toLong match {\n         \
    \       case 0 => b2.toLong\n                case 1 => 1\n                case\
    \ _ => b1.toLong.toInt*10 + b2.toLong\n            }\n        }\n        sortedArray",
  '        arr.sortWith(compareTo)', "        arr.map { x =>\n            val temp\
    \ = x.toBinaryString\n            val numOnes = temp.takeWhile(_ != '0').length\n\
    \            val decimal = Integer.parseInt(temp.dropWhile(_ != '0').mkString)\n\
    \            (numOnes, decimal)\n        } sortBy { case (a, b) => a._1 } // Sort\
    \ the array by number of ones\n            .map { case (a, b) =>\n           \
    \     // If two elements have same number of ones, sort by their decimal value\n\
    \                if (a == b) a._2\n                // If two elements have different\
    \ number of ones, sort by their decimal value reversed\n                else b._2\n\
    \            } sortBy { case (a, b) => a } // Sort the array by decimal\n    \
    \        .map { case (a, b) => a }\n            .toList", "        val numOnes\
    \ = arr\n            .map{ x => (x >>> 0l) }\n            .distinct\n        \
    \    .foldLeft(mutable.BitSet(0l,arr.length){\n                case (acc, x) =>\
    \ acc.or(x)\n            }) \n        val maxOnes = numOnes.count(x => x != 0l)\n\
    \        val bin = arr.map(x => (x >>> 0l).toInt)\n        val dec = (numOnes\
    \ zip bin).sortWith((x,y) => x > y)\n        val arr2 = dec.map{\n           \
    \ case (x, y) => (x * maxOnes) + y\n        }\n        arr2", "        val map\
    \ = new mutable.HashMap[Long, Int]()\n        for(num <- arr){\n            val\
    \ b = new BigInteger(Integer.toBinaryString(num))\n            if(map.containsKey(b)){\n\
    \                map.update(b, (map.get(b)+1))\n            }else{\n         \
    \       map.update(b, 1)\n            }\n        }\n        val list = arr.sorted((b1,\
    \ b2) => map.get(b1).compareTo(map.get(b2)))\n        list.map(x => x.toLong)",
  "        // sort by binary representation length\n        val binArr = arr.sortBy(x\
    \ => (x.length.bits.toLong, x))\n\n        // sort by decimal value\n        binArr.sortBy(x\
    \ => -x.toString.toDouble.toInt)", "        val res = arr.sortWith( (x, y) =>\
    \ x < y )\n        res.reverse", '        arr.sortWith(compare)', '        arr.sortWith(_
    < _)', "        val arr0 = arr.toArray.sortWith((x, y) => math.abs(x - y) < 0)\n\
    \        val arr1 = arr0.map(x => ((x * 8).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        val arr2 = arr1.map(x => ((x * 16).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        val arr3 = arr2.map(x => ((x * 32).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        val arr4 = arr3.map(x => ((x * 64).ceil.toInt, x)).sortBy(_._1).map(_._2)\n\
    \        arr4.toList", "        val ones = arr.filter(_==1).toList\n        val\
    \ zeros = arr.filter(_==0).toList\n        if (ones.isEmpty) zeros\n        else\
    \ if (zeros.isEmpty) ones\n        else {\n            val (minus, plus) = ones.minBy(x\
    \ => x.toBinaryString).splitAt(ones.size - 1)\n            val sortedZeros   \
    \ = sortArray(zeros)\n            val sortedOnes     = sortArray(plus)\n     \
    \       (sortedZeros ++ sortedOnes)\n                .sortBy(x => x.toDouble)\n\
    \                .zipWithIndex\n                .filter(_._2==0)\n           \
    \     .map(_._1)\n        }", "        arr.foldLeft((List[Long](), List[Long]()))((acc,\
    \ x) => {\n            val l = acc._2.last + acc\n            if (x == 1l.toLong)\
    \ acc._1 :+ (acc._2.last + x)\n            else acc._2 :+ (l * x)\n        })",
  "        val bin = arr.map(n => math.pow(2,n).toInt).toList\n        val sorted\
    \ = bin.sortBy(x => math.floor(math.pow(2,x).toInt))\n        bin.foldLeft(List(Long(0l,0l,0l,0l,0l,0l,0l)))\
    \ { case (acc, n) => acc.zip(sorted.drop(acc.length-1)).collect { case (a, b)\
    \ => if(a == n) b else Long(math.pow(a,b)).toLong }.toList }", '      arr.sortBy{case
    i => (arr.count(_ == i.toBinaryString) - arr.count(_ == i.toBinaryString.reverse))
    => i.toBinaryString.reverse}', "        val ones = arr.filter(_ == 1).length\n\
    \        val zeros = arr.filter(_ == 0).length\n        val minOne = math.min(ones,\
    \ zeros)\n        if(minOne > ones)\n        { arr.sortWith(_ < _) }\n       \
    \ else if(minOne == ones)\n        {\n            arr.sortWith(_ < _)\n      \
    \  }\n        else\n        { arr.sortWith(_ < _) }", "        val ones = new\
    \ Array[Int](arr.length).fill(0)\n        val twos = new Array[Int](arr.length).fill(0)\n\
    \        val decs = new Array[Long](arr.length).fill(0l)\n        val decOnes\
    \ = new Array[Long](arr.length).fill(0l)\n        for (i<- 0 until arr.length)\
    \ {\n            val bin = arr(i).toString.toUpperCase\n            val i = bin.indexOf(\"\
    1\")\n            val j = bin.indexOf(\"2\")\n            val k = bin.indexOf(\"\
    3\")\n            val l = bin.indexOf(\"4\")\n            ones(i) = 1\n      \
    \      twos(i) = 2\n            decs(i) = bin.substring(0, i).toLong\n       \
    \     decOnes(i) = decs(i) * ones(i)\n        }\n        val sorted = decs.map(dec\
    \ => dec / decOnes.sum).toList.sort\n        val sortedOnes = ones\n        val\
    \ res = sortedOnes.zip(sorted).map(x => arr(x._1) + x._2).reverse\n        res",
  '        // TODO: Implement this using sortWith', "        // Sort arr by number\
    \ of ones in binary representation.\n        // If there are multiple ones in\
    \ binary representation,\n        // sort the ones with lower decimal value.\n\
    \        // If there are equal number of ones in binary representation\n     \
    \   // and equal number of ones in decimal value,\n        // then sort the ones\
    \ with lower binary value.\n        // If there are equal number of ones in binary\
    \ representation\n        // and different number of ones in decimal value,\n\
    \        // then sort the ones with lower decimal value.\n        arr.sortWith((x,\
    \ y) => x.toInt == y.toInt * 2)", "        val ls = arr.map(x => (x, x.toBinaryString))\n\
    \        ls.toList.sortBy(x => x(1)).map(x => x(1))", "        // Implement here\n\
    \        arr.sortBy(_ / 2)", '        arr.sortBy(_.binary.size)', '        if
    (arr.isEmpty) arr.head else arr.sorted.map(x => (x -> (arr.count(y => y & x) ==
    x)))', "        var newArr: List[Long] = new Array[Long](arr.length)\n       \
    \ var sum = 0\n        var i = 0\n        while(i < arr.length) {\n          \
    \  sum = sum + (arr(i).toLong)\n            i += 1\n        }\n        var i =\
    \ 0\n        while(i < arr.length) {\n            val j = (sum - arr(i).toLong).toInt\n\
    \            newArr(j) = arr(i)\n            i += 1\n        }\n        return\
    \ newArr", "        if (arr.length == 0) return arr\n        val ones = arr.filter(_\
    \ == 1l).toSet\n        if (ones.size == 0) return arr\n        var onesSorted\
    \ = arr.filter(x => ones(x) == true).toList\n        var reSorted = 0L\n     \
    \   var onesIndex = 0\n        while (onesIndex < onesSorted.length) {\n     \
    \       if (reSorted == 0L) {\n                reSorted = onesSorted(onesIndex)\n\
    \                onesIndex += 1\n            } else if (onesSorted(onesIndex)\
    \ < reSorted) {\n                onesSorted(onesIndex) = reSorted\n          \
    \      onesIndex += 1\n                reSorted = 0L\n            } else {\n \
    \               var temp = onesSorted(onesIndex)\n                onesSorted(onesIndex)\
    \ = reSorted\n                reSorted = temp\n                onesIndex += 1\n\
    \            }\n        }\n        onesSorted.toList", '        arr.sortWith(_
    < _)', "        arr.reverse.foldLeft(arr.sortWith((x, y) => x < y)) {\n      \
    \      (acc: List[Long], x: Long) => {\n                if (acc.length == 0)\n\
    \                    List(x)\n                else if (x % acc.head.isOne)\n \
    \                   acc :+ acc.head\n                else\n                  \
    \  x match {\n                        case 0 => acc :+ acc.head\n            \
    \            case i => acc :+ (acc.head.dec * i)\n                    }\n    \
    \        }\n        }.reverse", "        var result: List[Long] = Nil\n      \
    \  for (n <- arr) {\n            if(n != 0) {\n                val bin = n.toBinaryString()\n\
    \                val decimal = bin.filter(_ == '1').length\n                if\
    \ (result contains decimal) {\n                    result = result.sortBy(_ -\
    \ decimal)\n                } else {\n                    result = result :::\
    \ List(decimal)\n                }\n            }\n        }\n        result :::\
    \ arr.sortBy(_ - arr.max)", "        // Sort the arr array in ascending order\
    \ using the number of ones\n        val zeros = arr.count(_ == 0)\n        if\
    \ (zeros > 0) {\n            val sortedArray = arr.toList.sortBy(x => -x % zeros)\n\
    \            val zeroIndex = arr.indexOf(zeros)\n            val result = sortedArray.drop(zeroIndex).reverse.take(zeroIndex+1).reverse.take(arr.length).toList.reverse\n\
    \            result\n        } else {\n            arr.toList\n        }", " \
    \       if (arr.size < 2) arr\n        else {\n            val twos = arr.filter(_\
    \ % 2 == 0)\n            val ones = arr.filter(_ % 2 == 1)\n            sortArray(ones)\
    \ ++ sortArray(twos)\n        }", '        arr.sortWith((x,y) => if (x%2==0) y
    < x else x < y)', "        def getBitCount(arr : List[Long]) : Map[Long, Long]\
    \ = {\n            val bitCount = mutable.Map.empty[Long, Long]\n            for\
    \ (elem <- arr) {\n                val binVal = elem.toBinaryString\n        \
    \        bitCount += binVal -> binVal.length\n            }\n            bitCount\n\
    \        }\n        val bitCount = getBitCount(arr)\n        val sortedBitCount\
    \ = bitCount.toSeq.sortBy(_._1)\n        val sortedLongCount = sortedBitCount.map\
    \ {\n            elem => (elem._2, elem._1)\n        }.toMap\n        arr.map(elem\
    \ => sortedLongCount(elem))", "        val m = arr.foldLeft(1L) {\n          \
    \  (m,v) =>\n                val m = m + 1\n                ((m.toInt, v.toInt))\n\
    \        }._1\n        arr.sortWith(compare(arr,m))", '        arr.sortWith(_
    >= _)', "        val bins = arr.map { i => Integer.toBinaryString(i) }\n     \
    \   val counts = bins.groupBy(_.length).mapValues(_.length).toMap\n        bins.map\
    \ { bin =>\n            val idx = counts.get bin.length\n            val vals\
    \ = bin.drop(idx)\n            val ones = bin.take(idx)\n            val pos =\
    \ ones.mkString(\".\").length\n            vals zip ones map { case (v, o) =>\n\
    \                if(v == o) v.toLong else if (v.length < ones.length) ones(v.length\
    \ - pos - 1) else v.charAt(v.length - ones.length) + o\n            }\n      \
    \  }", '        arr.sortWith(compare)', "        var bin = arr.map(_.toString(2)).map(x\
    \ => x % 2 == 0).map(x => x.toLong)\n        bin.sortWith(x => x._1 < x._2)\n\
    \        bin.reverse", '        arr.sortWith(x => isOnes(x)).sortWith(x => isNegative(x))',
  "        val result = new mutable.ListBuffer[Long]()\n        for (i <- arr.length)\
    \ {\n            result.clear()\n            i match {\n                case 0\
    \    => result.add(i)\n                case 1    => result.add(i + arr.length)\n\
    \                case 2    => result.add(i * 2 + arr.length)\n               \
    \ case 3    => result.add(i * 3 + arr.length)\n                case 4    => result.add(i\
    \ * 4  + arr.length)\n                case _    => println(\"Invalid element:\
    \ \" + i)\n            }\n            var ones = 0\n            var decimal =\
    \ 0\n            var j = 0\n            var maxDecimal = 0\n            while\
    \ (j < arr.length) {\n                ones += arr(j)\n                decimal\
    \ += arr(j)\n                j += 4\n                maxDecimal = if (maxDecimal\
    \ < decimal) decimal else maxDecimal\n            }\n            var onesNeg =\
    \ false\n            var zerosNeg = false\n            while (j < arr.length)\
    \ {\n                onesNeg = !ones\n                zerosNeg = !arr(j)\n   \
    \             if (onesNeg && zerosNeg) {\n                    result.add((decimal\
    \ * -1).toLong + arr.length)\n                    decimal = 0\n              \
    \      maxDecimal = 0\n                } else {\n                    result.add(ones\
    \ ? arr(j) : arr.length)\n                    ones = false\n                }\n\
    \                j += 4\n                maxDecimal = if (maxDecimal < decimal)\
    \ decimal else maxDecimal\n            }\n            result.addAll(arr(arr.length\
    \ - maxDecimal.toInt))\n            result.sortWith(compareNumbers)\n        }\n\
    \        result.toList", "        val bitSet = arr.map(v => (v.toInt, v.toBinaryString)).toMap\n\
    \        val bitSet2 = arr.map(v => (v.toInt, v.toString.reverse)).toMap\n   \
    \     val keys = arr.filter(v => (v.toInt == 0)).sorted\n        val vals = arr.filter(v\
    \ => (v.toInt == 1)).sorted\n        val bits = arr.map(v => (v.toInt, v.toBinaryString)).toMap\n\
    \        val bits2 = arr.map(v => (v.toInt, v.toString.reverse)).toMap\n     \
    \   if (arr.size == 0) arr.toList\n        else {\n            val list = new\
    \ mutable.ListBuffer[Long]()\n            val ones = mutable.ListBuffer[Int]()\n\
    \            val zeros = mutable.ListBuffer[Int]()\n            var count = 0\n\
    \            keys.foreach { k =>\n                val res = bits.get(k)\n    \
    \            val res2 = bits2.get(k)\n                if (res != 0) {\n      \
    \              if (count > 0) list.add(count, \"1\")\n                    ones\
    \ += res.toInt\n                }\n                if (res2 != 0) {\n        \
    \            if (count > 0) list.add(count, \"0\")\n                    zeros\
    \ += res2.toInt\n                }\n                count += 1\n            }\n\
    \            val zeros = zeros map {\n                case 0 => 0\n          \
    \      case 1 => -1\n                case _ => 0\n            }\n            val\
    \ ones = ones map {\n                case 0 => -1\n                case 1 => 0\n\
    \                case _ => 0\n            }\n            val diff = zeros diff\
    \ ones\n            val index = diff zip (ones) filter (_ == -1) map {\n     \
    \           case (val, 1) => val\n                case (val, -1) => val\n    \
    \        }\n            val zero = diff.toSet map {\n                case val\
    \ => val // or val.toInt, which is not the same as val => val.toInt\n        \
    \    }\n            val one = ones - zero\n            val sortedKeys = index\
    \ map (_ + key)\n            val zeros = zero map (one)\n            val result\
    \ = sortedKeys ++ zeros\n            list.toList\n        }", "        if (arr.isEmpty)\
    \ arr\n        else {\n            val ones = arr.count(x => x == 1l)\n      \
    \      val maxOnes = arr.count(x => x == 0l)\n            val negOnes = arr.count(x\
    \ => x == -1l)\n            val sortOrder = math.max((ones / negOnes), maxOnes)\n\
    \            if (sortOrder > 0) arr.sortWith(a => sortOrder * (a compare 0l))\n\
    \            else arr.sortWith(a => math.max(a.toInt, 0))\n        }", "     \
    \   if (arr.isEmpty)\n            return arr\n        if (arr.length == 1)\n \
    \           return List(arr(0))\n        val mn = arr.min\n        val mx = arr.max\n\
    \        val ones = arr.filter(x => x.toInt == 1)\n        val twos = arr.filter(x\
    \ => x.toInt == 2)\n        val threes = arr.filter(x => x.toInt == 3)\n     \
    \   val fours = arr.filter(x => x.toInt == 4)\n        val fives = arr.filter(x\
    \ => x.toInt == 5)\n        val sixes = arr.filter(x => x.toInt == 6)\n      \
    \  val sevens = arr.filter(x => x.toInt == 7)\n        val eights = arr.filter(x\
    \ => x.toInt == 8)\n        val nines = arr.filter(x => x.toInt == 9)\n      \
    \  val hundreds = arr.filter(x => x.toInt % 100 == 0)\n        val thousands =\
    \ arr.filter(x => x.toInt % 1000 == 0)\n        val tens = arr.filter(x => x.toInt\
    \ % 10 == 0)\n        val elevens = arr.filter(x => x.toInt % 11 == 0)\n     \
    \   val twelves = arr.filter(x => x.toInt % 12 == 0)\n        val ones = ones.sorted\n\
    \        val twos = twos.sorted\n        val threes = threes.sorted\n        val\
    \ fours = fours.sorted\n        val fives = fives.sorted\n        val sixes =\
    \ sixes.sorted\n        val sevens = sevens.sorted\n        val eights = eights.sorted\n\
    \        val nines = nines.sorted\n        val hundreds = hundreds.sorted\n  \
    \      val thousands = thousands.sorted\n        val tens = tens.sorted\n    \
    \    val elevens = elevens.sorted\n        val twelves = twelves.sorted\n    \
    \    val arr = ones + twos + threes + fours + fives + sixes + sevens + eights\
    \ + nines + hundreds + thousands + tens + elevens + twelves\n        arr.map(x\
    \ => if (x == mn) 0 else x)", "        val bits = arr.map(x => x.toInt)\n    \
    \    val count = new HashMap[Int, Int]()\n        for (i <- 0 until bits.length)\
    \ {\n            val b = bits(i)\n            if (b <= 0) break\n            if\
    \ (count.contains(b)) {\n                count(b) = count(b) + 1\n           \
    \ } else {\n                count(b) = 1\n            }\n        }\n        val\
    \ sortedList = mutable.Buffer.empty[Long]\n        for (k <- 0 until count.size)\
    \ {\n            val v = count(k)\n            val bit = 1 << k\n            val\
    \ pos = bit - 1\n            for (i <- 0 until bits.length) {\n              \
    \  val b = bits(i)\n                if (b <= 0 || b == bit) continue\n       \
    \         if (b <= pos) break\n                val bitCount = count(b) - 1\n \
    \               val min = (1 << (pos - b - 1))\n                val max = (1 <<\
    \ (pos + b - 1))\n                if (v <= min && (v & min) == 0) sortedList +=\
    \ b\n                if (v <= max && (v & max) == 0) sortedList += b\n       \
    \     }\n        }\n        sortedList.toList", "        // Convert list to array\
    \ of ints\n        val arr = arr.map(_.toInt)\n        \n        // Count the\
    \ number of 1s and store in counts\n        val counts = arr.map(x => if(x !=\
    \ 0) 1 else 0)\n        val numOnes = counts.sum\n        val ones = counts.map(x\
    \ => x/numOnes)\n        \n        // Find the maximum of numOnes and store in\
    \ maxNumOnes\n        val maxNumOnes = max(numOnes)\n        val maxOnes = max(ones)\n\
    \        \n        // Create empty list of sorted numbers\n        val res = new\
    \ Array[Long](numOnes+maxNumOnes)\n        \n        // Sort the counts\n    \
    \    var i = 0\n        while(i < numOnes) {\n            val j = numOnes - i\n\
    \            val k = maxNumOnes - j\n            val count = counts(i)\n     \
    \       \n            // Assign max to numOnes\n            if(count > maxOnes(k))\
    \ {\n                res(k) = maxNumOnes\n            }\n            else {\n\
    \                res(k) = j\n            }\n            \n            // Assign\
    \ j to maxNumOnes\n            if(count > maxOnes(k)) {\n                res(maxNumOnes\
    \ + k + 1) = j\n            }\n            else {\n                res(maxNumOnes\
    \ + k) = maxOnes(k)\n            }\n            i += 1\n        }\n        \n\
    \        // Assign the rest of the counts to the remaining parts\n        var\
    \ j = 0\n        while(j < maxNumOnes) {\n            val k = maxNumOnes - j\n\
    \            res(k) = counts(j)\n            j += 1\n        }\n        \n   \
    \     res", "      arr.sortWith( (x,y) => compare(x,y) < 0 ||\n              \
    \                  compare(y,x) > 0 )", "        val onesCount = arr.filter(x\
    \ => x.toInt == 1).size\n        val zerosCount = arr.filter(x => x.toInt == 0).size\n\
    \n        // count number of ones first\n        if(onesCount > 0) {\n       \
    \     val ones = arr.filter(x => x.toInt == 1)\n            val sortedOnes = ones.sortBy((x)\
    \ => -x.toInt)\n            val onesIndex = ones.indexOf(onesCount)\n        \
    \    val zeros = arr.filter(x => x.toInt == 0)\n            val sortedZeros =\
    \ zeros.sortBy((x) => -x.toInt)\n            val zerosIndex = zeros.indexOf(zerosCount)\n\
    \            val mergedArray = sortedOnes.drop(onesIndex).drop(zerosIndex)\n \
    \           mergedArray\n        }\n        else {\n            val zerosCount\
    \ = arr.filter(x => x.toInt == 0).size\n            val zeros = arr.filter(x =>\
    \ x.toInt == 0)\n            val sortedZeros = zeros.sortBy((x) => -x.toInt)\n\
    \            val zerosIndex = zeros.indexOf(zerosCount)\n            val mergedArray\
    \ = sortedZeros.drop(zerosIndex)\n            mergedArray\n        }", "     \
    \   //implement your algorithm here\n        val bin = new Array[String](arr.length)\n\
    \        arr.foreach { i =>\n            bin(i) = (i.toString.reverse.charAt(0)\
    \ == '1' ? 1 : 0)\n        }\n        val ones = mutable.TreeSet[Long]()\n   \
    \     val zeros = mutable.TreeSet[Long]()\n        val arr = bin.zipWithIndex.foreach\
    \ { case (k, v) =>\n            if (v == 0) {\n                zeros.add(k)\n\
    \            } else {\n                ones.add(k)\n            }\n        }\n\
    \        var i = 0\n        while (i < ones.size) {\n            arr.sortBy(i\
    \ => ones.get(i - 1))\n            i += 1\n        }\n        i += 1\n       \
    \ while (i < zeros.size) {\n            arr.sortBy(i => zeros.get(i - 1))\n  \
    \          i += 1\n        }\n        return arr.toList", '        arr.sortWith(compare)',
  "        val ones = mutable.ListBuffer[Long]()\n        val onesCount = mutable.ListBuffer[Int]()\n\
    \        val decs = mutable.ListBuffer[Long]()\n        arr.foreach{el =>\n  \
    \          // use if instead of else to avoid duplicate computation\n        \
    \    if (el.toInt == 0) {\n                ones.append(el)\n                onesCount.append(0)\n\
    \            } else {\n                val binary = el.toBinaryString\n      \
    \          val decValue = binary.reverse.map(_.toInt).map(Integer.parseInt(_)).toList.sorted\n\
    \                onesCount.append(decValue.length)\n                ones.append(decValue)\n\
    \                decs.append(decValue)\n            }\n        }\n\n        val\
    \ onesArray = ones.toArray\n        val onesCount = onesCount.toArray\n      \
    \  val decArray = decs.toArray\n        val newArr = new Array[Long](onesCount.length)\n\
    \        val newCount = new Array[Int](onesCount.length)\n        var i = 0\n\
    \        onesCount.foreach(c => {\n            newArr(i) = onesArray(i + c)\n\
    \            newCount(i) = onesCount(i + c)\n            i += c\n        })\n\n\
    \        onesCount.foreach(c => {\n            val arr2 = decArray.slice(i + c,\
    \ i + c)\n            val arr3 = decArray.slice(i + c)\n            val arr4 =\
    \ decArray.slice(i + c)\n            val arr5 = decArray.slice(i + c)\n      \
    \      val arr6 = decArray.slice(i + c)\n            val arr7 = decArray.slice(i\
    \ + c)\n            val arr8 = decArray.slice(i + c)\n            val arr9 = decArray.slice(i\
    \ + c)\n            val arr10 = decArray.slice(i + c)\n            val arr11 =\
    \ decArray.slice(i + c)\n            val arr12 = decArray.slice(i + c)\n     \
    \       val arr13 = decArray.slice(i + c)\n            val arr14 = decArray.slice(i\
    \ + c)\n            val arr15 = decArray.slice(i + c)\n            val arr16 =\
    \ decArray.slice(i + c)\n            val arr17 = decArray.slice(i + c)\n     \
    \       val arr18 = decArray.slice(i + c)\n            val arr19 = decArray.slice(i\
    \ + c)\n            val arr20 = decArray.slice(i + c)\n            val arr21 =\
    \ decArray.slice(i + c)\n            val arr22 = decArray.slice(i + c)\n     \
    \       val arr23 = decArray.slice(i + c)\n            val arr24 = decArray.slice",
  "        var sortedArr: List[Long] = new mutable.ListBuffer[Long]\n        var i\
    \ = 0\n        arr.foreach { x =>\n            if (x == 1l) {\n              \
    \  sortedArr += x\n            } else {\n                sortedArr += x.toLong\n\
    \            }\n            i += 1\n        }\n        sortedArr += arr.last\n\
    \        sortedArr = sortedArr.sortWith(_ >= _) // sort ascending\n        sortedArr\
    \ = sortedArr.reverse.map { x => (x*2).toLong } // convert into dec\n        sortedArr",
  "        val res = arr.sortWith((x, y) => x.toLong > y.toLong)\n        val zeros\
    \ = arr.count(_ == 0)\n        res.take(zeros.toLong + 1).map(_ - zeros.toLong).reverse",
  '        arr.sortWith((x, y) => compare(arr, x, y) > 0)', "        var zeros = 0\n\
    \        var ones = 0\n        for (i <- arr.indices) {\n            if (arr(i)\
    \ == 0) {\n                zeros += 1\n            }\n            else if (arr(i)\
    \ == 1) {\n                ones += 1\n            }\n        }\n        if (zeros\
    \ > ones) {\n            for (i <- arr.indices) {\n                if (arr(i)\
    \ == 0) {\n                    arr(i) = -arr(i)\n                }\n         \
    \   }\n            arr = arr.sortWith((x, y) => x.compare(y))\n        }\n   \
    \     else {\n            arr = arr.sortWith((x, y) => y.compare(x))\n       \
    \ }\n        arr", "        val bin = arr.map(x => (bin2dec(x),x))\n        bin.sortBy(_._1).map(_._2)",
  "        val binArr = arr.map(x => x.toBinaryString).map(x => x(0)).map(x => x.toLong).toArray\n\
    \        val countArr = binArr.map(x => x.toInt).map(x => x.toBinaryString).map(x\
    \ => x(0)).map(x => x.toLong).toArray\n        val valArr = binArr.map(x => x.toInt).map(x\
    \ => x.toBinaryString).map(x => x(0)).map(x => x.toLong).toArray\n        val\
    \ maxArr = valArr.map(x => x.toInt).map(x => x.toLong).max\n        val retVal\
    \ = valArr.map(x => x - maxArr)\n        retVal.sortWith((x,y) => (binArr(x) -\
    \ binArr(y)) == 0 ? x : y)", "        var sortedArray : List[Long] = arr.toList.sortWith((x,\
    \ y) => x.toLong == y.toLong)\n        var i = 1;\n        val size = sortedArray.size\n\
    \        while(i <= size) {\n            var counter = i\n            var tempSum\
    \ = 0\n            var tempMin = sortedArray(i-1)\n            while(counter >\
    \ 0 && tempMin > sortedArray((counter-1)/2)){\n                tempSum += sortedArray(counter)\n\
    \                counter -= 1\n            }\n            if(tempSum > sortedArray(counter)){\n\
    \                sortedArray = sortedArray.toList.reverse\n                i =\
    \ size\n            } else {\n                sortedArray = sortedArray.toList\n\
    \                i += 1\n            }\n        }\n        sortedArray", "   \
    \     val numOnes = arr\n            .filter(x => x != 0l)\n            .map(x\
    \ => x.toInt.toBinary)\n            .map(x => Array(x.size, x).map(i => x.charAt(i)\
    \ == '1').sum)\n            .sortWith(_ < _)\n            .reverse\n\n       \
    \ val decimals = arr.map { x => x.toInt.toDecimal }\n            .sortWith(_ <\
    \ _)\n\n        numOnes.zip(decimals).toList.sortWith(_._1 < _._1)", "       \
    \ // Your code here!\n        val ones = arr.filter( _ % 2 == 1).size\n      \
    \  val tens = arr.filter( _ % 10 == 0).size\n        val hundreds = arr.filter(\
    \ _ % 100 == 0).size\n        if (ones > tens && ones > hundreds) {\n        \
    \    arr.sortBy(_ % 10)\n        } else if (tens > ones && tens > hundreds) {\n\
    \            arr.sortBy(_ % 100)\n        } else {\n            arr.sortBy(_ %\
    \ 1000)\n        }", '        arr.sortBy { i => (i & 1) == 1 }', "        arr.map\
    \ {\n            case 0l => 0l\n            case x => x.toLong\n        }.sortBy(x\
    \ => math.log2(x).toInt)", "        var num1 = 0\n        var num2 = 0\n     \
    \   var temp : List[Long] = List()\n        var i = 0\n        while (i < arr.length)\
    \ {\n            if (arr(i) == 1l) {\n                num1 += 1\n            \
    \    if (num1 > 1l) {\n                    num1 = 0\n                    num2\
    \ += 1\n                }\n            } else {\n                num2 += 1\n \
    \           }\n            if (num1 == 1l) {\n                temp = arr(i)\n\
    \                arr(i) = num2\n                num2 = temp\n                i\
    \ += 1\n                num1 = 0\n            }\n        }\n        return arr",
  '        arr.sortBy(_.getOnes).sortBy(_.getDecimal)', "        var res = 0\n   \
    \     var bin = arr.map(x => x.toString(2))\n        bin.foreach(x => {\n    \
    \        val n = (x.toLong / 2).toInt\n            val ones = x.toLong % 2\n \
    \           res += ones * n\n        })\n        val dec = bin.map(x => x.toString.toLong.toInt).map(_.pow(2)).map(x\
    \ => x / res).sortBy(x => x).reverse\n        bin.map(x => x.toString(2)).sortBy(x\
    \ => x).reverse.map(x => x + dec).reduce(_ ++ _)", "        val bits = new BitSet(arr.length.toInt)\n\
    \        val ones = new BitSet(arr.length.toInt)\n        for (i<-0 until arr.length)\
    \ {\n            ones = bits | ones | BitSet.get(i.toInt)\n            val bin\
    \ = BitSet.toString(ones).dropRight(1).toString\n            bits = bits & ~(ones\
    \ & BitSet(i.toInt))\n            arr(i) = bin.toLong\n        }\n        arr",
  "        val count = arr.map(x => if (x == 1l) 0 else 1)\n        val sorted = arr.sortBy(x\
    \ => count(x) * math.log10(x.toDouble))\n        sorted.map(x => x.toLong)", " \
    \       val countMap : Map[Long, Long] = arr.groupBy(x => x).toMap\n        val\
    \ oneCountMap : Map[Long, Long] = countMap.filter(_._1 == 1).toMap\n        val\
    \ oneAndAllCountMap : Map[Long, Long] = countMap.filter(_._1 == 1 && _._2 == arr.length).toMap\n\
    \n        oneAndAllCountMap.map{\n            case (count, val) =>\n         \
    \       val index = math.abs(val - math.max(oneAndAllCountMap.keySet).max).toInt\n\
    \                val vals = arr.drop(index).filter(_ == 1)\n                val\
    \ oneAndAllCountArray = ones.toArray[Long](oneAndAllCountMap.keySet)\n       \
    \         val oneAndAllCountArrayCopy = oneAndAllCountArray.clone()\n        \
    \        val oneAndAllCountArrayCopyScala = oneAndAllCountArray.map(x => scala.math.abs(x\
    \ - scala.math.max(oneAndAllCountArrayCopy)))\n                val oneAndAllCountArrayScala\
    \ = oneAndAllCountArrayCopyScala.map(x => scala.math.abs(x - scala.math.max(oneAndAllCountArray)))\n\
    \                (oneAndAllCountArrayCopy.toList)(scala.math.min(oneAndAllCountArrayScala).toInt)\n\
    \        }", "        val l = new mutable.ArrayBuffer[Long]()\n        arr.foreach\
    \ {\n            x =>\n                val count = arr(x).toInt / 2\n        \
    \        var j = 0\n                while (j < count) {\n                    l.append(x\
    \ * (2l + (1l to count).toInt))\n                    j += 1\n                }\n\
    \        }\n        l.toList", "        var n = 1\n        val ones = arr filter\
    \ (_ == 1)\n        val twos = arr filter (_ == 2)\n        val thres = arr filter\
    \ (_ < 0)\n        val zeros = arr filter (_ < 0)\n        val zeroCounts = zeros.groupBy(0)\n\
    \        val oneCounts = ones.groupBy(1)\n        val twoCounts = twos.groupBy(2)\n\
    \        val thresCounts = thres.groupBy(0)\n        val zeroZeroCounts = zeroCounts\
    \ filter (_._2 == 0)\n        val oneOneCounts = oneCounts filter (_._2 == 1)\n\
    \        val twoTwoCounts = twoCounts filter (_._2 == 2)\n        val thresThresCounts\
    \ = thresCounts filter (_._2 == 0)\n        val zeroZeroZeroCounts = zeroZeroCounts\
    \ filter (_._2 == 0)\n        val oneOneOneCounts = oneOneCounts filter (_._2\
    \ == 1)\n        val twoTwoTwoCounts = twoTwoCounts filter (_._2 == 2)\n     \
    \   val thresThresThresCounts = thresThresCounts filter (_._2 == 0)\n        val\
    \ zeroZeroZeroZeroCounts = zeroZeroZeroCounts filter (_._2 == 0)\n        val\
    \ oneOneOneOneCounts = oneOneOneCounts filter (_._2 == 1)\n        val twoTwoTwoTwoCounts\
    \ = twoTwoTwoCounts filter (_._2 == 2)\n        val thresThresThresThresCounts\
    \ = thresThresThresCounts filter (_._2 == 0)\n        val zeroZeroZeroZeroZeroCounts\
    \ = zeroZeroZeroZeroCounts filter (_._2 == 0)\n        val oneOneOneOneOneCounts\
    \ = oneOneOneOneCounts filter (_._2 == 1)\n        val twoTwoTwoTwoTwoCounts =\
    \ twoTwoTwoTwoCounts filter (_._2 == 2)\n        val thresThresThresThresThresCounts\
    \ = thresThresThresThresCounts filter (_._2 == 0)\n        val zeroZeroZeroZeroZeroZeroCounts\
    \ = zeroZeroZeroZeroZeroCounts filter (_._2 == 0)\n        val oneOneOneOneOneOneCounts\
    \ = oneOneOneOneOneCounts filter (_._2 == 1)\n        val twoTwoTwoTwoTwoTwoCounts\
    \ = twoTwoTwoTwoTwoCounts filter (_._2 == 2)\n        val thresThresThresThresThresThresCounts\
    \ = ", "      require(arr.size >= 1, \"Cannot sort an empty list.\");\n      var\
    \ oneCount = 0;\n      var result = arr.toList\n      for (i <- 0 until arr.size)\
    \ {\n        oneCount += arr(i) match {\n          case 0 => 0\n          case\
    \ 1 => 1\n          case 2 => 2\n          case 3 => 3\n          case 4 => 4\n\
    \          case 5 => 5\n          case 6 => 6\n          case 7 => 7\n       \
    \   case 8 => 8\n          case 9 => 9\n          case _ => 10\n        }\n  \
    \    }\n      for (i <- 0 until oneCount) {\n        result = result.sortWith(_.compare(arr.head))\n\
    \      }\n      result", "      val ones : List[Long] = arr.filter(_ % 2 == 0l).toList\n\
    \      val zeros : List[Long] = arr.filter(_ % 2 == 1l).toList\n      val onesByTwos\
    \ : List[Long] = ones.zip(ones.map(_ * 2).toList).sortBy(_._1).map(_._2)\n   \
    \   val zerosByTwos : List[Long] = zeros.zip(zeros.map(_ * 2).toList).sortBy(_._1).map(_._2)\n\
    \      onesByTwos.union(zerosByTwos)", "        // Your code goes here.\n    \
    \    val m = arr.map(i => (i, (i.toInt * 10).asInstanceOf[Long])).toMap\n    \
    \    val n = arr.map(i => ((i.toInt * 10).asInstanceOf[Long], i)).toMap\n    \
    \    arr.map(i => (i, (m.getOrElse(i, 0).toInt + n.getOrElse(i, 0).toInt)).asInstanceOf[Long]).toList",
  "        var onesCount = 0.0\n        var result = arr.toList\n        for( item\
    \ <- arr) {\n            onesCount += item\n        }\n        var i = 0\n   \
    \     while(i < arr.length) {\n            if( arr(i) > 0 && onesCount > 0) {\n\
    \                for( j <- i until arr.length) {\n                    if( arr(j)\
    \ > 0) {\n                        arr(j) = arr(j) + onesCount\n              \
    \          break\n                    } else if( arr(j) == 0) {\n            \
    \            arr(j) = arr(j) + onesCount\n                        result.add(arr(j))\n\
    \                        onesCount = 0.0\n                        break\n    \
    \                } else {\n                        onesCount = onesCount - arr(j)\n\
    \                    }\n                }\n            } else {\n            \
    \    result.add(arr(i))\n            }\n            onesCount = 0.0\n        \
    \    i += 1\n        }\n        result", "        val ones = arr.filter(_%2==0).count\n\
    \        val tens = arr.filter(_%2==1).count\n        val tensOnes = tens * ones\n\
    \        val longs = arr.filter(_%2==0).sortBy(x => x.toLong)\n        val onesLongs\
    \ = longs.filter(_%2==0).sortBy(x => x.toLong)\n        val tensLongs = onesLongs.filter(_%2==1).sortBy(x\
    \ => x.toLong)\n        val onesTensLongs = tensLongs.filter(_%2==1).sortBy(x\
    \ => x.toLong)\n        val tensOnesLongs = onesTensLongs.filter(_%2==1).sortBy(x\
    \ => x.toLong)\n        onesLongs.take(ones) * tensLongs.take(tens) * onesTensLongs.take(onesTens)",
  '        arr.sortWith(compareByOnes)', "        val ones = arr.count(_ => 1).toLong\n\
    \        val zeros = arr.count(_ => 0).toLong\n        val numOnes = arr.count(_\
    \ > 0).toLong\n        val numZeros = arr.count(_ < 0).toLong\n        arr.sortBy(x\
    \ => (ones-(numOnes^x)), x => (zeros-(numZeros^x)))", '        arr.sortWith(_
    < _)', "        var arr = arr.reverse.sortWith(_ < _)\n        var bin = new Array[Long](64)\n\
    \        var dec = 0\n        var count = 1\n        for(i<-arr.length-1 downto\
    \ 0){\n            bin(i) = arr(i)\n            if(arr(i) == 1){\n           \
    \     count++\n            }\n            else if(arr(i) == 0){\n            \
    \    count -= 1\n            }\n            if(count > 0){\n                dec\
    \ = dec + (bin(i-1) * count)\n                count = 1\n            }\n     \
    \   }\n        arr = arr.reverse.sortWith(_ < _)\n        bin = bin.reverse.dropRight(63).toArray\n\
    \        arr = arr.take(dec)\n        arr = arr.take(arr.length - dec)\n     \
    \   if(arr.length > 0){\n            arr = arr + dec.toLong\n        }\n     \
    \   else{\n            arr = dec.toLong\n        }\n        for(i<-arr.length-1\
    \ downto 0){\n            bin(i) = (arr(i) - dec.toLong).toInt\n        }\n  \
    \      bin.reverse\n        arr.reverse", "        val oneArray = arr.filter(x\
    \ => x == 1l.toLong).toArray\n        if(oneArray.size > arr.size) {\n       \
    \     oneArray.sort { a =>\n                val zeroArray = arr.filter(x => x\
    \ == 0l.toLong).toArray\n                if(zeroArray.size > 0) {\n          \
    \          val oneArray2 = arr.filter(x => x == 1l.toLong).toArray\n         \
    \           oneArray2.sortWith(_ > _).sortWith(_ > _).sortWith(_ > _)\n      \
    \          }\n            }\n        }\n        oneArray", '        arr.sortWith(compareByOne)',
  "        var result: List[Long] = Nil\n        for (elem <- arr) {\n           \
    \ val bitCount = elem.toString.length\n            if (bitCount < 1) {\n     \
    \           result += arr\n                return result\n            }\n    \
    \        if (bitCount >= 1) {\n                val currentVal = elem.toString.reverse.foldLeft(0)(_\
    \ + _)\n                val bitValue = (currentVal & 1).toInt\n              \
    \  val newVal = currentVal | (1 << bitValue)\n                result += (newVal\
    \ << bitCount).toLong\n            }\n        }\n        result", "        //\
    \ Write your logic here\n        val len = arr.length\n        var i = 0\n   \
    \     var numOfOnes = 0 // number of 1s in arr\n        var temp = 0\n       \
    \ var j = 0\n        while(i < len) {\n            if(arr(i) == 1) numOfOnes++\
    \ else numOfOnes--\n            i += 1\n        }\n        if(numOfOnes > 0) arr.sortBy(x=>numOfOnes.toInt/10)\n\
    \        else arr.sortBy(x=>x.toInt)", "        if (arr.length == 0) return arr.toList\n\
    \        val n = arr.head\n        val rest = arr.tail.filter(_ % n == 0)\n  \
    \      val dec = dec2dec(n)\n        if (rest.isEmpty) rest.toList else dec.reverse.head\
    \ :: dec.reverse ++ sortArray(rest)", "        val numOfOnes = arr.map(x => math.pow(2,\
    \ x)).reduceLeft(_ + _)\n        val len = arr.length\n        val maxOnesBefore\
    \ = arr.filter(x => x == 1).length\n        val maxOnesAfter = len - maxOnesBefore\n\
    \        // sort by number of ones in ascending order\n        arr.sortWith(x\
    \ => numOfOnes - x)\n        // sort by number of ones in ascending order\n  \
    \      if (maxOnesAfter > maxOnesBefore) arr.sortWith(x => maxOnesBefore - x)\
    \ else arr", "        val bits = arr.map(_ => Long.bitCount(_))\n        val len\
    \ = arr.length\n        val ones = bits.toList\n        val zeros = List(0)\n\
    \        val bins = binary(ones, len)\n        bins.sortWith((a,b) => a > b ?\
    \ 1 : a < b ? -1 : 0)\n        val decs = bins.map(_ => binaryToDecimal(_, len))\n\
    \        decs match {\n            case Seq(dec1, dec2) => dec1.zip(dec2) match\
    \ {\n                case (dec, dec2) if dec.toInt == dec2.toInt => dec\n    \
    \            case _ => decs\n            }\n            case _ => decs\n     \
    \   }", "        //1. Sort array using binary sort\n        val ones = arr.count(_\
    \ == 1)\n        val twos = arr.count(_ == 2)\n        val threes = arr.count(_\
    \ == 3)\n        val fours = arr.count(_ == 4)\n        val fives = arr.count(_\
    \ == 5)\n        val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_\
    \ == 7)\n        val eights = arr.count(_ == 8)\n        val nines = arr.count(_\
    \ == 9)\n        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_\
    \ == 100)\n        val thousands = arr.count(_ == 1000)\n        val millions\
    \ = arr.count(_ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n\
    \        val onesArr = ones + twos + threes + fours + fives + sixes + sevens +\
    \ eights + nines + tens + hundreds + thousands + millions + billions\n       \
    \ val twosArr = twos + threes + fours + fives + sixes + sevens + eights + nines\
    \ + tens + hundreds + thousands + millions + billions\n        val threesArr =\
    \ threes + fours + fives + sixes + sevens + eights + nines + tens + hundreds +\
    \ thousands + millions + billions\n        val foursArr = fours + fives + sixes\
    \ + sevens + eights + nines + tens + hundreds + thousands + millions + billions\n\
    \        val fivesArr = fives + sixes + sevens + eights + nines + tens + hundreds\
    \ + thousands + millions + billions\n        val sixesArr = sixes + sevens + eights\
    \ + nines + tens + hundreds + thousands + millions + billions\n        val sevensArr\
    \ = sevens + eights + nines + tens + hundreds + thousands + millions + billions\n\
    \        val eightsArr = eights + nines + tens + hundreds + thousands + millions\
    \ + billions\n        val ninesArr = nines + tens + hundreds + thousands + millions\
    \ + billions\n        val tensArr = tens + hundreds + thousands + millions + billions\n\
    \        val ", "        val ones = arr.groupBy(x => Integer.bitCount(x))\n  \
    \      val twos = arr.groupBy(x => Integer.bitCount(x) >> 1)\n        val threes\
    \ = arr.groupBy(x => Integer.bitCount(x) >> 2)\n        val fours = arr.groupBy(x\
    \ => Integer.bitCount(x) >> 3)\n        val fives = arr.groupBy(x => Integer.bitCount(x)\
    \ >> 4)\n        val sixes = arr.groupBy(x => Integer.bitCount(x) >> 5)\n\n  \
    \      val newArr: List[Long] = new mutable.ArrayList[Long]()\n\n        var i\
    \ = 0\n        while(i < arr.length) {\n            val firstGroup = ones.get(arr(i))\n\
    \            val secondGroup = twos.get(arr(i))\n            val thirdGroup =\
    \ threes.get(arr(i))\n            val fourthGroup = fours.get(arr(i))\n      \
    \      val fifthGroup = fives.get(arr(i))\n            val sixthGroup = sixes.get(arr(i))\n\
    \n            val sortByOnes = firstGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByTwos = secondGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByThrees = thirdGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByFours = fourthGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortByFives = fifthGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \            val sortBySixes = sixthGroup.map(x => if (x == 0) x else Integer.MAX_VALUE).max\n\
    \n            if(sortByOnes > sortByTwos && sortByOnes > sortByThrees && sortByOnes\
    \ > sortByFours && sortByOnes > sortByFives && sortByOnes > sortBySixes) {\n \
    \               newArr += arr(i).toLong\n                i += 1\n            }\
    \ else if(sortByTwos > sortByOnes && sortByTwos > sortByThrees && sortByTwos >\
    \ sortByFours && sortByTwos > sortByFives && sortByTwos > sortBySixes) {\n   \
    \             newArr += arr(i).toLong\n                i += 1\n            } else\
    \ if(sortByThrees > sortByOnes && sortByThrees > sortByTwos && sortByThrees >\
    \ sortByFours && sortByThrees > sortByFives && sortByThrees > sortBySixes) {\n\
    \                newArr += arr(i).toLong\n                i += 1\n           \
    \ } else if(sortByFours > sortByOne", "        val sortedArr = arr.sortWith(\n\
    \            (x1: Long, x2: Long) => if (x2 == 0) x1 < x2 else x2 < x1)\n    \
    \    sortedArr", "        arr\n            .foldLeft(List[Long]())((acc, x) =>\
    \ {\n                val bin = x.toBinaryString\n                val count = bin.count(_\
    \ == '1')\n                val dec = bin.toInt() % (2 * Integer.MAX_VALUE)\n \
    \               acc :+ (if(count > 0) dec else -dec)\n            })", "     \
    \   arr.sortWith((a, b) => b - a) match {\n            case List() => arr.sorted\n\
    \            case List(a) => a :: sortArray(arr.filter(_ <= a).reverse)\n    \
    \        case _ =>  sortArray(arr.filter(_ <= arr.min))\n        }", "       \
    \ val ones = new mutable.HashSet[Long]()\n        val zeros = new mutable.HashSet[Long]()\n\
    \        for (elem <- arr) {\n            if(elem==1l.toLong){ones.add(elem)}\n\
    \            if(elem==0l.toLong){zeros.add(elem)}\n        }\n        val result\
    \ = new mutable.ArrayList[Long]()\n        if(ones.isEmpty){\n            val\
    \ remainedZeros = new mutable.HashSet[Long]()\n            for(elem <- zeros){\n\
    \                if(remainedZeros.contains(elem)){\n                    result.add(-elem);\n\
    \                    remainedZeros.remove(elem)\n                }\n         \
    \   }\n            result\n        }\n        else{\n            val oneRemained\
    \ = new mutable.HashSet[Long]()\n            for(elem <- ones){\n            \
    \    if(oneRemained.contains(elem)){\n                    result.add(elem);\n\
    \                    oneRemained.remove(elem)\n                }\n           \
    \     else{\n                    result.add(elem);\n                    oneRemained.add(elem)\n\
    \                }\n            }\n        }", "        // O(n)\n        val onesInBins\
    \ = arr\n            .map(_ => 1L * _)\n            .reduce(_ + _)\n         \
    \   .asInstanceOf[Long]\n            .grouped(2)\n            .toList\n      \
    \      .sortWith(_._1 < _._1)\n            .map(_._2)\n            .toList\n \
    \           .reverse\n        // O(n log n)\n        val onesInBinsSorted = onesInBins.reverse.sortWith(_\
    \ < _)\n        // O(n log n)\n        val onesInDecimal = onesInBinsSorted\n\
    \            .groupBy(x => x.toLong)\n            .mapValues(_.map(_(0).toLong))\n\
    \            .toList\n            .sortWith(_ < _)\n            .map(_._2)\n \
    \           .toList\n            .reverse\n        // O(n)\n        val sortedWithDecimal\
    \ = onesInDecimal.sortWith(_ < _)\n        sortedWithDecimal", "        if (arr.isEmpty\
    \ || arr.size == 1) arr\n        else {\n            var arr = arr.sortWith(compare(arr))\n\
    \            sortArray(arr.tail)\n        }", "        var ans = arr.toList.sortWith(_\
    \ > _)\n        if(arr.length < 2) ans\n        else {\n            var m = arr.head\n\
    \            var n = arr.last\n            var i = 0\n            while(i<ans.length-1\
    \ && ans.head==i) i+=1\n            while(i<ans.length-1 && ans.last==i) i+=1\n\
    \            while(true){\n                if(ans.head==i) m += 1\n          \
    \      if(ans.last==i) n += 1\n                if(i == ans.length-1) break\n \
    \               i +=1\n            }\n            ans = arr.toList.sortWith(x\
    \ => x > m && x < n)\n        }\n        ans", '        arr.groupBy(_ % 2).keys.toList.sortWith(_
    < _) // sort by number of ones', "        arr.sortBy( x => (arr.count(i => i==x.toBinaryString().reverse.dropWhile(_=='0').reverse.headOption).getOrElse(1),x))",
  "        var zeroCount = 0\n        var oneCount = 0\n        var sortedList = arr.toList\n\
    \        var sortedListLength = sortedList.length\n        var sortedListLength\
    \ = sortedListLength - 1\n        while (oneCount < sortedListLength - 1 && zeroCount\
    \ < sortedListLength - 1) {\n            if (sortedList(oneCount) == 1) {\n  \
    \              oneCount = oneCount + 1\n            } else {\n               \
    \ zeroCount = zeroCount + 1\n            }\n        }\n        if (oneCount <\
    \ sortedListLength - 1) {\n            val tempOneCount = oneCount\n         \
    \   val tempZeroCount = zeroCount\n            var zeroIndex = 0\n           \
    \ oneCount = sortedListLength - 1\n            zeroCount = 0\n            while\
    \ (oneCount < sortedListLength - 1 && zeroCount < sortedListLength - 1) {\n  \
    \              if (sortedList(oneCount) == 0) {\n                    oneCount\
    \ = oneCount + 1\n                } else {\n                    zeroCount = zeroCount\
    \ + 1\n                }\n            }\n            val tempSortedList = sortedList\n\
    \            sortedList = tempSortedList.take(tempOneCount)\n            sortedListLength\
    \ = sortedList.length\n            zeroCount = tempZeroCount\n            oneCount\
    \ = tempOneCount\n            sortedListLength = sortedListLength - 1\n      \
    \      val tempZeroIndex = zeroIndex\n            val tempOneIndex = oneIndex\n\
    \            while (oneCount < sortedListLength - 1 && zeroCount < sortedListLength\
    \ - 1) {\n                if (sortedList(oneCount) == 0) {\n                 \
    \   oneCount = oneCount + 1\n                } else {\n                    zeroCount\
    \ = zeroCount + 1\n                }\n            }\n            zeroIndex = tempZeroIndex\n\
    \            oneIndex = tempOneIndex\n            while (oneCount < sortedListLength\
    \ - 1) {\n                if (sortedList(oneCount) == 0) {\n                 \
    \   oneCount = oneCount + 1\n                } else {\n                    zeroCount\
    \ = zeroCount + 1\n                }\n            }\n            val tempOneIndex\
    \ = oneIndex\n            oneCount = sortedListLength - 1\n            zeroCount\
    \ = 0\n            while (oneCount < sortedListLength - 1) {\n               \
    \ if (sortedList(oneCount) == 1) {\n                    oneCount = oneCount +\
    \ 1\n                } else {\n                    zeroCount = zeroCount + 1\n\
    \                }\n            }\n            oneIndex = tempOneIndex\n     \
    \       val tempZeroCount = zeroCount\n            zeroCount = tempZeroCount\n\
    \            sortedList = tempSortedList.take(tempOneCount)\n            sortedListLength\
    \ = sortedList.length\n        }\n        if (zeroCount > 0) {\n            var\
    \ tempZeroCount = zeroCount\n            zeroCount = 0\n            val tempSortedList\
    \ = sortedList\n            sortedList = tempSortedList.take(tempZeroCount)\n\
    \            sortedListLength = sortedList.length\n            val tempZeroIndex\
    \ = zeroIndex\n            zeroIndex = 0", "        val numOfOnes = arr.map(i\
    \ => Integer.bitCount(i)).max\n        arr.sortBy(i => -numOfOnes - Integer.bitCount(i))",
  "        val res = arr.sortWith((a, b) => arr.count(b => a & (b >> Integer.bitCount(b))\
    \ == b) <= arr.count(b => a & (b >> Integer.bitCount(b)) == a & (b >> Integer.bitCount(b))))\n\
    \        res.reverse"]
stop_tokens:
- "\n    }\n"
