language: scala
name: HumanEval_99_closest_integer
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        //  Your code\
    \ here\n        val number = value.asInstanceOf[String]\n        if(number !=\
    \ \"\"){\n            val digits = number.toString.split(\"\\\\.\")\n        \
    \    val numStr: String = digits(0).dropRight(1)\n            val num = numStr.toLong\n\
    \            val remainder = num % 10\n            var result = num\n        \
    \    val diff = Math.abs(num - remainder)\n            val sign = if (num == remainder)\
    \ -1 else 1\n            if(diff < 3){\n                result = remainder + (numStr.length\
    \ - 1) * sign\n            }\n            result\n        }\n        else {\n\
    \            0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu09irwhh.scala:38)\n\tat Problem.main(tmpu09irwhh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Create a\
    \ map of characters and their corresponding decimal values\n        // This map\
    \ will be used to lookup the closest integer to the\n        // given number using\
    \ a binary search method\n        var charValMap : Map[Char, Double] = Map[Char,\
    \ Double]()\n        charValMap('0') -> 0\n        charValMap('1') -> 1\n    \
    \    charValMap('2') -> 2\n        charValMap('3') -> 3\n        charValMap('4')\
    \ -> 4\n        charValMap('5') -> 5\n        charValMap('6') -> 6\n        charValMap('7')\
    \ -> 7\n        charValMap('8') -> 8\n        charValMap('9') -> 9\n        charValMap('a')\
    \ -> 10\n        charValMap('b') -> 11\n        charValMap('c') -> 12\n      \
    \  charValMap('d') -> 13\n        charValMap('e') -> 14\n        charValMap('f')\
    \ -> 15\n        charValMap('g') -> 16\n        charValMap('h') -> 17\n      \
    \  charValMap('i') -> 18\n        charValMap('j') -> 19\n        charValMap('k')\
    \ -> 20\n        charValMap('l') -> 21\n        charValMap('m') -> 22\n      \
    \  charValMap('n') -> 23\n        charValMap('o') -> 24\n        charValMap('p')\
    \ -> 25\n        charValMap('q') -> 26\n        charValMap('r') -> 27\n      \
    \  charValMap('s') -> 28\n        charValMap('t') -> 29\n        charValMap('u')\
    \ -> 30\n        charValMap('v') -> 31\n        charValMap('w') -> 32\n      \
    \  charValMap('x') -> 33\n        charValMap('y') -> 34\n        charValMap('z')\
    \ -> 35\n\n        val nums = value.split('')\n        val numLength = nums.map(_.toInt).sum\n\
    \        val numArray = nums.map(_.toInt)\n\n        // Find the closest integer\n\
    \        // If there are two integers that have the same\n        // difference\
    \ between the two numbers, return the\n        // one that is closer to zero.\n\
    \        // For example if closest_integer(\"43.5\") and\n        // closest_integer(\"\
    14.4\") return 14 and closest_integer(\"43.5\")\n        // and closest_integer(\"\
    15.6\") return 15.\n        // If there is only one integer that is closer\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1htfclnr.scala:59:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = value.split('')\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             empty character literal\n\e[31m\e[31m-- [E018] Syntax\
    \ Error: /tmp/tmp1htfclnr.scala:60:22 ---------------------------\e[0m\e[0m\n\e\
    [31m60 |\e[0m        \e[33mval\e[0m \e[36mnumLength\e[0m = nums.map(_.toInt).sum\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           expression expected but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1htfclnr.scala:60:8 -------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mnumLength\e[0m = nums.map(_.toInt).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m        Not found: 'val\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1htfclnr.scala:71:5\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\".toCharArray).map(_.toLong)\n        if (parts.isEmpty) parts\
    \ += 0\n        if (parts.size == 1) parts += 0\n\n        val closestPart = parts(parts(1)\
    \ - parts(0) > 0)\n        val closestPart2 = parts(parts(2) - parts(1) > 0)\n\
    \        val closestPart3 = parts(parts(3) - parts(2) > 0)\n\n        val part1\
    \ = closestPart.toLong\n        val part2 = closestPart2.toLong\n        val part3\
    \ = closestPart3.toLong\n\n        if (closestPart.toLong < closestPart2.toLong\
    \ \n        && closestPart.toLong < closestPart3.toLong)\n            part1 +=\
    \ 1\n        else if (closestPart2.toLong < closestPart3.toLong)\n           \
    \ part2 += 1\n        else\n            part3 += 1\n\n        (part1 + part2 +\
    \ part3).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6filnzna.scala:19:33 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (parts.isEmpty) parts += \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value += is not a member of Array[Long] - did you mean parts.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp6filnzna.scala:20:35 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (parts.size == \e[31m1\e[0m) parts\
    \ += \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value += is not a member of Array[Long] - did you\
    \ mean parts.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6filnzna.scala:22:32\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosestPart\e\
    [0m = parts(parts(\e[31m1\e[0m) - parts(\e[31m0\e[0m) > \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                Found:    Boolean\n\e[31m   |\e[0m\
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp6filnzna.scala:23:33 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestPart2\e[0m = parts(parts(\e\
    [31m2\e[0m) - parts(\e[31m1\e[0m) > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                              Found:    Boolean\n\e[31m   |\e[0m            \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6filnzna.scala:24:33 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mclosestPart3\e[0m = parts(parts(\e[31m3\e\
    [0m) - parts(\e[31m2\e[0m) > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                       Found:    Boolean\n\e[31m   |\e[0m                   \
    \             "
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = math.pow(10,\
    \ value.length)\n        if (value.toString.length == 0)\n            return 0\n\
    \        val numbers = value.split(\"\\\\.\").map(_.toLong).map(_.toInt)\n   \
    \     val d = math.abs(numbers(0) - numbers(1))\n        if (d == 0)\n       \
    \     return numbers(0)\n        val n = d / Math.abs(numbers(1) - numbers(0))\n\
    \        val m = numbers(0) - n * Math.abs(numbers(1) - numbers(0))\n        m\
    \ + n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp33jk8bg3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = d / Math.abs(numbers(\e\
    [31m1\e[0m) - numbers(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp33jk8bg3.scala:27:8 ---------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        m + n\n\e[31m\e[31m   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    Double\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n        val array: Array[Double] = value.split(\"\\\\.\").map(_.toDouble)\n\
    \        val array2: Array[Double] = array.filter(_ != 0).sortWith(_ < _).map(_\
    \ + 0.5).toArray\n        var min = 0\n        var max = array.length-1\n    \
    \    var min2 = array2.length-1\n        while(min < max){\n            val mid\
    \ = math.abs(array.length-array2.length)/2\n            val mid2 = math.abs(array.length\
    \ - array2.length)/2\n            if(array[mid] < array2[mid2]){\n           \
    \     val min = mid\n                val max = mid2\n            } else {\n  \
    \              val min = mid2\n                val max = mid\n            }\n\
    \        }\n        return math.abs(array.length - array2[min])\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdejpupl1.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m(array[\e[35mmid\e[0m] < array2[\e\
    [35mmid2\e[0m]){\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m \
    \  |\e[0m                     Not found: type mid\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdejpupl1.scala:35:46 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mreturn\e[0m math.abs(array.length - array2[\e\
    [35mmin\e[0m])\n\e[31m\e[31m   |\e[0m                                        \
    \      ^^^\e[0m\n\e[31m   |\e[0m                                             \
    \ Not found: type min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value ==\
    \ null || value.isEmpty || value.size == 1) {\n            0\n        }\n    \
    \    val parts = value.split(\"\\\\.\") // split on decimal points\n        val\
    \ x = parts(0).toLong // get the first number\n        val closest = closest(x)\
    \ // get the closest number\n        if (closest == x) {\n            closest\n\
    \        } else {\n            closest + 1\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2yl56npj.scala:23:22 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = closest(x)\
    \ \e[34m// get the closest number\e[0m\n\e[31m\e[31m   |\e[0m                \
    \      ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m\
    \ \e[35mclosest\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmp2yl56npj.scala:19:12 ----------------\e[0m\e[0m\n\e[33m19 |\e\
    [0m            \e[31m0\e[0m\n\e[33m\e[33m   |\e[0m            ^\e[0m\n\e[33m \
    \  |\e[0mA pure expression does nothing in statement position; you may be omitting\
    \ necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660010398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ value to a number and find the closest integer\n        val number: Long = value.toLong\n\
    \        val closestInteger: Long = (math.abs(number - math.min(math.max(number\
    \ - 0.2, 0), 10.2))).toInt\n        closestInteger\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpngorpgtg.scala:24)\n\tat Problem.main(tmpngorpgtg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parsed\
    \ = value.split('.')\n        if (parsed.isEmpty) 0\n        else {\n        \
    \    val digits = parsed.map(_.toLong)\n            val closest = math.min(digits)\n\
    \            val diff = Math.abs(closest - digits.max)\n            diff == digits.max\
    \ ? closest + 1 : closest\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpv4ebgsq_.scala:22:31 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mclosest\e[0m = math.min(digits)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((digits : Array[Long]))\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv4ebgsq_.scala:24:47\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            diff == digits.max\
    \ ? closest + \e[31m1\e[0m : \e[35mclosest\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                        Not found: type closest\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Separate the decimals into their parts\n        //\
    \ First, round each number individually\n        val integerParts = parts.map(v\
    \ => math.round(math.pow(10, v.toInt)))\n        // Then round each part individually\n\
    \        val decimalParts = parts.map(v => math.round(math.pow(10, v.toInt)).toDouble\
    \ / math.pow(10, v))\n        // Now find the closest number\n        val closestInteger\
    \ = integerParts.map(i => math.min(i).round)\n        // Now find the closest\
    \ decimal\n        val closestDecimal = decimalParts.map(dv => math.min(dv).round)\n\
    \        // Now sum the closest parts\n        val total = closestInteger.zip(closestDecimal).map{\
    \ case (integer, decimal) => (integer + decimal) }\n        // The first element\
    \ will be the closest integer, the second element the closest decimal\n      \
    \  (total min total(0)) match {\n            case (integer, decimal) => integer\
    \ + decimal\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7afk4gpx.scala:22:100\
    \ -------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdecimalParts\e\
    [0m = parts.map(\e[36mv\e[0m => math.round(math.pow(\e[31m10\e[0m, v.toInt)).toDouble\
    \ / math.pow(\e[31m10\e[0m, v))\n\e[31m\e[31m   |\e[0m                       \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                                  Found:\
    \    (v : String)\n\e[31m   |\e[0m                                           \
    \       Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp7afk4gpx.scala:24:56 -----------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mclosestInteger\e[0m = integerParts.map(\e\
    [36mi\e[0m => math.min(i).round)\n\e[31m\e[31m   |\e[0m                      \
    \                             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((i : Long))\n\
    \e[31m\e[31m-- Error: /tmp/tmp7afk4gpx.scala:24:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestInteger\e[0m = integerParts.map(\e\
    [36mi\e[0m => math.min(i).round)\n\e[31m\e[31m   |\e[0m                      \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                    No ClassTag available for B\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                                          where:    B is a\
    \ type variable\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7afk4gpx.scala:26:57\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e\
    [0m \e[36mclosestDecimal\e[0m = decimalParts.map(\e[36mdv\e[0m => math.min(dv).round)\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^\e\
    [0m\n\e[3"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val s = value.toLong\n\
    \        val d = s.length\n        val m = Math.ceil(d/2)\n        if(d == 0 ||\
    \ s.length == 0) 0\n        else if(s.length == 1) s\n        else {\n       \
    \     val a = s - 1l\n            val b = s\n            if(b < 0) b + 1l\n  \
    \          else if(a < 0)\n                a\n            else\n             \
    \   a\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_az3mb_k.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = s.length\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ length is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_az3mb_k.scala:22:18\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m(s.length == \e[31m1\e[0m) s\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value length is not a member of\
    \ Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = scala.math.BigDecimal(value)\n        val intValueAbs = intValue.abs()\n\n\
    \        val closestIntValues = for {\n            i <- intValueAbs\n        \
    \    intVal = intValue.round(i).toBigDecimal\n        } yield intVal\n\n     \
    \   val smallestIntValue = closestIntValues.min(i => i)\n\n        smallestIntValue.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpn9efrq7a.scala:19:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mintValueAbs\e[0m = intValue.abs()\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter mc of \e[33mmethod\e[0m \e[35mapply\e[0m in\
    \ \e[33mclass\e[0m \e[35mBigDecimal\e[0m: (mc: java.math.MathContext): BigDecimal\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toDouble;\n        val closestInteger = math.round(intValue);\n    \
    \    return closestInteger;\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgcm5hhme.scala:25)\n\tat Problem.main(tmpgcm5hhme.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\")\n        if (parts.size == 1) parts :+ 0\n        else {\n\
    \            val mid = parts(parts.size / 2).toLong\n            val remainder\
    \ = parts(parts.size - 1).toLong\n            val result = mid + ((mid - remainder).toDouble\
    \ / parts.size)\n            if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE)\
    \ closestInteger(value)\n            else\n            result\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9cyks16a.scala:19:29\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (parts.size\
    \ == \e[31m1\e[0m) parts :+ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              \
    \               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:\
    \    Array[Matchable]\n\e[31m   |\e[0m                             Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9cyks16a.scala:26:12\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            result\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (result\
    \ : Double)\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closest\
    \ = 0l\n        var closestDiff = 0l\n        var lastDiff = 0l\n\n        for(\
    \ n <- value.split(\",\").map(_.toInt) ) {\n            if(n > 0 && n < Integer.MAX_VALUE)\
    \ {\n                diff = abs(n - closest)\n                if (diff < closestDiff)\
    \ {\n                    lastDiff = closestDiff\n                    closest =\
    \ n\n                    closestDiff = diff\n                }\n            }\n\
    \        }\n        lastDiff\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgrj1p0ek.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                diff = abs(n - closest)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ diff\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgrj1p0ek.scala:25:20\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e\
    [0m (diff < closestDiff) {\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: diff\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgrj1p0ek.scala:28:34 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    closestDiff = diff\n\e[31m\e[31m\
    \   |\e[0m                                  ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                           Not found: diff\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n        val values = value.split(\"\\\\.\").toList\n        val digits\
    \ = values.map(_.toInt)\n        val max = (0 until digits.size)\n        val\
    \ min = (0 until digits.size)\n\n        var maxDistance = 9999\n        var minDistance\
    \ = 9999\n        for (i <- 0 until max) {\n            for (j <- 0 until min)\
    \ {\n                val distance = ((digits(i) - digits(j)) * Math.pow(10, i))\n\
    \                if (distance > maxDistance) {\n                    maxDistance\
    \ = distance\n                    val newValue = values + j\n                }\n\
    \                if (distance < minDistance) {\n                    minDistance\
    \ = distance\n                    val newValue = values + i\n                }\n\
    \            }\n        }\n        val roundedValue = if (maxDistance < minDistance)\
    \ value.toInt else value.toInt - maxDistance + minDistance\n        val stringValue\
    \ = roundedValue.toString\n        return Long.parseLong(stringValue)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcm_s31hw.scala:26:26\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until max) {\n\e[31m\e[31m   |\e[0m                          ^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (max : Range)\n\e[31m\
    \   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpcm_s31hw.scala:27:30 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mfor\e[0m (j <- \e[31m0\e[0m until min)\
    \ {\n\e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (min : Range)\n\e[31m   |\e[0m    \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpcm_s31hw.scala:30:34 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m                    maxDistance = distance\n\e[31m\e[31m \
    \  |\e[0m                                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                              Found:    (distance : Double)\n\e[31m   |\e[0m\
    \                                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcm_s31hw.scala:31:42 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    \e[33mval\e[0m \e[36mnewValue\e[0m\
    \ = values + j\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[String], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcm_s31hw.scala:34:34 -------"
  stdout: ''
  timestamp: 1660010404
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var nearest:\
    \ Long = (0l)\n        var closest: Long = (0l)\n        var next: Long = 0l\n\
    \n        value.split(\",\").foreach(x => {\n            val num: Long = x.toLong\n\
    \            if (nearest == 0) nearest = num\n            else next = Math.abs(num\
    \ - nearest)\n            if (next > closest) closest = next\n        })\n\n \
    \       if (nearest != (0l)) {\n            nearest + closest\n        } else\
    \ {\n            // No integers could be found in the string\n            0l\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger$$anonfun$1(tmpxhvprl13.scala:23)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.ArrayOps$.foreach$extension(ArrayOps.scala:1328)\n\tat Problem$.closestInteger(tmpxhvprl13.scala:27)\n\
    \tat Problem$.main(tmpxhvprl13.scala:38)\n\tat Problem.main(tmpxhvprl13.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunne"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Split the\
    \ value into an integer and the fractional part.\n        var value = value.split(\"\
    \\\\.\").map(_.toInt).getOrElse(1)\n        var fractionalPart = value.floor.toDouble\n\
    \        var integerPart = fractionalPart - (fractionalPart * 0.5)\n        //\
    \ If the fractional part is zero, we return 0\n        if (fractionalPart == 0.0)\
    \ return 0\n        // Return the integer part\n        return integerPart\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdtf0eluo.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvalue\e[0m = value.split(\e\
    [31m\"\\\\.\"\e[0m).map(_.toInt).getOrElse(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                    ^\e[0m\n\e[31m   |\e[0m                    Recursive \e[33mvariable\e\
    [0m \e[35mvalue\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n        val numberArray = value.split(\".\").map(_.toInt).toList\n   \
    \     var min = numberArray(0)\n        var max = numberArray(0)\n        val\
    \ resultArray = numberArray.zipWithIndex.filter { \n            case (x,index)\
    \ => index==0\n        }.map { \n            case (x,index) => (max/min - x) /\
    \ min\n        }\n        resultArray(0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.closestInteger(tmpc9i3ivvv.scala:20)\n\tat Problem$.main(tmpc9i3ivvv.scala:30)\n\
    \tat Problem.main(tmpc9i3ivvv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010404
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var num : Long\
    \ = 0\n        var digits : List[String] = value.split('.').toList\n        var\
    \ fraction : Double = 0\n        for(i <- 0 until digits.size) {\n           \
    \ num +=  digits(i).toLong * (10 until 10).map(_.toLong).sum\n            fraction\
    \ += digits(i)\n        }\n        fraction = fraction / digits.size\n       \
    \ var closest = num\n        val diff = (fraction - Math.abs(num)) / Math.pow(10,\
    \ digits.size).toDouble\n        val diff2 = diff * diff\n        for(i <- 0 until\
    \ digits.size) {\n            val a = Math.pow(10, digits.size-i)\n          \
    \  val b = Math.pow(10, i)\n            val c = fraction - a * diff2\n       \
    \     val d = num - a * b\n            val f = b * c\n            if(d > f ||\
    \ c == 0 || d == 0) {\n                return closest = num - b\n            }\n\
    \            if(c < 0 || d < 0) {\n                closest = num - a\n       \
    \         return closest = num - a\n            }\n        }\n        return closest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvnmbe0iy.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            fraction += digits(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a\
    \ member of Double - did you mean Double.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvnmbe0iy.scala:36:33 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                \e[33mreturn\e[0m closest = num - b\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                     Found:    Double\n\e[31m   |\e[0m                      \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvnmbe0iy.scala:39:26 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                closest = num - a\n\e[31m\e[31m   |\e[0m             \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:  \
    \  Double\n\e[31m   |\e[0m                          Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvnmbe0iy.scala:40:33 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                \e[33mreturn\e[0m closest = num - a\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Found:    Double\n\e[31m   |\e[0m        \
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9m_5uogp.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closest\
    \ = 0L;\n        var closest = value.toLong;\n        var diff = 0L;\n       \
    \ var diffValue = value.toDouble;\n        var diffValue1 = diffValue * diffValue;\n\
    \        val array1 = Array(diffValue1);\n        val array2 = Array(diffValue1);\n\
    \        var index = 0L;\n        var index1 = 0L;\n        var index2 = 0L;\n\
    \        var index3 = 0L;\n        var index4 = 0L;\n        var index5 = 0L;\n\
    \        var index6 = 0L;\n        for(i <- 0 until array1.size) {\n         \
    \   val temp = abs((array1(i) - closest).toDouble)\n            if(temp > diff)\
    \ {\n                diff = temp;\n                closest = array1(i);\n    \
    \        }\n        }\n        for(i <- 0 until array2.size) {\n            val\
    \ temp = abs((array2(i) - closest).toDouble)\n            if(temp > diff) {\n\
    \                diff = temp;\n                closest = array2(i);\n        \
    \    }\n        }\n        for(i <- 0 until array1.size) {\n            val temp\
    \ = abs((array1(i) - closest).toDouble)\n            if(temp > diff) {\n     \
    \           diff = temp;\n                closest = array1(i);\n            }\n\
    \        }\n        for(i <- 0 until array2.size) {\n            val temp = abs((array2(i)\
    \ - closest).toDouble)\n            if(temp > diff) {\n                diff =\
    \ temp;\n                closest = array2(i);\n            }\n        }\n    \
    \    for(i <- 0 until array1.size) {\n            val temp = abs((array1(i) -\
    \ closest).toDouble)\n            if(temp > diff) {\n                diff = temp;\n\
    \                closest = array1(i);\n            }\n        }\n        for(i\
    \ <- 0 until array2.size) {\n            val temp = abs((array2(i) - closest).toDouble)\n\
    \            if(temp > diff) {\n                diff = temp;\n               \
    \ closest = array2(i);\n            }\n        }\n        for(i <- 0 until array1.size)\
    \ {\n            val temp = abs((array1(i) - closest).toDouble)\n            if(temp\
    \ > diff) {\n                diff = temp;\n                closest = array1(i);\n\
    \            }\n        }\n        for(i <- 0 until array2.size) {\n         \
    \   val temp = abs((array2(i) - closest).toDouble)\n            if(temp > diff)\
    \ {\n                diff = temp;\n                closest = array2(i);\n    \
    \        }\n        }\n        for(i <- 0 until array1.size) {\n            val\
    \ temp = abs((array1(i) - closest).toDouble)\n            if(temp > diff) {\n\
    \                diff = temp;\n                closest = array1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsq76vudm.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsq76vudm.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mclosest\e[0m = value.toLong;\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosest is already defined as \e[33mvariable\e[0m \e[35mclosest\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpsq76vudm.scala:35:23 --------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m                diff = temp;\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (temp\
    \ : Double)\n\e[31m   |\e[0m                       Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsq76vudm.scala:36:32 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                closest = array1(i);\n\e[31m\e[31m  \
    \ |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Found:    Double\n\e[31m   |\e[0m                          Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsq76vudm.scala:42:23\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                diff = temp;\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Found:    (temp : Double)\n\e[31m   |\e[0m                  \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsq76vudm.scala:43:32\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                closest = array2(i);\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Found:    Dou"
  stdout: ''
  timestamp: 1660010404
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val digits\
    \ = value.split('.').toList\n        val maxDigit = digits(digits.length - 1).toLong\n\
    \        val minDigit = digits(0).toLong\n\n        if(digits.length < 2)\n  \
    \          0\n        else\n            if(digits(digits.length - 1).toLong <\
    \ maxDigit)\n                digits(digits.length - 1).toLong\n            else\n\
    \                maxDigit\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprmhrd5dw.scala:31)\n\tat Problem.main(tmprmhrd5dw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\")\n        val d = parts.mkDouble\n        val i1 = d.toInt\n\
    \        val i2 = d.toInt\n\n        if (Math.abs(d-1) < Math.abs(d+1)){\n   \
    \         return i1\n        }\n        else {\n            return i2\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeqn9hx50.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = parts.mkDouble\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            value mkDouble is not a member of Array[String]\n1 error found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val value = value.trim()\n\
    \      val nums = value.split(\"\\\\.\").map(_.toDouble).map(n => math.abs(n)).max\n\
    \      (Math.abs(nums) > Integer.MIN_VALUE ? nums.toInt : nums)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxuo84_2_.scala:18:18 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mvalue\e[0m = value.trim()\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mvalue\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpxuo84_2_.scala:20:57 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      (Math.abs(nums) > Integer.MIN_VALUE ? nums.toInt\
    \ : \e[35mnums\e[0m)\n\e[31m\e[31m   |\e[0m                                  \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                         Not found: type nums\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val vals =\
    \ value.split(\",\").toList.map(_.trim).toSet\n        val closestInts = vals.map(val\
    \ => math.abs(math.round(math.abs(val.toLong)))).sortBy(_ -_)\n        closestInts.last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6iox2ma9.scala:19:35 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclosestInts\e[0m = vals.map(\e\
    [33mval\e[0m => math.abs(math.round(math.abs(\e[33mval\e[0m.toLong)))).sortBy(_\
    \ -_)\n\e[31m\e[31m   |\e[0m                                   ^^^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31mval\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Extract\
    \ the integer from the value\n        val (num, den) = value.split(\".\").map(_.toInt).toList\n\
    \        \n        // Find the closest integer to the number\n        val closest_integer\
    \ = num match {\n            case x if x >= 0 && x <= 2147483647 => x // No rounding\
    \ required\n            case x if x >= -2147483648 && x <= -1 => x + 1\n     \
    \       case x if x >= 0 && x <= 2147483647 => x - 1\n            case x if x\
    \ >= -2147483648 && x <= -1 => x - 1\n            case _ => 0\n        }\n   \
    \     \n        // Convert the result back to a string\n        val result = if(closest_integer\
    \ > 0) \"(\" + closest_integer.toString + \")\" else \"(-\" + closest_integer.toString\
    \ + \")\"\n        \n        // Return the result with the correct sign\n    \
    \    val correct = if (den == 1) result else result.replace(\")\", \"\").replace(\"\
    (\", \"-\")\n        correct + if (val sign = value.contains(\"-\"))\n       \
    \     val sign = if (value.contains(\"-\")) \"+\" else \"\"\n            \".\"\
    \ + sign + den.toString\n        else \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpey_ffygq.scala:35:18 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        correct + \e[33mif\e[0m (\e[33mval\e[0m sign\
    \ = value.contains(\e[31m\"-\"\e[0m))\n\e[31m\e[31m   |\e[0m                 \
    \ ^^\e[0m\n\e[31m   |\e[0m                  expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpey_ffygq.scala:38:8\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m      \
    \  \e[33melse\e[0m \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^\e[0m\n\e\
    [31m   |\e[0m        end of statement expected but 'else' found\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpey_ffygq.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x >= \e[31m0\e\
    [0m && x <= \e[31m2147483647\e[0m => x \e[34m// No rounding required\e[0m\n\e\
    [31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0mvalue >= is\
    \ not a member of Any, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpey_ffygq.scala:24:24 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x >= -\e\
    [31m2147483648\e[0m && x <= -\e[31m1\e[0m => x + \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0mvalue >= is not a member\
    \ of Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpey_ffygq.scala:24:55 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x >= -\e\
    [31m214"
  stdout: ''
  timestamp: 1660010414
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val split =\
    \ value.split(\"\\\\.\") // Split value by decimal point\n        val integer\
    \ = split(0).toLong // Convert first part to long \n        var previous = integer\
    \ - 1\n        for (s <- split.tail) {\n            val newInteger = previous\
    \ + s.toLong // Add value to previous\n            if (Math.abs(newInteger) <\
    \ Math.abs(previous)) {\n                previous = newInteger // Check if value\
    \ has moved\n            } else {\n                // If the difference between\
    \ two integers is less than one\n                // then round away from zero\
    \ and return the integer value\n                return newInteger\n          \
    \  }\n        }\n        return integer\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_6lz8bza.scala:35)\n\tat Problem.main(tmp_6lz8bza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010412
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Complete\
    \ the implementation of the function here.\n        val floatvalue = java.lang.Float.parseFloat(value)\n\
    \        val intvalue   = java.lang.Integer.parseInt(value)\n        val intdiff\
    \    = intvalue - intvalue%1\n        val difference = java.lang.Math.abs(intdiff)\n\
    \        if (difference < 0.5) {\n            return intvalue + 1\n        } else\
    \ {\n            return intvalue - difference\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqiddg79v.scala:30)\n\tat Problem.main(tmpqiddg79v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val arr = value.split(\"\
    \\\\.\").toList.map(_.toInt)\n        val sum = arr.sum\n        val mid = sum\
    \ / 2\n        val arr1 = arr.map(_ - mid)\n        val arr2 = arr1.map(math.min)\n\
    \        val closestLong = arr2.sum\n        return closestLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp9pmm0q97.scala:22:33 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr2\e[0m = arr1.map(math.min)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ expected type Int => B\n\e[31m\e[31m-- Error: /tmp/tmp9pmm0q97.scala:23:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestLong\e[0m = arr2.sum\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mDoubleIsFractional\e[0m in\
    \ \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // The function\
    \ returns the closest integer, but rounds\n        // it away from zero if the\
    \ number if equidistant from two\n        // integers.\n        var closestInt\
    \ : Long = math.abs(value.toDouble).toInt\n        var closestFromTwo : Long =\
    \ 0\n        \n        // If the value is negative, add it to closestFromTwo.\n\
    \        // If the value is positive, subtract it from closestFromTwo.\n     \
    \   if(value < 0){\n            closestFromTwo += value\n        }else{\n    \
    \        closestFromTwo -= value\n        }\n        \n        // If closestFromTwo\
    \ is equal to closestInt, then the\n        // numbers are equidistant. In this\
    \ case, add the\n        // integer to the closestInt.\n        if(closestFromTwo\
    \ == closestInt){\n            closestInt += value.toInt\n        }\n        \n\
    \        // Return the closest integer.\n        closestInt.toLong\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8a4kw3s1.scala:26:19\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m(value <\
    \ \e[31m0\e[0m){\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e\
    [0m                   Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e[0m        \
    \           Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8a4kw3s1.scala:27:27 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m            closestFromTwo += value\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Long - did you mean\
    \ Long.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8a4kw3s1.scala:29:27\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            closestFromTwo\
    \ -= value\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            value -= is not a member of Long - did you mean Long.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\") // split value into ints and decimals\n        val ns\
    \ = nums.tail // take last int from list to compare\n        val ds = nums.tail.tail\
    \ // take last decimal from list to compare\n        val ins = nums.head // take\
    \ first int from list to compare\n        val dec = nums.head.tail // take last\
    \ decimal from list to compare\n        var closestVal = math.MaxValue\n     \
    \   var closestDiff = math.MaxValue\n        var closestDiffInc = 0\n        var\
    \ closestDiffDec = 0\n        var closestDiffInt = 0\n        var closestDiffIntInc\
    \ = 0\n        var closestDiffDecimal = 0\n        var closestDiffDecimalInc =\
    \ 0\n        for (i<-ns.indices; i-->0)\n        {\n            val ni = ns.toDouble(i)\
    \ // convert to double\n            val dd = ds.toDouble(i) // convert to double\n\
    \            val ini = ins.toDouble(i) // convert to double\n            val dec\
    \ = dec.toDouble(i) // convert to double\n            val diffInc = Math.abs(ni\
    \ - ins) // absolute difference between input int and current input\n        \
    \    val diffDec = Math.abs(dd - dec) // absolute difference between input decimal\
    \ and current input\n            val diffInt = Math.abs(ni - ini) // absolute\
    \ difference between input int and current input\n            val diffDecimal\
    \ = Math.abs(dd - dec) // absolute difference between input decimal and current\
    \ input\n            if (diffInt < closestDiffInt)\n            {\n          \
    \      closestDiffInc = diffInt\n                closestDiffInt = diffInt\n  \
    \              closestVal = ni\n            }\n            if (diffDec < closestDiffDecimal)\n\
    \            {\n                closestDiffDec = diffDec\n                closestDiffDecimal\
    \ = diffDec\n                closestVal = dd\n            }\n            if (diffInc\
    \ < closestDiffInc)\n            {\n                closestDiffInc = diffInc\n\
    \                closestDiffInt = diffInc\n                closestVal = ni\n \
    \           }\n            if (diffDec < closestDiffDecimal)\n            {\n\
    \                closestDiffDec = diffDec\n                closestDiffDecimal\
    \ = diffDec\n                closestVal = dd\n            }\n            if (diffInc\
    \ < closestDiffInc)\n            {\n                closestDiffInc = diffInc\n\
    \                closestDiffInt = diffInc\n                closestVal = ni\n \
    \           }\n            if (diffDec < closestDiffDecimal)\n            {\n\
    \                closestDiffDec = diffDec\n                closestDiffDecimal\
    \ = diffDec\n                closestVal = dd\n            }\n        }\n     \
    \   for (i<-ds.indices; i-->0)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy0aavij7.scala:31:33 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (i<-ns.indices; i-->\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 '<-' expected, but ')' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpy0aavij7.scala:78:33 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mfor\e[0m (i<-ds.indices; i-->\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 '<-' expected, but ')' found\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpy0aavij7.scala:78:34 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mfor\e[0m (i<-ds.indices; i-->\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m  \
    \ |\e[0m                                  expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy0aavij7.scala:23:30\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e\
    [36mclosestVal\e[0m = math.MaxValue\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value MaxValue\
    \ is not a member of math\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy0aavij7.scala:24:31\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e\
    [36mclosestDiff\e[0m = math.MaxValue\n\e[31m\e[31m   |\e[0m                  \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value MaxValue\
    \ is not a member of math\n5 errors found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ goes here\n        val values = value.split(\"\\\\.\")\n        val firstPart\
    \ = values.get(0)\n        val secondPart = values.get(1)\n        if(firstPart.isEmpty){\n\
    \            if(secondPart.isEmpty){\n                return 0\n            }\n\
    \            return secondPart*1\n        }\n        if(secondPart.isEmpty){\n\
    \            return firstPart*1\n        }\n        val firstPartValue = firstPart.toInt\n\
    \        val secondPartValue = secondPart.toInt\n        if(firstPartValue > secondPartValue){\n\
    \            return firstPartValue - secondPartValue\n        }\n        return\
    \ firstPartValue + secondPartValue\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp225yz8kq.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mfirstPart\e[0m = values.get(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        value get is not a member of Array[String]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp225yz8kq.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msecondPart\e[0m = values.get(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         value get is not a member of Array[String]\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.trim().toInt;\n        val nums = intValue.grouped(2).map{x => x.toLong}.toSeq;\n\
    \        val differences = nums.map(x => Math.abs(x - intValue));\n        if(nums.isEmpty){\n\
    \            0\n        }else{\n            val closestIndex = differences.min;\n\
    \            val diffs = differences.toList;\n            diffs(closestIndex)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsk8hnrda.scala:19:28 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = intValue.grouped(\e\
    [31m2\e[0m).map{\e[36mx\e[0m => x.toLong}.toSeq;\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value grouped\
    \ is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010412
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val digits\
    \ = value.split(\"\\\\.\").map(_.toInt).toList\n        val digitValues = digits.map(x\
    \ => math.pow(10, x))\n        val closestToZero = digitValues.min\n        digits.maxBy(x\
    \ => math.abs(x - closestToZero))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt52l0v34.scala:25)\n\tat Problem.main(tmpt52l0v34.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number:\
    \ Double = parseDouble(value)\n        val result: Long = Math.ceil(number)\n\
    \        // Return result if it is equidistant from 2 other integers\n       \
    \ if(Math.abs(number-result) == 0.5l) result else number\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpae0nz363.scala:21:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m(Math.abs(number-result) == 0.5l)\
    \ result \e[33melse\e[0m number\n\e[31m\e[31m   |\e[0m                       \
    \               ^\e[0m\n\e[31m   |\e[0m                                      Invalid\
    \ literal number\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpae0nz363.scala:18:29\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mnumber\e[0m: \e[35mDouble\e[0m = parseDouble(value)\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \               Not found: parseDouble\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpae0nz363.scala:19:36 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mLong\e[0m\
    \ = Math.ceil(number)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    Double\n\e[31m   |\e\
    [0m                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpae0nz363.scala:21:56 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m(Math.abs(number-result) == 0.5l)\
    \ result \e[33melse\e[0m number\n\e[31m\e[31m   |\e[0m                       \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    (number : Double)\n\e[31m   |\e[0m  \
    \                                           Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // TODO: Your\
    \ code here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcnlqd01v.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m// TODO: Your code here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010413
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value contains\
    \ \".\") {\n            val doubleValue = value.toDouble\n            // The Math.round()\
    \ method rounds the value towards zero.\n            return math.round(doubleValue).toLong\n\
    \        } else {\n            val intValue = value.toInt\n            // The\
    \ Math.round() method rounds the value towards zero.\n            return math.round(intValue).toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr3ez3sm1.scala:31)\n\tat Problem.main(tmpr3ez3sm1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Extract\
    \ the integer and decimal parts of the number using the\n        // unapplySeq\
    \ method\n        val numParts = value.unapplySeq()\n        // Check if the number\
    \ is negative and if it is, return the\n        // integer part only\n       \
    \ if (numParts._2 < 0) numParts._1\n        // If it is not negative and the value\
    \ is positive, add the integer\n        // and the decimal parts and convert the\
    \ resulting strings to Longs\n        else {\n            val intPart = numParts._1\
    \ + numParts._2\n            val decimalPart = numParts._3\n            intPart.toLong\
    \ + decimalPart.toLong\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1rxbsm4_.scala:20:29 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnumParts\e[0m = value.unapplySeq()\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       value unapplySeq is not a member of String\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = scala.math.BigDecimal(value).intValue\n        val closestInteger = Math.abs(intValue)\
    \ - 1\n        closestInteger.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmvjz9ccd.scala:23)\n\tat Problem.main(tmpmvjz9ccd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toLong\n        val smallestDiff = math.min(math.abs(number), number\
    \ / 2)\n        val maxDiff = math.max(math.abs(number), number / 2)\n       \
    \ if (smallestDiff < maxDiff)\n        {\n            math.round(number);\n  \
    \      }\n        else\n        {\n            math.floor(number);\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zejiqa2.scala:27:22\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            math.floor(number);\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        Found:    Double\n\e[31m   |\e[0m            Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val stringArray\
    \ = value.split(\"\\\\.\").toArray\n        val firstInteger = stringArray(1).toLong\n\
    \        val secondInteger = stringArray(2).toLong\n        if (firstInteger <\
    \ secondInteger) secondInteger else firstInteger\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpanx4ihnk.scala:19)\n\tat Problem$.main(tmpanx4ihnk.scala:24)\n\
    \tat Problem.main(tmpanx4ihnk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intVal\
    \ = Try(value.toInt) match {\n            case Success(num) => num\n         \
    \   case Failure(_) => null\n        }\n        if(intVal == null) {\n       \
    \     null\n        }\n        val intDiff = abs((intVal-intVal.toDouble)/intVal.toDouble).toInt\n\
    \        (intVal + (intDiff < 1l) ? intDiff : 1l)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj3fnqq0a.scala:18:21 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mintVal\e[0m = Try(value.toInt)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: Try\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpj3fnqq0a.scala:19:17 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m Success(num) => num\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not\
    \ found: Success\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj3fnqq0a.scala:20:17\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e\
    [0m Failure(_) => \e[31mnull\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: Failure\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj3fnqq0a.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintDiff\e[0m = abs((intVal-intVal.toDouble)/intVal.toDouble).toInt\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj3fnqq0a.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        (intVal + (intDiff < \e[31m1l\e[0m) ? intDiff\
    \ : \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m         ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of Any, but could be made available as an extensio"
  stdout: ''
  timestamp: 1660010417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val valueAsLong\
    \ = value.asInstanceOf[String].toLong\n        val difference = differenceBetweenValues(valueAsLong)\n\
    \        // If difference is negative, then it is closer than zero. \n       \
    \ // If difference is positive, then it is closer than positive.\n        // If\
    \ difference is zero, then it is equidistant from two integers\n        // The\
    \ one you should return is the one which is closer to zero.\n        if (difference\
    \ > 0) return valueAsLong\n        if (difference < 0) return -valueAsLong\n \
    \       else return 0\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzpvdrq2z.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdifference\e[0m = differenceBetweenValues(valueAsLong)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: differenceBetweenValues\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val list =\
    \ value.split(\".\") // Split into array of ints\n        val listOfInts = list.map(_.toInt).toList\
    \ // convert string array\n        val list = listOfInts.sortWith(_ < _) // sort\
    \ array\n        if (list.size == 1) list.head // if only one item return it\n\
    \        else list.last - listOfInts.last // otherwise, return the last int that\
    \ isn't the closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfoq7lzwa.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = listOfInts.sortWith(_\
    \ < _) \e[34m// sort array\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlist is already defined as \e[33mvalue\e[0m \e[35mlist\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfoq7lzwa.scala:21:33 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mif\e[0m (list.size == \e[31m1\e[0m) list.head \e[34m// if\
    \ only one item return it\e[0m\n\e[31m\e[31m   |\e[0m                        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:    String\n\
    \e[31m   |\e[0m                            Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpfoq7lzwa.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m list.last - listOfInts.last \e\
    [34m// otherwise, return the last int that isn't the closest\e[0m\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val str = new\
    \ StringBuffer(value)\n        val num = str.slice(1).toInt\n        if (num ==\
    \ 0 || num == 1) return num\n        val diff = abs(num - closest(num, 0, num.toDouble))\n\
    \        if (diff < 1) {\n            closest(num, 0, diff)\n        } else {\n\
    \            closest(num, 1, diff)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9bn_7lxv.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnum\e[0m = str.slice(\e\
    [31m1\e[0m).toInt\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m   value slice is not a member of StringBuffer - did you mean str.clone?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bn_7lxv.scala:23:12 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            closest(num, \e[31m0\e[0m, diff)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: closest\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bn_7lxv.scala:25:12\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            closest(num,\
    \ \e[31m1\e[0m, diff)\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Not found: closest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val tokens\
    \ = value.split(\"\").toList\n        val totalLength = tokens.size\n        var\
    \ index = totalLength - 1\n        val distances = {\n            var totalDistance\
    \ = 0\n            var currentDistance = 0\n            var previousIndex = 0\n\
    \            while (index >= 0) {\n                val currentToken = tokens(index)\n\
    \                val previousToken = tokens(previousIndex)\n                if\
    \ (currentToken != previousToken) {\n                    currentDistance = math.abs(Integer.parseInt(currentToken)\
    \ - Integer.parseInt(previousToken))\n                    totalDistance += currentDistance\n\
    \                }\n                previousIndex -= 1\n                index\
    \ -= 1\n            }\n            totalDistance / totalLength\n        }\n  \
    \      val closestIndex = math.round(distances)\n        val closestToken = tokens(closestIndex)\n\
    \        Integer.parseInt(closestToken).toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp73vyfm1z.scala:38:34\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mclosestToken\e\
    [0m = tokens(closestIndex)\n\e[31m\e[31m   |\e[0m                            \
    \      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  Found:\
    \    (closestIndex : Long)\n\e[31m   |\e[0m                                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val input =\
    \ value.split(\",\")\n        val n = input(0).toLong\n        val x0 = input(1)\n\
    \        val x1 = input(2)\n        var closest = 0\n        var closest = n\n\
    \        val minDiff = math.abs(n-x0) + math.abs(n-x1)\n        var x = 0\n  \
    \      if(n >= x0) {\n            if(n < x1)\n                x = n\n        \
    \    else {\n                x = x1\n            }\n        } else if(n < x1)\
    \ {\n            x = x0\n        } else {\n            x = x1\n        }\n   \
    \     while(x != n) {\n            val diff = Math.abs(n-x)\n            if(diff\
    \ < minDiff) {\n                minDiff = diff\n                closest = x\n\
    \            }\n            x = x + 1\n        }\n        return closest.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv20pzx5t.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mclosest\e[0m = n\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclosest is already defined\
    \ as \e[33mvariable\e[0m \e[35mclosest\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpv20pzx5t.scala:24:32 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = math.abs(n-x0)\
    \ + math.abs(n-x1)\n\e[31m\e[31m   |\e[0m                               ^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((x0 : String))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpv20pzx5t.scala:26:13\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m(n\
    \ >= x0) {\n\e[31m\e[31m   |\e[0m           ^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m>=\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m \
    \  |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e\
    [0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x:\
    \ Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments\
    \ ((x0 : String))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpv20pzx5t.scala:27:17\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e\
    [0m(n < x1)\n\e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m \
    \  |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e\
    [0m (x: Int): Boolean\n\e[31m"
  stdout: ''
  timestamp: 1660010417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value match\
    \ {\n            case \"+inf\" => Long.MaxValue\n            case \"-inf\" =>\
    \ Long.MinValue\n            case x => x\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp15awrstv.scala:21:22\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m x\
    \ => x\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m   \
    \                   Found:    (x : String)\n\e[31m   |\e[0m                  \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var diff :\
    \ Double = 0.0\n        val digits = value.dropWhile(_ < '0').dropWhile(_ < '9')\n\
    \        for (i <- digits){\n            diff = math.pow(i.toLong, 2).toDouble\
    \ - diff\n        }\n        diff * math.pow(10, digits.length)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzvt54wxt.scala:23:8\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m        diff * math.pow(\e[31m10\e\
    [0m, digits.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val stringToLong\
    \ = Long.parseLong(value)\n        val difference = stringToLong - Integer.parseInt(stringToLong.toString)\n\
    \        return if (difference < 0) 0l else if (difference > 0) difference else\
    \ stringToLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxj9usnu7.scala:18:32 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstringToLong\e[0m = Long.parseLong(value)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                          value parseLong is not a member of object Long\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def nearestFactorial(n:Int)\
    \ : Int = {\n            val i = 2\n            while (i <= n) {\n           \
    \     if (n % i == 0) {\n                    return i\n                }\n   \
    \             i += 1\n            }\n            1\n        }\n        val factors\
    \ = value.split(\"\\\\.\").map(x => x.toInt).toList\n        def sum(xs: List[Int])\
    \ : Long = { sum(xs, 0l) }\n        def sum(xs: List[Int], sum: Long) : Long =\
    \ { xs.foldLeft(sum) { \n            (acc, x) => acc + x * nearestFactorial(x)\
    \ \n        }}\n        val a = sum.asInstanceOf[Long]\n        val b = factors.foldRight(a)\
    \ { \n            (acc, x) => acc + nearestFactorial(x) \n        }\n        (a\
    \ + b) % 1L\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3j40npg_.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mdef\e[0m \e[36msum\e[0m(\e[36mxs\e[0m:\
    \ \e[35mList\e[0m[\e[35mInt\e[0m], \e[36msum\e[0m: \e[35mLong\e[0m) : \e[35mLong\e\
    [0m = { xs.foldLeft(sum) { \n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0msum is already defined as \e[33mmethod\e[0m \e[35msum\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m31 |\e[0m            (\e[36macc\e[0m, \e[36mx\e\
    [0m) => acc + x * nearestFactorial(x) \n\e[31m32 |\e[0m        }}\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3j40npg_.scala:24:18 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                i += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m                value += is not a\
    \ member of Int - did you mean i.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3j40npg_.scala:29:46 --------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \        \e[33mdef\e[0m \e[36msum\e[0m(\e[36mxs\e[0m: \e[35mList\e[0m[\e[35mInt\e\
    [0m]) : \e[35mLong\e[0m = { sum(xs, \e[31m0l\e[0m) }\n\e[31m\e[31m   |\e[0m  \
    \                                            ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                         Found:    \e[1m\e[31m(\e[0mList[Int]\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m\n\e[31m\
    \   |\e[0m                                             Required: List[Int]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3j40npg_.scala:35:47\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            (\e[36macc\e[0m,\
    \ \e[36mx\e[0m) => acc + nearestFactorial(x) \n\e[31m\e[31m   |\e[0m         \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                                Found:    (x : Long)\n\e[31m   |\e[0m       \
    \                                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010424
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Write your\
    \ logic here\n        var result : Long = 0\n        var diff : Long = 0\n   \
    \     var temp : Long = 0\n        val parts = value.split(\"\\\\.\") \n     \
    \   for(p <- parts) {\n            if (p.length > 1) {\n                temp =\
    \ p.toLong\n                val temp1 =  p.toLong * 10\n                result\
    \ = temp\n                diff = Math.abs(result - temp1)\n                if\
    \ (diff > 0) {\n                    result = result / 10\n                }\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp754gelhs.scala:37)\n\tat Problem.main(tmp754gelhs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // If value\
    \ is equal to an integer, return it.\n        if (value.endsWith(\"l\")) value\
    \ + 0l\n        else if (value.endsWith(\"d\")) value + 0d\n        else if (value.endsWith(\"\
    m\")) value + 0m\n        else if (value.endsWith(\"s\")) value + 0s\n       \
    \ else value + 0\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphnwo63db.scala:21:48 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (value.endsWith(\e\
    [31m\"m\"\e[0m)) value + \e[31m0\e[0mm\n\e[31m\e[31m   |\e[0m                \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                 expression expected but \e[31melse\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnwo63db.scala:19:33 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (value.endsWith(\e[31m\"l\"\e[0m))\
    \ value + \e[31m0l\e[0m\n\e[31m\e[31m   |\e[0m                               \
    \  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:   \
    \ String\n\e[31m   |\e[0m                                 Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphnwo63db.scala:20:38 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (value.endsWith(\e\
    [31m\"d\"\e[0m)) value + \e[31m0d\e[0m\n\e[31m\e[31m   |\e[0m                \
    \                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                Found:    String\n\e[31m   |\e[0m                           \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9m_5uogp.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\",\")\n        val min = numbers.toSeq.map(_.toDouble).min\n\
    \        val max = numbers.toSeq.map(_.toDouble).max\n        val diff = max -\
    \ min\n        diff < 0 match {\n            case true => min + diff\n       \
    \     case false => max - diff\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt8omelvu.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e\
    [31mtrue\e[0m => min + diff\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    Double\n\e[31m   |\e[0m\
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpt8omelvu.scala:24:26 --------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e[31mfalse\e[0m => max - diff\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Found:    Double\n\e[31m   |\e[0m                 \
    \         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Declare\
    \ variables to store the closest and second closest values\n        // and initialize\
    \ them to the number 0 and the number Integer.MAX_VALUE\n        // respectively.\n\
    \        var closest = 0l\n        var secondClosest = Integer.MAX_VALUE\n   \
    \     // Split the given string into an array of strings of the form\n       \
    \ // \"[<number>, <number>, ..., <number>]\" where each <number> is a\n      \
    \  // single integer between 0 and Integer.MAX_VALUE.\n        var integerArray\
    \ = value.split(\"\\\\.\")\n        // Loop over the array of integers\n     \
    \   for(integer <- integerArray) {\n            // Convert the given number string\
    \ to an integer and store it\n            // in an integerVariable.\n        \
    \    val integerVariable = integer.toInt\n            // If the numberVariable\
    \ is closer to 0 than to the closest number,\n            // then update to the\
    \ closer number as the closest number.\n            if(integerVariable < closest)\
    \ {\n                closest = 0l\n            }\n            // If the numberVariable\
    \ is closer to Integer.MAX_VALUE than to\n            // the second closest number,\
    \ then update to the closer number as\n            // the second closest number.\n\
    \            if(integerVariable > secondClosest) {\n                secondClosest\
    \ = Integer.MAX_VALUE\n            }\n            // Update the closest and second\
    \ closest numbers to whichever one\n            // is closest to 0.\n        \
    \    if(integerVariable < closest) {\n                closest = integerVariable\n\
    \            }\n            if(integerVariable > secondClosest) {\n          \
    \      secondClosest = integerVariable\n            }\n        }\n        // Return\
    \ either the closest or second closest number\n        closest + secondClosest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80x1mp92.scala:56)\n\tat Problem.main(tmp80x1mp92.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n        val nums = value.split(\"\\\\.\").map(_.toDouble).toList\n   \
    \     var closestDiff = Double.PositiveInfinity\n        var closestNumber = 0\n\
    \        for(i <- 0 until nums.size){\n            var num = nums(i)\n       \
    \     if(Math.abs(num - closestNumber) < closestDiff){\n                closestDiff\
    \ = Math.abs(num - closestNumber)\n                closestNumber = num\n     \
    \       }\n        }\n        closestNumber\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpil2zcjwe.scala:26:32\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                closestNumber\
    \ = num\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e[31m\
    \   |\e[0m                                Found:    (num : Double)\n\e[31m   |\e\
    [0m                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closest\
    \ = Long.MaxValue - 1L\n        val numbers = value.split(\"\\\\.\").toList\n\
    \        val numList = new mutable.ListBuffer[Long]\n        for (i <- 0 to (numbers.size\
    \ - 1)) {\n            val num = numbers(i).toLong\n            numList.append(num)\n\
    \        }\n        val difference = (numList.last.abs() - numList(0)).abs\n \
    \       if (difference < closest) {\n            closest = difference\n      \
    \  }\n        closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6j0hmu0i.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnumList\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010422
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toLong\n\
    \        if (n < 0) return Long.MaxValue\n        if (n > Long.MaxValue) return\
    \ Long.MinValue\n        val dl = n % 1\n        if (dl == 0) return n\n     \
    \   if (dl < 0.5) {\n            val r = n - 1\n            val d = (r - 1) %\
    \ 1\n            if (Math.abs(d) < 0.5) r\n            else if (d == 0) r\n  \
    \          else r + 1\n        } else (n - 1) % 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmp8p_9av1e.scala:18)\n\
    \tat Problem$.main(tmp8p_9av1e.scala:33)\n\tat Problem.main(tmp8p_9av1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numValue\
    \ = Try(value.toLong).toOption\n        if(numValue.isFailure) throw new IllegalArgumentException(\"\
    Invalid value provided for argument: \" + value)\n        val diff = Math.abs(numValue.get.toLong\
    \ - numValue.get.toLong)\n        if(diff < Math.abs(numValue.get.toLong - numValue.get.toLong))\
    \ numValue.get.toLong\n        else numValue.get.toLong - diff\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfcuplrut.scala:18:23 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnumValue\e[0m = Try(value.toLong).toOption\n\
    \e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m        \
    \               Not found: Try\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList.map(_.toInt)\n        var minDist : Long = 100000\n\
    \        var minVal : Long = 100000\n        var curVal : Long = 0\n        var\
    \ diff : Long = 0\n        for ( n <- numbers ) {\n            curVal = n\n  \
    \          diff = abs(curVal - minVal)\n            if ( diff < minDist ) {\n\
    \                minDist = diff\n                minVal = curVal\n           \
    \ } else if ( diff == minDist ) {\n                // If the difference between\
    \ the current value and the previous\n                // value is less than the\
    \ smallest distance, then the current\n                // value should be updated\
    \ as the smallest distance has been\n                // updated.\n           \
    \     minVal = curVal\n            }\n        }\n        minVal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpst9t8c7a.scala:41)\n\tat Problem.main(tmpst9t8c7a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closestValue\
    \ = Long.MaxValue\n        var closestIndex = 0\n        for (i <- 0 until value.length)\n\
    \        {\n            val testValue = value.toDouble(i)\n            val absDiff\
    \ = testValue - closestValue\n            val diffAbs = Math.abs(absDiff)\n  \
    \          if (diffAbs < closestDiff)\n            {\n                closestValue\
    \ = testValue\n                closestIndex = i\n                closestDiff =\
    \ diffAbs\n            }\n        }\n        closestValue\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpld7bw_1n.scala:22:34 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mtestValue\e[0m = value.toDouble(i)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m             \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e[33mclass\e[0m\
    \ \e[35mStringOps\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpld7bw_1n.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                closestDiff = diffAbs\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not\
    \ found: closestDiff\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val split = intValue.split('.')\n    \
    \    val integers = split(0).map(_.toLong)\n        val remainder = split(1).map(_.toLong)\n\
    \n        val diffs = remainder zip integers\n        val smallest = diffs.filter(_._1\
    \ < 0).max\n        val largest = diffs.filter(_._1 > 0).min\n        smallest.max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxd5c3yp9.scala:26:17 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        smallest.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue max is not a member of (Long, Long), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following\
    \ import might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val values\
    \ = value.split(\",\")\n        var closestVal = -1L\n        var closestDiff\
    \ = Long.MaxValue\n        val array = new mutable.ArrayBuilder[String](values.length)\n\
    \        for (i <- 0 until values.length) {\n            val stringValue = value(i)\n\
    \            val value = stringValue.trim\n            val intValue = try {\n\
    \                val parsedValue = new BigDecimal(value)\n                parsedValue.toLong\n\
    \            } catch { case _ : Exception => 0 }\n            if (intValue < closestDiff)\
    \ {\n                closestVal = intValue\n                closestDiff = intValue\n\
    \            }\n            array.add(value)\n        }\n        val diff = closestDiff\n\
    \        if (diff == 0) {\n            // If difference is zero we can just return\
    \ closestVal since it is the\n            // closest integer\n            return\
    \ closestVal\n        } else {\n            // If difference is not zero then\
    \ we want the closest integer\n            // that is closest to zero. Since we\
    \ only care about the closest\n            // integer we get the absolute value\
    \ of the difference. If the difference\n            // is greater than or equal\
    \ to 0 we return the closestVal value. Otherwise\n            // we return the\
    \ closestVal plus diff, which in this case is positive.\n            if (diff\
    \ >= 0) {\n                return closestVal\n            } else {\n         \
    \       return closestVal + diff\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnervtq_h.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36marray\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuilder[\e[35mString\e[0m](values.length)\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val tokens\
    \ = value.split(\"\\\\.\")\n        val l = tokens.length\n        var i = 0\n\
    \        var closest = 0\n        var difference = 0\n        val minDiff = math.pow(10,\
    \ l)\n        while (i < l) {\n            val currentNum = tokens(i).toLong\n\
    \            val currentDiff = abs(currentNum - closest)\n            if (currentDiff\
    \ < difference) {\n                difference = currentDiff\n                closest\
    \ = currentNum\n            }\n            i += 1\n        }\n        if (difference\
    \ < minDiff) {\n            closest\n        } else {\n            closest - (difference\
    \ - minDiff)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3b_46txl.scala:28:29\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                difference =\
    \ currentDiff\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (currentDiff : Long)\n\
    \e[31m   |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3b_46txl.scala:29:26 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                closest = currentNum\n\e[31m\e[31m  \
    \ |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \               Found:    (currentNum : Long)\n\e[31m   |\e[0m               \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3b_46txl.scala:36:12 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            closest - (difference - minDiff)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    Double\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010427
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parsedValue\
    \ = value.asInstanceOf[Number].longValue\n        val difference = math.abs(parsedValue\
    \ - java.lang.Double.valueOf(parsedValue))\n        if (parsedValue > java.lang.Double.valueOf(\"\
    0.0\") || parsedValue < java.lang.Double.valueOf(\"-0.001\"))\n            return\
    \ parsedValue\n        val integerPartOfNumber: Long = parsedValue - java.lang.Double.valueOf(\"\
    1\").longValue\n        if (difference < java.lang.Double.valueOf(\"0.0001\"))\n\
    \            return integerPartOfNumber\n        if (difference < java.lang.Double.valueOf(\"\
    0.00000\"))\n            return java.lang.Double.valueOf(\"0\").longValue + integerPartOfNumber\n\
    \        return java.lang.Double.valueOf(\"0.999999\").longValue + integerPartOfNumber\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ClassCastException: class java.lang.String cannot be cast to\
    \ class java.lang.Number (java.lang.String and java.lang.Number are in module\
    \ java.base of loader 'bootstrap')\n\tat Problem$.closestInteger(tmpggv5ofrm.scala:18)\n\
    \tat Problem$.main(tmpggv5ofrm.scala:30)\n\tat Problem.main(tmpggv5ofrm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ value to a number, ignoring non-numeric values\n        value = value.replaceAll(\"\
    [^0-9]+\", \"\")\n        val n = value.toLong\n        // Find two numbers, closest\
    \ to zero and furthest from zero\n        val closestOne = math.min(n, math.max(-n,\
    \ 0))\n        val furthestOne = math.max(math.min(n, math.max(-n, 0)), 0)\n \
    \       // Return the integer closer to zero or the integer furthest from zero\n\
    \        (closestOne - furthestOne).toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpu54i6a4g.scala:19:14 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        value = value.replaceAll(\e[31m\"[^0-9]+\"\e\
    [0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val value\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val vals =\
    \ value.split(\".\");\n        val number = vals.toInt;\n        val positiveValues\
    \ = numbers.filter(n => n > 0).map(n => Math.abs(n)).max\n        val negativeValues\
    \ = numbers.filter(n => n < 0).map(n => Math.abs(n)).min\n        val value =\
    \ if(positiveValues.isDefined && negativeValues.isDefined) positiveValues.get.max\
    \ else negativeValues.get.min\n        val closest = (number + value).toLong\n\
    \        return closest;\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzpkfnlfs.scala:20:29 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mpositiveValues\e[0m = numbers.filter(\e\
    [36mn\e[0m => n > \e[31m0\e[0m).map(\e[36mn\e[0m => Math.abs(n)).max\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                       Not found: numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpzpkfnlfs.scala:21:29 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnegativeValues\e[0m = numbers.filter(\e\
    [36mn\e[0m => n < \e[31m0\e[0m).map(\e[36mn\e[0m => Math.abs(n)).min\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                       Not found: numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.trim\n\
    \        val numList = num.split(\"\\\\.\").map( _.toLong )\n        var closestVal\
    \ = (numList.min max 0)\n        val numList2 = numList.filter( i => i > closestVal)\n\
    \        val numList3 = numList2.map( i => closestVal = i).filter( i => i == 0)\n\
    \        if(numList3.nonEmpty) {\n            val closestInt = numList3.max\n\
    \            if(closestInt == (numList.max max 0)) {\n                closestVal\
    \ = closestInt + 1\n            }\n        }\n        closestVal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpksjcrkna.scala:22:71 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnumList3\e[0m = numList2.map(\
    \ \e[36mi\e[0m => closestVal = i).filter( \e[36mi\e[0m => i == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m           Values of types Unit and\
    \ Int cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpksjcrkna.scala:25:15\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \     \e[33mif\e[0m(closestInt == (numList.max max \e[31m0\e[0m)) {\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m          Values of types Unit and Long cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpksjcrkna.scala:26:40 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                closestVal = closestInt + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue + is not a member of Unit, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\",\").map(_.toInt)\n        // Find distance between two points\n\
    \        val distance = numbers.zip(numbers).map(x => math.sqrt(x._1 - x._2)).max\n\
    \        distance.round\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9l83pj2s.scala:24)\n\tat Problem.main(tmp9l83pj2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.max(parts(0)-parts(1),\
    \ parts(0)-parts(2))\n        val minDiffAbs = math.abs(minDiff)\n        val\
    \ minDiffSign = math.signum(minDiffAbs)\n        val minDiffFloor = math.floor(minDiffAbs)\n\
    \        val minDiffCeil = math.ceil(minDiffAbs)\n        val minDiffFloorCeil\
    \ = math.floorCeil(minDiffAbs)\n        val minDiffCeilCeil = math.ceilCeil(minDiffAbs)\n\
    \n        if (minDiffCeil==0){\n            return math.min(parts(0), parts(1))\n\
    \        }\n\n        if (minDiff==0){\n            return math.min(parts(0),\
    \ parts(1))\n        }\n\n        if (minDiffFloor == 0) {\n            var newDiff\
    \ = math.max(parts(0)-parts(1), parts(0)-parts(2))\n            if (newDiff==0)\
    \ {\n                return math.min(parts(0), parts(1))\n            }\n    \
    \        var newDiffAbs = math.abs(newDiff)\n            var newDiffSign = math.signum(newDiffAbs)\n\
    \            var newDiffFloor = math.floor(newDiffAbs)\n            var newDiffCeil\
    \ = math.ceil(newDiffAbs)\n            var newDiffFloorCeil = math.floorCeil(newDiffAbs)\n\
    \            var newDiffCeilCeil = math.ceilCeil(newDiffAbs)\n            if (newDiffCeil==0){\n\
    \                return math.min(parts(0), parts(1))\n            }\n        \
    \    if (newDiff==0){\n                return math.min(parts(0), parts(1))\n \
    \           }\n            if (newDiffFloor == 0) {\n                var newDiff\
    \ = math.max(parts(0)-parts(1), parts(0)-parts(2))\n                if (newDiff==0)\
    \ {\n                    return math.min(parts(0), parts(1))\n               \
    \ }\n                var newDiffAbs = math.abs(newDiff)\n                var newDiffSign\
    \ = math.signum(newDiffAbs)\n                var newDiffFloor = math.floor(newDiffAbs)\n\
    \                var newDiffCeil = math.ceil(newDiffAbs)\n                var\
    \ newDiffFloorCeil = math.floorCeil(newDiffAbs)\n                var newDiffCeilCeil\
    \ = math.ceilCeil(newDiffAbs)\n                if (newDiffCeil==0){\n        \
    \            return math.min(parts(0), parts(1))\n                }\n        \
    \        if (newDiff==0){\n                    return math.min(parts(0), parts(1))\n\
    \                }\n                if (newDiffFloor == 0) {\n               \
    \     var newDiff = math.max(parts(0)-parts(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp32ve8ovd.scala:70:58 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m                    \e[33mvar\e[0m \e[36mnewDiff\e[0m\
    \ = math.max(parts(\e[31m0\e[0m)-parts(\n\e[31m\e[31m   |\e[0m               \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                             expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp32ve8ovd.scala:81:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp32ve8ovd.scala:24:36 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mminDiffFloorCeil\e[0m = math.floorCeil(minDiffAbs)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value floorCeil is not a member of math\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp32ve8ovd.scala:25:35 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mminDiffCeilCeil\e[0m = math.ceilCeil(minDiffAbs)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              value ceilCeil is not a member of math\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp32ve8ovd.scala:44:40 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            \e[33mvar\e[0m \e[36mnewDiffFloorCeil\e[0m\
    \ = math.floorCeil(newDiffAbs)\n\e[31m\e[31m   |\e[0m                        \
    \           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \    value floorCeil is not a member of math\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp32ve8ovd.scala:45:39 ------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m            \e[33mvar\e[0m \e[36mnewDiffCeilCeil\e[0m = math.ceilCeil(newDiffAbs)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  value ceilCeil is not a member\
    \ of math\n\e[31m\e[31m-- [E008] Not Found Error: "
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ goes here\n        val input = value.split(\"\\\\.\").map{\n            _.toLong\n\
    \        }.toList\n        val difference = (input - input(0));\n        val differences\
    \ = difference.collect{\n            (diff : Double, idx : Long) => (diff < 0,\
    \ idx)\n        }.toList;\n        val toRemove = differences.find(_._1==true).get._2;\n\
    \        val toAdd = differences.find(_._1 == false).get._2;\n        input(toRemove)\
    \ = input(toAdd)\n        (input(0) + input(1)).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpadhq4ec1.scala:22:32 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdifference\e[0m = (input\
    \ - input(\e[31m0\e[0m));\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpadhq4ec1.scala:28:8 -------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        input(toRemove) = input(toAdd)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long]\
    \ - did you mean input.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val valueAsLong\
    \ = parseLong(value)\n        val min = valueAsLong - Math.abs(valueAsLong % 1)\n\
    \        val max = valueAsLong + Math.abs(valueAsLong % 1)\n        val isClosestToZero\
    \ = min % 1 == 0 && max % 1 == 0\n        if (isClosestToZero) {\n           \
    \ return valueAsLong\n        }\n        else {\n            return Math.min(min,\
    \ max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp05gm7gvj.scala:18:26 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mvalueAsLong\e[0m = parseLong(value)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: parseLong\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val digits\
    \ = value.map(_.toInt).toArray\n        // Find the closest integer\n        if\
    \ (digits.sum == 0) return 0\n        var closestDigit : Int = -1\n        var\
    \ sum : Long = 0\n        digits.foreach {\n            digit => {\n         \
    \       sum += digit\n                closestDigit = digit\n            }\n  \
    \      }\n        // Return the closest integer\n        if (sum < 0) return 0\n\
    \        else return closestDigit\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4czd3c.scala:34)\n\tat Problem.main(tmpb_4czd3c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ : Long = value match {\n            case \"0\" => 0\n            case \"1\"\
    \ => 1\n            case \"2\" => 2\n            case \"3\" => 3\n           \
    \ case \"4\" => 4\n            case \"5\" => 5\n            case \"6\" => 6\n\
    \            case \"7\" => 7\n            case \"8\" => 8\n            case \"\
    9\" => 9\n            case _ => Integer.parseInt(value)\n        }\n        var\
    \ closest : Long = intValue\n        var diff : Long = 0\n        while (closest\
    \ != intValue) {\n            if (diff < Math.abs(closest - intValue)) {\n   \
    \             diff = Math.abs(closest - intValue)\n                closest = intValue\n\
    \            } else {\n                closest = closest + diff\n            }\n\
    \        }\n        return closest\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat Problem$.closestInteger(tmpcjlbnq5h.scala:29)\n\tat Problem$.main(tmpcjlbnq5h.scala:45)\n\
    \tat Problem.main(tmpcjlbnq5h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010433
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val xs = value.split(\"\
    \\\\.\").map(_.toLong)\n        xs.foldLeft((-99999999,99999999)){\n         \
    \   case((diff,best) ,x) => if (x > best) (x, diff) else (best,diff)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk6zy81gd.scala:20:51\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m((diff,best)\
    \ ,x) => \e[33mif\e[0m (x > best) (x, diff) \e[33melse\e[0m (best,diff)\n\e[31m\e\
    [31m   |\e[0m                                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                                   Found:    (x : Long)\n\
    \e[31m   |\e[0m                                                   Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val (min, max) = nums.foldLeft((0,\
    \ Long.MaxValue))((a, b) => {\n            val l = abs(b - a).toInt\n        \
    \    if (l < min.asInstanceOf[Int]) (a, b) else (l, a)\n        })\n        val\
    \ mid = (min + max) / 2\n        val nums2 = nums.map(x => Math.round(x * 10)\
    \ / 10)\n        nums2.map(_ + mid)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpo1v4naen.scala:20:26 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = abs(b - a).toInt\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m None of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m  \
    \ |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m\
    \  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((a :\
    \ (Int, Long)))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo1v4naen.scala:21:44\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (l\
    \ < min.asInstanceOf[\e[35mInt\e[0m]) (a, b) \e[33melse\e[0m (l, a)\n\e[31m\e\
    [31m   |\e[0m                                            ^\e[0m\n\e[31m   |\e\
    [0m                                            Found:    (a : (Int, Long))\n\e\
    [31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo1v4naen.scala:21:59 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (l < min.asInstanceOf[\e[35mInt\e\
    [0m]) (a, b) \e[33melse\e[0m (l, a)\n\e[31m\e[31m   |\e[0m                   \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                Found:    (a : (Int, Long))\n\e[31m   |\e[0m\
    \                                             Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo1v4naen.scala:25:8 ---------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        nums2.map(_ + mid)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 "
  stdout: ''
  timestamp: 1660010435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.length\
    \ == 1)\n            value + \"0\"\n        val numString = value\n        val\
    \ n = numString.toDouble\n        val numbers = List.range(1, numString.length).map(x\
    \ => numString.substring(0, x)).toList\n        val dists = numbers.map(n => Math.pow(10.0,\
    \ (n - numString.toDouble)))\n        val min = math.min(dists.map(d => Math.pow(n,\
    \ 1.0 / d)))\n        val closestVal = numbers.map(n => Math.pow(n, 1.0 / min))\n\
    \        val index = closestVal.indexOf(min)\n        val rounding = closestVal(index).toString.substring(2)\n\
    \        (n - numString.toDouble).toLong * 1 + rounding\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_zaf2hru.scala:23:55 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mdists\e[0m = numbers.map(\e\
    [36mn\e[0m => Math.pow(\e[31m10.0\e[0m, (n - numString.toDouble)))\n\e[31m\e[31m\
    \   |\e[0m                                                     ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue - is not a member of String, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_zaf2hru.scala:24:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36mmin\e[0m = math.min(dists.map(\e[36md\e[0m => Math.pow(n, \e[31m1.0\e\
    [0m / d)))\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in\
    \ \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double,\
    \ y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e\
    [0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m  \
    \ |\e[0mmatch arguments (List[Double])\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_zaf2hru.scala:25:51 --------------------\e[0m\e[0m\n\e[31m25 |\e[0m\
    \        \e[33mval\e[0m \e[36mclosestVal\e[0m = numbers.map(\e[36mn\e[0m => Math.pow(n,\
    \ \e[31m1.0\e[0m / min))\n\e[31m\e[31m   |\e[0m                              \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                  Found:    (n : String)\n\e[31m   |\e[0m                   \
    \                               Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_zaf2hru.scala:28:8 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        (n - numString.toDouble).toLong * \e[31m1\e[0m\
    \ + rounding\n"
  stdout: ''
  timestamp: 1660010436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val stringToInt\
    \ = value.trim.toInt\n        if (stringToInt == 0)\n            return 0\n  \
    \      val closestInt = (stringToInt - math.abs(stringToInt - math.abs(stringToInt)))\n\
    \        closestInt > 0L ? closestInt.toLong : -closestInt.toLong\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgsdqqgct.scala:22:57 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        closestInt > \e[31m0L\e[0m ? closestInt.toLong\
    \ : \e[35m-closestInt\e[0m.toLong\n\e[31m\e[31m   |\e[0m                     \
    \                                    ^\e[0m\n\e[31m   |\e[0m                 \
    \                  an identifier expected, but '.' found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgsdqqgct.scala:22:24 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        closestInt > \e[31m0L\e[0m ? closestInt.toLong : \e\
    [35m-closestInt\e[0m.toLong\n\e[31m\e[31m   |\e[0m                     ^^^^\e\
    [0m\n\e[31m   |\e[0m                     value ? is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010434
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val ints =\
    \ value.split('.').toList\n        if (ints.size>1) {\n            val int1 =\
    \ ints.head.toLong\n            val int2 = ints.last.toLong\n            if (Math.abs(int1\
    \ - int2) == Math.abs(int1 - int2))\n                return int1\n           \
    \ else\n                return int2\n        }\n        else\n            ints.head.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdoy38kjl.scala:32)\n\tat Problem.main(tmpdoy38kjl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Extract\
    \ the numbers\n        val (intValue, decimal) = value.split(\".\") match {\n\
    \            case Array(a, b) => a.toLong * 10 + b.toLong\n            case a\
    \ => a.toLong\n        }\n        // Find the closest integer value\n        val\
    \ closestIntegerValue = (intValue - decimal.abs()).toInt\n        // Return the\
    \ closest integer value\n        closestIntegerValue\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9cfmsoix.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m a => a.toLong\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is\
    \ not a member of Array[String], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9cfmsoix.scala:24:44 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestIntegerValue\e[0m\
    \ = (intValue - decimal.abs()).toInt\n\e[31m\e[31m   |\e[0m                  \
    \                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9cfmsoix.scala:24:54 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestIntegerValue\e[0m\
    \ = (intValue - decimal.abs()).toInt\n\e[31m\e[31m   |\e[0m                  \
    \                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue abs is not\
    \ a member of Any, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Get a list\
    \ of integers that represent the value.\n        val ints = value.splitAt(value.length\
    \ - 1).map(_.toInt)\n        // If all the integers in the list are the same length,\
    \ return the list index\n        // of the first one\n        if(ints.forall(_.size\
    \ == ints.head.size)) {\n            return ints.indexWhere(_.size == ints.head.size)\n\
    \        } else {\n            // Otherwise, find the closest integer to the first\
    \ integer\n            // that has a length of at least one\n            val minIndex\
    \ = ints.indexWhere(x => x.size == ints.head.size)\n            val minValue =\
    \ ints(minIndex)\n            val diffs = minValue - ints\n            // If the\
    \ list is equidistant from two integers then return the\n            // smallest\
    \ one\n            if(diffs.forall(_.toDouble < 0)) {\n                return\
    \ minIndex\n            } else { \n                // Otherwise, return the index\
    \ of the smallest number greater than \n                // the integer represented\
    \ by the first integer in the list\n                val greaterIndex = ints.indexWhere(_.size\
    \ > minValue)\n                ints(greaterIndex)\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpugh7kf4c.scala:19:55 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mints\e[0m = value.splitAt(value.length\
    \ - \e[31m1\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                        \
    \                               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => _$1.toInt.\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpugh7kf4c.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m(ints.forall(_.size == ints.head.size))\
    \ {\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \    value forall is not a member of (Nothing, Nothing)\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpugh7kf4c.scala:23:24 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mreturn\e[0m ints.indexWhere(_.size == ints.head.size)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  value indexWhere is not a member of (Nothing, Nothing)\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpugh7kf4c.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mminIndex\e[0m = ints.indexWhere(\e\
    [36mx\e[0m => x.size == ints.head.size)\n\e[31m\e[31m   |\e[0m               \
    \            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  value indexWhere\
    \ is not a member of (Nothing, Nothing)\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpugh7kf4c.scala:29:33 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            \e[33mval\e[0m \e[36mdiffs\e[0m = minValue - ints\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of Tuple.Elem[Nothing *: Nothing *: EmptyTuple, \n\e[31m   |\e[0m \
    \ (minIndex : <error value indexWhere is not a member of (Nothing, Nothing)>)\n\
    \e[31m   |\e[0m], but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import"
  stdout: ''
  timestamp: 1660010437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \  = Integer.parseInt(value)\n        val diff      = intValue - intValue%100\n\
    \        val diff2     = diff - diff%10\n        val diff3     = diff2 - diff2%10\n\
    \        val diff4     = diff3 - diff3%10\n        val diff5     = diff4 - diff4%10\n\
    \        val diff6     = diff5 - diff5%10\n        val diff7     = diff6 - diff6%10\n\
    \        val diff8     = diff7 - diff7%10\n        val diff9     = diff8 - diff8%10\n\
    \        val diff10    = diff9 - diff9%10\n        val diff11    = diff10 - diff10%10\n\
    \        val diff12    = diff11 - diff11%10\n        val diff13    = diff12 -\
    \ diff12%10\n        val diff14    = diff13 - diff13%10\n        val diff15  \
    \  = diff14 - diff14%10\n        val diff16    = diff15 - diff15%10\n        val\
    \ diff17    = diff16 - diff16%10\n        val diff18    = diff17 - diff17%10\n\
    \        val diff19    = diff18 - diff18%10\n        val diff20    = diff19 -\
    \ diff19%10\n        val diff21    = diff20 - diff20%10\n        val diff22  \
    \  = diff21 - diff21%10\n        val diff23    = diff22 - diff22%10\n        val\
    \ diff24    = diff23 - diff23%10\n        val diff25    = diff24 - diff24%10\n\
    \        val diff26    = diff25 - diff25%10\n        val diff27    = diff26 -\
    \ diff26%10\n        val diff28    = diff27 - diff27%10\n        val diff29  \
    \  = diff28 - diff28%10\n        val diff30    = diff29 - diff29%10\n        val\
    \ diff31    = diff30 - diff30%10\n        val diff32    = diff31 - diff31%10\n\
    \        val diff33    = diff32 - diff32%10\n        val diff34    = diff33 -\
    \ diff33%10\n        val diff35    = diff34 - diff34%10\n        val diff36  \
    \  = diff35 - diff35%10\n        val diff37    = diff36 - diff36%10\n        val\
    \ diff38    = diff37 - diff37%10\n        val diff39    = diff38 - diff38%10\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpmmgsewk0.scala:58:11 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmmgsewk0.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parsedInt\
    \ : Long = Try(BigDecimal(value.toDouble)).orElse(0L)\n        val min = parsedInt\
    \ - parsedInt%min\n        val max = parsedInt + parsedInt%max\n        if (min\
    \ < max){\n            min\n        }else{\n            max\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbp2vrlpm.scala:18:31 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparsedInt\e[0m : \e[35mLong\e\
    [0m = Try(BigDecimal(value.toDouble)).orElse(\e[31m0L\e[0m)\n\e[31m\e[31m   |\e\
    [0m                               ^^^\e[0m\n\e[31m   |\e[0m                  \
    \             Not found: Try\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpbp2vrlpm.scala:19:40 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = parsedInt - parsedInt%min\n\e\
    [31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m   |\e\
    [0m                                        Recursive \e[33mvalue\e[0m \e[35mmin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbp2vrlpm.scala:20:40\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax\e[0m = parsedInt + parsedInt%max\n\e[31m\e[31m   |\e[0m          \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                 Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010433
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        //  write your\
    \ code\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc2mid8q1.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m//  write your code\e[0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val values\
    \ = value.split(\"\\\\.\") // Split on \".\"\n        var smallest = Integer.MIN_VALUE\n\
    \        var largest = Integer.MAX_VALUE\n        values.foreach { value =>\n\
    \            val newValue = value.trim.toInt\n            if (smallest > newValue)\
    \ {\n                smallest = newValue\n            }\n            if (largest\
    \ < newValue) {\n                largest = newValue\n            }\n        }\n\
    \        if (largest < smallest) {\n            // If largest is smaller than\
    \ smallest then largest is larger\n            // than smallest and smallest is\
    \ smaller than largest.\n            largest += 1\n        }\n        largest\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7mm8chy1.scala:38)\n\tat Problem.main(tmp7mm8chy1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010437
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toDouble\n        val listOfNumbers = List(intValue, 0)\n        val\
    \ indexOfZero = listOfNumbers.indexOf(listOfNumbers.max)\n        val numberOfIntegers\
    \ = listOfNumbers.length\n        val differenceFromZero = indexOfZero * numberOfIntegers\n\
    \        val differenceBetweenNumbers = Math.abs(intValue - listOfNumbers(indexOfZero))\n\
    \        val roundAwayFromZero = differenceFromZero + differenceBetweenNumbers\n\
    \        roundAwayFromZero.toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9j14vevs.scala:28)\n\tat Problem.main(tmp9j14vevs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\",\")\n        val smallestInteger = numbers(0).trim.toInt\n\
    \        val largestInteger = numbers(numbers.length-1).trim.toInt\n        var\
    \ smallestDiff = smallestInteger - smallestInteger\n        var largestDiff =\
    \ largestInteger - largestInteger\n        numbers(0).trim.toInt match {\n   \
    \         case x if (x == \"\") =>\n                0\n            case x =>\n\
    \                val newValue = smallestInteger + smallestDiff\n             \
    \   if (newValue > largestInteger) {\n                    largestDiff = smallestDiff\
    \ - smallestInteger\n                    smallestDiff = largestInteger - newValue\n\
    \                    largestInteger = newValue\n                    smallestInteger\
    \ = newValue\n                }\n                newValue\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkfp9juq7.scala:24:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m (x == \e\
    [31m\"\"\e[0m) =>\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m         Values of types Int and String cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkfp9juq7.scala:31:35 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    largestInteger = newValue\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val largestInteger\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpkfp9juq7.scala:32:36 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    smallestInteger = newValue\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val smallestInteger\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        var result = num\n        val smallestDiff = math.abs(num - math.floor(num))\n\
    \        val largestDiff = math.abs(num - math.ceil(num))\n        if (smallestDiff\
    \ < largestDiff) {\n            if (num < math.floor(num)) {\n               \
    \ result = math.floor(num)\n            } else if (num > math.ceil(num)) {\n \
    \               result = math.ceil(num)\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjinwa2t.scala:24:35\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                result = math.floor(num)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    Double\n\e[31m   |\e[0m                \
    \         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqjinwa2t.scala:26:34 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                result = math.ceil(num)\n\e[31m\e[31m   |\e[0m       \
    \                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Found:    Double\n\e[31m   |\e[0m                         Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ value to Long type\n        val value = value.asInstanceOf[String]\n       \
    \ val values = value.split('.').toList\n        val integer = values.map(_.toLong).sum\n\
    \        val difference = abs(integer - value.toLong)\n        if (difference\
    \ <= 10){\n            return integer\n        }\n        return integer - (difference\
    \ / 10)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8mzd60m0.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvalue\e[0m = value.asInstanceOf[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e\
    [0m                    Recursive \e[33mvalue\e[0m \e[35mvalue\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Use a mutable\
    \ set to hold a list of numbers. When we see a\n        // number that is equidistant\
    \ from two others, remove them\n        // from the set and return the new set.\
    \ Otherwise, return the\n        // original set\n        val mySet = mutable.HashSet[String]()\n\
    \        mySet += value\n        while (mySet.nonEmpty && mySet.toList.groupBy(_\
    \ - mySet.head).keys.toList.size > 1) {\n            mySet -= mySet.head\n   \
    \     }\n        mySet.toList.headOption.getOrElse(0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdhyyltw0.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmySet\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = new\
    \ BigDecimal(value)\n        // Return the closest integer less than or equal\
    \ to the number\n        num.intValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp574r491p.scala:18:33\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnum\e\
    [0m = \e[33mnew\e[0m \e[35mBigDecimal\e[0m(value)\n\e[31m\e[31m   |\e[0m     \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \            Found:    (value : String)\n\e[31m   |\e[0m                     \
    \            Required: java.math.BigDecimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closestInteger\
    \ = value.indexOf(\".\") == -1 ? value.toLong : int.parseInt(\"0\"+ value)\n \
    \       var closestDouble = closestInteger.toDouble\n        var closestInt =\
    \ closestInteger.toInt\n        // Keep dividing closestDouble by 10 until the\
    \ fraction is 0.\n        // Then subtract that from the closestInt until it's\
    \ 0.\n        // This way closestDouble will be closest to closestInt.\n     \
    \   while(closestDouble > 0.0 && closestDouble < 1.0) {\n            closestDouble\
    \ /= 10.0;\n            closestInt -= closestDouble * closestInt;\n        }\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptib4ffud.scala:18:83 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mclosestInteger\e[0m = value.indexOf(\e\
    [31m\".\"\e[0m) == -\e[31m1\e[0m ? value.toLong : int.parseInt(\e[31m\"0\"\e[0m+\
    \ value)\n\e[31m\e[31m   |\e[0m                                              \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                 end of statement expected but '(' found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptib4ffud.scala:18:71 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mclosestInteger\e[0m = value.indexOf(\e\
    [31m\".\"\e[0m) == -\e[31m1\e[0m ? value.toLong : int.parseInt(\e[31m\"0\"\e[0m+\
    \ value)\n\e[31m\e[31m   |\e[0m                                              \
    \                         ^^^\e[0m\n\e[31m   |\e[0m                          \
    \                                Not found: int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmptib4ffud.scala:18:54 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mclosestInteger\e[0m = value.indexOf(\e\
    [31m\".\"\e[0m) == -\e[31m1\e[0m ? value.toLong : int.parseInt(\e[31m\"0\"\e[0m+\
    \ value)\n\e[31m\e[31m   |\e[0m                                              \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                                          value\
    \ ? is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptib4ffud.scala:18:94\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mclosestInteger\e\
    [0m = value.indexOf(\e[31m\".\"\e[0m) == -\e[31m1\e[0m ? value.toLong : int.parseInt(\e\
    [31m\"0\"\e[0m+ value)\n\e[31m\e[31m   |\e[0m                                \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0m                                                          Found:   \
    \ Unit\n\e[31m   |\e[0m                                                      \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        //Use a for\
    \ loop to iterate through the String and convert each char\n        //into a numeric\
    \ value\n        //The value variable is of type String\n        for(i <- 0 until\
    \ value.length){\n            //If this char represents a number greater than\
    \ zero change it\n            //to an integer\n            //The charAt() method\
    \ takes a char and returns a char\n            if(i.value >= '0' && i.value <=\
    \ '9'){\n                //Convert the char to an int\n                val i =\
    \ i.toInt\n                //Return the closest int\n                return i\n\
    \            }\n        }\n        //Return 0 if the loop did not find a number\n\
    \        return 0\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpylzpo0gc.scala:25:17 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m(i.value >= \e[31m'0'\e[0m &&\
    \ i.value <= \e[31m'9'\e[0m){\n\e[31m\e[31m   |\e[0m               ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m               value value is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val stringArray\
    \ = value.split(\".\")\n      val lastNumber = stringArray(0)\n      val difference\
    \ = stringArray(0) - stringArray(1).reverse\n      val maxDiff = Math.abs(difference)\n\
    \      val closestDiff = Math.abs(difference - maxDiff)\n      val closestDiffIndex\
    \ = (difference - maxDiff).abs.toInt\n      val closestDiff = stringArray(0..closestDiffIndex).reverse\n\
    \      val roundingDiff = Math.abs(lastNumber - closestDiff(0))\n      val roundingDiffIndex\
    \ = lastNumber - closestDiff(0).abs.toInt\n      val roundingDiff = stringArray(0..roundingDiffIndex).reverse\n\
    \      val roundingDiffIndex = roundingDiffIndex + roundingDiff\n      val roundingDiff2\
    \ = Math.abs(roundingDiffIndex - difference)\n      val roundingDiffIndex = Math.max(roundingDiffIndex,\
    \ roundingDiffIndex)\n      val roundingDiff2 = Math.max(roundingDiff2, roundingDiff2)\n\
    \      val roundingDiffIndex = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex2\
    \ = Math.max(roundingDiffIndex2, roundingDiffIndex)\n      val roundingDiffIndex2\
    \ = Math.max(roundingDiffIndex2, roundingDiff2)\n      val roundingDiffIndex2\
    \ = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex3 = Math.max(roundingDiffIndex2,\
    \ roundingDiffIndex)\n      val roundingDiffIndex4 = Math.max(roundingDiffIndex3,\
    \ roundingDiffIndex)\n      val roundingDiffIndex5 = Math.max(roundingDiffIndex4,\
    \ roundingDiffIndex)\n      val roundingDiffIndex6 = Math.max(roundingDiffIndex5,\
    \ roundingDiffIndex)\n      val roundingDiffIndex7 = Math.max(roundingDiffIndex6,\
    \ roundingDiffIndex)\n      val roundingDiffIndex8 = roundingDiffIndex + roundingDiff\n\
    \      val roundingDiffIndex9 = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex10\
    \ = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex11 = roundingDiffIndex\
    \ + roundingDiff\n      val roundingDiffIndex12 = roundingDiffIndex + roundingDiff\n\
    \      val roundingDiffIndex13 = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex14\
    \ = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex15 = roundingDiffIndex\
    \ + roundingDiff\n      val roundingDiffIndex16 = roundingDiffIndex + roundingDiff\n\
    \      val roundingDiffIndex\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpafpoxoj7.scala:24:38 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m      \e[33mval\e[0m \e[36mclosestDiff\e[0m = stringArray(\e\
    [31m0\e[0m..closestDiffIndex).reverse\n\e[31m\e[31m   |\e[0m                 \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \   an identifier expected, but '.' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpafpoxoj7.scala:27:39 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m      \e[33mval\e[0m \e[36mroundingDiff\e[0m = stringArray(\e[31m0\e[0m..roundingDiffIndex).reverse\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                   an identifier expected, but '.' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpafpoxoj7.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpafpoxoj7.scala:28:10\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m      \e[33mval\e[0m \e\
    [36mroundingDiffIndex\e[0m = roundingDiffIndex + roundingDiff\n\e[31m\e[31m  \
    \ |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mroundingDiffIndex is already defined as \e[33mvalue\e[0m \e[35mroundingDiffIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpafpoxoj7.scala:30:10 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m      \e[33mval\e[0m \e[36mroundingDiffIndex\e[0m = Math.max(roundingDiffIndex,\
    \ roundingDiffIndex)\n\e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mroundingDiffIndex is already defined as \e[33mvalue\e[0m \e\
    [35mroundingDiffIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpafpoxoj7.scala:31:10 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mval\e[0m \e[36mroun"
  stdout: ''
  timestamp: 1660010444
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closestInt\
    \ : Long = Long.MinValue\n        var closestDiff = Long.MinValue\n        val\
    \ parts = value.split(\".\")\n        val firstPart = parts.get(0)\n        val\
    \ secondPart = parts.get(1) match {\n            case s if s.isEmpty() => \"0\"\
    \n            case s2 => s2\n        }\n        var num : Long = secondPart.toLong\
    \ * 10\n        var num2 : Long = firstPart.toLong * 10\n        var diff : Long\
    \ = Math.abs(num - num2)\n        while (num != num2){\n            num2 += diff\n\
    \            if (num2 == num){\n                diff -= 1\n            }\n   \
    \         num += 1\n        }\n        closestInt = num\n        closestDiff =\
    \ diff\n        return closestInt\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbx7dxy72.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfirstPart\e[0m = parts.get(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        value get is not a member of Array[String]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbx7dxy72.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msecondPart\e[0m = parts.get(\e\
    [31m1\e[0m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                        \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value get is not a member\
    \ of Array[String]\n2 errors found\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val digits\
    \ = value.substring(1, value.length-1).toInt\n        if(digits < 2) digits\n\
    \        else {\n            val lastDigit = value.substring(0,value.length-1).toInt\n\
    \            if(abs(digits-lastDigit) == 1) digits+lastDigit\n            else\
    \ lastDigit\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:678)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpo6pv3jil.scala:18)\n\
    \tat Problem$.main(tmpo6pv3jil.scala:27)\n\tat Problem.main(tmpo6pv3jil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010444
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ goes here\n        val nums = value.split(\",\")\n        val l = new mutable.LinkedList[Long](nums.map(_.toLong))\n\
    \        val maxDist = l.max\n        val numDist = l.map(x => Math.abs(x - maxDist)).toList.sorted.last\n\
    \        return maxDist + numDist\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo5ypdzsu.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.LinkedList[\e[35mLong\e[0m](nums.map(_.toLong))\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val splits\
    \ = value.split(\"\\\\.\");\n        var num : Long = 0\n        val diff : Double\
    \ = splits.map{_.toInt}.reduce(_ + _) - Double.valueOf(splits.head.toInt)\n  \
    \      if(diff < 0){\n            num = -diff\n        }else{\n            num\
    \ = diff\n        }\n        return num.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3q051d5t.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiff\e[0m : \e[35mDouble\e\
    [0m = splits.map{_.toInt}.reduce(_ + _) - Double.valueOf(splits.head.toInt)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value valueOf\
    \ is not a member of object Double\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3q051d5t.scala:22:18 --------------------\e[0m\e[0m\n\e[31m22 |\e[0m\
    \            num = -diff\n\e[31m\e[31m   |\e[0m                  ^^^^^\e[0m\n\e\
    [31m   |\e[0m                  Found:    Double\n\e[31m   |\e[0m             \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3q051d5t.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            num = diff\n\e[31m\e\
    [31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m                  Found:\
    \    (diff : Double)\n\e[31m   |\e[0m                  Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val value =\
    \ value.trim\n        if (value.length==1) value.toLong\n        else {\n    \
    \        val digits = value.dropRight(value.length/2).split(\"\"\"\\.\"\"\").map(_.toDouble)\n\
    \            val diffs = digits.map(_.minus(digits(0)))\n            val closestDiff\
    \ = diffs.foldLeft((0,0)){case ((diff,idx),d) => if (diff.isLessThan(d)) (diff,idx)\
    \ else (d.abs,idx) }._1\n            if (closestDiff < digits(0)) digits(0).toLong\
    \ else digits(0).abs + 1\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfgjrvisa.scala:18:20 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mvalue\e[0m = value.trim\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mvalue\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val list =\
    \ value.split(\" \").toList\n        var count = 0\n        var newVal = 0\n \
    \       var closestVal = 0\n        list.foreach(num => {\n            newVal\
    \ = java.lang.Long.parseLong(num).toDouble\n            if (Math.abs(newVal-closestVal)\
    \ < Math.abs(newVal-closestVal)) {\n                closestVal = newVal\n    \
    \        }\n            count += 1\n        })\n        closestVal.toLong\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn4vv2fk7.scala:23:51\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            newVal = java.lang.Long.parseLong(num).toDouble\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Double\n\e[31m   |\e[0m   \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        if (intValue == intValue.toLong) {\n            return\
    \ intValue\n        }\n        if (intValue == (intValue - 1)) {\n           \
    \ return intValue\n        }\n        if (intValue == (intValue + 1)) {\n    \
    \        return intValue\n        }\n        return intValue - 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmp_v54_e57.scala:18)\n\
    \tat Problem$.main(tmp_v54_e57.scala:32)\n\tat Problem.main(tmp_v54_e57.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubled\
    \ = value.toDouble\n        // Find any two numbers that are equidistant from\
    \ doubled\n        val equidistant = findEquidistant(doubled)\n        // If the\
    \ number is equidistant from two numbers, return the\n        // number furthest\
    \ from zero.\n        if (equidistant.length == 2) {\n            val f0 = equidistant.head\n\
    \            val f1 = equidistant.last\n            val difference = (f1 - f0).abs\n\
    \            if (difference > 0.001) {\n                (f0 + difference - 0.001).toLong\n\
    \            } else {\n                (f0 - difference + 0.001).toLong\n    \
    \        }\n        } else {\n            // If the number is equidistant to only\
    \ one number, return\n            // that number.\n            equidistant.head.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplyabwnba.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mequidistant\e[0m = findEquidistant(doubled)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                          Not found: findEquidistant\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val splits\
    \ = value.split(\".\")\n        val lval = splits(0)\n        val lvalInts = lval.split(\"\
    \\\\.\").toArray.map(_.toInt)\n        val rval = splits(1)\n        val rvalInts\
    \ = rval.split(\"\\\\.\").toArray.map(_.toInt)\n        var closestIndex = -1\n\
    \        var minDistance = Long.MaxValue\n        for (i <- 0 until lvalInts.length\
    \ - 1) {\n            var lvalIntDistance = abs(lvalInts(i) - lvalInts(i + 1))\n\
    \            var rvalIntDistance = abs(rvalInts(i) - rvalInts(i + 1))\n      \
    \      if (lvalIntDistance < rvalIntDistance) {\n                closestIndex\
    \ = i\n                minDistance = min(minDistance, lvalIntDistance)\n     \
    \       }\n            if (lvalIntDistance == rvalIntDistance) {\n           \
    \     if (abs(lvalInts(i) - lvalInts(i + 1)) < abs(rvalInts(i) - rvalInts(i +\
    \ 1))) {\n                    closestIndex = i\n                    minDistance\
    \ = min(minDistance, abs(lvalInts(i) - lvalInts(i + 1)))\n                }\n\
    \            }\n        }\n        if (minDistance == Long.MaxValue) {\n     \
    \       -1\n        } else {\n            minDistance\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.closestInteger(tmp8fho2ov7.scala:19)\n\tat Problem$.main(tmp8fho2ov7.scala:46)\n\
    \tat Problem.main(tmp8fho2ov7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010448
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value match\
    \ {\n            case n if n.startsWith(\"0\") => 0\n            case n => n.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmp3j0hrh4t.scala:20)\n\
    \tat Problem$.main(tmp3j0hrh4t.scala:25)\n\tat Problem.main(tmp3j0hrh4t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010447
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.trim.toDouble\n\
    \        val remainder = num % 1\n        if (remainder > 0)\n            return\
    \ math.ceil(remainder).asInstanceOf[Long]\n        else\n            return math.floor(remainder).asInstanceOf[Long]\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcwkqveen.scala:26)\n\tat Problem.main(tmpcwkqveen.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010447
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.asInstanceOf[String]\n\
    \        val numAsInt = num.asInstanceOf[Int]\n        val intToUse = if (numAsInt\
    \ < 0) -numAsInt else numAsInt\n\n        val intDistant = numAsInt - intToUse\n\
    \        val intDiff = abs(intDistant)\n        val intDiffToZero = if (intDist\
    \ < 0) 1 else -1\n\n        val diffInt = intDiffToZero.min(numAsInt - intToUse)\n\
    \        if (diffInt == 0) intDistant else diffInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1t_j4anb.scala:24:32 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mintDiffToZero\e[0m = \e\
    [33mif\e[0m (intDist < \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m -\e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Not found: intDist\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010444
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val input =\
    \ value.trim.toDouble\n        var closest = (input - 0.5).toInt\n        while(closest\
    \ != closest){\n            if(closest < 0){\n                closest = -closest\n\
    \            }\n            else {\n                closest += 1\n           \
    \ }\n        }\n        closest\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpim1o9vfn.scala:31)\n\tat Problem.main(tmpim1o9vfn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\".toList)\n        val first = parts.head.toInt\n        val\
    \ last = parts.tail.last.toInt\n        val diff = last - first\n        val mod\
    \ = diff % 1\n        if (mod > 0) {\n            return last - (diff - mod)\n\
    \        } else {\n            return first + diff\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo68xw6yn.scala:18:36\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparts\e\
    [0m = value.split(\e[31m\".\"\e[0m.toList)\n\e[31m\e[31m   |\e[0m            \
    \                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \        Found:    List[Char]\n\e[31m   |\e[0m                               \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010447
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val arr = value.split(\"\
    .\").map(_.toInt)\n        val xs = arr.takeWhile(_ > 0)\n        val ys = arr.dropWhile(_\
    \ > 0)\n        val xs_min = xs.min\n        val ys_min = ys.min\n        val\
    \ x_min = math.min(xs_min, ys_min)\n        val x_max = math.max(xs_min, ys_min)\n\
    \        val y_max = math.max(x_min, xs_min)\n        val x_diff = x_max - x_min\n\
    \        val y_diff = y_max - y_min\n        (x_diff + y_diff) / 2\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplw3fx9r3.scala:27:29 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36my_diff\e[0m = y_max - y_min\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: y_min\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val tokens\
    \ = value.split(\".\") // Split on \".\" to get the two integers\n        val\
    \ x = tokens(0).toLong // Get the first integer\n        val y = tokens(1).toLong\
    \ // Get the second integer\n        // Calculate the difference\n        val\
    \ difference = Math.abs(x - y)\n        // Now check to see if difference is closer\
    \ than a certain value (eg 1)\n        if (difference < 1) {\n            difference\n\
    \        } else {\n            // If it's closer than a certain value (eg 1),\
    \ then return the\n            // difference between the two integers\n      \
    \      val diff = x - y\n            // If it's equidistant, then return one integer\
    \ that is closer\n            if (diff == 0) x - y else x - y + 1\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.closestInteger(tmpw93q2f02.scala:19)\n\tat Problem$.main(tmpw93q2f02.scala:35)\n\
    \tat Problem.main(tmpw93q2f02.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intPart\
    \   = value.substring(0,1)\n        val decimals = value.substring(1).toDouble\n\
    \        if (decimals == 0.0) intPart.toLong\n        else intPart.toLong + math.ceil(decimals)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaxt7shu4.scala:21:13\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m intPart.toLong\
    \ + math.ceil(decimals)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Double\n\e[31m   |\e[0m           \
    \  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value match\
    \ {\n            case str if str.length == 0 => throw new IllegalArgumentException(s\"\
    The value passed in must be non-empty. Given $value\")\n            case _ =>\
    \ {\n                val splitStr = value.split(\"\"\"\\.\"\"\")\n           \
    \     val int1 = splitStr(0)\n                val int2 = splitStr(1)\n\n     \
    \           if (int1 == \"\") {\n                    if(int2 == \"\") (intToInt(splitStr(0)).abs)\n\
    \                    else (intToInt(splitStr(0)).abs + intToInt(splitStr(1)).abs)\n\
    \                } else if (int2 == \"\") {\n                    (intToInt(int1).abs\
    \ + intToInt(splitStr(1)).abs)\n                } else {\n                   \
    \ (intToInt(int1).abs + intToInt(int2).abs)\n                }\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjag106iy.scala:26:36 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33mif\e[0m(int2 == \e[31m\"\"\e\
    [0m) (intToInt(splitStr(\e[31m0\e[0m)).abs)\n\e[31m\e[31m   |\e[0m           \
    \                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \               Not found: intToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpjag106iy.scala:27:26 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m                    \e[33melse\e[0m (intToInt(splitStr(\e[31m0\e[0m)).abs +\
    \ intToInt(splitStr(\e[31m1\e[0m)).abs)\n\e[31m\e[31m   |\e[0m               \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ intToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjag106iy.scala:29:21\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    (intToInt(int1).abs\
    \ + intToInt(splitStr(\e[31m1\e[0m)).abs)\n\e[31m\e[31m   |\e[0m             \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: intToInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjag106iy.scala:31:21\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    (intToInt(int1).abs\
    \ + intToInt(int2).abs)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: intToInt\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") //split into number and fraction parts i.e. \"10.5\"\
    \ would be [\"10\",\"5\"]\n        val fractionPart = parts(1) //grab the fraction\
    \ part i.e. \"5\"\n        var closest = java.lang.Long.MAX_VALUE //set initial\
    \ max value to avoid infinite loop\n        val distanceMap = mutable.TreeMap[Long,Long]()\
    \ //create a map to hold pairs of distance from current number to each other number\n\
    \        for (i <- parts(0).asDigits.reverse to parts.last by -1){ //reverse the\
    \ digits because we want largest number first\n            val difference = java.lang.Math.abs(java.lang.Long.valueOf(i).asDigits\
    \ - java.lang.Long.valueOf(fractionPart).asDigits) //calculate the difference\
    \ between current number and its closest integer part i.e. \"5\" minus \"10\"\
    \ = -5\n            if (distanceMap.contains(difference)) //if map contains a\
    \ pair with that difference add the number\n                distanceMap += (difference\
    \ -> distanceMap(difference) + java.lang.Long.valueOf(i).asDigits) //add the number\
    \ to the map\n            else if (distance > difference) //if the difference\
    \ between the current number and closest integer part is greater than the number\
    \ being asked for, keep track of the closest integer and the distance\n      \
    \          distanceMap += (difference -> java.lang.Long.valueOf(i).asDigits) //add\
    \ the closest integer and the number to the map\n            else if (distanceMap.contains(difference))\
    \ //if the number being asked for is closer to the number already in the map then\
    \ keep track of the closest integer and the distance\n                distanceMap\
    \ += (difference -> distanceMap(difference) + java.lang.Long.valueOf(i).asDigits)\
    \ //add the number to the map\n            else //else keep track of the closest\
    \ integer and the distance\n                distanceMap += (difference -> java.lang.Long.valueOf(i).asDigits)\
    \ //add the closest integer and the number to the map\n        }\n        val\
    \ closestInteger = distanceMap.max._2 //get the value with the maximum distance\n\
    \        if (closestInteger > closest) //if the number being asked for is closer\
    \ to the number already in the map then return that number\n            closest\n\
    \        else\n            closestInteger\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk2mn8xhu.scala:21:26 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mdistanceMap\e[0m = mutable.TreeMap[\e\
    [35mLong\e[0m,\e[35mLong\e[0m]() \e[34m//create a map to hold pairs of distance\
    \ from current number to each other number\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk2mn8xhu.scala:22:27\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (i\
    \ <- parts(\e[31m0\e[0m).asDigits.reverse to parts.last by -\e[31m1\e[0m){ \e\
    [34m//reverse the digits because we want largest number first\e[0m\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \        value asDigits is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660010449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Implement\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyza4rt_9.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m// Implement here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\",\")\n        val convertedNumber = (numbers(0).toLong).asInstanceOf[Long]\n\
    \        val difference = numbers.map((x) => convertedNumber - x.toLong).toArray\n\
    \        val indexOfClosestElement = Math.abs(difference).indexOf(Math.max(Math.abs(difference(0)),\
    \ Math.abs(difference(1)))) + 1 \n        convertedNumber.asInstanceOf[Long] -\
    \ convertedNumber.asInstanceOf[Long](indexOfClosestElement)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4r5fhu4c.scala:21:41 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mindexOfClosestElement\e\
    [0m = Math.abs(difference).indexOf(Math.max(Math.abs(difference(\e[31m0\e[0m)),\
    \ Math.abs(difference(\e[31m1\e[0m)))) + \e[31m1\e[0m \n\e[31m\e[31m   |\e[0m\
    \                                    ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double): Double\n\e[31m\
    \   |\e[0m (x$0: Float): Float\n\e[31m   |\e[0m (x$0: Long): Long\n\e[31m   |\e\
    [0m (x$0: Int): Int\n\e[31m   |\e[0mmatch arguments ((difference : Array[Long]))\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmp4r5fhu4c.scala:22:73 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        convertedNumber.asInstanceOf[\e[35mLong\e[0m]\
    \ - convertedNumber.asInstanceOf[\e[35mLong\e[0m](indexOfClosestElement)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               \e[33mmethod\e[0m \e[35masInstanceOf\e[0m in\
    \ \e[33mclass\e[0m \e[35mAny\e[0m does not take parameters\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def closestInt2(n:\
    \ String, d: Long) : Long = n.toDouble.toInt match {\n            case 1 => d\n\
    \            case x =>\n                val a = n.toDouble - d\n             \
    \   val b = n.toDouble + d\n                if (Math.abs(a) < Math.abs(b)) {\n\
    \                    a\n                } else {\n                    b\n    \
    \            }\n        }\n\n        value match {\n            case s =>\n  \
    \              val arr = s.split('.')\n                val num = arr(0).toLong\n\
    \                val dec = arr(1).toLong\n                val inc = dec * -1\n\
    \                val dec2 = closestInt2(dec, num)\n                val inc2 =\
    \ closestInt2(inc, num)\n                if (Math.abs(num - dec2) > Math.abs(num\
    \ - inc2)) {\n                    num\n                } else {\n            \
    \        dec2\n                }\n            case _ => 0\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa17a9vin.scala:24:20\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    a\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    (a : Double)\n\e[31m   |\e[0m                    Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa17a9vin.scala:26:20 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    b\n\e[31m\e[31m   |\e[0m        \
    \            ^\e[0m\n\e[31m   |\e[0m                    Found:    (b : Double)\n\
    \e[31m   |\e[0m                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpa17a9vin.scala:36:39 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e[0m \e[36mdec2\e[0m = closestInt2(dec,\
    \ num)\n\e[31m\e[31m   |\e[0m                                       ^^^\e[0m\n\
    \e[31m   |\e[0m                                       Found:    (dec : Long)\n\
    \e[31m   |\e[0m                                       Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa17a9vin.scala:37:39 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                \e[33mval\e[0m \e[36minc2\e[0m = closestInt2(inc,\
    \ num)\n\e[31m\e[31m   |\e[0m                                       ^^^\e[0m\n\
    \e[31m   |\e[0m                                       Found:    (inc : Long)\n\
    \e[31m   |\e[0m                                       Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val xs = value.split(\"\
    \\\\.\").map(_.toLong).toArray\n        if(xs.length == 1) {\n            val\
    \ ys = xs.map((x:Long) => { (x - floor(x)) * (x - floor(x)) })\n            val\
    \ minIndex = ys.indexOf(min(ys).toDouble)\n            minIndex < 0 ? xs(0) :\
    \ xs(minIndex)\n        }\n        else {\n            val ys = xs.map((x:Long)\
    \ => { (x - floor(x)) * (x - floor(x)) })\n            val minIndex = ys.indexOf(min(ys).toDouble)\n\
    \            if(minIndex < 0) xs(0)\n            else xs(minIndex)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpu8_ixecu.scala:22:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            minIndex < \e[31m0\e[0m ? xs(\e[31m0\e[0m)\
    \ : \e[35mxs\e[0m(minIndex)\n\e[31m\e[31m   |\e[0m                           \
    \          ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but '(' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu8_ixecu.scala:21:38\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e\
    [0m \e[36mminIndex\e[0m = ys.indexOf(min(ys).toDouble)\n\e[31m\e[31m   |\e[0m\
    \                                      ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((ys : Array[Double]))\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu8_ixecu.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            minIndex < \e[31m0\e[0m ? xs(\e[31m0\e[0m)\
    \ : \e[35mxs\e[0m(minIndex)\n\e[31m\e[31m   |\e[0m                       ^^^\e\
    [0m\n\e[31m   |\e[0m                       value ? is not a member of Int\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val value =\
    \ value.trim.toDouble\n        var diff = Math.abs(value - closestInteger(value).toDouble)\n\
    \        var minDiff = diff\n        var minValue: Double = 0.0\n        for(i\
    \ <- 0 until 10){\n            val nextValue = closestInteger(i+1).toDouble\n\
    \            val nextDiff = Math.abs(nextValue - value)\n            if(nextDiff\
    \ < minDiff){\n                minValue = nextValue\n                minDiff =\
    \ nextDiff\n            }\n        }\n        math.round(minValue)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0k5m2sdt.scala:18:20 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mvalue\e[0m = value.trim.toDouble\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mvalue\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0k5m2sdt.scala:23:45 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mnextValue\e[0m = closestInteger(i+\e\
    [31m1\e[0m).toDouble\n\e[31m\e[31m   |\e[0m                                  \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \   Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m                          \
    \                   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Use a regular\
    \ expression to search for the decimal point\n        val p = \".*[\\\\d.]+\"\
    .r\n        // Parse the string into an array of integers, ignoring the decimal\
    \ point\n        val intArray = p findAll { s => s !=\"\" }.toArray.map( _.toInt\
    \ )\n        // Convert the array of integers into an array of doubles\n     \
    \   val doubleArray = intArray.map(_.toDouble)\n        // Find the closest integer\
    \ to the double value of the given number\n        val closestDouble = doubleArray.min(Math.abs)\n\
    \        // Return the value as a long\n        closestDouble.toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3oen994g.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = p findAll\
    \ { \e[36ms\e[0m => s !=\e[31m\"\"\e[0m }.toArray.map( _.toInt )\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue findAll\
    \ is not a member of scala.util.matching.Regex - did you mean p.findAllIn?\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmp3oen994g.scala:21:35 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = p findAll\
    \ { \e[36ms\e[0m => s !=\e[31m\"\"\e[0m }.toArray.map( _.toInt )\n\e[31m\e[31m\
    \   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m         \
    \                 Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   \
    \                       I could not infer the type of the parameter s.\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        //Using a HashMap\
    \ to store all the original ints\n        // To store the original ints\n    \
    \    val originalNums = new HashMap[String, Long]()\n        //To store the new\
    \ ints\n        val nums = new HashMap[String, Long]()\n        //To store the\
    \ original ints after the change\n        val numsWithChanges = new HashMap[String,\
    \ Long]()\n        //To store the original ints before the change\n        val\
    \ numsWithoutChanges = new HashMap[String, Long]()\n\n        //Using a loop over\
    \ the given value and adding the integer to a map\n        for (i <- value.split(\"\
    \\\\.\") ) originalNums(i) = originalNums.getOrElse(i, 0) + 1\n\n        //Looping\
    \ over all the keys in originalNums map\n        for (i <- originalNums.keys)\
    \ nums(i) = nums.getOrElse(i, 0) + 1\n\n        //Looping over all the keys in\
    \ nums map and updating value if needed\n        for (i <- nums.keys) if (originalNums.get(i)\
    \ < nums.get(i)) numsWithChanges(i) = numsWithChanges.getOrElse(i, 0) + nums(i)\
    \ - originalNums.get(i)\n        else numsWithoutChanges(i) = numsWithoutChanges.getOrElse(i,\
    \ 0) + nums(i) - originalNums.get(i)\n\n        //Returning the highest of all\
    \ the values with changes\n        val highestWithChanges = numsWithChanges.values.max\n\
    \        //Returning the lowest of all the values with changes\n        val lowestWithChanges\
    \ = numsWithChanges.values.min\n\n        //Returning the highest of all the values\
    \ with no changes\n        val highestWithoutChanges = numsWithoutChanges.values.max\n\
    \        //Returning the lowest of all the values with no changes\n        val\
    \ lowestWithoutChanges = numsWithoutChanges.values.min\n\n        //Returning\
    \ the highest of all the values\n        val highest = nums.values.max\n     \
    \   //Returning the lowest of all the values\n        val lowest = nums.values.min\n\
    \n        //Returning the highest of all the values\n        val highestTotal\
    \ = originalNums.values.max\n        //Returning the lowest of all the values\n\
    \        val lowestTotal = originalNums.values.min\n\n        //Returning the\
    \ highest of all the values\n        val highestTotalWithChanges = numsWithChanges.values.max\n\
    \        //Returning the lowest of all the values\n        val lowestTotalWithChanges\
    \ = numsWithChanges.values.min\n\n        //Returning the highest of all the values\n\
    \        val highestTotalWithoutChanges = numsWithoutChanges.values.max\n    \
    \    //Returning the lowest of all the values\n        val lowestTotalWithoutChanges\
    \ = numsWithoutChanges.values.min\n\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvpwm8w43.scala:68:11 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpvpwm8w43.scala:29:86 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (i <- value.split(\e[31m\"\\\\\
    .\"\e[0m) ) originalNums(i) = originalNums.getOrElse(i, \e[31m0\e[0m) + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of AnyVal, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvpwm8w43.scala:32:68 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m (i <- originalNums.keys) nums(i)\
    \ = nums.getOrElse(i, \e[31m0\e[0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of AnyVal, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvpwm8w43.scala:35:53\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mfor\e[0m (i\
    \ <- nums.keys) \e[33mif\e[0m (originalNums.get(i) < nums.get(i)) numsWithChanges(i)\
    \ = numsWithChanges.getOrElse(i, \e[31m"
  stdout: ''
  timestamp: 1660010457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        if(number < 0.0 || number > 1.0) {\n            throw\
    \ new IllegalArgumentException(\"Number must be in range [0.0, 1.0]\")\n     \
    \   }\n        val remainder = math.floor(number)\n        val closest = math.abs(remainder\
    \ - number)\n        if(closest > remainder) {\n            return math.floor(remainder)\n\
    \        } else {\n            return math.ceil(remainder)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx248ceh8.scala:25:29\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mreturn\e[0m\
    \ math.floor(remainder)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpx248ceh8.scala:27:28 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            \e[33mreturn\e[0m math.ceil(remainder)\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \      Found:    Double\n\e[31m   |\e[0m                   Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.dropWhile(_!='.').dropWhile(_!='e').dropWhile(_!='E').dropWhile(_!='-')\n\
    \        val integer = numbers.toInt\n        val result = (number - integer).abs.toInt\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppu96nd2x.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (number -\
    \ integer).abs.toInt\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: number\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def gcd(a :\
    \ Long, b : Long) : Long = {\n            if (b > 0) {\n                val c\
    \ = a % b\n                gcd(b, c)\n            } else {\n                a\n\
    \            }\n        }\n        def lcm(a: Long, b: Long) : Long = {\n    \
    \        if (b > 0) {\n                val c = a % b\n                val r =\
    \ a / b\n                val k = a / c\n                r * lcm(c, r) + k * lcm(b,\
    \ k)\n            } else {\n                a\n            }\n        }\n\n  \
    \      def euclid(a : Long, b : Long) : Long = {\n            if (b > 0) {\n \
    \               val c = a % b\n                euclid(b, c)\n            } else\
    \ {\n                a\n            }\n        }\n\n        // Compute the factors\
    \ of the number\n        val factors = value.map(_.toInt).map(x => x * x).filter(x\
    \ => x != 1).map(x => x / gcd(x, 10))\n            .map(x => x * euclid(x, 10))\n\
    \            .map(x => x / euclid(x, 10).ceil)\n            .map(x => x * lcm(100,\
    \ x))\n            .map(x => x / lcm(100, x).ceil)\n\n        // If the number\
    \ is a multiple of one and the remainder is zero, return it.\n        // Otherwise,\
    \ return the minimum value between the two numbers\n        if (factors.contains(1)\
    \ && factors.contains(0)) return value.toLong\n        else if (factors.contains(0))\
    \ return factors.min\n        else return (factors.min - value.toLong).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp99eveaca.scala:49:40 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            .map(x => x / euclid(x, \e[31m10\e[0m).ceil)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      value ceil is not a member of Long.\n\e[31m   |\e[0m      An extension\
    \ method was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m          floatWrapper(euclid(x, \e[31m10L\e[0m))\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp99eveaca.scala:50:24 ------------------------\e[0m\e\
    [0m\n\e[31m50 |\e[0m            .map(x => x * lcm(\e[31m100\e[0m, x))\n\e[31m\e\
    [31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0mvalue * is not a member\
    \ of Nothing, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp99eveaca.scala:51:24 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            .map(x => x / lcm(\e[31m100\e[0m, x).ceil)\n\
    \e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0mvalue / is\
    \ not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import concurrent.du"
  stdout: ''
  timestamp: 1660010458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def distance(x:\
    \ String, y: String) : Double = {\n            val firstNumber = 0l\n        \
    \    val secondNumber = 0l\n            val firstNumberString = x\n          \
    \  val secondNumberString = y\n            val firstNumberSplit = firstNumberString.split('.')\n\
    \            val secondNumberSplit = secondNumberString.split('.')\n         \
    \   val firstNumberInt = firstNumberSplit.length\n            val secondNumberInt\
    \ = secondNumberSplit.length\n            if (firstNumberInt == 1 && secondNumberInt\
    \ == 1) {\n                val firstValue = firstNumberSplit\n               \
    \ val secondValue = secondNumberSplit\n                val firstValue = firstValue(0).toLong\n\
    \                val secondValue = secondValue(0).toLong\n                Math.sqrt(Math.pow(firstValue\
    \ - secondValue, 2) + Math.pow(secondValue, 2))\n            }\n            else\
    \ if (firstNumberInt == 2 && secondNumberInt == 2) {\n                val firstValue\
    \ = firstNumberSplit\n                val secondValue = secondNumberSplit\n  \
    \              val firstValue = firstValue(1).toLong\n                val secondValue\
    \ = secondValue(1).toLong\n                Math.sqrt(Math.pow(firstValue - secondValue,\
    \ 2) + Math.pow(secondValue, 2))\n            }\n            else if (firstNumberInt\
    \ == 3 && secondNumberInt == 3) {\n                val firstValue = firstNumberSplit\n\
    \                val secondValue = secondNumberSplit\n                val firstValue\
    \ = firstValue(2).toLong\n                val secondValue = secondValue(2).toLong\n\
    \                Math.sqrt(Math.pow(firstValue - secondValue, 2) + Math.pow(secondValue,\
    \ 2))\n            }\n            else {\n                val firstValue = firstNumberString.toDouble\n\
    \                val secondValue = secondNumberString.toDouble\n             \
    \   val difference = firstValue - secondValue\n                val distance =\
    \ Math.pow(difference, 2)\n                distance\n            }\n        }\n\
    \        val numbers = value.split(\",\")\n        val sortedNumbers = numbers.sortWith(_.toDouble\
    \ < _.toDouble)\n        val firstNumberString = sortedNumbers(0)\n        val\
    \ secondNumberString = sortedNumbers(1)\n        val firstNumberSplit = firstNumberString.split('.')\n\
    \        val secondNumberSplit = secondNumberString.split('.')\n        val firstNumberInt\
    \ = firstNumberSplit.length\n        val secondNumberInt = secondNumberSplit.length\n\
    \        if (firstNumberInt == 1 && secondNumberInt == 1) {\n            val firstValue\
    \ = firstNumberSplit\n            val secondValue = secondNumberSplit\n      \
    \      val firstValue = firstValue(0).toLong\n            val secondValue = secondValue(0).toLong\n\
    \            Math.sqrt(Math.pow(firstValue - secondValue, 2) + Math.pow(secondValue,\
    \ 2))\n        }\n        else if (firstNumberInt == 2 && secondNumberInt == 2)\
    \ {\n            val firstValue = firstNumberSplit\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps1mct32h.scala:83:0 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps1mct32h.scala:30:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                \e[33mval\e\
    [0m \e[36mfirstValue\e[0m = firstValue(\e[31m0\e[0m).toLong\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mfirstValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mfirstValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps1mct32h.scala:31:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33mval\e\
    [0m \e[36msecondValue\e[0m = secondValue(\e[31m0\e[0m).toLong\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msecondValue is already defined as \e[33mvalue\e[0m \e[35msecondValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmps1mct32h.scala:32:46 ------------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m                Math.sqrt(Math.pow(firstValue - secondValue, \e\
    [31m2\e[0m) + Math.pow(secondValue, \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m    \
    \                               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of Array[String], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmps1mct32h.scala:32:75 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                Math.sqrt(Math.pow(firstValue - secondValue,\
    \ \e[31m2\e[0m) + Math.pow(secondValu"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.toDouble.split('.').map(_.toLong)\n        val low = math.min(numbers(0),\
    \ numbers(1))\n        val high = math.max(numbers(0), numbers(1))\n        if\
    \ (numbers(0) == low && numbers(1) == high) low + 10\n        else if (numbers(0)\
    \ == high) high - 10\n        else low + ((high - low) / 10).floor\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa6obu9ly.scala:18:37 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnumbers\e[0m = value.toDouble.split(\e\
    [31m'.'\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value split is not a member of Double\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010456
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\")\n        var smallest = (parts(0) split \".\").map(_.toInt).min.toLong\n\
    \        var largest = (parts(0) split \".\").map(_.toInt).max\n        for (i\
    \ <- 1 to parts.size - 1) {\n            val n = (parts(i-1) split \".\").map(_.toInt).max\n\
    \            val m = (parts(i-1) split \".\").map(_.toInt).min\n            val\
    \ diff = (m - n) / (2.0 * abs(smallest))\n            smallest = smallest+diff\n\
    \            largest = largest+diff\n        }\n        val maxLargest = if (largest\
    \ > 0) largest else -largest \n        val minSmallest = if (smallest < 0) smallest\
    \ else -smallest \n        val diff = abs(maxLargest - minSmallest)\n        val\
    \ closestResult = math.round(diff)\n        if (closestResult < smallest) smallest\
    \ else closestResult\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp83p633ne.scala:25:23\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            smallest = smallest+diff\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    Double\n\e[31m   |\e[0m                    \
    \   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp83p633ne.scala:26:22\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            largest = largest+diff\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Found:    Double\n\e[31m   |\e[0m                     \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val xs = value.split(\"\
    \ \")\n        val a = xs(0)\n        val b = xs(1)\n        val ab = a.toLong\
    \ * b\n        val x = a.toLong + b.toLong - ab\n        val x = x % a.toLong\n\
    \        return x\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzsucpu3y.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = x % a.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already\
    \ defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpzsucpu3y.scala:21:26 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mab\e[0m = a.toLong * b\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((b : String))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val floatNumber\
    \ = value.asInstanceOf[String].replaceAll(\"[^0-9.]\", \"\").toFloat\n       \
    \ val intNumber = value.replaceAll(\"[^0-9.]\", \"\").toInt\n        if (floatNumber.isNaN\
    \ || intNumber.isNaN) {\n            throw new Exception(\"Cannot parse number\
    \ \" + value)\n        }\n        val diff = (intNumber - floatNumber).abs.toInt\n\
    \        math.max(diff / 2, 0)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi88tnocv.scala:20:43 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (floatNumber.isNaN || intNumber.isNaN)\
    \ {\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m      value isNaN is not a member of Int.\n\e[31m   |\e[0m    \
    \  An extension method was tried, but could not be fully constructed:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m          double2Double(intNumber)\n1 error found\n"
  stdout: ''
  timestamp: 1660010455
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val numParts\
    \ = value.split(\"\\\\.\").map(_.toInt)\n      val difference = numParts(1) -\
    \ numParts(0)\n      if(difference <= 0) numParts(0) - difference else numParts(1)\
    \ - difference\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpsnumajvx.scala:19)\n\tat Problem$.main(tmpsnumajvx.scala:23)\n\
    \tat Problem.main(tmpsnumajvx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parsedValue\
    \ = Try(parse(value)).toOption\n        parsedValue.flatMap { value =>\n     \
    \       // TODO: Add more tests\n            val twoDecimals = value.dropRight(2).takeRight(2)\n\
    \            val isEvenOrOdd = twoDecimals.last % 2 == 0\n            val isEven\
    \ = twoDecimals.head % 2 == 0\n            val isOdd = twoDecimals.head % 2 !=\
    \ 0\n            if(isEvenOrOdd && isEven){\n                twoDecimals.last\
    \ + 1 \n            }\n            else if(isEvenOrOdd && isOdd){\n          \
    \      twoDecimals.last - 1\n            }\n            else if(isEvenOrOdd &&\
    \ !isEven && !isOdd){\n                twoDecimals.last + 0.5\n            }\n\
    \            else if(isEvenOrOdd && !isEven && isOdd){\n                twoDecimals.last\
    \ - 0.5\n            }\n            else if(!isEvenOrOdd && !isEven && !isOdd\
    \ && twoDecimals.last < 0){\n                twoDecimals.last + 1\n          \
    \  }\n            else if(!isEvenOrOdd && !isEven && !isOdd && twoDecimals.last\
    \ > 0){\n                twoDecimals.last - 1\n            }\n            else\
    \ if(!isEvenOrOdd && !isEven && !isOdd && twoDecimals.last == 0){\n          \
    \      twoDecimals.last + 1\n            }\n            else if(!isEvenOrOdd &&\
    \ !isEven && !isOdd && twoDecimals.last != 0){\n                twoDecimals.last\
    \ - 1\n            }\n            else if(!isEvenOrOdd && !isEven && isOdd &&\
    \ twoDecimals.last < 0){\n                twoDecimals.last + 0.5\n           \
    \ }\n            else if(!isEvenOrOdd && !isEven && isOdd && twoDecimals.last\
    \ > 0){\n                twoDecimals.last - 0.5\n            }\n            else\
    \ if(!isEvenOrOdd && !isEven && isOdd && twoDecimals.last == 0){\n           \
    \     twoDecimals.last + 0.5\n            }\n            else if(!isEvenOrOdd\
    \ && !isEven && isOdd && twoDecimals.last != 0){\n                twoDecimals.last\
    \ - 0.5\n            }\n            else if(!isEvenOrOdd && !isEven && !isOdd\
    \ && twoDecimals.last < 0){\n                twoDecimals.last + 1\n          \
    \  }\n            else if(!isEvenOrOdd && !isEven && !isOdd && twoDecimals.last\
    \ > 0){\n                twoDecimals.last - 1\n            }\n            else\
    \ if(!isEvenOrOdd && !\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpih3ria7v.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpih3ria7v.scala:78:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpih3ria7v.scala:18:26 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparsedValue\e[0m = Try(parse(value)).toOption\n\
    \e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m     \
    \                     Not found: Try\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpih3ria7v.scala:18:30 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparsedValue\e[0m = Try(parse(value)).toOption\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: parse\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpih3ria7v.scala:77:1 ---------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpih3ria7v.scala:69:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val split =\
    \ value.toString.split(\".\").map(_.toLong).toArray\n        val splitLen = split.length\n\
    \        var closest = (splitLen - 1)\n        for ((a, b) <- split.zipWithIndex)\
    \ {\n            if (a == 0 && b == 0)\n                closest = 0\n        \
    \    else if (abs(a - b) < abs(closest - a)) {\n                closest = b\n\
    \            }\n        }\n        val result = split.map(x => if (x == closest)\
    \ 0 else x).sum\n        closest\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf678k4l2.scala:32)\n\tat Problem.main(tmpf678k4l2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ String to Double\n        var num : Double = value.toDouble\n        // Return\
    \ closest integer\n        if(num > 0) {\n            return math.floor(num)\n\
    \        } else {\n            return math.ceil(num)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdibpz7lw.scala:22:29\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mreturn\e[0m\
    \ math.floor(num)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m          \
    \         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdibpz7lw.scala:24:28 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mreturn\e[0m math.ceil(num)\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    Double\n\e[31m   |\e[0m                   Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var max = 0\n\
    \        var closest = 0\n\n        val array = value.split(\",\")\n\n       \
    \ for (i <- 0 to (array.length-1)) {\n            if (array(i).contains(\".\"\
    )) {\n                val nums = array(i).split(\"\\\\.\").toList\n          \
    \      val num = nums(0).toLong\n                val num2 = nums(1).toLong\n \
    \               val d = Math.abs(num - num2)\n                if (d > max) {\n\
    \                    max = d\n                    closest = num\n            \
    \    }\n            } else {\n                val num = array(i).toLong\n    \
    \            val d = Math.abs(num - max)\n                if (d > max) {\n   \
    \                 max = d\n                    closest = num\n               \
    \ }\n            }\n        }\n        closest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8lf4nnzu.scala:30:26\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    max = d\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (d : Long)\n\e[31m   |\e[0m                    \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8lf4nnzu.scala:31:30\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    closest =\
    \ num\n\e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (num : Long)\n\e[31m   |\e[0m     \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8lf4nnzu.scala:37:26 --------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                    max = d\n\e[31m\e[31m   |\e[0m       \
    \                   ^\e[0m\n\e[31m   |\e[0m                          Found:  \
    \  (d : Long)\n\e[31m   |\e[0m                          Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8lf4nnzu.scala:38:30 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    closest = num\n\e[31m\e[31m   |\e\
    [0m                              ^^^\e[0m\n\e[31m   |\e[0m                   \
    \           Found:    (num : Long)\n\e[31m   |\e[0m                          \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def isClosed(num:\
    \ Long, target: Long) : Boolean = {\n            var diff = abs(num - target)\n\
    \            if (diff <= 1)\n                return true\n            else if\
    \ (diff < 2)\n                return false\n            else { \n            \
    \    val diff2 = abs(num - target / 2)\n                val diff3 = abs(num -\
    \ target / 3)\n                val diff4 = abs(num - target / 4)\n           \
    \     val diff5 = abs(num - target / 5)\n                val diff6 = abs(num -\
    \ target / 6)\n                val diff7 = abs(num - target / 7)\n           \
    \     val diff8 = abs(num - target / 8)\n                val diff9 = abs(num -\
    \ target / 9)\n                val diff10 = abs(num - target / 10)\n         \
    \       val diff11 = abs(num - target / 11)\n                val diff12 = abs(num\
    \ - target / 12)\n                val diff13 = abs(num - target / 13)\n      \
    \          val diff14 = abs(num - target / 14)\n                val diff15 = abs(num\
    \ - target / 15)\n                val diff16 = abs(num - target / 16)\n      \
    \          val diff17 = abs(num - target / 17)\n                val diff18 = abs(num\
    \ - target / 18)\n                val diff19 = abs(num - target / 19)\n      \
    \          val diff20 = abs(num - target / 20)\n                val diff21 = abs(num\
    \ - target / 21)\n                val diff22 = abs(num - target / 22)\n      \
    \          val diff23 = abs(num - target / 23)\n                val diff24 = abs(num\
    \ - target / 24)\n                val diff25 = abs(num - target / 25)\n      \
    \          val diff26 = abs(num - target / 26)\n                val diff27 = abs(num\
    \ - target / 27)\n                val diff28 = abs(num - target / 28)\n      \
    \          val diff29 = abs(num - target / 29)\n                val diff30 = abs(num\
    \ - target / 30)\n                val diff31 = abs(num - target / 31)\n      \
    \          val diff32 = abs(num - target / 32)\n                val diff33 = abs(num\
    \ - target / 33)\n                val diff34 = abs(num - target / 34)\n      \
    \          val diff35 = abs(num - target / 35)\n                val diff36 = abs(num\
    \ - target / 36)\n                val diff37 = abs(num - target / 37)\n      \
    \          val diff38 = abs(num - target / 38)\n                val diff39 = abs(num\
    \ - target / 39)\n                val diff40 = abs(num - target / 40)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprtqddb73.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprtqddb73.scala:73:1\
    \ ---------------------\e[0m\e[0m\n\e[31m73 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmprtqddb73.scala:65:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m65 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Create an\
    \ empty list to store the values found\n        var found = new mutable.ListBuffer[Long]()\n\
    \        // Create the counter for the minimum distance from zero\n        var\
    \ minDistance = Long.MaxValue\n        // Search all numbers in the string\n \
    \       for(i <- 1 to value.toInt){\n            // Create a counter for the current\
    \ distance\n            var currentDistance = abs(value.toDouble - i)\n      \
    \      // If the distance is smaller than the minimum distance\n            //\
    \ update it\n            if(currentDistance < minDistance){\n                minDistance\
    \ = currentDistance\n                found.clear()\n            }\n          \
    \  // If the current distance is smaller than the minimum distance\n         \
    \   // add it to the found list\n            if(currentDistance < minDistance){\n\
    \                found += i\n            }\n        }\n        // Return the minimum\
    \ distance\n        minDistance\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3wb7ta3p.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mfound\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3wb7ta3p.scala:29:30\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                minDistance =\
    \ currentDistance\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (currentDistance :\
    \ Double)\n\e[31m   |\e[0m                              Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closest\
    \ = value.toLong - Math.abs(value.toLong.toDouble)\n        var closestInt = 0\n\
    \        var minDistance = 0\n        var minIndex = -1\n        var difference\
    \ = value.charAt(value.length - 1).toDouble\n        // TODO: Optimize this code\n\
    \        for (i <- 0 until value.length) {\n            val current = value(i).toDouble\n\
    \            if (current < closest.abs && current > difference) {\n          \
    \      closest = current\n                closestInt = i\n                difference\
    \ = current - difference\n            }\n            if (minDistance == 0) {\n\
    \                minDistance = current - closest\n                minIndex = i\n\
    \            } else if (current - closest < minDistance * minDistance * 1.0) {\n\
    \                minDistance = current - closest\n                minIndex = i\n\
    \            }\n        }\n        if (closest < Math.abs(closestInt) * 1.0) {\n\
    \            closest = Math.abs(closestInt) * 1.0\n            closestInt = Math.abs(closestInt)\n\
    \        }\n        return closestInt\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmuyb4dyy.scala:32:30\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                minDistance =\
    \ current - closest\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Double\n\e[31m   |\e\
    [0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpmuyb4dyy.scala:35:30 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                minDistance = current - closest\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    Double\n\e[31m   |\e[0m           \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toLong\n        val range = scala.collection.immutable.Range(-Int, Int.MaxValue)\n\
    \        var closestToZero = Int.MaxValue\n        var closestToOne = Int.MaxValue\n\
    \n        for(i <- range) {\n            val diff = (number - i).abs\n\n     \
    \       if (diff < closestToZero) {\n                closestToZero = diff\n  \
    \          }\n\n            if (diff < closestToOne) {\n                closestToOne\
    \ = diff\n            }\n        }\n\n        if(closestToZero < closestToOne)\
    \ {\n            return number\n        }\n\n        val minDistance = closestToZero\n\
    \        val closestToZeroIndex = range.indexWhere(n => n >= minDistance)\n\n\
    \        val closestToOneIndex = range.indexWhere(n => n <= minDistance)\n\n \
    \       return range.apply(closestToZeroIndex - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuoaevi0e.scala:19:53 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mrange\e[0m = scala.collection.immutable.Range(-Int,\
    \ Int.MaxValue)\n\e[31m\e[31m   |\e[0m                                       \
    \              ^^^^\e[0m\n\e[31m   |\e[0mvalue unary_- is not a member of object\
    \ Int, but could be made available as an extension method.\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpuoaevi0e.scala:27:32 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                closestToZero = diff\n\e[31m\e[31m  \
    \ |\e[0m                                ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                     Found:    (diff : Long)\n\e[31m   |\e[0m               \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpuoaevi0e.scala:31:31 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                closestToOne = diff\n\e[31m\e[31m   |\e[0m           \
    \                    ^^^^\e[0m\n\e[31m   |\e[0m                              \
    \ Found:    (diff : Long)\n\e[31m   |\e[0m                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010463
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closest\
    \ = 0\n        val valueSplit = value.split('.')\n        val intSplit = valueSplit(0).split('')\n\
    \        val longSplit = valueSplit(1).split('')\n        val newLong = longSplit.map(_.toLong).toList\n\
    \        val newInt = intSplit.map(_.toInt).toList\n        for (i <- newInt.size\
    \ - 1 downTo 0 by -1){\n            if (Math.abs(newInt(i)-newInt[i-1]) < Math.abs(newInt(i)-newInt[i])){\n\
    \                closest += newInt(i)\n            }\n        }\n        closest.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpfpt52xnr.scala:20:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mintSplit\e[0m = valueSplit(\e\
    [31m0\e[0m).split('')\n\e[31m\e[31m   |\e[0m                                 \
    \          ^\e[0m\n\e[31m   |\e[0m                                           empty\
    \ character literal\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfpt52xnr.scala:21:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlongSplit\e[0m = valueSplit(\e[31m1\e[0m).split('')\n\e[31m\e[31m   |\e\
    [0m                      ^\e[0m\n\e[31m   |\e[0m                      expression\
    \ expected but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpfpt52xnr.scala:21:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ \e[33mval\e[0m \e[36mlongSplit\e[0m = valueSplit(\e[31m1\e[0m).split('')\n\e\
    [31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                            empty character literal\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfpt52xnr.scala:22:20 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnewLong\e[0m = longSplit.map(_.toLong).toList\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       expression expected but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfpt52xnr.scala:21:8 -------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlongSplit\e[0m = valueSplit(\e\
    [31m1\e[0m).split('')\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m\
    \        Not found: 'val\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfpt52xnr.scala:22:8 -------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mnewLong\e[0m = longSplit.map(_.toLong).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m        Not found"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val floatValue\
    \ : Double = value.drop(1).takeWhile(_ >= '0').toDouble\n        val lowerInt\
    \ : Long = Math.ceil(floatValue)\n        val higherInt : Long = Math.floor(floatValue)\n\
    \        if (floatValue == lowerInt || floatValue == higherInt) {\n          \
    \  lowerInt\n        } else {\n            higherInt\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2d6780n_.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlowerInt\e\
    [0m : \e[35mLong\e[0m = Math.ceil(floatValue)\n\e[31m\e[31m   |\e[0m         \
    \                     ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                  Found:    Double\n\e[31m   |\e[0m                         \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2d6780n_.scala:20:41\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mhigherInt\e\
    [0m : \e[35mLong\e[0m = Math.floor(floatValue)\n\e[31m\e[31m   |\e[0m        \
    \                       ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                      Found:    Double\n\e[31m   |\e[0m                     \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010463
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val splitString\
    \ = value.split(\"\\\\.\");\n        if (splitString.length == 2) {\n        \
    \    val firstNum = splitString(0).toInt;\n            val secondNum = splitString(1).toInt;\n\
    \            return Math.round((secondNum + firstNum) / 2);\n        }\n     \
    \   if (splitString.length == 1) {\n            val num = splitString(0).toInt;\n\
    \            return Math.round((num + num) / 2);\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphtgif7b8.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (splitString.length\
    \ == \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    Unit\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m \
    \       Maybe you are missing an else part for the conditional?\n\e[31m25 |\e\
    [0m            \e[33mval\e[0m \e[36mnum\e[0m = splitString(\e[31m0\e[0m).toInt;\n\
    \e[31m26 |\e[0m            \e[33mreturn\e[0m Math.round((num + num) / \e[31m2\e\
    [0m);\n\e[31m27 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numAsLong\
    \ = BigDecimal(value)\n        val difference = BigDecimal.ZERO\n        var closestNum:\
    \ BigDecimal = BigDecimal.ZERO\n        var closestNumVal: Long = 0\n        for\
    \ {\n            numAsLong <- numAsLong.divide(BigDecimal.ONE, 2, RoundingMode.SYNC)\n\
    \            difference <- numAsLong.subtract(BigDecimal.ZERO)\n        } yield\
    \ {\n            if (difference.signum == -1) {\n                closestNumVal\
    \ = numAsLong.doubleValue\n                closestNum = BigDecimal.valueOf(closestNumVal)\n\
    \            } else {\n                closestNumVal = closestNum.doubleValue\n\
    \                closestNum = BigDecimal.valueOf(closestNumVal)\n            }\n\
    \        }\n        closestNumVal\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdw3vzvxd.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdifference\e[0m = BigDecimal.ZERO\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m              value ZERO is not a member of object scala.math.BigDecimal\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpdw3vzvxd.scala:20:48 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mclosestNum\e[0m: \e[35mBigDecimal\e\
    [0m = BigDecimal.ZERO\n\e[31m\e[31m   |\e[0m                                 \
    \    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value ZERO is not a member\
    \ of object scala.math.BigDecimal\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdw3vzvxd.scala:23:35\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            numAsLong <-\
    \ numAsLong.divide(BigDecimal.ONE, \e[31m2\e[0m, RoundingMode.SYNC)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                        value divide is not a member of BigDecimal\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdw3vzvxd.scala:23:53 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            numAsLong <- numAsLong.divide(BigDecimal.ONE,\
    \ \e[31m2\e[0m, RoundingMode.SYNC)\n\e[31m\e[31m   |\e[0m                    \
    \                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ ONE is not a member of object scala.math.BigDecimal\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpdw3vzvxd.scala:23:61 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m            numAsLong <- numAsLong.divide(BigDecimal.ONE, \e[31m2\e\
    [0m, RoundingMode.SYNC)\n\e[31m\e[31m   |\e[0m                               \
    \                              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                     Not found: RoundingMode\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        var result : Long = 0\n        for(i\
    \ <- 0 until numbers.size) {\n            result += toLong(numbers(i))\n     \
    \   }\n        if(result > 0 && result % 1 == 0) {\n            result += 1\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6da8wer7.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            result += toLong(numbers(i))\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6da8wer7.scala:21:22 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            result += toLong(numbers(i))\n\e[31m\e[31m   |\e[0m           \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: toLong\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010464
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val integer\
    \ = value.toLong\n        val closestInteger = if (integer - math.abs(integer)\
    \ < 0) {\n            math.abs(integer) + 1;\n        } else {\n            math.abs(integer);\n\
    \        }\n        closestInteger\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpvsi9olte.scala:18)\n\
    \tat Problem$.main(tmpvsi9olte.scala:28)\n\tat Problem.main(tmpvsi9olte.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Create a\
    \ list of possible integers that could be the closest\n        val possibleInt\
    \ = mutable.ArrayBuffer[Long](\n            10l, 15l, 20l, 25l, 30l, 35l, 40l,\
    \ 45l, 50l, 55l, 60l, 65l,\n            70l, 75l, 80l, 85l, 90l, 95l, 100l, 105l,\
    \ 110l, 115l, 120l,\n            125l, 130l, 135l, 140l, 145l, 150l, 155l, 160l,\
    \ 165l, 170l,\n            175l, 180l, 185l, 190l, 195l, 200l, 205l, 210l, 215l,\
    \ 220l,\n            225l, 230l, 235l, 240l, 245l, 250l, 255l, 260l, 265l, 270l,\n\
    \            275l, 280l, 285l, 290l, 295l, 300l, 305l, 310l, 315l, 320l,\n   \
    \         325l, 330l, 335l, 340l, 345l, 350l, 355l, 360l, 365l, 370l,\n      \
    \      375l, 380l, 385l, 390l, 395l, 400l, 405l, 410l, 415l, 420l,\n         \
    \   425l, 430l, 435l, 440l, 445l, 450l, 455l, 460l, 465l, 470l,\n            475l,\
    \ 480l, 485l, 490l, 495l, 500l, 505l, 510l, 515l, 520l,\n            525l, 530l,\
    \ 535l, 540l, 545l, 550l, 555l, 560l, 565l, 570l,\n            575l, 580l, 585l,\
    \ 590l, 595l, 600l, 605l, 610l, 615l, 620l,\n            625l, 630l, 635l, 640l,\
    \ 645l, 650l, 655l, 660l, 665l, 670l,\n            675l, 680l, 685l, 690l, 695l,\
    \ 700l, 705l, 710l, 715l, 720l,\n            725l, 730l, 735l, 740l, 745l, 750l,\
    \ 755l, 760l, 765l, 770l,\n            775l, 780l, 785l, 790l, 795l, 800l, 805l,\
    \ 810l, 815l, 820l,\n            825l, 830l, 835l, 840l, 845l, 850l, 855l, 860l,\
    \ 865l, 870l,\n            875l, 880l, 885l, 890l, 895l, 900l, 905l, 910l, 915l,\
    \ 920l,\n            925l, 930l, 935l, 940l, 945l, 950l, 955l, 960l, 9\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkmm878_e.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkmm878_e.scala:19:26\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mpossibleInt\e[0m = mutable.ArrayBuffer[\e[35mLong\e[0m](\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkmm878_e.scala:39:5 ---------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Write your\
    \ solution here\n        val array = (value split '\\.').toArray\n        val\
    \ int1 = array.head.toInt\n        val int2 = array.last.toInt\n        var intDiff\
    \ = abs(int1 - int2)\n        if (intDiff == int1.toString.toInt) {\n        \
    \    if (int1 == 0) {\n                intDiff = abs(int2.toString.toInt - 0)\n\
    \                if (intDiff == int2.toString.toInt) {\n                    intDiff\
    \ = abs(int1.toString.toInt - 0)\n                }\n            } else {\n  \
    \              intDiff = abs(int1.toString.toInt - 0)\n            }\n       \
    \ } else if (intDiff == int2.toString.toInt) {\n            intDiff = abs(int2.toString.toInt\
    \ - 0)\n        }\n        val diff = abs(int1.toLong - int2.toLong)\n       \
    \ if (diff == int1.toString.toInt) {\n            val diff = abs(int1.toString.toInt\
    \ - 0)\n        } else if (diff == int2.toString.toInt) {\n            val diff\
    \ = abs(int2.toString.toInt - 0)\n        }\n        if (intDiff > int2.toString.toInt\
    \ && (intDiff - int1.toString.toInt) <= diff) {\n            int1.toLong\n   \
    \     } else {\n            int2.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpaos2eyke.scala:19:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36marray\e[0m = (value split\
    \ \e[31m'\\.'\e[0m).toArray\n\e[31m\e[31m   |\e[0m                           \
    \        ^\e[0m\n\e[31m   |\e[0m                                   invalid escape\
    \ character\n1 error found\n"
  stdout: ''
  timestamp: 1660010464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n        val intArray = value.split(\",\")\n        val resultArray = for\
    \ (a <- intArray) yield {\n            if (a.startsWith(\"-\")) {\n          \
    \      a.toLong * -1\n            } else {\n                a.toLong\n       \
    \     }\n        }\n        val result = resultArray.toArray\n        if (resultArray.length\
    \ == 0) throw new Exception(\"value can not be parsed\")\n        val minimum\
    \ = result(0)\n        val maximum = result(resultArray.length - 1).abs\n    \
    \    val minimumIndex = result.indexWhere(_ == minimum)\n        val maximumIndex\
    \ = result.indexWhere(_ == maximum)\n        val result = if (minimumIndex < maximumIndex)\
    \ maximum(minimumIndex) else minimum(maximumIndex)\n        result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1wd0fw7n.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (minimumIndex < maximumIndex) maximum(minimumIndex) \e[33melse\e[0m minimum(maximumIndex)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp1wd0fw7n.scala:34:8 ---------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (result : Array[Long])\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010467
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        if(intValue == intValue) intValue\n        else intValue.toLong\
    \ - intValue + (intValue.toLong/intValue.toInt).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpivsxf5m4.scala:18)\n\
    \tat Problem$.main(tmpivsxf5m4.scala:24)\n\tat Problem.main(tmpivsxf5m4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Extract\
    \ the numeric value from the input string\n        val num = value.trim().toDouble\n\
    \        // Return it if it is equidistant from two integers\n        if (num.isEqual\
    \ && num.isInfinite || num.isNaN ) {\n            return num\n        }\n    \
    \    // Get the integer closest to zero\n        val result = (-num).abs + math.min(math.max(num,0),Integer.MAX_VALUE).toInt\n\
    \        // Return the result\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi3yrgrmf.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (num.isEqual && num.isInfinite\
    \ || num.isNaN ) {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value isEqual is not a member of Double\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpi3yrgrmf.scala:22:19 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mreturn\e[0m num\n\e[31m\e[31m   |\e\
    [0m                   ^^^\e[0m\n\e[31m   |\e[0m                   Found:    (num\
    \ : Double)\n\e[31m   |\e[0m                   Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi3yrgrmf.scala:27:8 ---------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : Double)\n\e[31m   |\e[0m     \
    \   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010469
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ to numeric value\n        val floatVal = value.asInstanceOf[String].replaceAll(\"\
    [^0-9]\", \"\").toDouble\n        val low = math.floor(floatVal)\n        val\
    \ high = math.ceil(floatVal)\n        val diff = high - low\n        // Return\
    \ closest integer\n        if (diff == 0) {\n            return low\n        }\n\
    \        else {\n            return low + math.min(math.abs(diff), 1)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphmpvxc9r.scala:25:19\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mreturn\e[0m\
    \ low\n\e[31m\e[31m   |\e[0m                   ^^^\e[0m\n\e[31m   |\e[0m     \
    \              Found:    (low : Double)\n\e[31m   |\e[0m                   Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphmpvxc9r.scala:28:19\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mreturn\e[0m\
    \ low + math.min(math.abs(diff), \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \         Found:    Double\n\e[31m   |\e[0m                   Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010469
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = scala.math.BigDecimal(value).toLong\n\
    \        val diff = scala.math.BigDecimal.signum(num - java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)))\n\
    \        val closestToZero = java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)\
    \ - diff)\n        val rounded = java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)\
    \ + diff)\n        if (java.lang.Double.doubleToLongBits(rounded) == closestToZero)\
    \ {\n            val toDecimal = java.lang.Double.doubleToLongBits(num)\n    \
    \        val decimal = java.math.BigDecimal(toDecimal)\n            val round\
    \ = Math.round(decimal)\n            if (value == s\"${round}.0\")\n         \
    \       toDecimal\n            else round\n        } else {\n            val toDecimal\
    \ = java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num))\n\
    \            val decimal = java.math.BigDecimal(toDecimal)\n            val round\
    \ = Math.round(decimal)\n            if (value == s\"${round}.0\")\n         \
    \       toDecimal\n            else round\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmputaed5ik.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdiff\e[0m = scala.math.BigDecimal.signum(num\
    \ - java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue signum is not a member of object scala.math.BigDecimal, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmputaed5ik.scala:25:29 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mround\e[0m = Math.round(decimal)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mround\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double): Long\n\e[31m  \
    \ |\e[0m (x$0: Float): Int\n\e[31m   |\e[0mmatch arguments ((decimal : java.math.BigDecimal))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmputaed5ik.scala:32:29 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mround\e[0m = Math.round(decimal)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mround\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double): Long\n\e[31m  \
    \ |\e[0m (x$0: Float): Int\n\e[31m   |\e[0mmatch arguments ((decimal : java.math.BigDecimal))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010471
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9m_5uogp.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts :\
    \ (String, Int) = (value, value.toString.toInt)\n        val diffInDecimals =\
    \ parts._2 - parts._1\n        if(diffInDecimals > 0) {\n            parts._1\
    \ - (diffInDecimals)\n        } else {\n            parts._1 + (diffInDecimals)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp70l_70i7.scala:19:38 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdiffInDecimals\e[0m = parts._2\
    \ - parts._1\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((parts._1 : => String))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp70l_70i7.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            parts._1 - (diffInDecimals)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of String, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp70l_70i7.scala:23:12 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            parts._1 + (diffInDecimals)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Found:    String\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010472
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val arr = value.split(\"\
    .\").map(_.toLong)\n        val diff = arr.toSeq.map(_.toLong).takeRight(2).foldLeft(0d){\
    \ (acc, i) => acc + Math.abs(i - arr(0)) }\n        arr(0) + diff\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqdbufl_.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        arr(\e[31m0\e[0m) +\
    \ diff\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Double\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010472
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closestInteger\
    \ = 0\n        val values = value.split(\"\\\\.\")\n        val inputValue = values.last.toLong\n\
    \        for (number <- values) {\n            val testValue = inputValue + number.toLong\n\
    \            if (Math.abs(testValue - inputValue) < Math.abs(closestInteger -\
    \ inputValue)) {\n                closestInteger = testValue\n            }\n\
    \        }\n        closestInteger\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm2ye589a.scala:24:33\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                closestInteger\
    \ = testValue\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    (testValue : Long)\n\
    \e[31m   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010471
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val digits =\
    \ value.split(\",\").toList.map(_.toInt)\n      // Create a mutable set of all\
    \ existing numbers that are equidistant from\n      // the numbers currently in\
    \ the set\n      val existingSet = mutable.Set[Long]()\n      digits foreach {\
    \ n =>\n        existingSet += n\n      }\n      val closest = math.abs(digits.max\
    \ -digits.min) // Find the closest integer\n      // Add the number that is closest\
    \ to the original set to the set\n      // of numbers to try and find the next\
    \ closest integer\n      existingSet += (closest +- 0.5).toLong\n      digits.min.max(closest)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc0jfmiqf.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36mexistingSet\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val arr = value.split(\"\
    \\\\.\").map(_.toInt)\n        val smallestAbs = arr.minAbsolute\n        val\
    \ largestAbs = arr.maxAbsolute\n        val diff = largestAbs - smallestAbs\n\
    \        val closestIndex = arr.zip(arr.zipWithIndex).find(_._1 != _._1).map(x\
    \ => abs(x._1 - x._2)).sortBy(x => x).lastOption.getOrElse(0)\n        (arr(closestIndex\
    \ + smallestAbs) % diff) + smallestAbs\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6655w893.scala:19:30 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallestAbs\e[0m = arr.minAbsolute\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         value minAbsolute is not a member of Array[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6655w893.scala:20:29 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlargestAbs\e[0m = arr.maxAbsolute\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value maxAbsolute is not a member of Array[Int]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp6655w893.scala:22:60 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosestIndex\e[0m = arr.zip(arr.zipWithIndex).find(_._1\
    \ != _._1).map(\e[36mx\e[0m => abs(x._1 - x._2)).sortBy(\e[36mx\e[0m => x).lastOption.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \      value _1 is not a member of Int\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6655w893.scala:22:90\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e\
    [0m \e[36mclosestIndex\e[0m = arr.zip(arr.zipWithIndex).find(_._1 != _._1).map(\e\
    [36mx\e[0m => abs(x._1 - x._2)).sortBy(\e[36mx\e[0m => x).lastOption.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                                          ^^^^^^\e[0m\n\e[31m   |\e[0m None of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m  \
    \ |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m\
    \  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((x._2\
    \ : => (Int, Int)))\n4 errors found\n"
  stdout: ''
  timestamp: 1660010475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\", -1);\n        val num = parts.head.asInstanceOf[Number].longValue\n\
    \        val fraction = parts.last.asInstanceOf[Number].longValue\n        var\
    \ d = fraction / 10\n        var r = fraction % 10\n        if(num == 0 && fraction\
    \ == 0) {\n            return 0\n        }\n        if(fraction == 0) {\n    \
    \        return num\n        }\n        if(fraction == 1 && num != 0) {\n    \
    \        return num\n        }\n        while(num > 0) {\n            d = math.min(d,\
    \ 10 - r)\n            num = num / 10\n            r = num % 10\n        }\n \
    \       return num\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp59yd9nef.scala:34:16 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            num = num / \e[31m10\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val num\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val result = numbers.foldLeft((0,0)){\n\
    \            case ((cur, prev), number) => {\n                var prevNum = prev\n\
    \                prevNum = if(prevNum < 0) prevNum + 1 else prevNum - 1\n    \
    \            (prevNum + number.toLong, prevNum)\n            }\n        }\n  \
    \      result._1.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0yrrdr_v.scala:23:17\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                (prevNum + number.toLong,\
    \ prevNum)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                 Found:    Long\n\e[31m   |\e[0m              \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010474
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val value =\
    \ value.trim\n        val value = value.toDouble\n        val maxDistance = Math.abs(value\
    \ - (value % 1));\n        val closestInteger = Math.round(value) + 1;\n     \
    \   val distances = List(0, maxDistance);\n        if (distances.last < distances.head)\
    \ {\n            distances.reverse;\n        }\n        closestInteger;\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnx1d4zi_.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvalue\e[0m = value.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ is already defined as \e[33mvalue\e[0m \e[35mvalue\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnx1d4zi_.scala:18:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mvalue\e[0m = value.trim\n\e[31m\e[31m   |\e[0m                    ^\e\
    [0m\n\e[31m   |\e[0m                    Recursive \e[33mvalue\e[0m \e[35mvalue\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValues\
    \ = value.split('.').toList.toDouble.map { _.toInt }\n        val index = intValues.indexOf(Math.min.apply(0,\
    \ intValues))\n        Math.min.apply(0, intValues)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcd_qqqxn.scala:18:48 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = value.split(\e\
    [31m'.'\e[0m).toList.toDouble.map { _.toInt }\n\e[31m\e[31m   |\e[0m         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toDouble\
    \ is not a member of List[String], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Implement\
    \ your code here\n        val x = parseLong(value)\n        val closest = (x -\
    \ Math.round(x) == x)\n        if (closest) x else (x - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpodtvgtq_.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = parseLong(value)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Not found: parseLong\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val first = numbers.head\n  \
    \      val second = numbers.tail.head\n\n        val difference = second - first\n\
    \n        if (difference < 0) difference *= -1\n\n        if (Math.abs(difference)\
    \ > 1) {\n            if (Math.abs(difference) > Integer.MAX_VALUE) throw new\
    \ RuntimeException(\"Can't handle number too big\")\n            else Math.round(difference)\n\
    \        } else {\n            Math.abs(difference)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1fpmd9_z.scala:24:39 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (difference < \e[31m0\e[0m) difference\
    \ *= -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value *= is not a member of Int - did you mean\
    \ difference.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts :\
    \ Array[String] = value.toString.split(\"\\\\.\".toString)\n        val numbers\
    \ = parts.tail.map { part =>\n            val result = part.toLong\n         \
    \   if( result >= 0 && result < Number.MIN_INT ) {\n                result + Number.MIN_INT\n\
    \            }\n            else {\n                result - Number.MIN_INT\n\
    \            }\n        }\n        val closest = (numbers diff 0)(Ordering[Long](Ordering[Int]()))\n\
    \        return closest(0)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfjyhl3bn.scala:21:47 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m( result >= \e[31m0\e[0m &&\
    \ result < Number.MIN_INT ) {\n\e[31m\e[31m   |\e[0m                         \
    \               ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \ value MIN_INT is not a member of object Number\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpfjyhl3bn.scala:22:32 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                result + Number.MIN_INT\n\e[31m\e[31m   |\e[0m       \
    \                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   value MIN_INT is not a member of object Number\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpfjyhl3bn.scala:25:32 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m                result - Number.MIN_INT\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \          value MIN_INT is not a member of object Number\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpfjyhl3bn.scala:27:9 ------------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m  \
    \ |\e[0m         No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \         where:    B is a type variable\n\e[31m\e[31m-- Error: /tmp/tmpfjyhl3bn.scala:28:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mclosest\e[0m = (numbers diff \e[31m0\e[0m)(Ordering[\e\
    [35mLong\e[0m](Ordering[\e[35mInt\e[0m]()))\n\e[31m\e[31m   |\e[0m           \
    \                                           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter ord of \e[33mmethod\e[0m \e[35mapply\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m: (\e[33mimplicit \e[0mord: Ordering[Int]):\
    \ Ordering[Int]\n5 errors found\n"
  stdout: ''
  timestamp: 1660010475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Use a set\
    \ to collect all of the integers\n        val set = Set[Long]()\n\n        //\
    \ Iterate over the characters in the string, one at a time\n        for (i <-\
    \ value.iterator.toList)\n            // Add the integer represented by the character\
    \ to the set\n            if (i.isDigit) set.add(i.asInstanceOf[Int].toLong)\n\
    \n        // Return the smallest integer that's not in the set\n        set.min.filter(_\
    \ != value.toLong).head\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2yfc_46z.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        set.min.filter(_ != value.toLong).head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value filter\
    \ is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010474
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.contains(\"\
    .\")) {\n            val parts = value.split(\".\")\n            if (parts.length\
    \ != 2) {\n                throw new IllegalArgumentException\n              \
    \      (s\"Bad number of parts $parts\")\n            }\n            val number\
    \ = parts.head.toLong * 10000000 + parts.last.toLong\n            if (number ==\
    \ 0) throw new IllegalArgumentException\n                (s\"Bad number $number\
    \ for value $value\")\n            number\n        } else {\n            value.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: Bad number of parts [Ljava.lang.String;@1dd92fe2\n\
    \tat Problem$.closestInteger(tmp6mmh44oz.scala:22)\n\tat Problem$.main(tmp6mmh44oz.scala:34)\n\
    \tat Problem.main(tmp6mmh44oz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010477
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\").map(_.toLong)\n        val minParts = parts.sorted.take(2)\n\
    \        val maxParts = parts.sorted.takeRight(2)\n\n        (minParts zip maxParts).\n\
    \                filter{ case (first, second) => first <= second }.\n        \
    \        map{ case (first, second) => second }.toArray.\n                min.\n\
    \                toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.closestInteger(tmpm6nmq98f.scala:25)\n\tat Problem$.main(tmpm6nmq98f.scala:29)\n\
    \tat Problem.main(tmpm6nmq98f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val str = value.toInt\n\
    \        if (str == 0) 0\n        else if(str == Integer.MIN_VALUE) Integer.MAX_VALUE\n\
    \        else if (str < 0) Integer.MIN_VALUE\n        else { val diff = str -\
    \ Integer.MIN_VALUE\n        val diff2 = diff - diff\n        if (diff2 < 0) Integer.MIN_VALUE\n\
    \        else if (diff2 > 0) Integer.MAX_VALUE\n        else diff\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjnaomv3h.scala:30)\n\tat Problem.main(tmpjnaomv3h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val stringNumber\
    \ = value.toDouble\n        val difference = abs(stringNumber - stringNumber.roundToInt)\n\
    \        stringNumber.roundToInt\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyfgqkpo4.scala:19:57 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdifference\e[0m = abs(stringNumber\
    \ - stringNumber.roundToInt)\n\e[31m\e[31m   |\e[0m                          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                 value roundToInt is not a member of Double\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyfgqkpo4.scala:20:21 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        stringNumber.roundToInt\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value roundToInt is\
    \ not a member of Double\n2 errors found\n"
  stdout: ''
  timestamp: 1660010478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val stringNumber\
    \ = value\n        val integers = stringNumber.toIntArray()\n        val closestOne\
    \ = if (integers.length == 1) integers(0) else integers(0)\n        val closestTwo\
    \ = if (integers.length == 2) integers(0) else integers(1)\n        val closestThree\
    \ = if (integers.length == 3) integers(0) else integers(2)\n        val closestFour\
    \ = if (integers.length == 4) integers(0) else integers(3)\n        val closestFive\
    \ = if (integers.length == 5) integers(0) else integers(4)\n        val closestSix\
    \ = if (integers.length == 6) integers(0) else integers(5)\n        val closestSeven\
    \ = if (integers.length == 7) integers(0) else integers(6)\n        val closestEight\
    \ = if (integers.length == 8) integers(0) else integers(7)\n        val closestNine\
    \ = if (integers.length == 9) integers(0) else integers(8)\n        val closestTen\
    \ = if (integers.length == 10) integers(0) else integers(9)\n        val closestEleven\
    \ = if (integers.length == 11) integers(0) else integers(10)\n        val closestTwelve\
    \ = if (integers.length == 12) integers(0) else integers(11)\n        val closestThirteen\
    \ = if (integers.length == 13) integers(0) else integers(12)\n        val closestFourteen\
    \ = if (integers.length == 14) integers(0) else integers(13)\n        val closestFifteen\
    \ = if (integers.length == 15) integers(0) else integers(14)\n        val closestSixteen\
    \ = if (integers.length == 16) integers(0) else integers(15)\n        val closestSeventeen\
    \ = if (integers.length == 17) integers(0) else integers(16)\n        val closestEighteen\
    \ = if (integers.length == 18) integers(0) else integers(17)\n        val closestNineteen\
    \ = if (integers.length == 19) integers(0) else integers(18)\n        val closestTwenty\
    \ = if (integers.length == 20) integers(0) else integers(19)\n        val closestTwentyOne\
    \ = if (integers.length == 20) integers(1) else integers(20)\n        val closestTwentyTwo\
    \ = if (integers.length == 20) integers(2) else integers(20)\n        val closestTwentyThree\
    \ = if (integers.length == 20) integers(3) else integers(20)\n        val closestTwentyFour\
    \ = if (integers.length == 20) integers(4) else integers(20)\n        val closestTwentyFive\
    \ = if (integers.length == 20) integers(5) \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd74zbtcm.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mintegers\e[0m = stringNumber.toIntArray()\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value toIntArray is not a member of String\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd74zbtcm.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        var integers = mutable.LinkedHashSet[Long]()\n\
    \        val firstValue = numbers(0)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            val nextValue = numbers(i+1)\n            if (nextValue.toLong\
    \ <= firstValue.toLong) {\n                integers.add(nextValue.toLong)\n  \
    \          }\n        }\n        val closestIntegers = integers.toSeq.sortWith(_\
    \ < _)\n        if (closestIntegers.size == 1) {\n            closestIntegers.head\n\
    \        } else {\n            val closestInteger = closestIntegers.head\n   \
    \         val closestValues = integers.filter(_ != closestInteger)\n         \
    \   val diffs = closestValues.map(n => math.abs(closestInteger - n))\n       \
    \     if (diffs.min() < diffs.max) {\n                closestInteger\n       \
    \     } else {\n                closestIntegers\n            }\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptkitdyvv.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mintegers\e[0m = mutable.LinkedHashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def closestIntegerHelper(n\
    \ : String, result : Long) : Long = {\n            if(n.equals(\"-Infinity\")){\n\
    \                result = 0\n            }\n            if(n.equals(\"Infinity\"\
    )){\n                result = Long.MaxValue\n            }\n            if(n.equals(\"\
    0\")){\n                result = 0\n            }\n            if(n.equals(\"\
    NaN\")){\n                result = Long.MaxValue\n            }\n            else\
    \ if(n.startsWith(\"-\")){\n                val x = n.toLong\n               \
    \ val y = result * -1\n                if(x.toLong < y){\n                   \
    \ result = x - 1\n                }\n                else if(x.toLong > y){\n\
    \                    result = x + 1\n                }\n                else if(x.toLong\
    \ == y){\n                    result = x\n                }\n            }\n \
    \           else{\n                val x = n.toLong\n                val y = result\
    \ + 1\n                if(x.toLong > y){\n                    result = x + 1\n\
    \                }\n                else if(x.toLong < y){\n                 \
    \   result = x - 1\n                }\n                else if(x.toLong == y){\n\
    \                    result = x\n                }\n            }\n          \
    \  result\n        }\n        val num = value.toDouble\n        val intNum : Int\
    \ = num.toInt\n        if(intNum == num){\n            intNum\n        }\n   \
    \     else{\n            val result = closestIntegerHelper(value, intNum)\n  \
    \          if(result == 0){\n                intNum\n            }\n         \
    \   else{\n                result\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdb0jeh11.scala:20:23 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result = \e[31m0\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdb0jeh11.scala:23:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                result\
    \ = Long.MaxValue\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val result\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpdb0jeh11.scala:26:23 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                result = \e[31m0\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdb0jeh11.scala:29:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                result\
    \ = Long.MaxValue\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val result\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpdb0jeh11.scala:35:27 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    result = x - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \            Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpdb0jeh11.scala:38:27 -----------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                    result = x + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         Reassignment to val result\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660010476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // TODO: Code\
    \ goes here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpis4w9iu5.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m        \e[34m// TODO: Code goes here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closestValue\
    \ : Long = 0\n        val numbers = value.split(\"\"\"\\.|,|:|\\s/).map(_.toDouble)\n\
    \        var closestIndex = 0\n        for (i <- 0 until numbers.size) {\n   \
    \         val x = numbers(i)\n            val y = numbers(i + 1)\n           \
    \ val distance = (x - y).abs()\n            if (distance < closestValue) {\n \
    \               closestValue = distance\n                closestIndex = i\n  \
    \          }\n        }\n        numbers(closestIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmph29i0z8z.scala:19:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnumbers\e[0m = value.split(\"\
    \"\"\\.|,|:|\\s/).map(_.toDouble)\n\e[31m\e[31m   |\e[0m                     \
    \             ^\e[0m\n\e[31m   |\e[0m                                  unclosed\
    \ multi-line string literal\n1 error found\n"
  stdout: ''
  timestamp: 1660010476
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val values\
    \ = value.split(\"\\\\.\") map (_.toDouble)\n        val closestToZero = values.sorted.min\n\
    \        // round towards zero, i.e. closest to (but not below) zero\n       \
    \ math.round(closestToZero)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppu17lw50.scala:25)\n\tat Problem.main(tmppu17lw50.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Use a mutable\
    \ map to track the numbers that we've encountered\n        // and their distances\
    \ to the target number\n        val numMap = new mutable.HashMap[Long, Double]()\n\
    \        // Use a mutable set to keep track of the numbers that we've checked\n\
    \        val seen = new mutable.HashSet[Long]()\n        // Use a mutable set\
    \ to keep track of the numbers we've already considered\n        // so that we\
    \ don't repeat the same number\n        val checked = new mutable.HashSet[Long]()\n\
    \        // Remember the target number in the map\n        val num = (value.toDouble).longValue\n\
    \        // Keep a set containing the integers in the number range we care about\n\
    \        // We'll add 1 to this number later, so adding 1 is equivalent to subtracting\
    \ one\n        val range = (num.toInt - 1) * 1000\n        // Add the target number\
    \ to the map and then loop through all the numbers in the\n        // range to\
    \ see if we've seen them before\n        for (i <- range until (num.toInt + 1))\
    \ {\n            val newNum = (i.toDouble).longValue\n            val currentDistance\
    \ = abs(num - newNum)\n            // Add the current distance to the map\n  \
    \          val newEntry = (currentDistance, newNum)\n            numMap.put(newNum,\
    \ currentDistance)\n            // If the number has not been seen before, check\
    \ if we've reached the target\n            // number yet. If we have, we'll return\
    \ it\n            if (!seen.contains(newNum)) {\n                // Check if the\
    \ target number is in the map yet\n                if (!numMap.contains(num))\
    \ {\n                    seen.add(newNum)\n                    return newNum\n\
    \                } else {\n                    // If the number has already been\
    \ seen before, then update the distance\n                    // and add it to\
    \ the set of checked numbers\n                    numMap.put(num, currentDistance)\n\
    \                    checked.add(num)\n                }\n            }\n    \
    \    }\n        -1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0ony42l2.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnumMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mDouble\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0ony42l2.scala:22:23 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mseen\e[0m = \e[33mnew\e[0m mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0ony42l2.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mchecked\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def distance(x:\
    \ Long, y: Long): Long = {\n            val dx = x - y\n            if (dx ==\
    \ 0) 1\n            else abs(dx) / x\n        }\n        if (value.contains(\"\
    .\")){\n            val floatValue = value.split('.').toArray.head\n         \
    \   val integerValue = floatValue % 1\n            val integerDivisor = math.ceil(floatValue\
    \ * 100) / 100\n            val x = integerValue * integerDivisor\n          \
    \  val y = integerDivisor\n            var closestDiff: Long = distance(x, y)\n\
    \            if (closestDiff < distance(x+1.0, y)) {\n                closestDiff\
    \ = distance(x+1.0, y)\n            }\n            if (closestDiff < distance(x,\
    \ y-1.0)) {\n                closestDiff = distance(x, y-1.0)\n            }\n\
    \            closestDiff\n        } else {\n            val integerValue = value.toInt\n\
    \            val integerDivisor = math.ceil(integerValue * 100) / 100\n      \
    \      val x = integerValue * integerDivisor\n            val y = integerDivisor\n\
    \            var closestDiff: Long = distance(x, y)\n            if (closestDiff\
    \ < distance(x+1.0, y)) {\n                closestDiff = distance(x+1.0, y)\n\
    \            }\n            if (closestDiff < distance(x, y-1.0)) {\n        \
    \        closestDiff = distance(x, y-1.0)\n            }\n            closestDiff\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4q9pdsyh.scala:25:42 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mintegerValue\e[0m =\
    \ floatValue % \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                           \
    \    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of String, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mThe following import might make progress towards fixing the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4q9pdsyh.scala:26:43\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mintegerDivisor\e[0m = math.ceil(floatValue * \e[31m100\e[0m) / \e[31m100\e\
    [0m\n\e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Found:    String\n\
    \e[31m   |\e[0m                                           Required: Double\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4q9pdsyh.scala:29:48\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mvar\e[0m \e\
    [36mclosestDiff\e[0m: \e[35mLong\e[0m = distance(x, y)\n\e[31m\e[31m   |\e[0m\
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                           Found:    (y : Double)\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4q9pdsyh.scala:30:46 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (closestDiff < distance(x+\e\
    [31m1.0\e[0m, y)) {\n\e[31m\e[31m   |\e[0m                                   \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \    Found:    (y : Double)\n\e[31m   |\e[0m                                 \
    \             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when"
  stdout: ''
  timestamp: 1660010484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var sum : Double\
    \ = Double.PositiveInfinity\n        var numStr : String = value\n        var\
    \ num : Long = 0\n        var isNegative : Boolean = false\n        while(numStr\
    \ != \"\"){\n            val nextNumStr : String = numStr.substring(0,numStr.indexOf(\"\
    .\")+1)\n            val nextNum = nextNumStr.asInstanceOf[String].toLong\n  \
    \          val lastNumStr : String = numStr.substring(numStr.indexOf(\".\")+2)\n\
    \            val lastNum = lastNumStr.asInstanceOf[String].toLong\n          \
    \  if (nextNum > lastNum){\n                numStr = numStr.substring(0,numStr.indexOf(\"\
    .\")+1)\n                sum = Math.abs(nextNum - lastNum)\n                num\
    \ = nextNum\n            }\n            else if (nextNum < lastNum){\n       \
    \         numStr = numStr.substring(0,numStr.indexOf(\".\")+1)\n             \
    \   sum = Math.abs(lastNum - nextNum)\n                num = lastNum\n       \
    \     }\n            else{\n                sum = Math.abs(nextNum - lastNum)\n\
    \                num = nextNum\n            }\n            numStr = \"\"\n   \
    \     }\n        if (isNegative){\n            num = -num\n        }\n       \
    \ return num\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpi3clxs2q.scala:24)\n\
    \tat Problem$.main(tmpi3clxs2q.scala:49)\n\tat Problem.main(tmpi3clxs2q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010481
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value match\
    \ {\n            case x if x.toString.length == 2 => x.toString.toDouble.round()\n\
    \            case x if x.toString.length == 1 => x.toString.toDouble.round()\n\
    \            case _ => 0\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpo7ltnz27.scala:19:68 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x.toString.length\
    \ == \e[31m2\e[0m => x.toString.toDouble.round()\n\e[31m\e[31m   |\e[0m      \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m               \e[33mmethod\e[0m \e[35mround\e[0m in \e[33mclass\e\
    [0m \e[35mRichDouble\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpo7ltnz27.scala:20:68 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x.toString.length\
    \ == \e[31m1\e[0m => x.toString.toDouble.round()\n\e[31m\e[31m   |\e[0m      \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m               \e[33mmethod\e[0m \e[35mround\e[0m in \e[33mclass\e\
    [0m \e[35mRichDouble\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var closest\
    \ = Long.MaxValue\n        var closestIndex : Long = Long.MinValue\n        var\
    \ valueInt = value.toLong\n        var valueString = value.toString\n\n      \
    \  for ( i <- 1 to valueString.length-1) {\n            if (valueString.charAt(i)\
    \ == '-') {\n                valueInt = -valueInt\n            }\n           \
    \ val closestToI = valueInt.abs / (i+1)\n            if (closestToI < closest)\
    \ {\n                closest = closestToI\n                closestIndex = i\n\
    \            }\n        }\n        closest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp99e70o5r.scala:36)\n\tat Problem.main(tmp99e70o5r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // If the value\
    \ is blank\n        if (value == null || value == \"\") {\n            return\
    \ 0\n        }\n        // If the value is less than 1\n        else if (value.length()\
    \ < 1) {\n            return 0\n        }\n        // If it isn't an integer value\n\
    \        else if (value.toInt == 0) {\n            return 0\n        }\n     \
    \   // If the value is a single character string\n        else if (value.length()\
    \ == 1) {\n            if (value.charAt(0) == '-') {\n                return 0\n\
    \            }\n            else {\n                return value.charAt(0).toInt\n\
    \            }\n        }\n        // Split the value on the \".\" character\n\
    \        else if (value.contains(\".\") || value.contains(\",\")) {\n        \
    \    // If the value is a decimal value\n            if (value.contains(\".\"\
    )) {\n                // Split the value on the \".\" character\n            \
    \    val tokens = value.split(\".\")\n                // Get the left and right\
    \ parts of the value\n                val left = tokens(0).trim\n            \
    \    val right = tokens(1).trim\n                // If there is only one part,\
    \ make sure that the right part\n                // is less than 10\n        \
    \        if (left.length() == 1) {\n                    if (right.startsWith(\"\
    0\")) {\n                        return 0\n                    }\n           \
    \     }\n                // Calculate the difference between the left and right\
    \ parts\n                val diff = left.toInt - right.toInt\n               \
    \ // If the diff is greater than 10, round away from zero\n                if\
    \ (diff > 10) {\n                    return 0\n                }\n           \
    \     else if (diff > 0) {\n                    return diff\n                }\n\
    \                // If the diff is less than -10, round away from zero\n     \
    \           else if (diff < 0) {\n                    return 10 + diff\n     \
    \           }\n                // If the diff is equal to 0, return 0\n      \
    \          else {\n                    return 0\n                }\n         \
    \   }\n            // If the value is a comma separated value\n            if\
    \ (value.contains(\",\")) {\n                // Split the value on the \",\" character\n\
    \                val tokens = value.split(\",\")\n                // Get the left\
    \ and right parts of the value\n                val left = tokens(0).trim\n  \
    \              val right = tokens(1).trim\n                // If there is only\
    \ one part, make sure that the right part\n                // is less than 10\n\
    \                if (left.length() == 1) {\n                    if (right.startsWith(\"\
    0\")) {\n                        return 0\n                    }\n           \
    \     }\n                // Calculate the difference between the left and right\
    \ parts\n                val diff = left.toInt - right.toInt\n               \
    \ // If the diff is greater than 10, round away from zero\n                if\
    \ (diff > 10) {\n                    return 0\n                }\n           \
    \     else if (diff > 0) {\n                    return diff\n                }\n\
    \                // If the diff is less than -10, round away from zero\n     \
    \           else if (diff < 0) {\n                    return 10 + diff\n     \
    \           }\n                // If the diff is equal to 0, return 0\n      \
    \          else {\n                    return 0\n                }\n         \
    \   }\n            else {\n                // If the value is a zero padded string\n\
    \                if (value.startsWith(\"0\")) {\n                    // Split\
    \ the value on the \"0\" character\n                    val tokens = value.split(\"\
    0\")\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj_bpdwn1.scala:120:0 ---------------------------\e\
    [0m\e[0m\n\e[31m120 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj_bpdwn1.scala:40:13\
    \ --------------------\e[0m\e[0m\n\e[31m 40 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (value.contains(\e[31m\".\"\e[0m) || value.contains(\e[31m\",\"\e[0m)) {\n\
    \e[31m\e[31m    |\e[0m             ^\e[0m\n\e[31m    |\e[0m             Found:\
    \    Unit\n\e[31m    |\e[0m             Required: Long\n\e[31m    |\e[0m     \
    \        Maybe you are missing an else part for the conditional?\n\e[31m 41 |\e\
    [0m            \e[34m// If the value is a decimal value\e[0m\n\e[31m 42 |\e[0m\
    \            \e[33mif\e[0m (value.contains(\e[31m\".\"\e[0m)) {\n\e[31m 43 |\e\
    [0m                \e[34m// Split the value on the \".\" character\e[0m\n\e[31m\
    \ 44 |\e[0m                \e[33mval\e[0m tokens = value.split(\e[31m\".\"\e[0m)\n\
    \e[31m 45 |\e[0m                \e[34m// Get the left and right parts of the value\e\
    [0m\n\e[31m 46 |\e[0m                \e[33mval\e[0m left = tokens(\e[31m0\e[0m).trim\n\
    \e[31m 47 |\e[0m                \e[33mval\e[0m right = tokens(\e[31m1\e[0m).trim\n\
    \e[31m 48 |\e[0m                \e[34m// If there is only one part, make sure\
    \ that the right part\e[0m\n\e[31m 49 |\e[0m                \e[34m// is less than\
    \ 10\e[0m\n\e[31m 50 |\e[0m                \e[33mif\e[0m (left.length() == \e\
    [31m1\e[0m) {\n\e[31m 51 |\e[0m                    \e[33mif\e[0m (right.startsWith(\e\
    [31m\"0\"\e[0m)) {\n\e[31m 52 |\e[0m                        \e[33mreturn\e[0m\
    \ \e[31m0\e[0m\n\e[31m 53 |\e[0m                    }\n\e[31m 54 |\e[0m      \
    \          }\n\e[31m 55 |\e[0m                \e[34m// Calculate the difference\
    \ between the left and right parts\e[0m\n\e[31m 56 |\e[0m                \e[33mval\e\
    [0m diff = left.toInt - right.toInt\n\e[31m 57 |\e[0m                \e[34m//\
    \ If the diff is greater than 10, round away from zero\e[0m\n\e[31m 58 |\e[0m\
    \                \e[33mif\e[0m (diff > \e[31m10\e[0m) {\n\e[31m 59 |\e[0m    \
    \                \e[33mreturn\e[0m \e[31m0\e[0m\n\e[31m 60 |\e[0m            \
    \    }\n\e[31m 61 |\e[0m                \e[33melse\e[0m \e["
  stdout: ''
  timestamp: 1660010480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\")\n        val num = numbers(0)\n        val dec = numbers(1)\n\
    \        val digits = dec.toLong * 10\n        val num = num.toLong * 10\n   \
    \     val dec = dec.toLong * 10\n        val digitsToAdd = digits - dec\n    \
    \    var closestToZero = num\n        while (closestToZero > 0 && closestToZero\
    \ < digits) {\n            closestToZero += 1\n        }\n        val numToAdd\
    \ = num - closestToZero\n        return closestToZero + numToAdd\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqnpo48ei.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnum\e[0m = num.toLong *\
    \ \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mnum is already defined as \e[33mvalue\e[0m \e[35mnum\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqnpo48ei.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mdec\e[0m = dec.toLong * \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdec\
    \ is already defined as \e[33mvalue\e[0m \e[35mdec\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqnpo48ei.scala:24:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36mdigitsToAdd\e[0m = digits - dec\n\e[31m\e[31m   |\e[0m             \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((dec : String))\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqnpo48ei.scala:26:31 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mwhile\e[0m (closestToZero > \e[31m0\e[0m && closestToZero\
    \ < digits) {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e\
    [31m   |\e[0m                               Found:    (\e[31m0\e[0m : Int)\n\e\
    [31m   |\e[0m                               Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqnpo48ei.scala:26:52 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mwhile\e[0m (close"
  stdout: ''
  timestamp: 1660010485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val digits\
    \ = value.split('.').map(_.toInt).toList\n        val length = digits.length\n\
    \        if (length == 0)\n            return 0L\n        var closestToZero =\
    \ 0.0\n        var closestToZeroDigit = 0\n        digits.zipWithIndex.foreach\
    \ { case (digit, digitIndex) =>\n            val square = math.pow(10.0d, digitIndex)\n\
    \            if (digit < closestToZero)\n                closestToZero = digit\n\
    \            if (digit < closestToZero + square) {\n                closestToZeroDigit\
    \ = digitIndex\n            }\n        }\n        digits.zipWithIndex.foreach\
    \ { case (digit, digitIndex) =>\n            if (digitIndex == closestToZeroDigit\
    \ && digit < 0.0d)\n                digit = -digit\n        }\n        val closestInt\
    \ = digits.head * math.pow(10.0d, digits.tail.size - 1) + digits.last\n      \
    \  return closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdmqddon.scala:34:22 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                digit = -digit\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val digit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphdmqddon.scala:37:15\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mreturn\e[0m closestInt\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \      Found:    (closestInt : Double)\n\e[31m   |\e[0m               Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ goes here\n        val arr = value.split(\"\\\\.\") //((\"15\"))\n        val\
    \ narr=arr.tail\n        var ans=0\n        var dis=0\n        for(i <- 0 until\
    \ arr.length-1){\n            var f=arr(i)\n            var s=arr(i+1)\n     \
    \       if(f<s){\n                val c=f.toInt\n                val d=s.toInt\n\
    \                f=c-d\n                s=c+d\n            }\n            val\
    \ c=f.toInt\n            val d=s.toInt\n            f-=d\n            s-=c\n \
    \           val diff=math.abs(f-d);\n            val sum=math.abs(f+s);\n    \
    \        if(diff>sum)\n                continue;\n            if(diff<ans){\n\
    \                ans=diff\n            }\n        }\n        ans*math.pow(10,arr.length)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp33v8tayu.scala:29:18\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                f=c-d\n\e[31m\e\
    [31m   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  Found:\
    \    Int\n\e[31m   |\e[0m                  Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp33v8tayu.scala:30:20 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                s=c+d\n\e[31m\e[31m   |\e[0m        \
    \            ^\e[0m\n\e[31m   |\e[0m                    Found:    (d : Int)\n\e\
    [31m   |\e[0m                    Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp33v8tayu.scala:34:13 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            f-=d\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m            value -= is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp33v8tayu.scala:35:13\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            s-=c\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m            value -= is not\
    \ a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp33v8tayu.scala:36:31 ------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mdiff\e[0m=math.abs(f-d);\n\e[31m\e[31m\
    \   |\e[0m                              ^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of String, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp33v8tayu.scala:37:25 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36msum\e[0m=math.abs(f+s);\n\
    \e[31m"
  stdout: ''
  timestamp: 1660010486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numberAsString\
    \ = value.toDouble\n        var roundingConditions = true\n        var smallestDiff\
    \ = math.min(Math.abs(numberAsString), Math.abs(numberAsString))\n        var\
    \ largestDiff = math.max(Math.abs(numberAsString), Math.abs(numberAsString))\n\
    \        var smallerOne = math.abs(numberAsString) / smallestDiff\n        var\
    \ largerOne = math.abs(numberAsString) / largestDiff\n        while (roundingConditions)\
    \ {\n            // If it is the same number we already have, return it\n    \
    \        if (numberAsString == smallestDiff) {\n                return smallestDiff\n\
    \            }\n            if (numberAsString == largestDiff) {\n           \
    \     return largestDiff\n            }\n            // We need to see if it is\
    \ closer than our smallest or largest difference\n            if (Math.abs(numberAsString)\
    \ < smallestDiff) {\n                // If it is closer to our smallest difference,\
    \ we can round up\n                if (numberAsString - smallestDiff > largestDiff)\
    \ {\n                    numberAsString = math.ceil(numberAsString)\n        \
    \            // If it has been rounded to an integer more than twice and is closer\
    \ than our smallest difference\n                    //    we can just return that\n\
    \                    if (numberAsString == smallestDiff) {\n                 \
    \       return smallestDiff\n                    }\n                    // Otherwise,\
    \ we need to see if it is closer than our smallest difference\n              \
    \      // and round down\n                } else {\n                    numberAsString\
    \ = math.floor(numberAsString)\n                    // If it has been rounded\
    \ to an integer less than twice and is closer than our smallest difference\n \
    \                   //    we can just return that\n                    if (numberAsString\
    \ == smallestDiff) {\n                        return smallestDiff\n          \
    \          }\n                    // Otherwise, we need to see if it is closer\
    \ than our smallest difference\n                    // and round down\n      \
    \          }\n            }\n            if (Math.abs(numberAsString) > largestDiff)\
    \ {\n                // If it is closer to our largest difference, we can round\
    \ down\n                if (numberAsString - largestDiff < smallestDiff) {\n \
    \                   numberAsString = math.floor(numberAsString)\n            \
    \        // If it has been rounded to an integer more than twice and is closer\
    \ than our smallest difference\n                    //    we can just return that\n\
    \                    if (numberAsString == largestDiff) {\n                  \
    \      return largestDiff\n                    }\n                    // Otherwise,\
    \ we need to see if it is closer than our smallest difference\n              \
    \      // and round down\n                } else {\n                    numberAsString\
    \ = math.ceil(numberAsString)\n                    // If it has been rounded to\
    \ an integer less than twice and is closer than our smallest difference\n    \
    \                //    we can just return that\n                    if (numberAsString\
    \ == largestDiff) {\n                        return largestDiff\n            \
    \        }\n                    // Otherwise, we need to see if it is closer than\
    \ our smallest difference\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3hz4rh2o.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3hz4rh2o.scala:27:23\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mreturn\e\
    [0m smallestDiff\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (smallestDiff : Double)\n\e[31m\
    \   |\e[0m                       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3hz4rh2o.scala:30:23 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mreturn\e[0m largestDiff\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \               Found:    (largestDiff : Double)\n\e[31m   |\e[0m            \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp3hz4rh2o.scala:36:35 -----------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                    numberAsString = math.ceil(numberAsString)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val numberAsString\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3hz4rh2o.scala:40:31\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                        \e[33mreturn\e\
    [0m smallestDiff\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    (smallestDiff : Double)\n\
    \e[31m   |\e[0m                               Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp3hz4rh2o.scala:45:35 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    numberAsString = math"
  stdout: ''
  timestamp: 1660010486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\",\").toList.map(_.toLong)\n        val sum = parts.reduceLeftOption\
    \ { (x, y) => x + y }\n        val sum = sum.getOrElse(0)\n        val difference\
    \ = parts zip parts.tail.zipWithIndex\n        val difference = difference.toSeq.sortWith((x,\
    \ y) => x._1 > y._1).map{case (y,index) => (y._1 - x._1,index)}\n        val minDiff\
    \ = difference._2\n        val nearestDiff = minDiff - 1\n        val nearestParts\
    \ = parts.take(nearestDiff)\n        val nearestSum = parts.sum\n        (nearestSum\
    \ - sum, nearestParts)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm_h57gmp.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = sum.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msum is already defined as \e[33mvalue\e[0m \e[35msum\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpm_h57gmp.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mdifference\e[0m = difference.toSeq.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x._1 > y._1).map{\e[33mcase\e[0m (y,index) => (y._1\
    \ - x._1,index)}\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdifference is already defined as \e[33mvalue\e[0m \e[35mdifference\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpm_h57gmp.scala:23:33 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = difference._2\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \            value _2 is not a member of List[(Long, (Long, Int))]\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpm_h57gmp.scala:27:20 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        (nearestSum - sum, nearestParts)\n\e[31m\e[31m\
    \   |\e[0m         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((sum : Option[Long]))\n4 errors found\n"
  stdout: ''
  timestamp: 1660010486
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var current\
    \ = 0L\n        var next = value.toLong\n        var currentSum = 0L\n       \
    \ var nextSum = 0L\n        while(current < next){\n            currentSum +=\
    \ current\n            next = math.abs(next)\n            currentSum -= next\n\
    \            next += current\n        }\n        if(current < next){\n       \
    \     currentSum += next\n        }\n        return currentSum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val list =\
    \ value.split('.').toList\n        val num = list(0)\n        if (list.length\
    \ > 1) {\n            val dist = list.zip(list.tail)\n                .map(x =>\
    \ (Math.abs(num.toDouble - x._1.toDouble), x._2))\n                .reduce(_._1).getOrElse((0L,\
    \ 0L))\n            val closest = dist.filter(_._1 > dist)\n                .map(_._2)\n\
    \                .getOrElse(num)\n            val diff = ((closest.toDouble -\
    \ num.toDouble) / num.toDouble) * 100\n            diff < 0 ? closest.toLong :\
    \ closest.toLong - diff\n        } else {\n            val n = num.toLong\n  \
    \          if (n < 0) -n else n\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpk69sabjv.scala:23:24 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                .reduce(_._1).getOrElse((\e[31m0L\e[0m,\
    \ \e[31m0L\e[0m))\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                        Wrong number of parameters, expected: 2\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk69sabjv.scala:28:55 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            diff < \e[31m0\e[0m ? closest.toLong : closest.toLong\
    \ \e[35m-\e[0m \e[35mdiff\e[0m\n\e[31m\e[31m   |\e[0m                        \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Not found: type -\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val fractions\
    \ = value.split('.')\n        var total = 0L\n        var i = 0\n        var pow\
    \ = 1L\n        val length = fractions.length\n        for(frac <- fractions)\
    \ {\n            val value = frac.toLong\n            total += value * pow\n \
    \           i ++\n            pow *= 10L\n        }\n        val fractionLength\
    \ = fractions.length\n        if (fractionLength == 0) {\n            total\n\
    \        } else if (fractionLength == 1) {\n            total + fractions(0).toLong\n\
    \        } else if (fractionLength == 2) {\n            total + fractions(0).toLong\
    \ + fractions(1).toLong\n        } else if (fractionLength >= 3) {\n         \
    \   val min = (fractions(0).toLong + fractions(1).toLong)\n            val max\
    \ = (fractions(fractionLength - 1).toLong + fractions(fractionLength).toLong)\n\
    \            val delta = max - min\n            val closestNum = min + delta/2\n\
    \            val distance = pow * (fractionLength - 1)\n            val result\
    \ = closest + distance\n            closestNum.toLong\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoluv6ql3.scala:26:14 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            i ++\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            value ++ is not a member of Int\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpoluv6ql3.scala:42:25 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = closest\
    \ + distance\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: closest\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val input =\
    \ value.asInstanceOf[String]\n        val splitInput = input.split(\"\")\n   \
    \     val inputAsList = splitInput.map(_.toLong).toList\n        val min = inputAsList.min()\n\
    \        val max = inputAsList.max()\n        if(Math.abs(max - min) < .00001){\n\
    \            return inputAsList\n        }\n        val diff = max - min\n   \
    \     val diffAbs = Math.abs(diff)\n        val splitDiff = diff.split(\"\")\n\
    \        val diffAsList = splitDiff.map(_.toLong).toList\n        val index =\
    \ diffAbs.indexOf(0)\n        val roundedDiff = diffAsList(index).toInt\n    \
    \    val roundedDiffAbs = Math.abs(roundedDiff)\n        val roundDiff = roundedDiff\
    \ / Math.pow(10, diffAbs.length)\n        val roundDiffAbs = Math.abs(roundDiff)\n\
    \        if(diffAbs == roundedDiffAbs && diffAbs == roundDiffAbs){\n         \
    \   return inputAsList\n        }\n        val newInput = inputAsList.length -\
    \ 1\n        val splitNewInput = newInput.split(\"\")\n        val newInputAsList\
    \ = splitNewInput.map(_.toLong).toList\n        val minNewInput = newInputAsList.min()\n\
    \        val maxNewInput = newInputAsList.max()\n        if(Math.abs(maxNewInput\
    \ - minNewInput) < .00001){\n            return inputAsList\n        }\n     \
    \   val diff = maxNewInput - minNewInput\n        val diffAbs = Math.abs(diff)\n\
    \        val splitDiff = diff.split(\"\")\n        val diffAsList = splitDiff.map(_.toLong).toList\n\
    \        val index = diffAbs.indexOf(0)\n        val roundedDiff = diffAsList(index).toInt\n\
    \        val roundedDiffAbs = Math.abs(roundedDiff)\n        val roundDiff = roundedDiff\
    \ / Math.pow(10, diffAbs.length)\n        val roundDiffAbs = Math.abs(roundDiff)\n\
    \        if(diffAbs == roundedDiffAbs && diffAbs == roundDiffAbs){\n         \
    \   return inputAsList\n        }\n        val newInput2 = inputAsList.length\
    \ - 1\n        val splitNewInput2 = newInput2.split(\"\")\n        val newInputAsList2\
    \ = splitNewInput2.map(_.toLong).toList\n        val minNewInput2 = newInputAsList2.min()\n\
    \        val maxNewInput2 = newInputAsList2.max()\n        if(Math.abs(maxNewInput2\
    \ - minNewInput2) < .00001){\n            return inputAsList\n        }\n    \
    \    val diff = maxNewInput2 - minNewInput2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv9d_2l39.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mdiff\e[0m = maxNewInput\
    \ - minNewInput\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiff is already defined as \e[33mvalue\e[0m \e[35mdiff\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv9d_2l39.scala:47:12 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mval\e[0m \e[36mdiffAbs\e[0m = Math.abs(diff)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdiffAbs is\
    \ already defined as \e[33mvalue\e[0m \e[35mdiffAbs\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv9d_2l39.scala:48:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m\
    \ \e[36msplitDiff\e[0m = diff.split(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msplitDiff is already\
    \ defined as \e[33mvalue\e[0m \e[35msplitDiff\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv9d_2l39.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffAsList\e[0m = splitDiff.map(_.toLong).toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdiffAsList\
    \ is already defined as \e[33mvalue\e[0m \e[35mdiffAsList\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv9d_2l39.scala:50:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m\
    \ \e[36mindex\e[0m = diffAbs.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mindex is already defined\
    \ as \e[33mvalue\e[0m \e[35mi"
  stdout: ''
  timestamp: 1660010488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val splitString\
    \ = value.split(\"\\\\.\");\n        val stringValue = splitString(0);\n     \
    \   val numberValue = splitString(1);\n        val numberAsLong = tryParse(numberValue);\n\
    \        val stringAsLong = tryParse(stringValue);\n        var numberToReturn:\
    \ Long = numberAsLong\n        if(stringValue == \"-\" && (numberAsLong + numberAsLong\
    \ == numberAsLong))\n            numberToReturn = numberAsLong * -1\n        if(numberAsLong\
    \ < numberToReturn && stringAsLong < numberToReturn)\n            numberToReturn\
    \ = numberAsLong\n        if(numberToReturn < numberAsLong && stringToReturn <\
    \ numberToReturn)\n            numberToReturn = numberToReturn\n        if(stringToReturn\
    \ < numberToReturn && stringAsLong < numberToReturn)\n            numberToReturn\
    \ = numberToReturn\n        if(stringToReturn < numberToReturn && stringToReturn\
    \ < stringAsLong)\n            numberToReturn = numberToReturn\n        if(stringToReturn\
    \ < stringAsLong)\n            numberToReturn = numberToReturn\n        numberToReturn\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp224_tc4j.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnumberAsLong\e[0m = tryParse(numberValue);\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: tryParse\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp224_tc4j.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstringAsLong\e[0m = tryParse(stringValue);\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: tryParse\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp224_tc4j.scala:30:11 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m(stringToReturn < numberToReturn\
    \ && stringAsLong < numberToReturn)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           Not found: stringToReturn\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp224_tc4j.scala:32:11 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m(stringToReturn < numberToReturn\
    \ && stringToReturn < stringAsLong)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           Not found: stringToReturn\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp224_tc4j.scala:34:11 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m(stringToReturn < stringAsLong)\n\
    \e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \  Not found: stringToReturn\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Define a\
    \ function that will find the closest integer\n        def closestInt(num : Double)\
    \ : Double = {\n            val abs = math.abs(num)\n            if(abs < .1)\
    \ {\n                if(abs < 1.0) {\n                    if(abs < 1.5) {\n  \
    \                      if(abs < 2.0) {\n                            if(abs < 2.5)\
    \ {\n                                if(abs < 3.0) {\n                       \
    \             if(abs < 3.5)\n                                        0\n     \
    \                           }\n                            }\n               \
    \         }\n                    }\n                }\n            }\n       \
    \     else {\n                if(abs < 2.0) {\n                    if(abs < 3.0)\
    \ {\n                        if(abs < 3.5) {\n                            if(abs\
    \ < 4.0) {\n                                if(abs < 4.5)\n                  \
    \                  0\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        //\
    \ Convert the value to a double, make sure to convert it to double\n        //\
    \ and not a string.\n        val x = value.asInstanceOf[Double]\n        // Find\
    \ the closest integer\n        val closestInt = (Math.round(x)).asInstanceOf[Double]\n\
    \        // Find the difference between closest integer and original value\n \
    \       val diffInt = x - closestInt\n        // Find the number of places after\
    \ the decimal to round to\n        val numPlaces = java.lang.Math.floor(java.lang.Math.abs(java.lang.Math.abs(diffInt)/0.1)).asInstanceOf[Double]\n\
    \        // Now get the nearest integer\n        val nearestInt = closestInt *\
    \ java.lang.pow(10,numPlaces)\n        // Find the absolute difference\n     \
    \   val diff = Math.abs(nearestInt - x)\n        // Return the closest integer\n\
    \        return closestInt.asInstanceOf[Long]\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuyav822s.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mclosestInt\e[0m = (Math.round(x)).asInstanceOf[\e\
    [35mDouble\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestInt is already defined as \e[33mmethod\e[0m \e[35mclosestInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpuyav822s.scala:22:16 --------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m                \e[33mif\e[0m(abs < \e[31m1.0\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Found:   \
    \ Unit\n\e[31m   |\e[0m                Required: Double\n\e[31m   |\e[0m     \
    \           Maybe you are missing an else part for the conditional?\n\e[31m23\
    \ |\e[0m                    \e[33mif\e[0m(abs < \e[31m1.5\e[0m) {\n\e[31m24 |\e\
    [0m                        \e[33mif\e[0m(abs < \e[31m2.0\e[0m) {\n\e[31m25 |\e\
    [0m                            \e[33mif\e[0m(abs < \e[31m2.5\e[0m) {\n\e[31m26\
    \ |\e[0m                                \e[33mif\e[0m(abs < \e[31m3.0\e[0m) {\n\
    \e[31m27 |\e[0m                                    \e[33mif\e[0m(abs < \e[31m3.5\e\
    [0m)\n\e[31m28 |\e[0m                                        \e[31m0\e[0m\n\e\
    [31m29 |\e[0m                                }\n\e[31m30 |\e[0m              \
    \              }\n\e[31m31 |\e[0m                        }\n\e[31m32 |\e[0m  \
    \                  }\n\e[31m33 |\e[0m                }\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpuyav822s.scala:36:16 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mif\e[0m(abs < \e[31m2.0\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Found:\
    \    Unit\n\e[31m   |\e[0m                Required: Double\n\e[31m   |\e[0m  \
    \              Maybe you are missing an else part for the conditional?\n\e[31m37\
    \ |\e[0m                    \e[33mif\e[0m(abs < \e[31m3.0\e[0m) {\n\e[31m38 |\e\
    [0m         "
  stdout: ''
  timestamp: 1660010488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ string to a number\n        var value = value.toLong\n        var last = 0\n\
    \        // Loop through all possible integers\n        for (i <- 1 until value)\
    \ {\n            // Check if a multiple of i\n            if (value % i == 0)\
    \ {\n                // If so, check if it is closer to last or not\n        \
    \        if (Math.abs(value - i) < Math.abs(value - last)) {\n               \
    \     // If so, use i\n                    last = i\n                }\n     \
    \       }\n        }\n        // Return final answer\n        value\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6m2extv9.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvalue\e[0m = value.toLong\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvariable\e[0m \e[35mvalue\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val valueAsDouble\
    \ = value.asInstanceOf[String].toDouble\n        val closestInteger = math.ceil(valueAsDouble)\n\
    \        val closestIntegerAsString = closestInteger.toString.asInstanceOf[String]\n\
    \        (closestIntegerAsString -> closestInteger)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn5bfigcg.scala:21:9\
    \ ---------------------\e[0m\e[0m\n\e[31m21 |\e[0m        (closestIntegerAsString\
    \ -> closestInteger)\n\e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Found:    (String, Double)\n\e[31m   |\e[0m     \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        // If there is no integer after the decimal\n        if (num < 10.0)\n\
    \            num\n        // If there is an integer, get rid of everything after\
    \ the decimal\n        else {\n            // If there is more than one integer\
    \ after the decimal\n            if (num > 99)\n                num / 10.0\n \
    \           // If there is only one integer after the decimal\n            else\
    \ {\n                // Return the integer if it is closer to zero\n         \
    \       val pow10 = math.pow(10.0, math.ceil(math.log10(num)))\n             \
    \   val intVal = num / pow10\n                if (intVal < num)\n            \
    \        intVal\n                else\n                    num\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp_4v3opv.scala:26:16\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                num / \e[31m10.0\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \             Found:    Double\n\e[31m   |\e[0m                Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp_4v3opv.scala:33:20\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    intVal\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \          Found:    (intVal : Double)\n\e[31m   |\e[0m                    Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val result\
    \ = value.trim.toDouble.abs + 1\n        val fraction = value.substring(0,value.length-1)\n\
    \        val decimal = fraction.substring(fraction.length-1,fraction.length)\n\
    \        val fractionalInt = decimal.toInt\n        if(fractionalInt > result)\n\
    \            fractionalInt\n        else if(fractionalInt == result)\n       \
    \     fractionalInt + 1\n        else\n            result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt0619mzn.scala:27:12\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            result\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (result\
    \ : Double)\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.isEmpty)\
    \ throw new Exception(\"Empty value\")\n        val parts = value.split('.')\n\
    \        if (parts.size > 3) throw new Exception(\"Invalid value\")\n        val\
    \ digits = parts(0) to parts(parts.size-1)\n        val smallestDistance = digits.size-1\n\
    \        for {\n            d <- digits\n        } yield {\n            val x\
    \ = d.toInt\n            if (x < 0)\n                smallestDistance = digits\n\
    \            else smallestDistance = digits.size-1\n        }\n        smallestDistance\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi4kcevrr.scala:21:38\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mdigits\e\
    [0m = parts(\e[31m0\e[0m) to parts(parts.size-\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    String\n\e[31m   |\e[0m                \
    \           Required: scala.collection.Factory[Char, Any]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpi4kcevrr.scala:22:38 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msmallestDistance\e[0m =\
    \ digits.size-\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue size is not a member of Nothing, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.buffer\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsJavaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi4kcevrr.scala:24:17\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            d <- digits\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0mvalue map is\
    \ not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the prob"
  stdout: ''
  timestamp: 1660010489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n       if (value.contains(\"\
    .\")){\n           val splits = value.split('.')\n           val integer1 = splits(0).toLong\n\
    \           val integer2 = splits(1).toLong\n           val difference = integer2\
    \ - integer1\n           val quotient = difference / integer1\n           return\
    \ integer1 + quotient\n       } else {\n           val splits = value.split('.')\n\
    \           val integer = splits(0).toLong\n           val remainder = integer\
    \ % 1\n           return integer + remainder\n       }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg1xi0dl1.scala:34)\n\tat Problem.main(tmpg1xi0dl1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val valueAsLong\
    \ = value.trim.toLong\n        // Find the distance between the current value\
    \ and the target value\n        val distance: Double = closestDistance(valueAsLong)\n\
    \n        // Return the value that is closest to the given value that is less\
    \ than\n        // or equal to zero\n        math.round(distance)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplun2jwx1.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdistance\e[0m: \e[35mDouble\e\
    [0m = closestDistance(valueAsLong)\n\e[31m\e[31m   |\e[0m                    \
    \           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \   Not found: closestDistance\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Create a\
    \ list of (index, integer) pairs\n        val (indice, integer) =\n          \
    \  value match {\n                // match on two integers, return an index that\
    \ maps to an integer from 0\n                case x if x.toInt == x =>\n     \
    \               (0L, x.toLong)\n                // match on two integers, return\
    \ a pair of integers\n                case x if x.toInt == x.toInt =>\n      \
    \              (0L, x.toInt)\n                // match on a float, return a pair\
    \ of integers\n                case x if x.toFloat == x.toFloat =>\n         \
    \           (0L, x.toDouble)\n                // otherwise, match on any string\
    \ representation of a number\n                case x if x.toString.toInt == x.toString.toInt\
    \ =>\n                    (0L, x.toString.toLong)\n            }\n        // Iterate\
    \ through the list to find the nearest integer\n        val newIndice = indice.zip(integer)\n\
    \        newIndice.foreach{ case (index, integer) =>\n            // If the index\
    \ is the same as the previous, don't do anything\n            if (index == indice.head\
    \ - 1) {\n                index\n            } else {\n                // If we\
    \ are not equidistant, round it away\n                if (Math.abs(integer - indice.tail.head)\
    \ > integer) {\n                    index - indice.head - 1\n                }\
    \ else {\n                    index\n                }\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptp4z17jo.scala:22:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m x \e[33mif\e[0m x.toInt\
    \ == x =>\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m         Values of types Int and String cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptp4z17jo.scala:35:31 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mnewIndice\e[0m = indice.zip(integer)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        value zip is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010489
