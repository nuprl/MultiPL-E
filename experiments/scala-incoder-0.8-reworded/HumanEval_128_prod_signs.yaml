name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the list, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
  \ -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n\
  \    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n    def prodSigns(arr\
  \ : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        arr.foldLeft((1l, 1l))((accVal, currVal) => {\n           \
    \ // Multiply currVal\n            (accVal * currVal, // Multiply currVal\n  \
    \          accVal + currVal) // Add currVal\n        })", "        val signs =\
    \ arr.foldLeft((0l,0l)) {\n            case ((sumOfSigns, productOfSigns), v)\
    \ =>\n                if (v > 0) (sumOfSigns + 1l, v) else (sumOfSigns - v, v\
    \ * -1)\n        }\n        signs._1 / (signs._2)", "        val product = arr.map(x\
    \ => x * x).sum\n        val signs = arr.map((x) => math.signum(x)).sum\n    \
    \    Option((product * signs))", "      arr.foldLeft(0L) {\n        case (acc,\
    \ val) => (if (val < 0) -val else val) * acc }", "        var product = 1\n  \
    \      var sumMagnitudes = 0l\n        for (el <- arr) {\n            sumMagnitudes\
    \ += Math.pow(el, product)\n            product *= el\n        }\n        if (arr.isEmpty)\
    \ None else Some(sumMagnitudes)", "        def product(x : Long, y : Long) : Long\
    \ = {\n            if (x>0) x*y else y*x\n        }\n        val mags = arr.map(x\
    \ => abs(x))\n        mags.foldLeft(0l) {\n            case (acc, x) => acc +\
    \ product(x, 1)\n        }", "        var sign : Long = 0\n        var maxSign\
    \ : Long = 0\n        arr.foreach{x =>\n            sign = math.signum(x)\n  \
    \          if(sign == -1)\n                maxSign = math.max(x,maxSign)\n   \
    \         else if(sign == 0)\n                maxSign = math.max(maxSign,x)\n\
    \        }\n        Some(maxSign*arr.sum)", "        arr.toIterator.flatMap {\
    \ x=>\n            val sign = x.getSign\n            val mag = x.toDouble\n  \
    \          if(mag==0.0)\n            None\n            else\n            Some((sign\
    \ * mag))\n        }.reduceLeftOption(x=>x*x).map(x=>x.toLong)", "        val\
    \ signs = mutable.Set[Int]()\n        val magnitudes = mutable.Map[Long, Long]()\n\
    \        val products = mutable.Map[Long, Long]()\n\n        arr.foreach{ i =>\n\
    \            signs += i\n            magnitudes(i) = i\n            products(i)\
    \ = i\n        }\n\n        magnitudes.foldLeft(0l) { (product, magnitude) =>\
    \ product * magnitude }\n        signs.foldLeft(0l) { (product, sign) => product\
    \ * sign }", '        if (arr.isEmpty) None else Some(arr.map(_.abs) * arr.product)',
  "        def checkMag(x : Long) : Int = {\n            if (x != 0) return 1\n  \
    \          else if (x < 0) return -1\n            else return 0\n        }\n \
    \       arr.foldLeft((0, arr(0).toLong))((acc, x) => {\n            (checkMag(x)\
    \ * acc(1), x)\n        })", "        val m = arr.map(_.abs).sum\n        var\
    \ signs = arr.map(_.signum).sum\n        if (signs == 0) {\n            Some(m\
    \ * arr.last)\n        } else {\n            signs = arr.map(_.signum).sum\n \
    \           if (signs != 0) {\n                Some((arr.takeWhile(_ > 0).last)\
    \ * m)\n            } else {\n                None\n            }\n        }",
  "        var sum = 0L\n        var mag = 0\n        var sign = 1\n\n        for(num\
    \ <- arr) {\n            mag += num\n            if(num > 0) {\n             \
    \   sign += num\n            } else {\n                sign *= -1\n          \
    \  }\n            sum += mag\n        }\n        Some(sum)", "        var sum:\
    \ Option[Long] = Option.empty[Long]\n        var product: Option[Long] = Option.empty[Long]\n\
    \        var sign: Option[Long] = Option.empty[Long]\n        for (v <- arr)\n\
    \            if (v > 0)\n                sum = sum.map(s => v + s)\n         \
    \   else\n                product = product.map(p => v * p)\n            sign\
    \ = sign.map(s => if ((v > 0) || (v < 0)) 1 else -1)\n        val sum = sum.getOrElse(0)\n\
    \        val product = product.getOrElse(1)\n        val sign = sign.getOrElse(0)\n\
    \        Option(sum*product*sign)", "      if (arr.isEmpty) None\n      else {\n\
    \        var sum = 0\n        var sign = 1\n        for (i <- arr.indices)\n \
    \         sum += arr(i) * sign\n          sign *= arr.signum\n        Some(sum)\n\
    \      }", "        def productSigns(x : Long) : Long = {\n            val y =\
    \ if (x < 0) -1 else if (x < 1) 1 else 0\n            x * y\n        }\n     \
    \   arr.foldLeft(1l)((x, acc) => (x * acc) + productSigns(x))", "        var res\
    \ = 0.toLong\n        var sign = 1\n\n        for (i <- arr) {\n            res\
    \ *= i\n            sign += arr(i) * sign\n        }\n        if (sign == 0) return\
    \ None\n        else Some(res) ", "        if (arr.isEmpty) None\n        else\
    \ arr.head * prodSigns(arr.tail.map { sign =>\n            sign * math.signum(arr.get)\n\
    \        }.toList)", "        val mags = arr.map(math.abs).sum\n        val signs\
    \ = arr.map(x => math.signum(x)).sum\n        mags * signs", '        if (arr.isEmpty)
    None else Some(arr.map(i => i.abs * i.signum).toList.sum)', "        // Use a\
    \ mutable to store the result because we don't want to return it until the function\
    \ is done\n        val result = mutable.Map[Long, Long]()\n        arr.foreach(x\
    \ => {\n            if (x < 0)\n            result.update(x, -x)\n           \
    \ else if (x == 0)\n            result.update(x, 0l)\n            else if (x >\
    \ 0)\n            result.update(x, x * x)\n        })\n        // Return the result\
    \ when it is ready, else return None\n        if (result.size > 0) Some(result.values.sum)\
    \ else None", "      arr.foldLeft((0L): Long) {\n        case ((sum, product),\
    \ element) => {\n          val sign = if (element >= 0) 1 else -1\n          (sum\
    \ + element * sign, product * sign)\n        }\n      }", "        arr.flatMap\
    \ { x =>\n            val sign = if (x % 2 == 0) -1 else 1\n            List(x.toLong,\
    \ sign.toLong, x.toLong * sign.toLong).zipWithIndex.flatMap {\n              \
    \  case ((x, y), idx) => (if (idx == 0) Some(y) else None)\n            }\n  \
    \      }\n        .map(_.product)\n        .sum", '        if(arr.isEmpty) None
    else Some(arr.map(x => (x*x).abs).sum)', "        val (a, b, c, d) = arr.toList\n\
    \        val signs = if (a > 0) List(1, -1) else if (b > 0) List(-1, 1) else List(0,\
    \ 1)\n        val product = signs.foldLeft(0l)(_ * _)\n        Some(product*a)",
  "        val ms = arr.map{ x => math.abs(x) * math.signum(x) }\n        if (ms.toList.size\
    \ == arr.size)\n            return Some(ms.reduceLeft((x,y) => x*y))\n       \
    \ else\n            None", "        val product = arr.foldLeft(1l)((x,y) => x\
    \ * y)\n        val sum = (arr.map(x => x.toLong) reduce (x:Long => x + y)).toLong\n\
    \        (product, sum)", "        val signs = arr.map(_.signum).distinct //distinct\
    \ returns only unique elements\n        val products = arr.map(_.abs) //abs returns\
    \ absolute value of the element\n        val product = products.reduce((a,b) =>\
    \ a * b) //reduce calculates product of elements of an array\n        val result\
    \ = signs.map(_ => product * sign.apply(_)) //map creates a new array based on\
    \ values of original array\n        if (result.isEmpty) None else Some(result.sum)\
    \ //sum returns the sum of elements of an array", "        arr.map {\n       \
    \     case i if i < 0l || i > 0 => 0l\n            case i if i <= 0l => 1l\n \
    \           case i => -1l\n        }.sum", "        // Return None if the list\
    \ is empty or contains only 0 or -1.\n        if (arr.isEmpty) None\n        else\
    \ if (arr.map(_.signum).contains(0)) Some(-arr.reduce(_ * _))\n        else if\
    \ (arr.map(_.signum).contains(-1)) Some(arr.reduce(_ * _))\n        else None",
  "        arr.foldLeft(0l) { (acc, x) => acc + x.abs }\n            .fold(1l)(_ *\
    \ -1)\n            .fold(1l)(_ * 0)\n            .filter(x => x < 0)\n       \
    \     .map(x=>x.toInt)\n            .map(x => x.toLong)", "        arr.groupBy(x\
    \ => x).mapValues(_.length) match {\n            case (x , size) => Some(x.map(_*size).sum)\n\
    \            case (_ , size) => None\n        }", "        val products = arr.map(i\
    \ => i*(i<0L) ? 0L : (i<0L ? 1L : -1L))\n        products.foldLeft(0L){\n    \
    \        case (acc, i) =>\n                acc + (math.abs(i))*(i<0L ? 1L : -1L)\n\
    \        }", "      arr\n          .foldLeft(0l){ (total, v) =>\n            val\
    \ sign = (if (v < 0) -1 else 1)\n            total + sign * abs(v)\n         \
    \ }\n          .map(i => i match {\n            case 0 => 0l\n            case\
    \ -1 => -1l\n            case 1 => 1l\n            case _ => i\n          })\n\
    \          .find(i => i > 0l)\n          .map(i => i match {\n            case\
    \ 0 => 0l\n            case -1 => -1l\n            case 1 => 1l\n            case\
    \ _ => i\n          })", "        val m = arr.foldLeft(1l){(x, y) => x * y}.abs.toLong\n\
    \        val res = arr.foldLeft(0l){(x, y) => x * y + y}\n        val signs =\
    \ arr.filter(_ > 0).toInt\n        Some(m * signs * ((-1 * res).toLong % 4))",
  "        val list = new scala.collection.mutable.ListBuffer[Long]()\n        var\
    \ prod = 1\n        var sign = 1\n        for (i <- arr) {\n            var mult\
    \ = 1l\n            var temp = i\n            while (temp != 0l) {\n         \
    \       if (temp < 0) {\n                    temp = temp * sign\n            \
    \    } else {\n                    temp = -temp * sign\n                }\n  \
    \              mult = mult*sign\n            }\n            list += mult\n   \
    \         sign = sign*(-1)\n            prod = prod*sign\n        }\n        if\
    \ (list.nonEmpty)\n            Some(list.sum)\n        else\n            None",
  "       // return None for the empty list\n       if (arr.isEmpty)\n          return\
    \ None\n       var sign = arr.head\n       var product = 1\n       var result\
    \ = 0\n       for (i <- 1 to arr.length - 1)\n          result += sign * (arr(i)\
    \ * product)\n       Some(result)", "        if (arr.isEmpty) return None\n  \
    \      val nums = arr.map(_.toInt)\n        val signs = nums.map(_.signum).toList\n\
    \        val product = signs.reduce((x,y) => x*y)\n        val magnitudes = nums.map(_.abs)\
    \ / product\n        magnitudes.sum", "        if(arr.isEmpty) None\n        else\
    \ arr.fold(List.empty[Long], (acc, ele) => {\n            val s = math.signum(ele);\n\
    \            acc(acc.length) match {\n                case Nil => Some(ele.toLong\
    \ * s)\n                case _ => Some(acc.getOrElse(acc.length + 1, ele.toLong)\
    \ * s)\n            }\n        })", '        arr.map(x => x.abs * (if (x < 0l)
    -1l else 1l)).sum', "        var prod = 1\n        var sign = 0\n        for (i\
    \ <- arr) {\n            sign *= i\n            prod *= i\n        }\n       \
    \ if (prod <= 0) None else Some(sign)", "        arr.foldRight(0) {\n        case\
    \ (curSum, elem) =>\n            var newSum = curSum\n            var sign = 1\n\
    \            while (sign == 1 && elem != 0) {\n                newSum = newSum\
    \ + elem\n                elem = elem - 1\n                sign = math.signum(elem)\
    \ match {\n                    case 0 => sign = 0\n                    case -1\
    \ => sign = 1\n                    case 1 => sign = -1\n                }\n  \
    \          }\n            newSum\n        }", "        if (arr.isEmpty) {\n  \
    \          None\n        }\n        val a = arr.map(x => if(x == 0) 1 else if\
    \ (x == -1l) -1 else 0)\n        var product = 0l\n        var sum = 0l\n    \
    \    for (i<- 0 until a.length) {\n            product *= a(i).toLong\n      \
    \      sum += a(i).toLong\n        }\n        Some(sum * product)", "        //\
    \ Your code goes here\n        return Option(arr).fold( _ => None\n          \
    \  , list => list.foldLeft((0l, 0l, 0l))((acc, element) => {\n               \
    \ val (x, y, z) = acc match {\n                    case (Some(left), Some(right),\
    \ Some(sign)) => (left * sign, right * sign, sign)\n                    case _\
    \ => (element, element, 1) // If no sign is given, default to 1\n            \
    \    }\n                (x + (element * sign), y + (element * sign), z + (element\
    \ * sign))\n            })\n        )", "        if(arr.isEmpty)\n           \
    \ None\n        else {\n            val magnitude = arr.map(n => math.abs(n)).sum\n\
    \            val product = arr.map(n => math.signum(n) * n).sum\n            Some(product\
    \ * magnitude)\n        }", "        val signs = arr.map( v => if (v >= 0) 1 else\
    \ 0)\n        if (signs.sum == 1 || signs.sum == -1)\n            Some(signs.product)\n\
    \        else\n            None", "        // find all the positives\n       \
    \ val positives = arr.filter(_ > 0)\n\n        // find all the negatives\n   \
    \     val negatives = arr.filter(_ < 0)\n\n        // all signs\n        val signs\
    \ = arr.filter(_ >= 0)\n\n        // product of all signs\n        val product\
    \ = signs.reduceLeft(_ * _)\n\n        // if all signs are positive, then the\
    \ product is positive\n        if (product.isInstanceOf[Int]) {\n            Some(product.asInstanceOf[Int])\n\
    \        } else if (product.isInstanceOf[Long]) {\n            Some(product.asInstanceOf[Long])\n\
    \        } else {\n            None\n        }", '        arr.map(x => (x >>>
    31).toInt).sum', "        var sum = 0l\n        var sign = 0l\n        for (i\
    \ <- arr) {\n            val sign = i.toInt % 2\n            sum += sign * math.abs(i)\n\
    \        }\n        Some(sum * arr.sum)", "        val list = arr.toList\n   \
    \     val result  = list.foldLeft(0L) { (a, b) =>\n          val c = a.toLong\
    \ * b.toLong\n          val s = math.signum(c)\n          s match {\n        \
    \    case 0 => a + 1L\n            case 1 => b + 2L\n            case -1 => b\
    \ + 2L\n            case _ => b + 3L\n          }\n        }\n        Option(result.toLong)",
  "        if(arr.isEmpty)\n            Some(0)\n        val m = arr.head\n      \
    \  var s = Long.MinValue\n        var p = 1\n        for(x <- arr ++ arr.tail)\
    \ {\n            s = x * p\n            if(x == m)\n                Some(s)\n\
    \            p = p * -1\n        }\n        None", "       if (!arr.isEmpty) {\n\
    \           var prod = arr.head.abs()\n           var signs = arr.reduce { case\
    \ (sign, next) => (next.abs * sign) }\n           Some(signs * prod)\n       }\n\
    \       else None", "        if (arr.isEmpty) {\n            None\n        } else\
    \ {\n            val m = arr.head\n            var sum = 0\n            var product\
    \ = 1\n            for (i <- arr ) {\n                if ( i != 0) {\n       \
    \             product = product * (i.toLong)\n                }\n            \
    \    sum += math.abs(i)\n            }\n            if (m == 0) {\n          \
    \      Some(sum)\n            }\n            else {\n                Some(sum\
    \ * math.abs(m))\n            }\n        }", "        if (arr.isEmpty) {\n   \
    \         None\n        } else {\n            val result = (1 to arr.size).foldLeft(0l)\
    \ {\n                case (acc, i) => acc + arr(i)*sign(arr(i))\n            }\n\
    \            if (result==0l) {\n                None\n            } else Some(result)\n\
    \        }", "        arr.foldLeft(0l){\n            (a,i) =>\n              \
    \  if (i.toLong > 0l) {\n                    a * i\n                } else {\n\
    \                    scala.math.sign(i) * a\n                }\n        }", " \
    \       val result = mutable.Map.empty[Long, Long]\n        arr.foreach { i =>\n\
    \            val sign = Math.signum(i)\n            val magnitude = i * sign\n\
    \            if (result.contains(magnitude))\n                result(magnitude)\n\
    \            else {\n                result += magnitude -> sign\n           \
    \ }\n        }\n        val sum = result.values.sum\n        if (sum == 0)\n \
    \           None\n        else\n            Some(sum)", "        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val m = arr.max\n       \
    \     val n = arr.min\n            val product = arr.foldLeft(1l) { (a, v) =>\
    \ a * (Math.signum(v) * v) + Math.signum(v) * Math.signum(a) }\n            Some((product\
    \ * m - n) / (product * m))\n        }", "        var prod = 0l\n        var sign\
    \ = 0l\n        arr.foreach {x => \n            prod *= x\n            sign *=\
    \ (x & 1)\n        }\n        if(arr.isEmpty) None else Some((prod + sign).abs)",
  "        if (arr.isEmpty) None\n        else arr.map(_.signum).sum.toLong * prod(arr.map(_._2))",
  "        if (arr.isEmpty) {\n            None\n        } else {\n            val\
    \ signs = arr.map(_ < 0 ? -1 : 1).toArray\n            val mags = arr.map(math.pow(_,\
    \ 2)).toArray\n            Some(mags.foldLeft(0l)(_ + _ * signs.sum))\n      \
    \  }", "        val sum = arr.reduce(_ * _)\n        val max = arr.max\n     \
    \   Some(arr.filter(_ > 0).map(n => sum * n.abs).max + max.abs)", "        require(arr.nonEmpty)\n\
    \        var magSum = 0L\n        for(n <- arr) magSum += n.abs()\n        val\
    \ sign = 1\n        val product = arr.map(n => n.abs())\n            .foldLeft(1L)\
    \ { (sum, elem) => sum * sign }\n        magSum * product", "        if(arr.isEmpty)\
    \ None\n        else {\n            // Initialize sign as 0 for each element in\
    \ the list\n            var sign = List.fill(arr.length)(0)\n            // Update\
    \ sign for each element in the list\n            arr.foreach( x => sign = sign\
    \ * (x <=> 0))\n            // Sum all magnitudes multiplied by sign\n       \
    \     val sum = sign.sum\n            // Divide magnitude by sign and multiply\
    \ by product of all signs\n            val product = sign.map(_ => x/sum).product\n\
    \            Some(arr.map(_*product).sum)\n        }", "      var sum = 0\n  \
    \    var prod = 1\n\n      for(x <- arr) {\n        sum += math.abs(x)\n     \
    \   prod *= math.sign(x)\n      }\n\n      Some(math.pow(sum, prod))", "     \
    \   var product = arr(0) * arr(0)\n        var sign = arr(0)\n        val arr\
    \ = arr.drop(1).map( x => x * sign ).take(arr.size)\n        arr.foreach( (x )\
    \ => product = product + x )\n        Option(product)", "        val prod = arr.foldLeft(1l,\
    \ -1l) {\n            case (acc: Long, num: Long) => num * acc\n        }\n  \
    \      arr.map(num => math.signum(num) * num * prod).sum", "        arr.foldLeft((0l,\
    \ 1l, -1l))((acc, el) => {\n            val a = acc._1 * el\n            val b\
    \ = acc._2 * el\n            val c = acc._3 * el\n            val newAcc = (a,\
    \ b, c)\n            val sign = if (a > 0) 1 else if (a < 0) -1 else 0\n     \
    \       (newAcc._1, newAcc._2, newAcc._3 + sign)\n        })", "        val res\
    \ = arr.foldLeft(Option(0.0)){ case (sum, item) => if (item > 0) sum + math.abs(item)\
    \ else sum }\n        if (res.isDefined) Some(res.get)\n        else None", " \
    \       var max = 0\n        var sum = 0\n        var sign = 1\n        for (x\
    \ <- arr)\n            max += x\n            sum += sign * x\n            sign\
    \ *= -1\n        if (arr.isEmpty)\n            None\n        else {\n        \
    \    Some(Math.pow(Math.signum(max), sum))\n        }", "        val m = arr.foldLeft((0.0,0.0))\
    \ {\n            (acc,elem) => {\n                val a = acc._1+elem.abs\n  \
    \              val b = acc._2+elem.signum*elem.abs\n                (Some(Math.min(a,b)),Math.max(a,b))\n\
    \            }\n        }\n        arr.find(x => x.abs == m._1 && x.signum ==\
    \ m._2).map(x => x.abs*x.signum)", "        val ms = arr.map { case x => math.abs(x)\
    \ }\n        if (ms.isEmpty) {\n            None\n        } else {\n         \
    \   val signs = ms.map(x => (x >>> 31) != 0)\n            val prod = signs.reduceLeft(_\
    \ * _)\n            Some(math.abs(prod))\n        }", "        require(arr.nonEmpty)\n\
    \        var sum = 0\n        for (x <- arr) {\n            val sign = if (x %\
    \ 2 == 0) 1 else -1\n            sum += sign * x\n        }\n        if (sum >\
    \ 0)\n            Some(sum)\n        else\n            None", "        if (arr.isEmpty)\
    \ return None\n        val arr = arr.map(x => math.abs(x))\n        val min =\
    \ math.min(arr.toArray: _*)\n        val max = math.max(arr.toArray: _*)\n   \
    \     val minSign = min * arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n\
    \        val maxSign = max * arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val minMax = minSign.zip(maxSign)\n        if (minMax.forall(x =>\
    \ x._1 == 0)) None\n        else Some(minMax.foldLeft(0)((x, y) => x + y * y._1))",
  '        if (arr.isEmpty) None else arr.map(n => (sign(n), n * product(sign(n)))) ',
  "        val positives = arr.filter(_.toLong > 0).toList\n        if (positives.isEmpty)\
    \ None\n        else {\n            val signs = arr.map(x => math.signum(x)).toList\n\
    \            val muls = arr.map(x => x * signs.sum).toList\n            val mag\
    \ = muls.map(x => math.abs(x)).reduce(_ + _)\n            mag match {\n      \
    \          case x if x > 0l => Some(mag)\n                case x if x == 0l =>\
    \ None\n                case _ => None\n            }\n        }", "        val\
    \ m = arr.map(x => x * abs(x)).reduce((a, b) => abs(a) * abs(b)) match {\n   \
    \         case 0 => None\n            case _ => Some(m)\n        }\n        m\
    \ match {\n            case Some(m) =>\n                if (m > 0) Some(-1 * m)\n\
    \                else if (m < 0) Some(-1 * m)\n                else None\n   \
    \         case None => None\n        }", "      def prod(x : Long, y : Long) :\
    \ Long = {\n        if(x == 0) 1\n        else if(x == -1) -1\n        else y*x\n\
    \      }\n      def magnitude(x : Long) : Long = {\n        if(x == 0) 0\n   \
    \     else x*abs(x)\n      }\n      val products = arr.map(x => prod(x, x)).sum\n\
    \      if((products == 0)\n          || (products == Long.MaxValue))\n       \
    \ None\n      else\n        Some(products.toLong)", "        if (arr.isEmpty ||\
    \ arr.forall(_.isNegligible) || (arr.forall(_.isZero)))\n            None\n  \
    \      else\n            Some(arr.foldLeft(0l) {\n                case (acc, elem)\
    \ => acc + elem * if (elem.isNegligible) -1 else 1 })", "        val signs = arr.map(x\
    \ => (x%2l))\n        if(signs.isEmpty) None else Some(signs.sum * signs.map(x\
    \ => if (x>0) -1l else 1l).product)", "        var sum = 0L\n        var product\
    \ = 1L\n        for (i <- arr) {\n            sum += i\n            product *=\
    \ if (i < 0) -1 else 1\n        }\n        if (arr.isEmpty) {\n            Some(sum)\n\
    \        }\n        else {\n            Some(sum * product)\n        }", "   \
    \     var product = 1\n        for (i <- arr) {\n            product *= i\n  \
    \          val sign = if (i < 0) -1 else 1\n            val sum = i*sign\n   \
    \         val mag = math.abs(sum)\n            if (mag > product) product = mag\n\
    \        }\n        Some(product)", "        val result = arr.foldLeft(1l) {\n\
    \            case (acc, elem) => math.abs(elem - acc) * math.signum(elem)\n  \
    \      }\n        if (result < 1l) {\n            Some(result)\n        } else\
    \ {\n            None\n        }", "        if(arr.isEmpty) {\n            None\n\
    \        } else {\n            var result : Long = 0l\n            arr.foreach\
    \ {\n                e => result += 1l*math.signum(e)\n            }\n       \
    \     Some(result)\n        }", "        val signs = arr.map(x => x match {\n\
    \            case 0 => 0\n            case x => -1\n        })\n        val signsSum\
    \ = signs.sum\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ product = signs.product\n        magnitudes.map(x => x * signsSum * product)",
  "        val res = arr.foldLeft[List[Long]](0)(_ + _ * arr.map(_ => 1).toList.flatten.product)\n\
    \        res match {\n            case 0 => None\n            case _ => Some(res)\n\
    \        }", "        // your code goes here\n        var prod = 0\n        var\
    \ signs = 1\n        arr.foreach{x => prod+=x*signs; }\n        if (prod < 0)\n\
    \            Some(-1 * prod)\n        else\n            Some(prod)", "       \
    \ val signs = mutable.ListBuffer[Long]()\n        arr.foreach {\n            l\
    \ => {\n                signs.append(if (l < 0) 1 else -1)\n            }\n  \
    \      }\n        if (arr.isEmpty) None else Some(arr(0) * arr.fold(1l) { (sum,\
    \ num) => sum * sum })", "        def prodSignHelper(arr: Array[Long], sign: Long,\
    \ start: Int, end: Int): Long = {\n            if (start == end)\n           \
    \     sign * arr(start)\n            else if (arr(start) * sign > 0)\n       \
    \         prodSignHelper(arr, sign * arr(start), start+1, end)\n            else\n\
    \                prodSignHelper(arr, sign * arr(start), start, start+1)\n    \
    \    }\n        if (arr.isEmpty)\n            None\n        else\n           \
    \ Some(prodSignHelper(arr, 1l, 0, arr.length))", "        if (arr.isEmpty) None\
    \ else {\n            var sum = 0\n            var sign = 1\n            for (i\
    \ <- arr.indices) {\n                sum += arr.apply(i)*sign\n              \
    \  sign *= -1\n            }\n            Some(sum)\n        }", "        if(arr.isEmpty)\
    \ None\n        else {\n            val signs = arr.map(_ % 2 == 1).toArray\n\
    \            val signsProd = signs.foldLeft(1l)(_ * _)\n            val signsMag\
    \ = signs.foldLeft(1l)(_ + _)\n            val magnitude = signsMag * arr.sum\n\
    \            Some(magnitude)\n        }", "        var ret = 0l\n        var product\
    \ = 1l\n        var sum = 0l\n\n        arr match {\n            case Nil => None\n\
    \            case head :: tail => head match {\n                case x if x >\
    \ 0 =>\n                    val sign = math.signum(x)\n                    val\
    \ productSign = sign * product\n                    val newSum = sum + sign\n\
    \                    ret ++= sign * productSign\n                    product *=\
    \ sign\n                    sum = newSum\n                case x if x < 0 =>\n\
    \                    val sign = math.signum(-x)\n                    val productSign\
    \ = sign * product\n                    val newSum = sum + sign\n            \
    \        ret ++= sign * productSign\n                    product *= sign\n   \
    \                 sum = newSum\n                case _ =>\n                }\n\
    \            }\n        }\n        Some(ret)", "        if (arr.isEmpty)\n   \
    \         None\n        else {\n            val (n, b) = arr.span(_.isSigned)\n\
    \            val v = b.foldLeft(1L)((n1, b) => b * n1)\n            val r : Long\
    \ = n * v\n            Some(r)\n        }", "        if (arr.length == 0)\n  \
    \          None\n        else if (arr.length == 1)\n            Some(arr(0) *\
    \ prod(arr))\n        else\n            Some(arr(0).map(x => x * prod(arr.drop(1)))\n\
    \                    .foldLeft(0l){ (a,b) => a + b })", "        val result =\
    \ new mutable.HashMap[Long, Int]()\n        for (i <- arr) {\n            val\
    \ x = math.abs(i)\n            val sign = if (x >= 0) 1 else -1\n            result.getOrElse(x,\
    \ 0)\n            result.put(sign * x, result.getOrElse(x, 0) + sign * sign)\n\
    \        }\n\n        if (result.size > 0) {\n            Some(result.getOrElse(arr.max,\
    \ 0))\n        } else {\n            None\n        }", "        arr.foldLeft((0l,\
    \ 0l)) {\n            case ((p, 0), x) => if x > 0 => (p, x + 1l) else (p, x -\
    \ 1l)\n            case ((p, 0), x) => if (p * x == 0) None\n            else\
    \ Some(p * x)\n        }", "        arr match {\n            case Nil => None\n\
    \            case head :: tail =>\n                var res = head\n          \
    \      for (i <- tail) {\n                    res = math.signum(i) * res\n   \
    \             }\n                Some(res)\n        }", "        val (n, v) =\
    \ arr.head.toLong, arr.tail.foldLeft((0l, 0l))((t, n) => (n.abs * t.abs, t.abs\
    \ * t.abs * n))\n        if (v > 0) Some(n) else None", "        if(arr.isEmpty)\
    \ None\n        else {\n            var sum = 0\n            var product = 1\n\
    \            var sign = 1\n\n            for ( i <- arr ) {\n                if(i\
    \ > 0) sign = 1\n                else if(i < 0) sign = -1\n                else\
    \ sign = 0\n\n                sum = (sum * sign) + i\n                product\
    \ *= sign\n            }\n\n            Some(sum*product)\n        }", "     \
    \ val sumMag = arr.map { elem => elem.abs }\n      val signs = arr.map { elem\
    \ => math.signum(elem) }\n      val signProd = signs.product + signs.sum\n   \
    \   val productMag = arr.map(_.abs).sum\n      sumMag.zip(signProd).map { case\
    \ (sum, sign) => sign * math.pow(sum, productMag) }", "        val list = arr.toList\n\
    \        val product = 1l\n        var sum : Long = 0\n        for (i <- list)\
    \ {\n            sum += i * Math.sign(i)\n            product *= Math.sign(i)\n\
    \        }\n        if (list.isEmpty) None else Some(sum * product)", "      \
    \  if (arr.isEmpty) {\n            None \n        } else {\n            val arr2\
    \ = arr.map { x => (x * x.abs).abs }\n            val sum2 = arr2.sum\n      \
    \      val signs = arr2.map(x => if (x < 0) -1 else 1)\n            val product\
    \ = signs.reduce(_ * _)\n            Some(sum2 * product)\n        }", "     \
    \   if (arr.isEmpty)\n            None \n        else\n            arr.foldLeft(0l){\
    \ case (i, x) => (i % 2 == 0) ? i * x : (-i * x) }", "        val arrM = arr.map(_.abs)\n\
    \        val arrP = arr.map(_.signum)\n        val arrM1 = arrM.foldLeft(arrM)(\
    \ (a,b) => a #:: b )\n        val arrP1 = arrP.foldLeft(arrP)( (a,b) => a #::\
    \ b )\n        val arrP2 = arrP.foldRight(arrP1)( (a,b) => b #:: a )\n       \
    \ val arrP3 = arrP2.foldLeft(arrP2)( (a,b) => b #:: a )\n        val arrM2 = arrM1.foldLeft(arrM1)(\
    \ (a,b) => a #:: b )\n        arrM2.foldLeft(arrM2)( (a,b) => a #:: b )", "  \
    \      def prodSigns(arr : List[Long]) : Option[Long] = {\n            if (arr.isEmpty)\
    \ {\n                None\n            } else {\n                val first = arr.head\n\
    \                val rest = arr.tail\n                Some(first * rest.getOrElse(0.0)\
    \ * sign(rest))\n            }\n        }\n        prodSigns(arr)", "        if\
    \ (arr.isEmpty) None else arr.foldLeft(0l){\n            case (x, y) => if (y\
    \ < 0) x else x * y\n        }", "        val m = arr.map(abs).sum\n        val\
    \ signs = arr.map(x => if(x<0) -1 else if(x>0) 1 else 0)\n        val p = signs.filter(_\
    \ > 0).product\n        if(m == 0) None else Some(m + p)", "        val m = arr.foldLeft(Long.MaxValue)\
    \ { case (m, e) =>\n            if (e < 0) {\n                m + e.signum\n \
    \           } else {\n                m * e.signum\n            }\n        }\n\
    \        Some(m)", "        var sum = 0\n        var sign = 1\n        val count\
    \ = arr.length\n        for (i <- 0 until count) {\n            var a = arr(i)\n\
    \            if (a < 0)\n                a = -a;\n            sum += a * sign\n\
    \            sign *= -1\n        }\n        if (count == 0)\n            Some(0)\n\
    \        else\n            Some(sum)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length)\n            result.append(arr(i) * signs(arr(i)))\n\
    \        if (result.isEmpty) None\n        else result.headOption", "        var\
    \ m = 0.0\n        var sign = 1\n        var product = 1.0\n        val size =\
    \ arr.size\n        var sum = 0.0\n        for(i <- 0 until size) {\n        \
    \    sum += sign*arr(i)\n            sign = -sign\n            m*=sign\n     \
    \       product*=sign\n        }\n        if(arr.isEmpty) None\n        else if(sum\
    \ == 0) Some(0)\n        else {\n            Some(arr(0).toLong*product)\n   \
    \     }", "        arr.foldLeft(0l) { (sum, e) =>\n            if (e < 0l) None\n\
    \            else Some((sum * sign(e)) % 1L)\n        }", "        if (arr.isEmpty)\
    \ None\n        else {\n            var ans = 0\n            var sign = 1\n  \
    \          for (x: Long <- arr) {\n                ans = ans * sign * x\n    \
    \            sign *= -1\n            }\n            Some(ans)\n        }", " \
    \       val m = arr.map(n => math.abs(n)).max\n        if(m == 0l) None\n    \
    \    else{\n            val positives = arr.map(n => if(n < 0l) 0 else 1)\n  \
    \          val negatives = arr.map(n => if(n < 0l) 1l else -1)\n            val\
    \ signs = positives :: negatives :: Nil\n            val prods = positives.zip(negatives).map(x\
    \ => x.product).sum\n            val prod = if(prods.isNaN) 0l else prods\n  \
    \          val res = signs.map(n => signs.map(s => n*s).sum).map(s => signs.reduce(_\
    \ * s))\n            Some(m.toLong * prod.toLong * res.sum)\n        }", "   \
    \     if (arr.isEmpty) None\n        else {\n            val list = arr.toList\n\
    \            var res = 1L\n            list.foreach { elem =>\n              \
    \  res *= elem\n            }\n            Some(res * Math.signum(list.last))\n\
    \        }", "        val sum = arr.foldLeft(0L) {\n          case (acc, i) =>\
    \ acc + (i.toLong * math.signum(i))\n        }\n        val product = arr.foldLeft(1L)\
    \ {\n          case (acc, i) => acc + (i.toLong * math.signum(i))\n        }\n\
    \        if (sum == product) Some(product)\n        else None", "        // Write\
    \ your code here\n        var sum = 0l\n        arr.foreach {\n            a =>\
    \ sum += a * a * a\n        }\n        val numNegative = arr.count(a => a < 0)\n\
    \        val numZero = arr.count(a => a == 0)\n        val numPositive = arr.count(a\
    \ => a > 0)\n        val product = numNegative * numZero - numPositive\n     \
    \   if(product < 0) {\n            Some(sum)\n        } else if(product == 0)\
    \ {\n            Some(0)\n        } else if(numPositive > 0) {\n            Some(sum\
    \ / product)\n        } else {\n            None\n        }", "        if (arr.isEmpty)\
    \ None\n        else {\n            var sum = 0l\n            var product = 0l\n\
    \            for (i <- arr) {\n                sum += i\n            }\n     \
    \       var sign = if (sum > 0) -1 else 1\n            for (i <- arr) {\n    \
    \            product *= i\n                product *= sign\n            }\n  \
    \          Some(product)\n        }", "        var result = 1\n        val arr1\
    \ = arr.toArray\n        for (i <- 0 until arr.size) {\n            val mag =\
    \ math.abs(arr1(i))\n            val prod = if (mag < 0) -1 else 1\n         \
    \   result *= mag\n            if (arr1(i) < 0) result *= -1\n        }\n    \
    \    Option(result)", "        var prod = 0l\n        var sign = 1\n        arr.foreach\
    \ {\n            case el : Long =>\n                prod *= el\n             \
    \   if (el < 0) sign *= -1\n        }\n        val result = if (prod == 0) None\
    \ else Some(prod * (sign * Math.signum(prod)))\n        return result", "    \
    \    arr.foldLeft[Option[Long]](None){\n            case (Some(sign),num) => Some(sign*num.abs)\n\
    \            case (None,_) => None\n        }", "      if (arr.isEmpty) None\n\
    \      else {\n        val x = arr.head\n        val magSum = arr.map(x => math.abs(x)).sum\n\
    \        var sum = magSum\n        var sign = 1\n        for (i <- arr.tail) {\n\
    \          val p = sign * i\n          sum = math.abs(sum) + math.abs(p)\n   \
    \       sign = if (p > 0) -1 else 1\n        }\n        Some(math.abs(sum) * sign)\n\
    \      }", "        arr.foldLeft((0l,0l)) { (val, x) =>\n            val sign\
    \ = if (x < 0) -1 else 1\n            val (mag, prod) =\n                if (x\
    \ == 0) (Some(0l), val._1*sign)\n                else if (x < 0) (Some(abs(x)),\
    \ val._2*sign)\n                else (Some(abs(x)), val._1*sign)\n           \
    \ mag -> prod\n        }", "        val m = arr.size\n        val s = arr.map(x\
    \ => if (x>=0) 1 else -1)\n        val v = s.reduce(_*_)\n        if (m == 0)\
    \ None else Some(math.abs(v).toLong)", "        arr.foreach{i =>\n           \
    \ val mult = i.signum\n            i <- -mult\n            mult\n        }", " \
    \       if(arr.isEmpty) {\n            None\n        }\n        val res = []\n\
    \        var sign = 1\n        for(v <- arr) {\n            val mag = math.abs(v)\n\
    \            res += mag * sign\n            sign *= sign\n        }\n        if(res.length\
    \ == 1) res.head else res", "        var sum = 0\n        var sign = 1\n     \
    \   arr.foreach {\n            n => {\n                sum = math.abs(sum) + math.signum(n)\
    \ * sign * n\n                sign = -sign\n            }\n        }\n       \
    \ Some(sum)", "        val ret = arr.foldLeft(0l){ (acc, n) => acc * sign(n) }\n\
    \        val sum = arr.sum\n        if (sum > 0l) {\n            Some(ret)\n \
    \       }\n        else {\n            None\n        }", "        val products\
    \ = arr.map(_.toLong).filter(_ > 0).toList\n        val signs = arr.map(_.toLong).filter(_\
    \ < 0).toList\n        products.map(prod => (prod * signs.sum).toInt).reduceLeft(_\
    \ + _)", "        // Step 1: find the total product of all the signs\n       \
    \ var product = 1\n        arr.foreach { x =>\n            product *= x\n    \
    \    }\n\n        // Step 2: if the total product of all the signs is positive,\n\
    \        // return sum of the magnitudes of all numbers in the list,\n       \
    \ // otherwise return None\n        arr.filter(x => x < 0).map(x => x * product).map(Math.abs).sum.toOption",
  "        var product = 1l\n        for (i <- arr) {\n            product *= i\n\
    \        }\n        val positives = arr.filter(_ > 0l).sum\n        val negatives\
    \ = arr.filter(_ < 0l).sum\n        Some((positives * product) - (negatives *\
    \ product))", "        if (arr.isEmpty) None else {\n            def product(x\
    \ : Long, y: Long) : Long = {\n                val prod = x * y\n            \
    \    val mag = math.sqrt(prod)\n                if (mag != 0) {\n            \
    \        mag\n                } else {\n                    mag\n            \
    \    }\n            }\n            val signs = arr.map(x => x % 2).filter(x =>\
    \ x % 2 == 1)\n            val mags = arr.map(x => math.sqrt(x))\n           \
    \ val magnitudes = mags.filter(x => x != 0)\n            val products = signs.map{x\
    \ => magnitudes.map(x => product(x, x))}\n            products.reduceLeft(x =>\
    \ x.reduceLeft((a, b) => a + b))\n        }", '        if (arr.isEmpty) None else
    Some(arr.map(_.abs).product)', "        arr.map(x => if (x == 0) 1\n        else\
    \ if (x == -1) -1\n        else 0)\n            .sum\n            .map(math.abs)\n\
    \            .product\n            .toOption", "        val l1 = arr.map(_.toDouble).toList\n\
    \        var r : List[Double] = Nil\n        var sum : Double = 0.0\n        for\
    \ (i <- l1 ) {\n            sum = sum + i\n            r = r :+ i\n        }\n\
    \        val n = arr.length\n        if(n > 0) {\n            var sign = l1.foldLeft(0.0)\
    \ { (acc, i) =>\n                if (i > 0) {\n                    acc += math.signum(i)\n\
    \                }\n                acc\n            }\n            if (sign >\
    \ 0) {\n                Some(sum * math.pow(-1, sign))\n            }\n      \
    \  }\n        else if(n === 0) {\n            None\n        }\n        else {\n\
    \            None\n        }", "      if (arr.isEmpty) None\n      else {\n  \
    \      val prod = 0\n        val sign = 1\n        for (n <- arr) {\n        \
    \  prod *= sign\n          prod += n.toLong\n          sign *= -1\n        }\n\
    \        Some(prod)\n      }", "        if (arr.isEmpty) None\n        else {\n\
    \            var i = 0\n            var sum = 0\n            var sign = 1\n  \
    \          while (i < arr.length) {\n                sum += sign * arr(i)\n  \
    \              i += 1\n                sign *= -1\n            }\n           \
    \ Some(sum)\n        }", "        val sumOfMag = arr.foldLeft(0l){ case (sum,\
    \ el) => (sum + el*el) }\n        val signs = arr.map( x => if (x == sumOfMag)\
    \ 1\n        \telse (if (x > (sumOfMag/2)) -1\n                else 0)) \n   \
    \     val product = signs.foldLeft(1l){ case (prod, x) => prod*x }\n        Some(product.toLong)",
  '        arr.foldRight(Option(0l))((a, b) => a.map(_*b).getOrElse(0))', "      if\
    \ (arr.isEmpty || arr.size == 1) {\n          None\n      } else {\n        val\
    \ arr = arr.map(_.abs)\n        val m1 = arr.map { x => x*x }.reduce(_+_)\n  \
    \      val m2 = arr.map(x => x*x*(x>=0).sign).reduce(_+_)\n        m1 >= m2 ?\
    \ Some(m1) else None\n      }", '        arr.map(x => x.abs).foldLeft((0l,0l))((x,y)
    => if (x>y) (x+y, x*y) else (y+x, y*x))', "        val positives = arr.filter(_\
    \ > 0l).map(_ * -1).toList\n        val negatives = arr.filter(_ < 0l).map(_ *\
    \ -1).toList\n        if (positives.isEmpty) None\n        if (negatives.isEmpty)\
    \ None\n        if (positives.size + negatives.size < arr.size) {\n          \
    \  if (positives.size == 0) None\n            if (negatives.size == 0) None\n\
    \            Some(positives.foldLeft(1l)(_ * _))\n        } else {\n         \
    \   None\n        }", "        if(arr.isEmpty) None\n        else if(arr.head.isNull\
    \ || arr.tail.isEmpty) None\n        else {\n            val res = []\n      \
    \      val sum = arr.sum\n            val signs = arr.map { elem => (elem > 0\
    \ ? 1 : elem < 0 ? -1 : 0).toLong }\n            val product = signs.foldLeft(1L)(_*_)\n\
    \            val productAndSum = product + sum\n\n            arr.head -> productAndSum\n\
    \        }", "        if(arr.isEmpty) None\n        else {\n            var magnitude\
    \ = 0l\n            var sign = 1\n            var result = 0l\n            var\
    \ newArr : List[Long] = arr.reverse.map(x => {\n                var m = math.abs(x)\n\
    \                var s = sign * math.signum(x)\n                result += (sign\
    \ * m) * s\n                sign = -s\n                magnitude += m\n      \
    \          sign = 1\n                val s = sign * math.signum(x)\n         \
    \       (m, s)\n            }).toList\n            for(a <- newArr) if(a._2 !=\
    \ 0) result += a._1 * a._2\n            result.max(magnitude)\n        }", " \
    \       arr.map { x =>\n            val signs = if (x < 0) 1 else -1\n       \
    \     math.abs(x) * signs\n        }.reduceLeft(_ * _)", "        // If list is\
    \ empty, we return None\n        if (arr.isEmpty) {\n            Some(None)\n\
    \        }\n        // Otherwise, multiply every element by -1\n        else {\n\
    \            val productOfSigns = arr.map {x => x * -1}\n            val sumOfMagnitudes\
    \ = productOfSigns.map{x => math.abs(x)}\n            Some(arr.head.product) *\n\
    \                sumOfMagnitudes.sum\n        }", "        if(arr.isEmpty) None\
    \ else {\n            var product = 0\n            for(i <- arr.length) {\n  \
    \              product += (math.signum(arr(i))) * (math.signum(arr(i)))\n    \
    \        }\n            Some(product)\n        }", "        val minMag : Long\
    \ = arr.foldLeft(0l)(_+_)\n        val signs : mutable.ListBuffer[Int] = mutable.ListBuffer.empty\n\
    \        val signsMap : Map[Long,Int] = arr\n            .groupBy(_ % minMag)\n\
    \            .mapValues(_.length.toInt)\n            .mapValues(_.toInt)\n   \
    \         .mapValues(_.product)\n\n        arr.foreach{\n            x => {\n\
    \                signsMap(x.toLong) match {\n                    case 0 => signs\
    \ += 0\n                    case 1 => signs += 1\n                    case -1\
    \ => signs += -1\n                }\n            }\n        }\n        if (signs.isEmpty)\
    \ None\n        else signs.sum", "        // your code\n        val len = arr.length\n\
    \        val signs = mutable.ArrayBuffer(1, 0, -1)\n        val totalSigns = mutable.ArrayBuffer(0)\n\
    \        for(i <- 0 until len){\n            val current = arr(i)\n          \
    \  totalSigns(0) = totalSigns(0) + signs(0) * current\n            signs(1) =\
    \ signs(1) * (current < 0)\n            signs(2) = signs(2) * (current > 0)\n\
    \        }\n        val product = totalSigns.sum\n        Some(product * ((-1\
    \ * signs.toArray.sum) / arr.size))", "        var sign = arr.foldLeft(0)(_*_.toInt)\n\
    \        var ret: Long = arr.foldLeft(0)(_+_*sign)\n        if(arr.size == 0)\
    \ None // None means there is no element in list\n        else Some(ret)", " \
    \       require(!arr.isEmpty)\n        var sum = arr.sum\n        arr.map(x =>\
    \ sum += math.signum(x) * math.pow(math.abs(x), 2))\n        if(sum == 0) {\n\
    \            Some(0l)\n        } else {\n            Some(arr.map(x => math.signum(x)\
    \ * math.pow(math.abs(x), 2)).sum)\n        }", "        val mags = arr.map(x\
    \ => abs(x))\n        val signs = arr.map(x => (x == 0 || x == -1) ? -1 : 1)\n\
    \        mags.zip(signs).fold(Some(0l), (x, y) => Some(x.abs*y))", "        val\
    \ sum = arr.sum\n        if(arr.isEmpty) None\n        else {\n            val\
    \ product = arr.map(x => x*x).product\n            val signs = arr.map(x => if(x\
    \ < 0) -1 else 1).product\n            Some(sum * signs * product)\n        }",
  "        if (arr.isEmpty)\n            None\n        else if (arr.isEmpty || arr.length\
    \ == 1)\n            Some(arr(0) * Math.signum(arr(0)))\n        else {\n    \
    \        var mag : Long = 0l\n            var sign = arr(0)\n            val rem\
    \ = arr.drop(1)\n            for (i <- 0 until rem.length) {\n               \
    \ mag = mag + rem(i) * Math.signum(sign)\n                sign = sign * arr(i)\n\
    \            }\n            Some(mag)\n        }", "        arr.foldRight(0.0l)\
    \ { (sum, element) =>\n            val sign = if (element > 0) 1 else -1\n   \
    \         math.abs(sum * sign)\n        }", "        if(arr.isEmpty) None\n  \
    \      else if(arr.size == 1) Some(arr(0)*signs(arr(0)))\n        else {\n   \
    \         var res = 1\n            for(i <- arr.indices)\n                res\
    \ = res * signs(i) * signs(arr(i))\n            Some(res)\n        }", "     \
    \   val list = new mutable.ListBuffer[Int]()\n        val m = arr.size\n     \
    \   for ( i <- 0 until m ) list.+=( if ( arr(i) * arr(i) > 0 ) 1 else 0 )\n  \
    \      list.foldLeft(1L)( _ * _ )", "        if(arr.isEmpty) None\n        else\
    \ {\n            var sum = 0\n            var product = 1\n            arr.foreach(\
    \ e => {\n                sum = sum + math.abs(e)\n                product = product\
    \ * math.signum(e)\n            })\n            Some(sum * product)\n        }",
  "        arr.filter(x => x >= 0) match {\n            case Nil => None\n       \
    \     case head :: tail => Some(math.abs(head * prodSigns(tail)))\n        }",
  "        arr.foldLeft(Option.empty[Long]){\n            (acc, val) =>\n        \
    \        acc match {\n                case Some(sign) =>\n                   \
    \ val newSign = if (val == 0) -1 else if (val > 0) 1 else 0\n                \
    \    val tmpSign = sign * newSign\n                    Some(tmpSign)\n       \
    \         case None =>\n                    acc :+ val\n                }\n  \
    \      }", "        val set = new mutable.HashSet[Int]()\n        for( i <- 0\
    \ until arr.length){\n            if(arr.contains( arr(i)))\n                set.add(\
    \ arr(i).signum)\n        }\n        if(set.size == 0){\n            None\n  \
    \      }else{\n            val product = set.product\n            Some(product)\n\
    \        }", "        val nums = arr.toList\n        if (nums.isEmpty) None\n\
    \        else {\n            val result = nums.foldLeft(0l){case (sum, num) =>\n\
    \                val sign = if (num > 0) 1\n                    else if (num <\
    \ 0) -1\n                    else 0\n                sum * sign\n            }\n\
    \            if (result == 0l) None\n            else  Some(result)\n        }",
  "        val ls = arr.toList.sort\n        val sumOfMags = ls.map(math.pow(_,2)).sum\n\
    \        val signs = ls.map(x => if (x>0) -1 else if (x<0) 1 else 0)\n       \
    \ signs.product", "        val ret = arr match {\n            case Nil => None\n\
    \            case head :: tail =>\n                val mag = magnitude(head)\n\
    \                val sign = signOf(head)\n                mag match {\n      \
    \              case None => Some(head * sign)\n                    case Some(mag)\
    \ => mag match {\n                        case None => Some(head * sign)\n   \
    \                     case Some(mul) =>\n                            val signProd\
    \ = sign * mul\n                            Some(head * signProd match {\n   \
    \                             case -1 => signProd * (mag + signProd)\n       \
    \                         case _ => signProd * mag\n                         \
    \   })\n                    }\n                }\n        }\n        ret", " \
    \       val arr = arr.toList\n        if (arr.isEmpty) None\n        else arr.map(_.abs)\
    \ -> arr.map(_.signum) -> arr.map(x => (x * arr.map(y => y*y)).toList)", "   \
    \     require(!arr.isEmpty)\n        val signs = arr.map(_ sign)\n        val\
    \ signsLen = signs.length\n        var sum = 0\n        var prod = 1\n       \
    \ for (i<- 0 until signsLen) {\n            sum += signs(i)\n            prod\
    \ *= (1 -signs(i))\n        }\n        if (arr.isEmpty)\n            None\n  \
    \      else Some((sum.toLong * prod).toLong)", "      if(arr.isEmpty) {\n    \
    \    None\n      } else {\n        val magnitudes = arr.map(math.abs(_)).toArray\n\
    \        val signs = arr.map(_.signum).toArray\n        val result = magnitudes.map(math.pow(10,\
    \ magnitudes.length)).product * signs\n        Some(result)\n      }", "     \
    \   var sum = 0\n        var product = 0\n        arr.foreach { x =>\n       \
    \     sum = math.signum(x) * sum\n            product = math.signum(x) * product\n\
    \        }\n        Some(math.abs(product) * sum)", "        if(arr.isEmpty) None\n\
    \        else {\n            val m = arr.map(math.abs).map(math.signum).sum\n\
    \            val n = arr.size\n            val s = arr.map(x => if(math.signum(x)\
    \ > 0) 1 else 0).sum\n            val product = math.signum(m) * math.signum(n)\
    \ * math.signum(s)\n            val sign = (m * n * s) == 0 ? 0 : m * n * s\n\
    \            Some(product * sign)\n        }", "        if (arr.isEmpty) {\n \
    \           None\n        } else {\n            var total = 0l\n            var\
    \ sign = 1\n            var i = -1\n            var product = 1l\n           \
    \ val lenArr = arr.length\n\n            while (i < lenArr) {\n              \
    \  val num = arr(i)\n                total += num\n                sign *= if\
    \ (num < 0) -1 else 1\n                product = num * product\n             \
    \   i += 1\n            }\n            val signOfTotal = sign * total\n      \
    \      Some(signOfTotal * product)\n        }", "        if (arr.isEmpty) None\n\
    \        else {\n            val arr = arr.map(x => x.toLong).toList\n       \
    \     var m = scala.math.abs(arr(0));\n            var product = arr(0)\n    \
    \        for (i <- 0 until arr.size) {\n                val sign = scala.math.signum(arr(i));\n\
    \                product *= sign\n                m += sign * scala.math.abs(arr(i))\n\
    \            }\n            Some(m)\n        }", "        var product = 1\n  \
    \      var result = 0\n        arr.foreach {\n            i =>\n             \
    \   product *= i\n                if (product >= 0)\n                    result\
    \ += product\n                product = 1\n        }\n        if (product > 0)\n\
    \            result += product\n        if (result > 0)\n            Some(result)\n\
    \        else\n            None", "        arr.foldLeft(Option.empty[Long]) {\
    \ (acc, curr) =>\n            var res = curr\n            acc match {\n      \
    \          case Some(sign) =>\n                    res = (sign * res.getOrElse(0l))\n\
    \                case _ =>\n            }\n            acc\n        }", "    \
    \    // init signs\n        var sign = 1l\n        var signs  = arr.filter(_ <\
    \ 0).toList.map(sign)\n        // find products\n        val prod  = arr.filter(_\
    \ > 0).toList.map(sign * _)\n        // sum signs\n        signs = signs.sum\n\
    \n        // return magnitudes\n        Some(prod.map(abs).sum / signs)", "  \
    \      val sum = 0\n        var i = 1\n        while (i < arr.length) {\n    \
    \        sum += abs(arr(i)) * (-1)\n            i += 2\n        }\n        if\
    \ (arr.isEmpty) None else Some(sum)", "        if (arr.isEmpty) None\n       \
    \ else Some(arr.map(x => (x*arr.signum).abs).sum)", "        val signs = mutable.ArrayBuffer[Long]()\n\
    \        arr.foreach { x => signs += (if (x == 0) 1 else if (x == -1) 0 else 0l)\
    \ }\n        signs.foldLeft(0l) { case (x, y) => (x * y) + x }", '        arr.foldLeft(1L){case
    (acc, n) => n.toLong * acc}', "        var magnitude = 0l\n        var sign =\
    \ 1\n        var product = 1\n        for (x <- arr) {\n            magnitude\
    \ += x * sign\n            sign *= 1\n            product *= sign\n        }\n\
    \        if (product != 1l) None else Some(magnitude)", "      var product = 0\n\
    \      var sign = 0\n      for (x<-arr) {\n        sign = if (x < 0) -1 else if\
    \ (x > 0) 1 else 0\n        product = product * sign\n      }\n      if (arr.size\
    \ == 0) None\n      else {\n        Some(product)\n      }", "        val nums\
    \ = arr.toSet.flatMap(_ * arr.map(_.signum))\n        if (nums.isEmpty) None\n\
    \        else {\n            val rem = nums.takeWhile(_ < 0) // [-4, -2, 2, 2],\
    \ take all negative numbers in the array and subtract them from the set\n    \
    \        val (m, n) = rem // m = 4, n = -1\n            if (n == 0) Some(m * nums.count(_\
    \ == -1)) // the product of any number multiplied by its sign must be equal to\
    \ number of -1s in the array\n            else {\n                val (i, j) =\
    \ (nums.size - 1, nums.last) // i=2, j=1\n                if (rem == 1) Some(m\
    \ * nums.count(_ == i)) // if the product of any number multiplied by its sign\
    \ and number of -1s is equal to number in the array then we found a valid answer\
    \ to the original problem\n                else {\n                    val a =\
    \ nums(i) * (1 - n) // a = 4, n = -1\n                    val b = nums(j) * n\
    \ // b = -2, n = 1\n                    if (a > b) Some(m * a) // if the product\
    \ of a and b is greater then we found a valid answer to the original problem\n\
    \                    else Some(m * b) // otherwise, the product of a and b must\
    \ be lesser than the product of b and n\n                }\n            }\n  \
    \      }", "        val signs = arr.map(x => if(x > 0) { 1 } else if(x < 0) {\
    \ -1} else { 0 })\n        val len = arr.length\n        val ans = arr.map(x =>\
    \ x*signs.map(_*x).sum/len).toList\n        if(ans.sum != 1) {\n            Some(ans.sum)\n\
    \        } else {\n            None\n        }", "        var ret = 0\n      \
    \  var sign = 1\n        for (i <- arr) {\n            ret += sign * i\n     \
    \       sign *= (-1)\n        }\n        if (arr.isEmpty)\n            Some(ret)\n\
    \        else\n            None", "      var m = 0\n      var sum = 0\n      arr.foreach\
    \ {\n          x => {\n            m += Math.signum(x);\n            sum += m\n\
    \          }\n      }\n      if (arr.isEmpty) None\n      else if (sum == 0) Some(0)\n\
    \      else Some(sum)", "        arr.foldRight(0) { (sum, elem) => \n        \
    \    sum + elem.abs.product\n        }", "        if(arr.isEmpty)\n          \
    \  None\n        else\n            Some(arr.map(x => math.abs(x)).product)", " \
    \       val signs = arr.map(_ % 2L).sum\n        if (signs == 0) None else Some(signs\
    \ * arr.map(x => x%2L).product)", '        arr.headOption.flatMap(x => arr.filterNot(_
    == x).map(y => x*y))', "        def sign(x: Long) = (x < 0l) ? -1 : 1\n      \
    \  def mag(x: Long) = (x * x).abs()\n        def prodSign(x: Long) = (sign(x)\
    \ * (mag(x) + x.toLong)).abs()\n        val n = arr.length\n        if (n <= 0)\
    \ {\n            None\n        } else {\n            val signs = arr.map( x =>\
    \ sign(x) * sign(x) )\n            val signAndMags = signs zip arr.map(mag)\n\
    \            val prodSigns = signAndMags map (x => prod(x))\n            val prodSignAndMags\
    \ = prodSigns zip signAndMags\n            prodSignAndMags.reduceLeft { case (a,\
    \ b) => a * b}\n        }", "        if (arr.isEmpty) None\n        else {\n \
    \           val arr = arr.sortBy(math.signum).reverse\n            val res = arr(0)\n\
    \            for (i <- arr.indices) {\n                if (arr(i) < 0) {\n   \
    \                 res * -1\n                } else {\n                    res\n\
    \                }\n            }\n        }", "        if (arr.isEmpty) {\n \
    \           None\n        } else {\n            val signs = arr.map( x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n            val mags = arr.map(Math.abs)\n\
    \            val product = signs.reduceLeft(_ * _)\n            Some(mags.sum\
    \ * product)\n        }", "        def sign(x : Long) : Int = if (x < 0) -1 else\
    \ if (x > 0) 1 else 0\n        val product = arr.foldLeft(1L)(_ * _)\n       \
    \ arr.map(x => (sign(x) * x).asInstanceOf[Long]).map(product * _).sum", "    \
    \    if (arr.length == 0)\n            Some(0l)\n        else {\n            val\
    \ prod = 0\n            val signs = arr.map(x => if (x > 0) -1 else if (x < 0)\
    \ 1 else 0)\n            val product = signs.foldLeft(1l)(_ * _)\n           \
    \ val result = product.map{ x => (x / product) * prod }\n            Some(result)\n\
    \        }", "        arr.foldLeft(0l){\n            case (acc, elem) => acc +\
    \ Math.signum(elem) * elem\n        }", "        val arr = arr.toVector\n    \
    \    val result = arr.map{ x =>\n            val sign = x * x.signum\n       \
    \     sign * math.abs(x)\n        }.reduce((x, y) => x * y)\n        arr.size\
    \ > 0 match {\n            case true => Some(result.toLong)\n            case\
    \ _ => None\n        }", "        // use immutable collections\n        var res\
    \ : Option[Long] = None\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        // sum of the magnitudes of numbers in the list\n\
    \        var sum : Long = arr.map(_ => 0).reduceLeft(_ + _)\n        // products\
    \ of signs in the list\n        var product : Long = signs.reduce(_ * _)\n   \
    \     // iterate over the elements of the list to calculate the magnitudes of\
    \ numbers in the list\n        for (v <- arr)\n            // add the magnitude\
    \ of the number multiplied by the sign of the number\n            sum += v * (signs.lastOption.getOrElse(0)\
    \ * product)\n        // set res to None if the list has no elements\n       \
    \ if (arr.isEmpty) None else res.set(sum)\n        // return result if at least\
    \ one number in the list has a non-zero magnitude\n        if (res.isDefined)\
    \ res.get else None", "        var sum = 0l\n        var sign = 1\n        arr.foreach(a\
    \ => {\n            val s = a.toInt\n            sum += sign * s\n           \
    \ sign = -sign\n        })\n        if (arr.isEmpty) None else Some(Math.pow(sum,\
    \ arr.size.toDouble))", "      arr.foldLeft(0l){\n        (sum, value) => {\n\
    \          val product = value * (if(value < 0L) -1L else 1L)\n          sum +\
    \ math.abs(product)\n        }\n      }", "        // init result and sign counter\n\
    \        var res = 0l\n        var sign = 1l\n\n        // for each element of\
    \ arr do something\n        for (e <- arr) {\n            if (e < 0) {\n     \
    \           sign = sign * -1\n            }\n            res += e * sign\n   \
    \     }\n        // return result\n        if (res != 0l) {\n            Some(res)\n\
    \        } else {\n            None\n        }", "        def sign(x: Long): Long\
    \ = if (x < 0) -1 else if (x > 0l) 1 else 0\n        val s = arr.map(x => sign(x))\n\
    \        val m = arr.map(_.abs)\n        val p = s.product(m)\n        val res\
    \ = Some(p.sum)\n        res", "        val signsMap : Map[Long, Int] = arr.groupBy(x\
    \ => (x.signum))\n        val signsList : List[Long] = signsMap.toList.map(_._2).flatten\n\
    \        if (signsList.isEmpty) None\n        else Some(arr.map(x => x * signsMap(x)).sum.toLong)"]
stop_tokens:
- "\n    }\n"
