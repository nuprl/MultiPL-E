name: HumanEval_103_rounded_avg
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given two positive integers n and m, and your task is to compute\
  \ the\n    // average of the integers from n through m (including n and m). \n \
  \   // Round the answer to the nearest integer and convert that to binary.\n   \
  \ // If n is greater than m, return -1.\n    // Example:\n    // >>> roundedAvg((1l),\
  \ (5l))\n    // \"0b11\"\n    // >>> roundedAvg((7l), (5l))\n    // -1l\n    //\
  \ >>> roundedAvg((10l), (20l))\n    // \"0b1111\"\n    // >>> roundedAvg((20l),\
  \ (33l))\n    // \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String,\
  \ Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l),\
  \ (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"\
  ));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l),\
  \ (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"\
  0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"\
  ));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l),\
  \ (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"\
  0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l),\
  \ (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n \
  \   }\n\n}\n"
completions: ["        if(n > m) Left(s\"$n is greater than $m\")\n        else if(n\
    \ <= m) Right((n.toString + m.toString + n%m.toString.reverse).replaceAll(\"(\\\
    \\d+?)\\\\1\", \"0b$1\"))\n        else Left(-1)", "        val n1 = n\n     \
    \   val m1 = m\n        if(n1 > m){\n            Right(-1)\n        }else{\n \
    \           val list = List(n1 until m1)\n            val newList = list.map {x\
    \ => \n                if (x < n) x - n\n                else if (x > m) m - x\n\
    \                else x \n            }\n            val sum = newList.reduce((x,\
    \ y) => x + y)\n            val avg = sum / newList.size\n            val rightBin\
    \ = Integer.toBinaryString(avg)\n            val leftBin = Integer.toBinaryString(-avg)\n\
    \            val leftBin2 = leftBin.take(8 - rightBin.size)\n            val rightBin2\
    \ = rightBin.take(8 - leftBin.size)\n            Right(rightBin2 + leftBin2)\n\
    \        }", "        var ans : Long = 0l\n        var sum : Long = 0l\n     \
    \   var avg : Long = 0l\n        for (i <- n until m) {\n            sum += i\n\
    \        }\n        ans = sum / m.toDouble\n        avg = ans.toBinaryString\n\
    \        Either.cond(avg < 0 || avg > 1) match {\n            case Right(r) =>\n\
    \                Right(ans)\n            case Left(e) => Left(e)\n        }",
  "        if (n == 0) Left(-1)\n        else if (m == 0) Right(-1)\n        else\
    \ n to m map (_ + _) reduceLeft (_ + _) / 2.0", "        if (n >= m) {\n     \
    \       Right(-1L)\n        }\n        else {\n            var sum = n + m\n \
    \           var count = 0\n            var sumAndCount = 0\n            var avg\
    \ = 0.0\n            // Sum from n to m\n            for (x<-sum to m by -1) {\n\
    \                sum += x\n                count += 1\n                // Sum\
    \ & count is equal to sum + count \n                // because both sum and count\
    \ are the same in the loop\n                sumAndCount += sum + count\n     \
    \       }\n            // Average is equal to sum / count\n            avg = sumAndCount\
    \ / count\n            // Round the average to nearest integer\n            val\
    \ rAvg = math.round(avg)\n            val res = rAvg << 1\n            // Convert\
    \ that to binary\n            val binStr = res.toBinaryString\n            //\
    \ If n < m, return -1\n            if (n < m) {\n                Right(binStr)\n\
    \            }\n            // Otherwise, return binStr\n            else {\n\
    \                Left(binStr)\n            }\n        }", "        if (n == m)\n\
    \            Right(n)\n        else if (n < m)\n            Left(s\"${n} > ${m}\"\
    )\n        else {\n            val total = (n - m).toInt\n            val remainder\
    \ = m % total\n            val count = total - remainder\n            val bits\
    \ = Integer.toString(count + (remainder * 2), 2).padToMax(64, \"0\")\n       \
    \     Right(s\"${n & m}b${bits}\")\n        }", "        if (n > m) {\n      \
    \      Right(-1)\n        } else if (n == m) {\n            Right(n.toBinaryString)\n\
    \        } else {\n            val n = n.toInt\n            val m = m.toInt\n\
    \            if (n > m) {\n                Right(-1)\n            } else {\n \
    \               val diff = m - n\n                val rn = n >> diff\n       \
    \         val rm = m >> diff\n                if (rm == 0) {\n               \
    \     Right(rn.toBinaryString)\n                } else {\n                   \
    \ Right(Long.MaxValue.toBinaryString)\n                }\n            }\n    \
    \    }", "        val l = n - m\n        if (l < 1l) Right(l)\n        else if\
    \ (l > 3l) Left(-1)\n        else Right(math.round(l).toInt + m)", "        //\
    \ Write your code here\n        val n = n.toBinaryString\n        val m = m.toBinaryString\n\
    \        val n = n.toInt\n        val m = m.toInt\n        if (n > m) Right(-1)\n\
    \        else if (n == m) Right(n)\n        else Left(\"Binary conversion of \"\
    \ + n + \" and \" + m + \" produces different numbers\")", "        val n1 = n.toInt\n\
    \        val m1 = m.toInt\n        if(m1 < n1) Left(s\"$n is less than $m\")\n\
    \        else {\n            val n = (n1..m1).filter(x => x > 0 && x < n1).sum\
    \ / 2\n            val m = (m1..n1).filter(x => x > 0 && x < m1).sum / 2\n   \
    \         Right(n.toString + m.toBinary)\n        }", "        if(n < m) Left(-1)\n\
    \        if(n < m) Right(-1)\n        val avg = (n to m).sum / 2\n        val\
    \ ans = math.round(avg * 2).toInt\n        if(ans < 0 || ans >= 21) Right(ans)\n\
    \        if(ans == 0) Left(-1)\n        Left(ans.toBinaryString)", "        if\
    \ (n > m) return Right(-1)\n        val arr = new Array[Long](m+1)\n        arr(0)\
    \ = n\n        for (i <- 1 to m) {\n            arr(i) = arr(i-1) + i\n      \
    \  }\n        // Find the average of the middle m elements and round it to nearest\
    \ integer\n        val mid = math.ceil((m/2.0).toDouble).toInt\n        val average\
    \ = math.ceil((arr(mid)/m).toDouble)\n        val res = (average * Integer.parseInt(Integer.toBinaryString(average))).asInstanceOf[Long]\n\
    \        return Right(res)", "        require(n >= m, \"n is greater than m\"\
    )\n        // get the numbers to compute them from\n        var nums = Vector.tabulate(n\
    \ to m)\n        // get the sum\n        var sum = nums.sum\n        // get the\
    \ count\n        var count = nums.count\n        // get the average\n        var\
    \ average = sum / count\n        // round to nearest integer\n        val rounded\
    \ = math.round(average).asInstanceOf[Long]\n        // convert to binary\n   \
    \     val binary = Integer.toBinaryString(rounded)\n        // return either -1\
    \ or binary string\n        val left = binary.left\n        if (rounded == 0)\
    \ {\n            Left(left)\n        } else {\n            Right(left)\n     \
    \   }", "      val nMax = math.max(n.toInt, m.toInt)\n      val nMin = math.min(n.toInt,\
    \ m.toInt)\n      val remaining = n.toInt - nMin\n      val remainder = 1l.remainder(remaining)\n\
    \      val remainderString = \"0b\" + remainder.toBinaryString\n      if(remainderString.length\
    \ < m) Left(\"-1 too large\")\n      else if(remainderString.length > m) Right(-1)\n\
    \      else {\n        val intPart = remainderString.substring(0, m)\n       \
    \ val avg = (nMax - nMin).toDouble * (intPart.toLong / remainderString.length).toLong\
    \ + nMin\n        Right(avg)\n      }", "        if(n >= m) Right(-1)\n      \
    \  val n = n.toInt\n        val m = m.toInt\n        val mid = (n + m) / 2\n \
    \       val nums = Vector.range(n, m).map(_ - mid).filter(_ > 0)\n        val\
    \ counts = Vector.range(n, m).map(_ - mid)\n        val bins = Vector.range(n.toInt,\
    \ m.toInt).map(_.toBinaryString).filter(_ != '0')\n        val sum = nums.sum\
    \ + counts.sum\n        var count = 0\n        for(i <- bins){\n            if(sum\
    \ % 2 == 0){\n                count += counts(bins.indexOf(i))\n            }\n\
    \        }\n        \n        if(count == 0) Right(-1)\n        val avg = count\
    \ / bins.length\n        val binNums = bins.map(_ - mid)\n        val avg = binNums.sum\
    \ / binNums.length\n        val avgBinNums = binNums.map(_ - mid)\n        val\
    \ finalCount = count\n        val finalBin = bins\n        Right(s\"0b${avgBinNums(0)}${avgBinNums(1)}\"\
    )", "        val nBin = n.toBinary.dropRight(n.toBinary.length)\n        val mBin\
    \ = m.toBinary.dropRight(m.toBinary.length)\n        val result = (nBin ++ mBin)\
    \ / Double(n.toBinary.length)\n        Right(math.round(result))", "        var\
    \ sum : Long = n.toLong + m.toLong\n        val average = sum / 2\n        if\
    \ (average < n.toLong || average > m.toLong) {\n            Left(-1)\n       \
    \ } else {\n            Right(math.round(sum.toBinaryString).padTo(\"0\", 8, \"\
    0\") + \"0\" + average.toBinaryString)\n        }", "        if(n >= m) Left(-1)\n\
    \        else {\n            val sum : Long = n to m by -1\n            val sumAsString\
    \ = String.format(\"%b\", sum)\n            Right(Long.parseByte(sumAsString).get)\n\
    \        }", "        var nBits = n.toBinaryString\n        var mBits = m.toBinaryString\n\
    \        var nBitsLength = mBits.length\n        var mBitsLength = nBits.length\n\
    \        var nStartPos = nBitsLength - mBitsLength\n        var mStartPos = nBitsLength\
    \ + mBitsLength\n        var nLastPos : Int = nBitsLength - 1\n        var mLastPos\
    \ : Int = mBitsLength - 1\n        while (nLastPos >= 0 && mLastPos >= 0 && nBitsLength\
    \ > mBitsLength) {\n            if (nBits(nLastPos) & mBits(mLastPos) > 0)\n \
    \               nBits += \"1\"\n            else\n                mBits += \"\
    1\"\n            nLastPos -= 1\n            mLastPos -= 1\n        }\n       \
    \ if (nBitsLength >= mBitsLength)\n            return Right(mBits.substring(0,\
    \ mBitsLength) + \"0\" * (nStartPos - mStartPos))\n        else\n            return\
    \ Left(nBits.substring(0, nBitsLength) + \"0\" * (mStartPos - nStartPos))", " \
    \       if (n < m) {\n            Left(-1)\n        }\n        else {\n      \
    \      val mInc = m + n\n            val nInc = n + m\n            val nToM =\
    \ n + m\n            val avg = (nInc + mInc) / mToM\n            val bin = math.signum(avg).toBinaryString\n\
    \            Right(bin)\n        }", "        if(n >= m) Left(-1)\n        else\
    \ Right(round(n / 2l) + round(m / 2l))", "        val n = n & 0x1\n        val\
    \ m = m & 0x1\n        if (n > m) {\n            Left(-1l)\n        } else if\
    \ (n == m) {\n            Right(n & 0x1)\n        } else {\n            val num\
    \ = (n - m) + 1\n            val rem = m & n\n            val quotient = num /\
    \ rem\n            val remainder = num % rem\n            Right(quotient | remainder)\n\
    \        }", "        var sum = 0l\n        var count = 0l\n        for (x <-\
    \ n until m) {\n            sum = sum + x\n            count = count + 1\n   \
    \     }\n        if (n == m) {\n            return Right(sum.toString.length.toBinary)\n\
    \        }\n        val round = Math.ceil(sum.toDouble / (count * 8));\n     \
    \   if (round < sum) {\n            return Right(sum.toString.length.toBinary)\n\
    \        }\n        val ret = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        val remainder = sum - round\n        for (x <- 0 until count) {\n   \
    \         val s = remainder / (count - 1) - remainder / (count - 2)\n        \
    \    ret.insert(0, round)\n            ret.insert(1, s)\n            remainder\
    \ -= s\n        }\n        val retString = ret.toList.foldLeft(\"0\")((a, b) =>\
    \ a + b + \"0\")\n        return Left(retString)", "        if(n > m) return Left(\"\
    Nope\")\n        val average = BigDecimal(n).divide(BigDecimal(m), 2).toLong\n\
    \        // Add 0b prefix to convert back to binary\n        Right(average.toBinaryString)",
  "        val sum = (0 until n).toIterator.map(n => (0 to m)).flatMap(m => \n   \
    \         (0 to m).map(n => (n to m)).toIterator.flatMap(n => \n             \
    \   List(math.abs(n div m) + math.abs(n mod m))\n            ).sum\n        )\n\
    \        val div = (0 until n).toIterator.map(n => (0 to m)).flatMap(m => \n \
    \           (0 to m).map(n => (n to m)).toIterator.flatMap(n => \n           \
    \     List(math.abs(n div m) + math.abs(n mod m))\n            ).sum\n       \
    \ ).toList\n        val mod = (0 until n).toIterator.map(n => (0 to m)).flatMap(m\
    \ => \n            (0 to m).map(n => (n to m)).toIterator.flatMap(n => \n    \
    \            List(math.abs(n div m) + math.abs(n mod m))\n            ).sum\n\
    \        ).toList\n        val avg = (0 until n).toIterator.map(n => (0 to m)).flatMap(m\
    \ => \n            (0 to m).map(n => (n to m)).toIterator.flatMap(n => \n    \
    \            List(math.abs(n div m) + math.abs(n mod m))\n            ).sum\n\
    \        ).toList\n        val left = (0 until n).toIterator.map(n => (0 to m)).flatMap(m\
    \ => \n            (0 to m).map(n => (n to m)).toIterator.flatMap(n => \n    \
    \            List(math.abs(n div m) + math.abs(n mod m))\n            ).sum\n\
    \        ).toList\n        val right = (0 until n).toIterator.map(n => (0 to m)).flatMap(m\
    \ => \n            (0 to m).map(n => (n to m)).toIterator.flatMap(n => \n    \
    \            List(math.abs(n div m) + math.abs(n mod m))\n            ).sum\n\
    \        ).toList\n        val left = sum.zip(div).zip(mod).zip(avg).zip(left).flatMap(n\
    \ => \n            n._1._1.toString + n._1._2.toString + n._2._1.toString + n._2._2.toString\
    \ + n._3.toString + n._4.toString\n        ).foldLeft(\"\")(_ + _)\n        val\
    \ right = sum.zip(div).zip(mod).zip(avg).zip(right).flatMap(n => \n          \
    \  n._1._1.toString + n._1._2.toString + n._2._1.toString + n._2._2.toString +\
    \ n._3.toString + n._4.", "        if(m > n) Left(-1)\n        else if(n < 0)\
    \ Right(-1)\n        else Right(scala.math.round(n/2).asBinary.toInt)", "    \
    \    if (n.toInt > m.toInt) Left(-1)\n        if (n.toInt < m.toInt) Left(-1)\n\
    \        val mid = (n.toInt + m.toInt) / 2\n        if (n.toInt < m.toInt) {\n\
    \            val bin1 = n.toString.reverse.foldLeft(\"\")((x, c) => (x + (c x))\
    \ + (if (c > 0) \"1\" : \"0\"))\n            val bin2 = m.toString.reverse.foldLeft(\"\
    \")((x, c) => (x + (c x)) + (if (c > 0) \"1\" : \"0\"))\n            Right(bin1\
    \ + bin2 + mid.toString.reverse)\n        } else {\n            val bin1 = n.toString.reverse.foldLeft(\"\
    \")((x, c) => (x + (c x)) + (if (c > 0) \"1\" : \"0\"))\n            val bin2\
    \ = m.toString.reverse.foldLeft(\"\")((x, c) => (x + (c x)) + (if (c > 0) \"1\"\
    \ : \"0\"))\n            Left(bin1 + bin2 + mid.toString.reverse)\n        }",
  "        require(n >= m, \"n must be greater than m\")\n        val r = n.toInt\n\
    \        val s = m.toInt\n        val len = r - s + 1\n        if (len == 0) Left(\"\
    0\")\n        else {\n            val sum : Long = 0\n            val sums : mutable.MutableList[Long]\
    \ = new mutable.MutableList[Long](len)\n            val m = 0\n            while\
    \ (m <= r) {\n                val x = r - m\n                val y = s - m\n \
    \               val z = y + x\n                val r = z / (z + 1)\n         \
    \       sums.update(0, r)\n                val i = sums.size - 1\n           \
    \     val s = sums(i) / 2\n                sum = sum + s\n                m =\
    \ m + x\n            }\n            Right(scala.math.ceil(sum.toBinaryString).toLong)\n\
    \        }", "        var avg = 0.0;\n        var count = m.toLong;\n        if\
    \ (n.toLong > m.toLong) {\n            avg = -1.0;\n            count = m.toLong\
    \ - n.toLong;\n        }\n        else {\n            val min: Int = ((n.toLong\
    \ + m.toLong) / 2);\n            for (i: Int = n.toInt + 1; i.toInt <= min.toInt;\
    \ i += 2)\n                avg += i.toLong\n        }\n        Either.left(\"\
    invalid input\") match {\n            case Right(right) => Either.right(avg);\n\
    \            case Left(left) => Either.left(left)\n        }", "        val sum\
    \ : Long = (m+n)/2\n        if(sum == 0) Right(\"0b0\")\n        else if(sum ==\
    \ 1) Right(\"0b1\")\n        else if(sum > 1) { \n            val bin = scala.util.BigDecimal(sum).divide(new\
    \ scala.util.BigDecimal(2), 2, RoundingMode.HALF_UP).toBinary() \n           \
    \ Right(\"0b\"+bin)\n        } else { \n            Left(s\"Average of $n to $m\
    \ is invalid\")\n        }", "        val nDigits = math.min(math.log10(n), math.log10(m))\n\
    \        val nToTen = math.pow(n, math.ceil(nDigits / 10))\n        val mToTen\
    \ = math.pow(m, math.ceil(math.log10(m) / nDigits))\n        val average = (nToTen\
    \ + mToTen) / 2\n        val decimal = math.pow(10, nDigits)\n        if (math.round(average\
    \ * decimal) == average) {\n            Right(average * decimal)\n        } else\
    \ {\n            Left(s\"${math.round(average, decimal)}${math.pow(2, nDigits\
    \ - math.round(average * decimal))}\")\n        }", "        if ( n > m ) {\n\
    \            Left(-1)\n        } else if ( n == m ) {\n            Right(m)\n\
    \        } else {\n            val avg = math.ceil((m + n) / 2)\n            val\
    \ bin = Integer.toBinaryString(avg)\n            Right(bin)\n        }", "   \
    \    val sum = 0l\n       val nSum = 0l\n       val mSum = 0l\n       for (i <-\
    \ n until m)\n          if(i <= m)\n             nSum += i\n          else\n \
    \            mSum += i\n       if(mSum > 0l && nSum > 0l) {\n         val avg\
    \ = nSum / mSum\n         if (avg < 10l) Right(avg.toBinaryString) else Left(s\"\
    $avg cannot be represented in binary\")\n       }\n       else Left(s\"${nSum\
    \ / mSum} cannot be represented in binary\")", "      require(n>=0 && m>0)\n \
    \     val counts = (0 until n).map(n => m+1)\n      val total = counts\n     \
    \   .foldLeft(1l)((acc, _) => acc*(_ + 1))\n        .map(x => math.ceil(x/2))\n\
    \        .toVector\n      val remainder = total % 2\n      val leftCount = total\
    \ - remainder\n      val right = total - leftCount\n      if (leftCount>0)\n \
    \       Left(s\"0b$total\")\n      else if (right>0)\n        Right(s\"0b$(remainder+2)\"\
    )\n      else\n        Right(s\"0b0\")", "        if(n > m) Left(-1)\n       \
    \ else Right(n.toBinaryString() + m.toBinaryString).replaceFirst(\"1\",\"0\")",
  "        val sum : Long = n until m\n        val diff = Math.abs((sum - n until\
    \ m).sum)\n        val avg = (sum - diff) / diff.toDouble\n        val bin = Integer.toBinaryString(avg)\n\
    \        val left = bin.substring(0, bin.size - diff)\n        val right = bin.substring(bin.size\
    \ - diff, bin.size)\n        if (right.length == 0)\n            Right(left)\n\
    \        else if (right.length == 1)\n            Left(right.toLong)\n       \
    \ else\n            Left(left) ||| Right(right.toLong)", "        if (n == 0 ||\
    \ m == 0) Right(-1)\n        else if (n <= m) Right(n)\n        else Left(\"-1\"\
    )", "        if (m > n) return Left(s\"The sum cannot be greater than the difference\
    \ (${m} > ${n})\")\n        // round the average number to nearest integer\n \
    \       val avg = scala.math.round(n/(m+1.0)*16)*16\n        // convert binary\
    \ string to decimal\n        val avg = java.lang.Long.parseLong(scala.math.binary.BigInt(avg).toString(2)).toString.toLong\n\
    \        // compare the sum and difference (return 0 if both are same)\n     \
    \   if (avg == m) Right(avg) else Left(s\"The sum cannot be greater than the difference\
    \ (${avg} > ${m})\")", "        val sum = n.toLong + m.toLong\n        if (sum\
    \ < 0 || sum > Integer.MAX_VALUE)\n            Left(-1)\n        else\n      \
    \      Right(sum / (n.toLong + m.toLong))", "        val m = m + n - 1\n     \
    \   if (n == 0) Right(-1)\n        else if (m == 0) Right(-1)\n        else if\
    \ (m >= n) Right(-1)\n        else Right(n.toBinary.reverse.foldLeft(0)((acc,\
    \ x) => acc * 2 + (x shr 1))/m)", "        n to m match {\n            case (first,\
    \ rest) => \n                val avg = first + (rest - 1).toDouble / 2\n     \
    \           if (rest < m) Left(s\"${avg}l\")\n                else if (avg < n)\
    \ Right(avg)\n                else Right(-1)\n            case _ => Right(-1)\n\
    \        }", "        def getSum : Long = n to m map { i => (i.toLong + i.toLong)\
    \ }\n        def getCount : Int = n to m size + 1\n        def getSum2 : Long\
    \ = n to m map { i => (i.toLong / 2).toLong}\n        def getSum3 : Long = n to\
    \ m map { i => (i.toLong * 2).toLong}\n        def getSum4 : Long = n to m map\
    \ { i => i.toLong * 2L}\n        def getSum5 : Long = n to m map { i => (2 * i).toLong}\n\
    \        def getSum6 : Long = n to m map { i => (i * 2L).toLong}\n        def\
    \ getSum7 : Long = n to m map { i => ((i * 2L).toLong + i.toLong).toLong}\n  \
    \      def getSum8 : Long = n to m map { i => ((i * 2L).toLong / 2).toLong}\n\
    \        def getSum9 : Long = n to m map { i => ((i * 2L).toLong / 2).toLong}\n\
    \        def getSum10 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum11 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum12 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum13 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum14 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum15 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum16 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum17 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum18 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum19 : Long = n to m map { i => ((i * 2L).toLong * 2L).toLong}\n\
    \        def getSum20 : Long = n to m map { i => ((i * 2L).toLong", "        var\
    \ sum : Long = 0\n        var sum2 : Long = 0\n        var cnt = 0\n        var\
    \ cnt : Int = 0\n        val m = n.toInt\n        val n = m.toInt\n        for(i\
    \ <- 1 to m) {\n            sum = sum + i\n            sum2 = sum2 + i.toBinaryString\n\
    \            cnt += 1\n        }\n        if(sum != 0l && sum2 == sum) {\n   \
    \         val left = \"\"\n            val right = sum2.toInt\n            val\
    \ right2 = right.toBinaryString\n            val right3 = right2.substring(1,\
    \ right2.length-1)\n            if(right == 0 && right3 == 1) {\n            \
    \    Left(left)\n            } else {\n                Right(left+right3)\n  \
    \          }\n        } else {\n            Left(\"\"+sum2)\n        }", "   \
    \     val sum = m\n        val count = m\n        var sumB : Long = 0\n      \
    \  var countB : Long = 0\n        while (n <= m) {\n            if (countB ==\
    \ 0 || sumB % 2 != 0) {\n                sumB += 1\n                countB +=\
    \ 1\n            } else {\n                sumB += 2\n                countB +=\
    \ 1\n            }\n            sum += n\n            n += 1\n        }\n    \
    \    if (sum < sumB) {\n            val x = sum\n            val y = sumB\n  \
    \          Right(BigDecimal(x / y.toDouble).toString(2))\n        } else {\n \
    \           val x = sumB\n            val y = sum\n            Left(BigDecimal(x\
    \ / y.toDouble).toString(2))\n        }", "        val ans = math.ceil((n + m)\
    \ / 2)\n        val num = ans.toBinaryString\n        Right(if (num.length < 8)\
    \ -1 else num)", "        if (n > m) return Left(-1l).asInstanceOf[Either[String,\
    \ Long]]\n        var sum = 0l\n        var count = 0l\n        for (i <- n until\
    \ m) {\n            sum += i\n            count += 1\n        }\n        val avg\
    \ = sum / count\n        val str = new DecimalFormat(new DecimalFormatSymbols(Locale.US)).maximumFractionDigits(2).format(avg)\n\
    \        return Right(str.asInstanceOf[String]).asInstanceOf[Either[String, Long]]",
  "        if (m >= n) return Left(-1l)\n        val m = m.toInt\n        val n =\
    \ n.toInt\n        if (n == m) Right(math.round(n/2.0).toBinary)\n        else\
    \ Left(-1l)", "        if (n < m) Left(-1)\n        else {\n            var avg\
    \ : Long = 0l\n            var i : Long = 0l\n            var j : Long = 0l\n\
    \            while (i < m && j < n) {\n                avg = avg + i\n       \
    \         i = i + 1\n                j = j + 1\n            }\n            avg\
    \ = avg / n\n            val bits = Integer.toBinaryString(avg)\n            if\
    \ (bits.size == 1) Left(\"0b\" + bits.toUpperCase)\n            else Right(\"\
    0b\" + bits.toUpperCase)\n        }", "        if (n < m) Left(s\"$n is less than\
    \ $m\")\n        n + (m - (n + m)) * ((0.5).toLong).toBinary", "        val bin\
    \ = new StringBuilder()\n        var sum = 0\n        var sumOfDigits = 0\n  \
    \      var nextSum = 0\n        var nextSumOfDigits = 0\n        var first = 0\n\
    \        var second = 0\n        var firstOfDigits = 0\n        var secondOfDigits\
    \ = 0\n        var firstSum = 0\n        var secondSum = 0\n        var tempSum\
    \ = 0\n        var tempSumOfDigits = 0\n        for(i <- n to m) {\n         \
    \   if(i / 10 == 0)\n                sum += i\n            else\n            \
    \    sumOfDigits += i.toInt\n        }\n        firstOfDigits = sumOfDigits %\
    \ 10\n        secondOfDigits = sum / 10\n        tempSumOfDigits = sumOfDigits\
    \ % 10\n        tempSum = sum / 10\n        for(i <- n to m) {\n            if(i\
    \ / 10 == 0) {\n                firstSum += i\n                firstOfDigits +=\
    \ i.toInt\n                firstSumOfDigits = firstOfDigits % 10\n           \
    \     secondSum = firstSum / 10\n                secondOfDigits = secondSum %\
    \ 10\n                for(j <- i to m) {\n                    nextSum += j\n \
    \                   nextSumOfDigits += j.toInt\n                }\n          \
    \      if(nextSumOfDigits % 2 == 1) {\n                    bin.append(\"0b\").append(bin.deleteCharAt(bin.length-1).toString).append(bin.deleteCharAt(bin.length-1).toString).toString\n\
    \                }\n                else {\n                    bin.append(\"\
    0b\").append(bin.deleteCharAt(bin.length-1).toString).append(bin.deleteCharAt(bin.length-1).toString).toString\n\
    \                }\n            }\n            else {\n                secondSum\
    \ += i\n                secondOfDigits += i.toInt\n                secondSumOfDigits\
    \ = secondOfDigits % 10\n                for(j <- i to m) {\n                \
    \    nextSum += j\n                    nextSumOfDigits += j.toInt\n          \
    \      }\n                if(nextSumOfDigits % 2 == 1) {\n                   \
    \ bin.append(\"0b\").append(bin.deleteCharAt(bin.length-1).toString).append(bin.deleteCharAt(bin.length-1).toString).toString\n\
    \                }\n                else {\n                    bin.append(\"\
    0b\").append(bin.deleteCharAt(bin.length-1).toString).append(bin.deleteCharAt(bin.length-1).toString).toString\n\
    \                }\n            }\n        }\n        if(tempSumOfDigits % 2 ==\
    \ 1) {\n            bin.append(\"0b\").append(bin.deleteCharAt(bin.length-1).toString).append(bin.deleteCharAt(bin.length-1).toString).toString\n\
    \        }\n        else {\n            bin.append(\"0b\").append(bin.deleteCharAt(bin.length-1).toString).append(bin",
  "        if (n < m) Right(-1)\n        val mid = (n + m) / 2\n        if (mid <\
    \ n) Right(-1)\n        val result = binary(n, mid)\n        if (n < m) Right(result)\n\
    \        Left(result)", "      val (n, m) = (n, m) match {\n        case (a, b)\
    \ if a < b => (b, a)\n        case (a, b) => (a, b)\n      }\n      val avg =\
    \ (n to m).foldLeft(0.0d) { case (acc, next) => acc + next } / 2\n      val digits\
    \ = math.ceil(math.log10(avg)) + 1\n      Right(s\"0${round(avg)}\".reverse.dropRight(digits))",
  "        var count = 1\n        var sum = 0\n        for(i <- n until m){\n    \
    \        if(i < n) sum += i\n            if(i < m) count += 1\n        }\n   \
    \     if(count == 0) return Left(s\"${n} to ${m} doesn't contain any numbers\"\
    )\n        val avg = sum / count\n        val result = math.round(avg).toBinaryString\n\
    \        if(result.length > 0) Right(result)\n        else Left(s\"${n} to ${m}\
    \ doesn't contain any numbers\")", "        if (n.toLong < m.toLong) {\n     \
    \       Left(\"invalid input\")\n        } else {\n            val m1 = n + m\n\
    \            var n = n\n            while (n <= m1)\n                n += n \n\
    \            Right(n.toBinary)\n        }", "        require(n <= m)\n       \
    \ if (m == 0L) Right(-1)\n        else {\n            val sum = n.toLong + (m\
    \ - 1L).toLong\n            val remainder = sum.toLong % 2\n            val remainderString\
    \ = if (remainder == 0L) \"0b0\" else toBinaryString(remainder)\n            val\
    \ totalString = toBinaryString(sum)\n            Right(totalString + remainderString)\n\
    \        }", "        var sum = n.toLong + m.toLong\n        var n = n.toLong\n\
    \        var m = m.toLong\n        val diff = sum - m\n        val a = n / diff\n\
    \        val b = m / diff\n        val ans = a + b\n        val r = scala.math.ceil(ans.toDouble).toBinaryString\n\
    \        Right(r)", "        // Compute the average of the integers from n through\
    \ m (including n and m).\n        // The average is rounded towards zero to the\
    \ nearest integer.\n        // Divide by (n + m) so that the average is never\
    \ negative.\n        val avg = scala.math.round((n + m)/2.0)\n        // Convert\
    \ the average to binary. \n        // If it is less than 2, just return a string\
    \ containing the average in binary.\n        // If it is greater than 2, return\
    \ -1 as the final answer.\n        // If it is exactly 2, return a string containing\
    \ two 1s.\n        if (avg < 2L) {\n            return Left(s\"0b${avg}\")\n \
    \       } else if (avg > 2L) {\n            return Right(-1)\n        } else {\n\
    \            return Left(s\"0b${avg}\")\n        }", "      var a : Long = 0\n\
    \      var c : Long = 0\n      var b : Long = 0\n      var e : Long = 0\n    \
    \  for(i <- n until m) {\n        a = i\n        c = math.max(a,b)\n        b\
    \ = c\n        e = a + b\n      }\n      if(n.toInt == c.toInt)\n        Right(c.toHexString)\n\
    \      else\n        Left(s\"${c.toInt} = $e\")", "        if (n > m) Left(-1)\n\
    \        else if (n == m) Right(n)\n        else {\n            val list = List(n,\
    \ m)\n            val a = list.toSet\n            val sum = list.sum\n       \
    \     val count = (list.size - 1) * list.size\n            val average = sum /\
    \ count\n\n            Right(average.toBinaryString).left.map(average.toBinaryString(_))\n\
    \        }", "        if(n < m) Right(-1)\n        else if((n.toLong <= m.toLong)\
    \ && (n.toLong > 0)) Right(n.toLong + m.toLong / 2)\n        else Left(-1)", " \
    \       if (n > m) Left(-1)\n        else Right(math.ceil((n - m) / math.pow(10.0,\
    \ 1.0)))", "        val m1 = m + n\n        if(m1 <= 0) {\n            Left(\"\
    Invalid input\")\n        } else {\n            val n1 = n - m\n            val\
    \ binary = math.round(n1 * 2l).toString(2)\n            Right(binary + m1.toString(2))\n\
    \        }", "        require(n >= 0 && m >= 0)\n        if (n > m) {\n      \
    \      return Left(-1)\n        }\n        val result = n + m + 1\n        val\
    \ bits = toBinary(result.toInt)\n        Right(bits.toInt)", "        val result\
    \ = n.toInt + (m toInt)\n        result > m ? Right(result) : Left(s\"Error: ${result}\
    \ is greater than ${m}\")", "        if (n < m){\n            Left(\"invalid input\"\
    )\n        }\n        val left = n.toLong\n        val right = m.toLong\n    \
    \    if (left < right){\n            val l = n.toLong\n            val r = m.toLong\n\
    \            if (left >= r){\n                Right((left.toInt + right).toLong)\n\
    \            }\n            else{\n                Right(-1)\n            }\n\
    \        }\n        else{\n            Right(-1)\n        }", "      if(n > m)\
    \ Left(-1)\n      else if (n < m) Right(-1)\n      else n to m map {\n       \
    \ case n if (n < 0) => (n << 1) + 1\n        case n => (n << 1) + 0\n      }.sum\
    \ / 2", "      if (n < 0 || m < 0) {\n        return Right(-1l)\n      }\n   \
    \   if (n == m && n == 0) {\n        return Right(1l)\n      }\n      var sum\
    \ : Long = 0\n      var n : Long = math.min(m, n)\n      var i : Long = 0\n  \
    \    while (i < n) {\n        sum += i\n        i += 1\n      }\n      sum.toRight(\"\
    Can't compute\")", "        var sum : Long = 0\n        val count = m + 1 - n\n\
    \        if (count <= 0) {\n            Left(s\"$count <= 0\")\n        } else\
    \ {\n            sum = (sum + n + m) / count\n            Right(Long.bitCount(sum).toHexString)\n\
    \        }", "        val min = (n) min m\n        val max = (m) max n\n     \
    \   val result = (min to max).filter(_ % 2 == 0).sum / 2\n        val hexString\
    \ = result.toString.reverse leftPad(result, 6)\n        Right(hexString)", " \
    \       val num = 0\n        var sum : Long = 0\n        if (n == 0)\n       \
    \     Left(-1)\n        else if (m == 0)\n            Right(-1)\n        else\
    \ { \n            for (i = n to m; i > 0; i = i / 2)\n                sum = sum\
    \ + i\n            sum = sum / 2\n            val string = sum.toString \n   \
    \         Right(string.dropRight(string.size).reverse)\n        }", "        var\
    \ n = n.toInt\n        var m = m.toInt\n        var sum = m + ((n + m) / 2)\n\
    \        if (n > m) {\n            sum = sum.asInstanceOf[Long]\n            n\
    \ = sum - sum * 2\n        }\n        if (sum < 0l){\n            return Left(\"\
    \")\n        }\n        else {\n            val string = (sum & 0xffffffff00000000).asInstanceOf[String]\n\
    \            val s = string.substring(0, string.length-1)\n            val m =\
    \ string.toLong\n            if (m == 0l){\n                Right(Right(s))\n\
    \            }\n            else {\n                val b = (s + \"1\").asInstanceOf[Byte]\n\
    \                Right(Right(String.valueOf(b)))\n            }\n        }", " \
    \       val average = n + (m - 1) / 2\n        val remainder = average % 2\n \
    \       if(remainder == 0){\n            Right(average.toBinaryString().toLong)\n\
    \        } else {\n            Left(\"-1\")\n        }", "        n match {\n\
    \            when {\n                when {m > n => Left(s\"$m is greater than\
    \ $n\")}\n                m == n => Right(n)\n                else => Right(m)\n\
    \            }\n        }", "        val sum = n.toLong + m.toLong\n        val\
    \ average = Math.round(sum / 2).toInt * 2\n        val result = average match\
    \ {\n            case n if n < m => Left(s\"$average is too large\")\n       \
    \     case n if n == m => Right(average)\n            case n => Left(s\"$average\
    \ is not a whole number\")\n        }\n        result", "        if (m > n) return\
    \ Right(-1)\n        val bin = BigInt(n)\n        val binM1 = BigInt(m)\n    \
    \    var sum : Long = 0\n        for (i <- bin.upTo[binM1]) {\n            sum\
    \ += i\n        }\n        val avg = math.round(sum * 1.0f / binM1.toDouble)\n\
    \        val result = (sum / (binM1.toDouble - 1)) & \"0\" \n        val binRes\
    \ = BigInt(result)\n        if (binRes > binM1) Right(-1)\n        else Right(result)",
  "      val sum = (n to m).sum\n      val diff = (n to m).count\n      val avg =\
    \ math.round(sum / diff)\n      if (avg >= math.pow(10, 9)) {\n        val b =\
    \ math.pow(10, 9).toBinaryString(avg).reverse\n        Right(s\"${b.slice(0, b.length\
    \ / 2)}1\")\n      } else {\n        Left(\"Invalid Input\")\n      }", "    \
    \    def sum(n: Long, m: Long): Long = n + m\n        def divide(n: Long, m: Long,\
    \ d: Long): Long = n * d / d\n\n        val n = n.toDouble\n        val m = m.toDouble\n\
    \        val d = m * 2 - n\n        val d = if (d < 0.5) d else d - (1 - d)\n\
    \        val r = sum(n, m)\n        val q = divide(n, r, d)\n        Right(math.abs(q).roundBinary)",
  "        val nums = Iterator.from(n.toInt).takeWhile(_ < m).map(_.toInt).take(m\
    \ + 2 - n)\n        if (nums.isEmpty) Left(-1)\n        else Right(nums.sum.toInt\
    \ - n + m.toInt.toBinary)", "      val n = n.toLong\n      val m = m.toLong\n\
    \      if (n < m) Right(-1)\n      else Left(\n        s\"$n is greater than $m,\
    \ so cannot compute average from $n to $m\")", "        if(m > n) return Left(s\"\
    ${m} is bigger than ${n}\")\n        if(n > m) return Right(-1)\n        val avg\
    \ = ((n + m) toLong).toBinaryString\n        Right(s\"0b${avg}\")", "        val\
    \ avg =  n.toDouble / m.toDouble * Math.ceil \n        Right(avg.toBinaryString)",
  "        val bits = math.log(n, 2).toInt\n        if (bits < 0 || bits > 32) {\n\
    \            return Left(s\"Invalid number n or m: ${n} or ${m}\")\n        }\n\
    \        var sum = 0\n        for (i <- n to m) {\n            sum += i\n    \
    \    }\n        val avg = sum / 32\n        val bitString = binary(avg)\n    \
    \    val result = Right(bitString) \n        result", "        val total = (n\
    \ to m).foldLeft(1l) {\n            case (acc, x) => acc * 2l\n            case\
    \ (acc, y) => acc + y\n        }\n\n        val decimalResult = total.toInt.asInstanceOf[Double]\n\
    \        if (decimalResult == total) {\n            Right(math.round(decimalResult))\n\
    \        } else {\n            Left(s\"$decimalResult\")\n        }", "      \
    \  val nNums = n.toInt * m\n        val mNums = n.toInt * m\n        if(mNums\
    \ > nNums) {\n            Right(-1l)\n        } else {\n            val nSum =\
    \ n.toInt\n            val mSum = m.toInt\n            val totalSum = nSum + mSum\n\
    \            val totalInt = n.toInt + m.toInt\n            val total = totalSum\
    \ + totalInt\n            Right(total.toString.toLong)\n        }", "        if\
    \ (n >= m) Left(-1)\n        else {\n            val total = (n-m +1) * (n+m)/2\n\
    \            val count = n - m\n            val s = scala.math.round(total.toDouble).toBinaryString\n\
    \            Right(s)\n        }", "        val m1 = m + n\n        val binary\
    \ = m1.toString (2).toCharArray.map(x => if(x =='1') '0' else ' ').mkString\n\
    \        val str = binary + ((m1 - n).abs % 2).map (x => if(x =='1') '0' else\
    \ ' ').mkString\n        if(str.startsWith(\"0b\")) {\n          Right(str.drop(1))\n\
    \        } else {\n          Left(str)\n        }", "        val avg = n.toFloat\
    \ / m\n        val result = (avg + 0.5).toInt\n        if (result > Integer.MAX_VALUE)\
    \ return Left(\"-1\")\n        if (result < 0) return Right(-1l)\n        Right(result.toString)",
  "        var sum = m.toLong\n        if(n.toLong > sum){\n            sum = n.toLong\n\
    \        }\n        if(m.toLong > sum){\n            sum = m.toLong\n        }\n\
    \        val remainder = (sum >>> 1) - (n << 1)\n        val remainder2 = (remainder\
    \ << 1) | (sum & 1)\n        return if(remainder != 0) Right(remainder2) else\
    \ Left(\"No integers\")", "        if (n.toLong <= m && m.toLong >= n) Right((n.toLong+m.toLong)/2l)\n\
    \        else Left(\"-1l\")", "        var n1 : Long = 0\n        var n2 : Long\
    \ = 0\n        var n3 : Long = 0\n        var n4 : Long = 0\n        var n5 :\
    \ Long = 0\n        var n6 : Long = 0\n        var n7 : Long = 0\n        var\
    \ n8 : Long = 0\n        var n9 : Long = 0\n        var n10 : Long = 0\n     \
    \   var n11 : Long = 0\n        var n12 : Long = 0\n        var n13 : Long = 0\n\
    \        var n14 : Long = 0\n        var n15 : Long = 0\n        var n16 : Long\
    \ = 0\n        var n17 : Long = 0\n        var n18 : Long = 0\n        var n19\
    \ : Long = 0\n        var n20 : Long = 0\n        var n21 : Long = 0\n       \
    \ var n22 : Long = 0\n        var n23 : Long = 0\n        var n24 : Long = 0\n\
    \        var n25 : Long = 0\n        var n26 : Long = 0\n        var n27 : Long\
    \ = 0\n        var n28 : Long = 0\n        var n29 : Long = 0\n        var n30\
    \ : Long = 0\n        var n31 : Long = 0\n        var n32 : Long = 0\n       \
    \ var n33 : Long = 0\n        var n34 : Long = 0\n        var n35 : Long = 0\n\
    \        var n36 : Long = 0\n        var n37 : Long = 0\n        var n38 : Long\
    \ = 0\n        var n39 : Long = 0\n        var n40 : Long = 0\n        var n41\
    \ : Long = 0\n        var n42 : Long = 0\n        var n43 : Long = 0\n       \
    \ var n44 : Long = 0\n        var n45 : Long = 0\n        var n46 : Long = 0\n\
    \        var n47 : Long = 0\n        var n48 : Long = 0\n        var n49 : Long\
    \ = 0\n        var n50 : Long = 0\n        var n51 : Long = 0\n        var n52\
    \ : Long = 0\n        var n53 : Long = 0\n        var n54 : Long = 0\n       \
    \ var n55 : Long = 0\n        var n56 : Long = 0\n        var n57 : Long = 0\n\
    \        var n58 : Long = 0\n        var n59 : Long = 0\n        var n60 : Long\
    \ = 0\n        var n61 : Long = 0\n        var n62 : Long = 0\n        var n63\
    \ : Long = 0\n        var n64 : Long = 0\n        var n65 : Long = 0\n       \
    \ var n66 : Long = 0\n        var n67 : Long = 0\n        var n68 : Long = 0\n\
    \        var n69 : Long = 0\n        var n70 : Long = 0\n        var n71 : Long\
    \ = 0\n        var n72 : Long = 0\n        var n73 : Long = 0\n        var ",
  "        def nextDigit(n : Long, m : Long) : String = {\n            var str = n.toBinaryString\n\
    \            var i = 0\n            while (i < m.toBinaryString.length) { str\
    \ += \"0\" + m.toBinaryString(i) ; i += 1; }\n            return str\n       \
    \ }\n        if (n <= m) Right(n.toBinaryString) else Left(\"-1\")", "       \
    \ val diff = Math.abs(n - m);\n        val diff = diff % 2\n        if (diff ==\
    \ 0)\n            Right(n.toInt)\n        else if (diff == 1)\n            Left(\"\
    \")\n        else Right(-1)", "        val sum = n.toInt + m.toInt\n        val\
    \ avg = sum / 2\n        val bits = binary(avg)\n        val left = (sum.toString\
    \ + bits.rightPadTo(bits.length, 0)).dropRight(1)\n        val right = (sum.toString\
    \ + bits.leftPadTo(bits.length, 0)).dropLeft(1)\n        val sum = left.toLong\
    \ + right.toLong\n        if(sum > Long.MaxValue)\n            Left(s\"${avg}\
    \ is too big, use -1 instead\")\n        else\n            Right(sum)", "    \
    \    val avg = ((n+m)/2.0).toInt\n        if(avg > m){\n            Left(s\"${Integer.toBinaryString(avg)}\
    \ > ${Integer.toBinaryString(m)}\")\n        } else {\n            Right(avg)\n\
    \        }", "        def rec(n : Long, m : Long, acc : Long, result : String)\
    \ : Either[String, Long] = {\n            if (n <= m) Right(acc)\n           \
    \ else {\n                if (n >= m) Left(s\"$acc is not a valid range\")\n \
    \               else {\n                    val r = n % 2\n                  \
    \  val r2 = (n / 2)\n                    if (r == 1) rec(n - 1, m-1, acc + r2,\
    \ s\"${acc}b${r2}\") else if (r == 0) rec(n - 1, r2, acc + r2, s\"${acc}b${r2}\"\
    ) else if (r == -1) rec(n - 1, m, acc, s\"${acc}b${r2}\") else rec(n - 1, m, r2,\
    \ s\"${acc}b${r}\")\n                }\n            }\n        }\n        rec(n,\
    \ m, 0, 0)", "      val (nToM, nToM) = (n, m) match {\n        case (n,m) => for\
    \ { _ <- n until m } yield (m, m)\n        case _ => throw new IllegalArgumentException(s\"\
    Arguments n and m should be positive integers\")\n      }\n      val avg = (nToM\
    \ - nToM.floor) / 2\n      if (avg < 0 || n <= m) Left(s\"Cannot compute average\
    \ between $n and $m, avg: ${avg}\")\n      else Right(s\"0b${math.abs(avg).asBinaryString.reverse}\"\
    .replaceFirst(\"0b\", \"\"))", "        if ((n>m)) {\n            return Left(\"\
    -1\")\n        }\n        val count = (n-m).abs // How many numbers from n to\
    \ m are present\n        val sum = ((n+m)*(n+1))/2 + n/2 + (m/2)\n        val\
    \ quotient = sum.toLong/count.toLong\n        val remainder = sum.toLong - quotient*count.toLong\n\
    \        // This will return -1 if n is greater than m\n        Right(quotient.toBinaryString.dropRight(remainder.toInt))",
  "        if (n <= m) Right((n.toBinaryString).padTo(32, \"0\"))\n        else Left(-1)",
  "        val m = m.toInt\n        val n = n.toInt\n        if (m > n) Left(s\"${m}\
    \ is greater than ${n}\")\n        else if (n == m) Right(m+n)\n        else {\
    \ val nm = n.until(m).sum.toDouble / (m.until(n).sum.toDouble + 1.0)\n       \
    \     Right(nm.toBinaryString) }", "        val l = List.range(n, m + 1)\n   \
    \     if(l.isEmpty) Right(-1)\n        else {\n            val list = l.toList\n\
    \            val sum = list.reduce(_ + _)\n            val avg = sum / l.length\n\
    \            val res = (if (avg == 0) \"0\" else math.ceil(avg).toBinaryString).replace(\"\
    0\", \"1\")\n            Right(res)\n        }", "        var count = 0L\n   \
    \     var sum = 0L\n        for (i = n; i >= m; i--) {\n            count = i\
    \ + 1\n            sum = sum + i\n        }\n        \n        if (count != 0L)\
    \ {\n            sum = sum / count\n        }\n        \n        val str = if(sum\
    \ == 0) \"0b0\" else Integer.toString(sum.toInt)\n        val bin = str.charAt(str.length\
    \ - 1) - '0'\n        \n        Right(bin)", "        require(n <= m)\n      \
    \  val diff = m+1-n\n        val sum = 0\n        val count = 0\n        while(diff>0)\
    \ {\n            sum += n\n            count += 1\n            diff -= 1\n   \
    \     }\n        require(count==0 && diff>0)\n        val avg = math.round(sum/count).toInt\n\
    \        val binary = if (avg<0) \"0b\" + Integer.toBinaryString(-avg) else Integer.toBinaryString(avg)\n\
    \        Left(binary)", '        if (n.toInt() < m.toInt()) Left(-1l) else Right(m.toLong.toBinary)',
  "        if((n < m)){\n            Left(-1)\n        }else{\n            val count\
    \ = n.toInt\n            val bits = (count.toLong.toBinary)\n            val len\
    \ = bits.length\n            val count2 = bits.toLong\n            val count3\
    \ = 0l\n            val count4 = 0l\n            val count5 = 0l\n           \
    \ val count6 = 0l\n            val count7 = 0l\n            val count8 = 0l\n\
    \            val count9 = 0l\n            val count10 = 0l\n            val count11\
    \ = 0l\n            val count12 = 0l\n            val count13 = 0l\n         \
    \   val count14 = 0l\n            val count15 = 0l\n            val count16 =\
    \ 0l\n            val count17 = 0l\n            val count18 = 0l\n           \
    \ val count19 = 0l\n            val count20 = 0l\n            val count21 = 0l\n\
    \            val count22 = 0l\n            val count23 = 0l\n            val count24\
    \ = 0l\n            val count25 = 0l\n            val count26 = 0l\n         \
    \   val count27 = 0l\n            val count28 = 0l\n            val count29 =\
    \ 0l\n            val count30 = 0l\n            val count31 = 0l\n           \
    \ val count32 = 0l\n            val count33 = 0l\n            val count34 = 0l\n\
    \            val count35 = 0l\n            val count36 = 0l\n            val count37\
    \ = 0l\n            val count38 = 0l\n            val count39 = 0l\n         \
    \   val count40 = 0l\n            val count41 = 0l\n            val count42 =\
    \ 0l\n            val count43 = 0l\n            val count44 = 0l\n           \
    \ val count45 = 0l\n            val count46 = 0l\n            val count47 = 0l\n\
    \            val count48 = 0l\n            val count49 = 0l\n            val count50\
    \ = 0l\n            val count51 = 0l\n            val count52 = 0l\n         \
    \   val count53 = 0l\n            val count54 = 0l\n            val count55 =\
    \ 0l\n            val count56 = 0l\n            val count57 = 0l\n           \
    \ val count58 = 0l\n            val count59 = 0l\n            val count60 = 0l\n\
    \            val count61 = 0l\n            val count62 = 0l\n            val count63\
    \ = 0l\n            val count64 = 0l\n            val count65 = 0l\n         \
    \   val count66 = 0l\n            val count67 = 0l\n            val count68 =\
    \ 0l\n            val ", "        val sum = n.toInt + m.toInt\n        val avg\
    \ = sum / 2\n        val answer = avg.toBinary\n        if (answer < 0)\n    \
    \        Left(s\"$answer cannot be represented in binary notation\")\n       \
    \ else\n            Right(answer)", "        var sum : Long = 0l\n        var\
    \ min : Long = Long.MinValue\n        for (i <- n to m) {\n            sum +=\
    \ i\n            min = if (i < min) i else min\n        }\n        if (min < 0)\
    \ Left(s\"Negative min: ${min}\")\n        else Right(sum / m).asBin", "     \
    \   var sum = n.toLong + m.toLong\n        var mid = sum / 2\n        sum -= mid\n\
    \        val rem = sum / 2\n        val n1 = if (rem > 0) rem else 0l\n      \
    \  val m1 = if (rem > 0) rem else 0l\n        val left = if (n1 < m1) n1 else\
    \ m1\n        val right = if (n1 < m1) m1 else n1\n        val result = if (left\
    \ < right) left.toBinaryString + right.toBinaryString else left.toBinaryString\
    \ + right.dropRight(1)\n        return Right(result)", "        val nums = List(n,\
    \ m)\n        val diff = nums.sum - nums.tail.head\n        if (diff == 0) Right(nums.sum)\n\
    \        else if (diff < 0 ) Left(s\"$diff is too large\")\n        else Right(nums.sum.toBinaryString).asInstanceOf[Either[String,\
    \ Long]]", "        var avg :Long = n.toLong + m.toLong\n        if (n > m) {\n\
    \            avg = -1\n        }\n        return Either.left(avg)", "        n\
    \ match {\n            case n if n > m => Left(-1)\n            case n => Right(n\
    \ / 2l + (n % 2l) / 2l)\n        }", "        def average(xs : List[Long]) = {\n\
    \            def total(xs : List[Long], total : Long) = total + xs.sum\n     \
    \       val total = n.toInt * m.toInt\n            if (total <= 0)\n         \
    \       Left(s\"Cannot compute the average for $n and $m because $n or $m is too\
    \ small\")\n            else\n                Right(total / xs.length)\n     \
    \   }\n        val xs = n.toInt.toList.drop(m).take(m).toList\n        average(xs)",
  "        val total = ((n.toLong + m.toLong)/2).toInt\n        val binary = total.toBinary(2)\n\
    \        return if(binary == \"0\") Right(total.toLong.toInt) \n            else\
    \ Left(s\"$total is not a valid integer.\")", "        val n = n.toInt\n     \
    \   val m = m.toInt\n        if(n > m) {\n            Right(\"-1\")\n        }\n\
    \        else {\n            val s = n.toString.reverse.drop(1).dropRight(1)\n\
    \            val l = m.toString.reverse.drop(1).dropRight(1)\n            val\
    \ nInt = new BigInteger(n)\n            val mInt = new BigInteger(m)\n       \
    \     if(l.toString.length == 0 || nInt.toString.length == 0) {\n            \
    \    Right(-1)\n            }\n            else {\n                val l = l.toString.reverse\n\
    \                val nStr = new BigInteger(s).mod(nInt)\n                val mStr\
    \ = new BigInteger(l).mod(mInt)\n                val sum = nStr.toString(2) +\
    \ mStr.toString(2)\n                val len = sum.length\n                if(len\
    \ == 0) {\n                    Right(-1)\n                }\n                else\
    \ {\n                    val str = sum.reverse.drop(len).reverse\n           \
    \         val rstr = new BigInteger(str)\n                    val ans = rstr.divide(BigInteger.valueOf(2)).intValue()\n\
    \                    Right(ans.toBinaryString)\n                }\n          \
    \  }\n        }", "        if (n >= m) {\n            Left(-1)\n        }\n  \
    \      else {\n            val total = n.toInt\n            val count = m.toInt\n\
    \            val sum = Math.floor(total.toDouble / count).toInt\n            val\
    \ binary = sum.toBinaryString\n            Right(binary.padLeft(count.length,\
    \ \"0\"))\n        }", "        val sum = n + m\n        if (sum < 1l) Left(-1)\n\
    \        else if (sum > 1l) Right(-1)\n        else {\n            val x = math.ceil(sum).toInt\n\
    \            val y = math.ceil(sum - x).toInt\n            val avg = math.floor(sum\
    \ - x / 2).toInt + (x % 2) * 2\n            Right((0b.toBinary(y) + 0b.toBinary(avg)).toLong)\n\
    \        }", "        val l = n.toString.length\n        val ll = m.toString.length\n\
    \        val sum = ((n.toInt + m.toInt).toString + n.toString + m.toString).\n\
    \                substring((l + (n - ll)).ceil.toInt)\n        val left = sum.substring(0,\
    \ sum.length - 1)\n        val right = sum.substring(sum.length - 1)\n       \
    \ val a = (left.reverse.charAt(0) - '0') + (right.reverse.charAt(0) - '0') * (1\
    \ / (ll-l))\n        val b = left.reverse.charAt(0)\n        Right(a.toString\
    \ + b)", "        def sum(n: Int, m: Int): Long = {\n            if (n < m) 0l\n\
    \            else\n                n.toLong + m.toLong\n        }\n        val\
    \ l = sum(n, m) + 2 * sum((n + m) / 2, 2 * n)\n        val s = (l / (m+n)) * 10\n\
    \n        if (s > 10) Right(s\"0b$s\")\n        else Left(s\"$s is not a power\
    \ of 2\")", "        if (m >= n) Left(-1l) // n == m\n        else if (n > m)\
    \ Right(-1l) // n < m\n        else if (n == m) Right(n.toInt) \n        else\
    \ { \n            // first determine how many times n has moved across the interval\n\
    \            var count = 0\n            var nNew = 0\n            while (n > m)\
    \ {\n                n -= m // n has moved m times \n                nNew += m\n\
    \                count += 1 \n            }\n            if (count == 0) Right(-1l)\
    \ // n == m\n            else { \n                val m = nNew / count\n     \
    \           Right(n.toInt + m.toBinaryString) // add the m to n\n            }\n\
    \        }", "        // Round n to m by shifting n and m right by floor(log2(m))\n\
    \        // and shifting the bits of m right by ceil(log2(m))\n        val shift\
    \ = math.floor(math.log2(m))\n        val nShifted = n.shiftRight(shift)\n   \
    \     val mShifted = m.shiftRight(math.ceil(math.log2(m)))\n\n        // If n\
    \ is greater than m, return -1\n        if (nShifted > mShifted) {\n         \
    \   return Left(-1)\n        }\n\n        // Compute the sum of the digits in\
    \ m using recursion\n        val sum = recurse(nShifted, mShifted, m, shift)\n\
    \n        // If n is less than m, compute the sum of the digits in n using recursion\n\
    \        if (nShifted < mShifted) {\n            val newSum = recurse(nShifted,\
    \ m, m, shift) \n            val remainder = newSum - sum\n            val result\
    \ = sum + remainder\n            val resultStr = result.toBinaryString\n     \
    \       return Right(math.pow(2,m) - math.pow(2,shift) + resultStr)\n        }\n\
    \n        // If the sum of the digits in m is less than or equal to the\n    \
    \    // sum of the digits in n, then both sums are equal\n        return Right(-1)",
  "        // Your code goes here\n        val result = new mutable.HashSet[Long]\n\
    \        var count = 0\n        var total = 0\n        if(n > m){\n          \
    \  return Left(s\"$n is greater than $m\")\n        }\n        while(n <= m){\n\
    \            total += n\n            count += 1\n            result += n\n   \
    \         n = n + n\n        }\n        val answer = (total/count).roundToInt\n\
    \        if(answer < 0){\n            answer = -1\n        }\n        Right(answer)",
  "       val sum = n + m\n       if (sum > 0) Right(sum.abs.toBinaryString.reverse)\
    \ else Left(s\"Negative values are not allowed.\")", "        var sum : Long =\
    \ 0\n        var count : Long = 1\n        var i : Long = 0\n        var avg :\
    \ Long = 0\n        while (i<n || i<m) {\n            sum += i\n            count\
    \ += 1\n            if (i<n) {\n                i += 1\n            } else if\
    \ (i<m) {\n                i +=1\n            } else {\n                break\n\
    \            }\n        }\n        avg = sum/count\n        if (count>1) {\n \
    \           return Left(Long.toBinaryString(avg))\n        } else {\n        \
    \    return Right(avg)\n        }", "        val sum = 0L\n        var count =\
    \ 0L\n        for (i <- n until m) sum += i\n        val avg = sum / count\n \
    \       val binString = toBinString(avg)\n        if (binString.length > 7) Left(\"\
    -1\")\n        else Right(binString)", "      val count = new mutable.HashMap[Long,\
    \ Long]\n      var sum = 0L\n      var avg :Long = 0L\n      var min = 0L\n  \
    \    var max = 0L\n      var i = 0\n\n      while(i < n && i < m) {\n        if\
    \ (i+1 >= n) {\n          sum = sum + 1\n          count += 1\n          avg =\
    \ sum / count.toDouble\n          i = i + 1\n        }\n        else {\n     \
    \     if (i <= m) {\n            sum = sum + i\n            count += 1\n     \
    \       avg = sum / count.toDouble\n          }\n          else {\n          \
    \  sum = sum + 1\n            count += 1\n            avg = sum / count.toDouble\n\
    \            i = i + 1\n          }\n        }\n        if (i+1 > m) {\n     \
    \     max = i\n        }\n        if (i == m) {\n          min = i\n        }\n\
    \        i += 1\n      }\n      if (n < m) {\n        Left(-1)\n      }\n    \
    \  else {\n        if (min == max) {\n          Right(max.toBinaryString)\n  \
    \      }\n        else {\n          val left = min.toBinaryString\n          val\
    \ right = max.toBinaryString\n          Right(left + right)\n        }\n     \
    \ }", "        require(n > 0, \"n must be positive\")\n        require(m > 0,\
    \ \"m must be positive\")\n        if (n == 0) Right(0) \n        else if (m ==\
    \ 0 || n == m) Right(0)\n        else Right(((n - m) / Math.ceil(n / m)) + m +\
    \ n - (m * Math.ceil(n / m)))", "        // TODO: Fill this in.\n        val n\
    \ = n.toInt\n        val m = m.toInt\n        if (n <= m) {\n            Left(s\"\
    ${n} to $m average is ${n.toBinaryString.reverse.foldLeft(0l){ (a, b) => if (a\
    \ > b) a else b}}.\")\n        } else {\n            Right(-1)\n        }", " \
    \       if(m == 0) {\n            return Right(-1l)\n        }\n        val i\
    \ = 2l\n        val res = 0l\n        for(i <- 2 until m-1) {\n            res\
    \ = (res + n) / i\n            i = i*2l\n        }\n        val rightBin = Right(res.toBinaryString)\
    \ // .toString doesn't work for Long\n        return if(n.compareTo(m) == 0) {\n\
    \            rightBin\n        } else {\n            Left(\"Error in the input\"\
    )\n        }", "        val sum = n.toInt * m\n        val diff = sum - (m * m)\n\
    \        val diff2 = diff - (diff*diff) / 2\n        if (diff2 == 0) {\n     \
    \       Right(diff.toBinary)\n        } else if (diff2 < 0) {\n            Left(s\"\
    ${diff2.toBinary}b\")\n        } else {\n            val diff3 = diff2 - 1\n \
    \           val diff4 = diff3 - (diff3*diff3) / 2\n            val diff5 = diff4\
    \ - (diff4*diff4) / 2\n            val diff6 = diff5 - (diff5*diff5) / 2\n   \
    \         val diff7 = diff6 - (diff6*diff6) / 2\n            val diff8 = diff7\
    \ - (diff7*diff7) / 2\n            val diff9 = diff8 - (diff8*diff8) / 2\n   \
    \         val diff10 = diff9 - (diff9*diff9) / 2\n            val diff11 = diff10\
    \ - (diff10*diff10) / 2\n            val diff12 = diff11 - (diff11*diff11) / 2\n\
    \            val diff13 = diff12 - (diff12*diff12) / 2\n            val diff14\
    \ = diff13 - (diff13*diff13) / 2\n            val diff15 = diff14 - (diff14*diff14)\
    \ / 2\n            val diff16 = diff15 - (diff15*diff15) / 2\n            val\
    \ diff17 = diff16 - (diff16*diff16) / 2\n            val diff18 = diff17 - (diff17*diff17)\
    \ / 2\n            val diff19 = diff18 - (diff18*diff18) / 2\n            val\
    \ diff20 = diff19 - (diff19*diff19) / 2\n            val diff21 = diff20 - (diff20*diff20)\
    \ / 2\n            val diff22 = diff21 - (diff21*diff21) / 2\n            val\
    \ diff23 = diff22 - (diff22*diff22) / 2\n            val diff24 = diff23 - (diff23*diff23)\
    \ / 2\n            val diff25 = diff24 - (diff24*diff24) / 2\n            val\
    \ diff26 = diff25 - (diff25*diff25) / 2\n            val diff27 = diff26 - (diff26*diff26)\
    \ / 2\n            val diff28 = diff27 - (diff27*diff27) / 2\n            val\
    \ diff29 = diff28 - (diff28*diff28) / 2\n            val diff30 = diff29 - (diff29*diff29)\
    \ / 2\n            val diff31 = diff30 - (diff30*diff30) / 2\n            val\
    \ diff32 = diff31 - (diff31*diff31) / 2\n            val diff33 = diff32 - (diff32*diff32)\
    \ / 2\n            val diff34 = ", "        if (n >= m) Left(-1)\n        else\
    \ {\n            val avg = Math.ceil((n - m) / 2) // floor division\n        \
    \    val bin = Integer.toBinaryString(avg)\n            Right(bin)\n        }",
  "        if (n < 0 || m < 0) {\n            return Left(s\"$n or $m can't be negative\"\
    )\n        }\n        if (m > n) {\n            return Right(-1l)\n        }\n\
    \        val binary = n.toBinaryString\n        var sum : Long = 0\n        var\
    \ n : Long = 1\n        while (n <= m) {\n            sum = sum + n\n        \
    \    n = n + 2\n        }\n        sum = sum / 2\n        val result  = scala.math.BigInt(sum.toInt)\n\
    \        result.asBinary", "      if(n > m) {\n        Left(-1l)\n      } else\
    \ {\n        val arr : mutable.ArrayBuilder[Long] = mutable.ArrayBuilder[Long]()\n\
    \        for(i <- n to m) {\n          arr += i\n        }\n        Right(arr.sum.toBinaryString(2))\n\
    \      }", "        val avg = if (n >= m) -1l else n.toLong\n        val binary\
    \ = scala.math.pow(2,avg % 4).toBinaryString\n        Right(binary.padTo(4,\"\
    0\"))", "        val mid = (m + n) / 2\n        val binMid = (mid / 2).toBinaryString\n\
    \        if (binMid.length < 2)\n            Right(mid / 2l).toLong\n        else\n\
    \            Left(\"0b\" + binMid.reverse.drop(binMid.length - 1).reverse)", " \
    \       val sum = scala.math.pow(n, m) / 2\n        val remainder = scala.math.pow(n,\
    \ m) % 2\n        if (remainder == 0) {\n            Left(binary(sum))\n     \
    \   } else {\n            Right(-1)\n        }", "        if (n.toInt < m.toInt)\
    \ return Left(s\"invalid input: n < m\")\n        val avg = n.toDouble/(m.toDouble\
    \ - n.toDouble)\n        val ret = (Math.round(avg).toString + if (avg == 1) \"\
    0\" else \"\") + Long.toString(m)\n        Right(ret)", "        val l = n - m\n\
    \        if (l < 0)\n            Left(s\"$n is greater than $m\")\n        else\n\
    \            Right(math.ceil(l / 2).toLong)", "        var sum : Long = 0\n  \
    \      var counter : Int = 0\n        for(i <- n until m){\n            sum +=\
    \ i\n            counter += 1\n        }\n        val avg = sum / counter\n  \
    \      val s = Long.toString(avg)\n        val b = s.split(\"l\")\n        if(b.length\
    \ == 1 && b(0).toInt == 0)\n            Right(-1)\n        else\n            Left(s\"\
    0b$s\")", "        val avg = (n + m) / 2\n        val bin = BigInt(avg).toBinaryString\n\
    \        val l = bin.indexOf('1')\n        val r = bin.lastIndexOf('1')\n    \
    \    val ans = if (l > r)\n            Right(bin.substring(0, l))\n        else\n\
    \            Left(\"-1l\")", "        val n = n.toInt\n        val m = m.toInt\n\
    \        if(n>m) Right(-1l) else Right(n.toBinaryString+m.toBinaryString)", " \
    \       val sum = 0l\n        val maxM = m % 2\n        val count = new mutable.HashSet[Long]()\n\
    \n        for(i <- n to maxM by -1){\n            sum+= i\n            count.add(i)\n\
    \        }\n\n        if(sum > 0){\n            val rounded = math.round(sum/sum.toDouble).toBinaryString\n\
    \            val sign = if (n>m) 1 else -1\n            if(rounded.length == 1)\
    \ Right(\"0b\"+rounded+\"0\")\n            else if(rounded.length == 2) Right(\"\
    0b\"+rounded)\n            else Left(s\"The sum must be greater than 0 and is\
    \ ${sum}.\")\n        }\n        else Left(s\"The sum must be greater than 0 and\
    \ is ${sum}.\")", "        if (n > m) {\n            Left(-1)\n        } else\
    \ {\n            val n = math.min(m, math.max(0,n))\n            val r = n.toBinaryString\n\
    \            Right(n.toInt*(2l) + r.length*r)\n        }", "        // TODO: Complete\
    \ this function\n        val result = 0\n        var i = (n - 1)\n        var\
    \ j = m\n        while (i > 0) {\n            result += i\n            i -= 1\n\
    \        }\n        while (j > 0) {\n            result += j\n            j -=\
    \ 1\n        }\n        \n        val num = math.round(result.toDouble).toBinaryString\n\
    \        if (num.length == 1) {\n            Right(num)\n        } else {\n  \
    \          Left(num)\n        }", "        if(n < m) {\n            Right(-1)\n\
    \        } else {\n            val sum = n.toLong + m.toLong\n            val\
    \ avg = sum / 2\n            val numBits = math.ceil(math.log2(sum)).toInt\n \
    \           if(numBits < 6) {\n                // Convert to binary\n        \
    \        var bin = \"\"\n                for(i <- 0 until numBits) {\n       \
    \             bin += if(sum & (1l << i) != 0) \"1\" else \"0\"\n             \
    \   }\n                Right(bin)\n            } else {\n                Right(avg.toBinary)\n\
    \            }\n        }", "        if (n >= m) Right(-1l)\n        else {\n\
    \            val m1 = m + 1 // n must be < m\n            val sum = n until m1\
    \ // n through m\n            val binary = sum.toArray.mkString(\"\").reverse.dropRight(1)\
    \ + sum.toArray.mkString(\"\").reverse\n            Right(scala.util.Right(scala.util.Success(math.round(math.pow(2,binary.length\
    \ - 1) * math.pow(10, math.ceil(math.log10(m) - math.floor(math.log10(m))) + math.ceil(math.log10(m)).toLong))))\n\
    \        }", "        val nM : mutable.MutableList[Long] = n to m by -1\n    \
    \    var sum = 0\n        var count = 0\n        nM.foreach{x => sum += x; count\
    \ += 1}\n        if ((count-1)%2 == 0) Left(format(sum/count).padLeft(4, \"0\"\
    )) else if (n>m) Right(-1)\n        else Right(format(sum/count).padLeft(4, \"\
    0\"))", "        if(n > m) {\n            Left(-1)\n        } else {\n       \
    \     val n = n - 1\n            val r = n % 2\n            val k = m + 1 - n\n\
    \            val m1 = m - k\n            val m2 = m + 1 - k\n            val d1\
    \ = m1 - m\n            val d2 = m2 - m\n            val l = Math.min(n, m2)\n\
    \            val d = Math.min(d1, d2)\n            val a = (n * d) / (k + d)\n\
    \            val m = (l - a) / d\n            Right(m)\n        }", "        var\
    \ n1 = n.toInt\n        var m1 = m.toInt\n        if ((n1 > m1) && (n1 < 0)) return\
    \ Left(s\"$n is too large\")\n        if ((m1 > n1) && (m1 < 0)) return Right(-1)\n\
    \        val binary = if (n1 > m1) \"0b\"+(n1-m1).getBinary() else\n         \
    \   if (m1 < n1) \"0b\"+m1.getBinary() else\n            if (m1 < n1) \"0b\"+(n1-m1).getBinary()\
    \ else \"0b\"+(m1-l).getBinary()\n        Right(binary.reverse)", "        if\
    \ (n >= m) {\n            Left(-1)\n        }\n        else {\n            val\
    \ list = Vector.fill(m){ n + i }.takeWhile(_ < m).reverse\n            val sum\
    \ = list.reduceLeft(_ + _)\n            if (sum > m) {\n                Left(-1)\n\
    \            }\n            else if (sum < n) {\n                Right(sum.toBinaryString)\n\
    \            }\n            else {\n                Right(sum.toBinaryString.padToExactLength(m.toBinaryString.length))\n\
    \            }\n        }", "        val sum = (n + m) / 2\n        val result\
    \ = (sum.toString + sum.toInt).dropRight(2)\n        result.length == 2 || Left(s\"\
    $sum did not have an even number\")", "        if(n>m) return Left(s\"$n is greater\
    \ than $m\")\n        var sum : Long = 0L\n        for(i <- n..m) sum += i\n \
    \       val avg = sum / (m+n)\n        val bin = (math.round(avg)).asBinary.toLong\n\
    \        val result = Right(bin.toHexString)\n        if(bin>0) result else Left(s\"\
    $n must be at least $m\")", "        val nn = math.min(n.toInt,m.toInt)\n    \
    \    if(nn.toInt >= nn){\n            Right(nn.toBinary.reverse)\n        }\n\
    \        else{\n            Left(-1)\n        }", "        val leftSide = n.toString\
    \ + m.toString.padLeft((m.toString.length - n.toString.length))\n        val rightSide\
    \ = n.toString.padRight((m.toString.length - n.toString.length)) + m.toString.padLeft((m.toString.length\
    \ - n.toString.length))\n        val binary = rightSide.split(\"\").map(_.asDigit.toInt).sum\
    \ / 2\n        val left = leftSide + binary.toString\n        val right = binary.toString\n\
    \        if (left.length >=  left.toString.length)\n            return Right(left)\n\
    \        else\n            return Left(\"-1\")", "        val avg = n.toDouble/(m.toDouble+1)\n\
    \        if (avg > 1.toDouble) Left(avg.toHexString)\n        else if (avg < 0.toDouble)\
    \ Right(-1)\n        else Right(avg.toBinaryString)", "        if (n > m) {\n\
    \            Left(-1)\n        } else {\n            val sum = n + (m >>> 1)\n\
    \            val avg = sum / 2\n            val bits = toBinary(avg)\n       \
    \     Right(bits.reverse)\n        }", "        val sum = n + m;\n        val\
    \ avg = sum / 2\n        if (sum > 0) {\n            if (n == m)\n           \
    \     return Right(avg)\n            else {\n                val bin = Integer.toBinaryString((avg\
    \ + n | 1l << 48) - avg - n | 1l << 48)\n                val bin2 = bin.substring(bin.length\
    \ - 4)\n                return Right(bin2)\n            }\n        }\n       \
    \ else {\n            return Right(-1)\n        }", "        if(n >= m) Right(-1l)\n\
    \        var sum: Long = n to m by -1\n        val countOfAll = sum.size\n   \
    \     val countOfEvens = sum.filter(x => (x % 2 == 0)).size\n        var evenSum\
    \ = sum.filter(x => x % 2 == 0).sum\n        var oddSum = sum.filter(x => x %\
    \ 2 != 0).sum\n\n        if(countOfAll > countOfEvens) {\n            evenSum\
    \ = evenSum.dropRight(countOfAll)\n        } else {\n            oddSum = oddSum.dropRight(countOfEvens)\n\
    \        }\n        Right((evenSum.toString.reverse.padTo(32, '0') + oddSum.toString.reverse.padTo(32,\
    \ '0')).toLong)", "        val avg: Double = (n.toDouble + m.toDouble)/2\n   \
    \     val bits: Double = (avg.toBinaryString).dropRight(1)\n        // Return\
    \ error if integer overflow\n        if(bits.indexOf(\"1\") < 0)\n           \
    \ Left(\"Overflow error\")\n        else\n            Right(bits.toLong)", " \
    \       if (n == 0l) Right(\"0b0\")\n        if (m == 0l) Right(\"0b0\")\n   \
    \     if (n < m) Left(s\"$n < $m\")\n        if (n == m) Right(s\"$n -> $m\")\n\
    \        val count = (m until (n - 1l)).length\n        if (count == 0l) Right(s\"\
    $n -> $m\")\n        val sum = n until (m - 1l)\n        val total = sum.foldLeft((0l,\
    \ 0l))((sums, x) => sums + x)\n        val average = total / count\n        Right(s\"\
    $n -> ${(scala.math.round(average.doubleToLong * 2l) * 2l).toBinaryString}\")",
  "        val n = math.max(n, m)\n        val m = math.min(m, n)\n        if(n <=\
    \ m){\n            Right(math.round(n + m/2))\n        } else {\n            Left(-1)\n\
    \        }", "        val sum = (n.toDouble + m.toDouble) / 2\n        if (sum\
    \ > 0) Right(sum) else Left(\"Input must be greater than m\")", "        val result\
    \ = new mutable.HashSet[Long]()\n        if(n > m) return Right(-1)\n        for(i\
    \ <- n until m) result += i\n        val avg = result.sum / result.size\n    \
    \    if(avg < 0L) return Right(-1)\n        val ones = BigDecimal(avg).divide(BigDecimal(2l),\
    \ 2, BigDecimal.RoundingMode.HALF_DOWN)\n        Right(ones.toBinaryString)",
  "        var sum = n.toLong + m.toLong\n        var avg = sum / 2\n        if (sum\
    \ > 0) {\n            avg = Math.round(avg)\n            if (avg >= 1) {\n   \
    \             avg /= 2\n                sum += avg\n            } else {\n   \
    \             sum *= 2\n                avg -= avg\n            }\n        }\n\
    \        val binary = sum.toString(2)\n        Right(binary.substring(0, binary.length\
    \ - 1))", "      val n = n.toBinaryString\n      val m = m.toBinaryString\n  \
    \    val nPos = n.length - 1\n      val mPos = m.length - 1\n      val n = n.toCharArray.mkString.toLong\n\
    \      val m = m.toCharArray.mkString.toLong\n      if (n < m) Left(s\"$n is greater\
    \ than $m\")\n      else {\n        var total = 0\n        var i = 0\n       \
    \ var j = 0\n        while (i < nPos && j < mPos) {\n          total = total +\
    \ n(i) + m(j)\n          i = i + 1\n          j = j + 1\n        }\n        if\
    \ (total == 0) Left(s\"$n is greater than $m\")\n        else {\n          val\
    \ bits = BigDecimal(total).divide(BigDecimal(2).pow(mPos)).toInt.toBinaryString\n\
    \          if (bits.size == 0) Right(-1)\n          else {\n            Right(s\"\
    ${bits.reverse}${nPos - i}\".toLong)\n          }\n        }\n      }", "    \
    \    val sum = n.toInt + m.toInt\n        val diff = m - sum\n        if(diff\
    \ < 0) Left(s\"$sum can't be calculated.\")\n        else if(diff == 0) Left(s\"\
    $sum is 0\")\n        else Right(roundToNearest(sum, diff).toBinary)", "     \
    \   if (m > n) {\n            return Left(-1)\n        } else if (m == n) {\n\
    \            return Right(m)\n        } else {\n            // return -1\n   \
    \         val sum = n to m by -1\n            var sum2 = sum.map(i => math.pow(2,\
    \ i)).toArray\n            val len = sum2.length\n            val mask = (1l<<len)-1\n\
    \            var result = 0\n            val nums = 0 until len\n            for(i\
    \ <- 0 until len) {\n                if (sum2(i) & mask > 0) {\n             \
    \       result += (math.pow(2, i) * nums(i))\n                    mask -= math.pow(2,\
    \ i)\n                }\n            }\n            val resultStr = result.toString\n\
    \            resultStr.charAt(0)\n            if (resultStr.charAt(0) == '0')\
    \ Right(result)\n            else Left(resultStr)\n        }", "        var n\
    \ = n\n        var m = m\n        if(n > m) \n            return Left(-1l)\n \
    \       else if(n < m)\n            return Right(m+n)\n        else\n        \
    \    return Right((n+m)/2)", "        val l = n.toInt\n        val r = m.toInt\n\
    \        if(n<m) Left(-1)\n        else Right(l + r).roundToBin.toLong", "   \
    \     val count = n to m by -1\n        val sum = mutable.Map[Long, Long]()\n\
    \        for (i <- 0 until count.length) {\n            val a = count(i)\n   \
    \         val b = count(i + 1)\n            val c = count(i + 2)\n           \
    \ val d = count(i + 3)\n            val e = count(i + 4)\n            val f =\
    \ count(i + 5)\n            val g = count(i + 6)\n            val h = count(i\
    \ + 7)\n            val i = count(i + 8)\n            val j = count(i + 9)\n \
    \           val k = count(i + 10)\n            val l = count(i + 11)\n       \
    \     val m = count(i + 12)\n            val n = count(i + 13)\n            val\
    \ o = count(i + 14)\n            val p = count(i + 15)\n            val q = count(i\
    \ + 16)\n            val r = count(i + 17)\n            val s = count(i + 18)\n\
    \            val t = count(i + 19)\n            val u = count(i + 20)\n      \
    \      val v = count(i + 21)\n            val w = count(i + 22)\n            val\
    \ x = count(i + 23)\n            val y = count(i + 24)\n            val z = count(i\
    \ + 25)\n            val a = count(i + 26)\n            val b = count(i + 27)\n\
    \            val c = count(i + 28)\n            val d = count(i + 29)\n      \
    \      val e = count(i + 30)\n            val f = count(i + 31)\n            val\
    \ g = count(i + 32)\n            val h = count(i + 33)\n            val i = count(i\
    \ + 34)\n            val j = count(i + 35)\n            val k = count(i + 36)\n\
    \            val l = count(i + 37)\n            val m = count(i + 38)\n      \
    \      val n = count(i + 39)\n            val o = count(i + 40)\n            val\
    \ p = count(i + 41)\n            val q = count(i + 42)\n            val r = count(i\
    \ + 43)\n            val s = count(i + 44)\n            val t = count(i + 45)\n\
    \            val u = count(i + 46)\n            val v = count(i + 47)\n      \
    \      val w = count(i + 48)\n            val x = count(i + 49)\n            val\
    \ y = count(i + 50)\n            val z = count(i + 51)\n            val a = count(i\
    \ + 52)\n            val b = count(i + 53)\n            val c = count(i + 54)\n\
    \            val d = count(i + 55)\n            val e = count(i + 56)\n      \
    \      val f = count(i + 57)\n            val g = count(i + 58)\n            val\
    \ h = count(i + 59)\n            val i = count(i + 60)\n            val j = count(i\
    \ + 61)\n            val k = count(i + 62)\n            val l = count(i + 63)\n\
    \            val ", "        if (n == 0 || m == 0) {\n            Left(\"\")\n\
    \        } else if (n == m) {\n            Right(n)\n        } else if (n < m)\
    \ {\n            Left(s\"$n is greater than $m\")\n        } else {\n        \
    \    val leftSum = n + m;\n            val rightSum = n - m;\n            val\
    \ numBits = (leftSum + rightSum).bitLength;\n            val leftBin = leftSum\
    \ >> numBits;\n            val rightBin = rightSum >> numBits;\n            val\
    \ sum = leftBin + rightBin;\n            val rounded = (sum >>> 1) + (sum & 1l);\n\
    \            Right(rounded)\n        }", "        if (n >= m) {\n            return\
    \ Left(-1)\n        }\n        val total = n.toInt\n        val length = m.toInt\n\
    \        if (total + length < 2L * length) {\n            Left(-1)\n        }\
    \ else {\n            val remainder = total % length\n            val quotient\
    \ = total / length\n            val remainderString = if (remainder > 0) s\"$remainder\"\
    \ else \"0\"\n            val quotientString = if (quotient < 2L) s\"$quotient\"\
    \ else \"0\"\n            Right(s\"${(2L << length) - remainderString} $quotientString\"\
    )\n        }", "        var ans : Long = 0\n        var sum : Long = 0\n     \
    \   var n : Long = n.toLong\n        var m : Long = m.toLong\n        var i :\
    \ Long = 1\n\n        while (i <= m && i <= n){\n            sum = sum + i\n \
    \           i = i + 1\n        }\n\n        if (i == n){\n            if (sum\
    \ > m){\n                return Right(-1)\n            }else{\n              \
    \  ans = sum/(n-m)\n                ans = ans.toBinaryString\n               \
    \ return Right(ans)\n            }\n        }else if (i == m){\n            if\
    \ (sum > n){\n                return Right(-1)\n            }else{\n         \
    \       ans = sum/(n-m)\n                ans = ans.toBinaryString\n          \
    \      return Right(ans)\n            }\n        }else{\n            if (sum >\
    \ n){\n                return Right(-1)\n            }else{\n                ans\
    \ = sum/(n-m)\n                ans = ans.toBinaryString\n                return\
    \ Right(ans)\n            }\n        }", "        if (n>m) Left(-1)\n        val\
    \ count = n to m by -1\n        val avg = count.reduceLeft(_+_)/count.size\n \
    \       val binary = avg.toBinaryString\n        if (binary.length == 0)\n   \
    \         Right(avg)\n        else if (binary(binary.length-1)=='1')\n       \
    \     Right(-1)\n        else\n            Left(binary.reverse)", "        if\
    \ (m > n)\n            Right(-1)\n        else {\n            val sum = n to m\
    \ by -1\n            val sum = sum.filter(x => x == x.toBinaryString).sum\n  \
    \          val decimal = new BigDecimal(sum)\n            val decimal2 = decimal.setScale(2,\
    \ BigDecimal.RoundingMode.HALF_UP)\n            val binary = decimal2.toBinaryString\n\
    \            Right(binary)\n        }", "        // Write your solution here\n\
    \        val sum = mutable.ListBuffer[Long]()\n        for (i <- n until m){\n\
    \            sum.append(i)\n        }\n        val average = sum.sum / sum.size\n\
    \        val finalValue = if (average == 0) Right(average) else Left(\"No numbers\
    \ in range\")\n        finalValue", "        if (n == 0 || m == 0) Right(\"\"\
    )\n        else {\n            val n = Math.max(n, m)\n            val s = n.toString.padLeft(m,\
    \ \"0\") + m.toString.padLeft(n, \"0\")\n            Right(s) match {\n      \
    \      case Right(s) => Right(BigInt(s).divide(BigInt(2) * BigInt(m).toLong *\
    \ BigInt(n).toLong).toInt)\n            case Left(err) => Left(err)\n        \
    \    }\n        }", "        val sum = (n.toInt + m.toInt) / 2\n        val binary\
    \ = sum.toString(2)\n        if (binary.length < 6) -1\n        else binary.reverse.tail.foldLeft(0)((acc,\
    \ x) => acc + 2l ^ x)", "        if (n == 0 || m == 0)\n            return Left(\"\
    \")\n        val x = math.max(n, m)\n        val y = math.min(n, m)\n        val\
    \ binary = x.toBinary.padTo(y, \"0\")\n        val binStr = binary.mkString\n\
    \        val binSum = binStr.length\n\n        if (binSum == 0)\n            return\
    \ Right(\"\")\n        val x = binStr.charAt(binSum - 1)\n        if (x != '1')\n\
    \            return Left(binStr)\n        val bin = binStr.substring(binSum -\
    \ 2)\n        val bin1 = bin.charAt(0).toLong\n        val bin2 = bin.charAt(1).toLong\n\
    \        val binSum = bin1 + bin2\n        if (binSum == x)\n            return\
    \ Right(bin)\n        else\n            return Left(binStr)", "        if(m ==\
    \ -1)\n            Left(-1)\n        if(m == 1L)\n            Right(n.toBinaryString)\n\
    \        if(m > n)\n            Left(-1)\n        val result = new mutable.ListBuffer[String]()\n\
    \        var remaining = m\n        while(remaining > 1L) {\n            result.push(remaining.toBinaryString)\n\
    \            remaining -= 1L\n        }\n        result.push(remaining.toBinaryString)\n\
    \        Right(result.mkString)", "        if(n <= m)\n            Right(Long(n))\n\
    \        else {\n            val n = n.toBinaryString\n            val m = m.toBinaryString\n\
    \            val l = m.length - n.length\n            val ans = (1L + n.charAt(0)/2).ceil.pow(2).*(1L+n.charAt(l)/2).ceil\n\
    \            Right(Long(ans))\n        }", "        val bins = mutable.Buffer[String]()\n\
    \        var i = 0\n        while(i < n) {\n            bins += Integer.toBinaryString(i)\n\
    \            i += 1\n        }\n        i -= 1\n        val j = 0\n        while(j\
    \ < m) {\n            bins += Integer.toBinaryString(j)\n            j += 1\n\
    \        }\n        bins.mkString(\"\")", "        if(n>m) Left(s\"n is greater\
    \ than m\")\n        else Right(math.round(n/m)*m.toBinaryString)", "        require(n\
    \ <= m)\n        if(n > m) Left(-1)\n        else {\n            def toBinary(x:\
    \ Long) : String = x match {\n                case 0 => \"0\"\n              \
    \  case x => \"0b\" + toBinary(x / 2)\n            }\n            val nn = toBinary(n)\n\
    \            val mm = toBinary(m)\n            val nmm = nn + mm\n           \
    \ val nmmLen = nm.length\n            val mmLen = mm.length\n            val nnmm\
    \ = nnn.length + mmLen\n            val nnmmLen = nnmm.length\n            val\
    \ maxLen = nmmLen + mmLen\n            val nmmBin = nm.toInt * 2 \n          \
    \  val mmBin = mm.toInt * 2\n            val nnmmBin = nnmm.toInt\n          \
    \  val nmmBinLen = nmmBin.length\n            val mmBinLen = mmbBin.length\n \
    \           val nnmmBinLen = nnmmBin.length\n            val maxLenLen = maxLen\
    \ + nnmmLen\n            val nmmBinLenLen = nmmBinLen.length\n            val\
    \ mmBinLenLen = mmBinLen.length\n            val nnmmBinLenLen = nnmmBinLen.length\n\
    \            val maxLenLenLen = maxLen + nnmmLenLen\n            val nmmBinLenLenLen\
    \ = nmmBinLenLen.length\n            val mmBinLenLenLen = mmBinLenLen.length\n\
    \            val nnmmBinLenLenLen = nnmmBinLenLen.length\n            val nn =\
    \ nm.toLong\n            val m = m.toLong\n            val nn = n.toLong\n   \
    \         val mm = mm.toLong\n            val nmm = nnn.toLong\n            val\
    \ nnmm = nnmm.toLong\n            val nmmLen = nm.length\n            val mmLen\
    \ = mm.length\n            val nnmmLen = nnn.length\n            val maxLenLenLen\
    \ = maxLen + nnmmLenLen\n            val nmmBin = nm.toLong * 2\n            val\
    \ mmBin = mm.toLong * 2\n            val nnmmBin = nnmm.toLong\n            val\
    \ nmmBinLen = nmmBin.length\n            val mmBinLen = mmbBin.length\n      \
    \      val nnmmBinLen = nnmmBin.length\n            val maxLenLenLen = maxLen\
    \ + nnmmLenLen\n            val nmmBinLenLen = nmmBinLen.length\n            val\
    \ mmBinLenLen = mmBinLen.length\n            val nnmmBinLenLen = nnmmBin", " \
    \       var count = 0\n        var sum = 0.0\n        for(i <- n to m) {\n   \
    \         sum += i\n            count += 1\n        }\n        val avg = sum /\
    \ (count - 1)\n        val bin = avg.toString.reverse.charAt(0)\n        val left\
    \ = Math.min(Math.max(n , 0l), Math.max(m, 0l))\n        Left(bin.rightPad + bin.leftPad\
    \ + left.toString)", "        val n = n.toLong;\n        val m = m.toLong;\n \
    \       if (n > m) {\n            Left(s\"$n > $m\")\n        } else {\n     \
    \       val total = math.ceil((n-m)/2).toInt;\n            val remainder = math.ceil((n-m)-total)/2;\n\
    \            Right(total + remainder.toBinary)\n        }", "        val m = math.min(m,\
    \ n)\n        if(n > m) {\n            Right(-1)\n        } else if(m == n) {\n\
    \            Right(m)\n        } else {\n            val m1 = m - math.min(m,\
    \ n)\n            val m2 = m - (n - m)\n            val sum = mutable.ArrayBuffer(n\
    \ + m)\n            val m1 = sum.slice(0, n)\n            val m2 = sum.slice(n,\
    \ sum.length)\n            val m3 = sum.slice(sum.length, 0)\n            val\
    \ m4 = sum.slice(0, sum.length)\n            val sum1 = m1.reduce(_ + _) / m1\n\
    \            val sum2 = m2.reduce(_ + _) / m2\n            val sum3 = m3.reduce(_\
    \ + _) / m3\n            val sum4 = m4.reduce(_ + _) / m4\n            val sum\
    \ = sum1 + sum2 + sum3 + sum4\n            val intSum = sum.toString.toInt\n \
    \           val binSum = math.pow(2,intSum).toBinaryString\n            Right(binSum)\n\
    \        }", "        val result = scala.util.Either.Left(-1)\n        if (n >=\
    \ m) {\n            result\n        }\n        else {\n            val sum = 0L\n\
    \            val i = 0L\n            while (i < n || i < m) {\n              \
    \  if (i < n) sum += i\n                if (i < m) sum += i + 1\n            \
    \    i += 1\n            }\n            result(Long.toBinaryString(sum / 2l))\n\
    \        }", "        val min = math.min(n.toInt, m.toInt)\n        val max =\
    \ math.max(n.toInt, m.toInt)\n        var sum = 0L\n        var count = 0L\n \
    \       var sumOfBits = 0L\n        for (x <- n until max) {\n            sum\
    \ += x\n            count += x != 0L\n            if (count > 1L) {\n        \
    \        sumOfBits += sum.toInt\n                sum = 0L\n                count\
    \ = 0L\n            }\n        }\n        if (sumOfBits == sum) {\n          \
    \  if (sumOfBits.toInt < max) {\n                Right((sum & 1).toString)\n \
    \           } else {\n                Left(-1)\n            }\n        } else\
    \ if (sumOfBits < sum) {\n            Right((sumOfBits & 1).toString)\n      \
    \  } else {\n            Left(-1)\n        }", "      val sum = (n to m).sum\n\
    \      val avg = sum / 2\n      val left = (n to m diff 1).toList\n      val right\
    \ = (m to n diff 1).toList\n      (if (left.isEmpty) Left(s\"$avg\") else Right(avg))\
    \ match {\n        case Right(avg) => Right(math.round(avg))\n        case Left(e)\
    \ => Left(s\"${e.toBinaryString}\") // or e.toBinaryString\n      }", "      \
    \  val diff = m.toLong - n.toLong\n        val result: Long = n.toLong + diff/2;\n\
    \        if(result.mod(2)==0) Right(Long.toBinaryString(result)) else Left(\"\
    -1\");", "        if(n < m){\n            Left(-1)\n        }\n        else if(n\
    \ >= m){\n            Right(-1l)\n        }\n        else{\n            val low\
    \ = n.toInt\n            val high = m.toInt\n            val nums = List[Long]()\n\
    \            var cur = 0l\n            while(high > low){\n                nums\
    \ match {\n                    case Nil => Right(-1l)\n                    case\
    \ head :: tail => {\n                        if(cur <= (high - low) / 2){\n  \
    \                          cur += low\n                            nums = head\
    \ :: tail\n                        }\n                        else if(cur > cur\
    \ * 2){\n                            cur += low\n                            nums\
    \ = head :: tail\n                        }\n                        else{\n \
    \                           Right(-1l)\n                        }\n          \
    \          }\n                }\n            }\n            nums match {\n   \
    \             case head :: tail => {\n                    val numStr = head.asBinary\n\
    \                    val len = numStr.length\n                    Right(len.toInt\
    \ * \"0b\" + numStr)\n                }\n            }\n        }", "        //\
    \ Write your logic here.\n        if (m > n) {\n            return Left(s\"$n\
    \ is greater than $m\")\n        }\n        val one = n.toLong\n        val two\
    \ = m.toLong\n        val sum = one + two\n        val remainder = sum % 2\n \
    \       if (remainder == 0) {\n            return Right(sum.toBinaryString)\n\
    \        }\n        return Left(sum.toBinaryString)", "        // Your code goes\
    \ here\n        val arr = (n to m).toArray\n        val count = (0 until arr.length).scanLeft(0){\
    \ case (x, i) => x + arr.length }\n        val sum = (0 until arr.length).scanLeft(0){\
    \ case (x, i) => x + arr(i) }\n        val avg = sum / count.reduce((a, b) =>\
    \ a + b)\n        val binary = sum.toString + avg.toString\n        if (binary.length\
    \ < m.toString.length) Right(binary.toLong)\n        else if (n >= m) Left(-1)\n\
    \        else Left(binary)", "        if (n <= m) return Right(n)\n        if\
    \ (n < 0) Left(-1)\n        val mid = n + ((m - 1l) / 2l)\n        val leftHalf\
    \ = Math.abs(n - (mid) / 2l)\n        val rightHalf = Math.abs(mid)\n        val\
    \ sum = 0l\n        val average = 0l\n        for (x <- mid..m if x > mid) {\n\
    \            val y = x + (mid-x)\n            sum += y\n        }\n        average\
    \ = Math.round(sum/rightHalf).asInstanceOf[Long]\n        if (leftHalf == rightHalf\
    \ && average == n) Left(n.toBinaryString)\n        else if (leftHalf < rightHalf)\
    \ Left(-1l)\n        else Right(average.toBinaryString)", "        val n = math.max(m,\
    \ n)\n        val l = n - m\n        if (l < 0) Left(s\"$n is greater than $m\"\
    )\n        else Right(math.ceil(l / 2).map(math.pow(2,_)+\"0\").foldLeft(0)(_+_)/2l*2l)",
  "        if(n > m)\n            Left(-1)\n        else\n            Right(n.toString.reverse.takeWhile(\
    \ _.isDigit).reverse.foldLeft(0l) {\n                case (a, b) => a + b.toLong\n\
    \            } / m.toString.reverse.length)", "        require(n >= 0 && m >=\
    \ 0, \"Negative number is not allowed\")\n        if (n >= m) {\n            Left(-1)\n\
    \        }\n        else {\n            Right(scala.math.ceil(n / m).toIntBinary)\n\
    \        }", "        if (n > m) Left(s\"The value of n must be less than or equal\
    \ to m.\")\n        else if (n == m) Right(n)\n        else Left(s\"n must be\
    \ less than m.\")", "        if (n <= m) Right(n)\n        else {\n          \
    \  val rn = Math.round(n/m)*m\n            Right(rn.toBinaryString) \n       \
    \ }", "        require(n.toInt == n && m.toInt == m && n.toLong <= m.toLong)\n\
    \        val arr = new mutable.MutableList[Long]()\n        val arr2 = new mutable.MutableList[Long]()\n\
    \        for (i = n.toLong; i <= m.toLong; i += 1){\n            arr.add(i)\n\
    \        }\n        for (i = m.toLong; i >= n.toLong; i -= 1){\n            arr2.add(i)\n\
    \        }\n        arr.zipWithIndex.foreach {\n            case (l, idx) => arr(idx)\
    \ = l.toString + arr(idx).substring(0,1)\n        }\n        arr2.zipWithIndex.foreach\
    \ {\n            case (l, idx) => arr2(idx) = l.toString + arr2(idx).substring(0,1)\n\
    \        }\n        for (i = arr.size - 1; i >= 0; i -= 1){\n            arr(i)\
    \ match {\n                case c if c.length == 1 => arr2(i) = arr(i).replaceAll(\"\
    0\",\"1\")\n                case _ => arr2(i) = arr(i).replaceAll(\"0\",\"1\"\
    )\n            }\n        }\n        val arr = arr2.toList\n        val res =\
    \ arr.reverse.foldLeft(0)(_+_)/arr.size.toLong\n        if (res > Integer.MAX_VALUE)\
    \ Left(-1)\n        else Right(Integer.toBinaryString(res))", "        if(n.toInt\
    \ == m.toInt) {\n            if(n.toInt < m.toInt) Right(-1)\n            else\
    \ Right(0)\n        } else {\n            val s = n.toInt\n            val e =\
    \ m.toInt\n            val l = ((e - s) / 2 + s).toBinaryString\n            val\
    \ l2 = l.toInt\n            val e = l2 % 2\n            val r = ((l2 + 1) / 2)\n\
    \            val r = r.toBinaryString\n            val r2 = r.toInt\n        \
    \    val r3 = r2 + e\n            val r4 = r3 % 2\n            val l3 = l + r3\n\
    \            val r5 = ((l3 + 2) / 2)\n            val r5 = r5.toBinaryString\n\
    \            val r6 = r5 % 2\n            val l4 = l3 + r5\n            val r7\
    \ = ((l4 + 2) / 2)\n            val r7 = r7.toBinaryString\n            val r8\
    \ = r7 % 2\n            val l5 = l4 + r7\n            val r9 = ((l5 + 2) / 2)\n\
    \            val r9 = r9.toBinaryString\n            val r10 = r9 % 2\n      \
    \      val l6 = l5 + r9\n            val r11 = ((l6 + 2) / 2)\n            val\
    \ r11 = r11.toBinaryString\n            val r12 = r11 % 2\n            val l7\
    \ = l6 + r11\n            val r13 = ((l7 + 2) / 2)\n            val r13 = r13.toBinaryString\n\
    \            val r14 = r13 % 2\n            val l8 = l7 + r13\n            val\
    \ r15 = ((l8 + 2) / 2)\n            val r15 = r15.toBinaryString\n           \
    \ val r16 = r15 % 2\n            val l9 = l8 + r15\n            val r17 = ((l9\
    \ + 2) / 2)\n            val r17 = r17.toBinaryString\n            val r18 = r17\
    \ % 2\n            val l10 = l9 + r17\n            val r19 = ((l10 + 2) / 2)\n\
    \            val r19 = r19.toBinaryString\n            val r20 = r19 % 2\n   \
    \         val l11 = l10 + r19\n            val r21 = ((l11 + 2) / 2)\n       \
    \     val r21 = r21.toBinaryString\n            val r22 = r21 % 2\n          \
    \  val l12 = l11 + r21\n            val r23 = ((l12 + 2) / 2)\n            val\
    \ r23 = r23.toBinaryString\n            val "]
stop_tokens:
- "\n    }\n"
